<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1979f15955664d7234fb482eee890374c7dcc93d72acc637f51414da6db4ee4eb12a6eb8a4987f042c59067bb71c55cb43c3561bbfe7b63bd17de5c543490d90e0b36b243b258607e0e94f8fafcc03f177df6069a5eb4e858bf75ae3183ad04fc3c9e5a3f9ccca049f0ed10a549bc668bc3649957fbeff2e33c270931704678d0db26f0a6443397cf724b034a5ce8fb70b1acb84f97b80f207ae768c7d8e82c66629c9f783d6fc7b6baf00ec26e3e27cbe1aaa9e20c7b3ce14ee544424f982fffa1c50ab108a4ac5920a8b00a4bc88ac34fe72c2a65a2f0dbc0286ae456c3aef5443bd022ffeae5fe317910ab561e434294c487c5f25324b68ac12bb97e2979af377f33c1245c5d51dabb5702f1f67c2d2c43e8b48ffcfb2a85ba9f5bfdee3abe29812bf6a9ffb1d20ec3ed3fe469aec84e488727fe94e87c5913138a63a660c2ac82dd1f680ec9271382fb7b765bdc6c10b0895e34c32cf2016a9169a5bdb851e80e3f0c0415d9f109fcc72e3320a0aa2dededa27997b398cb6d49d32a537f3e5b23878ab7a8d9a432336687740b357780b5253c3c3d62aedc08e14a7e954db984079a53b557ca490a19d73217a04f90aba6a5f7a4cf5cb0d5360b8ec3e05825be639f6bbabc34920c619115ce5b0955526b93e7912de484dc5b8f26b5cf684849b1cdc59cbc87247907b9cd96b7a930226b15de002019c22ef879e94a5e6ce5fdc2bb0294f7ae8588a852dbc0bc7774b7b7c4507fbbcb00fbf7dd4ba4e5f3335d99c34b151d78b819e418dc193bb9cfe0eceba47e159539adf2f37a6176656371e42bdbad18e24b21ad7dfaa0b887cbab673b1c62c48e3df21c2f23dd14eb932bf0480a767edc9b542f6dc59b47cf4477cbd84990c18fcee287149ca3bd80f0329ad8a928d80c689f649cc5124a2c6da016d15cdc3319a8856736bf2b5c12f9d737bfde55c5b3a8453a1b48abe4cd8dc0b5a4623f898db342ab84057d5c25f0ffcf2e16f90a8204c70006a7ed18705588853815c4b0664e2f4489a838a344f8d0fcae3c0cb26a1e0de576b5c9d26b7aa4b4989d16e61d561d655e72bbe6018d4e60062282643fa84db6252ead3a7f33b7a6e4436a18e1c9255389d0639e7e92c6add0e165c5f06b137475dd34fbbb23a5b551ac0bb691414a8bcb623e209f440b2393af853d8a39a7024696f62a9464c34b73722094beb1d209cc3c60e9cff792ac77b0b316ff8740f8cef432601d31f9fbf12f00f2b9f9fe81cc76b49730e90a0392d63b1da076e32d24277f5233cba64855d0b2a2236ef83d143a817d101d1367511b26101508ef4824dc2eed7427c9b337f60a567c8142f44f333b3a3042b3e5b4a18883a963232c7eef5c12a08b192d285c344e91972acc3dda729281922c00931dd2f185a8c9ec3e02b3451f5cd08a1db4a31be52838f18f35924087cd94d69e8407d60a23801b4cfb0cf58c2af0347e5392dc10c1f258438cf91235a705d81b005edd7046535905aeb5aca4cbb90b7fb7d63e642ba7e99dfd7b7923f99d0f18680ecfa5f8339a58a4db7766ccdd395e6f821902555f8735782fff2bb9c9123a592b7c670a603d7ba45b18b4eb7b18d4926b0d951ef7a87a9c00abaef8bc105c66f1ab47c1edee4a11a9655df523cf5452b83c19fdda6d8a4d32784b28052fccb3747a7d38c4c000bcc71deb72a9bdc1bc65e6861bb9bf088dd6314d1e2f037ad1da0a3ae88beca2213bbe955a5112485af7da966b6c4f1e05d578b4eef5ed651c8309e82e4bfbff003603c2471a111bd4caa47514c8c3d1f3cf3dc3c6099627aaea00e24377914d73b86c652d464a2e74ab06b539ffccc2304696732a95d04912a25e442ce62a0571d05837ae4346b72bebb11b23effe5813cd3a0b86d7be788e5276bdf55f9f6e0a6789c64cd448aa9b2494a18381bc904cf3cb8d4782a2f3d22cbfba453e02c843cc4f3f0d76f424b0f10ab46bdb246288f0d53afe02b24807036deffb6770d6d92f0d0e2af616e8a857b38e760b6275fed3651131c71f65c8479f3ba837d97e326b5bdbb8b768114a89b7ee56293da9c7a3c4a896fc0752c9a72b269787ca666cbef970e40c95f844f5ed548e6249d60b7e7ccbdea5888c4ecf1d65777e60a4f26fde1b141afd7c787ce022fc3d1b791d28b9fd6ebdc3937d3ea125c8a8c7f2f2259b4225dbb541ed2a1127e8bdbc3524c1148afa5561a74f41e3f83823bbcd1f47a63ce682d22cb3262fd363a5cee433503b1d8bc9353b0ac3f911ff8fb1637bdfff04efd5274643d25f1081e0c6d3adf3a1b6fe781a6daf008f9a0d3367c15d4a02f6134770d0589f6f80e604d418e4752ef604fa15d7e2494593b32181a9b320b533cf1fba8239122611634f860c08b2442b23bee3274f5e72768a39e9cd49ebdf61da327e2aa12d2968ed331d88e00d374bb32da61f993d51fcdb382b0999f7dd594b9870bc5d773ddd6322a1974b79dbc5c426a5bec75a8f9077876f105a025a3bfba8945406ae19282e8bb3ddc8f09fe24582543ba3d40689741a4b02448ecb385061b0074e7837605c08c9e3e180f5e2b8946b84a891f8601777ffb20cf3ecd09e2581a49373ca021845979e0f014f6b6c726e6ef859c5400ea9a037de86c8127b7de0c06c7c862daa5ecfcacab4773d416d38b967adfe4751feaec70ae54fb23d67d5c1f77c31b38d4f07be2d42ef8a6547e47a731d1c0a77ffec6e3aa7d95383cd0cfe76ef6f31b69f99ee97323f1350906f81d12e0ecc3d71488cbd63b5423f76fefd535d7637d1c2c487456ada977b5306f3e2811ece78fe6abc2ead72c58cebb4f39424472e1250b7698a7c900fa0ba76d7ec3021af590fefb1d6e0010bd26c403b9be5edf6b704fc084b4317c659d00f841da1964b265f15ebbdfaaf17b006f35b6039ec0151a217271170c9c66b1cf5c3bce2de3be99333d4a4994745a0f3b31d676eaf8c94202954ac2f815556135d467d03b9638d0f78d2bf98a798a7e08ce6936d5320c316f4a610ff777c5e98dc659bf03962be4790f43fb42472c03675c9a9f8c08a5032a7cce50c4704868b8ebfa576019ca70a713a900c465cd9d9135d5432f3f16917ed1e87ea2083ecd7a0667a6884fc1da055a93644785ee6fade77096bc70048605ea5e2ce2003a143959c9f4371e44977664ae21b53da4d778508a28acbfeace50858c973d135c50be54f22afc20a94cb87f1d946e7c2c2fe7f17755c14a8ec3e263b8ecec0f27695ff50934680dc840110dda46256a880c0c5756561d1f4a6c1eb76cbc9546ca4f7ae8b28e90567fe70722e94d3e17abb811552ce29e3d71ef9460f95f4dc315388fc2fdf1c28d02c48677c90fa3506a750908da552394c1d0d3f9b6bdd8fd2e198f78b022ccf8cc87d1fd12c0b9472c6f2a9e149f967754efb3978999d4839419f3b3fad77f93c42da3d6ca36834ca9a826b0e91f9e5e24fb80a5eb49fcff63ebf6611ae4ea6a361e853b632e4f00fe2c6a653f4ada9001450ce3805c2406029d6b0f5183f6d28612bd5c11c51bdfe0d6bd567022e33794da104b6dca6f28ff8182e2c8054d023c005c2debb576f67aa78ac407b4357451b24415cdb533647f7b890403fc054bca1d1440ebc4fab36a89d840084dcfdc141155b65b5cbd6cb34e6522757b584c1d1f250e81b85ee472c55928fc94e803ff63528a2d95d73eac5c3ff344ea9171dbb603338b1b294ccda2d9c70d55a356d22d426b1d03d1b17f8035744e925acc50df81e6a2946cbaaee94a2cb44496e8b867dce933b62dc228f9add83d44c47d49d5ff4d4f603ad2dd02842ed0073a0b5a11b1cd944c9e131128068d69565c2bd646209bc25b4ea48bcdd5d021b91ad72c1ff55f1f43485452941dca46fbd931c08f268b539144fee6b488a0cefa436f56770188d6b79f8dfa14396d686b4294135df6d6a3ab65086b37aa7d6fd7b0ec6ea772b6b15517a1dd6737d6b5bfa15298f54d8c038bb9c30ad3ef7d8f8d4c547713c0af95cf514519440058669773a39b4ef5d1d67a128468a8b2f36150008ecab1d3c235ff15ec1a2e4bd64d76f2c7ff5d10362a235e3817bb726decc225aa93b702d607f4311de410bface5dabe61ee78ec8aa4d58158c8d834da5b33ded80ce792c3debc9de3bcfdab7c1f87055dcd0b70687af94222c248be759d1cba90f264b9b6393b39656728fb3200981050dce8e70a5f3c5b26f08cec614acb12fe405e6479615a5e69fdaa421f745f7bd9f8f88a33d0fff8f64dd2ed2980d2a9403b59fb7b3d30ceb017646760d1f8407f84e1295a579286263d8a54a635e621cad607b5c3204a6f53856c379d14576e932d2702d9bf29f74acc650831b004d92bd30fca358419967736f316085e128828c2ef1a40dacb0125d3340e46ec069528a9b6cc96b9996a76a621aa9b3c6f4f29329781db15328c97e515b12188b68f409af93cc29edaaadfc896012c7cd1524d49ff2549c6c6983d88d3eb72a944661e5403988bb7fdeb45e7146665cc50223033899d5d1a3be8ea5b5d0b00fe6ede6d94c80c7c83658e1153a8bdb005f691d381e685098d29b66d83e6e4df0ddad2f9e17666e80cce9c5d58e7f2b36d5854956eb4525ed43155bbbe2108a461c367b1b3a0088653fea29e15afd1b6a1449ffa88d4e77369e87c33e0fb1f85ac78abc159fc365bdace898df60220473f4c2ed7f7830ae380a55a713634323276e4d0a4d787a3346c52671d2d784ea576eb9c560b70648158e87bf453cb9a130cc753420f7a2639dbed76cc3a4f24a399b28a9091ebec042a9d5256ccbf0ae5d29c12b7cc38b7c79fd66b7ce1b4661e172df385e8274d935602bfef354a1ed3a6e62dfe25c56bc3b8c11cc5ca1ccad6512ad46c39fea56759acbd7e4aef469a687994e9110b80a5dd6a405834483579c30993f526194a14ed0ca93a53598732544f710857c4dff5a8fe05051ac09d0db8f0ff3a4778743e94eb16377218300ad3aa35c9a5063b116662a9155d4c608f98dae2ac8342b0bb818459277eaa6d15c015685d294845b68db40c8fd9ce604f7c4abcb6901c5f25f9d86719ec4890373403eb6981d0c5ecbe36d27d42fcc15259e79a71e419cbf4531737fdeccead84d154caead05c2fa4746d34b9ad70e0bb18dbab14aaa935a946e9cd1e44124db56467200d95b409fe04de37fe81acf73c056082f4cc40c5cdcf2bd4add60eb7b3b451fdf72cf48d4a333547c83a907150d550a50694a8ed6ea509faac0ea824872413e27526832dd71b55d6eb7e89edae90b7289b345945a85ab8442bab4b99d8a395c45fd40353e728de6eeded5c41c39c5c693a8f4be0cd9a24c1b698b220e92f2005c9574201bf6ca419e8b6101cd2a11e2ef6711fa715e7a8d9c395e57d03569df828dc8b3ab7ed3a7b2af40b42394cce6836179e7283ca1a584f0919234d431743a6efd65a45cb4b50c4435285aba28e75268db0fde0a01348f8f6b0989dc0a8b95c10a005038145cabef0901a52641e186cb855150c32e006e81b96e54292cd7e7692beb3c3ae7279f98c409b95d4a74d15471ce31fc1e7c0ebc2598f406c3b6d0aa40410db13b8f2f0b0ed1ce74f875e62b8e54d5f5926c509f1167b734566c76673d8eaf395f04e8c51c8720510faf1891e94e6791a5d58676a464edc4efa22588a5acc54cb5302f336d9cadb80b3fd26f597c6c72ce4a383079cf4ed432a27c219d5bda0b9f9f50eb4136f2282c8c43d430208c7c12330f240331942e1e391efa12eac89f3e6b6a23c9cdffa14cb11eb570cdb462c808c30a761af929b159d33cdc82a69e34c4b6cc34becd257347a4560c488f16b9cd19fba29d3129e6e4713f2970009f4f9bef8e3248c86f94322601624358dbbd7c87c89a88abc558b25b25c42ac0c5e09e2ecf8d8cbe709bbd0388acf89819170a913cc622ac4342ccba7db03afcd09b4eb1072cfb9fe534ceb94828695defadc1e3388bfa2b11fe0250e35aa7a336ccfb9ef744b5f4344f3bb9be7d39cdd90f432887a82fda4a527fecf8646f97f0ab39509a291edf825c84d6fdb4b070f5af7f0ca76ce2de0d7d498012fa7342790d5e8999936dd31fdeb81344382e9e05d36c1c7d561bc77f577a23d5777ef1750dc7890429d0b74c1ec7a8b5829c22bffe24b2b4e6dc3220e331550f33a1b34dfa325d15b9aac58c482256c0ba19712c59020f8fa2f3f9e015bbd279f635579673949e110da38ffe6760a1b93ff8e8982f18162209bebaaffb4e3d406c5dccdc489a11d667fd5a21e6a71d96b82f26276ad4a8fe3cb795c3c1fdea4d19c068de0088b0e2c6fcc69275787d3fafcf47b003b4d7c2ea7ce3b80400e69a0bae492d67d9977d8762a5b3a5aa58f1563309e328f7aea7aec82c10015f2eae79e5f16a473eddd9b3c92b2f754ced28c276ff7df58b064985483f1974698d7456a2d7c179abb609193454617fecb75e9a210d4e00918e668defbe76f61f86b1b188edb75fce4abac01c14ba53733c95df5c761b2cfbc88b88d8a17a6064e827c64f7410fbe6943b1b9b6e4012b0fe5f4773a254e924b6df6074f1c88c7c4dd02343115f5f0788efab54587ca0aa77c8afc6dd174ec261d50d30a5801ea8eeaca26bf73934954ea055c313b8656f745865ea4027d0af67360b59a79e97e9421c9b657daa288c87c554f9182be34cec72fa73cf989617eccd3fc35038f5afca1c01b905bea07d89070e3c5d7597343e3958142bf92cc9852a281cbfe4eaf8da0a2cb432d3c1548ef5d34d56999cd3111a3ddb0d5f5d9f477d12f1aec2e6ae6d3c5540a2de38ca706646223a00c45b5f9cca883ae05586c0654fa5c778d3cc805fd2a3c8c23d96e321701d22fc911c05a09f85413f218a9927c1c122304c1b2198af8daa36d30b4e508a0bd6794e16b44589d1b7019ceda955045af0f2cf490eceeabe1a5986c60f0a934d89062dbea6f01616c2a003b70c93512b306bb174c7437843b618599fb09c2ebc50af4153498820d7f002765c22133321e50af3c68ddb9cda6d3d47daad9076ff7992fdf8fe82d638160c3bb98b9fdd7d8e8b3b2c9a863803053e302d4140c0e38d758abbfb1125b824ce16bde24f73c8df79e3a164fa68b3a4f39457226aeb13fb98586e3ba1ed758128105be6a6bdc2dacaee0f0912f511fa87075c5dd02b04c068c793972da2f19c3e89b601034c0e4897227421ec327abe4e72c101659d2cfc531195c4ec539e7dbb2514f0fdad04a9fe43ee72440c0f111da9249b026df91a863b9d7f563041c506f30b139b4bb95b95b1ce0c155f6eeb920cda317bcd30ca5fa28f41e85ebcdb6aa568dbb84e75094b53556844d75a40661572f068280d505f7935451a57d3d9406e34dbbcc19713f833605c06d91c72c4cad433cbceb23d10d775da82550381407774551c09f971f00f349015d399e4dfe8eeb43a930d515125f0637ea7d9070b173ab62aeb75e1649949466e518577b67d5feb02b663f017f1770189664a19f03d48d69aafa8632116883a8e85f391b60c430720faab986b73ec8e000fc584d0cee8d90098e28439abaccd039252ea7616ad404912be71e3d1a7406e6809834a5320cfd0ff3c373757a0f7cae5247e00c10a8d56b3b04662c5871b155090cd4ad9af51b260da1e2a3c23bb0150f992b4eba6792df3f822c0dce65b91c18e1275cce178fb58f2451b799ddc58c10868585d8079c1d3cf2ff7c8535886744011594a2f206b410c18d6613128f8d4cfa18a79656c552ffa4c9f492a1a9c079b9c88cca72f6be85d6655a9903aeac741b5d82604ef1c0db0916fbc40c6c445e7ecaf8a434c649f011c682303e5858b4705c480031cc1c264da4b1ffbe8e73a724b69f7686e270101ac3432b949ce2bd5cae0c860cff3c6793a6de5e0a927db21d53228bdb58ff6f5f5340b54f2b3dded9788f69dda43ad13031afe2ecf32fe9a37b7ac6ef6a7157fe3dd96684d70d516bb004e09fcc4f78230b7e2b70b62096ab4d8010163a212e18eb3952215f9bfebbdbcf0f6991fc96526625f092e44748cbf2132a2bff95108a196a2257c60a64ac2d810ec8f116858b2ed48414a2cb7edc27d2d0bb2f4d2042eb9b0a8fd086d2e835f29bb193e08218253097d4d0656ccf4a4d10db6ffd71bdd2ad3b7e36df3a6ee7224d5f11c6b1fa8ebfdf9e5981c509f4420decd2c9209788bf5dbc03f298d36e3326d5cb60e02ac30a9ed15a68191026321dfef825eec4c6644bcc4745e9a86b3c582bccf8357dfe6c820aee0e67d358916aa4395b6c8d84354da54fd388f31f41d4bc92e4165034d74c6b3c87ae723e50efeea529fb51dc74d0e3e31817a489254e0dc950c2a8e6a6c6eaf0ea783933ed0a2c6badaf6e0ae70385ea4a4b74dfc6be4124573aa538ad1d89d06c34f55d9e9b3089f8071d3cc2b421a3524a43767a2c9226f50bfa5fe8149b46b25de35e164c841a7e6bf32b27aea4267d9fff2821f5aea9301dfeb2e7516b09032303b23239cba9d33a3dcd434e9bd5f132b262cdff50218d64ecad88f01fdcc4e21e5c9fe46324ac9c7ecf66f5ac586fb377e33cb2ef507a60a9c8370420c8243951a0e258f7fb8e6cffc86f7a95855e431c375edee8633d0dd418a816721724d37228e6b9246ddaf71ffd621488018cf66776715951aeb43f489b6859e37eb6f5798a8f08e36aa13044d2565bd4dddb19d4d9bf64b89cc15d224abeb3c02724013ed6d60e198618b601c8d06dfee6cc650a112b8deb55873e1d6412748e6c61d7d4678cd34a44ae56905ca0e900d774ed4aa85dfa11c5fb8cf2aa4374e9950a096ce91331897d2efec5badb1f8d1701695694f016e4ec5763b9bfce9fa24d2a3746609624efa72354888aa47833c7ccf487d3f377f84359dab8bbf9d8dfe5570a1c1d984c23c7d5d1488a64b329b231ff932df77883bcf5df216fe6caec1763ced407732f607b6f5900bf98437bd7385f00814dfdb4536b329e0e8db8df9596e37b0fcd410c738b5fb576eb879048036f62ef70a51d6abf682691341657615bfe63147861a7512c4f5c4bd4f7e8efb13883c70ba34327544f782d735e1d69bb3f66930fe1b0c3742ef36460abb603927cb89c8cc5e6f3dc00b9fd87d98dd5fe913df51be82bea74a271bdaf7c04a8e826e8fa94c92c9e6591fc2fed041bcbec63a25f055e263ef1a895389c905a7283fc6455ac2ea4a2bfd5d5170f10495482eb26c7fc6bb0f63ce7c3b9a201e0601dd8b2862f1642a3fd02a5b578512179f2a7b2ad0479bbb9b29ad4de7db1405b9e50b2d3c69cd7d131e59f86b60630a95d3a6ebc4e34d712b3a44a7d67ae64fbb067bbfa27801d95b44117434e31ec2ea0ac0131a0097ece3763d15213e27443f3ad69ebba6ba8ee19b09c7decd3c46af17c25654cb33738e6593e26cf099bae9c6a88aca12046255f621bc5d8f4ae4dee9a1ce118120fe4d741e88f5dc1bcba29d829b1b2ff7ac4a375fc9fb34e3d1de2dd262492b12ae1896a45d7bdbfaed55a16352779efd02f56634c247c8a3f9e90661f300ce6e4f53dc8843a54df29773f84b6788fea69669a96f569de22b4f8f16e7a8f4dafb65f7a3e81ec5ba1cfe42982b004c7ac71c7312b8cbd1014f9bca2f1473c706c6730f32570269c6b8498d8401852626c34dcf26d7d3198c2ca7f9d086d20b72fd9dfc424aa20d4f63d18f6dfacfa222781a41e086ed8aa86d0811200e1a326b04f832522fc712a6f42d37164e2b8d12f759b5561767a5124e3842f1bb7f4b89da546392c0239a1bc499072ae0ff369262a8e32f3b135cb6446c633ba7e5060d6a4e29ba6c31f1383895daee0a38108c9c9a97e1bc04ceb96352a6f23810951967ba98e8bbff8166ca399d122b350e7688af99c9d341365fb742453c07a5d5f92534a68436598790a187bacc7106e236e07a50f80cdbcf4aed704841fea66fe31abda5ef1daff214399b90a8910631ac815c1761679c94217f54c1cdda094cbde081cc9038fe8a79a9bdda072ac5732d191d2b75e4ea803329b4bc9d1ebbad8c0f5b62f4a0e98843764f29eeaa3f7e2eaaba0c7c9ca1f90454247e9b3bd27f641350d830a9062fe0c12000e1dcf74fdeeae75f3af155b25abb0bc3763f37a77e111fc6704d0d33e37f652c85d60ffa46815349f54f91385e89676b0fb7f58c3df8ef78bbb339d47240df11db254c7093ddec778fe14c0dbb7064233206d755cc8fd9414a7f5b8005c1995133e18fe48e9481a9e0ed158189a71cf7718ce446356ccf276d2bee545381df1c70e8954d816789b6d50fe2e716ce36922a6ec18c002b1750e6581f0aa523a7987428a82d95991f35bd8cbfdd3494f0896b688ded6e5c8952fd175b1801513c3c4405422f5535b52729a09bcb1a6d3a632937ecc82c2a5c34dbfe15b87a7a42f82ad24571e127f9606b0333161dd464dc7c6b3468c8f7c878efc656facc3fc9006ca0fb361271c5374a8842910e7dac40958bc713d77876291bc70c47bfd728b1c36cffe4cdedda9e9f87ad78d614a4bd1af81051a4f53ff7698bb12891441f6fe16837231d4ac8eeac104f2070733d8af778dd86208e59de5a939522f634c95e6a5bf6bfbd62f95b4e7809074b4d77f52eb63177c54b49dd99e264fd135d928f60aaa7caa861ca2963891b0cefdbd0a9dd33771320f877c8eb64aae7683d9bac1d824f6c39d6ccda3ef9e7fd7c7a8609e478e3e6c1ac51c2a16b6d9073bd3e3efb1c9736bfc77192515c6910089623d457b44f13d4a462ff4741318a27c240a4bc2cc7127add75e385d2cece31a13d6534450507648a67ec02f4a2f0b5ecfc0b7c569bed881751ca4ffd69300abf1638eb1d01cd443e50786937fc3ba0e6f65c2ad1ae16a26888743aa7c75e69e8830792574ab3bc549cf0084382f72cfc194e21ba249fcf2e65cee2753516b195e2bfe29fa1a438f42cd84c07dde191ae2e3f0582bb87147868252320a5cf8e3e98dc299c2b4b40e87a2bd55afd13e52619337f89756810aa80a958bdea9140cef2a72d11de042606e3803e45691f0e3ca34b6509a9e38988bca6b3e1fdfbfda6be057cf1eacb94e6ae530f12bb56680e892d18afe1f85ec0f1f173e30054f28e66cb900b6a98c5a3fe43ec157b9f7508585dd2dbee89a010536e4bb6998a90308a9886d6f9138ed51824f91c2e22089b6ab9fa8a52031b89bfda066bd9d122c9a5070e1aa0a82ae76590ed004b8dbf648452796d0460ae2876c0ff5f1f3390ed28724e4de7e197f5d71a2d4d9d50a79302391b93050dd732c8a0d615494f1d608032f7f593a830f861fbd64e4d58642682937d328a4be5936afa19308eb16148a73da1fdd93a7d7e4d105e721ee7d2da840a3cba43caae58d28ed6859ea5d5d6924812f577da5cc7965a9f5785862915701443c796b3454137f5d646264e5e96fec5904e34e9e86e2f7e5c02bda4f2de69a6ae4975c6ea10ad9911df4bb9993f1f520a158350d478682c5ca016c1b84d8e22f62647122c71b467da56f5c92ecb9174ba1d1a67752d47359fca99a9fb72f3d2a7f5f0acd20fed9bc9cd46c7ac15361dbc946e7071a30f960ecdf7e7cf1d03b8f3f638628ebf9fe9bc067697c1e6cf85461eba9679b0a5f4044f90fdf15bc860e9efcd0eeb7db04a7e4100a23b2d3287d847fb578216a5dd23e98be65b8226969fe0dc413ec62b9dec328269028ba8631077af5b58c799e78e3b6549ada721eb27f27e8fc2ae1b1ee044a6a3d9fbbc6fdc5f29f9d6abb853f336602cad1d23cfb77bcf58b9225c27120ab95fba50b32dddf0e56837f1f240a9bf5a1f7b358587439b20f72bdb674b4208f01632f5951d284a863cb4a96b95c032143a82f55b5e51cdb11d9775e3598afe28c27bfda0e690ded26adc5aa0ab643c6299086d0ab97be8e5b10fdb3f01c39630df178dbe4b0d551da09e2141a3d19f027f9e1be645d83c79eca085bd854b365cbee1da6af1077c63b06d9940780dad2e43bca98ccccfce27e52fe37cb5568ce667ebb7c53db43ec1d85baa007ce45ef4d48bec59bb1e3f9e4d34ae2dcc162d4b8226d67101a7c8dc98f8303e64fa966486f2752c692730e161156d4f79aa557f79ddec9991a835f40304484286ad6c5e7ad9bc005458a3f7d7ac4fce1bc8511c49fc36f8db91f620ba2fd57726c64d26088755070c66e828d405e844de25a8204c1c5458e1a2ff1d4704bd26768ebcc0e18e4866b40a72e0d061cff4dc06696f8190462175c6d2b860c628328d9181c6e493442535f54a2bd52c81a7908ae394ba79fc02037efa78594abff615aca3abf6bd6093da70d1d4a600a7565b2e5938dbde3a95d506289517c4e5ae71b84c637eb517075d52a6792ce3244e66e07eca3c11a891f78bdba71c6b9ffd73d3fe10dad3946958fd5283a796ff9cc43aabafb5480bafde2d9e8d366035084b8865490489fa18b68102df252145e96e37ea15eea991092eeecec2e120460bc7b7eb64363d1ca2fcc12921c2ecd28ff9b7b3cfebe881a168dfb3f83a9fd768f8fbe10eb2eb7240790d6770b7e6e6c42671e8e2f941021768a68bca0958a8e9135037393b1c008b94506a1f21c2dd533b317528e49728be702ab51d278bd86c84f42860c4c21a6f41f5f0bb6225e8c1e81dc365276602d634f2df4ee596a9bca04714b7d0672ad7443ef4a6b6ee486f6051633522db9476d3e130c8368902e98f129942ba1ee6d58e03f3618cac0a79054fcd5acbbdbf7aeb2d02961e1996b5e0406ec9e844d3b2c6635b4b81658f746736c60e47c217f6b6afd8444871852c2ab7e8ea9f2115bb9b0ed6810ba6fb7743e91cd8f19da8e31a00247ee42b8f6184abaa9edecf04391b47a20ad09b236efeda87fa279109ab0723ab0010f7fc1474e0e4292b9aa827aff494070bcc432c43dbf3c1c2953a3358a1374fe268329cf07e46eb61433eb52356f61e8d71f24747ab3ec7e9abc8e6ebbbc5da6807df6a36d60f6f090a1c32c686cd5c00b09905cf4454b6b0a99f95ca99fbba8d28f67da908d1669acfa8b72c9096b68ba96e41a04b14aaccad9b8873e788cd13e9af6df9208a1ff24b647c80133a434e4a371211faddaf5d7d4cf962a168c4d485573d447b6d5966197a11a65980efb6ba878079e49f57a18c7837a60ebb28d63c2a706e28eede868e3270259e261e71236970e45c92f09d0fd84f0077453d2600e2ee85827239d2dc2f95d60160bb9302c7bf6a3f6e762943a1816c4fd55344d40a3af66980893dbdec0bf2a44010ed1ae9fc3a587695f77609f7c257dcfc435f2c70e9f9e17a54b617528c62c6cf6a56c15a04b9f9970e4673a4c0e289d6f6ed67826e10975abf603983f1c57f5b8c6b194d9501e87dba00aaf326d80cf842981f9f8a8610a95d87c5f033d77ec3cde6133b960825f0010b238e121f69e3321e895a941962c85b2cfa5b2be7b53f110856b630581cc323ae3b350cc9cfe4b54571c456992dfe2391bd354ae3369205c9ff5a09c9f71d7615f933fcc39623e3f13f4c481bb3dbe620dbb9504cdebeec9b28d83c09af42598fa4def3fd54f24c54462b57f79a89bc9382f9de8f6111eb718a4c2014d3eb76ff2c9bf65fecb3b559dcc1559d754c0fcd6141602ee0b00d2760981454869d6ca1c8d547237986a3d35ab3efe8fe5d2ed2bd2ec0bc99e2f4686fdee93aa54834242c91a81248ddd69f4450f8644ca96c975706b34df45da61892ab1973dc77b42be9ba4f39d35203f029e2cdf36f3848bfab46ae6822cb74ba2caff3cda8b511b5582abd9adc39fda697551273fa6e2a3de610807be8559f831725a1f25ddb9177c5af78520c30c1231e10512828ab77be82d622dacfe8f846628f403c641dd7dcd4edf007e30a4d91daf22206e1ce8c3526a078377ced20970db4c3859c3f915e2cb23f3d2a7dd9c4a3867c796f6317f52c86f0068be8c920796d1904ed8a2e90105e4cf35f5084cd849ae1e4a5a9c264424ecae7b9a110d644e056fc0f890e490dceb96b7869b045631fa1aed0deceefdd7de2fe89a34bbabace764d95a1217221b5fa07a9da1c6a7bdb7ca24e3673c3eccb71f5181b895ee25c644d9020ba5f27f17c1c7ed0029053e9abe5cd3fa71d4d3458e2ae8584c050f4f6a77ecb02e6a08621abeb0f972c5898b8c924f658824494fccdcd79bddf63586fa3a64232067517b8ee1bf60c1ccd69621e838b5e236ce9e26a5956e161ea16c95d07dd22d9d20bd69234d96aa349d4bb5df040a6e128871bf5a773d02b13d6c934bb051393eaec46ed4d0241fdb880e9149d62015556accb1f5f43dfcaf0c80bbf4c59721a68d1058d9dab3d859634ddf32d31eea06e50aac362e6b54447ca3ad0a8106efff660aa19d4f91943773eff7bf08cbb26c14a9211937be886ee1d6550268428a00f2b5869f30603227b38af641d7436fd0f9fff4f26b238b9726f045ea30183ca744a2814dc79ffb5cb6f0df0b9004ac0243de6ae8aa659558d9095b1263e2042abf4149fa9ecd14477dbc516f4f748da5be9d42ee3173c167a5ebea89f7181826253627e2bc455664106e04a731d753addc95a6b172e66105c1d3b323765dafb0a7b97a9a4f7678c5eaa1021a96b3e8016b2c119a0091a64f539cac649d083e8ddbbb1be60a0490ee54cb2f996050f8d029b43d58a34b30664e45d54f311283b4ad5787ee6188be1b44b05b18134faf6236c86fe20411b5efa3a6b5c49e2110de3de33c355d8548105f8bc15d0fd98f3ca3e7ac470916f2b48e27be87b5280895080520437a12d1349ee1f21ef922d486df098b56fa90cffd70913e4496a5945dadfda49d42dccb8903a9051c9def294c5ea8659ae861ea4fb37958886ed0cf8f67159f1a631aaf49c9dd56f8d18d42a3f083afcf683b0cbb9f1d67ef6e7fab85d1b8f471117621d782eb394e3103a8b576ebe90f316b46abf547bc28b95fb097ebfddba9b1094980d31949a15b3678f5729bdf305470814bd81f6f05e6883953241418f0443995d927f301b726c6462968a9470fef325751d3bcec245688e178703e77732bbb5e957767f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
