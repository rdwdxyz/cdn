<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11213266d163c362d2835e8d0f47e7059b1418f7557a76c0b35a052de19a61c960846ac53bcbd71466f46a2b0cca14e92f1e9607e43e68389aa2407cb80a23957eed69958df6a1066601a443f4f2427b43d6dc415e928fcba0545f98a5f2890b2a12d19fe1b1c335e6aa59bb134c9abde436420f0f52fa11d56427351b4ec44f282fa1002f8b432518c26d2ec37cda3d0a22826700dde30408be1659e72a51af7395584077e384e53ead1dcfcadee239b0767c470f9515da824622cca8e9a2794b1b3ce8478eb2576bda1e68330c0429dbffc2150b08acdcef2e4fef45d24c49c996ebc634737e44e64efebd97864f8a15b2f15f0166d591f4a7b977cf43753c13543423099d2925846265b921712c1d61f3f58587f968d58f53b37d0e9104307ad1aa4e7e99c73b5b362d79431e68c16b9312068c52036a2bd4eeff97a4e2f1e4780758e006e0ac5825298b980c784440306b36e9d2b3d18a6cac4737a36d5a022406f3f282810a736cd1426c31c8a1d1fa34b80616e2a5da0c31e8d7261dd62b73eea81b9f5f274e53b07515d57923b6306848448feced971a637d6d43ef85dd27aefec133599ad949d66ba47f06fc1f01f10da51583b8f26b51c66f36978ddeb4f71c6ae22ca3b9291a10492050a291b70ef5666318fe94bc50e825be720124613c7fdc8c9d10396cf7352b8eb4633db55103b6d99e9504cf26c08684b518d67bd77c398e76882ad207f96ae6bdf2e95de0d1fbbe76e2056a90a1c1538ec77b41442edd114113a7d64643e993f540f8a74be374a50bc53bb9afa3d5dcbc11c0787a7951ffcf77f22830bd1525885c7b4fd5a6cbbfa4a6b17fcd436e5f9aaa8da7ead6c3723c3103ead9b11111c6fe8934dd14e7ad04681d6946f283bd5d4700e4f00677fbd890ee0c0939b4471d8735c510b710e188dcbf9c4c21baa2defe57c0cf7adaf2f30bce994a10b2fe5d0a3efa9dc4d3f1fb563e2ef132db2ff5473f65f83c5fb37dad92841eddcc5205d160ff219a396e175551b3cc1189f64ad34d9f87cf09e770d0865bf4edf0dfb198495039220f455bb865bf38d5a869b451914fddc10db18ad6ef8a6ce8622aa7e9ce4da33cee188e64b59ed514f342dab388eeba8817063ca5dde388805f3ccfd2c0f672013d411a9067e9bf801ffb867eaa68c3f36de02126dcf4f4fbab94110ecf7a39528219b3ad8225dfdccccc6d1871e5aac6a66c1e1a05246416489d64734e56b3794b37f0384c922484a073a15edd29764052a4a4b9ea6f1de5cb1246f886129ed333432f3a8b851070eb7ac090f5e50b9557f2f9bd54bd31134cb022f9ae8b48cdea064b86479143b4cfe22380688d66fd589ea820f82e21d46381668964c7e5a7e808ec8faf79d43f96b2d14db076aa8cfe136ec5766c15429372a4d4d80f5824c3545fddc4b0d6935e93fbf1b1cd984b4441321a1ba47e8d3df0774cd9ffb62fc82e32f28b131f4a2f6a575312a68eafcb1ea594dc7370008e292afaede56d160810789569f0beae14ebcd503e00d2af4015daac2996ce9096aa2c97d5cb1c71af8035ab9a8dbd4875fea7cd9380803e8b35863480e79f671b9d5cce9f57cac406ba4ed61dd39a1a273c2c3dd8f4ae8bda9affdd28620c6d31ef4a304ed50eec71388949421a576a35bdff638032119fc1cb27d6fe87e5625ef6546999b416ec47fa2ee154e2b9a39877ccdcaca0b5f643437f12f1b9eb7295ab105c29c086952383a428603478473c1d53eae90757c8021e53bc09277f625fc4741980fa58f18fcde1f24577252d28fc14ec618cb252efa5e4002eff56874d05074bdefa53e7b82a344c7b9b6623be213c4182ad8a7473a80d2778d2370e0b4adf53f6634cf91e28819d709fb9708dd0834e1df1bc2d516be96c751199daf641915e965c7869dc3c00aa3aaa27a68b7db3806735dc32587019d47ac029b0d9264f7ca27fa5b285800bd77c52eecd0332516ac8b212ed9acf5b5d43988430199a2515e19888cce849a04cf4bec5ad85980f49abdfd7f124275582a778caaeef0437d4c7f79c1bfd7d4e1721dd50767c994fc51afffd1d3b164b898960d707f351f22df6af26eb51c5fc4907473449b97ded67a19a7936b1193263fad8b35733d54e255e34ffd6c91983a5dc694153d6ad4eb3a1113d1894f6b75272ff914c364077c1c1cfb6d877b1a2c4954d9c186e03dfc7e713a98aab5fb62487b536b0d03f783cb387b38ee2d596465fe60f084253ae0d2a09821de03189b008deb46ade8c506d8268c5ef483deb5dd50ea1140442988da3383cab10ca8cc4fd64225f732136e25ca93d013a383f450644f58eaa873e0cc8b06a82ed8e8fdfd2488b52bc1b8ac08c2da06a6c6c608b94c6d0f354f5f171367013cce12774d6dbaa00c2e911ef27e4b1aba2f3db994b0e3d0246fecfb9da44b746b2bbc8e0976e6d838c98a8fb631ce2d85cbfcfba1ba7520d03ee1290ef78aee62ac4c93cc68a8d66da4591b70a34013f030d0f5cdae4eb1d2fa0bf7ca14bc056df837a680e1b07980abceed69e0cf60bc2edb9e234b84cc3dd1d58c91c677bc727b8442a69f0c53a878b0f1f494523eef896d28e7ad6c0f1d70311ce3df618af24c896b35073e24a875723c12495831138a7f05f95c1ab7d849f84751646b3b27041a8424691b21bda6bda470501f2e0ada960c86147de5851a3d65fda45095e165769029cb241353a6b8e071790233733766b9beb1083bd7eb4d52d0be20a979eaf1f0dbf65144d16ade416e71a163fbd989e5037297d2d1bc55f0465cd62d7ec182823e6b58d34da28b8980eb28be35e29add1aa4bb0e7aab5f9393f4ee911a984f84c2706792132ae78ca1f76db978f8b16a30fb80b1863e4a34424f132dfacea7d8806906f40101b9b93c1f5c217b14ea93b3471d3318e4e99218676d4a2af3d09d2ff016a7b96d83ee97085fdf6c3129eb22b143f9d47e19dfd5d17e4a898347981c84a0d668c03a1dfe8723add2a189b520b302a60bb6a51fca1a9498bc3ba8685af18de749a284fa94ac9d488ad2ea7b7e3b77f43fab600c944b4c13d26d9771865daa366e888ca64530ee397364d3a20bbc4958e7323c280db680ab6431968f6fa7f2225671f0702ad0c1051ff690c89bee503cdfa963416d8e0750c5b1ebaf55f8164306e9f2d3e714dcbfa419405241394c31601f5775bc3605257ace1d6ad91737770addd4a80efb01d03beb8e148752c0cf8b0e37c56aa9dd23d2cc184f3ee8dbd28d8d34c4cf448fafe891446bf0147f067f6e77d5444f539624a9940fefdb76573b2a9a385bbbe965d62e0f10dbc4cd08ebca0117c17bb9f02f3e7eac5978247cffe1bde28558e7b47fef6dcacd6f918e570be2b844711b78ad84563af7cda0cd17201f5be052e850b3e9fea9469923c9e5d0a21451cb0946c4f25543d6c09c5941e310591e33e9aa4ef0b1436bdfea0102a77d0e72a1e02a2ee01264309252cb265155c931a87396131d8e2ed1887d0288cb6fb5a75934b74efe49e9802292f4a96bb5f47f20624b2ce307bbd0b9c03c59b07e3d32410cf896f9ef1e9ea51a512b48861c3afff3a065a6b08a1a5583a035f4a528555924cdc51a22059a3d464a2846c037fb278c892911ec5774aad3e2a32058f2b39a08000fb04f26702b9201e3a55244604e9ec6673354a39281e41f1c2cff385373fdf693078a40def5428c94a87b8c097e6c93b65d0207b8151a981bd2e645d248bb3ad8041a12771f3d38cbc4d8befabdefb16aeb7b5ac4aea608fb6e8abf6c4fa860a03af89815d5ffa553e096a262847b4db5a1c5e8522d1db46497fc694c4ad0a59d7164e5cac99f684fe236f308383eda7c13cc20927829b2cc12976b92f59b5d4c7634c5919b5783951941856ef7a68776a07e7f27d2122f243391430559abde87144492b2bda2b5ea7b37a0737c6f0dd57781880612edf38be2557b73b87703ed57856968e68727bab4735ef07c848aaf384b089d4a915e97f6fae66d143290c7953ddfe973b8113fce4ca6d2079a946375089c134fddb24bd7aa694b22027484fcf98c6063e1262c138efab74bbca03fc5033b510de6bfca1502bdf602fb65a729081e2ccbaeaecf54ef8e83ca7eba60e7205ec7b8625adcbdf74c1c6dc5a84a0faf7f764011b069b804e1c6489df52cc1e87f0ac5383fab7d8e05001dded2241e892ed78bb78912afb4aa4936a2fe59c6759c1f0d7ab963d0c95be64831f4fa0acaf7521a293e08cd53cc84059492b840c5932e2edbf53e2c678b741b4424019f9c3100e53d6ee177d1d767d8a9ae3d224e3a971ae65cb210cf174a151af88b5d9a77b2fd2cd9887a830e1c7a02be9778645599af841e946392891261ba7d699ad593c26a7bcf86fe15e5be83b161f6e9f99bb7d04839cee9f98749d33315d0d6a52860907ff7159e1a1b4be2b9d1873bc37bcf0837969431bcadf01de776971298702ac2b079af540b945890293c6afbf5d3e27574ed12e71a24bac7a24bc2259b4a13032a4a8359e802b12605905df2e053dce447e6568db9b8a1c1e37741f00e0deda7f433b64109839f6e4874b0a0881f547c32bc11eb7bcb66d012a0136f234211b75bade5c7b8afeb74256f62e21879d07ae9003bbeae2846e9c9bad6673379b88b69119da6287716d4035cd2ad4b933c6f16f93017ccf86326b674a0a3b3d5645d44209ed6ef077266772b4a2d1391b5978a6523f166acfc88189dd0acf6d6eed1bdd849a8e7ff8b597a11a2fc7dac9d47faa5e008ac6bea303442d1ef35b7b8340bb101761e71d02812c0326f5a4d34f9b4c64ed81443bb0d11e28e2f9c482dbf6a28916a0864ff39206fdd899d6516e678359880a5a0dbc71f241a0b84d0e365a5839234d16699ee3393c46eb367e2c2a4c4bd4116f215e533e0fc9bff792f8fddd9f3883f2971c37c939ed14f227c286b70833ea8afb05e54f85c4becc14e4803ae6f6f35eee070f38986daa0ff21677407a01dd1204abac6d9f47ba40200c31262441d0039168bb90a7d6c3bdbd1710825a5fdffad7dd70fc370eee048761b5a5459423344fdd0edcd7b43837996947cd908682eb4e22aadf7212ce62b68e3e54eccc27fbad8297104338c6ebce39522d0b57a39ed8177e0ff1131966d300979a513a92309d4da8bd577bad421c57c6d7f068c306412772f571a6f40dd13fc73bb62e5c633ea1f2854f7eeda3404ee7be32630fa6aa941cdcbf37f70425f693fe57ea9e9edbff5ba4df8a6d3691085afbbaa3dace1a26f37b44aebc2f7dd9403b04fb62826077cac6280dede57348f85283593898441d82abe202bc84c7ea96749b04ce6edb29cca82cd4f51475cd5cacc53697c99974a43bd7335bc661481e70ce8b0c47f1328be66eb0ad22afb5474afeeeaed3e37436dd5aa7b537c79d1ede48a87a7e364db1ff0c6ff374583697403eaa7b172a9f504815a95804b1952624dc14d4a7bd157d63aacdeaad753b940f5392a3530a33d6a149619fa8c2568ba749e0dc4cae13344a7176eb1551a93fa521ae29d55d4e4ba8c5419e9d7196fabc87b31958fbec7633f50a9b53bd5bfdf9df1abb29bbd652c3bfce0700bc8d1260421ee0f3c1fd6f3b2cc2cf6d88c4794c9918a38527dbe102e42007d4259d5fdd26c79701e8507593735dc21c7ed644f41b54169163695af4cf86aa80f130671bb1c01f95ff6c43cf63c0a42939ac44df95f19417b81d19a2091dd9e5d4dbc80db0b5046eba015a388d52b7b558a79aa140a7ed33777ffca6d9120de40d5586cbbc49a92a5849f8e2f328aa61325a9d52c19d1adeb3c998ef4ccc728ad60a3fc76c3f0094057ea24113716f954a8a1693c218cfa5f1becb29d832133659e8a2a4602fc32e490214e3f886c2a900cf1b2fea9815140ade62afdebdefb43fc71ac27fd628cf07bbc82a3c61c23cb0d1a73114dd33936814c9176077558a383488bf4553e4fdfa40affd12339060906bdaedbe8e6997b4555119c0d798ed00304a81bdfa75b244a3fa2266dce032ebdee31baf5fab93ac8e20b46125cae27e26744b163b5cb2c87e4f545398dd9e60f0149e6c0cb7194ce29e3fbf95fcc6bf1d994355c24931bca0ae25872cef712a11235f5e91555db48a2b4b0a303c633f41c65fa4b9cfe9df82370c968a8efc1c4097de0782e1c1d3109100d09c0466f8eb452810002c5fa711a7fbd9a9b6cae9fd9d021566de1377a597f2de3dda70fb020871b05689726ffdf378c6f66d13e249fe4b7b2301b4ee94a7ef141074fdf1b32c4ba4f7bac2982bf244e2ca9d269181f58d76f32d590b929a553326b90c3a3e7546701d410faa721814283fa978a42157226ded176edab6db123f6ef9172bc4b106bebe7896141b256ac6f20433cca1cc999b8a9e426e967f115cfbb6376a6d293ad259171ca2a66e0ce38b6f2714b73321c1385533e9df7a9fb2151b2b2b8d5f3d458600c26bdf36c74add9a4e9a3a9cd48a72344968400333aef2f16280cd4ad34019a08c9aa5b71d17195617e23e90b5351ad46ed0ccd29af3ec9720f1a72834e9b79a28d0119eb1ae74b197d5d03eb177e1a060b59aa071bec7a20b55a6182005d4396af5b6858441bae9c93cbad95112858e0c9e234a679f898617eb380fb8a2c9c91b879352323ac9fb13d81ef7f5e9edd8fc322b4870b988741ec5f8d6ae701890d6ea2d151c2e0975858de204878588017dc8cf88c1a8ab10605ac60aff79084ccf1f1ade5d08e44f2c6498f8437c1c7c737831519d85df6e880a826b773890851222637f8b602e1d612ead86a41f011a3d77e285923d2f4bc632bed6899622724a6fea93ddcf9519dfe952c4940f2b672258e35d8e1a60234294aae4290cb16c6fb14641d691b5245ea583515c0c6843c4ef59bb333e1ef26b20c74f83dd0fad59919b5693a84b4cbfb344d1ce5beb4b6718a2aa9e4df5c026487772409b0ee114e1572232e74f84d74072476a50ecc4842a333231e2b42ec0b7809abcbf421bc293f4ac5965ff88ab58a23022eda295cadedba7433d7aa258779a0ac10ace3f8a614e6f382f05475a44eb94c418d982b7e11da95e7b912ee1934deda0806f1516b169fdebbf6c23849ba93b03c81289de0d3dfe8bb951909efbad0ee7619083b1642abe1b2c9e99ef3220db8e462c7fcbc0ce13ecdbe83f6b269601078742cde7ce01c09e04ce3df220c1f919175fc93670021b59812939cdd745a6de2cb231ee1fa2e1be6c0b003123b114bf70064ca5d3ef9892500ea4cd015c05ac7699c70dfcca971f038bcd2e0bcf9a32a2994e2fb628b05ea06fa82fad1f52584235866de712ba1e7ed66711e693636925bd80966d17db57620562ea7219a49d669f3ff8abc91471873392962e624ceafba5fee18dbd84b0e1930450655e5dc1cdbe2a775aaad45fb4fa5280484636feb4f5ae873c004c833f9b338b7f109bee6949bc53e914251d4ed4bdab955c26a3c344a5f400062ff74942de4a212f6a159e179628c8f1fb0bb6c307945a66bc693785aaffcd80ec04eaca1d987873e4ef4dbc98d7e399759967e8a1a9899005e3aa393969a392f881a51fca19d0985511796aa816431e242a69ddaaf6850ba80e71d56787bed6de0d2eb627b2d8385ec14ecbccb640d7a2c15be8ea5a86b383c5eb217d32b8aa9dea80b6b3535313debe4f4c75573b8b1e1b88b91afecf5cbd50e4a4b7a7757f54b1b46a3f78c0d193194afec144b1e55e43c3d39592abefe03e4cd0becf84715992c5865d4fa16505e27b87cc8cdd89d554b94c88bd1853ce01bcd2981a96d4cdc0a74a9f9821e6205abd72789128b5bb27c8751279f7ae037e982f5792d786cc595e131bffad124c9bc5ac64f16ee33d0c816ee08605ca63945b64451dbbe690488ace30b0ea83866ce19143bb8a0aef36b01f31fb6b33c9bf456ee765d293a70d140da1a9d41b50b67e9047a875497f11b2601d62169e199dec648200d3b9d574ee1bae4f8ca619a28e0732bdbfa94d2523659a138eab5a304991058ea8b2e57ebe3dc7210810bdb4ec7f9604510c34c1fa34682414d3c2dfe433793cc86be44a19ba7d82bc86b583048fcc2749d57896668dbf33a99ce4a6d5b0b23bea3168ad99049f24ccca1b24f5150fa9b396389a5a6e9569c2a5c4d27462ac158fa8a625032d29751daa743f2736e0fe5fd0a15272723e14b0128092e45c431c7f6c2f76bf474fe8f5e436f6ae1a4cba1318a87e94f1c2264cd4925e4edd74d56f0e5eaf539d7c75d809798686e5a8e7baf97b78494df5b0cbadadfe42514c55121bda3299bc51400a176a17e56e7b642e2bb6d392ef3309aa01fb90bc6c1a65e6edf23990a64cc33620c53b1109b746c74a523df03345e83f4b2421e1594684b87b3b13ecb4e99aadcdcc4a95a5e79345f71bc99724efcca4eb4974e1121b3d27ad3f53f27bdc62d2e786cba239e9af7fe2409604424e79e9333c5869ea0b0b675f246d8c033f082076ba5a74926b96c867a081aad0e97a1e187d70adacdd9ae9d143726c7aaf79acfe7353ac98570b7c86cfe24991a1ec38c4a053c7019e5f1e349fd634e40b996097334ecda57db82b48590923f3eac0e60d12d7df22ec746fad1424ee068afbe9d0608c1130902b0d0ba62d64f6fa12d7f893e330cd219e333aec54f2b86617dc8031898e99331b7131903c0150d1bdc56115040a9a7243b967584e47e116045883bc8b603d787eec78a74c60b55b8f2f15410d738d108cd923fcd588dc452720a875aab847de46cda1168ca781f7c62015a554d36c846e7b89a0d528c0e6effc802a7d791ab036901534962e28edcc10d411355c1fdb3751410518cf05920d2e9a415767448f24df026801b53586f0d662f8e77b2037066a2b1f31d60756dfa7cdd42d49e72effbebdc6f61d46062ffe0eefd371971014f342c57ba7df7bde1d83e2ab2217541cb388213c8aad1a698fb2c908317ccf8a6537b48b32e7cdd3680df6ba8519a0ff5b17409ff16bd54425d1b432db2582e53f48ce79f51f5ee24d8d0c2b92b8849a84d892a3a4763811fed1754b433f19ada3c98fb80843d81adb9467877fc2754f005fe15f900e11e8a6812cf8e64573c7c926fe663c2c02a3622a09acefa89478666828990e83ca0ba1a1b5495c4c79f8e466fff6e53414b4758f22a3236738563ec62ad8f919e60a4b0150e1d2072702f172b03d0f20b1bc89a16b087ec721b25ed051f65bc89bce136ff5eb73907e1517f9aa4b3380573c83b951e20c6789ae40b4b499422e096999d3c1f8c5fbf137524b2c869529d0bf171f20b2569179718a26936ed34d13674595e71e971f7de2c1b1afd9c21b8cee54fd6496619ef35dadf3412d2627a379f7b47d6829a37e28471534ac47d0465bcc45c597515536d82d939b509327308a6f0d9fddc66f03022911faaceca062eef7ba7aa7d2819e19f73433923a7bb79a491d6b25d83b88e292fbce60c936812ac7bad5520de214273712b9b6476d0084dee54990f65c87cf590fbd6d7addae1aabcb0fce5b7cc76e99c98e8db68c6a625856ec0afcda98e5096c2520530a919fafdcf2c2a603f8589091815758d9fd29d9933db1fc24ff5b9a9a37bb56940dc6e741d99cef68e1751ce7a29814032b29082cf3344cf976fc95c05309008f5b937ddd3b15655da53e97b8d0088f5df5a668e43154a1749bf8aa639cc762d174eb51ca870baff51507d29a30170fff1559f8f3a4d30d8fcbb4b3cf8fd4190e26c80d480cc3fb8b4471d0fc16317b0ae093658da13d490b437404d5e8d285cbfe80693a48b4c66856864f9d326c6cff8721f7a5f935d7e6201c32a84d4ac2155442afb4685da7780b23eb689e38a12950797903697857a404cdad07ec9f2e34659b66dcd6e9dc161d86e58d6db11027c2d9f0c6158e8571499ee42c6b33e6f797dcd1e0f8e77914e1e0988b941aa4fd5cf87d209bbc0b7247cda5d09c069a2d3e19647933b32157ce051578579754184cd8bd2c80921a0b61b617ea76a588322edba5c4af72fdf91f42ce14a01ee7483bbe6f909ace462010cd43d7b52cd54ebe08d427d779f3c46a179e537c01c0a06f392a55476fb4b843cd07a8b8e699bbe674b6cbb3a5c0dd1dfd106eac724647fa77b998b3bbc8a401704d6ecfc8bbbe4c1bc2a0410aa5108775325274387b3c858338156b389b343cafdb7c64b604d16086c96ce9a59378d90bad3f119741439af001c4d36aab55e6dec87d388bad03dd6f118fbc38296d6ea2ef1a2805461ea2e55154ee24a4dff1b2eb7fbe10b7c5abf6636a42b34ee7e82ddef28b7c19ae0f2bf5d048da84cffa7c3b5f139df09682df2c0bb13232177b54ac9b3372bda9a7d55a15741c170ff7881e3bf1acaa402e276ea9997a19ad8fa2a6d2abc4d44f21def2a5a656eb68db1fbf6ee8b846a2ab651d0506e8806cb973666d6378bd91a858a7fa3f5bdec0d693c1cfb5d386498a4d6e9c792e8d554463dab4664424e7e9e2d831fc488682f266d14e4cbcc1a074891fef728153903a7f2234c2d424ab3a55dca421cf627258ba6199b372f647db1156c1d2d4213aa31fbe985404930213c9e7a2dd018e6c2d09bbf0bccfb2e5bde7c12ca6ad827b49c35d05f159caa2af824a5531ae65224b3d16d839b4f8e3212b492816c112d863cf59ce0e3389394e2720fdadab5e5fc3b31ace7a1f626c8331b5158d36a40d7b333847a85807359b49a9dc6135a2ece16040edb1faec1ade731e550c4879f3d76f6b0056c0d0c70478e59aa6e3fb9cd674a4665a8e512d47ae3c6b9c255c7f70220d284221ce1c1071c4d97cc5d468e048bd4e0e9c9d0e13301fa54bea074ce1f21f5eed6515f2a4e4e7cdfac03f0a1a4375e37ab61018bf65fe8b444beddcbd3a1ac5e95ba255b722dfd9ed99ee3946871edc064133c427fb3d34297661008489c5e159cac7dcc5f9edf2b72e2468ee8a32caf6e63077878e93f122d98004efb6e6bcf4b0adcbf0e4e31d66da0d0819cbbb38c15243b1e863a0bb7532bea6f656c459840613ec3665efd190fef874ccae66ad65c1500c00ce0492452d29acb6193de5720a7ec08c6b0f481b52a94331632750b0aa670ed30f3a398bc07abdcbcca380c6a06a52d87839d76eae60c36fd9a634cb4d9436201a81e033637b1990d23fb64b759cc02a4213b74f526f2be42b66f2a9025377ead54f309588e7b2428b9393645a911dd329481c429120d431ac944ef7b21ca3da62933b2a1b73524315c5b4a14e1425e359b79faa4369e10bc20152ce3a5041f1f10c6525dcd96d0cfb904adb86ec57440739c59eb1576a1106c5edf916706e0bdb72f05e8343ea23d2c427dd31575dde5f848f581b3270212a3151b2405aaf474c1a27d874dd3cd6a2df42c5f78cb4c27941e138720e7ec8ae7e3877466043f9fcf5211da87973afc9e3a087eb58f95fab85cce9db648ad912f55d69aa856c5a47e7d4292bb487dd0bda732cc94052c864c6588cd0837057e33f1cd799763dbff247a6467086c2eb7e5e7d098d67598e9258d7116e9c808a1c0a9176a98f4d334600db60eb3bb85e3903af4fee1bf46ab7c0b176d59aea60f0618cf6270d32ae19a00c3a728bd0d146740a59d21407593166872afdd5a46be17d69c7482999606badc60e97229b48b74d15cdf971511e859ca4e88190542e65aed3197a09c1ae87481726512b4fd7228b93109c339c11d9761cff0733583b4d4c642ee038dae2a3ed3f71d1aa03470db17b650b863126d5d79e2fe37554ffee19d75035d057259d9de48b0213f169817cf23da5ad57b593ad3bcdff46d8233ce1a93c431385f111ecec38309510e3944b60b40ae005e653d50b2996ef93a78f6210e36ca0a32251b846bd2feaf9616b6c5db9638162a4b6f529ae5ab5ea50ea2986a07b96f6416707a5a42e0a852276353eaeff7938aface72b026e234055a12a6f74927590bc8422d7781a2f1a2431adf46571784e5edeaea96db28811858f7bbce4430be04b7446d470eb517c541cef252fac39eb17246891a2e9aa11498e7e6247f3aa81e70920611fca0f1a6db8ebc11736a728aff8a7bee530204163382fedcaf48626f047fbab94824ebb9080c6ef84627d59e08fd4baaa4aeb61e121ddc3f84cf96e05062f310149e7319046cee9d3acc0a8920ea89fcd1df3187f59472f4b2413283fdbbe663ff655ba37835f395ae2659f13f92604d2d7657f6f40ac1f207d4796fb2bfe90d236126f334208d16b764dbe90464b7f542a0746a31967beebacf6a822ad92f26e33eaf1e65d751e9097c1808d71b8519697923f9bf105d6c17529701e38514c2bc0fceb0094f6f211767a890bc0ff123b1197e45b76e06a3ab458e96d958d0b6ae5ed944e04404ed6da852525adb78b2195db2c057c3cc68cc7cd5b3c81c50f892fd56b8de276a0b9a008656636d30a28c67ba9b54dd8708a646e52a7c5d6556a323fab1c5710fb5c9698a52e40c89ad43d63aefa5722f73c363da1fb9c49e2216f6e56858c67c782720e0b4fcdbb243ed06fd80acd08e7134a8f7e3e1062d94ea1a5159801cee02ed3c6ce6da4fc2e3722d91fb5c46503b6526dca2fe6a6446c68739728a6c3085a493fea4b71ab7b36b1fdbf726cc9b42be676342a55d223be3fd70186b631aa17aa60b2b28c83dcb388d3bdef4be6da7cea58d98677bcaa7935479f2f3a0e33f63d4f126c2dafd3d51ba9f4134cec159fc34103ff77db8a2935f9363dbcce45dd0be57fdbc4446f8a0b85032cc40f743098a4bf0097be3987fdfb3b76c5dbcace389c67080224c67bf72f377e727d6811353951e416f6806b68ba493216267d90e878f85651dc8d6ca2c0513527ec9af63c54215e240d71209978af2378401e74afe1a28841e993cb8fbd8ef47d10421c655df7c65513995a863165a9d27640ffc52032b791de5536e55c979e950bfd243a0ff22190ed73ca13ba10f936ca6a8941c220062cc5fb219b2ac6bf6fbe842de16cca06b8902da643e5aab7f072b6501cc1d6da05c08a6193e29cfe9a43604a328d61b6e54d73e6c05fe086545fee08331dcf87c05a6ae7da6254f6541ea407e1aa660b4abc56bee9d941cada909d75c7e92c004a0831015f6bbb04394e4d7cb96e2cb7d7a3e3839bd9b43f0d1e6958adde303d8dda059f73dd5d1873e8f4932124e1d0b2e5cb60b91e0cf0e9d215f94ddd04a2a59bb12c80fbaeeb7ee602461a5f983062c19b9a13d2ea83f3cb59aeb2dff53d1437b6af80cd4deb0adc22b146769111956869ca358a7af1fa2066cf86a24485337b2fdde57aba1e7482fece12ccb710b9db26a691b3c7d8f44388578e1316c5ae8c2ed543951206caf7096cc65afaaa7570b43cf809e38997f75ef9b95e684bf738ac2befa65b6edf4aee888129827cb50ebf5b44453875897b830fdb80d0df4f077da1d4f823eb5f700e9da63cf7ed21e76e789c748032da3a2a3a014fded174284bd997b984b8aeb3a4b1bb2c11515ffba99b97a13492d6be4d709639d5819f6c365135401080617bf459c0551627c96ad94c8aecb18b8037eff2a8230170399dd5c8953732a9d8229afcd941da94e5aaa92dae36b91a15ef3c91f7f1f13ebf520be31a06ff1d032e946b324c17dac06878239468b01cf37197cfeadda8c4e3ab0a54ae42df936ffd81f08e6514568bf133a38302fec206a343d88dd5c4274bb3cd660482e3f5459646930205f8287b71f62fd34ee3d819ae0df2f52fcbbdb75557f7a0e43fc7900846ff1608ab58c8854ab7f802d73e026aae7e1e004755f1aa973f802505b743ab7c1648b5f73e363545f91bdd76195c80f393f30eb9ef59563bac59b71672f463a440f54fbbe8e2473a0577364466c6c7ed9548717998f7e2ed7b7583157b060876d1d4f5d2945f002528ed1c385531ffe9d788059f686f87670c20e16662c11a3d1b6876d9f8abc184d7fbb1f44843d083ad0d7c42e99ab042f95826b774793496d90e743375e95f7cf9a04bd25a5e76c23ab055f51c433c78818ebef2d072bbb72e7ddc0534c89006d81a50821463bff93eb83dbc033e1daa901ac0233a7d47e509ac3b0168a65d1f7a97ffe7b94029b2714fd897e0ed190ac2f7b30021ad669ee8146e79ae617fc065d975a0f756ad4a209ac34ca55491cff75f4c7c97c92b61eb4721e37a180d56f92bbb5e29719b46a9d829d0bf524011025c7a1716c01a068b25c1233f494b17cfa705d4b75fa27a4d5d6f61adac54c165d3296649c1faaaa32f92d188563836e7f4a85f2bbece44885f0d3241ac58a3159b8bc00df12105fbf7eaf61afd7672dd12c185de25eb27078eeae42305a2268997ec948d87c22306412719ae87d8283b99012ee961ae9d10bba6d36d852faeb2dc38817ec290c6662640ca872f100696b763588765fc087d696a66abec60c72c36cbddc36ee477193fe5264eaafa9326b757a73663a8bd23fd008e1ec2cd6c798d1834a2241629cfd80d196423044592d045f1592b517ff374d78c4246c9654c22cc92ff7ca32c326ab7e762522c3b7429300e33f663682c951dc92b0bbf1a4fd0c7398519a44e4b095d61c57c06604c57b07b9a3caa20fd9e5c7141a95ed28663f2bf37072ddbdf7cb823a47e2c156f8b0477afa330a67c591c613b2e3ed2eb03b313c5384aabf11311f71ba15614d4577b3bc660efa5ad40b3cc34e2a8bcc90c9c8902543d19bea6d289a699e261739a94139b8d937623cf4a152733cc77d8ce90005b5852f2e63632a4fc1cafc1b129288b04a1eab724cb6235d61a68bb319df1f6eae0c2779f431e34bf1d8bf869fc3c4d32ce818ed2b54ba6d915630a1b8af569a6e4ed1696002fd8fddffa81db9a1c59af9073813be17ea28c086a4f7a0f1d03608af9493a91508232cb5ca6c6da3265888845cce22ded3aaf9a9ced0d48396167b2989f799f3413f02306fef432930a335aec36fa3384ea050470c58ba76e2d1f580b8746e76f56523916535811f5f71041fe788a65d1edc910c7440366957ee2aeb94a72604869bd6f8992484b10fbee595c357599ba4b69ff06367faff70bb2cf4de7c244dc3683c40c6fb145464879a84329477a87b9b8d963136e5c135b555b6f00748cb79047133f7dfa7570cb0b3ac931def95a029771daf0786c02d48450fcc59f50b7f223ced0253f91d0c12f92f772ee9690623471164c39baf3fe266b1b241e7968f1c3006fc5bce57adc7e2e6d27468e272240a5e28b0d267eecb73f461d472bc11075ce2852bc21717ee922d44fc9e98dcb684ed4c06ae18f8e8953a953a3b6dd26c9ef074f0c6d8a3ffc228e468fe14343c0ca36ed9cd94bcb781d73db1b5eba812d1f8e466164dd23841ce5d06cf46fca61562862b4fba7eaf552972526aa121fab261d15f8028a5b9e2b151bcc3280b295f1826d768f600da3bd6f5494bec57d078b155b2cd0b97bfe222a42e045fa792f907aec70fcb7272cdc5d7ad83b45fd542602d82e4830fb4919de89f6fdc30e54079fa358b19ec3c37482c932013e6b3f6c8d8a701935918131869b6ec93dda4df8830c502ad6e751e7ecc8c85326798c774309281f1752d6a9c68e3a8acdc3c5a20d1d1986d73f7c696392106f1afd20aef3ae9ddfb86af1032a9fd1eae07ee72ebceb015b372331924b9e0a6069b0fd9833cab3af4ea213306f4dba7a0e7b681364fd8b774c053a1022e7ccb751d54ad553e8fabf32547dfa1b24dbecfedeebe6f4c86282ac638afce37b43be387bf83c09d300e108852304c0d90d9a27211981cbd8535582fef02618475d6bea83096a1b0eda30756166e83f1c30d8a35b9016c7e3cbf39f586462667abf8bb102b495436a761283a11d06bcf3a2ae446a7ac0e4007364c922d68c01527b8408fb1e833da34812e3af8c869dfcf708cc2bb77c06de7897b96598d8c176418dfbde13dfa512793378e9798825e75f1bb44920c2ce7332f42284a60b35e63cbf25926032ded184a55a36e0d02c6e46d7b70069508d15d54bda2ba705686bfa36d53f7a9fdcd6859c0c46cbd9748852aaf7e1f96bd2a5c716a2629e7bab428784397b0cd067f918b0d5588ad77c38eafac85b01e75db967aab7e4c8168d5da4eaedc8bdf2eaf8f07ef2940a51658bfaf46ab71fea9990e793783f498f7825bd5e9fd83e74ca34c345172fc0dfc53b454595d57e737e6bb3709eff387bd30eccc417ef1b7b5255bbd3d0455fd5eb9a1dcbba46f8804fe3104b4da23cb9c5a00453ec58fc7bc5b326191fa24e529cfbc531123499cbb26cf1d643e23dad0ea7e5e6a362aee04163f6b3f576a8d5e3a50fe18e43f0095ede4fffe005280abcbe427ab3aea0ae29ec1e7fc4fe88bf28cb8a62360ff9d931ac22f719f9deba2f72d735662d6785243dca1c8666e8e224680912bdfd5ec2506de71d58e2fe213c5b9bf65763fcce5752726a86a79ee92b343b2cbd43a728f56289ec910d76191feab6d13011edd69b79d85d0f0c06747edf527f0ea9bb567b233add51049b18e7e5dba5e6163976c3b9adf4e8a3a752161055967811803902e0374da4abfcbdb504c0c87510a1a971465583e9e292b805a00fd2982d4e1d5782fa7f871e8a29c01ff17674d1d8e3796615d98817447dedae749f1ddeb2a3480fb1f38b596286fee06b9751f59aaf4ac8050114aea1f13870968956c330362583f29c5b988fd6bd9eea0c4cbe8f746000685dc5f05977ce37dee71b61dd631d73707eb804bfb6490e1f7f857b3ec8875a326f00a7983d3c9dffdc4157cb778845fc72d70b3e3eee2a0b917afb7d4c6fcda5d58e1449d9ddd9426dfa4bddf1efc1c98918fb611b631c0ebb3e918dcc06c1e9f7008d03dd10cae4c345ddc260f2eebd0b5371ef28851a881ce19833f7c7e205b762d8cdf86f0e56c6d7ebbd783b1eb091aef61737d45c999d08a7fdc8954006662be3a1ac0728b25d9c88465dc08c1c601e892ec9a6807f954f9b3d70a65ec1f8b5765801287fc06cd13fae8b53badde9a94dab07436dd341cdf7f7ef42d571a6d1e8eec42b9123cc38a7ad64d1862c82dbe3ca0be55bb4e3db2ffdda9777d4afaddae7ce6e1dd179d569e85fcbc7155a8509a6ca90c51b9f51ae922217c1eceace2c6b34132d3f9ac97dcd088bfd9fd310000fcafb06acffc122bb941a65073f04f2a0b5a6053805c5a75bccce0ccf8e4b8fcd2c232337daf694b38ce792741cd6be582979c2b796b5d5781796686198bdf38cde4c9deb19c649f8c05d28ef1f971652fdfd681a8a6664bee7b0d3284f43032aae1cf3f8080fccf505876d9ae190ecc8d25408fe3196a1f2446aeb2ddbcd8ab9c9065e7a72fd1f6e5afb14311fd7e613cbb1b839db2e1ccee52424ee2a0523bbc294da39944c12a158c8b46e32dd89845cfb4d916c7c214a51d77ee17d58736597063f9e95fbd8c5f2e0b6e5cff07da5db3aba737fc89694c8cbadf17303ab5ad920a8254d13ced69236a769974e15bc941302daccadbb03c1a570931a4973ecb480bf340681c1e71a7f3e6bea0a8fe54174b7043c0b99664593da05429e742d0a16f92855991882b0b2bd0236f11ff44e13c4330faaa2759e9b4399362503ed85666ce724a88791f699f6fb16aab4f44c525df56bd7812ee5051238cff24260b83db6be302c70b7c9c709cfc55971b46305c4332485d84b0fd4f48b9981dc07a6e02790f1e7fa7a95efdbf9c39dde6854b478e029d1aaab79badfa55d394c39513e8f64c03ea959b74f57f70e6e0c799a8d52283137804db51fa31e68c86f2b08130d3e8a2b4286d6cdda9d92c32164436f20ea38006276b5b03f533f75fa481dc948b20f66d454c03795219581f668b1b0f2e4d5bb219f56173fec159209ac815e85f9582f0d16df14b1f00ea83925ccca024f6d605649d52b0c95f3ee1af22b77c422d544e4ba6440d0a4d19d725dc3df4dc983fb08d62a71db3c96aedb494a0cf9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
