<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48044fe190b4e057acf5b950ed7ed6083c9f0f381c096ec7936b2330d86ade589d9754a78fc93879a03e04a05827676aef8f797128450c0abe713a1d951c472d327e26d3b19cb0476c290a0e1045795dfacba84314be225087a4de4f7defe515d24edee342ce4d54ec8fdd70bc995b8c44e0c88b6d62a7a56c91d54eee49a74409cbca256d65dc8906869c41847658507428ddcbf27adfd2cfe1770b0b18b8b18d68a65da171b49ede0a9f92eef02e0256f8b3b7aad29d016b55e8b256d0a626c2f0d0aed483424fb530791dd3b3e3fb8499cdd767c3ce958fef1cfa5bc8c9d01bb52d7ea08f2284b966715b4f9f9d3849659c70e427c796c233bde002620d3fea77cea921feb3c09ffbcd3c49ccc7c04d60314d8e6e530f71e70f6a73ea2b1c254261366efe007e3096f4274073d72a4c995ee4406fe88c239a662204a126f39180037145e18709edb23bade953e0696301ef1e3c3a1db259d46b137ae54fa2ad68c1bcca753e8dadf9f9b4194c773246fefabb3defe6779da7fe8d7c66e4cfcaf555ed6bb32e4b13c2b84435896c4df08874d7f879e87c6befab28b9bff64176c94bbd6d88b117bcd37255d868b3fd38d8c02b2001372305848c2f79329546c57da4298e2b78016cb704956f4d9a3eebfa0fd6d3f805b254ddcb7532f6bc0f4f36c1efd227ef4ad998816445a88793d90144f3dd1f37547732ed29e7b9bcdadc5026e323c14431abea6b22cb23f66b732fc602343bd099454b00d9991c5e071603ee2d301df22b60b553deccd15d9404df02223f60d6ddf95481d393b1d53ae5995a4b78810934cf3b3f86ef6f66122bed3aaece0e0c43a16fe230b5335b77c7db1176b63e9826df0dfb6c4733c9c98530cd5c8f690fc558039c8f209510162d653d3fdc65d097bbd7ff61341e46226ae4dc4517ca3895506e99913ffe5b2c9885d209a69d1e95e67300cd7d2f4b0644f9cd84103a83c8cd3cb951a1c33b652c0a91c68324ba90b137e7160e7e5cb0ea35d6166dbc2bd32aa9448f7fe45d9674f7a9e12d25ef5542583b43454364dc388902d4be944eeb92dfbe2a89a58d6a8169998a8f553fbb7ad60bbd727a0179658efba67daa7ade1ef05be9cd0a1251bded9e043404edbbfd629aace586ca4b0f857c02ab1fe86b28b962219e77a126296e6b61e93dff2ba6693eb06a89bc3817e5889a7986a23e16479b5d463ded97bd75034a4f19d4a66d90876f4e4e6114f37ccda6e40effb36905acbf3eb1730e6754768104d173411dff0a2ca6d7175b0f9ab1cc1977eecc6d65b0f6cef7c222119817951562acf5bf313df5f1deb92e202a31ac3dbfeeff0b1da0094563e31014d102af735d66862c4bb90ece2f36fa0cdd2bbb5d916d012a6a952d8d61033c60ba4d54027c6d625fbc07fbf1289ee16b8c19e469e769b136a8ef0d7d11f6aed746b43d96f0ef20101ebaeb91cbffa591dbe1f214e38e1802fd786f1fdb7bb5586266f3abed4e05bcddd95db1b966f61713dc6c2de8054c922bb4977f7816e457d602b4b4e34a3c2041a6bd5e82f5a2fbe05a967cf9ed6839af974e8721b4da2cb30c5fef113dfcc32fa6e1b12f29a77d63fee68c53ebb72a9908c6a9db212e708e115469f9696f2ee43c2363675a6d75199c1be1d23c4638f42ba19e88e647782581d4c7694bbfaa9c805d16945fd1f4a5e2783b4af5f986ab2ea1ac7e1a515ca041f972b2d76609a3d769d9867ae2c00212b3ac3ca5c1d8c075e190065b6fe33073f7c899056348e4599a7a525ca52e216625bf6b951037b130265c746a24abe038db61e547a0711cae08c57bb4d7d4e4a5944086850741787f825a868c3f094f3730782b37f6ee87e4ff21867ac5b55dab26253dd0d4d7ba7b3caa4a5ea68b19d8e968cb5539e50df45d2360a655f1c267b756489186e7f5c18f8c1ab1fac13678fd731ad0b85f5ace7277966c9dd124797d6fc1745598615183f8e8be68cdc6fd059b1f736a5ab8d86af00b6cac895f79f0098e7714bc0a273c09b64f2b98916ec2c6f72cf50f1f770b07cb4780393966e0928e7752d8d6193e3c2e498b17b219185a8cd3d45f089a8c0ccd0d684fd931b16db23e6e0a9894d3cc7b60a8b6230614966e38819ea5c328f9a11f9db1f3e0ac901ff58ced2d8d6834f0962c47f0a89d5b026c9c17ee10e8d4d82581ae6f174d561e668c17212188683b8293ccb96b0dfa9b7811cb178be15f39d3883be8cc1bb14c988ff2c3a71dcb8dfa028ac112f4d23042fcf8e9c71cbf65de647415ac026355d705338dc383bf6f82678356eb0e42338530d3fe5136ff29b64ced63f044a779ba4ab3444877f4a7a43cf29ec4c1f2ace53a725c8e11cb366e80ecc1d5a0689e2d076dc8c422fc229afbbb33ad4d57d3f68eebf55792a608724f825089029662e821bbcb92ff8a1b40d7bf047be2f4db3a777ef5c6bdec259061dd8023034073b323a7189f334b980250cc4c90606e6ff972150bec87c8c0cdb2faebbb955f0a9f8c9133599f04abfe9b32f47daa593d6ac3deca65fad0cdbd932640c904bbd16eba8e8b983228058364ea725d39607f4e909fdf1b87d85a4fef86371a3a714e17918988ee9062e8882a63ee8b6acbf650c34a3c2b5a5ec45f23c7aee49c1a6273b42580c0e9e55c62761865e421096bcaf833f6fc6472f9caae34f6ddea03cbd795f7fad04fbc52b3ee1e0375bdee9d8e64bc9252ad83a1e637810e6ca769c3911283ea7ab4223fbcfe8534bfd6db4d01d1461e66b03f0a446c2a56cc12c9f81623d914d6dbbbe0afc14be52652eb5069b1c57a3faad874b4e521903efcbd8d1ec5476cc9313d6f654ae80786e53058a108c25accead71ed2a6cd3e5137c403a6f655a5d826716cd14555fe73c63a1e25e115da97626e40b5e4bab6f86879c4eeb65c8cb0cef5c8ce74ce2f23f7d5ec0051e684b82abe7b4125a859617eae875ab715ab2e39495ab5e81a803e485c3faf4492bb1148bd85ab14e180433d3a00d3f64f785248bc2848d9b16e182d18ed55662e5390e9128dce3f5ba8e2f85f69550787e9da8450ba3fafeb31d94d5756fe488799fdc5fdd27c416bfeee3114be019a5154f92ee88beaf06c058e27f9c9b39284f75014836d0a112ae0c87e2d4bee5757c852396a7ef25ac86099cd58300be3a7b8f30b551ef88f139b038c93e66bb851847a03320211166163f3c7f43168020f3f1ff40c7d2577462422579f85c2ceefa073d18e25f4568ccbdb17381d5d94192691f22973ac3012eea97130cf2d9950d827cabebda8ef9c8a05cd604339ee9f2e1edf4bd825810e54b18cf9e18b5957838118b96d3c17d19e41f0d81f1174b8318db4245900e2548c046451f4ebe91b7ffce463439650ebafdf8a1775f5f8419941d4ac11fec109ad807d76db7404578af2fcb09bf40da233aec2e9a3f797d26c1214a158cfd42a3ebc03a43c05f46d558acb2da6f58e87cd99f04cc521456605dce63716bb7747ed6bcf54be5c127d52a2cfd9ef67b96fcdb1b0e3c12f1d53374fd93fbf9c5433f74e3bcf8b05567b0063027277d0b1cbe8aff05e01962ea9d555ad5e2a4ab326a76f78097d954aaba7aed034f226dd56a97bffc5661dcb1d3348bc7d97434abfc3c365b888065b4faa3a1084d3924abdf343e403c93801afa93371b4d2c3650d3e11262ebbf0ffcd12963bb493a65d1261f77fb225e5a28629e7da1d80237f4374d6e2894e25f5ce2719e8981c7cb8f097397f7817bb5f8780d9313cd60f834f530368de7b37c09c13d4fcad0a8c9f82228f43b6f282f5334bbd2369f4378dcf1d884643a88670c6d98f98f132ac27832ffaa3bb2bf1b0481abf3b5ff85a61aa0138cca294d0d53ea5938ab395d8e3d1cb9f3ff46de4c774c958154e94a8786425f2633da926bf5455e049bbd2c073f9912c449d5d9982ffe5ff96db364ae2379bc2ee8bcbf6303ec28a878b888392e03d7014f639b23e5db2deedb03fae05e07f8c8eda8f2e8b1c06abcaf988da9b8e475c1c8905f993b8f90a3411d96e4c23244d057c798e329a1cb12fceed916e916a865c8ab4d546aa44753ac4d5b7ad1fcd00c8c33642c3ad6dec8b5f67d71508c915c0f13863c182ecc44c60b3898c9046caf698fdf0de68143c1630ee832961b0e746d2078afd7347378f0d6aa18b5b5f911205ae2d300e97862e68e21c2659a7ce6b24bbfd5e2eae9fe6fb7b568c48a53ae32592c712e0401c57d2ca3ffc8a6d83e8f431145ea0b19af2dd064fddc57d6eeea3792df9ab6403e9cbaa803d56f85f9117bdf0ebb982040570a73b1d18f60f10de25b396f0e592ad9e77e563089eba32d5ebe7cb9ba4a5eb23e7c13806e743b7b70ee3189b85ad5c5d0a362870a480421c77a71cdc0e7c87ac28eccd40f9616262bc9b35fc8439309b6a89180133704128c17b368bcd19bf3481f4bdb860f37595db9776b9a5aa45b875b40ccab282917e95ef267ea86e2c8405963b64088d7aff5a928ec981bee3ad0f608567bba52f4ecb9fc90d6fdd256a96918059532395b3678fb057333f3ca9e59deef3c7ef807dabeaeb49700ac7d133de356003c3205b9db335269721bd14cd8b635a0e66432036963dc0b6d026f14ac58b1651fcef5c836c26d44d49fa2cd44b390a0a87845a9ded7e23dac13f2d86d95a0f0e33cadbfb4f985e1549a4628670518e63ea6ec116363bcf73e2766e16193d97dd8ee40be7683f96a7d92409ea4b17ed30f03105fd22a6192a45d04ffdb2574a3a711c940e6c07a7b70278008912a289705bac7de1ba396e7d051c98a73c165fc9e046855051dd68fb47fd304a89b5cf6e7070fa4b6a74f15766a488d904a6827edfffac0e9a755820760f3247618484d01516537ec5e785c41dc0c14ce4a590d37851b46dd3c2359f832f1ab7727cb1ebb957ffdb6df9b89f72f41bd3a9389580b0cb94f715727f5d28721fd26cd14909fdb043ae0e5ee65a8aea5142f7fc901e845244166f1bafe67c8b950f0c0b6461d8aacf1543626966a92c877dd3d4ab90b479eda0549f06056944b9badf8d53a7b76ce7c2b3ac4907b1abb554964910572aa2d2010a47a35de1d76a786663da0306bd2ac8c8fc5f79b0ae47601e943d6a380b5942c8c0d0f7a6a8c46fc4e98c9ea96878252715633ab790315a2fe7c90b8e1eaa76cc1d954dd397dd1a59d27addf80d61b186a1312db0637d8ed51b15dbd0f84df9187721d30463f8b4ed8b6d0c7bc77bb8388a046477be6c43cedfba3227eff298f444f621e26f2e83c4ea4982dd5485cd532243545d215a7ad55b9bf6ae7487ca2755445fca98b51c16330e271a4cd00b0e9811372399518a1e01761a5742eb23fdb4f858606e39f96f0d873fd503f63cdd7f47443212096fc4bc656a65cbfa5a7c7a7cd14a17f2200fba304fd955b7ea8904cbeb96f8c3e4e63aa738ca7ab05999812df0c38853c120b6213fd31a22008c150042a34658492bf7e8231e66d115efaa8fda64651dd447d91c3c7b91e61154640b0fc228874d874f3feda9d097825b98cd262d0f5fe96c781a01ffb693c01adbd0705fdbbb5c08c2e2cf3676712817c89be5420246becae4d6765e619714b5c9f8be5b61e0bee81799a71efb5bcf4e28b0e4be426de9a9cbdcea17f8c7083194f4edfd1cafa165aae4276bce93f4aa2b3889bb0ce8f4389e612c3fe7fa3bec330a821947d40846a85daa5d7772e2f5525df5c2a49732b22225125c59d0b0d35358c2d749ef6de24575c332b9db09a608762440e327b4b3d62dca09d1206716e49ccfebdf603f9c1d768654ae121182241c40773bd1ee2f67acc0a842cdb37f3ee00ef0e8df5166baa007ce65b3aa6c2bfdc81fb63f5f7b35b42768171479699f45333c5ddb86cca82416a55a500e0e9f2f051f39193d4d723ed2433803e0a71d248387a40204b45753d46e9414dcd0ecdd35b2eedfb783bda219416c1b0807369d1d7f3e5089767fcecc0053fdf9f3b5805474535328b51ad78139ecc79da07ae8fcffc52b12fc087043c1d82f317db2310e4360e5b988de133db265e8b5129844dc3222b431a58dbac6ca0c273c9a244b1eb234ba247f6e114ec55d8842d7b57cb0292fccdec64cbe9bcd1d1806d3af5e33c2d3c1293a7403e867645c78e784968dae38afec94b6edcced61e1fa576544f8df77af5972b1e0a149a366624ce2e6447568ecb4edaf8237dbfe755512b944c60db1d2d62c66ea914febae8e29940cb7951a775031974d43fbb4a321427e664264819918ca1b22f4e01b38dc39a432d10abb4cdacfe0ab9e4174b314dffe64d326cecf14c7fc7631a372b41d360b57a8366122dbfb459a54bd3be1755c5d0cc7d321f29a7e5db596105359f419e587edfbebcacd0f11f82d816c68c288ef052020d9c3e53048121ab1728e700af38d17a16b4b50e3a676a5b31076daf9e24b0425c915846ab310acccdbc06c9d1b5c8394725680155a61d2e701f6adb24058451d76f5b7af1e16a7ffb1a0e409df288aaf278a20a83bc1855707acdd5fa4ea86e9f96e3f8f4e57b93548efd9210cfd402e06aca8e9739dd2d47342dc03d58d231bef629d54283ebdcf72e95d3e4278eff9dfbd1117368e0b05419d8d03c0f0e7de54ff8f118393dd870db3c959775cc8bf3a47f16f7389d0514f9ff6c7334b1564917e3fbb96e470b17b05f65227c73b257b4383b686537b2394fd97d4682bedfe1f828e4e1d635da7b8660c3a6c0aa0671df996cfd1e8cbbce003ba43449825a73985e0e36c6527cef08a532c30c78b00ef19211e8af4aa9df50819c022945e593170f908e40186c29a5aa1ec95f6f145633a8e83e8ecf7f36501eff178ae2f89e0b74f637b4bb17922de7fa2f96061df08c8bcc0edcf488ee151808223990a0c9c40d301c6f6262b8b31ca0cfe5329d2385ff59c3b6035cdd162d3bfcc2cce8ac61380084a07dbb7de0ffc0a650fa1eee1e19f6a0e1e95385d3dba5f7e8201908afb4e9f8cf6fa9f7d9198ecbf017269901b20e71d6a3ff8bdef1de2fd98c26085cdf22984717602a4cd13a7775cae47bda6b1ace096bf05e58096453bfd58718ae6c242787a2fa1d2c2db867ba37e8d75ba81d1f9687a7f1d2d256063db6a963d53a354b6a20dbd722d06ca48cb22feec8fa1f3b62be3fbdebacfc67780f1d6b362bca8fb44a10b02569532bf5fd52a560db7956f5006ca3350e5264fef3de1915866b03819b9107d64a705e5d95e4f4b599ac477a1882ac5992789c8ea18e41b96b15cd657dd50f6fd62c48c86780271e81986810167038825377ff4b550fce33b9e16f79e43c9c48cd7361bf01554697cfd94b946a551e432f1dfd6c1eee8407f690ca84223fc54616b421f2b849f096fb75fcd2f79d94383fe7795c9664bee05bd266b5ef7990026dd3045ba90db8bee3f9b033c8260966b98f94d57ea003a04142ebb80c4a1e7e019c1ff6c52a162505ed6e1fda35aca5d28b220a97eadfe0d5f3706361deafc16c07b535b1e82f9005da94f071f146775d197a8191995bf41df1feec9b595cb08334e790dae4081c43b3f8af250f3f88d5738587c0ac8173725b8dfdcf9c496799c82191e9e1cb011a5ebfe34c55c8fad4e1d5c98612bafd04b886fac393f624498bc43fed0baa21adceb327ea954828bbb8692c3f54d861cb866343710ab0fc1b80f629c11559f08c7b38f8e9655ae8f1e2b8030c24f8c584c2e7b08da2d954677839314dbead6b5d8426d5dd1d4bc28e2ed525bfb2feb30a0cf0cc7698792984e4c99e7d5ea87edf1badcf5d54151dcf98c35c70e0e63872b403cbe0c9466ebbab3263031b74765f2bb3e0de26915970d8f785303ff2f84f270d133528a89e5170c27b66051bbb2402136eb906e2d7749918bf15ea2ee01896bc747e10b07237c4ea6444648de7722c4ea26a46e5dd815896703a6f14ce693d74443e59aeb2e543bd05b878156c7ac3d5967b4196cdc0eb9e7554d79f3b58ac5cd48ee4241b0e05f37eba6849c177a642b9d2ea0633b9023f9227009ac72ed78690e9235a0362dea6b7718d6d09254695a16802a44d7327cfa304ee5f755380483b8b47647974b0235ab07bc533b1fd5eaa3d9b1a7f753b63b4f585281f1dbc5456a0655773755fb1c4d564cf37e20183fbd62fecf34c4408f668d1ec4a1695ae1f6093baf0f29e9e87723c4c2c0da1efc52f8d03bb8ec70f03acecc84d3e6e6388033d5c1073717d823728551a9c2c8c58086425b08245ff85ef26ca3a633ce27ed41346d96c6b98b540ef06bc8f55c6f578de7421995b8f6dafda7f7c8a16d70b4e62511a682f2ee822ae3e5332af25d67d91302ac30f498a276df9a0d2c8f16f98c59697a350ff8be953c20c51e9bec7563065af132f2e3cd62762e191eec66dd62ce3164d2656994ee89222efdb4d4f7e0ad24b4d90422ba39eaaefe3e3bdb59df9dd1e450bd8a29af136efcb308eb37a6e2b827ea3fb3d862936b90003ef88a89260b91b24a9c6ce76cdd1b3c17e8757237955f46202a53fbdf87c39cc7d07a71aaef2af22bc2ab4026b3619c6ee4442b63f8e61175fb1516c4706a371c44bcc691bdbd4042676553c8af48f754990bee8a4300cd5fd6694a40f2bc87b5e8e72ba4f5053f4fe1c25905a85731203f5c7ad79e0f274fa7a9a0d6742ec8723626b0f53c4a5466787a910fa65044b34d2113aecd1fa927375fe800f8208a2a311856b7808a85c9cbfa9e620e1e4f0a9e3c47a8c12476c0e228d4c8b6b9ae07eed83d59fcd2f934a4677589abc53b1ceeeb71c08a7815272e2b67b6463bab41acaa4d2cc8ecef95bc858090fc9802eca866fde7c7d9950993fb382e149e5f8e721b5eda43fbaa45187c96a1406b8d6676ee029740d4e6c506c8e75c39a6ae2e383a2926445fcfbfd2044a2e87154e98d4592779f08c61be7769bbd00d5e50fbcfb007ed145d9679683b216e8fb4396639a593a7c07cd17523a0bcc41b7fb388de17c47de331ea086414dbdf84337c3004853802db0a841f398daca111356aced0a4a76fdd991cdfb4c9ff217a5b11a678dcd2414fe3bbb5fdac3114a2429b811664ee80c9e7fcc53cde2a64ce0a185e13b4ad6b7ebdb4985fc06841fb0b3cf334112dd327a0580043a337a8a55d314d2fa0cc594e207d68f26d0a6daab4d87a0bf707d12d5325bf4d6c0571cd3f8187ce45ef72faaa6b926045ae8aac9e3b7fe2c54836dd91e0eb8d9def8d7e5ea3c55807cd6da77329096c758feb9e0941b566262637448b8f3fb412176417198a0eb4d024efed15803a3f16a242b8d8a726abd2603db0dd77be4d50577a3e6dec20d7d42132568216416f33d9b428678166d981ed4e40e4253b29d5d3a19d26cbbcc37af8de0fbe983aa30b89250f79c64dd46d559d79769f52db4477549495cf9a8c89ee4e2aa87774dd70fb636b485a86d4a9943f8a74c04d8e8b87f852195b2cbac97415519916e6fcaf8e37b42a15807d22ce7a3e92337de41d3d184e6851d1eac155bb58d9c9c18cff3d10cd1d4a6c4fe23a01599f024a1fbe794cd1047a211c2af15fef6695744a756c838ca2702b273259bb1469c0989032c5f6a920bfe030d8098c0433128c57e099404f5ced440a8b6c2f0238ef3f46efe7089b78bc7d0fe10e5810fa34ecaf0247bc609e5e273782aafac8f35373b2e5afc9e281fae4a470dc046d11b4a1bbcf527f5d0cbd5730a58fee10483bfeb77af479f24bc1b5fbbd20524394e4f39a745bcabafe09687d77b4ffd6d5e21c5a2d2ec4c958d70510e1e122db49d19af611cfa73679401d6ad2a6e84ac7ee85f1f18185689e93e0bf981969894be2b3df0afc650fe88aeb7c0a860e27339f2380083514742e3e8583dc22da310cff3e0f16d2abc5eafbd6525b28685d2e8c77ad78fc77b3e73608015aa9f5bd2cde6cade62141654dd5b83a5b9df8289440f546874fd731019d1aa3a7bb93ffff31f665ab6954d7b6b6763b861362fab9053c8e21a488f5664f80e018bf26303a3d76526e0b647be118676cf9470027696b91a3dccfa320aa2f9bf2fbca2b7947cdc384d8a99508e8a74d4672c42ed2ced0e480c202f95d2a66c05cf86e09f12549de2db6c17319089582fd51ccd087425d835697a4646c54a73e07f9c133d4e2ed28f76e57adcf8dae5c6542c0e9a01e397feb99f8d73214bebdef752aeb703ffbff0758a43f9adf31551c8671309065591b0d7149cb9cd95063f2962e6290b93682358e420d0fdf1118ad8aff8bddfa15a718b8c98310c963ecd0fda8868517662c9d440d69e5c7a86962b608d592c1baf3acf5e58b9c20693c13b90628234f0ece3e88a270710b9f6cb3ffc7802019e52c9dd9b20be81b7112cac6e213fd8c80c333a263bc6602815ed9ea6849941798e46198d0caab2e50a94fbd672d1393d38cd69975b1587d9ae5996423e01df3c062d9660c7f57e6368e385735a7b2948656a2e09c03ff940f80e92d7e4b443e83cd8f92f29415cfea87946eba632710af8c07dac841a3e03d08921bc5f256043255699bb6c2f77c8708a124fd36a58d1d09fd83830f06926b581e8521698ad9c0db1e4d2196b8e5cea3c4c1afb3baf5ecd95b9198cdc620e0407fddf3632cc05d1bfe4f3a839181d37e089109b26d309d394abbd9c3d6954ff4376a8a41cdc25d2f9202c325cce204dc90ec61f04daa0e29f1f6b50db6fe81e6492dce8ecd1960b377862ebdab625c5cd20e446ceb5eb8bf0e01afec57af9a1c7362b58884f001e127a2bf13cd300f39a04041b921485f1a2f8cc35c456bbea09c715baec7494613936870694cc22bf79d67a809f96f2da5170fbfc84136138ba597cf6d0c3ce8a3c343fc08e28260750decd8c167f96411f9582dc5fdd529488b99718285840b3bab6a6e341e454f1e4342ddf05e7444327999eac37ef0bd53831e9323081ba06b40c4ef352a93bc83147e659fafca0e47336ac59a5802f3e4aa16d38f7a4a486c95c64e70707de94de5a1f1dc31d24ce1f16ad4f57cfc91c550014c940181e95d925ff4c29b06919f369b48eb70c838b372dc6f1e23102749916c82ce45aaf0be18806588bdcf69fae8686ba3f98d9658f64ef8525bb09e597a565eb5ceedbea810c0316d7495f4349341558ba818869bb748c05cb8974d159dd044d3655af36281360569f05c6b8c8e985dd804d48329d46329d4573c178abc177ed7615292d836faf46aa15b5b4da4b76b65c3007acf5230dd9cc855f3cf1d9571bd890fbf3528a0a6a2bdbcef6753ac12c32add0591e06e5b34f6f3ccbe2a45a62080a6fe39fdb83ebb57db1b05357f8c927dada551b18c9ec18aeab864688f5ee1f9229fd1477abc94f8a2b43153f956b78f7000c97b0e6581fba5c1357ff0b5017a3eea1063e65111a256cead3640ac30bcca39313e1b9f4ef69bc14582a8abef9b4915452d9bd2b25c2a159159172e4f1b5e223607e1f238fb85f085e7e3df3fd166bbd1cb10949c81dc1e467cfbba17da5043c5a7829f4f5e70580265e3db0189a67b5d291e6976307e2798c97afd5ed74943160d7b3dba0fe9210a82ab056f96ee3ffebae0140295fcd2676025ffec4f96ed94e3dadc112d23eef89d69dc8af8f4114d406a980c0bd5adb9ac5a429d270e8ea3be5fc39fa258bc1238166fbd991d51899ba0361039230d8d494c488db4781d0669497ebf6a472417dd01d5e02548c95440aa69d2cee2293bf30e5768fe9a4943d20d480668c285ddf1ddd81c37d9984cfcb0f7f2be0b17b518eeb3a7cc3fca684b45e217fb29fdaaba60ca9be08de3dbf8fcc647035f23a7052ae6f3d4438b9d508f5b3bdcb519a48ad0a5fe21be0ac00a811464441b21dae1275eb0bc4ac3e85d428ed6db40c084008cde3ce6074fe0caff0688cfdd2f6b95d5365364a6dd2e3e4e0d4988eb84638d323313b975aee8ad598b44528af056162d6cbff3f74edd3c6cfd4a6f536395f3a139bf54649f654f1858ea8b9554695d7b39d88d169aa52415bab9738bf8044aa6240aca6fd1fa295b528dfbc1cb20ac8eb3258668ee0a7ed85c5ba930f8ee1ef9c5cb6a57376253379113d7529a7d50425dca83ac14ccef5ad38ba80d60a63a1d61d9dcc256b8997c8c96e02f6248750af9cbebc348a8481433b6b3263369dd99f1d0d8f9642131bb7813faf35e00efb3dee2d09507930839bdd5dc6951c5e16744d5fc1be824cb363465c25068c18493630bca85e3d77fd46c5e1660386d28bf0c48ee87b95799b133ccb36f2ef0d21bf43ceae3a97c7955cdd3b8ca0c1e60a7f7da1509a70d6d698a90aedb89bb8445d1756747697d1365650b7377e2de4857a1799459322a58399602e7373e83d9648c0871574937d6780707595b94bd831a07bdd8f3b7366a3fbc172614bfd4ea433848d6181d7b83f25f96be89e37fb29797b534f96e3718d6c1a878bd29734d40f8b2c294410433ec33154ebdb4b7291a9b149f08410895a2d24000a77fecf29931198c41ec8938c98d36548cd31910972ec7fa4f3fabad36c7466bae0f2ccdd194b56e1f519ea58a0f7406643300d172074b881985b875e06d0f6d9469efd4ed2701bf062a07122b6b8874408f64a612eadf69a6b3df31a311559c6de8b67f31a1b2e61dc5750483e7711ac5650315acea6666bf8e7a033d8552604e3a920b07275ea4955c7b729757b0fd59f6271f5ee295948f7d5a1d8c3119c2bd84d7cbe6962b1f5fa9e58710036c18f80e6524d55b47d2cb12360b569d34c390bc3c2689d4ef34cad00a7def4c54fa4fb68553b1d5c5038ab191f25ab3e710a9224476bd4dfe50b22e1032c9ac50818d55dc0b9404a5201f0e6d883eb5616791282cdc7d36f9ab457db2ce527e5296bde70d7f573921035f58399e4c28c4dab8cffcd06b6e4a92887a0f0aca6bf96bb2c4b9c49d40f1d5087b909e04433d9d29151a2987e8690b645b9a4ab4ff713880673f3ac70ff490b5615c1a857c65d275213acfb52c2d47a120eaed9fed387832e3e2e24653bf03052005cde156a398a1380a367002fcb0f6a9bfcf4664fba2d1939d7a0900c9af5dd0f9dca4ff3aefc244a76ec3857477358b41fb720a9b32563363623a2d1c2624e8740b8d2290f7f17861eda57c155fb70dbde491f872b7a288ce1c170e32e5810306729f21afc3e6912736c52a5190d07a622145d528e1ebabb551477f9e1ee7f1a794b09f07b50189a3c7bdd26fe292f36309d0c28bbf3bc6db751b4d610d316f57b87e2bec456f1910a848dd429dbd22cc7ae10ed0871b2b1f867eb24b7df71d5a4696c7f74f2108b76d57e50ba9feb4dcc87ee5fcdf67d2220ccd5235b3130f827be6e4588a495936ad11b4256f802af486d7198603d03e86b2f185d5317d13da192d4eba6b738de6a4c8e50647e6e1117f0c1633e63bb4487a970b0955a7bb0198d4212329d9f751973a8f8ecdf34ccffcb1d15a48390237a70213c3e693293b46674d91be60330c39485514a387660280621d652f25c286f85af898c16c315d7f3e566a437418b87fe86bd0c4a0ba119b28ff6981fffc30e0c81a37ab2fe9b336a180b43a98375e5f993684cfd537e3363bd808a374a0783c2cdbb0d8816257ddd611239ad7a3386a9d619e419b8001c3e61d4062d067d00385253cfffd62fb78614c562741d36424f5af61fa49527b4ffcd282d9a4fd20fde0e286570ae42a702c3df2ee7681dcda5b8c7b968d57750f436c11b87392046ce25a3e3497536289de59db54849170ae279540f767d48bd308e4aa4259098abd607bfd49c27aec045ed24fa44b842a62ce20eea09c88854e460ab3eb6a8f6a22b4cb16a72b113844e2b17e1d75f05c779a9023227950ccb31e881133d3a562a11485d062f2422e6b71767cd6d4a5ec5a84621346bfca476e54910329f36f0f548e0c8cf5306f6332ee3274a57c4db9b5432ad557edc6236f0d179754bad003338e0a430e8796492d369573ceb8abd8a338f82f899a39a85d447f7f62346eb1239346e86e8f307761800b1790ff6faef410568cc14f2d5891b7c25ed988e8f2a4012a9625837e9cf08de211add06a48f849505176caadcb2c3f709843506dcb403c9e8a5ddc2d101a587ce802a6f3c8ed9afb34109ffc368840080514729d0359c45fe5eb1875052c5443ed361a94315d9cb6945258665661b7d4003c96b0b8316672c8dd40794fa2d88f4ac8d5914b2f16ff6b36b04ab0fd3a5d56ab2d621ac22b5fb774864f1153059270b4170b7fab574841a55cf7210754d27ed095f4063962a6c72d733deb4980d4ada00eb819a95b98e39243d5dacec13de0b051e74f687eba44d63f75a319ed8f6c58f0de6127fe9aa45c09dce920f3604f130547a31a37a14319f264c019ca8757446cf430fe60c3bc3faf9625e22d2d0ff4e34e94f93ed037f7e3b81e0aa165f7c3203a992867e56bf16ecb4978f3a4ebbd0d387002c6a5ddbb4962602fb566604d658e99d2871647abec384e097aba5f170d49106e0d9faa7b0cabde2be99c04c1a6903cd0dc198ae078ad18ab751d5b78930d68798a4a6e91efa372189d0f390116c810dd2a4e2f8aa59d449ed15ee476bf274ec9cc14ad69ef4b9e16b790e14e67ab8e7f73912b5dc718e838baa1ea8e94ea7966cb5da993233bf3b7b616811933297f87479222803bfe1b53a3b99731f7272246deb250562d52a74482315b470077357c42a87de05ebc5c35791b0f2d8466519c2234f7679452d89d636a953ae006a2e07740e767409ae099cc52bf5aec016030f3d12e98de43377a2e7a36501a8024c856772d9728a66d7114d6683108fe7be541faf2453a17594b4bf01ee4b597e0a09f5f02a1cc9ca5fee2a7e55e85cf3a6254af687fa5ffb2fac4b4c3d17b081520f25cf20de048b5838d1e344899f421c67e78b0d1775d081509010b8d5fa6b8310eb1eb57c7a1fe9053b589f56114b76d55b88896d1d991c8dab6e2c2ff3f96e7de8f65133e8f7df42741675adb34e4a0e7e613b8624ac74f6fe7200f99289a8279634c71aa4d25d2577245bd686af7cae4593daf2b96ff1e6b2bb089bc00785444554f4be6e8b1de5d29e0adea5a98271e08bfb44149f7cab60ea01f1879ec82d6c1d866e2dd30271e4824f67f907907914384c9f20ed45194683ed37a1a38e20871c60fe78bf7977946854c469a484b5c47bd1f3a2816e0c9cc2055208667b2af943d475827b48c444efd5be96417f8811cbf34ef2a85be29f3036b709b6db6fce4b5277c25f15c98e9412cea1075e88d1c7cb4bbdf9da6ea20183c0f87f55e727e3307e0a58095a6583d2cf849a0e9386ea51f13b16863d65fb0d55ef08cb521716c6ed7d0ead67ac675a794cbef9dee3a361d5f1f4205cab4e9d5a3c199c786130ea6fb360a30226ef9a4bef641e50a96936bb9bb80d8dc853d96626c07a4cff1e382b840fdb0c2e6a8ed000790e35f1bf6440239a8a4ce33b2df3615b51325ba2709c2821b9b9345c7592b053a1e34bbdfd8513c177daba9af019227a863f5e91a2238eb3a2a1a537b1988934214d09d90de34129225ed86c8443bbfbf31d6dd09e816c8f90aff033155ab65ebe37892c569f5bd65c372c182a8d930a8b2fd02efeeef30f53c2bd007f50c6ef2ccb747e69fb3b64440b11a6c584cf5d8a453b89814df01dee40b8d1ebc66ba83a8832d17886d49ed49464a7593900f0d618d30476718cb6b06ecb0ee08f1c1b192cb265d5a180b52b52d84ef2654d9e86bc1aaf18f2e8cc560076c0f349ab051518862777f8a763a0a8bb24a8a55fdd3e34273c2879af8677fc0391358735482033b68b7eb05247efe782b9140318a67aee1ee0c062ad2c4e39c64f44fe63d84d3a535661f328ac8b1409282dd25a98ab2264c89bddde7358021c2c32271e1cf02b7714d28c833390ef346ed0b0dbe7e01e068799211fb5d4cd77ab0c7151bda85da5aa9edfdebf072a9c6d4e837e8c7d56f857a0775ceed539557f622e2f9c28cbbcc391ced69c9e4f37f53b32e60f64f17b23723afc82fb8e8b7b4add132fc9bfe46aba8c7646b6b7664b69fe518bbec8151c98b33d62dda25f6211e235e563f5345aba69172d0aafe13b716c600128ab35a0a8bfe6a7e3fad1e3547278f02b98d46e5c0bc76307a9621e0452b9a3c15fbca1905fc35f7ca20380e0c659932e4a61a4e56b051ad319370e361c8723e2c25087f72b097fad373d918de7c7054cdcabd77e1ff0c2c3bce2c75d4b64992c27c58f982c23a4a159b9dd688569b00a65abd5b8fc1b24f8de04dd7a4744ecfc4a47c9269dccb752f1d7bf33730f2ed2152f297d19e935cc8ac86c7811b60004249f34c27ca071fb1efd1f0193b2d12e396fac21e3e1d620a9ee4ab7905c3bc5a63d8a436fc2daa000dccd3af42d7a409033133fa366d0f05906005e10fbbf5cc85a58dfa415c9904d442dfef96a32b5df5dafc303d4d47567ed8519ca0ee30024c35191c7f90a9ec615490d21d6110c40153486b716a4d1f590893104fc376b2048108728c68486a3a050d2a61e353ea9bb5c8fa9c93dab749f1966963db0250180bae62be6eff2cb08e44f13a239037ae0563db13e17c80dad34588516c1df2837db10675263360e738a998779058ccf351020acb34a9307843c6f5513be4126390b971ff0f45376a7b0e25a46c47842deef79ed03c6a1e9d52062f914e4f14357cd2f8213bdd992fd58a6c0b9c26d6d6c94234b3ea7974a87f5d3514d573257c310911e015c15660b16d02c973073d4368bb00996f0b382e6890efa86e21d99037fa349637410483c341740201d2d2fb135ee947f99b03fc143c1cdfaff7d27caec637e306e748e4312ed4a315febcbfc67a0d84ce475178045a6cec9cc292b5b0ee9f390a56a5b123ad009534d26f38e0a75fce55eb05f6ef3c00ae119a9b5dc10f28827929f5fea88cfea7d815d78012ee13a5c9095e19153ec2ddc808b966c75371a193dc889fff6f89800be16d34b35723ecf705af150bd7067d9795af9b0b2be1f2d2d2d6dc258a20fbd3d43778367010225f54660c4405a479c97e3b54207fb913d881ed8b080f68da3d413374aa17a871c4991a549bfc1390ba36abe3e941b2a91de92a238fa9ef1f58ac2b99f2f9fc81bd79c9f46942d05366cb69bd8fa7305d43de34e0b5ebbb5f995bc786ddafd5e55f35bb47c2ffd5a5a400ce080cf685927b259b3aaa056ebe6ca33aba5857aa13608666d794b4f04ad2c8ef2e748a12db50669fcf005f59b3d59205011e241b3049780eaad929ac712ca662026ab57566eab6252d10315334c51e884c76ae530f7b1e2c295195057eb3828e3f0216ffaabafe79f716c87720fb99036e8b4d9e063c9fa8ee0cbf3e1a8bad7244b75cb6754ec75e67a2c65632060353dfecd1929544b244580446cfff45a58fc719475b729b52cd6d7831cafdf0b3be05a2e552d01548a528d4de01daa814c399ca86d26c2a7e8f648836a425551d8e9b6f709d63d3079fb9a2bb36fc26018b5e916f9fbe2d3085fd96d596860f7ce53f39626dc8872d04b69a5db42bdc69633751f1e9542d54fe9306bbb153457dc4e76625994888b82429543fea0e3ee5dc56e5581fb441c14ddb2aa58a3d0a2f7904926321467e738de6be7ae3c5c6eb88e0d17a289d7bff14e497848b5ea660ff6935a9d26f781b2ee1d277428df89a625f03370a909a405af31ee80c640d97b57d4a147edd5762a7e2a42377d81c303e4437a6c056817e0a0bfd9aa8b3ae714a9e0f7075688abc2f33851c7fe37e381327f2137707f135bde61b9ad7d98d5778c518d0d3bd5bd4696898f09285c34bea44c4bd52c4d28af483a182b8175e27b9be627cecd2710a9b6e87976329b20bede8e767429f95b0d33f903ad28ad44742c496a121453cebfab0fc737cc291253e44a05ce9a769f711d4fa1d93d8788e2dedfce2b3f3f972af2465330044d9c4ae1162d19f2164386cd668c3bd8a9d0dd3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
