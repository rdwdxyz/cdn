<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"157e1f2a61971d8f783bc262bba78c9de185e73dfd2163f3b6d2a1bf612f95ba90a055b5ea1231b8c3b7e26f5d556f743f8ca8b4072fc05c271db877dded6cf8965715437d618585f4a68a587e5fa129a9d553139d8297f786889aeaf0119fb3a499e0dde343a0ad64213251fbc3d128b856abf9fb9da44f5d9f4137dc81f631bfca1be21d6fab232ea25c7d861845d2177ed6adee99cacb4276d85e1123a4b86ededd2423a848043bf1d5d595cd481cdf6dfa1868bd4497578c75e4da9334cf03a9488f8b5390cbe96ae5e5813f1b6b6cefe8df17b765dee99330d542f7e6a5068611b5ebdd5308e2d5d9df56e9acfb026cbf9cfd5328e2292397f747cb755201e7c3396794e1ee82a96c139142aed966e42c8617114d2dfcb5bef278a2bcc1508d3eab22836702766cb0bd9066cf98a6644b1333d02e53845d08a879c90efb37449fa451267b933c72fe611356f3a8016030b090035e41fbbfcf050c51ca510c6a126d5b3ff35606b048296be12081f1d131a5d595caa77c3b5dba20b816b8ac65358ca8e70f3ef610c83e2fc66197f9c45af807d88781509b0e360279e6bda1f1d156f339b3a135b733175f1900251796c27abc9a3b989d80461398e8b7f874285c595a9bb9600be6b8d21b3374a10376cdeab27266a72574abc9f68270acd01ad90a382190d5f93cba8ce5c32091900477b9426622684a4ed39df30835f4999fdaab829bc7e5b4bce8ea4022097f3f628c20bab294fc82da78dca501ceb73464a7fc9a322d16a2fa19e6c4d5569aa7692c5b54b9847fc275be0a0662cdd369cd7955d26bde06fc98a6e88f84ba14009e7d6546d517ce5515b7a7e63ad0b14846e85dc5bcd8165ae6b4183c877f1f8175710e12b4527cf5ef1634a91a116877fe78ab9f643cd07e8fd3aad74eb94f942e3306c6da20f7ad90f3588956d3ebf5343fec831d2ded7de5fc9bc492da8f9ee2d89eb53d7d2e5384965ba2af3f8faa0a0a02652ddac93d894c64946df936dc38fb41bf2f8c308139815d04dcbf4cf16ea753c5c516f9038409ca80cd80f7dddf3f66dca594b2886c7c93d408f59c3d995856073faf2d3179e07c759f33d191128b1959b1d42f446e86163d37845d1952f15ce9dd446091bb25445f2347715207f8ed1a2ce13829d66d027303b385e96c23ed1fb4ca380a71dda47699b56dc25a8605db2e00e23fd47bd8255280c2090f2d13119d0159f01adb94cbc439be376727ba01147da15ccc7a850909c543d31bbdf6ebba7afd99dab67c3d95b0f5d4ba25fa76235ee72934f535fac76dbe578b2c052292934536771d66e8df0f19285406c2b7ac56afa9442423e9b50632ad32a726938221908497effc5718741a9d0fa9a2f4dfe9b914d0924a2a35ec88d49649ecf03ac9b559f2a827dba1a05b19fa026ba2e4163385c5c8a6b987ea9bdaa1f0d6ce8a455d7528b0f8abb513e86a448c146a708914a6a4a4588556a396e2eac20d79c1d643e4c7bc6d8d2bd6daf17c9f17d03f7f3bcb0b57c90d12ef6fe4ed6285b213173264748a406f12b12dd788d14dd81647f54b7cf6aa9ea774753475578387c9a7668847c1121fdb523deb1d3820cb18683d93efbe1a2d6cfc2dada277432a1c89c41d3a358bd96a60c7df0155cc77c3ccdf1b8806617662817c2ecc1032b2b83d1b075e5f5409cd9c231d30f61fd63270e716b756ecfcc0ae55373abcc2898de88ec44d352156bcc52e3c8a848a46ae7ee670cf9b15ac2825903846b33a161774568b7d60c8eb9dbfd62d64d546bb5bdd1490e86d391f8c4343a6d3193b396a3bd90622afcd145ad67405f475019328b20141b2fa1103309716e207e69a2452d43b44edc481419fd1223ede90f63c453569031bff7414408771b497194a7f4875dc2a8f0c7141c0297162556bef9aca8e61c89dc0e6c563752c00e38fb8c43b1c06b222cd2ef8e6f5c93a9061c12ffb3785296bc8f64543bed0d52b8723ac12883c7c25f4d75e011bee9e6ce47ef9e1b251558786c35d95bcf10b23809c3885077eda3b33b447da285ebd2d7c13e81eebea412146587bc92fcbe19d3fbf98fc3c6c64692d47c926090c35505c0411c10e2e94d2e2e81f058c009938a16f5fc7c69ead667e1680b1f139f8b5bfe429ccf11688b645bcc01b632cb3670ceb0f23d51167779891534fea2699b0a4c250bb30e4d24eaf9e1f0f8d323ec88a5a5b64bc0c27c0c3e0dad1a37978a3d8e701b8c95f347dc6cca0f982055539114b4756674155aed8f0aea27b1489fa453479eda568ccab4f8c0d9c3599651a23bc267b3c49ee34a8359a40e08efc3274ca4e9bc847a13fd371d3f22edb0e6b5c27f7b572c9640801630fd25270d57aa5546cf3438e45a1d423ec92ea8b21fb1c47a88f15066f93fa6d9ae5ce4f77fe32e981b8fb31127c2f423ad2f9935ab29e9732c950670c5bcd99d6f5113ba32f729d5e65a5f9ee3af5c6ba0371d1c69d38ad3ce69d159d011163bfc802225506b3877bd44f5d8f5dfcc157f9953377d666b6f6d720f52b8f3f18c2d2ea19d3fcfb80b9bf937d12278c191635cc40a4e85f6243092c20a7dfe941188a3ad9864eab6f2ff73fe4c55e68872523c050edcb3a28e898fc1987c40811883443b6f96904cc631b9295aa08677b2fe5fa1e97c83e01617dd5e3d23595b452495d5f94eda3ebe973a4a0a4aa7b86d3c017f7c0154472ff6a7adc9e4ba380819ddf51c49fcde8d36f96b7e89ad6e121885e89739a53275b130d9fa8198d6f28240e83d975a293888ecd849a790fe3af82c16430aeb7a6d63caebca7c9b5a1a520cbca7a71ebe79a74bc0684ffe28adf0c455105e4b2a0d43578f3bda22a36ae7c34d780b6a2a17f63cb33cfd0e8470e738802a3eae1fe876ddc6c02f202069ff1bca1e72ba190da8fdaad186a4a5c40c2067c1e49552126dbc30bd1a602a2615c5b2c675128bdc17062a7f14935b5db0ae69bb0377f5b13414f2c7ba58169347e91aff43fd2e881afa3d4bb2c236a2724b5033fb06ec3def008f66827c05c9ebeaae3b944990797ab16309d52e6e7fbca45b2b0820df883f1642d22509127f7703cf330d1568694e487049202fa565f86e3b213659d2ff9d7d77be75cf9c14a37b0dcefc3c3918a35538bad25ef4532ee85aeb46203d508faef08fd7a93018764405f2725fa22be0355038d111c028a34a88af89d1270457bfe09e3b699680233c8763ac352c39ee20735e88474fdf1bf46ad7845d126cccbd3af34e1253e24c308c889fc1b38a2243ad2b559e6557d988a81047e08d149694e70bbcf6687b79a5a2344f30d7a3c16c138424fabd83c56f57306e09ed194df8f5d01a575eb08f68d9c02ba2a7da33e7cde6eabf1c311fd750357c5383ee11a722d700924d9f7bfa7eebe9034f116811741a293e7929201a328dbac71f483ffc0fdc1d61338dd2f9d255f2ff1d30a793422eeddaa2371a1d309acfc5844045330d06111a0a682cf2c39a4e323f3a11d9fc6ba90a77e9aa2ae0cd5b25b1c29e2f536148c83a9427d659b82d80f94145421b700c0391d5a19794c926e068bc033849835f214efd5e1c6b640a4539ddc5d2267358540fb6136ebd59e5f23e6a9f7fb9287f6e1ecfbfe3fb5db75a0eed22a3f81f60dd69277302f8c98753ea3798d00082d6165d9b5f9992ef2f24ce961bb0a9d2d2b6a981dbac8d5c4eb8cc3d7fce676b6d12870ddc806906b6823bebbdbe98da17825ae45fed0cdaf24e36cdb0c6ef59a95eb87d1316d4824835018de006812386bf00fec6ffbca4a6fe60fad7e0ba14d44af3b26bad21c137063a922dfe7c85e2d8f7cdb5a7b9958dd5a510be5671f2eeda482667675a21ea7ecc6e243572262f04b540f08178b85a2b92ae249845bc200a4d04dea16c8ef90bc2681fcb19e31aa235791792f7a49cb04fac30f81d206439b638fb2a2758613fa7ac79b12831484b64df0bd05ff23871c0bb74321e6265ede23a59447d2b1cdd361505aed28ae8b60aa81546a173653b3936c7ddebe774d2d56c4e01113d1ff3654c3dea84878b624af7553f57c139c11fdeb4f620ffd88a08788b0a0c2115dc3fc88021703b8cbd56a425d29ff3259bbe2a4bf624a873501a0bf71b7f496d9a2211ee6b145d356350fee99d2484406fc3de8c4a263a3416d711e41839fc540dbec4be35975725c428274e86dc24b2b5bf43f3bc08a3bcd8f73e4b575b6c49602723b784b2f0c5c7826e8b1e69fca86b62cb19896e8afe7196ce633bc67de8103b5186477e87c42113cc47bb8bf9cfba01d3f4bbe58f0fc0f33f22b20b5fe07237ca83b41caceabc91d26f7bab0685c1d221c0f82f0511a96e524769ff1d4f2cfbe6a9be01d0e010c4e8b8ed221e238134121616a2480f09f09aa5a4886bbd71394ed74056f2645610ed6e76e9ac3db93ec45fa7f2f366866f4d5252597d571699c5cffcdc28f4ca7ce86d5c166018958cc9615e0bd66a1c7fc8e4dc928a6752d0898bf81a06b91b3103ce7fd46b82f6ff2372c14eb7ca29203a2f58cc52264e7a89309aa621d5b555ab76e6c88d82add2229342b514dffc53403d226c2e67abf6ce3b9d98688e1b5d6a4f0e3cefee6f82a87c051fe2bea283d5681d04956c039296b6c9e57387469ac5c94d7f271b988858d55e75d43c180802d01fe8bd24ae8e9dcaa7e13dc72bc2664fe108f9b94b6f776482d6175a7bbcabf1df468dae6b765bc94d7ccf5c8edf4a826cf3f83694788e78efcb344b91a43b31233feab35a2f7785259d7556e64a23184de84e05319d4eb8905813b6428b1fdf27cd8d7a26e120ffd16f529ca3ae551632fed52f41b7837626117e8b1b59c137ddd7183a842102fe7edab9edc9ea9103af05f53a74e1924017685f77c20e9eb813f37ebe2d48a97568bfde7d2cb349d7bfff96adde44c72e1b680ff2a00d0e8f755191dc21ca7216f9134151a7e0130efe0ff494a8dd09cd238e15a3de1f4d4edd909d06840c605cfbcf911bd78ed6668bf2e9d4f7945f5bf1f4f3c0fc55e0929de83a0dbefb4086ed3fdea405f7240da37b78a8409c9862150d0109d4803acfefa789b4f005a1931ec76d08329897752a681ffc65cf82a027383ae96d6a04e2db22e5114537edb6fb4e5d3c478de17dd192f6a8416030e95e1db24472978e9a54177c76ce52ec53b9c6e33663b1ac7ff96aa08acf734fa056b04c8b0f63494693a3e8e17cda40257db3948447a70c72ced0cfabcc69e278aa1a725a68eec7b359df95c0e8590dc984699109d82fdea53f817c1154668aa1f464327fcbcab762c00ce2224616940d207bcc32a0f64d615d0b917d8d39b6cbed1f1a2bc0895e9432a8831f5692686edbbb8924a6c15b89e8feee1a2290f510f7d2479d87ac5bcfa519589e3d4af7b44a6b30077b4a1c7bccb844c5983c424804cf2fdc94919c05456f92821ab6b3f51139bc8ef4fd76b69f6f30a37f07605141839cb0c9d2b6609c050a1f6a69f0bebc06b19619d7aa3f280402037a5878f4b902f0d7e76ab9fe1ed2630fa63e366e5747025dd99475fb62efedd2ef7f194cd5df94d30eb8ab110a16bfede0e7ea49a5c1a215b64fa459758fdbe45a2ea69214e56bdb9f95f4691f660b3910ba8090de8fed1a963de346f417bcdd486860241fcf4d5845f024db7b73f30b8a2ce2d0cd3286b1d215bc7dc13f3793fe2c52161e13b6985786022e93edf0e2eca95099ea4ce7a0e0d45948bc0f3371ef2e809088ede760452e5d7a585335ef12060a240ab9be89f818179334dc49614ac16f2b01bef1146b71e8e5dd15ca887973a3514058453d37cfb555d2bb45fa62158291c19a95e3f96eaca6e09eb9743efe778af60ff52490b5157b915ffbf2339c7f79ee6608a8259916a6d4c58c84adab63fc54f68fb89ddd766774ba04a4affd2434fdcb13a8e72d88dd63be8c29248fef8bcd051e85d67e5c88d0d367bd1b4c4f27143d2f1c314e0828121a95018cded72e9f1771826552c2b9a3f3cadceac61e968222a66c7e9e8df45766fd6277ec19f574c5783fca4bb9f2ef7c619c9c5bf3094aaa169126fe6260193c973521a67ac7cd8cda4ad6eb20ce599e814957479c0bd4e215668cd25608c8e9bc67c2459d7da5d2cc438156b00c589904f069cd95a8860401c046546fa519049078cb7ffa9fa409dc082333e5557d3b8ca515e910330f4b5d9c3aebdd03107333c9326365ede41900a459fcb3ac259b483604f6f4a84b420f5f61a24968da84ecbfba75b2897d80e42663a9f6f63ccd99e88bd3a37b5b595b7cf903153056434bbaaf4474a3507aaca37be1dcba4e83a13aeeca6c52c4b67fefde7228a16444b6b88f695fbbf4dd07915015370ed9b0c8de51c408cd3668109bdb77ccbd829ad255b15b274b5ac106280c58470c8f6fa427532f0e5bbedef1a5d81922f159165ebececaf0e125f630f26570bb03d8792bfe4e247e763b6e4590e8809462ee9e255b9766379628995bf312eae4238b76b34ca83b3b0741379073ce883e5b25b6236fc8813d11876d38e51394da350536e8842ff7915496b14accbcd313411b1fc64574ac90818b2270397eb954fb08eac3ac9f2550a4cae011062b4a54e1737e21447d7b97f5e72d52d1ca97c2197aa692093e11753c7803dbb14fccba76327f5d1739327dbb1ebf9b3858ff6fb33448c98c979a185042e75a7ac1269649d155952e8c325239e730fb2f50c7982d218e6c560cd2d5bc8c310a3836c19dbf13d8dadd011960799f59ff9bc5b314df647dc4ecc08640aa7b37db3241263109a16ab806911c19d02ab7c21c6dd92acf69e48780f56452054a0ef25f52ebd33157796300ac1dbeb6522be40ff8de4145c92162c575f88b2872fa61792cb49272a263a4d290ad1bceadc3ff63cf843228903f56e36516a1a8f82bcc190a40ef57eb028bc2daf4b34b79c5a48bc7fa951999d34a3275f7ce2b012926fb425e05f29b967cddef422da3950b8ac151138ecb9c8c2392cf5a7c08b0ffe2f659fff5c4f64953616caeba4fdac9e32fa5d2b520b8e4b6690c1af8c6396ca53ee30b74b1b60d1631fdb117cd606a1ca49585621232aea1182259b58acd55e75e01cae4e578c2ec0fa65fb721bd96c33ce8f00e0886d9130bb6261c6988825d2affd0bcdce827e13284ecef91ec160b2ae62c7f99e97dddce67590cb1f99daa62b12fd8ff0c49fd666625dabb2b3bb9cb0e11347366292c03fc201bdbfc7c05b526818db020e0940fb9950bf8900509278add5645a7abc5275120fd3bda02c6736a42b00afa261bcb35d78813c6bb043ad15a7904512cd28605b712990bd42d24d625c825bbea9215d812679eca509930f32d0787b557330e02a6ee11068794f246494317abc70cce611885fdd56d9df3b82f9a0afb102f04cfc72176c29ce6b4dc2241567a599f42ecf44611630ce42d1311bd3c10d16360448e7b684be3c38bce34ab8bd46ceb57e3cd646f776c1e4c492bafbcb6c37f21eaef51517977c4b610237b93e906bb918a957fa85d95f2d4e16ae9b92b082adb3ef9c86f48d0ec0229a1696f44eef12fe9e9635b61b2c8c83466f841423a4fcf0a5d9e556321dc5034254611bdae117e931702a5a4f64f02b2c917afe134ac1135272a2ea0e6a336e7926316214b5a86628303448a169e672ab7a1ddb7570b36ec618ec192335fe16cbe32229325362f76d48c8864f0fa329e6e7b35f0ec85fe9bac0ea3d5e99a5f14c2f51f9d5d489b013716c98a1f49d9c834f51b804b107e25176a5f5f7e5715e91dca0584173ba90e679d29f5d8537ce987152bfdefa0e0c9f257cc6febada0efded3b10be8fb73fb24d87c5b4873663bd3bcb0aea068082e5ea5c1d102419f83aede1510a8b348d1bbeefcb3b3047914a43c16f296829417ec1b62c5fab4458a8a8d92a32ac938d5b827512f70e8247e3871978e9875c71b2ffbc85cfd2dab82a17a189c31a397aee0f60969e53e081c3f33f42ebf2f41c44dedb3026efb64f8fe47eeb592894614857c1aa16fec2f69b7fae734f8ac76cd83bf176197d1f3ac39d71cb9f44a083ba848aa14edab58ed5f9fff85462a2462e4ea5ece2ea3de197ae822a4e6a88ad03b4efcbf17df3d0117c5983b8203567543781b8c4db8961ed6932bd691200c2bf19512148bfcc3678e63ed90ee301733fd1b634129815d6e54fc9a348b6d238b6f4ba09aafc242b3bc9519f6c2054463702202411ec5de4b1791a14e8d68505d52fae21756944ffbacf7bc0b5f52476f92cb2860a817f9d2520a687b3487c9a04ec049bdaa2b314e826be7e3db0e1060cdb17832c98a8970d9b24cf7ff3321969608d2b89fcd8901b0e63e51ad046adf8001a530238d87dd0f51c167782d04191251534ec4208d0095643ec886b8aed310b6d3b16bd1be39d9fae157dadb32b01e4c655013f3e259fdb9ef719fc62b9cbf13fc63411e1ace310f420aed8c8d94794486fb2970c1eacd5b029335de1af42c2910082e3d4d596df746fc83228f9d09f3068a3fcdb097b0cf9ce6e1cee59a1f14d506f20122d0e0311c48ad681478fd86d6cc8bfc2599c837962d79d4dde6ce0b487f9b690d78e3df13199b1d68aeafcce941cb2b9eeefdf04595145d9a48dbdb6b6e41d96d7431ea02d0e04cd3c0b15ff6bf96fb91abc641c39aad8b8cd1bbdf35ce462387ae340fe362f7c797d1fd62d789c5975619b6ccff645fb3e864de352f6a0848562c9c481494397d48bec923b47c974b749c2f73526eb3400051f362afa0e7f7b51f15a4b91982c2f3eb7cb5723a63154dda76b0c9886bf241747b14f45e78a78a338aee675b1eeb47cd803556e962212946d6bbba3a9da5c246085b8cc300f3171fe7fd1f1ec56168241a9822276d49eee8c639d5453928ff84239c0e779a70d8ba8a75f460f84db683ff8c8d9d7390ec8f1ac204d16e6fd679aec2365f6b80dd882bd69a550571b56e31450caf5979dc57174e95dde161d545f49cd7a13c138191aad8ad360c535e59b153c10b3ca7b4427b29e0ef2777c016d07a769312fe5de856629670750ae1f2fdba60fe9c789e60ecbeff766e7cc3aea3c7feba829f9b0df2a4d2e31222e631250378984992a4f263741fb2ef48ae818341ea778c9a851942e1ce885599359d57f195d2deea7980c90983f5cf3b87a36583501f2fdc1adabf3a8b3924a19ba61d44ce5ce8cf791dd568d79c07ac89b8bd6fdff18aea83fcea38759e443e283fafcc937e3f855c5d77c6cfb118e4b0eea6925959673f0c6835237b82630b1c6f5c698d9c54d7750eb800d41d2772f6810a715c97b160d1ef5b493260825ad69fffd5e6299496331b733de033f9c9f55801950749ac2d6f90941a53f853649c1ed59082eb58ce206237acb0a450a78fa65797f9b33a52757578c281b0416d82c13cd31edcf677ef329e1111477371990ba6243ce554b0b201aaf5a3f84161e27b71def18e5b621cfe555edfea571359fe9ab3b28d35767f24c01ffa9e0f56134ce88e8d7d52a202ec5f811e8c4000454e1a67710be41d375fb97800d93d93bb723a0085bba9214b9ae5d817044861357077aed933b039706ed2eb42d961047082d5ea51728b5b4d01b5af5187cb59ed71d2000ecb17d7e6ed4a6c5defd59fab24fde55b9a8084125a0ff050a23e2cdaf8556b67afc716982550b8a7654537cb0ee76e9842f1324bea9c2943a342a3b65f7fe2a21f955b17099a17302e9b0eb5e1be0d9279501b5c51881946e92e27448ec66cc01f058f80594f1f5615e6ff83d9ea422d3d985a72010e2f01bd84237560ec3a583d0b03089ac494f3ea87e3f33c8a184e2b0a3cd40ae1321f3776363a5b15be363f6eebb3f6a9a1f29cd29e51beed2f538aa5c61f012f4d44eb986842e0726ae04eac360c31b248361f64c55be9e05b63b8aad7a6614247ab00e1e5cf8ecb2d6117aa24c801df0fad4c04f6a13f05ea77f18873f44c4ae24271b790357dbecd821907b80956aeb833f56aa89a7bf3d90e236ad54548800469a4b0f0de229be7757fe800cdc4cf0bbd5b4f844c15901520f4b360eea0b4e4602293991f582db80a61f2e77a5190a800f83ac97fd4cec043c2370395d5513811a9208d3908f910df0b937dcbef2b6fab30ae859eda64ed494567672caf97acff9fc387e40f8b0db83bbb9be1c443af8a1d3a070c8abf1affbe030f2f8f3f6c2b11dd0740fcccd1cbd0e53f23a8fb54f7e885fa475e5aafb0c4be3ed0c98a6127b440631baa2767f217ea93dc7903eae342476e1708c7955f9bfbc073e802169eb513e57d775b4ce3a6b8cc4f93633d55528dd8763088443cdd3b9782e256f9a8476b8a20ef6aa319fb68ab707f6e2053c139e4d46baf33626525cdedeb551f525f8b032dbaaa10ce4f520da739b5f9051dd576698535baf3f8dfc7b429ced9fb52a8852534428b60f7481ac2c19dd4369b41410e5bb305cf01033489adbf8984b7285b803cfb69da83069b92d885e85bf92280459d381929a170cb770abd605af93fbea4ff7106f407e7e3a66145261f88d4c881d11410629f5c4dbcf88262d12bc8dd3cc314d622dab1335b4a1d1eebaec09975783665bf17a6d52e8e09a5e864c53041d93afbe20558ea27813be6b10a403601f42fd5e53025c2fa7047018f60873d3f466aeeb34d87644339cb66b6925d73c14a53dc3de6cef0933d51edf26b3186945665190c2b01530154faace15655ff592df0cdb03d510a71d047d399596e7c134d3beb652e5b3be1d11a60c3439914eeb62fad5d25f77009ddff0527dbc0c1470ec43c81b4d7614472196fa7c56ba15cd836f8674ce5644300623aab9f34902a42144cb9baf630abf455e76ce8185476c33ee249f7322155a09a97032d7d94f93d286d4a12788d119968f218d744e8ecb7bcc1b40d74bc6c4c745e8a0187d4d436d10ff8f7fff15527ec11840be44a5a67eba88fffd53ece47943232a48a2e5795b7ac5310f7d5e4086c0fca70dc8f4436e929b1eb901f1f3e8dcf8b502b6cab80360e8cdf7be3271551dd3f280a9ece2ec196f341890b4261be50f39cbbbcda79aeb4082b9a45c99b8346ac8cac31f1b96eb3c5c2ffa4314be0e108b29e2821357dc7f1542715744a2885ffbc301f754d12dc01268fccde6381e197621eaeaeabdd8adf5c9179c53b4cc8daff856e672d232133e8bbff46da713e30f76911c2fa7b0aefe4407d039e4c2c9728979114971f75caaef2ee243fff93f901042bfe5550d0b61960de6a3294f84d1160df1cdb35dee54cdd8ef927b9149a80e918231ab2caef3bfb0b4023ff9822317f2b694f678e423086c7c70c91e61c32d58e693db6cabf51edab264ff9240323e1793dee793870f028c466e6e2bb5300a2905d2cc820e0d074417e33458237c01130a6bae6868aa06353ed621acb757a229b5188390916da68232e3f7c978015f695d906409714f851ea8d5dd63aca0938883bf9f7aec2ec96a9000b6014b61f0683058004469de8f97871a151b79a73d63fea12d7dd83864924c45379ea710aae6c148e5996a48ad301be24e212e3bdad65f6dc06eb46d9128c449e551e6297150550a94a871d1ef865b897cf89fb0733107b2899f7120bc472f5a1367b0979b096f0f4b05838a14f85798a3d57241f5a58097a83f1d5c0a319d5664e71c42fe28244211800f249dcee17bca2513462bbf39959e3dc9997f0e0f63932b24345da46d334f4f4e9fd5d9175f3da530b60de0e599cc3edbf51cc8b3639b182f676c796e2ad8b3a60a14340452a2a0b376e38c544bf04e3b74dbb0d0b93931881c22a0a4e0cd1671c60b2eae92cb00f637df001594d667072588497796fde3b3f918aff5a6c2518ea1c7ede21408186f1c1be6a0238359efd180118132cc4b2dfea9d6acdf1cf243c24f7e8cbaac4be315d9d1319e774a75a06106104eb5a0705ab29c65bf97aeb9c6ae13461742117e3eddc12c80cc9f22d96b76c3b7db47ce2dbfda79ba27214528976ba4bd84ef8266ec813ecd33f250ea37dc120ada6998822770cecf4a3143cb8098ddb6dc31932dee7c6e5756decacab2c63efc8e4c7b30ad88b348628e1245f54f9f27ecee052cbdfa630f43eb1984105c689a85787b9193e906f24273b3a3665d873e6ba5c1f0b8cfce41354931f7f9c94d9f9f1f01de36e658ccfd5533faaec9f77943b3168b15ded75799a2e1dba1ac9224b29cba0ccf8f3e7b5925034b2ba1cbea412e52deb3593f92772aa1d7df8a8b3f2346fc1510a858a066e90eea6705f3e161b9c722e532339b10b3c55281d59e4971ec960ac9e55881c0f0d37dbe9e601d691308e78c27d89237f11baa7160fd3d42ec80b64588b744ea8c23d5cd7f9a9d366cac7ade8484d3de2d85d5e41eb402bb2663c7df574965087ed0c9a45f75fe739699c29fd4f092be90de7529cfaf41b52fd4bf8425bf7eba9cce805671ccccd42677b161071b2d203f1420b5b80aa835ecb9680dce09b606d10c06f02da07620b492513c0bf1309800fed905cfec20b1567519a1fdda3df2b41c5ff71df33a35de9f786e6d5ac1974e699557cb03f7232b8fe113affb50fbbf6a72f3e9f146912dc94e8f44a3e943d9e9ed5ce195f3afb8d8bd29d76a6416e8e721312d78574a5709a6d06cd7768ad1a84a9c083902b23fbb2486c36c62e92fa839aed627996fd55344b4209f76f9a5fceb52386246b667a88896e6d6ef9766396bffbf90074430f44e7ae2b024171a4cfc61f454c901a21323ac33b9aa1c3cb0b2df5d02643680c3bf44302b07635573f9059f71e3d44d141d1128879ad7525be49947fb255420605a2bb724bdc5ff0433eb2d45c50abce2bbe262775b67ba130b218fa9970f1afa0f3a0565562389efc77434aa0a3ba5a4b752b4ab6a21711430a2cbe819beda06546a9c4df63f92fa27fd695ab782d6dca1c459d1c475d3b0bfc504806128fce64577b958a2671cf23f41391a70c6b6975618ed03397a2f4627179da55656690640d43404137fa58f472d6c291388d664ca453c4c69106838ccd4a5ee394b06d53c348da2817af46839f7ec379a459acd6f3eaece6a366115db058b41b36c201bbb3614eb8f65aa34fd99371568dde880a78f4af80c2aa46d50acf666b3ba32a155359406ed86624002faa55c309a1538353dbb98e324aaa52b203e60a6b8375cbcb0652be43835ffaf789b933b68e519c88d90e8a86012653fa050a835ad7f2741199fee371ca958d1f3f05ff6d3015cb533544583af888c06eb5466b5be0c3bca609ca39d0cd16297a84aeb96365744ac2f45f3b6fd22d272ae7b5659e5c8b8f381496fb91fc825b848ea554b98235a7b41be85c60d9fe8e323d8e8ac251148e7e9175ead4664f48585e2580b62a43a69cb424b6556088f273d487c3b89d9d2d09ddda6087f53ef938fd2feb2299a333265c723e4f7e018cf9e66f47bd021b022ee7e9aaa53986c0e1a6bfb8786ceda5fb2f275ef10eb5602956cf247a95f9108b6e5d879e424c5e74d043550a5cdf6ea70de9e184a0d5b067f9375f4d0d4d52a40f73d9d1e122026f267a7d3e6c57875c40e7a88a39cd9af7ca2d79e1bf6a7145fe824acd968da2a6cd7bc6c405c399ea0aa63910f4b8397f5b8b9f29e816b8203a74cb10c5bf969e3f698e59e84f613cfdfcff4d4ae32802980fdbfcbf4895a6fbc5a855a1baad767c668d2efe26a9ead683c755a2ec6084f36435c6f0fdae459e168ebaf6e9c4cff350125d97ed8ae686d6e807addc00881417d73275bd8b60d1c320a4fd649e52c64cc764fa95f4322775c8e5995aa7abaf9a17fc7db6858e755f5b0658d130cc99994e9245169a753adc3b6765bcdd7a821835f02b9d7ffdcc0592cdf366663c83f391637419b4a5a00c85c239ac9d3909fcaf7fcd104b5743d8b9b6a0d9930b5a46c9ac1940edbd45881d8f8bcac0a59ae1a58ab2d3d239652b4afc2051c5a776424f35cf1c59f4cdf869e738f0dae7b95fad7b52d6c64cd8897387646846ae447ab2a275ec3bafdfb0b50766eefb51a70f473bd32b82d4a330a31acd90086c98cab6f10efc90635623188acdfe7b7091c880bb39bd135ace09cb448c83391b87ed53f494de9b21074aeacbbdb003774eb23e019a7690e8f4f182b1800c2f002f3c082c43ca51682e09d5b29f5d10cd08ef435baaf4e0b7eb6e7da79f926f879857e80d6dc6983a68c2ed790c2bc331594fa896eea673c0e301d79d0a040e75724d263d4fa44dd7ad2bb52c2eb549a8d1499ed147e37557f94154d464e3cddf029d2fec4bbfafbd644f415dc6e146426e787aefb06dcc37cb9575952564c3fdd6415aba571d6b165046b2f96f83452c53759bae321bcb916de023585c03b74ca7078989d32e1ea91b87304dbf2b47a8cbf6c7a5fe41149f93582b9a24be4bbe0df6a7f8ab98f6c0dcf195b9a66a4106c24f4c9e186116ae8373fcbc696c17a9dae3ee47bb7acefc993df062db9c070ed63f9d9d4a02b3003e3d042e0b12e341b517f94815926bd81d137ddbd18f71d7c7918ea0bde5a7ffe77853a30f26f17a7bbdbe6792791f0af9c65418deb532ee467d8556d32771adcd23f073094d0af52fc45980bdc9ba27c66706a9bf8fea19b76d9bfa300cdac72d440316817d6703445ddcf8d712dee0c92fe2b5ad8c32e83e3bf61fccb4bccf5d2659753143f3e252d3eb8f8251f96477da67b24815be787afaed0d1085a576692ad42fcd91ce8ce9ccac0f752b14d5820dc30d9e7e450000569b05be65d600bd63199e7b5759c83073918983ce816cf8ef4ab0be5bfdcdcbcb43608826a527f4a8828afe1c829cbae71ce80549cef4a7f87989694c964c7df4a999ebddccbd5e7affe9ded959786d1f5ed102df2739b4d99d4e1452cecadb9b5c21a29792132b0760f57db9356bb35921790ab7b4e5ce0f761a1ffb5894f04ca1fa8f73330d70835064b73fc6845a35f1925f16ca4c9e6278446eba0afb3ce7c6e799cb4cbd278dc8558fd3efa704c1ce5931750f9e9f05a2090369ccecf24f737b118ee32c1740ffdd5e4fb2e86e07dbaf47fc5c392256b1b0766feca0de85fa9a54655f09d60d629dc6c0ab77561d053da94c6b7ad1b1b509e395c5af5f8986aa965879e47aa5569a53bbcb076b5d4f19a7ceb18174bd98b70c8086b9a55dfbb0055cc9dd76beb3cf5252e8fdeb4f188b10835d6eafab01cf3b7dee9a40104918100f2dd0d7cb929025b4f3428b2f9a4a99e916c309d93842cfe5a8206ea6256e3eca281bc23ff8f9b96af5df06d3f14a4da7c65b0725b6ca48f243081e7a23467027139e1e269780d1ed5ad832b16b41d4bf467fa7c89f34403b94575ebc0275ae642064297337e35b29e39edacc5cfd1c76a9237545b1ce6d8d0ac2292caa4b1c8e0f55897d8f005d996534bd2689372f110411928e5ac31467989eb681d5f663f47d526e8dd144e56683ae000184506a9131962ce7bfe239c8698ce4e2abe8b4e71743a2698aa139e73478a897afb6c5c9a6cfed06577c52f326df3bb1ce222b77ace6393f04826bcc36522e744cf0056a27f7017c21851eef530d361106ef1b6f71e99cd5acad165dbea18d2dd6f201ed5ba95eefd0fb0f9bff99e64d61fb0cc722ae9097cb667af7b09fd6799e6545e14557356a868e2511195ee8e4f630f3aaa2e052c2715a427cdaad77cac784c037d18bcca705465bfee21d2e226713366ef3f44f928116b4fbca7d9e6cb05f6aee025a13b232b713e86f37923104ff4e4c8757f3b1b11251a7cff2af3ddbae96a9d2aea078ab3df4873f8658ca302394408f2a5047494ca909afe31e76d8902784e5c0c5340b853686ebf55f612a51e0b38d9ebacc5bca21b01f37fd3126b20458392e9d37124200976c45764c5c6dc0a150dfae755efeed9c5473b91a51fb357805a27904090c131389d8f272015129df6a1809223e7fd256d42d9b8c724c7e46f1c737dda12a97d95e1af2845c5c633caefa5eff53107b1d453a55f0addc00d7a5adeb1c3553192d5b367af5970a8756237d10ab7bb9f8d6f995bf2571b4999818a5a8375a41e14e32803d5fbc2359b5f71a12363539c4593d0b48bf292f409198b6bc35b5861b7e94544335817fae71aaed25a02d200ca222fd6c8f12cbe755d45864f05693c2e5af6ae18c411d555a35e55fd807fd6d6a5bd922ee41c1b4ad328beeec15cc8938a795099dab850d04fc79d855040661624daac00366cd81edd3f63037f9fa48069d9f03399036fb560eede3a16d50b91e83b8bd4642bd8f8e8b54c40f1f4f5d1c80b8c45142d8c125424d636f374f57301ab9262482a33204da05c8cea99421254c0bf6083512bd639b48920c167f097a5d671f96eeae9522e1127b0c5bbfa1ceef70ee83f24fbbf0d4049b725d7e3612454ab0475b0b73a956db5065df8d494e0a2ab6ee12247ebac06517a7a16fce008864261fe93220c2a946753d1469a14ccab556f5604558797a6c170ff6fd10fae788431eaba274f71345182f853a62b4d80ab9d8beee3819164d7390d844f0ae0572991459b3a34f8ea6e6c1f7a812f1f9a63e0200022edba64f27f5f08af00a169ec14e325699baa129b4fa6d9e42cad4a1cc0e0a97190ca0a633cbb3c62fdbb8bc5331d283d4d3eecbb24712c685bec31e572dedf5d7d1a5ed6000b20556e398da35f6d407bd06ce7a403034da069e07ea455c58ba021bf72006ab9c2fdd399f21b6ff10bca15297620169e3d9c67836a8b495213be3c6c12a36fec02263192069b531b8069dc558e4cc0bb680f68a6dea07ff4b0538faa9cebd747d2ae0f3bc6d46949185599e110bd69cacb8a1d034e06464fc4eb9dd669c700576e6910493c9bdd2dc8fd2df2bc0e835a80f72cdd0f1b01d7e8c97fafc438058e6011b104eaa9b2263cc72fd5abcc3a666c01d8b4ebf3b687642045221dbe0686354d85066b97636dec313d3ffee5915178f48a229557497ec367b9cb3f4e6bb29ea69b3bf6a7267c7d652465d41264b36265dcf247c22c730b0ad2d017f33ade52ce6cd049a7dc36a6af1f3ed8058f9709a17eb99feb41ba716e850c4ae7e0a5cd0d5d3b3f63d6827d0f418436945162abf99889a68e901724618eb76a69610c629c77f3daa443b135576aecdf9510fa38b369cdb43eaedb612e7fbe349060d9c56042d18cf275d5b3c7f1e420450c341e64b6719cefdb17106db50d606a99965760df88801e287c5f1bba45a2d551dd37860ed34a1d48c72541abb1feec803d06cc5e66ede32b09019767c40103ad72f255a859b7cb0178ba82e55abe6c9cc74af74de51498a92eaf4e738c185a30cb537e279b23e46bccbfc82929fd7b78d99898766c222492eb294e972e47e7796fc89051b0dcac8b9a14a458ea58cdb53056500452412ec4335bd3aa908cff200740c6df355f954478822c1ae27bb63b1a5ff0647f0d4e4371d44dc5af8baca9cb666b2fb8f73cabc9f35fe811107620d1160ee76c5102888c372c3dbf7daec490a27433cb8cefc0e5af9accf3beb0a4d988c174cb1ec1ce2e13e88bb6059b12350b5765859d3eb199a814410ee60ce04823813dc43824d3d28dcf62c31a0aa70b630ef5908282b8bca69f6a731eb3d1abf0207372c6166f33ad43f0ab0f8f9e04ddc73881d1fbc8a2316ad4cfd8b5d9660bb5b3d2ff1d52149690953022f706c2a29ed34fd32325119e04132d2ad4e29b754829e53c68d3ec476db77791c109ec56fb41e442acf1189d9d8541237bd402baaa3a04f87f1e2f0fc76ef7bfc15021863a023704d021fab0b73499d4237a78308096c509798e683b65a37cbc12f9aa1b2a3adc7ad1b5ea81a57e678405d9ca6a45711137a4be3d31d15084a107937ba244ce47293a7b1dfe9fe1dea51c19f44be616350697d4fd5ff86d5a759c233c6b35b4dcc436d4caf5c5fc7e71b22911417b37b0c7d1c0033a4914fe7aba860da1aefbcc6a4058bbdbbdeb1422227d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
