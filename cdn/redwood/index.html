<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22b005f2859d1a7a424886d192384765f7fa40729126bf96edf194d239033230397af98953b4cc20fe35bf2007399f6cfbacc9c71a9860397fa3a0561f3df839dfcdc195230ebe9a30baac6eb3df656d7f451cd7c700f7e408246f45fdc844a7b911048412bce422b07e48bf3cb88884ba4a772bcfa8bb5daaa2d54591c425836fb11b6732320cc83a043e361a429a56c60a722feb6b9999bb5e3bbb67b2ffbbdfa32ae580d2b6d22aacafeb728566490a970e0ce3cf41d46b4944baa6320e6922f15b0297ea3eb0810befde20ee8dd22f5d466b30d68dca32b18d63224f9621345601754b7fb40eb64d83e74bc55e233c5628993657f355ddb3a49e56f338b7b5a9d13ad450d349d55eac916f8d40fe457e928c1c80b14912adeedf3f258970100dd0b82a3aa54b707450343e0bbe110a149c69c6810eea47af1948ac07209f20c55fc44f15a4ee5fc490aa04c31bde741ab2600d46d61be074cecd9dfa6e973d6bded988d6d4c88da4c2040380259bdf7996aa507b267520fbb21fee3e4be618a497ac11a47fc9a4a18f01520c92d816e8c0f3746451fa5cb0a0292603e4450611587fd18efaa0a6194f4d44ee144837eb4da1d6124e6312f9ced2befa600b6738fca0fa9e6d8c58c318897123d4995abe6aaf616226f15e75e9b5cc6c2fc9be50baa159b7a1850bcc976f458512ddb88c22130ba6a635979fd4bcf70146e627f1d32fbada269249dfe60814d4dfb4e6a7c115cb228ea27760a09199ab4371c39431252630d7d63ea6c273884a935577e4c14c1b24bbcdecce4054fe75904554183a9b0b78f682a4db21b86420d82e5f5f926a5167f7df39043a7a6e48e31c73f38c8889fe33f16470df85bb5dc34e719661f5ae368db55637a11559995a3d0b8bcaf92c882f26c75da18e09df0384dada5365778417583b55fac588fca8b7267eeb3faf08d4336f07efc551f01acea5603228e649dde5746eeefcf5c7a814344cc659c484186bc78b01caf40eabe1637bbc16e86aaa35caec705f864ec5f50ddbdfbcff5c7787cca94c15cad2ea1d9ecc59d99cc7595ed49785bcb67d44e673a22bfecafec378a8318484458fc566ca67858eda8760f1e1d4e867f7bb71a208a394904b70e681898da00900cfcf70fc81c417062501fa0c046fb89f665012d99ba8c4d0d573aa6187a0e9bffd585372bd4e5688f977060c64efa0c0836d2d2c016301f73e42b2c620ef1d8a6f285511afe2db3d9d794da9cffe32da9e83e5c67ec39e1eca3365ed8c9d5abffdae5616809821e0fc1e20a632bef4d278f19e377bb29f4d323972be26c3107e8eed44f027fe3df013ac0d21bb2a5e38e74ce57f2f13f4797b2dba88f1a9283bb16ca878cb37533503f35c8a29e1117277454f52957882452cbd9b0a420d7cd4ee6c947769cc6aeb7e0d9abbc25d03c8137d277810060fb3f1a2353fb4b57ebfee78e69077efecc5b5014ede6f268d031be250018803b090f50da6df9e4a39447bbd26460cb39145b781ab276d977295b936981524ca5717229006e28cad092d1d83bc49343722850c838ce6742154118e3ded73046dac937fb8df97b8c987373e02697f2b01844e4f278289ad4410a9046b09bcf4511dc21c4e0aa2d780a2ba8db748d1b390f327a6349fbe86d7c552fa1c4f96343e100b4adbf554e1d5c5e0f083be5faf8548b36234e58b9e5e7b81c360dfd94952233919a63ca9cbf6047c6a9f799d1a300f1106c356935698f7367d5c57900cb13cc4a4cfe12ecfc8492c33d64cebcfdd40d965c51156b29fcbd5985f95634f6b5a46aac15689cdb857ca7353c382541f94335851b1b2f3055b6486357086b389ec65c4b1925767fd1654dd6d37a912ce215f2a9533624082699739ebf47f7ad1e77d50ef1956c5c3180a0f92daa7364606bfd0d8ea8b4fe7f47633b04869d3b2701dfc6a8ce3102aca0fd1c847714620c9a4b2eb8e061152c64b883bbdb0f42b37fbfdbf132afc1fe5caaf6047c28cfb6fde2ce025939f06968ef28d5f5cbaf3af2b3facfe0acc143e645cec1c4690a36bced622f1e5bc5c15843d1f20de1bcf7ce75e74d65ac5eb9496794313e2c9eed245b29c99590ec458aec6a9b759b83fceb077d985b793e9a69718431d8f74b38be242cbfc04de16dd2baa051efcbd408735f234b1f7c39bba718af33d437fc087146b97cfe6e1970864ab20c9ee88da503c2b43608b8d2f464d885534ad227bcb2d5d0840057665a7e8f9b16437124b7355aab91c4613318e9401c29ae8cb5ed57ba4716380a7a773cb51514366e1142352d141c6cd4f907eca3bf152145b44c7a784debdf37871037d19c665c2d47e4a2c2c55b20b51dc0a64ea67ab6a560811d307249e73a0176ea6efbd6d1d7b17de7ca3540b05cdcd7df54587586f12a1acb1b4540b23528aef16ddf742be4259f4b1b7753469aa61bbff4a77bb7dafdabf9186fe40904c75dc250d096a45e077520c56057965b01febab68d38e13fcb636082adc973748234cbe8fcd0129b32f7ab70bdbe48c793dbc3c74d1b398bf569ec10eb10de05648dec71114f881d33334b89435033900bdab8419551480470d8bbe5bc567e4454b9f59cd87e15dc7caa6e0039e6f2e34fa851e6419cfeeb8a7eaefabe23b2ec670d25b90f191cfa00bf1db1b4079cc551910b696c73a4599389fc4f59b6a2f71e83069366174175934c8a467e5fc3d2e8842f76a522713aeec02987363f9e6a64dd7cdc20b2e70fb7a4437ed1dcf573c108d1ca2047664abc5c03d4ce9f3756847a7917277c78821de1aa5bc94c78d58896c0cbb365c33ea2565d4f20dafe94e5cc3c1846a616b30796a6a62ede32ecf5aa2e52d95a25f835a7c13215edd8412845e1181dc6e6d3b0205bc0daa9542286a935978bca836f5207794f890ae24e3c8cb66d92ab104c2ab1644179f64d4046d95bfeba09b6acb6ffc712c3cd921230b911cf4d3ff1aa6c64b46190c381dcbca25f4deb220dd95d159a6b4a2bc65f1ae7b082c25cefde419cbcec5b702b5de30f7d8dcd6f3a870ae37e817509285b0bbbdd6fc2399863662d8bec032e5e09d18eecac22afc561eac386b3dfe98a8f36f46d407960786bc030ab0007d288b2779d6127ea486a335a8a77970a19768095ecadbd2312a8581bf8f788c2d17f3de14077ac421663f92059f9a16786d51465540498e309ad99b3068b163c9e8a329c369b39fe2ad8042b86a3f9a757cda2efc047291429d434f47e8e1277e366d48dfd3bac94ed2cd61de7bef8b8efc1ac081d041c26ff127ead3b68ebf53f86b3aa4652c322622536ac0ec3e1d462a73aea82b992cf490136f9e4ec19877cc0aa3b57206cd9081052376991d7e8a92dc4fa891669be971ee0d8c32c25ec9934dbdc130b8715ebf96a35a26b33c8d893fc6204edabb8b736d806e0c31c2bc75ee907e1d8ca53af3eab6d857cdcef9f59e9fcbc9fa8353f196d320abeef24923544912277e423eb8d022507691f45c392cd460d933aed508a35a8eb39479e2b52adc2f0330bd8e13fef0de88b82b5f29c898adf2b1fded784c20c6c56e5974187ed8f7e1c9383cd7a093dc89137bee7871dcef3a79dee544f7f402da0e9e2afca2b0c9531ec6d47f1392047c3cd638d1d989c0b85ba8561cd6254a7a773942288c9da998408e0e7b15e5c57614497d54132c8c8d602d0ca2526a1ee8f72ff3cef8379267437ddce683311b9100e15f0100d392556d8e002d0067a1a72cc96e7825cf4c930ea15e0f4f46cc48d829a1a5db7bbd9d4a19da9604cbd2b389e601ee1152af30c5f9edb6072972ead7dbb0d4ce57ef697437f537ae4b3f180d910fc3d7f7343720d7c7245658f3c83db4e609422ed272dd51a833a3577544d13040adfe5e851265af35df28ceb5e5f80303ca56e5da252bfb464baae1a38184f14faf0f654017a6f4db828c34c58a1bc24cf7eb11be179d2fceaf119979775ed6b5160c049f785f661c3974d2e72bd4b4c19f1c97eea36918e7ecfa5ae37e3bef803d7b3a2ad490a60d1512caae71f67f8e98e4d34ab5f50f339f76eb3a6df60fe72464a03026e44e112919142c75472b433da2d2fdfc6ff397a2e387f9e7a7d8ccaeb43338fb220c83d11d378f9bf1e38c277dce083b474bf7415ff4813e1bd246f9da0a4af1a571f56f3af83998745e894cf8a2f4d94f8d17980af718c455b84fa59c93409353a778168f23d0db67d38ac558d0c9acfb6a357e7045f829996486da0cfeb22bb5a1e692df1108ab082147986920948d5da9d3803d8d479aff9b25c4f28b26280fd6d46fd0be048762ed1d1af28767bb1def33c22ce3544b04ff3d761bcce359f5e211995830b4641805b4ae6163d79ae19817cf8f6d9874987d065d7221e274d2bcef07ceabb3126c8d87721f7eea529bbd3b379e78255e7bf264ab66e9d028d6666195c199a90c0285dca8fac82b1ff22f9917e1b7aaf8c7708b119bcfb69e04c7e6403631068c91afa4a1f7cd424fba023214ac87b1a5e50197496eb3ad03b5f3441c44daef54bcc94f79881f99659aec7503912f1bdf9b8d2aa66e788ca583fa922e6cfc7c63f3f055f17526f7884df822b30efce69643edd3ad18764d2505ec29caa8a5d1e4176958973877c60234af0bc79d6d93faa86ba3a5c8a9246784497b2df726091f1d6474e193e1b17dcbdf1529ccdeceef0987d42905747e7f719fdeefa7be1dbf4f1962e92046a6d2038365cd07aa5b67cccee1e13143de1de3a2250c8918b2e130252b5667491e4e0c91f1517a332e71301e56876418209ba5596406e679b429d3bf879e5a1382fcad0e565bf67cb571465954cfe3fe7eb8e438a3ff3112eefea49d2a67ad92a83e788b328914350b10a1b86b870ed1ee3a2f60856151ffe01e7cc806efa2f3c5a6fc6cbd11234015c8e3fa9b57b33853373cbd1ecaacf5f48ee7ca54376c3430202220e1b62e7795a9d4fad7a4974e4819cb14341824e9776d4142963fca4601945d262809b9c256567ed47113b91aaed57610c6fae7b51a0271bd4a6f57da1c7746a7bedbf15b88af269847324a6c87faef48d99e6864730b39de0a6abeb567c343dfdd5505d67cf48df2e6711a883e53d324ccc4b86b4c113b0d122b048745a0fbcc17283dcece82ace04a1fc39a4ad9ec1bd1fe89aa7c3c1ecd8982dba82d52736e7bcf3641ab52cdaf0e5a124be6b6400543a59d712fb39099cef9cd3f17536818a175d30f75815ecf23c35f4186546829f828fc757c30a63d51e86b43baeeae4e18abd93e61a801ad2767921e94a21b85c3c971fb6b65ec1d9cc189645fee4dd693e1b45af6f6f114c4cb641abf78db2fc4d94156755e4ad5602f181ee93075d03da474c789cef8f106d1207827987a592676e2fd35f504817000972009ac52302ac56466d410cc58baba38122cce93efc41f3af2b282d739f16ac3c354314cdf31dba6f9625c9745cca831a2cca0e05cff4a09274b84035ba23323d6635cc224b9c23ef4e4a6a901619d096921e05535480d0724d4658da1aadc9d143427be0483efbf2c197cbb81ae9e4ac21cbfb126a2d97c4655308bc8ad8e97404cc150fcb24fd2b8242acf014d8f7d55a18ccd893ad06b6cab560a75eb95c57ef015822bcdb5d24cd98215da9436c82fa06f2c0e05abde77b970811ca2119bdb66c7b16210172d7116fc641cbac4b1662fa9bc1d043673998dfe1c09b3dd31e5eba529d6712aab51acc1e3032131b2897c958459b74ecf631c25b370171cefaf8e6ce19ee64603599145394689ea09204420674724ba73e631da5eb103479f93082e2df135af3123a8625d58af86bacd86479023ee4cb80db9ea9735e6bf1011ab01c9c8d3156c2bedd1dad3d2e6c2ee34b1adf61bf808a1c37b4fa409df0774536d30b8d6a6df26a5befffc869cf123d594cda7181bf1feae3d49cbf22a41409d95cf3a7ae5a337e728517e9d75b80a638a78f7ec637157f1a3ccaee0beca989315ce2d7034485a1d6184d4ae4c0a4edae7fa4378141fd7ea3bc122f8a5e65ceec0c63ec6035824d2be0371c257d27c19a8a79b7aa50f5e0c766aaf055754412ab7b4b1db83231216292757564f1192e3ec997fd20041f4d51038d8ea686ab51e7bbdabe5cf0bf464f81de79225528e2baf423681aecd142eed6276527ea8f8a3fe36b84589fa227541a47e19e9c90e0cd37a3028504ae0ab5e22765190dc0308ef3796f52441fd35e4c3a2ae4fa18e2496b8cbd73b8aa82a1c292152ed28b20e06151e7ae88f19a50a4f26e4d5d355e5f16bcb23b5938519b3e0bffce3b6670c26b081add9aeb84a06eee6f7b87f37a7a860232c64272929f61f6d1b14fcc273965c2412541f696952c0b29853b47185e22e469814931bd0a6aaa71c77e2601deade7a22f827be239970423ff94828d8ce4a95dbc0c068be925df7c67b7ab048ba52f825f098e4a2cdadac005624b7adb10527a8ca7c0d42edf0f59dedc322c2df835d9d6a5d6b13d74a766b51c87f446d14b2ec76986cb4f7f075615e5764d1a14e7fe61e1db966e4a62402ed079c477283c87e6bbf9f59fbcdd1b0faba3b3e777bbdb8d05062fc1c64ed5323ea72caec837ad9d66cf48a883d3803800a5a9028ab31cbf4495a53c9ca34525388a0bd7b6183543776186fbd40de174b830d42e3cc7a59f866f9dec1fc50a08021781eca0b64e032d7be2da148644af7168ab54ceb1eb18823f23970f43a5ffd22ce2dc9203937945089bd2d1faa1bccc118a2346979cdb518a8fdeaa2002f85b86a898d5bb7db43e12c438b92aa5d87e755402a4180ff2ff5f8009f0e9bb86fba75dbffcf3bff4d32b050b1245be9d30ecd5d57d482c86fda9addeaaf6dbbcf4faa024acf677ec5c743c3b80ac60f8adb66c69182e660d5e2f107d5a375ae55b6e54fd14fd96311b048d6dc3b53bf8c2e92a5626e25fe37969d75351f734a9a2c5de9a654f57a207b845e66389ff5e097610acee86b793a0cd1f9db1ef5cbc66a72f36fa389ea05b7f4463c9a5d2dd916f59fdf7ef771b0b93c8b7b5ee2c4dbacfe32e33c20cfe1d3f173d70a81324776bb04ab490817e8669f6d92b2e609afb2003123f9d99bf57b89e215dd9369a41ae2bd0eabfcb82d374c92559029d1cd2ff2b3df27d9904a07baf7f2e33f5d668a5c9f29b4a69cd2f31db17450aaba7fb4e115da289a5f0e520b31e77762e80ecba9e4aecad6c3c512db3ce06da8d05977455aacad99713038c8888cf5e7eadbb8e1313fb3259dfdbca09c70c2949086b4047b334872a3fa00505259e6cc2311b0757d47c00aa7907606e7434e0ae974d2e55534091851bda08deafa13fd0e836acd036143e45349f82b26193cb081aa00c94234f0ed56156c842cee32b01467e25f239d2df7d3a5a959178d41af3631992830e4297dee5dc64fb3245c6f3085205778451ba0bbf43b38d009a3cc66997515b081267d7f655a82c7286f2dfde30e1dba8d581b7f46ae8772ac57ba4290b08f0121ca34d9350166a770d22f741738dca4138581fbac97c02a5678193cb044ff4abe7f1cb672d021dd52fd014e27ecb67ca1f0e2d6bc0d7ebec20cc6984230476397b7296f80c66c55323d28e8e25ceae16c125d02988126aa028f1ac69167ecf2f32d368fd66461fb52f2c372aabb395b7cb884db88a8103eb513973ef12a9951ccddeb6566a2a092de36792076c59e777cee62717f859efc68670938ca3eb9cfeea0b5d9486a93ac3890ff107df11ed194efa37ef456cfe79d1ccaf631569e8b895399d7964cfa4fb2725d337ab0b753b06714a2223d522258824e64389520337e4f10e9a4e725167b480230dc48329b9cce2161428b155eb5c5d4a58f28b9b7467ce056c733789ec34cbbdd47233a4515bf8f884a327e40aae3895ecf3583051dc1a2a9d14461f12e74bcdb250dc2bfdb88579acda38157669b62bb52d872881d99d86b8a21b2e976764878b76cb5b1f90586e7b8c3dc58b701195098c7d23b456fd57fde5d1b02ff3337a66862b8fa7fd0ba46be04c13d04830348a73300683cb8f430e14fffe4f661d27b53217be5a1580bcef46b183e2c98f60aaa94923b8a1979462450e2ace3beb6dfe5c8a85823c9bbc7434a9b529e17f1845653ae9f45284a1e46a2bc7ace2b2d3e13981e5e773e7850fbd932fdbb640146053d3924152e6a61fdf425eca7ca3f05f5924460e1ba17eb90bc06fcff0234cb8004bc35bf53deabc82d8b35083d20f954b8dc9403d7f899127c551a6ad96fc03b491726acbeb7e205b4e82eb622e85c42045b282d00c15b7bc37657b954349953d759b6aeee025b4877595b7a12b4e50c0d2c159a10aa2cfd657e25d9f854c21be31bb0fb866fa450f116de2183daba6d46b76022e559dbc4116804900f0d0047e1a3c505def9c17c80a29f6d0dbc04cf012c90d0a2ba89ad78f131da2cfb49fd4cc7f164338abbbddaf12791153e9a51dd7f7490912d9bde829c05472c7fe8ff81f1cc1d97c9d58b46cc59e99dda76cbecd33cda5563c12eae374cd518b863a141a5035ab316f27fc2edc2b4d4693422ea5f7e3c013d75865d7e03b8e88c06c6f820fb5aaea75b414e1e93eb402629131bcfe80adf348003cf31de072eb3577b06f2adb9edd322cbbe9f1384c247bf6422577396e907282fc4d530a286110e5e91249e1c87a0c62caf1d12acefe5701f46023ead9c1255d981b1feceddbfd3d79088530f77d1f307d009821875aaa06f79351c45a7eecb668893d95a34d7ce860d3dd10b9f56bb69698ce81a0ec8fc6eb59fc963c71523806c62911b2b6a1749288356336a1d6b49bed98811607e11f989cb2450ed463bfd24dbbeb805860540914a50939cf8955141e009e64ca6e3d7051fd35e8ee43a8a53a34bfd738e6fd5f4d33f883de48d78b377aeecb80e957c30123510417dbc50e09a2c1e52ce0e80c4bd3130774e5c9c39861fbba6d91ac321672fbeeea59ec12b6d06d488a63f446cc3a3dbdc49b8aa0e5d615009fa81bf4f44b6ddfcbb7a912cc844988fc2b46c98024fd0c2fd2bb244a7cb8a516ad11a8fa5eac7347f935608a7512108b7d41881b83c50e7ac8de58ac64fd1719c3d19298ac7265f08fb23a60bafc8fdcd5e1f61b915f8107f734b4aa33de81bfd878e5a5bce53f368dc58104d74de8175092dcd12037a86cb2e8f0fef0d7e66e035c3b9444d1aa2817987ad73e8ae3c9e8b87ad5e1f3cde396457b1e809b3997909f3f521f52e6726d40be81addea0f590b00c26c26bc4ed67963aa36a880b969d2e444be6f4e873b3a829eddfe235d7a06a78411905887c5cfd3fb3fba4cc40b28200be4b0a90c59e50109df6dd4fdab7500f5a7d9898f16ba45f3114a7a1f2ef9a107d997ab637f3de8e97401f8caad5348ed2ef6f2fbdd04a3017de9dfa1e68a4ff53f528736fcb4aa15c92c14e94ee7b892d1f03ed79920cd61a6a4b4ec5ea80c79b1a336b276938df73ce115102470bfcb7e0f6108aabc039a5e3340ffb9a0d279b4be787687e9efdde95b8150c72e5b8817ea6cf2f0bb5a7d7ca435c17fd76cc88f2fbf8eff75663cec2ca044ec7810fdd0af31ebb28a686b7f69cf4f7ef7d3d8d7bb9da9de37cc5d09bc1a8c2ac3ec81360a5653c3c32f942d8e5e73cb73d8755a3ca2786636565aabdccf19cb308fca2cdc765511496f3dfebd72edb5efce532afbb99886e2837e92ace8e8c07d420f4eee59d66fdfda02737432c2d4c1eef70e073b8f4964c43b3c3a70c0e8614db7f6385da5d38cc37bb2fc6aaf96a305a47cea4bcd2bea4ce0e3a759f0c9aa9766e3787486e5292d576dcaa873cd105bc17cc8a4cc4f907e7a57f2ced04d10ed9bf26f70214f647e995bb2b7bfa03b3eddacdbfb57b1b0425f8215d67aac03dcb4d4de262739926d177a889dd97552218bb23a60ea1cce0f227a62bc7cb5f67eefebce5e5a684a6d6d66bce14bbd8923004b0f86018c1a53b991fd134ac3d7d3b248df06619fc8a4ec621af15fcc4d47ad586e721b1a49e9481ce300cd73bd525808bd14c222158a8de91c0d8cc71c776eeda8c56b4b92c685c2e356591ccf440f712bc13f18d24709b93249e4f350acf582e20612693b77b721b61922d5a8c3b30f95f0cd432e3a0d026d40615f751a96e28b4515cc43062189ffdf1c9284e0dc246e4533f80dd995da3ace0bcb51a6e57c7e22f16e543e7d3d41f346c70f68c1a24c78af664713d72d7ccaab776dc23e7ae80449ad6d4fb96fdf9ec2e865756bb195d1529b2a5961423f0c3edfe5e8292a5cc1e1ad4f25508f081ce1e46d2e63792182f77524c52cd02ee14bf0633fca894a988d13373108900d6c9c0b59200c755d3b692d0140dc795cfaed062e07d7bb86aae2ba55ed075a8a5d10d2e9f27f71118eddaca96030c9d891ae8071db4f13124690eb0f6ca6ce8bf2dfc2eae83d139578b012a92d967009b504eb4dd02ac4316df6b57a2d15709efe7338b002edcd65685fcdc51d00b619a8ffa34133eb2880e0d32d3c00b333130b709ce1e11c95810ddbaf80aa54fa577d69873b43a1d4d5bea50534805f425b4cc71b47af217f4ebb72dd87c33f33cca02588d4828138c43abdba0bf9de41ca67eb1d2ed65217f2b082d57d14dd1438ebe3208dc1324a84c82711ffe153e0d6f0f25ed7c825ee131451c53d4f863327007b322e8bc1446a27a027493b4efccc764aabf4333e2916e38542d4c601112686267e4e014d9a326a6f1405d0f6fbf166aa51248ae30460a5cfb8fcdee56ffb3c17e52e8ab433920ac6913aff4c3da7c0268556f053c2975f536e611cfe7e068e06daa9c6f545cb9bf3868e90d7f6b86d9fc48be55d1f6ef27a939ce51b054a850e5621552c099312223448c7fa814586979a1e0410e3613e2d8d7365b7c5897b0f65d283572e1b1d323a30eb8ba98107efabffa70981df824f30dca9f1db21f1fd693940fc67d0be3bc568d4bae7ffd4b9d7c839606bd1a7ea6d7b7f74f639143381549501f4cb446672aca205055252bf430b305edfb9c53606dda3afad66321d730e55e3a1b0a65c1e4a5408729399c8fd23e8dadbc1e74be60b56a2b7a40acc984821bd89985ffb7c87311e3c69da4828d6556485fad4650814782054efd5cb7e918dc47f985963cb83c400f8492b06c0d8aeb6b6bf4fb9beec40906185c2f03f8692e0265f2f3a61532ad9306d207ad1f3b0fa4d3541e06b304002332d1ab573565d68f675a7ad7085bf65cdcb533026291bd90952ec3040a80a31006bd760ee2e5ecbb90dcc994f0eb070df53117a271c5cb4360619c42e516942d5ed12a81a6d59154ea76e6ae12c3059d20a91c59a85d9790b8b71761bc347ae1b87915eb8d8b580a18687a7e34f474033254659a0bfb70e40bf75751f5e776fd0792ac522b2fdb3c64e4f2b2cd3dc5804e961563e5a722947ce75275e004d95e4eefa4a20c53ee70526b315c8f41c6bb65adf8f90b93d46802e74c89f07d7ce9c207d68c4681ca7354256796eb536fe3fd27d828b521c07b4295b9459197ebb245c6d7de5befa86637fa8e5334e10e0941a44535a70fbaeec2663d1817ced3c3969999cb0743efd0915863b7c91b91c74f903516de95d6fb7b5076de1bdcfd0092140b9b36c201c051810fb00da9dc865eddc3a4bfd8e654b3bf651d131c013d29b33597b8df846c5954a2d6e8d7fd6fab575321daea313f83a1e31f43d829480fd00408b0296fb38e9edf2361eff6c79841d76d7d8453a4fbaeef911002f005e2a217459995390029b8c802bf8445c61083f39055fa26fe33c07c0088062d3369fb60aa050cb444f7d7097d33174fe1658b04e3511ee74866694cda701c57a8d73dbe5f9e38071623fdb09b70b3ff0734e937117f15e3f224194df1cd042a496faf78c4f38def77c8636b92298390bbf0d376ecbf94915c15a75fd6938aa588520918693614a3490cf4b0ac1ff587866514f4e709ff1508cf91902e18239119bc9e02ee4af1efd3e310c318ae5f3050c2d630d1833217193d2cc4345103a4c31eb999a51fb59d620071a691fffa44e181a21bd3f3be1b2cc8b312eeded97ef993d9b744b4c7b93bd917ba236ceea739b389ba9df35b5a984d0d08a2dabd66fe510eae2276bfb39205f0a79dcbe9482105f9884d106eac6809114df5117cdbb5b49970888b473b71a4953983c436abae9d785c91cd57c8fa90e21bd29f4e58b47dce49af00a7802d3369c564b2f1702f213a9005d096097195e67ea6142f81b59ac2af9e73d6bee40bbcab46544bbd58db0120dec2002e78a03595e5a6596cd4a1dd0c122acbef5ca972883ef868e00301e615584da4f18964ec9284fa149682177979678fda87f3a6eb84f1eb7c7360c163c6167f0bb713770cfeceea62e874bec69516b72b9c696e9d3d6960d37f87c7c59dac6c894999db84d06501c58b05263e0f301ad3ec536c1f1b7cdb9e712c3a384c11267f097ad469f6ae85962708ec11a2dddb7f56f3555f1f7f63fa7498d2f63530d02304ed6cbb22ca6f67083f2f10ff32a3f46782a8c52571cc538a7bbdd959d505f895bbfe2aeb73e37cfd6be6ec9c68936cbcd7650e8d0387e0be0e43e90a6f7945c013bcb8b3e30f2a420d0933be0d9f9a22fb40593eddefb87dcc2af56819855d40b44a16593ffee8674b65c75e289a823fc5a8146a5305123a7ee4beb4854d70a043989f7da604e93407aaf8450e55963a0fa32418c2ab5c20d2abbdf179b68ed6258500faf26d7f7071f0fbdafc280022f6cd11203f8619b0b16f9e1bcb7a2e1e450b827349d2a73ae9e626be3cba8c6a986450a92412c3c455e11e0c987e3b7401513bd8ea666f5533709b32c61d73b07997675c3d359be262f394d56d1e7f23904b413b85de28fd4c577cf4ed135e157bac4faf0cb53180b616f1009fbc1c8da62f50b310e3da84cfd0eb8c6c476c0340ae33829f938fee4c83dfeca48a4d65dbf05e4045e8c32b498e58546c448d772812cb7bd6f70b3f6b0763f02fafbf8acee5d70d518c4108c8b9506af6a00899df7ba81ba1e9c23a2a2e73ed8bdbb058a30b710687f7e4a4f446030a7841b1dc6b6b214fcff4b596b9675cdcdfbd39d88b93e2be5b41e341d05474ce9132ae56870f397bc909a3986c4af2250ea6cdf61f1e8dcf74eac4170667ab4774488fa8074b300bc209f033dd5cce530ddd4a3c32b3b8006a6782f9ca9d55ebdf25f548ca732b34499143140837f8ae1c172a7842c0d80e53f10ee258ff8b1542c208c3165840f9467cc35daabfebe46cf832ef2a8737a90cf8674cb9f9fb3d659a7f3c22a35e284e0b2ee6b91b41fb8d2c8784338cba350a98141c33b5039333092fb87e8c160da22fcc38cde9464b4fa7cc9f96604c00c3f9725a8658daeb1c2c5e09d333ea733c967f8165dd07071198e5c168783cdb3cee445cf7c0b61469b030e2ca43804a67528d6bee9b921f0725ef8964c17a580098ba2d8488a273b99362f7800704bd2c70735685834ad1fe60d1c0cd6220e603ac47f811c09a9150d2d813dc24f76842c4b1f75a36d70d5478ec74f75e30562da10e426004474b05a193847fb722679f338e88159c72d30823e59cd900f1648b88b8f96678f3af9a9f1bc37b8da6b9d053810e6809ce34bfcd55e005e90b5adc51342283ac9f87c5fe2bf37b73a6fe9d2bc4578c3999e0d188927e75d1c932f755079c2e68627468d397be7f18df03576e7796178993636210e2a68efddc2b8d8ef3673a23ca659e9caaa70e09f69c3128c85417bfc6d7180de6c2e5c64921bbc7d06b1ea41918bae7c19b2725c29a918487dc549065fabe9d6e4e0ed4b34245688051b98234dc9cd8ee354192fa9d0c35c83f8f55abe2054decc9fcfca6f911aedc0d4917ce8cc6b2997c29144c39898f56f9c45c78ccaedd986d16623cb3c404690711d709bc6e34388a7821750556f6dec2f178975c00ea5ecb94783246e6cfd5a6a4e47ff6dd2cf3ed607a6936405d26cfd3aee6d7e700fde40136d7037ee23dd0c2462f35137286bf5b621f68502c3370c5bc2aaa8eebb3131e4cc53fb19f5493bf87426f8388e21b1379bd0fa4042c8265c7fba06c8675e76496bd6f206e78873477bd6b582dddcde745a8d8d1e19b128692f5795c5052e60133e6b73fb8459fc7d18117d3a02d74baf45b283c50125aa44b94bc563e4e6be65c44a914ab2a6b5d7829bfab643f57cb31da117832fb80c1a2c6b4940366d960819532b28a8b3f5e31155e59710c5ea55ff977710a4d7e38dc7eec5c112df47339afd84936aa37c175171aab4f35d2a9ba1be4365d3f4414e6a860df8744c156636d67338c8600eb3d88c90a7ffac5f6376283b096eb1e6f2208c2a639ac0ecd23aa7e9d8ff524f50da9a23a8aa9c4ea57c0c15af48644a25f328eb642e29ecc5749858c1c3dfa341c17d19bdf15055d128f64330188c2878f537809f3ee6d1ba70690c774e3918b0e02e0056c7ff885e80d1c134e4bfccd84d9a86c2641f6991d93b2811ceab9f0391babaf9a000e984a25a0d5dba7eee5f89aa5a8a6db19b29c0cd9a27bca2ac4daf7f578e32933362c5c82eee45c467c9d45caa7057bf8b3967f594debafcdc040feb157c7a0c94abe7e0ed1180517dbf35865a4e6f519445c18619454b0266b6604a6ab698e78d9c1b1f619ebedfc6ea1d3f17c998430db2061ae7d81e2b198fecc984f994853f71aba935ede90e289f908e395c4ad7ead4b3cda2ce757bbadc67616c211c147f384e1e6a2c7613891d58e92d8f6213371b4b9c49262d3205005b403aebc1a85099e9dfc14d6d08c7afafd1ff5bf6405c6ecff03b79f200dfe0ff909148e1cce37940dac0f4538e9a7ab25a658884e7533069e96c8d66fa24f0263f3db4d03360f66780bde0a4391583477c03f82e2e1589bc40a2a03c41f5c6d1b8ac74ddcf821fcf56c4f5e837a6598c779eb1d02b790b4612f9842303cc7ce7aeb7d1c2e99d2ef025e1762076b5b7843a325b3332b8a5d891c79ae93150d92ea073071e035cdafb47972b9aea8e0f1203176715a75efc3c4650e04447e86a7fe390d6a146e43c2e52a72ba83182e968ce08111deb39203463b6ca8ab7c418633687fdc50f147ac60e12b07896b57aec146f254ab517f688b6c17570a5b9a43e960e6e53cc4d67cca1906890291e9627e1c6e0bfb93c0c98094cb79b307f285352719b0addf7846bef90a443e8406c81fe49e7d34731769447ce783ba608b905b131381c8fc1cac2d37e50569d7ae22076852090e323d9f8e14cae57c94f2c3722d6222eba333e4d37e9cb6511ddec0e6c3300db26ce719209a1ab5644905b48c7e0550f13ebef3e67ba17566f135b2c5b64a73084f77f9f546b46ae06723b91eb6b36b2faf52c178875e50a3be9d6ed4efea43076b2dffc63989ed891df9901c8f2fc46d6cd63afedd59894fd49cf83f582669e375041e0eb2c2c8ad1e6140f50def95680ef96ced5e9402b9f3e4539ebec5954c00c2487075ba3720f7f04593e25162828715b575661592aacd310dd80994c11543d29c4321106cee84c16b3e7db132e937afb1120dd8a8d3a2f66df72c3290472062731621205e42c56cb5ed87644a6c03c38144fb2e3227b85e7c211c28dc4874482c256c3a4b37508123b81129a13aaede39e46b323f9fcb6f6ef4ecb5d05b8da6961ed6df4e2edd68cb93817bec549912520f7b91521cae0efbcaa9a8917cfdfc6964f4c4636cdfb92c054939beb2ed37d75475e2bee80f95fb40c798fc358f43dc7499416d57edcf69338e2537acb6598b5b6e77077092a4363ac7d7d2626a7a0f60ab0b6943b1f773a3ae313e1515d2b1cac0bf2e193e1b69ba810ebccc84d6fedb2733c2945769c8d5cbe36101e23acb33ee31a30919ed4174db0dc81d0c1d5d79c883b147bd74fd1fc1ebd02f0b10025e20c899790309891de797d22cd111a814a9247cf549a19094d8f8e489d434c777a91d35366117e96c23866cb860a81264b90c1e6a7501f105a2a342b9f23d37df98029c6ad077d44cfb74501819376c2c98d95edaed9d0a36d9d4277f28dca2d0ea3c0fea12792d40db72dd4cf77b3b71d1c08a9922861bed16376c5763834dd04490a11eb05276f416250986f69b26eb4053226d0de8799fd6eaefb51a8c377c37db4d78c74788e8e69dcba5a44a887218100eff26c8502c9530cb1f5c9e4fbd3fb92de82ed785bdafe8cfcb6353900e4879dc53fef47dd9a3a14979723cb1259d0c630058229354bdada27c55bd96d67ec41998c5cadbfc21a44d497a7eb7c08a177c49962906db8bfa11aa604469e72e60f683c10b1c7df2c18c7f0649a51bad56b45dca0cad624da22bf2b70cffe67f01db26bc587392b66eaa09d54a4ae02369c92f6ed1ebd75e36b8ff584da8bebb670454db91feb4fef21c4f80e029d068b98bdc5181389126b508dcfc7f7abaa0febbc975524844fab1f501e25de6cae9e5102c295fe5f0c8614d0349b8af52a5184e5d5c57e8ad2342012fb0be03ca247e82ec280064ccb9f9dc4f8f3e63676a4759e9e83c6d3ce442efa51d26d3df69dd4cbcd00332cf851e639175cdefd4786962b23f5863ad72d7f2bc4711dd88cbab292a98d995a030b0f13511069fc2c87c56a914679b04cf2076dc0a3f87b279c99116f7e9509c4b097fedb025f3fbfef7ea5ea2a58ee762c9aefaa9068572ef6380fc9f9b2955bfba73e76393f2bbbcd7542dfe9f6bf138f85427534cba2f67f1a455c0a053cef35650f748a15ec1be99d9946f677fe4538e50a308771464c31debd22de62dc061c4f16d5ed6acab4db2863f4cf6b511746bd61fe9a8ce16ad349e3f117249d453b592d2c3d8fc576f32808db81516d7cdf85d55b42b2f4a41a5dd5ba636e810fc37d82b4c6958b78e936fc6abc888f551695710c0e9b2f546cd74efd5681b0cdd228cc0138d10e7a6c9cef9f38a6e5fc076760162cb1b3c5ef2bb93e2f441ffbb6a8c17a929f9f65497337485c44dfa82952679772280a5300700a6d28b7853ec4cfe2057f88540887f7ef4d75ef5750bfb193c3ac0a8e016e024416d5b59edae05dded0c058f08180365516b9683fb4041ce294e3a21d8877fb8397f9806fe3750cb47acc886584da4879ce9449383e34cf92f0d5977efc58230639f5d7509b1685335b36fa9425d3d78bf28ad5ea89b3242b899f1c346f7925a9948751bca994e9fb3a550fe3eb54fde12a5d0843a9ff46f89faea48a5aa0ad7a25cb8f41fe19f35caf7574a3672456fc49f327ce0ccfe53211487048e71f94bc8a7bfac81609deec8e04a9348ed5196aca27fa5f822944ea39bdeaa1f5a6c4cfca54eeb5f8bd60918d91c3473e6f1ee8990fe1ddf89828b57af66b6245950e33b591a45669d761574eda28c50fbf751bb1bbcbdfe1848e7ed5787228e82847037153e62c97fb4c6bc63ecb185a193921a488e3c050ef759cffd45b855861b8de05bba074b65588c10de3335426e93ba6560d95081452ffce11626697caaee94e579ee5efb0e8c5bc88fb929b87d956a4bb7ebff5ead9ae306dbeb9011c5b4727b912d61f24d2303b7f11d41ca9c15726040a923efa0b503c6a5450be7712d61f9fd049587a931938fea8f037e33d6a2c10fd00c8333e150859dfe3247aef9ac84cb1e4d066fca90c743f99a73c41a8d5c516fee36e037ee4ca9b893d428c8cc403b9f80a3c3484bcf30c981c06697d8a0045d387b286a5aa19b09839ad17d84a91ffb69f7c1dac00c0885e954c2a16ec218b992fab461262eb087413684742a464b741f1a7337097bf111d6c01859f77dcce7f1224c7e650f15558fb61c9a7949d800a292336b97a563b0bea040c6208a5c1502397001db8f93f1b169735b84d7ece3add8b01d3d3674ab3126e368f41a74ba3467932499428400144959eea700d4cbefa3e1a9662d7b1a5f624c23c5944fecd11ab85ac478a19cdfbe393964691","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
