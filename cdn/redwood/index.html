<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b989b1183ccbe54f1c5d18f9c2835fce223df9c8ccc8e23319ff6ff9c9c8b8b4b2d3e458060863630de998ed26fdca1ce2862a30fee01ec6f09fd050278bf567a62fb787ad33ca950459691e71201bac75ccd283024b35459c8c2ac3ad9fc970b3e40326c004332771614d7a5e1e21748ed6795be7a7016b699d1937ec9d0aaadddcf9f4df620b679474dee5d2ea077c5217425ba2fa1b00643d300f70d09c3b53433a3bec4de3bf7dc29f18435823c4afbf228da950ffe29bdd6675884814b88d287436b2a3ba8f2218369103026e3f7a6c1f982cd277e04222021da098c49825b6fe5c9f43cfc089da706efea8eb114a406f79d789718f03b82f52f125d600303d867cfc28a2933867f7934a85d30f0a09c35f9c5ab8a4c3900c745bf5e75dabcc5b5701dbb79b0adcff1a874b33fccc8f8b9953b1393e274231db2f3a1526050ab83b418a57ad56d0cce442ef9959a093e284894467b80ab41da8441c3b65489669569712bf120d7fb641d500ad2bc6ff750b019c05e531a23ad061d5d002c23ae3c9a64ea04749bf79c7f408f8b7562814752af024fb359ef2ea34c45bdc3bc35636d15a59346bcc6ca1596557768fe6a95b6a4c188085109b57238ff7d06fcf91b223550adcad582eeac6273d1a6f3b33e9f5487ea20ceb7a16bdf72486930e741021cdbb5afef4055b15b13d3eb62dce0177f4e5144c61dfd9d0d00216aff76790a0d8e26ca1d374020a1d3465c2421b43e323eb8cbe3b6aabe1284593ef13d63bf1d1a3d004789a8d72886dd92e6fed98dfd09c61bf413ded882abd52bf7d7a2127761cab48bf8095da2d4fd467717eb1117cff8ec2606b5562c7d4a78ac53ab5c24e34cba13a6e5477404ca76d9ade90baf5eb4189bd6fa36b02f01d2d868ebaa9a07c5092378cd93941571dc35635493d81ab9904dddaf43a268c6c01f40b13c5e9d8576fc26dd2cb61e4088cd337778c6c6aa105c661278db279971157f8f3232fb00c3ccd499572fc082640c8dd2b8dcbaa16c6f3bc8bea72abe855e35c75d81429f5f3a477bd7ec3ae47c6b156041551301b79864041c92bfdffa9ea5b3ce3a4e084b648cde83bcfe371504eabf582a92e7ee6624738f397d70c3de3d52ae13f3e6db0a272248a24dcd42d32af7b9c21ec6f0578adb76800cc798a0b1d47232204f2448ed19a09d9f8534e034f269543ea4899c58c575463940018709b79ea3f474e1b91b4856e8dbad97f1e5fb1f4cd5633329d5b8eb79899f3812c9e403fa5eae1e9dc242d0216318cd40674787c5cab4d33826a0892b9cd71c2ad1019f8fd5a82cb0bd8aa50bf5998844db85bc3ebf74d6d345b161a0dfa2d2711f5a6800450fbbad7cc446ab9d1e793cf95b90d46c8d8419de3e28ee5e44bf4416e13b393453b712dffd5e5d712a9728a009dd02eafbb48650c7f99ffd950a9739f29660fb91a76e56eeac2332e06f939df970cd75d45b434fce34bd2521772225da9cd9c9b5dddb4f8efdaf02d25ff09f467acff382835b725595a44c12bc748229e4d6a09716d9f3e2093fd3f4da788360e53e4941fdbb0ffd19f0bd6da9a9d8fc4630d96b67f03c90fede6d00fdeca6977b4f381f05bfaf4be2626b1ce70ade004fed46a992abbd3f0e27a88af017d513608e7294e562b685afa5f5f49483469ad4ed80338f46b8a9f950ef1421f195a9eb2f51719e6ab6265f8651bbb49d95f9aa028253fb33a9d13fd56b3fc3aeb3f442ea4f5cd61a52ce0a0c3eeb3da8fc21302d1f0481f982d20804d90cc2377148c0469de6b15d438d8fc8afbe642cabd33f2b32ebc449821e2787252c619078ec9fe8225a3d6ca1e61aff494443225e798ab0d81ac65e14dc20ad262dbd11516d1da9536384c6ed1d2cdbb64d81a25120afa4b207fd2f07744ef3a6dbf32c36c1a4d263804d70cb1189c0176d577952e806f7f1805e01b4a8940612de3149f8c19441cb231cbaed68f5f6475e9bd0f2fe9b022af42adea9eda519d266a18c5d1bd02c15aa19f01ce21761e149c1babe9b34f60250a1d8537b0e23dfa92a3de2a46026d1cff53f35ce49685b7fcc94ea4a0d359c8b28944720de5bacad355852648c693806614dd07665e37f2348b8464afea9144e271870c79293c3198e82680fcce972af06ec81915b0dfdcd40d37c86c34f169dce85044c036f631cfade1e8273b847ecfd0c259a190e6e2dcdbc2c936f09c7ef2eb30f54ebcb73891ae72d43d9320bcb92124429d39478745c66f452d1a4a21fee05d50d9f1765164a0dcfc5127d5bdcf85d4babaa3b49e34106738c69f6939cc76100c4a747727e46f15d95074237f376c3176d32d73f924f1d895a34c694976d158444de9bb195cea9b7aaf9ae387679dc1964c5c81b157c7985505d776a15d59d9a8469112b8e9e09ff372c66dff0935c564f1f2f75e3f3e3d95bb16f56f8b330317c120b632e7fbdfe9a9362d251a0239a55c44068babdaa4f311e88307a59698161e52248e06010fd9c740a2d7af49bf24ecf5f8c870a77c84d03a00828d04d4b01205cef6d73fc7aafcd9ccffda9c07bc2873023454fc8a64721aa935e26d8656e4e0baf769ccea0844395a92e28cfa82588f4b968010b43440ee3cf38a92dbb3ba5b9fa1a950f609308a5b0f2464ad2a76526d9782368b7b379934fd7f5cae50871edb217dfa06e0a617e3d0a2dbde989cfc338be081f562b564a8628e0fabcf0fbffe2498d2ecea48cf24cb208e89b9de5b760a1449fabb3d72ba708f0b41574f1ae322f71dd96c7bc93c9716bedd083858daf2fb957ed3a9493c053c4d0d60dd7f9b631ee8706f341cef0fdbdba7a11c0be00b21debf0232b6f3b98bae8e71be4eb9221e4f46d81c8957b8b955e3c434e8429cdc2b95bf61551c604c6b12fd59ca2887c32ef04ad61b65e4fd75469360a535e82927faf431779ceed5a71ca5b9279251c8a7dba99f9914d017da5c3b79ded22a1ce8acf1a6b5592316fec4ad3c047e9c188649bb8fe93381d0ead3b73bdbfca6c3a3add13bc1655fcddb93d36b5a55740687440c92a0504a55353be68aa2beabca4714ad0bba31bf66fe100eed1325ef0ee13bfa6bac3158c13d645d831669d96fc79162f584d4d1213975d9c521da76726e8f6fde6d7672292a7a1d751a806ba5f07fc029444e56acc9a6cf589c59cde23a7beab00c292dfa8aa61b6e6d1445d385ffb0599d252111b518ec516766245f0af69146939b92b2d121849452acb824911d728840162829f374e082b0fca0ae3e2dac24c88334fb4a9e1be84b9272dff8a16844519fcd8268b622de0561756b6a29efdb4d44ca23a22822ad3df53757ab0cddbffa0f59950474cceafe5cbd41d10605e925e1d5a895ea15b4809233d4dda59725505d9298dc7bd100889af5135be02bc55285fcfef48fee637e8f6f8c09ade0d75ef0a047c96d78ce1a731db9cfe889a1e47c93b4a23616691f4bbebbfc4c5edc4dc8edd72b2a539fa65257dc2a88eb3b7f51a5ff81a33bbefbc760e995172d90c262760748681814c7ab773c964ab8489f233a51b604662385280914b21742b17b253930e77defd55517c033f43920b675d5154a76d4b7145fd1b960528abea66c9a3e5e5d32059e5d01baee4422fa34aa8d1d76b46daccf1ee09c6f4ebca52caeb616df380dbc585a78447b08495c8d1b867c18b48bc8c03a4ed8a2b30c938fedad21abb2d5fdf2c566743c6e7f793b42f233168e16acb4fd7189530abf140ee640a558119446769764db347d51645a144fef35cd0553b2cb4fb90eda5cbf0d6483f402421fd1105fd23c1121583176358b528f341a9df4ce550585c1aa90909ba4755dc5e4eeb493b66916019985005d6148024a78b1612ef1fa854c1e6d8a1dfffd0932a4fb973bcab3894655ab05808a5a59b125223a81bed2213eb1d65abd67e29599d308716b7bc91e77200e43b04fe30aa7e91ca6c0895cac84d3f0632f41831ca11eaa26ca00b941e3d00b3dd205062c9e319f622926418d78a05348205aed8a8d4581333bd77a06ea28b283b7f89ac66675b498d76fdc6168ea8e0b46a821d5c9ef549209feecccd09794d83de395dd6a4fdb5649a9c9f1bc34f712e52447fdf57129850e8e6564780da1dcc0ddea2c9ca1be73f894da5ad07c35c892519f3c47279dcd7cccdb3a318a05fad835cb01a15c8127ec1c98c2f688aaf7e03f309eb2d1652482aa3820cf7ea4a9e85b567f283b82c2171ed68d3de6c6d88c6cb6d4a9e2a81ba241ad13d882f7d2a0841f34ced1ca8a81554483951bcac24aca7ec65f17830011d2de365c0ae6aa22c9b43ddfe7ef1a5e69d02abd775d561b9d50af6f453881268c8fe9127fa9bde9839fe434698a787d99ba226a749cf9a87575aa79e01d326307082b1275d011373325892d34179eb627f3fe59ab75f701818f4762f582312573a06dee6385a9859b7f2c1cb13473c04d658a7f3db2211a620747482f140776d82a8f56904c635e978afb20f937eb207d0bd45cdba056eb113db2396f6f069672cb8d83418127c68803b8f6c5298765508f30639046f86f23e4212e0e616b9c26dcfdbe99c9f01b5502324adffb37d4d9f962f68d58c225b4c93456b2d47c4e97686b915721e7759d3ed73f7e5024de06d681fbb693bef0f5e0350b1f4938176e15fd941fcc1b6ff68232695a8d5e960409bf0bd206a113f4f1e3d0f7b34d85466b310f9201ebdba6c39f51889abdf224bfb19cb4b0335a2fe00e728c10a28c70fccff3b246dc61374b7c151320cad270883c0bd2bac07a3b0f3c28e2854b5b85c498691ff5cb8ce3d6cad3eaf188b8de2ee44d902afb92c7375566c7ae10e145f9d598176b21744e99185d4fd5b3358747d033acaa09a15eeffb7b920890dc6eae6fdf854d0e665332ce1d9a6a79f65b21639b501224c2d564df4af947d0ddbae3e2bbb65f9f639d89ca72b129f8de0527cccdb23b40ad629d65bc2050b083781809eeac252d791146b097038bd05b9fe4cfa3a450cd4cd7aa2a834d195853fc83986d844bf2e28115269ca8926d749aff9b086d98c40f9f004effc47f97f26e7f7769b016c27d3cda579d28c9df57d484c3872b5a5bd6c2a2b99120623732afaebe89b9f9fd04f03b0ef040e86f13263412646d6e8d8f88594d41f1f253091bd977222ef535d36c628a923dc4cd8068ade83e61f41e7a7507beb0ae117f002131af046ac85aa7ea2ce4fc3d206a6fc043430fb3c434af8ecc197eebb383b3fa4867f5d566473ae70a5f03c74aeb6d7d505d6d1387b6574b2d9217bb917fe5b85e1e015794bf9ccc293e2854defa50236f09a483c56c412538213f64b870987a38c6615ed10ffd749d36d34bd7541794fb805a5e6aa8275ce65c9447358cc2ccbb2dc1874fd2b3a501afe31b586f51c01d98fc94449e65a16158797f485f2b5946013f79fe03aa21dc3a627c707f9b179830fc1e5fdcad8a53b7fd56f07a233fb16100198d5e8d8a04449fe307a034017ffd7a665dcf0660b1298645925db9c49bd8eb1adeb3d54f757f3f6ea66a35b12e822cfcf1f0c8142944233c5358e9cb7600231e4b507953046205829632f2ffd7a9f9380eadf82f006d1ea7f326c6cc2abb8fcc22f1d187a0160e8c4b13705205932756fc84d994be277569c981bf6a452ef6d8b79165853ccc7ae500a7f76280bc2ea5ca41de0b17fb9c632c90c80b18dc911cc9289745535995891c43e41909bf5da0b5a04d18ddb23744ac546968abb2a161306e9f14198591df8b925e5ee75d816e7e7850c4cbaf0d92c6aaafc8cfb900d28c1cbf81802164349b9a1bc64257cf7b47c0bfa5573b97039e8d6d929730a0e895ea78fbb312a10d8bfa29605adb51158ff3c5296a43812aac8b9dd432ddd45b15b384b9b4bd89e6da1c05c9774370f81df93a34fa0f6a5199333519a8369d4372833ff8bcd8f9a4eee41a70c76ad44c9c051d5d58e2ec4197f7173c2d88cc461e003b4c0fdcb93080e16f1b69b9324be9370326ee3b1ddfcee7806134b67ed535495815a6f89e54e98b9dcb9381b5fc02aa29fbde9688566f8ef531b3671323e9d4d00acd50ba0a659839d5d1c3baa738a07b6defd776098f811d50878bd03bcb33171cc68177929eb88c80e468788e78b5dd0d13227f5df30041fc54c4e16ceb1fcda832eacefa9417be8ff659c8fe0709c6c4559a4fcebe819fd9df360e32c3f907e15b960852c95fdbe3e5d2f638c77f536bac2176fffcc1df4c96ca327227fa67db92c1bbfad4cd2b6b8f731caeaefb47fd2fe4c343ee06851f09655ba95b2d810625291b99ed141ac9e56cf543dbcfcddf8be02f30f52f2584acc518eb2b9546f9d0d4fbcd63fe018e55a4cd497e0e09d1d096edaa3572344359ace2d13b2e77c6aba7614fac284f76a60c1b026330cbf94699254c3d15eab4e3a9e49b8b060ad7e6fd852e37a784db49174109ead482d2bf506a8d99f42770e6ebfab3d62ed776e7060137384e7b95d7651ac7f3f1ce962292c9c9b13922a221450eed494414445f371935e06bce595504fb5707bcfa567a5630c9447b97abbf4480de96a9d248a685741b3082ecc4def6cc0adbb52b4d0fbb45f44d3ad3576ad9f1ceb8a86f9fbf7c82bf50e57b06811c178435b37828504f73261f9051efc4745b8b80eb7b933b7f27345c914ce5730455474a84f9702d232b831b7bc383899afd078e9f1eca0d605a893baba47a61069a7dca481cec8e557477ce9db13f791574595b8599c61e4e40837bea9f54ad51b7df8c7d0b8b190bfcda855bcdae274ebf77eb42157517153dfc4fe13c0f1fd45eca810830c65d83dac94b752e83f05072c123ef700702b5da2c3fee535978897f86de9dc0470c57ac2e5c741d77450ddd5f64b48fdc5dad87ab1ab1aa455311a5482fb8a3b9486f12d0eef90cf1b6c37825410f7a6cc3d6be2fabfa0972aadace9a7fbcec9461e2e7bf9614f9362e82d539d9645fc99d906f3baf86e0f779971c583646e0bae1ee752fcb9d8d1dbc5dcd0726e6843675e71a60cb9288784f7217d6c2949c761457b30a37986d3f2ee0f06f632fdd3c76bf4e5f0d96f9859f6290891171488caa3e47ee0c6596e77b6509a079e34f121d1d2edaff085198d38364f5a41b98e22f164bcadc1220749ac955cfd1394b947c8f63cfa3c25081cc58127d7e124aac8096d86156150de21b2936125596e40bd28bee58b5551abe9cf784833b8b9d1e9a9847fffd5521ec44a927d611b45e0fedaca9becb76bc4c483cd88297dfcb486c022701e4d3bce74ca64a745110b84a90e9a92eb503053d2dcaad4a24af3b5351a2f5485da983156ecc031e0701ad0e5a11cf9e4cde6360584c3310d177e4866f7b321713471117c9ac497537f16d1f4ed891bd6725882df00d11e7ab0697693e9b3a306218ddf65ed3623e17ab865cfec142e6ac4a764f1398d06f4040c618d69cf41f427778c0f368b53a6b05aa7a4d17ea57c1976d0365816c4f23e4ad8913f5e500de33ffa00b22de8d89e44d98a4d4279d02ade720de1e3baa795dbb47c4ade800bc417524356c21be89a128b4ef3bd3e1bccf6c86153e1d2b78567fc42072529a1f67cc3b7f3f85f6283dd616e67a6bee55b503531a08f42f376cfeb3a293a73bb3b6257955c07e9b22744199b0bf857c975ad9e74f076f88c900849622fa270da8aeac6bb3797de4b4d8e81f83e6162ab5b1d5d29fe88d659aa04a62192edd9c04cc8f33c185cf45042ea83ac6771368307701b993782ca267ca347bb3df94b249af03fabeef62b789462863d72714aec3621f63b5017e80f76ee583d0e01c5073aa116aacad74e0b34414b6c8af3cc1471b31eb9d66888547256c79f6c501154f50d4d33a0cd88ba83a22b94cfcfde90909f54cd85da59d3221c265ef93fb3f89c5d9f18ebc1a28b1a9e0f8df79176be59fa3e777eb097caa5b269f51e3ea7315d45fc152c846d411b7b5f97d94c92c408a35814ff04dd46f7fc449f1fd42e7858d4aaef6fdef0186b7c89474c58d012392648d6319841262ab71b0f3117aef3f6a92aeb4f9311da83136c364da0ead4933bb21d0faa3ce94008ac641c552ee491f3d0da923e8c534a054205d12d7c50d49378f2a06eb255e4d836ef1eea8028acfed643eac070d30341ec81fa4a7e56342a0f3e6b651117a37ed20e8f1f216b6753018e9e7e2f0f69d51d43ad0498383afb3686371264c19e6351a398fffd9bdcdf95cd703ee2ced9a535319cf5f40cdcec599627f2eb8f7ae1a854946e7b400234267b0ff837f24d1aac73b7532429c5dcf3a4d10bc5c1ccf122c82a0b31f72333393620c250522180543332f10875b9dfea9a374ebc7ca6f324088c1dce061788e706b153ec2d0d090d3ddf9e8f2b2374d4b50e3112be59dde62accbd82da832b7d56cf85eea665f9bc0ff3bce3a4597fd0a601b343b5d6f4d3e39139628234da8ce9cfa67e5ed31f365aee90ed736f5efd06dc9fbf18d3c534da52301625b8934b1b65e2660a90cf3887c5966290ccf8d4cc0760332d2ffc472126ff0a2c370a57991aa316328aca35cce66b16db9567918786fee1ddb87138630b144363c1e66aa87ec49615b24fd07f15fe02b8572a4e9451e0d6436e282f217e833e78c999785388dd97e0dfddf44d9331f01f06111885c6c29e2399eac0298f932141ca1a86ff62be6914c68d09689ff8014a27f068b6ce049c82f228c87a4c8069a039bb16ee7ecc631f86bb41a5f4d34c112fffdca26ede4df3064c576e2e6c1d2d0d6c28ad5edcd0838d57aa38a5baceb449ff36bb2f9fa3ad8d31ef3a22b71f3e7c3235b447706e929cd3b64f22308e43bf18e95760333e75e286d18202aa366c01c8a3cc609f5ba890d789dedb56f712ddc6650a3a174c900f31f678473405501cb9700400ac295445c6b869a2587dd4b1ebbeae927f0e9c5a755dd4f92da87455e7da8e9e7c7eb1618b69abf2178bb0c653be6aa02fd5dda0bc58f50f32efa3feb95b278b9c2611bffc4f513d05b0c3f209b05b54f1d88da9d695d7748d4fed73ff935dd6ebb86f66f94b7a2e0a441dd83ea21af83460775e740c7453e49c7c48dc38347409f5aa1589bad5c54891a5bad174e8c7950e174495dbf3d0c9d6948b45081f996f5d7aac475f9b008efbf83bfd5e552669726d72856480165e077fb67aa863a13800e12fcb7367e4c2f516a0129f3b1c571b0d3a5d877ca74ea1828df1b9ad356391e19125125ae65d6e748e882d4c71deefb9e933786d46987d00f90d5002e2ef006a0ea71706b342a347ce31e023e34519a792de7b90f71816d6ee082281bab6222933b387cb272f7f231d6bb255a6bf1dbc81dbfd5a5fdc557d300230e3435130be0ca80c91afc55845c413a504e52c409e54daa509e15e24027cf91cae9b53b37e7bb663b26c56324326362a63b95e1f0445fe6bf7f874d86312361584fd46c57f6ef247771343424e62a960425b5c689cb5463c6753ace7aa24bef163257eabcc6cf2b7445e7e8961bf04797de4ad9c5612243bbca1872e3d18923e8f26d09d22115a898156b8d2008f4971f7ee83f43ebf8ae8399ef4fd2e8bf39b59458a892b4812274fd490d05a8f050c8625ccf9e24d2cad3073d70e82a0fd9b129e760d0957409c8ffefe9ec1d4f493d4d2f5e448d27e254da3eb97491ea29a576ec609add6300c33dfa6842b491d33c60464d4fee505a26f193d4f5236bcdf461d96f239c0b25fda7b0345113f67bb9475c98b4a16266c125d40c9654982a0cf1d763020d37a704ef1fe8efe3e5ce40b5bfd02a88ba4e7163827a2992d595981035288fb659875cd519261cf2ef2ee5a79d21e611d8446b4865d4a8d1b44ce9f372de700ce2cc80ce799a678dab1ec7c2352cc09f85b1316db5d07c20a935f065fd5117e44ab6281f06fe51d10d1e78655dffcbaec8b9ceca4c31a59f1e0dbc5b543cb85835d8f2762270545c292d06bbb5286afed4e8fa319aef7446d00d51befed901601449518bb1a22a81621ff56136507327ba13ebcbdbbb6ab4b5e377d5e31fe072ccff38a13e9e8840be4f62511f93b9585170b0cb71c9851203105bafb1171023985e5e7727a2726c95554f63dca20fbb1f1328bb615a9c6e13694e8e81e58f984d11678d9474289a16fb9ff7e38d34fd19e28d5dacb8af7e89c31bff82a63e4249cd245d2e9b63cbcf459d3de8c75e411a39e805e7376c40760d39ae547907f8d6624a8e182abf10baf910d450c6b7e53b049f1419be98f8b6e82823698b169ac791ead001f2173cba4cb3d5433427fa78c6a09e44fa897b9e8dc2fe9feba71d5dfb4bbde9f6f075b258ab8c6d1dd5c9904dfeb9adf411208cf0396f20bc7261f7ff82b6207d324580d10fa08de92fd24a883181cdb348ada8fcc7f977f961f60881e63e604d502db1bc556469bcb774382edb00c1951fc1fd452f80205e96579b2dfb38212fdc7f745e3c9d6499f6adcc29a2f1b368b68e9739838fe46f884cb2e92f6d50d85aa9da1ad43f51be9f4e7c39bbc8619fa72c13d245e62cf3fac55b2f41c36472f4c99b9816dc7a98be1ae382bee1e1a284bb89bf11ce38839d34f8bc9ae362c4cfa1c27a720d115e775670a01266c8b84387c04e8ea13a52c45f68a041fd5cd3c4c21611ecf203fb509ac8a4e5e7af18ebd7ff9c2ecb3d10663d64c37881e558931361eba045854247be9240b3d8870cd0e16ffa0a466195f14ae3739263cb062ab51b5526ffcac3f5ff555b4266aa4383f887cdd3eb970dff62721b35f6f387350524c353c3f49f7908fedfdd429296d9e0895cd406059fe97cb4529f4b75f6d546d5fb44b244b137a06a16d5086e8e7f8bdcfc586f4375d197b69b48911722f0d86ef19a7f2108c6c8d5a43412702bc082e58025115899cb2196bb645a8f5b811d78889e46a8249057a5c184591891d9446751e281d998679752e918808dec28d1809a950c71dfadf8e1b44b7a8161ed9df1b526b6ba7d864c1d794668248459156d5d536c63d0c9b25543da250850080b8c6dc2580491ee161f354f7442bd7c546e3ac19702c0ff35a64141145ca2cbd23fb253c2623ec41c1072ae3fb57247cc14d7c9e79c7b67eaeacb553c012d5fb5408cc673da58c70fb508bbb87ca5a6dfe80a22c0fde44b3c680b2c60df71c3738ba13300bc9f1b5d7e77c8ec36c92421906d17d1dd8f03c54345876426ef0a8e53a39975c098f517400130b59a5d22e15f7ce09003faa992103aeb2fd08c907aaadf6fa893eb60745e9929c8a8dfc29ca5a1a43d23e04e64132b5a5ad5280b5bd8e1c538fb200ce1d91536d194f426d99c5f8430c883380340889345c99284f378dc8e1bad8b506579d970a074f70d263495994a8455f19dc097b90c2de61f5148a4082b7ced5e05fe5d6b6478b9cb47dd7ad346cbfbc9f0bbb4f73735a0775fc9bc597d5c0537eb622ae93e64f8e22977dac6a4cda981c2f27461802c79a1f0264521c9894ee3024a69b51dad5896200f96c4780ce603c9b4612a684007ddb5523db884b96aaf03caab267062771dc913a90e7d2187465cd0e51acc3579e4e133a8cf6a76ed6bdbb76fe7265e86a361a4b22fcd0922ee4b7ddb6bda864871beaf72ed2c8e5055f236f81fbf5f63ee17abe2e332bd1f702aadcb48b4aa6bad12ef24013af964741d52a0f6dd0e12d314d506cd6ebf9332469206457896b7593237a4ebe319e0610e1d905b9159eae7ffdc1f855836b3bc923864dd7b64a5dba5be22dd30f40431ba65e1a02cae6e093ce35714282aee1170236364b6b1666a179ed360cae9aa079cf7cb3fef4916f8d12c101c1b629fdf229259fddc0d17612837c37c69e7e9722f27d1f6b223ca1a36a00edb158d8c34ecbe8ff94be84ea23ba578615c0fd4dc8af92c48a3eb525943e48823fac54b327477ce2f179ca197faccf79646d827fd8a070d79ca57273afb832a6bfd9ad38352de3772c6b5a0ee62d6084bbef122760e4e7e260fac45b96b75613ac217079a9327c099671ae475bdd06f70a657200665d7b76d062b4a7af03cb5eb23636cb6281531f5b8639b0b8f356f5ced33a759fbefc2e9c2fba948dcb13b0039a012b2a1af878ef8e3f0f7ea35425fb413dabc1724477a32d8dc07d324deda8e9b580e2bef78a13d3e14a1f1dca92db3754ca2ea42281ed93bda0226af25744ab7a8b6c195372f3346e8f153dc23b85d90b296cc6e4b9157f35a735b8b177fbce2f360cdb23fa93f63e72cee3b9a444cd187b530ec8ac9f7bb502f0c6826a68a92de203084765d004d78551cc4785470c7ef905b9cb9933730448a6ae931ef7f3b5aba891b535f28a3f6ff68dd4af82e649468b397d2a06ce9263a94c082a1f191a7195b45d2e719e7d86589e2a955e5fd8832d5a16b9349662e3886e72ee7c01a65d978b1befa0f6d340678d09254397331d70564f24a55af0b5a6a60c1059cdbd9b45273933ab2cebadb71cc931df57f39c30a021532b133c48497fb80b95e0a436c2fc7d0718f4993c3a72a12d19d8ad6be852b848e6eb0702bb89eb55689704c707a8ce69b447ac523a8b51dea95b52c945cd713d670e850990ec97845ce31db637c816c0f5e5ce0061335bb86233d7a967f427bf0f3a043b8abe63694edd5b2c300d2e6fbb6a5e372bb077d53e196c91d41ffd9ea04aaae4a75d610c94f428bb415c88b30e44f3e6319bbdca6cd257970c033b0e2805d6d195e54731338fe950c85aa5f92ba1dcf5818c013dc0bb619b319875a1b030a418d87e1a4c356e7397d0d6a32d52174545d4b15af7ba6f9495ff7b2d6803a4c9bed51279d52779b2214f45efe2e3a52b1c5393d0fa2963db331ac0f365a808316d20ba13ad3e7b6f1e56bb0b0bd4295452c3584a6e37eaacc4cbb5f62f9ef0983aabefe7a789685551825a1bec7b926abc59aa3086443f019977ed42ab15cf7c037f8151f3053a150a893562069c761080639ee3cff84c292150113b2c1157d41679a1341c02acbc49a98b9a8748fbf4da8ce9b913934215ba203f0553cf4655e188da41d33a6f5fc306147c2edd832fb1e5facdc5f82287b6d054e506946f8ed21a8bfeb03694d882e2a973a1b991f75f2c7d7e8c5f6dab2bf30bad4a2678564bafb678b214a5007f1e9f50c923903732948ac8e3106f2f2752ba4bc9dc0c6e9a638363fbbcd029c9521b19959e5006bd261d9837275f6b61150bae919e0ace0705aadac7d9792d617097d714da46f22fa5fd14b663167b21b8758219693ab7d5c1aa9838a37076c264fd761e9d9bad67144229e9727de7807f922ccb9a9eca336672bdbc117fd56be63b2a62fd4c9a19a5ab3d78f15fafe6cf42267e25397d9dd95ea2eba3bf8b049f4a5866cb28e8bad33aa0fca380eee3f3882e70a54e10ea45db218ee8717722dc1d50836836e0e6ab763d10b618e6e26802905e23b8c55835ed6b07567b41804777d033ac084d6168806c82bbf8fd016f24901fed62647ed80e797ef886149690ea77b618fef50ec459a862e2fe879653c707ff31f4ed28d6a84d361c372291d1b6faf84602f08bf7c699386ac8b63217c2ab8e4b834bc7924f18064059c20b59a5c3a71969cd2cdcf7368e048210897326376efaf2fb50d69849dee2370a471a15008a865402dcd9a2e4daac485589be55a2cdc46f9ad5850710f5b0e73facd43159fa6b3f99468062ac3421fb6368d7255230f04be9885f69f67dae075768b2152991ba4b34c4cb00ad5bf392338afd5163c10a540c0e289017116f988c1597b3fa034ae38b2a5d50bd1968cedf7692c58fc6c2468c415f2768b2e40831d777b18841a6ee14a7ade313ca576da08ad53719e2352e5ff4fe20efb86145d35c6a533b647a547b178ad8cd115c94ecdff904f74be96611b9a6a8d839fb30f12f0c79080c20bf7051aa16b31ba1469332a81cb9968a481d6e0175284065ab996dfddeb948906685ba0cfcc27d66214d9692a68dc32c446eee75a75bd5f3864c1f741649c6a3a895552fabacbfedcd8f772601a1bb375bee49f8076bc33f69d598aeb23a99e7bb4730984d604279250c8f55c8e0c3e72ae338ec781b605fb11f9484f146bdfb9e8f12bafe6f73527b5e0ef0f17c256f64d9f6e2000074659b7eb7b5ddeb0b645cf93cb8de8b7e6c242751f0378ae2acda8782312bf1b43306bd9691821db3f5f62fc176b45f430c52791ea93dc2916a9b898573daa309b43a2f69863298c16ec6be2b749275bc464fea68b0769f546516f189152c2da2a05d8b8f275e5e1a99a2b631e0a7b8e12ed92326854884faf6fff4ec81491ae94287a701e591a90f411d3533108a67d433e3e7ef8498a92f7462e2f8f14062410a2037cd8c28cc5a3557fdfcc5331284dafe02b28a89235b91d8888d658a50f9a097cad0bf46d53aab1e4f8f71135f5940f699a979f7fb3a8f593f85f4572be89c8d765ffc20ee6b70366ba192629352ee2d5f563a164f63637931af8714367c2834ed8a3dfa668087d439f2b9eaec4c0c0f9eeed66dd2978d65245a25d5d4503ea86b277b05db13ec50de823b6492cc796d32823592ed96be2807c978d7f4b49a19340fa4e37b59ba6fa24a732182ac8d87581967ce781765ab2c7eca97b1a40e5fa4c2881f9a6a9a3b730a3ef0a4a1f77efe8421dfd80e8fbdbf1b0dfbd247e9e273c94c57896815508095e1fb453b78bc48ebf6cfbc91741f2c2b76be2e422d56aa39c622324ab9a0beec16f192147c1ff2f36a24dfbd5c18a9c62cb3059299943909635a3aca628a0ad30a5e8693bbf8fa751bcc1eba0f87d4906e17d390c90f0cd09f3222a522203b2546af22c8e1e4f2cb79de29336236a55f8b4113c6047b8979bce40085d5b92dae0e6e9fe2dac21c6f7c6effd4f9bff60c861396ee2951c294f36e4c617f4063fb81a05693a5b20949cb784cd3b4ac06923ad8ba7a0a7c99ac3e00ec0f00ba1998259612cfaaeb7ab4d141396ab76e0481519b0f346dfb5a98c46220c570fc82bcb4ea1a879dd97b6ce4e3a8ac42d676d89a255b039cffc536f507b80970fc2aa000a52092b3011d6c794681de90a34dd4143db326982486e68fb0dd5e38ebaf95639a3c006e96b2d050112a4f6eaf491fc200737b4f2005d2c71f2ed5a6f7e9c9acd7f424d1a8bc9ae167f26121514a6afc382450c0fe2820537379dc5eb61329c5d55f45f9dcf3c69e814b60803bcc16dc1d39a01f4f14aff95f21f85b5fe62fad639edf7271fff69e0d46ec203a9146c5a584072fb5e95e21825dbeacafa4ace79f8df5f6ae7c4d84b7138a95842cc952aa631ab535c78792886884f4570bcc4ea11f7b57416b08feb8032e85a1d553cb09f63a41f21df4cb6935e7d6df64a968664a3945670b9f80e51e24476630313731c790535df2c64cc169adf83b3b148a0f75369ee9d2ea068a86624000278529f137f43783490e49043388083b46956531bffd93142691439b753749342f1694d364423530e9166cebe9bf942a99d66fd152329b9b9cf0eca4731696f63a3a731cc45468399d1ff0858f4aeb7baa6c1bdfba586824f43e43893d81713ec9784845a6d3f852eab313fd5bc4be1f3640707375f20c80e1692c9a88b6bbd57940baa4695b3678477602e485f3ed2979296d33ebc3050c83142d2371a1770df4ba1fca9fd88cba055d38540e8367eaa85e99e96a55feef3750eb446b05684fcf2b703dd15201aa84a73e76411f4ef434738df709b7b2e5755d9fe51da26a31a248b6d1833dcce8c3848489224559290eae3ecf085d3b7830084b39b6030d6ffceb06995ccebc51821bdb4d875793ad25deaaecfa4205e2eca15d66a08ba7dafdfe7ac5bf56b631b51a8089a91d8813338bf6ce21e9c90f56003b75b529a97f445785d80915618a7108af97c0d069d9c66318e6fb398e677cf3774d0f3c4af7301f9768ae2ef237db591a2dfc278a82f605388e34e97766cca0b2fdcd2dd684b6661e6e7e7e421fe4b1f98e34116027d42f782dac4d7708c19da305b8747e36d0e510b09c4a2d64bfdeba61872f094970e59772b33035174aa22e898ac779f6aa73898c1cddebd68f41d1882e4d6c944dd021f5ff8ed6716e2b7ecee65619ee3987cab7bf845f056605379458a1ded320ed2e42e229b8af9bcaaff98eb4f26e50a54a652c05ec103bec6f3a8fce937c0b72424349ee1a8453d3296df9866121e748205240ffe19fbb448c5be98ec55339d42bb27a6cea0c0596ae6543ed7ae5f3653b33af7644829ddfe4e45a89e04f645b4f9708623c17d996ee77a66fbc1e345767ce5d90e69527f35212b9c6961871a6a95d530daf0b411ff6e2f255f0ff8398fd7b96abc6192c1ade590e1e6195adbce1e88287852de9869d6f91e7be7ae46f1f15cdc56249d06da93dc21d1abbd064fe58f0a0d833c3670ee1ba365a7c438b58ed08ba5c6d42c4c5a3922335ac59106ef3f3abdbd8ac8148ce6ef4e2d52c28f35348e4553c92f8c72337c4a6900e3f902ef268c77ebcb6213470b2384d87538475b53530b0371f7bae26b1a1044e63ec2191cdca1753711fe66e7e9ae03be8c864abd5e4c1a7fb9b519fc3bfcdcefff0842bcbd3f69f5cbdeb23bb48041ee16930e0897b5b1925418cde09f9a301e44009f29ae9c0cc8f517137021551f69c8c22d52704461ccbc29b278193becbd9cda38f8272289f13d8d2b5e122929c9b6b36e2f62701399a3b52df2807fc2cbcff7790cdf10da1b5cc94bb6a6eacb99d0ec35f1ff4b06882e88ee287add074e2e20ef4f1cc31295312e8a844ba0f37ce69b86dc81e20a0d89b9b67f91740d5d7a76682ef93bde28ad52e957117dade7bf558207da4c111f0b66d47bae395a86962971fd57ad2e9b40343b2fb0a829067ee08ecbbd38f0c11a579fcf344faa3b8e2f0bffad5f594df345e674cc49a93e96a9bc910c8b12c4d6f4afd16e5f9ddc19434b4a013d381b0b46c64365aa0d8069204229441b25288924b517d0534eb259804f168badcf83fdacf1a707ab7f5f3242a95dd736237894f5f6626962521f407bc0d66d87eca6c7cfdefb6a33c31da7b7e9014c4c14c79fd7bf3e04f3adfd1756fa37ac58cef121385e5718a60998f40aad76aa27ea917bcc8c7cefea93fe65a7d5177563b6bc5c8ecac2ca18415d350881000ac96203f4e1a5130d940d2510ef7bba08bde9b09e55c58e782435d5a232235ffef6803fe3f57697d3ecac7c43929ee9e82c1337a9f21509be5df1f0984e85621549415188b9582934786c4d49c14a070bf5cf125f7fd1abd91937d89999408b0538e6f126ab38180d7d5eacba8ae4cb1745c18fde619537c6cd4a6757f61ecee5ffe3173d23be0edf9de9cc73367ede5b134ac9dc125f23b88648a654ad9f023a11948b3401f549bec9896daf529b3cf8372b82cfbae5990377cb18dc971387627c55325f298ef3ad767ab64f45cb627e1c422d30fd98acb4cb1da662f03fd88f52ee04744b244fb87d445c21b24859b4f03e3eb70666ea832607bdcde1086de908534910467616b8a503f13937ffa24e03dc6c83599766f7b84bd2f230e9d5c1f9f52781d03c060e8f9fbd9b5f4e9ffe30c0627d9324972501651a48351e7521c4de3a20287b56083b4f522af7b6a8cc87793e14103332c41b525c9a055f46a6e429de887892f7b240bb800f233075858c3da48f6a73327e63a8e86db34cf48ea163b72e52b197947637751515eaddbaa1bcaefec12d3ab4f15dff32369fb4691d35b81ea83e22b12656b9b4a6b5ce52e00b3433c5f4f295c6a772e8df4da788883010aa53e750aba840f47b6862b19f63e7a399f5630ff9cfaa8d65db506384cabfdfab73ad8f154905643385e2b7d841706c935a987698a30a23b225194252263de04c2d31c78d1910f6cbd791387204a4f43b703cce40651fa01d6dd42c9ea002b470b333e4b7f8f1b0125c9a5ca05476485abb276ea80f84c8e455ca566c62b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
