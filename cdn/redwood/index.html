<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0e51fae16b19252460ee2a9e0ab6fae0a9438c9e779e6a1e142f7ee4768dc3d59c068b1bf9f77f622c2245efdcaf078020e9b798ab6956761564fa5ee37299bdc24c72bb8dd538341c31131b5ccdfc37c98083176da169b396a2b5f21090703915cd3c5612a9d58d076e9a2d53fc7486a8d0f4255ac2470c7e49479626ab0c030f8e4917134b7e4d572603916f3ae282ccb0030f6b216d7fc840d3249e58e32d9510f29766b3afd62118397132583d4d3a8e84aa8bba98549ffd7ee465bae35ed4963310b925c39e5b9643f165823f221a33106d2323c440d4436e281dfdf33b1de98dc78472524b694b8dd8484cea297a6d5ed68e3081347cab67ab25ebc4af1b0a777f4d4f900e0d08705790ebc51fcc283d8bd4f3c62220aa6d62411a6e923f8556369ede3feeb7f2b046532976504dcd142de1781ff68121cbd5dd7117a3f4959eb92b55ae79e3c6ded5d0168a23cbff5fd47d713bbad6b53c61d26b3c3f33292a0c6e000ebed521c17a9a00750b44eee0ad531aae7a92d84a525f47a20f599cdf6e22f500c28de3c154ff877fbffcce387edc1a8846244c9235dc4783ce0f303835ac39f40ac54db9d95af4920c18f94944e8ecf69130166a6b46df23ee7282422704908f21449e7846720e54e86410fe9d224d49c249a1fd7173fd61096fbd218b9df42097a5958aa25205220cb83315cc3c0db2425e0c1e1a7d0d2d33da677028c35f3fafacbb3017baf21140e0e7bef78f0098da8adb9d135427263291ea2af152d403939f418f86de4a227a376fd95f3b5f323e91b9d0f21797a10bb585b41aa198ba97de43ca520e6589a7cad1198b7fb7be29f69127b3f23d36d8b8316c4fac54ad434c5df2fd58f1cb3e5a44296d72d400e5298a07040d468729b4a9799fdece189bfb1b70ed74692f74c101683825408c9c52cdd4d2a576cffc80b00013990bee287ea6d11605746f11dbaf703a45f85d06667918c397915c6ce926dd9f63061ee224e0e26380497ce3eb93ef0248e6f2804d06248f8c8e8de9e5c880f009c516b0e0767963cd2b8298b035006e953e3d14c0128f167be3ae3642ce7c0f9000fe40f74569932bea0ca4461bf5c638e77f0a277cd02a13d79f3daa598fdf87395bcd4fd76dcdf324509b1fb952b7974cdd3b11a8006d379f83110924b66244869897b341a3774d2a62702ed796ce5b98f2da69d56530d3ce1223ee68e2388215ece699113fed9d987be495c113eba0087dbb6a5638d701bfd49a4d948a382cd6179375670d09d4a7b913bb5318567d066edee97f2288ab9cfc5d81e02ecf8e0bbb8d6d4985db35bea23b90b345a20530323eb41dc1cacb258264cb5ae5623ac8de1f9da029bdcf0a25bec976bd65662d57a0ee615bbd7aab488796502815e6791108325f74c029ab51851a250e2c40585c047a030866130a89087d31587e213a97ad72cdfe7dc2d456756139b9b81ee5fa26a60832c1ff540e9ded6f5db133558c136962f66a3623558e1b2d492b74ec243c46ec95d8f75cbf49ab7252229fcf623a9ff99562fe3d854a68da4b9eae67bbe9c08ac9a4055be38038cb55a5ad43a57e7510745c804451136d9a68b31ca1a0078334b539e68b64cfe20002b873efd921bf810ab57caa5057497c6a4958a8dce329f5ab362e928980967aeb2e7fd5c05fe9ff0d505ea3f12de59d2202c612b80df20d8251cf25525a25689a71fce7535d37d8e0578d23ec038974b85f98a557dcf4f1f3aee6b7602c617989a2ff595b56b136eb3a73a748f518770e6e6a29ee8e3624129bcf2b1c16c770733cb77111234b77e5954e214c569698674950dfa8ef61ab64c039ee8ac991d1cb4fdd669abb846e2ee997aeb1157a59e5c1ab4c9007bf7d7464e2b6f5be679527cc7ad08c4daa60ea7d2a8f2d87c803d4c8a1507ab24d0d3d8e1aa924ad1194fcd3958a4fd00b6f5818197cb7f01298946002c2fd4c87ff2404328c04dceca6582898e2b7a61c29a323b37c1f01ac84ae32a27b8e55d87ee56fe2b8d219b5bed2f2901c59baf4d335f9d82da915bd770824ddad9c79c29508596462f5b2e140daebad72b87d17814b08ad9bf054b1daf1f9d507b246b9dc005d64e0f0ba0107cc7164b599e1ddc64eb40d4a907bd0ac8490c3af26b1b2b1c37b50e5c7e92e20f00ca186ba96b60a6f4fe7f87b2998cdeab321dac94b9bb645caa69e563f4b40256d1e4e23c582153a24c66fa7d31da0a050bb1561e0654c8d656146396ea028fb72c9520575646dccffbfda7758ca73860e8815ba1851b9a1a755153ccec0e981b417351b7f3cf9ae3bbd3ca3b81c89109751b6d6b3898c18f31f64708b5734f654d125c4d44e708bc77d213cac83d8a2d0bea4df17a56883f7b1a309fb05b9d639e95615290c2c0bd2bfc0585b33977dd51bfbff11a7122e7cb990c01f09233cf80105bc4174bfaf81fd845b573c7e09df773678cbfbdb2bf1bca471bcb5f8c56ba00ed03d5de066eae76ac350de3958078ca7a1a2bde10ebc94632c3a636e4ce28804a81dfdf8d7440c0635bcafcc56813f9b477bbce52f6241e0e9f6217998a98ca0f69549f406b899dda72760c63603738753a831e1e8b5d0939df1b5aff1647c5f20cfccff603322303305660f88008060caa10eea0f309278912e885478f18722c9eec5c33ccd480749021cbdd76a5c180190bab4311674e77d5302e6db44f609867826afcfe977b71f61a594e839a811ddd7cfbcd954256a522dd87845355ffc83f82a5fc9bcb87699f43e038c93624dafc49a1ec4e2c07d7d0784d23108ccf33db2ca6a3e764c3df16879b8061b678f6b943a212fff24ef42bd8a18c4a04a5e2979137f8821eea3654f41c6cb354ad41c486f460e3ebbca6792bfe63c333ff38bdbef984942dc24e3b5352d746fda126d4d15279e79b19370712b07f6d2e65be6819e584720293bc98b4b238f6102f3d288b0cc4b584234335f91eaf4e9d55c5a36443a6e03878bd871c4b8e0cb3b5393a0abf7f5d23bd4c5f3299a109b5f0a3630bc799b3ca1dbea6f39f2514ecb1782a0880dfc8f8bc0a014a000148ad83ffffd379f3ededdd781f4e75ad9d936a7c6e807e9063d3292224c69cfd92bc43588c374e5301bcb5c6593b00609f7c9c6d495adbd88869a979a63f08f755fde88240d96d120c33c5bdd423cf4b42f334b86f8dbb5504c897b115671f09445c412d0726ace6cbc6db823d639ae493bc4a92fdcf2b2b456a22152762bb218c046b1ab05094e74d0a34d86193da38e7fe2bd68efcc2baa5ccf98c8b246adb252fbed2eb8dba31d66bf27f0bf22fa835388bd4ec9c9cc597e8e9cb2e43b0eeaf85dd029a3d0f5f2a4dde083bf6e687a107c7857d34a2ef0af3e5d505b8e225020dc6086dc063cf011c4cf4fbd2acb366c566468fa15f2a5c62878fb2e5c58d38aeb7fe59b824341f6239445556694a0d22ed7952393b4eb398f88551e8b5426dc5d477418303f780a3541ddbe2d2803c208f21e05501f878d26e08f35ad577e67329e75f80a0ba70fc3a7a32e431eae41671fd0abf5a074c0e55c965fd04da9e74b84f7592e34e9485ee8a1f50b84526a245e9463fe575452a433de89ab476083a9aba10ffcc1639eaabff714460537255178b758176350ce94fb771e674dc0ca596e26e79f5ab24cc8b52f5cbf0c199dd1c529cb680b1776cb0ef4c3ba4c1b8f52a4b8127d9d38204cf97518cca099856b7fa82e4d3764f668e02d1fb569f7bf0701ffb621c654a69a84a4189eb55f3a9086444af4ad3f15f5bc634977ca035eaa0a00fb52d2d519612ba16c8c3c76271cd68bac663bc287cdafd7fbf43fd0f8a1d36b47125ffc45b95d64a9f85bd732d653c3f106888f5cce509195c447731348bc24fa1e29c50d2f73a49265cd4b200c1699983364eb0fa96f27fd028a8acfd873cf86a5efd61978dbc6fb70312d43ab63539b5b01c402abcfa66ecf63148253635effa34d8a51f67f10df70c866d00842092b4055f171056062a48da50ad29a44d60bffc8066e6217a7102a4afc66b70ea1cdacb366da021f3879d3377e02c0e0f2d0ccd5dca76597ff544c9e967ae5bacfff262a46eae98562dee3e3724176a20c8eb708bb6cb75655deb22c96da8768fa34d6eb9403532cbe45f4542dd6df21978ce26e9d0739993ad94a26c2218c864255f3237de11761f261ddb5ebfb188f0d8845197c72c8e1e12d862c780e62aa9ec6e8e40e736cb88e54a578d4d0a73cdb94af0b875e470d4a6b27e30f619d607d1742f3c50a6f45fa3d2016f3e0b0a40aae5cd2b57c4afbc9c5d0f0de5feae902633f950e64ea8f60b951f9b9fdf22363fcacfb99f2917e3decf39def2c93a1b8fd16eda21c4f052aadb92fa3526efcf2c7ef067a815cb2d94be42f3a2355a9210b1bf2a0850b764414cc59ee583eb1935603e0e60a41842936359a96f8d8f69122c5a7e561ea8f8c4e121944e20783f1ac34ff600f1bcd6a3dcaf4053b3ff7acf2c3f4b5506b663f07f892da5ef228c05566a8bb1cc90fcb2fb0dc44af652a2dcc6cd621013e47d90bcbc207f309a7764cd2db9c898694814e6dbe06bfc3846fd5770d1cb52e9411f28c0bfd0370e8e156f08b835f1ab63fbe950764197cbe83a9f66a3aac543da0a3a75e1e129aef2b7aa460d7a6f4d05611d1f1a33f29e516199378e548aeb149f5d1dc4761926daf23fbb02d494021f4cabd5ef355603a88123035bc41e18a77f7ba5738af001d018667cf2151212c6fe8bfc86c348398bdeeac8995fdfd9d6728c41ac1aaab93a3c1493e0c0de029f1cf3efaf1e4d0db045b0bf9ee51c42c3859fd3428fb094c7448da877a2d7fe61891d962e5dab68d040e945405b467a83439b08c5ee6acf37017969e7665bbeb0585968ab43a761865fa4c9864edb99b0fcca97c86d70b114fe69ccab269516046197f7aaf6586f6f30216debf8dcbee5f2303b2dae49f105d0b4bcedd6fec5e5e8ac84a48fddb19c5dd033171bebc5a4b55435aa47241a1a66f8f07c2ffcac05f56fd6249b7a11f7a5b830e19a69321b0a3b9aecc8f3293edc539bb93a758b9efc00965bed8dec8b8b29ef586b1d667e9fe853d8f5707cc7f7ebdf2e998a139c64e4dadbb8d0424680d3de5aa80c4ba68166ce6f9b845228b7600a6277e1a7a7b506612b37a16cf6d87519f0701b04bd46eb326057fd57742a05aecf9ecf2c21a050af5dc0337617fb88c734c065d96585590a009af33c4fefdf65364687d1b8fdef5324b9275d038820891fd7483c1b8f6bdeeffed03fb1fc7b0a617f48b0380a0341967df77d09e714f60018610b7965d6c84967acb99de491b71799d4aa6eec4eaf3681d26a66ae8f3fe4a8b288f2f4a53edb9582aaee1fc27c01cca73c150b5ec83c4fbd11dfac42a8a17d6fb225f92f9cf065c1777ab801da82337274ec0cdb5f7d29a0a6dd9250b35dbad2b141a6ba6db817359109d64c3bc8c833f98b35c690d2923cf22542200950aa9649076f112df305e23ee9b913d6ff88c0d9bdebf26fabcaff80f8a41dbc5d1f1a750ac1034942b1cb6f762e48ae6824cc2807342479ec98e75d0df2b6e432876ccac90c113e02a1cb27d549c9bf7c12bd8cc9a13cde27ed8e2ede6fa36f0757160f02ee7b137c9a49d7474f715c8f19c0d29b12c8bc43e973a8418d28d56d968520df7c677767c5668f940afdbde1a9b3703147a3f5b994cd16aae1eaca50b6be37c06753f6f2075615d9a4ae2e3e219ad5eebfdd7759e05de4545996f9edcbee0b98ca0d2c3f05552f95b9efa5c20bd68f2feaf92cf5444c9a98fdb219a10b3a6f15ecdd766166b1d164d252b115c6e30fcd34aa4d897663f6738f23bd0e9c4c0892342e53a7b2d8c0423655ce993d17378bb73d8da7dd239efec5497cc743ffef3aba6ee1f99d98a01ff0d0a369a69631cff3773fa85abab25a9e8e995fcc3c7669ae121d1a0cc50f35f88d64b35f6e67f1cb7f735a14837b2800371b2228a3d109f4f9c2ce396796660c8cd83f340e50c8b514a8ab01389b1a31e68bc47bb8cdf850aca6b1f6ed3acc9dd4ef236ba6bf27bc87d0c2a2b896250b2ad2288685cbb659f4275039a0f072b53e0e7da719e1d3c742d33941a348510613b18bb16f063088ab0b7c91a6b9a78e4092ff77babdd7bad05b18aaeb16a3357d725fa3e397a5014f25134ab2c4dac05f41236f8b60f3c4fcd2fbf9e0eb3d4603ecc38ae900501f63826c3f484ec2a9b1723a5127541b1fc04f8e1a55d5a8ea4c7b41015e527f6bff8cfe9925f0fd9fea3948da3b1809fa1b8c656facb95d4e91cfa143da4f29a243a57adf142c6702c2fcdff7dfd493e0449c14ce17bbf2f5068e386827c3c26af2d0ab67baafd25549980204a8392424bf98640e119c7a5cd35d7924b975e5e75441b66c48d22f5d5e9fc34a2c824e3658cc5df53c69c1a40836a06de103e39763a3232f7df89eb0f3372632297bbd958460987598af06af713cfb690aaef4661a3c5afb764747aa54db3e114fcefaa6efd20a0f9879c159c41ee41925598e42e494b240ca23624428aa3202a7a8e05c0bcd76bc6b82c2fc5b8b7ccb400d53a17676a0fb7f76d38fb245617d9b7d3cf854c3f2211637da755d0e620b637f6218fd792147658922375c262071678f263c2b1c8a0ef7129656d5a0e4152acd7d23dcb05f10f1ec9ee1d3eabc4bcf5c52ef2bbb74577e06fed0e740c3afafc978132a0eabac1d5964a63ca5bc4cfc312792d01cda6ad412365dfd3e1afa873f21a75c858c4cd13b179c67a3837e7e553f1cf86d9b3ef6b4822d348043e9a7be395c94f0ca2cc6dc7f51c2fa5802da25ad27ac59e7d9e8a02c160bd0d336adae6aaeeb8a15324c97f1d5e6f20b1f7b2d523d8bf0344a3b7a64931a67d50ebe0981a058789740b06d758ea9abf7324317181c1bcc45c65e3e5efe1183b99b0058ceacca8d98769e6e029815e96ccb98d158d47ef329c483a385971baf40e57b339ce0ae1bb87a672b9de2abb71f784da5258a3773f985e7dfd53153796b335c6c0db0794f5c1cc9cb4e4eae182a512a7ff6730eade6c13f492e216d032f084f176fa9a59faf424c09b57abcf05d91fc5f21577a02e1176ca42f49edc2eebd0366df3269f3f24d8d3c03ffa829789d102e3031e7f47ffd936b7ee4ef0b6c2edd864c565a806d46aa3e1fb9ee0a21db8da6f21135c982842fe930ff794857d953b7c9e1774aa6909265f26c4f6a3258558e36195e3a5d2db821662b327b8b2c40f6ea49a24eb04b448a4f9f388961c3df667f9960171182f7c9d5063665cc55365e1c7d1e29d63c8bb37ed8b841f0519f920c190a4d88207edb48c45577bc768dd73286021b048fd88287d0d55dea3255d111b230d5328ce5b804a33661945b9a7b209d1404d398f6ff6398d2665c4712746bc80071bb0f5a5264995d66c1fcf6c409b7bbaaba9c42bf369c3672723162ade93715a5a83dc52f1980145c6f4ca60dd562efe5c9ec78524dba1543f8de05d0ec1409f0d8373d74c17e406ba79b24ce47619a621cf18e5eae1149bfdc1cab4463f3887cd675831a1799b3c5e469001786f6fc0683299afe3182e288e4bbdeac9b1d1e6af3bdc7ed63cad1a6e6757614d567331ddf23d667ebc1861f23c2c30557f02efd063c21d6b3d7364f8b5f20274a50f0b1c947e641ddffae2e209a79ed0ef403f309e0f76d67eb272379692234b32cf0073ded75c97ca0de931ef42c4a2d0b9b8ba0a8b07f35f2fc9b13e8783e681b27ed13c4ab020ae3e51ef462800d0d20fa48966bca670bdfbfd8215aef44e39e58585302033d5c91dca952a8a3973af9349f479a15f30095781ec64ee70fede0f39d8a52cf5f104d68d5a1ec4563f7b360037937fcd85c6ef39223831a0616c056f67003ff8b4a08c188e11eb55e748827502bf7c8b374ebd3d027ceffd69e2616cb80659a75c6a6d9febb921e471a4c12d3a0c1da95b5987514d4928d0f2c3dfbd5016cd7a5a222e2f11035df895f815e0499fca52233bafca42bcfc1e512326f3d4bbc18b80fd9ac0123a9e61a6d8e250fd437926ce31527568a74eca67018c0984fc999bea0ff9d61244b6f639e3c5feab629052d9c9e6ec4571901b940d2648e7b2518765f35f501b67ecc5af7a86aea79d380bbfcb3a4fa46852630082003ed2a9c95f698ca240138dfa575c374802652260d1e65bd8fa12ab769236f3b13f44995bb04090c1f5009963b590991a315d55a9c52721f850cdd850ccafff64cdbf943260cdfa5d561eaf57b1b0b18f84c9f31334715a5289d8f067754b4c9336f61a75e31027723a9f14912dfaedcc5df959127fc3e5661d57781b70223c8087b340044d4e86f5de02124901f148c57ba139a962764308c1e6e237573d870adae0aabac5d4807520939df33ba6c8f317c9f92d07158f118c0c386616e3e0105db1720b7c43cfc218b34824d8e608039f6c733a1fc46e680bd9434c7bea71247d82f910419e935960385a4026121b0343fe6fa8fbb2732dcde5305841e301d73813506e151b2b0cbc2ff76cbc065df4fa5b247c4d0266b2f8df9375b0f40398ef27cb04f502e14dd4b6c18d6846a785b71953a8ac6124573eb50bdf2c0a6a786b4668885c7757e2f74bb3f4efbf81c94e3e5603e3ff41ecf3dd32955bc7a201715b94ff9c98573bc9226a7b7dfa52db12da37b151ef4d384cc77e156317861aa0a201fbe0b227796755608a3b19ef8c362b24cc6af7887f717f52c0a40dcf03b16d162aa4c3686c1577dd67a392e1757811e98d539e8d155bee3e14e3535a0bd688ffe3f337bc989d99ee1392614abc0126ec4931e69dfa6658c6e2480d5766985360853243494c4f244ac10b71042382dc3bcf76eaf0184ccf1d43c4e5b50ed72382c462785c1bfd3a5b7cd6d616e45907cc5567dd1090946e6d3dfe13049217d11dad698a2fed0caaed2928ad214fa70be71b3b9d8e8309bec14d925264f0c59b57a5045571660a9ab07158de4608db3a9d09e6a4173de879deed2ceffb2611edc067ba70a53125c8803a25ed390d4c807512d574bf82c75c73b9c339d5bf92cf03ad04123c6dbe96277ce5ad13337fef7b54526d24b657aedac57c335d09313a1bdac7fad3db49453247404d3ff6c05038e9266e32285cd0fd1e94c9a9ae5fff9848f7bbd387721458e484a5ed5c28ed55a6289f83c872ce849dcdc6588771738b8d96a5696af5df27ac5f4f275eebc2731f54c08c2324ca6f5a915be970193f8e5526b6c7f158e7edabb6a09e9a6abf6bf233d5408eca83326c547d19e4394b8b9baa758699964aa550591b86cae86dec255d1f098623b7c2b6b338585ed1af73ba1ec48607577b44a3b5efb7be3bbd939a418c3c473baf32b61e9d5b6bff3f163aad01abbac4ffe61502063833935d358f3cf05dbbc84ebb75b6a1ab3d1cd191560ae0cea1ebb431bf1cc1ed15a2b7de40b9f9f1efc3cd104a76248cad10460b3b4dfa284e6165d82e0c780a20d31e9a43ad6d50a75ab0e76db8a69e3815012f61d078cd137326459aa1418059db5584820ea3c8c40526cd4b443fe14aa5f4b03c6038343064b0d959f93422ab99cdc2bfe365cbdb8a808957b33e97b39f6dd5429debfd08bfa41dacae8fe8dd023d00da4ff8db7be22ae875ff2f3fcae8a61a4154c57c0864775d2f848555b07c686fbec69502c440a67e68b40250e93856bc14dd115225e5e6d2b07b0ab2a2b2c4f5d6c32a0304420e794acf6555594e10b241f49f0f230ed3ed94603edff9745790633ee8feb125997736c1fefa6a6a3405fd6b82b78516d7f66b8e3101f3a9d37ec3d250147cb2a49567bc34e26e788c63a785d6b45a1a30cb8dedeae2db7d90a6473d5ec4260f9593903967eed5fc146c8ad9f7ae1884f127fa2c097da56d585c8c7f6a67e92e9246cde9e5fdd06d09a190f350a0532dc426abcb86a8010d6847040d147916c29e43be75acbf849da5b96e134fa3849394cdcb6a76e6fa26224d3b90b2dbd57793eb0abec993745a24703c1ba7679f58f3b57c641510f200083bedefbeaf25d6f17d477dbc6bd07e51340f118c376c5c41abb754eb0d0ef85ef9f98aba41b761c4d1e3a842949afddd5314e5d57790a774fc3ee0c223b7584bf067396fb0187c42a4dbc671cbc01c71a6eed095e4058a2eb6b15786e2db17d6715d2ac6c3926a5b973c26d33d79c704145d72b2880738996295d8f738344eaa5c2fb4898ebc11489a287afc982e5e31f28479419454cb1b9423b0d5832998501741c27731bf650d9b6ae114c4312e948ee8261f67450222d2a07d156876bb676ff220420803fba2e1203115d89725a2e93692bdd0f1a4f46313e83b652c59c62f4eaa7f8ff7bb6fdfeb8d898e676bdf1a9080aa655d2191b7d41b49a9b8c010a04df35558dfa44bbf535aa506a8584114d47fe8de1d4f8007adc19140a0452e18da5ea7f6c7fc697c34ca6044834a17ef30516b2ed16f549bc72e407778f4032c368ecdaeba1b79cc3d08d51eb71780ecb62481bb7304f80cd70444276d0f14667b954afae1b182429f1d34fde423a40998175a5de4f24ae9c2a58caa5000ef63d23bb3f7885aae18f004842953887c5f19ceec7fb6575981505f98814ddf92ec64bc46665bda4ad1e0a1e55f13e44be4206661b8632c027c25f9d726e0cd0f3799246a404530fa8a1d7c1f0307fa894681ffb411a88a1d520f3569cbfabe4764a1ad9daf821c29f45da6223bbafc88f21eb4090bea4dd017fb66c88ce59e67fc54e9be947a415fd324a071e281004820afe15b91b6c237a9375dfa9516ae256388c89278b05fe7b8f392aed97eed70a33267dc08bea6b4d2be1bfa0ef45712a6aeadc3567b9688ad15b8905cf840a9e08a6a3158c408a3193af826c0e86de8a4f2a94bddad0471a2db29ff7a93669a2c8f5e5aa5ff9ac0c6fa5fa58abfbbfa8cf361bf7c28f9c975f360f11a98789216863fd093f2d7a5fca7f8908669edb1dba0512d3aee5c1fb7d8bf85f623daa31c710ea7cc648990b36c533303a390424fe1b4ab2e4d8254a05eb94c8849da418d35a1bb15ff68885ec32b88f524814aa4d7b9c88babed1ad484b6ab0668e9452fbaae0b0cecd1b78cec1d5b0514cd1f7edc6b9346e854f715c0441a5e832a7be62f26b8e9953aed5716a297df63060989dc6309173a96b54dbfa274aef2da0eb9f2c89cae8a5fd4e7ffb4c9d1965e991195d3b6d119dadc3d4acb0ae5dac567edb97ba7f6335dc34247f74d40df47842c91ab59feefc1dcaaccb3bf9c2b28aeb098b50401faecb32040515924758d116908f91d078bf7abab8f3ba58895b85ac8831152af4b3cf128122272757a8e9bd93eb9c6ffc6e553cf3a6ec9d5d5dbc38fcf44e3545b56812907aca2c4b6dd9b90a67baf6c1619d0a502e277593c21008d6026efc2c233bc4fc16098a5d9ac37683ef44961faaa2402f003a8adf4ed6d4fb99ac4caeb113ae999e46eb9c4905c683b71e8a80da62c1f4e1bfadfb2089eef4564dd11ec327b616d825a78edcf3f9dffdc5cc650baf7e828d3bf9c3d5c07a74505a7ed3b9dc37935e82163c703835b87dafa3dc01f1cf6c8e03ac06ef763c2894910a661037a3c1133d940b799d5f08bdc70952394b929889ba0059d1eaec61dcbfda1256c70e42594fe4278ccc11ce0eb7332f4455a6dffe5280379208725d1da9df2a552f63d0f0cb6345177be632f027449dad4ca2808dd9b15b6ddf7d3f5652fa4ab74c4d2d16dc4cf05a2508b0bc8fee4bc0b1ca15863855dd44e37d8119c209cbd00c9efb2c14cce2659aee0024bfb38f9babc229b89242513bfe896a678f1b2280319cafdd38c4203f0bf29409572d0e6382aecf9d8fd77df4d0e1a9977e716e7d9409ed847dfa815d198ad53618e8daae3cdb081900d66c3229d9bb91079b84fe76c072a150fe590b1868b7fe7c5adf8e7955670d51f75d6474fb6ed9b0778befd002286f0d5a8d6ff7f29c6feb90825674e4e7de2f4ea1520f55ad604a605cd94ed62c325d4c6171c47c0bf8b9bf03190206dadb0262d06f3dedd0340ef6a2acf74895d7e476a593a213fd4276ee8b4bed25cde1cd07f8954ce73372a44afa22e1ecd46d2f26571becc97a6bfd9fd0116ff7ccf6584556b5394e8178b29500eee8a18f605dfae56941c9e1761b1c86171109f8e8ff4f22efd796c9c0adfa5c059c4814e4a2f34f91c121b84450310a760e4dfcf053db429a722365ce15b4ca46c59a548c8c4dd950efe6976dbbd9246d017a1ef151a08ea9904b05e165d8bf0094a9be7e3853ae64094d36f1751c4fdb6ec0f6659562dbd65e9bef6be09c9093244ce21a9924c9d96568013b573e7673527819766b0b414cc06128e69ceb8973926928c4ec09c7273e86532b81742a3a59562721cba608a1581d92cdedcc50c830e7355f057f58ddc10c1b21db9cb7e98b9b38406de7b6381a5b8888f5d4375af4e853d367ff8a9f1c55d7a51720f3e4cfe7ec47da11f1b4022674512fd6784f4288a3cdbc101dc845eaa9ae34e1ff1ce50aff790fee5f7d026813a879cebe496af4c2ea2fc4503a61f4e0646b66164d632af842d910c85ce64be690bc454e640f138f90f907a4846fcad1f317cf19446ccdfaa5e243f1306c484f18b95ad34256cd35de465cb1850ae6c05bb75a9efa16999059e8acf6dee54f81bf0a791f9f6606807a43cecb068b90cd6081ce324fba8cfba520657fc6d4b1e3ae6a0e6979ebd890fb63d49e930bb3152c752ebdbcc41847b5465d57a85628b53e1f916b0c26086686e99a5688fc55ac9d549cfab3bf940817d499d71a7bc21cc0d85f566ec2923cae8429a7296d7338d3703cab50d8cd340ef0a813cd02c0e37842459f359d9344cb15107baebbcbedc844e39f8f94c31fab3db64a1baaf475ca0d58913885665a3e55b33f0a25dff93bb5eecab15594032dc5299330544d7a02be8135656df425463b07d8e066e28328e2d32030af7c8c5b8e8c75d405168eb3c33e1a60818cf0fbaec556af0759126dc07f41380356966abd019207430d081f5afccb4f5d9980dd483d9f576d1f5af8021db92ab1d9011eb22356e3e66b3d196745f094d2d9c81cbf8745fb8ec0b01f638348bfe2f05f9ff19bbba4b72f24e1d9e454584ea12472b55bc9ad3261517faede515bc8c96326a4adb9f52b08c5416a1426473fde96aa1980003606a32fb3d54bb4e042f0bab1ba7e2e7a062a427aeac9754835dccaee93b3232a6849a7ef7e40a8af95e2cd748b5e7ad32c4f5e2d414c6421f7e5de0dade78d00ae92ca8e581383d44555fac3d00b30da4e80640d4babf286a54d2385e8eb527682da735c965677c8346ad03692571ec4d11dd59f83bcb33c612f73dd939f55026512179cedf5b5a6907deb94c9f070b5a53c34f556eb9096ea3b0380436c32ed8de6de0ee633a9fba0aa91bc9bf0c4af488d7e6369355f97591f1419ea932b8cb60edcca6c0af3d624b9cd1c977eaa30d3eb4f24121606b6cc7c60c54aea96a023c4ea8f47cdacb85187aef118f6a41e1cb3e84846cd9a99eb5ae856c67adcb8a43f1e20029434a11cd5b2b81df6b91dc53955d4ea4020dff7d8a4498a28eb5ebfb42416e55567913de759f621f70fdec6b03cea5425b93007f31ae55287085315570a6199995c2cb3cb1f7b8bb8645b2d08861fb5c6f8de34b81df45d65224078df1c53e918af9bc9ec574205d2daf19939f73cd3abd1cf4ce285ddd43b1b5ef6e9034dfb6c561a16a3cf3c8cd9afccae814f3afedc3802f306e0a0b53a93eaa259a53c488c7bba5fe7189d52cdcbd00b4096aab9bef1403373d84b1a4a7b54a8eb854a809f8a13b27b954cf08b61f40a4348611f73b5db4615f837182dffb86d2a7864b025fdfe5151333e59ac2b127ce2893f9f1bb76f3b978de015d54ea8e6a2ff04d79893bb1cdf82c1b0b775ba9b16f4e2250436f091779cdde98a5563e8859740d0202ac57afa4e774c4bfaf6d6325aed65b11fd5a6242848b2b30599d6b6aa871dfb19f93857f8447536ae3a6969b5875f0abca1b7d48c0e15b36910e64d0a29940f1f010ed9001da8654ae82ecbe39f09da0788734aef5bb0dffb7535bee2eb327aa7ed3a50e2982d2dc9431b116928c95af5a94a11dcf78912831ff84cbd539f8016be8a5c61b6400f2ec56ad3e385215eb0a66a4d742fa53e2924d240de03c538b65511fb97e8fc6fb392f260571f9722a5f3ce0d6af7cfcea033c9f4737049ed650772d019f56f4719cc593b214e8e96f80f7ee18f0638b359ebd18f3d196e4dee59106d0f26c34054675d3ca6eb2d7ea444e9a7fe28f264b968be88d6ae19e5af30e8d8dc1bcc1b7189c113c91f6da69d396fdd1e9e7a692c0ad036ec0d2bca1d626a80a515806f1b921dce24118653e7484208051d6ab2e5ea3fdb16d02c41f7af2a6ac1c2f1086e17955963b75c3e4e4df895aaa2b95a2d02b26680deacba9ae0b0b275b535e5ba95dc11a79f4b609f71f3b7fc4936c712653599d2caa81e6771e6c58ad032cd368deaf95d0efbaeb0dc10982cf75cf66869826a7f369610f30d0d375506f62da23288c95ebe654fe7f998e18646f338530430a9179e2b3c546395f7c702adacfb47084ca6bc7d5e4978210fce4fbd0cb25363318733f3c9e8a1cd3bbaf54dacf8e058733f3c26e9b316c7d7d4a1bc78619a1bf1da208e2f68afa16e90924968d0b6840527fbabab4fc1509953b463c42837394e024e9a36888aa6fadbaca3c7d4e4a56eb610c435b9f2085c33ec2eb984573d764b6210f58728b9af584c9c791d532222d473be4cd7b0104e400b031811cc50419beb20abcba19869bda7c87a2659b3e384c97c1755227bfa3e8fcb7e2036a2e1f28732a10b45db8c9c2e27ee9e82748241c7a3f54942b93abad5727e9b6780206b7c84681220b5e0f67390786505ced7c206c7a44afcc868bbf334d713017de8deea1f0e884de93e55f4c2612139a609927739ca1b2548aeea52f10991e77f99d08a894d80bbd269ef84250001b9f01a6378794b18dce9bc62aef06b1f5c1316ce9d6a94034744ffe161637bb56bee263d2c5f31eca43ab7137205cd10873f6ca009b5bf7167a858750a52d1ed09864e6aea63ba4a9133346214a47735e89471850fe28ee0113e1adcda41fc78b509d5e626f7fb92039e2839ec8b0509ac6a5fd2d374e1b780dd75c8d465ae7f76063ce0c554512b63edeff1ad5a49f4ea5e30b484e7ee30242e4253c573df0587edb7c3b5f3e318d624d1bc079a650861caa8bbc198a6539ef2e3e68aabbef59891e9d0378bf532b57ee5b159293a046c818c53bb5ba8170f0a9f79af5318da585bd47c8e7dda28c0e5cec595a34a82d05daf38508323f5e94334471b781a3c75672bf64024d253f06d2b7f38d124199fcb023db22d56a1595fc3a4bc43cf4f542bf85c3cdb639d62216f5bfd144ec3270e119b3bf1210a9f774d81d42881e5e0ce20f67f241a6269348345e8cb470f6c353587f621e3c187b6eb060ae4287d0a6e098ed2d7155139d7ac28592a3d05f2e551f9102d3dfe8fc20e6fa5271908634feab708faf8631607981f8861cf0fcea0cca38448030b1e82e6618286e8df6ea6305948c016733fa8b1794c50a31ce7f378d1c518bd70b5fdb8889ea2ef03d619562ab05ac655e1be88359714cf7aa00383de79fc84a78899a5b03a953e9282b5252e3f44c88cc7212677408059f088f0cc1ead9124047e8e8c0b8f318592579f1201c485402c1d4af371b0def9190c60dc50151d794196b652ee359ffdaecb04d4ff4d848277f627ad39c4affdacd3e719b88d2c042b408e9e6bb5875b71694be97dac3bc20e058a55ea9795b79fb39ba5d3dd0a7b7c136f0c243a6282a46b9c5d76fa954f79bfa17df09871361f83452e031c5091670b9b945e706e8df858aaef17acc78eb674d015bb3bb38d1c36b174852e2abdbf04802611ca48757776960b92aea198df3a798ad510935c1ddde376496c0738afdf9c1604c67486cd7748ed1e59b8da669e52e4b6d711ba7814e11531fcd35d406abdbbdf602b55a1975a0c05c2aacf1d72bb2b54c214ff07e99b9ecf30c760ab18d1f72e40f01989a6ed55922eb1e13ae79e3cdb77ee83669592edf328de3ce6037fe8b2ebe5feb643640bc29cfbf1b26565dbd909d856eb0e774c736f48d6bd417d24863fe82e4cc519338adcdaea2fb42c4ab286a1844337749177b231a5ed0d68a5fb9a71341a5d1dafa7f40adf057bceccd56f531a4839c8d5b4928e722a99abf63f94d2b96aa858b514652117d824c1e2adb5cc47c6958800405da0edac542511c673b045af74222fe8a94ded7fe60f095b8a08725b6200db4cfad92c57bc44380de6e3e54684ba80527256293d0145b3e0d7dfc73c6c181d4fb017457539c26175d6536b3ba83e316b2a03baea2c53867b5e73cf481d5920a68372b742370c233f5808d63e1ab05f49d6af726300557e08433ced5daa832048babc14f551936fe8750afdc8b765fc3dcd70353fa33afd57ac086e7d0c39253d3f38a7c8d7d9fb96388dd8287db0395ef5d10b0f41b6026e8eb25bd822d061495d0f577c10f13f0d3f9f57e8b5ddf5c827bb3763ff062b0f5cd67ecbf07da16e47272c7540618e3b29ace96b91fd350fab1236cfcd43e67980cb43f7e5dffac636d7bbb7b333f418d9857e8102d287b07f8d1b93d7c85cb7735632c60fc8d667b2c1070e6da3461f3178fe2857353bcefce739a57d06f68beac6473f103966bdffa74b19e14b3a8d89b9cb7870be75385e2631fe39730e30bc80d91f7ed534754c8eab18d18cb26b145e7034fa6394643dc8e8487a48f3f232798d09988776ae77655b07a1d6088b4db8914047475735a7d4f6e70697b6d2101e59a387b5a8963a313d68fdc940f158f851b748b824cd6736363836b16902e4dd708cf330ee27f5a8403213c02944018c9f67cb628dd7b58a436a115f89b94d4cddfa32dacf82392ee6de2a38f0e221a2fc050501d04c7840a3638f74bf0741b9b3b03d8fc9f6329e48692d4e294b4dd1ba2f76f9037f56be3e5f5e85cc518b7e77c9ad26f2497c50ef71b95002a44a380e6c5bf38c74981022da3ce5223535bf9dc6a1862d138f3efc32c026b063fbf5a979689bfcecde939a12648b260ce93c4c179231e779b3feb3fb887bc7d5a3bb62bcf9ee9971dc7096ba6cdaa6879e69ddb0d57243f90ba6aade057bb8f19c7fb4af6602016c1b80824f65437da917a95e0f010256e0120e4da0a7184ae32bd0dd4608040bd3a5487c991f71291b0c5c41c51cfb2d8a8b9bfcf482b405c1054449dcb1c5969b923ec30351831c573f5c7bae08b4b7d3339e523e2dc05f97cff9ed39a5e93900576dcb30ce7c216207d8f09cd561824c1544d6356a207a27179d71aa4be3ec8049e4981503e321669612de60e935cc7699bb530c67c6a17194d101685c7b1c59aaea0352c4277540aaa0ccf25ed3ffed5bec51fea0259dbe00fbf84bfe7aff1aced4c47b0d327331e58bbdf7df9231f4f1208cb6f4b1ac2e9cd58bd85b80c261c3ff9d2d5f6ed3dfa6ea7fa5cca4403cdc8b63d480dcc8f6845cebcf2fe2ea34a499c3a94c9026235a9feddd5db4b2b4cf0a0ab0b4eeef80fa9a2f42518712b89275185a46248780b6816f5e68e73c00a380b7d3951e136c1df13c55adfbcf10e33489b110f40174265477ec2ce6bee854b0e149e41a5570712e82b56f9d8d1f72390e2f6f8739a09fb75f7f958ccb8cd15d96ad9de41239d7d0d6acc640f26d5949ce8cd8de1a9af6844c10facde843122fb669d4a09a233c31a870d55a597d94933c4bd104e405a726e8ee2247d63ae96331e69257731ee30d5d7ae0448bf9fd422ad9ce2e601f09479b9154089720edfa5a79b3aad8af8cfd0a270b3ff3d639a100c15552ae2368e71cce99d6dc105f57a195fe66d72ac32a075e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
