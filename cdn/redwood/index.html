<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c26c556ebe84f3cf8c580fb24043a24f4ad79d26265c47fbc841610f3f70fb483bca1209b48287d66e31013446c43ed39b836ada2eaf1faade19445d0b734c33af63828d85de1c56c5f856e7f353dac12a08898096d27847e0e0a67b41d6344ef75cddcf6094860fe33fe4462b3ccd7145632ed430ff4862c8f49e689bfaf283067e48c36850e0153c0057b0163104e571c6f89de916858a59c950ff2f13f79640bd7640cfca3013dba97f3f7b02c44ad66a2abf1d67ec30c7ef338d9b847e663b9c23e97b6ee7c9277c6d8fbdf98e29be9914ee6cb9043225da1a7f0d7af26f09786f74c435d417113aeeea24c02500088fda63891ba9b6bbeae224a9e57bcd0aa3dccb279bc0189f69e29f004b1882470999ff081eea4a2547562301096349c682adcebb9b926b6370c4d5067ad6fdc0cc7a921efbede6b4f6c9c6a2af6eee62cd8603afb9c501f98076efc7ef8c7652784af1d7295e76483a19957958888b8d054213a92456333c5217b8acd956b55295388021cc189cd644d67b9884fdb73a25a2897169323c49748a50285d98f29a4b385168e33d69f43f178b169240e63650c8da2a6ce13548e0e7fc73104c24c4e0847d7fc8ca544ea1063227731cca02bdc65b7847c08d83b8484020dea6466a307cba5c535d69218f9ddeb3dbfc3ec972d132d22d6300261331490ad0a3566ab86d7083aafb08986d9481fdecb02dd452e7de094f573a5cc60cc3b36a353158c879ffa2e6431974bb778b5773ebc1748fe71de8ccad8f4f1d44f94056000a8a225ba069652be90d16003597e6022268e2db486fd6ffb1f42f74edf49e7f835fdd3a601c9cf4ded720c8e53753946b5ce7b5bb5e58ca4fde26131e0e1238d9f16c324ee27eeb0a37e50e73205fdebd6a1f9e994b7fbf1fafbb4e0c0aec9142af26160c86ac9d4daa9d2036edca39f616459e2acd5b254dfc2159018c8ba5d87fbfb89491e5045b68b072e32eee85ac949e302da16d61053a5a779b4e6a77bd4255a0c390b2c84bd11bf9471c4fcd90c95fc7f4da91253007deea16a3ea218a485971b6d0414312010a853d5d3574e5a41332ba627843b95cdd31d20825e27bd4573d3b63622ef2f25065352422532401a4ec32b21f4fc9b18232f8a169d34a9da5c654bff7b8375cc9ca226a7d433c626e4df877c8dbe96719cc0494b18bdf88cef1660eddc5eb286d21507c7bc7789b6fd3ef190fa2fd52b62651dee2b13c3e20f21af1d10eb64c11fbbc5886f0ec33155df8a8fd07d96a4c95fcd77bbe392692f380217f05262ecc767887e51a7309515de9cb212cd992fbd4c7dad1b015db55a16ab6d708efeb0e1c9dae653173d7dc6b832d2795b6252719cb74e68d05915d460d8db6eda8f396702f002b4d168f4b2854b83401e54e6a5aa512ba0fc06a286c5d21702ed59f26a6fdf1507ae10f4529e9ce9a0d5d5420cf1a8e10ac145ecdecebd7efcecfed2b8134325d21f37e9e92490388b65d9a0d91728ab2c37436a70d528820ba3ef1155ca5078036275d4ceeb1d0fb4cc9ead24ba91fd14a9c75213e60acf8f9b1e84ecc980791225cf212c9e0b485013cb8edb3a070eb08d6a3fa9e19cccd7c050c62bb0aa4aaeec525171e07ca620d400d95c1ff52d96baa308a6cbf004aa2e9c72c6b7acc414e37d971b8be88a93dacbb6144ee789a42277f6b70e61fc86f8d8a69939061725c76fd049b042f0d0ce9ed42aea481543d3d853fb964e17b30ee53996287785d734c4852a7ee0006b805fe43cce328f04d4ee212f2f3df580aa0c85ca536d0d1464e35a69935dc87ed0babcb567130b85bb8b5cfdddda6bfe9b520fc52e351b2abfcabc9ff6f53c1df96218a8a0db3bfa6d978b7c016386be42cb6911e835ceb5386dcd4247278c8e4632428eabe325fc46021dee2afef5e12b93fe64db57e2ad4c606110669053031f7c3223366a4866dadd8d4ba52211843776a9c4e3a8a567f6adf53ac55f09384f97cddc0ccee9917590d453d48d678c493fb306276e04df070ae6aacc441f05ab909499839076131db4634ef0cb31edf25765fdec90816c3c3d124ac782e90667ccaf51ca1b6098325e7916629f436b37f1cad68666f1ec1a37a1c78d68a8075473fdfbd9b7b595123bf339590a39fa543376235b67fd1b316e774739b6c1185eeb223ca01800a0c7618c5b71419195bdfcb0b829a5fcecb540f13b9b1dabb7942ec7d1fa162dca86225b259797f52d9d196ffda87b2af519eb143c21877613f4fc49e39dc0d25be173520c698d094f1d3f9d9b6f2e20be6d65a53aaeadcfe8c4248c858178d53294635de63418cb697284c7abb27880b48b88d2e437fae606a374ff25ef1d9c436dc0adedc5fbbc5e1901f3cb4d86c5d7423c9823db6fc30967c39b04de29bcfcf2b2c4014d853a091672e32ba71a3e6bd06c1ae1008374e1e8dee0c20c235a856632e48fbdfa065292317c3d7ca5c55734f6e3e5cc722a6c4a4d848272dab8210616e909906fbd6147df94d53faeb936e73906d33e33c1ad3646e7774aa856b91c45d21369e14a137ea488aad66906be9dff87e2f18052adbd70c81c55cdcb6477549f7059694866cf7b1167abd23b91b32bd927467bcded1e9eeb7eac87b19d367c657adb0e63db26bbcb287781e7ec4bc1d26db09f3541bc10f64010ac9da8581c0ed20ad4508385e230da1c7982af8478abbfa3f689fd2bb820f3203e05e47750fc1b5aa8d0c01ae7f892a345aaab9b8b907281b518fddf2cee04dfb2581fa36cbbfd512c853ff4b5734b61ec2a26a5e06ff460b53b431cc711702a0c25280ca70be6ed33d09783f8f8e0678b82b9f13d06500ab8f6c783ece51dfd4112e64f940ee425261be1dd8b431641a153e9a418864a4761efa990d3a234b3cc7e757a4a5cb2ed091a8039b3e55e5c936e822431d33b39dbf575fd222dd5fe623284428b8d476bb041cd3c4615354de406b0c9b84fbac703bc7ce62b2f92e0d7a8e6ed65a9918c2b2707476b54eff7c6d030c86ed972731c8889639745a1a4b275b9b651bad385068a62ee875df3eb69606f989f869bc0dd4263c5238d551a28541de12adaab9617d53dae9c558ad4d63b3f483045d05f1ae9314a3156feb953cec6fa392501fce0e8da0e565b082f6159d8b1ea7de526be84cb56802fa9c819a6557447532fc6e066d055d8b8e7031503c47f795abef88b7bc476a1cd89f591d020a3a0b23b1317996d8ed5e118db74edec08fb157e870adb1efbdc5fcaac5e514242b41d6a6f35e15d94d2e0af50f167c37ed383899b9f4e823c32953a758bded5d1d69b816660ae2b9d920dad3b3fe99df24ec5b7f14061dcadb288eafaf7dff64f819ad0ddf5683d94e123b7407a2b8159afcd24e5fb265a7c7e539b387fefd78487e7dbef01d5f3ce3d16b0850f3b86d87db8d0dbabe4178963e420cf5d481708ad109b3ce75432114968de7daa5df9c0b2f2f386af0152224de75e967af231a666e25dbb050fa77709f5bdb9fbb45809f6ee2050f2f72000c7eb447b90572c325e813f8eccaee34226524d7c50d2cab9af867ef5efc20d6e5e856b3516e3de482e7b7528b3f3c8a009ebeee6b92893148442e046592903e6bcf275e242a1a976467d738af76c918211e611f4c91fd3243c3acea1b0f166d674f25b8d61effbc32cc59c2be75c6d9fc8341c5614314cd25c90df9d285810978d090627adea379e37c9d96d0d8607f448665328f387f5bf0b0afa5fa4cdb4bffa2f28888e1e91def4e969ac6f495ff3e78c3edd45037f64568eb6d0e93092035ce17cc075f48e37aca1eb715c85d1b34036ee54e5bbfab56c13f8a31f6c4a200884e6ca90efebf6a033f062d04d40085f0d38f5a369c9a679786ab3ef7aea39ed8d6aab41171efd7c7b4325eb84c171b0d6823175171558074fd50510d30ac03fe2a25a35adb3f00d8bb40aedc761a2449e42d13ed87a9ae330a5116055a3100c13b61d25cc551b7544c6eefbfd07c664f26ba848145b36790452d1a44a9e3ded69b7a5fabe4937d157162451fc0728315b282103faf3270d11808151ba5b78a5f352e44867ecea30823aeb9fd7b689cc3a396aeec1b44a3a4ab2082cf65e9d14f3d040a3a6718406eed173fe63643fd969d6f0456e2a22b61f1684a4201299cd4dbb2a6276b7f90be27be089551567ecaf2a1c852059b9b0141748140c5d621c5dc8b149e72b85989876acf2929696609c8ac3dc0a026866b5112a397e7810e812d4ccf9f2e2dc85b976edc7819c9cb2ea8b6aa816d8af19981bc81281cb1dcf9a0ac03ca0a608b74951bce379f5182d9922c6f525e7cae4a1a1cf002e805e7babdbd2bcca920d96c71bc99aa74db87bce4e18f970f0c388fe7e6dee49dfb035bddcfebb4b620adbbf84becd5d1fce5e933a37a116655833a8c7361bb7f4e3e598c9789d6fb46c38e8c25bf71c7a39e6cdbb0b5770b53b016c2d7b9d8ddf78e4b41e5ab9555cd6d0cd893ff6a0c58759be931b440763bf720c2a4c508655387dabf1a994b919b6105b92e3674299bf9f726ab7bffdce132ec6b353d5cb3d67ebf9a5c2c291f45de22230b6df6913fa05b2268121acc282549bdd0ad29469a3158a253a1c65e228e5539dcad025d1dc6e706a29f8c1370ab5be646aaf6dc9bfe1a8bedf6d878cad91623947360198707da196b572bad96df70752e11e5330582746f6d429808ec9a1f7ed307479b95684124323fe58986f4aacfd0db15da642e9e8cf20c2f0171dc9fa3bb90fc1f6ac0606824c92914b1ddd95c6cb6efe494ad0a64322b3437a7fc93e71ecad0c04649df4931b692b7bcf8c8712d121b2eb56ab403ac2613eb74dff78751b98e3f157ff1843844671789caeb3f9c6ba13e02854934d265613ea27d7169104b93a7a1243f4134134bc2efaf9a534b0e7423e890cc5f54975777bb83b1bf59000b3bfb6af4a2a2820adb83d1dda8931bb68f63b3d251333823e73fa5ab61795404c854db8f3dbdbf10b5cf1180a4274f4049a7827da339eabaeda2ae7cfd079b83e163fe601b1f9c47d0ee9a9e06dc1e057cf942f6c88a1092143cad945943bdc7fb5a0055b589940e2604788bb4a9b7c1ebacafd45711b0c86d138c2714a1d21307717ea87a1e988506915ce40ac912ce4ef6cada22a058d7ca812e74d7b0e8d608040b59abde4b21d1212313f4fe1b0d47d444f736ad20812e7a5f2dc3891ec0517b6ba0a5a97ea256622e1df0f81db2a67d2049a56c79fb7f1731db10a738d7744b8aac22f13d5d8a37f943ce5e400f6b3263f1d5023bf008f0918eae1560803a354b6dde5fd7ed0f01aac91291fd7cc5a0aeadc3e4f3b64ac1e4c2e972aa6b7b8462bd35915b273e87dc4c9b7ea25f6edd8fe7161979c4dce91c5cea997950c3d9ad85236cda64f87597235d1349c90bc107388ce9b5293d60d693dc5e18e60fce2c9c8e584ea29b30610e13ba1519696229e6d120bc16b716fa6dae1f721196ffdec2a82a0edcef08ae67ff62a8e19a480ca6a69ed4455f1881d2d5f6f583f721035b4f0fb031ce692cba1a307234c89ae62615f56bddd181f4680759091a46a7d460852ff9c6d84d3d96f189dfdbe6a39032bcb7c01a0a3239658bc2b934bc9c8ded92e6644b9fe5c1311f1be75610eb4c1fea96432afdf05f4f244e10d9d81f5e17740fc07bcccc07726a498d4ad4b703dd668988982b78939a6cdd297913d63a955aae7e4ab057ddaa335f9babdc9362e1041bba650cbaf8600b219dc783ff629be9e551b5df863bc17bdfc0b297d9972a27cc66c599ab11f4b875c48db3e03a8c58511ea8cd839eece5ea8ffdf11bbe16c52f36fb5e0768cb73296b38a9d8724a2029623587db141275af6037a9d1773cfe3f7120bd1f4fa3ff11b343b67d8414d552df7830c6ce3d9a6e41d4cf98b68fc313a367f085061d1bacf4e197efc32c732ef0c8665429cb3e753dee0f23f6a4edd254140607ed2db4380cd8aba80613b680ee3a24d200c375c2a8317775d63f162af6f3da85a0700f7bb54a58f32d277d5e78c2e304a4fc487d6ba724cb7d576f58f043a18686e3f9ede6f7aa8d59428305e69b7c12ec89c91f6d915ba5baf5c93b12de847e85c2309f7bc8582cadb532382e3c8c8067acf5a1db5d99a1e5dbbfc74062fd1ab4f47f9b8147f60d2fa1986a31612880cfe52827f3d0786c7483a80d62801693f4fb4d02f81fae5ccd489aad2ded3533fc9e6a0e08315aa1533c51fc9ab44d9d6437bc02610d9cc2b3577d09efb23103f0be3925a8ee10b46eb7069c2ac8b47aa2533c60164f0f5a0a70abb943e4e90061318038fbd878425c14c445cb759445cda068510a7a3d7724ddb84a8e4ba398aeddb9caeb0418612bc062af802f415a7c1b9fcff6f48971a7047cfc8d7f298d48d155eeb7a86b059846d73b5260cd390134cd9ad4b1c737d0044840cd1304c37527a2871518da0c3004cdcd3034d18a45c98bf013c98cfd9a7fdb2358777846eeee9e050f7fc0e725851451cfb5eee41107c6122f27676ba682b47954e78a19acc4b65045d77186461f5256b918bad7174e9e48d36a2740499abff5514facc3372edd6b905b47ece599cd46df0817d6441f784b1f56842efb15f67c08cf5833189c37cd9e8613b2a9132ce8bc0a1e5ddefbcac5f190fcd5d2622692afe92579316d928c48664db26482576479b41d4c3b30a63deac794efbef5c1e52880e742edf70f993a485685b921d70b3596ebca4a1cfbb084e433a14d83c84537e1c2c42046d940c07bc02cd69a8ee5d6130037910cc1ef33ec39e966468935eee8a11c8713736cdab20a716809d764e235c09f32aa90d6a3769a0eae799024f0925ab8b66e494074a035c968af6c999f8d542a79521cba29513f8fb838d3bfa85c14a8a609a08eede086f017034e5958f86aa62a43d7c7602a8e2b994cf62adf43692066c3fd5f4698c4527769a57033a8635f5f1c8f886c3b131f00b7c97fdaa4af6087216b7420e53177273b3f24b75c251910e71d13ad75ea3b612cd82c897fccee9a80aa216f069cf906fa9dedde469921096db809c2593b6c8284d5613a023f63b435f4d16c68f42b27afe8aea185d1a9b5e9828caf9994d7ca2004307f2e8a7fee3717fb75e736846d9ac5af919559579a4a4b720168f8220e0e43c20721fd9047169a98bf140edc3c813c3053e434d89ffd9e0bd8f9a5c89727b8ae8740fe76404f25ed564d6569f0fca79c7c73edaae4c7d190cbcf42040cb5d084e2d8a00fe64cf29717c07e43a0de0401aec96b8685255d7b81982d4a55be4161d7d5e93fa72bcaa01964563315cabfc37cc5909c30bd1dc3fe4e31e3b97474e3b5498019cf29f3c2cb8a10a51f71d6c07ddb700015efb8e016cbc3ee60ce398d3dece33080760b23b75db65c78b014cd75f65666bc28b7f303bf5dafc314e6117d5190ca69cb5512e7c1cfb95757620a37a71bfc89e88e3b69850bb8fd04172d2ea85f928d3f44b53ce9c5d860b56dc30cca90f75abe27a70939ed0a01aac4cce169ca8477794a0ec66a9b34561a8cd0cb56314d1af499c0a222feeea9602ecaa1c49ec5985464fd58a87eedeb3b506046308df61efc76e6c676f195c7a88ceb05bf3df9202fe249bd78005a1a8998d7f474edfdc9648fee786c4ac5406284e966ff42b1d046e94fb4d559c1ae2289c6a41425ab0217d67f5eab1748f1dfe6c11040c8ad26cb9a7b449ed31ea7a40f940de57b8c546cceeb9ce0ef44d1e4628bcce6793bc3533e86ec49bc1b015aaff51b5238f2083b59bf5a046a273aa0775d9c4a9c945541db077d2b356df77138ffc04d0a9111d6eb81e90255987024098ef794e4b275d92580c6232d75083a904b7dca977f21a134deab0435c48292d7fad0e1e908442363d255350e6eca9da7aa11473f2da5da52e99ed95ee3c59156fc0f5aab33f8a71f407ce8c3f78462aab4ed1f380b524daed3fc6d679b5d206fce668d8d2fbd75e14bf0a69b666d26afc4391358c85f1fb6321b785f4655f28d48e31fc6ed082d7a09f25c1ebdd7bc9dc03f428b2c23e312cf30d5f7dfc01c396ce6d1818cdbeda363254429a039921ec9211b512f365fe82fb6415dea451eb96ce175c5518cd1d356cb996e6d1d62e41526c0b398eaeae0a4022f6a1eb6a12a6480ae264227e893e5055b0607360d283d7fcd2ae2df061fe70c8db7cae639e484893237abf8f584ec3bd769dd7d293250f59e00d3268b0ab28797a4957757a6a02081ad008129abc374f37bf036820d43c52df85fcf2f0c3b173b0ce5a88447acf98f526636caac839169384c49a89ab60964569b62c60573473dd5b82457e94bdf007c78cd523c44c10e18cc76751769bc0ab5beff23cbd075e3679cdc30741f0c59d2092d82e7a524743511186c9eb09f8f4c137242acd25b3fd307487fba0b6b6a4c48154c8353f3801da4c9564ceddfa3f3569a21b6f7c7996f38ebe7b9bad925726e7f032e2d9119174405b1b520151d078bd7d423240d933380b49902c17a0ab244d781dfbd1a2ed4d1ff406a6eda394c46436f2517aae95ec598ad5017d264cd1cb4718ff940714a1bfc32933655496aacc80fdec36083711f5624fbb4ac572da99ce2af938087e47142bd0f33885f1c7b79571f757590071c654fb7e685cb6bc8e02cb615a6d2879f02dca419145faa9a765b77b2faf0e7aadcafcd54a3761857e142e6709c4c9e9a8619ab958a5e3414f761ee4e5e4f794b91fd6de3213a5c109c4e03da781c21919795bde8856680d69d7228c54e962dc5e8362fa1d8e9394258d9d99d467a554fac11cc8aba807b0ecd8f16e6aa249b9f821db59c8de21a76e55e5dfe701f807379a0540f1cf274d2db1cb48035a54009e6f7706db48c57f6f3ef74d75334fc37f04bb2d9fd76fb28a1e82c1911721d1ed8bbbc361ffde4899246ed5bffc5e01dafb1242826cfff6b6672ce542411ce0a954c3015dfc4c7ce5aa7b7163c76e15905cc843aaf3e78cdac0c0a2153b7193d79a5d39232473edbcdcaab85252256c6fc7f4294d000df8963006052f91b7dcd730c97ed7fde57ad8cfa061eae03670dbec3f28d7ee29833c725bb42277767662afca345c32f2ae172f478697885c9927461baaa664a3a336fbe2fc4cf305fe92cba138ad43638a7dd91161bb766124a16d6b4bcf61260c14205217facde37f139f1e0ad0d29e3947cfa34656441ee3ee3a427fd77b30def92a8fef440d7f654b6386e5139224afe132cd7a6b0de020929599b5f897e431e705eaa86aa6a5e3d2a7c0e06a50e7aba3478bea9286f47164de2f736ce512873656b98b5282a308e8b8c1fa8861ea867a019b04e32d1f7aca2eac0f5e5ec774f9b733b0ff58c8c41f7ce97e33c1090631d5986ffc788f7108b95eb87ae6c7d45f5be7c88a68076411e551f165a87aefe4bee3596acdb6471606def6e600a8a2322588a4b5d38844ccc767654a72d6dc02bc5df095769bac1b3da64c917524adda3f1653827fbd26bfd2a58a6495b6dbc7bbb9a831b475077ec14ef63a050c034db7af4aeb230ac9c098eaaed82c195ac770f6ce39e0175ade08c0acfe6101d8d6a5c64c89636d12b10931f764abfb6ebf93d20de4647fecf26bb7afe2cc30eb8053f53b31f94b5a805552c34fd4013e993fc2464fcb3f4c97f4006b6ae0d655170b71b6f6d820d12bff46b4cd0f2e63f0f946b8802bb1e0daacfd81c5a94e1e69153f98e6df4beb32e0367be3ee4bd9efd34eb95d7ed7bf7615150708051a9df040a0d741d2650f33b0cb01da73e908ed59447b15bc1d920f5fb2a4c5fa7f442ad8e52b3ffd8b8268051d3f5671fd66f6c4b427262c09615d23688c1418f8da6a2c643eecb01479c7ee5e986e9dc61490b40bbcfd209e557b18699d7959ab01134efd4cde88f05d579de8b3b23c5ec076a6d74e62c1a27e3e184624b3b46d7a25081a058b18238b829ae7cfdbe6ec5d29eccbf0920a2f7444ebda1a5e49d348a7231838a17e59c5f2d3ee9a7b835b679c47b22cf934b63c7948835fd260c8b98da1d15d73d359d81d8bc58ada7db967d882742be1061e31988d6d4e4f35e369f7abc11d010a7763cfd4526eea0398007d5499484342a3c1c518764f668deb9e13681c1eb0895c32504ec34e086dfad34d695f45356066029154f8a54992f89d3712ec9e4ea8ba9d76ec1967a5fabf977bea8d59d60f14f1db6e2a6720f45b50d211a409175484335bf4c83b15ebb76ca59410d3e7dd2a66eeaa3ab30b906bd385e9bb83548faaa2b76f4f4c65ed609bf335fd7b19f0987478948c70d644993698d64f43a0d9715652244846b312f570207fdc37a8df16788bdfe4d16d7c6769bca61ce7b8dc8798984c460abfd1560446f56c689a78d42e47f86f1b2dae65164c3967860a458bf55b30046c0e7203045d668ed01e429fb25285ede4a2d4a4ef068c7666a17e1417a578f4ea016f8c41fc8f018f159e96398a0cac3bedf9799828f9a12ffa7ca9de6b5da533e4f311165ff6df8d00e8e48fe14f84b53defaf8c2b0dd4fcebc984192851cfd6871b27506671d06a2d9c273b5c1255b6564c0349fd478b9366e19de6c4ca11d1bb53df84cf0bcd800aa8ab1c14e4e1b613c8aa37e11d8d4a3343787702de2b4c6b887c4733feaa9ef1e0835319ba3808ecd1002ff318308f620bec9a667d3a39e7ba66dd555e12e1704b2c6b0b3ec76f188d164c5720ef7d896602f222e315298951a2f50a6ce5428a8854779353359b096a696df87ed9259ebcfa7bfa141a3a0378d04d8697ac93690812caa7f012555f1ff14921e14f36996debd19f25a7df2f3d85acdd67bbe12bac45e8eda07a6c3de64df5250a9362b77172f5b77198b44698fc9903938107f6c25fb30ade98448575b9a7651de34a045096311ff61cb28c1fd8754af4bab223721fd51bcfcc6df946a91c45e5cd079e422f25390c5bcbba858d4ebdfdc1b36363071d3607469ea47b715112bfe54623948ba4ef625125b026b17049668442cb201e796711140c53762246509e4327d4a3d63855830c91160512422c1ff02633a96316d498d967cb27f1c1caabe406281552758518a79f2316f740f4dd6807373a045fae6961f77b3b671c8d9c49a3b15730022bf09ba38ae629a4adc5b162f971d1315d8d56fa463be854f826ed264e46b9966cb0901642f5cf3f7f4ab6d5fa0d6287ded4ae745134a7ae6e1ce6ddfbd57170f182a21bae72c96b1dc067a3fc08fba88bfea7c2179c768f3cd7f8192eb3bfd5257e2d5aec89e853ee6d0df576c94675f4a72f40fede61a2878191a23056536454ad3d5ad9a18cc27177a343084a03cdda6fd2d99fe378d6b52a77bcc0e386a8dae55f07a4de4888e8a8c604ff6c957a8080a9f38abfca35a00ceb8799143ca9e1c93b638c5793e5812fbed6acf22eb3ce8b240fb84199c9e5b61bc78b9502d61368fed252c5ade68c4a9575b21d4b1585e8fcba833d2ca560f46c73a9f1c0741e1adabcee375912579e8a9077ef680d30c8bc0a88387bdce2d0b2214bd097850c2d66b05a1d7a7d17c2b3f846b69a21be247587ab9aceac72164c83ac159f5662c921c2c65fd513ec3ae86897ebec04a6231b3da83d16aebae3bf8888754f094586f5c3346873a7c4ca2195d5ce7a385e2878c24f8000bf75413b8b76ce08e9f40485b835187dec8835022b8a64b76099cdbe752d951e3591b978315e8802f50da62ca65577fb3f11a641bc6c56722c2fb7f64273305720757924ad66d3548e571c0dddc221ffaae02c53bc751603648c5fd354bffb76c6af9f079d8ae5bca6aa8d1dec5bd065a8fe99ded8f3047e9cacf1800d1f1774a54b4d0a306f4cdb50f16def107558954af82d154397de9d6f676698413fdc0694af9e73bc3644636b726c471d9690c03ea8acbf578646447cc67096edd6e1b979f628f22dfecc32fa9df01febcc67c27df77863527ca5292f410bad54552932577282204858858ccc0dbfc346407bfc079ec42fc3f0b63719b2a07d6f9f5d1d7c314f312b52cfcfc9c6ff61349b62963544e13c8b189de3b5fdcdff11d0db84efcc57ce21fbf125a86a5ad19fc0ca9a2a8ae03d98875dc562eb48e1a3d82cdd4f1ff0010e798d62e244e3577a2f8dfffb5d2ae762815b1a88f2107ca4d1cd3ea7f808c48570fb79aad25f84fd51a9be8606f80403c0fa08487f565d29f50ff92efd34972008a6c2b2ee8844cb90655dd60d122144471da7796de3bea96d5fc642275c474e41efedfa2fda557aa41d5c5ee90f196624ccaf4bf06b8f2b3dbaa775b926949428ef1a328347cc3a8d01c5c88cc0c0e0da8e33eb160e8c69c2017295d53fca71eb3736ba99b9df38e96c590791748398d3ba2690cc936fe526d9d1a8ad91076b14a674872c0c183f890b1f601bf8be390bbade0878c90ac5e31a576801855491db2115b2652b5f49ccff3d250d61f238c328de850f51255d884522946d5abae34faf67b7faef46554d9d19c6898d0e5f91177935fa739dfca6a493181bab9277ba973d5a77f738c4c800035734126f358a6f9452ad165df4ccc728b41295e96b0334ec38f4f096c7ba9ca92661e6720a44f077af39f8d97d2a6ff1d1025ae2c61479709e99b7666170ca464c40004851a387429b1acab642d36b48279adbf0b676e36c3d29682dce42758dd6d55381818b4fd9902dceef4d1de984e28153748d8ace8feb269b71bc1d0156d1e57ad1f4e037546b97a9d0551ce6b66cfe9163fae3315e0762b5428ef370f55338d1cfea9c828acb87868db35b1d75469d6ccec4ea99d3c9a27e512fb1fc6c304285d7ad2b2452004f2118034ad9a4da96cddfe4b4a544aaaefa10ff979a9c404ad5a0c7c3a4d950b3a293114ee267b253caa28ba45c817bdd013a63db3333aa36500a9f6bee753a742cb5aafc195ec3d7f9ce9e936b707a0df13e7a6819bee297772d606986c851ac9c91dc55c7e277dbdcbd676b82db5b0e17b74f8b96f7c95c51f6e72f5625ba18c3e5429f484e59c78a913ffb9f18ebabf62992e3368fc702f7267f7d3a9ccd22fed443af402ba57081552e40a7af43f6e4f75b531df42e8a5767b4c8df80d1dc7e037bcfb375585232b8ab374a13479e1a496e38dc8554a4aa312a74c744d73de9eeebe78a407c819857f5e1306e2fc8b6ade66023475810d2331777fb50bb0bccf5f54aa6b0d4d69a1ac32136ea4afcbd03c3307cffb2a637d60994a3af291640a77b6c1f4117d0216653042c35f9c050eac172d3b2c77c1a207c7a5f007032be000c5dc8bbaffbfb8eb7e939d740f92956792af93b5efb9c66b0228454dc0e6da8971c58542f1d363d2696aa787a7c6cbfaa8f9dab477c2b8b80c8d9e4c1c8724cdd5acaea7f4997dc339dc197df28b9d8709c9645b2d632392ce205ff2c64a7fd53017aa60e31b2a4e0d4ed324c665d380f731fafa1b61e9a606a93cd4f9ac8e45f5a473bd8d58c0c76af0307d44a47182f5a600b6f7ef22528b6502a1c7eb95e0f08cf18143ac5f5b21b3171f86fbb150df7c33f3d393f70f7ee8420f61288298acf6e4bcd53887eab0c66656db0fb934671e5cad1895ebb756176e77a7c8f6f18967bebc0211ca73d54155d338f4d2c90d0831f73178edeb4956e02c36a1cf2e506bd5d328d19b1ae715980a9873cf75b374eeb4e6f8685a1d8656858753bac585788e6c298c6ac8d2cd3035b9617bf06cfc5365df88c6b8c3d0a901808630354fa54699c3ce2d6c40b4fd5e929a7707a536b75412ba6736b50dfd0e4e8b01449212ba2ba10fb0a8734cccb351f1ad6632d5e0106834eccade9a976d53b294698e8afd9cafb230cc0234b0eed3b764299e95284df0c8b71b4fddcbc9cee4552787523ee54dc42ea289a94a0612470f153944ae8e754c9c7c3e047ab911f52908c0b2673bda88f354cd653fea9ae740f33b4adb67ca07bb3fe8d437a4e968adf14ccc6dda34de4cd272cbea84b6940ccb1dc3f378a1b893812b4f69d11af15141476e2c25f0b01642a33355759030f88607cf075b2e720445db256b4a11e9ec5e7b468db62729a484e9a4e995d2037fca18a585db1101cea9b6217ae764767652b872ad04138d4429aa5e1e5738428ee0ad66edc08d23dcf93f929516d7fcb390a4815375c8555e4247011c35ea3198ab6e62c98dd815711ef304fd8f4e0f6746b20ebde8fdab0b49ded97ad85990ca95bedce0fa4de23ed8eb0a9af0fec28d611265d9d1cc83c53e35b5fcc478ce06cdc4cb66f68bb107de703590ca8891f876be2a0b031a7b1a09f79ed968f1810ac1305d8e370a49ed9a6015236648eeec9b255efca1a14338817cebb26931b72a9003a889ad032bb14ffe166ccb21953e855a754f44df2552c21f9664d14eb9d60d064c37a07a09cf6a41d07925cec5f08a879820881e4313390863d33bb047faf86f70bff4af033239ad5df14b5ca64c6c50459159e426fbaf30cd838041aec57836049bac4917b1812506202f5785acea6094069cd4757249ee2a6f2648ea5b31cb3aa0f5c7c63cf31a3f39e3d53e2049ca0c571b7b00ece4d02beb8398261c2d9134154341e2abb31f3dc9495e54b326b0447203e9da2becd01d3f3071173f9853b5759db707d2406edb8dc35de3dab622fa964f54a77c3244b3b29d0a1cae3abc86152c04ec8794a3328a693426bef720cb58801bab90d787fb1e9c88817648e7cfa8f37a5e8b1ccaecdea2b6575a96dd2babff59e1996a525c2fec7964b7b3eaf62490d7c8a116e1a240afe432c47d549f41bebff97e5fd6404b20b6fccbe2c0dfabffa70d658ac2106c3a46bb804c87946effb248137581727e1f1a9416095a5f1698aecbdde9ed31fb7f9e7f0a622ec3e422b9cc36549971f1ca77f593277e9838d9b3c4dac2331cdd36d308f73c53e5a29bb3102563f7fb16184c2323a9c9c984563408c1b48803a28dbf59372f8fe21bee2ba406cec9b6605cf9fa473f4368be4851c402c0c5d6dd49dfc71249ae12add23d41d396afc36135326374e5a69e60edab02ea5f0d702f55a6555e8c22dd2019b449a5b1a9072ff75876dacfe296a845d1d5d8e832bf26d5461282ddcd4b78d687888db6c7d21e0fd9fedcd3004dfeb3e391409bcf6a646dd95ac5da8a60418616fc5bf5d0f8f4f989beaf9b231f55138d1b01796855f27f5c27286681be050482a0db751eb3d494aaddc6e60d4e80c90ade7bcce0a51e5aaac03585e219c70bb845b3cafb381a7192a0b4eafa05436b899b6be8396c50cd99fc68fb943a878eddcb017531e68ea50b8cf403003e324367f7fcb81276d39bd279e4ef6ec145e81f2a14129b2cddcf57c174d5a532ce9e8aaa5b599390b946613e697956cc05620fd9861a787041c4184d44d44730e8591636038db5081d390cf5c4db5fea53d13320637589ccce3a89d0ba3eeb812f6fc67c0b5edc76b0b68e35a8229a56f28db343dab688ab0fc8f900359f4fdf6810d6902bd48c91716e3e8289894e43d41feef4df044ceacdba25aa8d0c74b16730db009c627aea96e53bdd447dd5e4cbb64fd47d90f3f82434a416693a95edbe41a37f77b2d14ae883b516cca42682f469fd8a218051ac7a72a979a5dacdf54a8d72b4bd753d3f0902cd28046a65ee653f6de4b6cba913f9a92bd03516786ca9ef24268b9e65679700ef42606551942525cd2748dc87ba38bea4bd88b758dd2aabcfc6992942c005c58bd5ee72640c47fa40219b04022c42fc79061540a72153af9b6ed028dbe6d7a21f0c13dcd76364e67ae13b5543bca479fbc550c1fbf1600beed15dbd2d59a5d426c140cd69993fa5e0f520aa14681be5fbf53a929ed8f06e0d09bf26a1c748f2a18bebf0b296110ee527735b9d0d2189bfffdaa4ad417198fa77fc81b1ba877d2a5d583712862d2161ee3d1771d4695711d704d3714b4fcf188969aefd1f930ef0398af6ceb02c85592952c14f39bd86de8914ec3e024056b35e44ae583e82cd63aadaf54dd44edda15fce2d6d3d27dba692f37ccb8c8971499fe216691657736bfc7a874e415cd780be7eb40a1c63fdbc55ed646ff8495fa3bea985a7838ad70f5bf60e7b96c88860ccd654494ec5ac08dd479eac583b8ca68c76bbd95aca6dcabd25ecaf8f39fb76d135e3927895c78a6b6ef957baee1a2144223502b588622fe34d14504756975a6a49a33cd0c8821171b7109519d4cf102e7131919e0acacf69a618b87ee1ee36f391847c373478962ea2086d1f78e8b6404ecc00b64bf3ff896d06f7063e73ec9b7bef7c977646c254c66d4a89f6cc9727db95c4f93c818c53ad809cc4cc2ed1df55bdbb5ac997da62e957993849a6e913becf16b163d35d29bf3833c569f1a3355a2942bc26b3e8a62d1926f57d8b0aba62dbf0391b2dad68a5d251f7a76b1bf53d36ca619d7bc9f30cb1c7e9a5513e67e2817c51538898e49a8fe381592a50b1c1c7fe81cc2d9138712d2f1298ffca1bb2c80a48160296ce08fb529a4f64c430cc4a448756df2b7fe51c014f7b00d3ac954bdede515cc493f26777e2fddf0814d1fda0aae3625f7e3fa3deda3ae23788cf7650af17f53f06ac34dee588d1c9ecc002c61075e5a9e331c3ed2c53368c05646c1a44106453e6093439aea60a4865db8a2eaf2663db30a04fe99fd33fd3f000aa450f143c8e3e787fcebfe42586e8462c471083a3887e9084b1d2fbe4d7584322f0566ab9762a172afb3a717d47e5a884f72f480eacc63ed3308385d8e3eddc5ab7bec097b033e0226974621b14b0fe8a02dee9f1b6d06b6b15c8ccbc4acfe4a25bbff46d74e4af6fc17c3832386022ede0163ef1e2d68fae3e21cfae07c09510fa84e85f095ad338a6ac01cadf1b32512e9af43dc74c15b777fd1d3cc806efd74d6909c7d35ebc390473d95224f71aec9889a7d67fe8698bb3ea94d82a9fe79983e962b76550b1e83f0127441e1889bbe668032ef456a628dcebbbdff1fa9b63570107195f5f1b1e7698416c6b6af331248c8645bd4bf553c0baa07a62fba538a881fe293abf57780105a43a3d4007d02a9aa2aca24e882be88563d646bc982213fdcd8813a50bfb04b8d883607a66a42ebe2d19ba97cc9ba94f0651844c11e23905d8530682a7064aad94d621221af03621554dcdaab293690988bc1c37b0c40bc7cd58811e3e8627f80b8bc0b2706fa6770461c23456195362ffe106dd5c727b7480eff93b2507751ae6f2f0055181fc3af1f3c9bc130b35e9d54a2c81ad749cbc9144ed130d900f17cdb21f974d2917a141d3eeaf66045b6e5f19468a17e614caf0c173f3371b98aa5b602c097f3d196b832dba0aba444ceb231bcb8b63dc9f2ecc99869b8e7ba482823efe64735e781edb148b8e9b568d06855393ddc04bff411b224358b6c03fab94c484c0b638cbaea5773b8b21bb6c19c1e4443d246637a29c45d4e03b3c3da33e58ac385d5f7c17cd23655ca4a11a6846f31f9ba5105c7ba64c88824d6a4f1fdaeabd73352571f1d6c489274b53d18833796e5d7d24e3a621cb64f4e80429105548ea5bc9d611e446c4580c49fba43c426850908418ffaf52d0fc8a5391a9ecd071948fe9246e93442b3438c1ff2a1d67031fdb1a20903199ff769d34bd36d18ae21039b835c78f817b0352ee2f7ed0cca5a759caa6d958dd93799442253561858bf2d93900534027e906fb41e89346920102fedb84ef8ec01c79d3bbd97985549a3a7be45e94bb0a9348d6ca2c7596d2ef08984317a8b5565a4907bbb9728721d0aae8f9a093a386c8b5c342fe52498eed504ae462c48abdd9ce6f04bc47ebf8ba4e6d62dcd7150625435c5efb58d4feb49bba95e08bec2b07d1d2f66c1799fdad28855c13d04f8b8c89bb8e9c80e478cfbdb65511ae43172c9894570132541704dc47b3f8ed6fde142c23d42bfabf517b9f482f7b95e4c214e8ad1894158c3c24209b6d9e8f361114739288658ba6495d40d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
