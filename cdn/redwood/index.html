<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d80d952829dd2e825a590baa89dc9239a79c03d69c25577a6c0af4bb3ed4fc6cb9020c0d2464abf877b21855e8389aa0f5e1b356a20c5f98c397e4ac34f664de7ef3034cf9fffcac792fa332d8143d7d2956889399e09b43c1f98a12b8b67128ea2f15d994923700e4d1da1c7b12715acabf31f6ca90e5ff96fb2ab29f13d5483efcbc3aaca30d628e45aa04fe05d78e7d49e6f4eae654d1a3beadc82e05c592c76d3710e100dc4871502f1928df52bea5b0c4c5213cd444eb088fc26a805224b9ef1d032c5f31e5419a8ceb51d6b65f0c4a18c04a81b74dabf4e2a6bc5ec6e9debfc92494b7bb439ae43d4f44e8e420b38780a522b9b9ab13be69fa65a493605b0737cb28d9c342ed0ba4598df7a040ea73e7f980d516c1f8b44a5398bc60bb5c3dfd942d75b4a2cb0a90e95ff4a5b9d9860e9c77e9a80eff633744628882bb6b9084c8fca8b53a5bac09af9d881ee59464ae86fc63467e5e53aa6f456f1a7c58472a4af325ae4607ed9df032e2a21f8bf5aaa34ff7db8c6351f5babfc88ec3a9e129f719828a676b65cee63e565883fcda27d0f36bacef8b81a77a7aedfda68fd176797ef290d573118d99e3dd1bc14518378ccc302cb077f1c1a1ab711364a8fc03e74fac55432b2afc7ca51f9bf6d7af12ec2bca9a08712525939e1e4b7a39750cbdb338900eb8061914e5092b111ae69ffb039bdbf500c12f5f85323631d0318063a673de69ba7cc34a5a5d3be57a3e0cedee63765978a3467a6ab40f2b526e3111acf52ee7a14aeb58b5533a5cf049794b2606141744b1efe55fd1beb414acc3a1a44c571f4c430f59388fecc8192aa151d0442d01eb70365ba64f7394654f08974d410317d469c53e1612a3b8612f19125be737b358819aed853b3afff3ff276acac816f8f84738963a96279c34845ebafb5b10be4d652cc2ce7ca7e3ceb6540e1dd624f2f33df964368a82d53a74cf764217145d803ba09531a295141bd601c9747ee4d41fd81dd6f06020cb4188d8a904bc7d8ba859af0d8f0fa2c40f738e77ccaf0a340099016eb1520309c286d196f476c9dcddd270aa62204e8f7e147592db4a74dfcea0081f0e3218d54fb3e23b33498bdb80d584cfaffd0cbeceb480be2889ebe3f66dba1c8a7148c4daad425837a6055b588fda74384e9b5d0d53ad3faa91506e5bfc0b6632d9fbd221ce948993fc9bb493a9886c97d423d908ad3be39b7b21fba464f958a03d62f6bdb285ff8d1af0844c66957ad114aa1c65cffa8c2cfcac7b18f4c72971eb5ddb5fd34ed59114d712e78428877ebb9dd0eaedcf553ca0e033fe67692e87936e4cbbc7e583c666955e272443311d183029d4e86c86fc42038d5243efa07e5adc3cfc9024ed8691f5a9070dead501611a680d84ee45a21582192bc2511bb2eb14ac2a636c644bb8e68ad32f845ef8cdfd956603a3425be74fdb675b18b902a056d3259d84d773fa33568b75bafe9db195232822d0ef577e3db00269ffcd4e8986b4943536bd054bdce6b9e5a21dafb7ba3659b080d33508615933de0bbe8ac5885eebf81cf3070e9908f86447d6d832b63ab028e2a988eb0ded2f920ef1fbbc9a1037fe639a00ed1710a4679016a1c2e432fa2ad8fae272ce2ca7b7be51f6855290b2edd7394887b93981b03897c998a3a39294649b1f8fd741f1f02d660e5fb552f20c39199810f3bc09ff4bf9cfdb30169967b02ad8f55c886a5031aa4147235e3dd115e30081e2a75d66ded44d446bcdc6d697cc8ad9a5bae81d646270cad6498f9c2401dbdb09031190682aeee1a815c3ce6d2960e85e3562ecc90ba02aa5dfbf6739c535b027e1d8d334b596f802e816ec66997b0ca7b6a88381cf96748f0bdc8dcac9ad6edc4e43b868a3f6c97b8b34fced7052feb6cd515ea34e84c9e6713e84acbd19f4faf55b7ab28cef696c32f02567f86eed135b845f87ec24fd08ae2c774d0781b9a9428433d8e1627a32a19143a386e378650586ab93e28291944f4be25015bee536f465dbae6079ccdf0186e188e12845f6ca81c7b9b59647c3a29c8eee7b45641de604e3d57b79de3b24aa977771fc0f853e642337586b6011820c3637877f5ac6138f26a97aad57e52e46a29faf1ca1c3c57cd950e8a9630c7a25f30a6eeb3e4f8c02716f112a2d6aee13e41314c59518c38bd35ddf8b1e1a253d0fde71fec54fa33a38ca82a84b13eaa4e3777779483bd298d1c6201840f4f0388dcad54acee2bba159b1850189ae59671b49d5ab1b26937665049525062ab8f57d1521ea1e9a6247e057c43108754f2bdeed90e8e77bbeaf409f2bc1ca88707bef302e1cc896c36ddfec63444f1182ab24f49b0470f733462a81a43c2212a8c2f5188c70c57b82dcdc660c3a33af76be80c343312deab325367d5491f9ed64304492d50b9d94340ea4d9283c6cc95a0947b30a4ddd1f74c4cea05e7a35fde7544ad7f0483c513d130a75ab1f83a5511dfe2ed2b32f4dd7416522b57a83c133e61195b563d851a3ce4e6f839454d4ae5fab7e5a6e31af0416ac51be8e20b0331c37f997741e2444db0c13775ee9a726709375b108e5b47bf9a304522ad3e87544052fad5a2c9a8dd11c317e4e04a1d1b38e6a52b2710ea2d60840c3d6aacdc60732edd3934eeb7df75177b844aa1adb1f760b7923c1bac9a3c965e5806ea9025845d6a2aa20b5498dce855f0ffd388dece7ad16d633f8c5a6826bb988d733ae4e9497b654d644c76219562ce43702f5c657c7bbf2b0a715d3abde0e7a282a191531616019fa0e75a9039f9b0addfbdfb7bcbad177a67fc0743624d36f8d983d7e4bf2d2649594830092700930afbd419359f95399de507e674d050744f1dd284bb2d53e6760db17ff9698dbeac8aa8741a195606d4da9637edb869dc1c72763eb53fe2ef04bca075260e00894fac67930cf86eeea7db857591af127767b50986fe44a453a9d37df84133170ef98e002a2c5b6b517549e0a57957678541d5295858b8abfeb91a5b165b4e75b7948c6ba201cb1edb093a5207b3e79d77ad6fba392cd4f6209529983ed512fe3f7d4dcaa508b00efe3bb8e41509dd27a0cffc2ad68ad8c373a50bb970bf450bd3997359a00883694092dd468c5137e864e6ab110b0c018525955bcbd70944d048b81328ae69bdf4939afe45a19574dee081d2a8131f10170a92331f6e5bd5283a4e82f7a79c6bbc09972606c30283dfbd7c7effb61286c610bee137ad7b2ffa66e1ce891a93cdb0ac7ebd47e9927c5698ff60c62cef4a94472c78a8c01e1d9e59701b638dc256d359bf407e163fc0076debfb1ee89dbf0dc84667baf115c8919fcb1a021c8344918cdfeb838c8225e8aeba4018157225768fb8f26652b8c5a5b003980fb615296d670dcdf1bee0fe15af2f82d4cd13aec18185cfc741cf6c543a4760f36d3557e4a2b5eb49f4c1633aeccf7851659e4f80d3fcc0bc27fceadfd08404274152544424d8635c0a95192a43fc49d849e84d4bafe5fea8d9b2abd47b04e61fbf1cfb637e3df37522f25875919a8df7731e92455a4f677a6c39e83589d2e9b9e6ef4706c775855c9869da0a853d9bebc39bca25e986c37d44161052a481ef94bd1551455e663d8a47fedf7ad54eff57a16d5e7f98c5b29a8282cbb4758fe8241d09bd871d72841abb7b2ced2e71b3819372bbad4685afef5faa11746956de688e36cbd033924b01af9a85e88c915c2ad95fe2849b2815fd15e70406e898b011ba6d41b7a58a1d096e9f343947cd4c682d49edb4fcab19de32393c830a43917900464df8223ed1cfd6b8bbdef2cab41787ec7bdd2a569e2f97ddc76a63610027234a0c85d6a4a35095e0ea917aa28dcd79c1f3b69af6b36768de29a873ac17fdbac4e52f84eec31e258f3b5d8c6c04fc9d41e48f7d627bb046de5f6f26fa10fc819e2a3dc0e4193bdbe2fcad2ca909023058af3f4e696b84dd4157c0487ec8a298b5ba0105635f7b21d8c69b656fd467a753bf839c8ed1ee926748443b1c19b19eae97d3d27a15b93d115dc1eedb3c6cc735e7a84dd65c1c35a6ca41460bb91eeec1533d91e8612da5707204832c5497aa233bf720c34ed7b58ad189bcb23d9d87eef489a568b6a75ac5ba3eb0a07b80cd7ac1862aa4257443622e691db02367e146ec689e65040da9935e2fd6794bf50da5d6a15bf7190bef3128f81babf33192d1c53e452ac5646ef83304b1bd193a8b9fc6caffeee4762925c0e85abdfb5d688f1fe93411bfc591352c31c8fe84bfe9c39427f62178741804b77ecd97e61179bfb6b90f31d01f0fe46a0ae208c8fd9bbcf59ec7a07981422e8caa3831435e5d4109c583802870802459deff0526b2a776c20e20dabebe7fb30e6a8051b441457e3b8321047a642a9e60a54df5904a2068ad51e7aeb928ccc389c5a37bf5ddaf8605a55cef6767276ca00f6843a61f22b499995c3a355211d99679618b77bfadbba94e110d82cd8d5d034726deb7150c0160103859f24be6b734b8219468df01839a5192c603a93d33ea240febd1da70cebab92769e4cdfa607147dea1bcfafe7b3dc0af38f65df223167a4a0c30a8438c50c6a78a52a22143ab2c4478135caefb53dccacd5eb6de3b476d5c1445ecc9a80fd11ae57d6dec36554aff226b7ebd26b2ceb5efa9ec61ef393bcc0cd7032972ef03b065c8abd5ff75a8f9f38929bb790d016f06a335148993a3f7388e4ecd9be95e3725f02136f61e05801c2789b415eedf9b5296e8e1f4685a9b68d154957dd77370b8c7821e3d14dff42fd856858fa0f5978891e43ce3cc0f3ad156ac7bdad288b20763f2cb555184f19982203133d7df8a5b2f004867916b0b5054d04cad234ab6f2e8f2a94007a2fb3cd06188aba6596e91e7084c30697073d542ac9844ee9eb8a001ff8e13c30514a2ad1efe1e45e841149613ed1700554edd37e15b2e2917d56e06ba8a9558fa691ca0d657445685520ad2c8c68537d6224118a584f6b2f4a1a9a04bdf723ea7c93071cae56d746f19476a06e3d2bdcd2c404b3d5e880c08a6147f4d33d533940d5a32aaec329d56c97c062c4ffe0be46cee8f36db9ed04cce83a2e8446a444a41d56d529b6d05cc6c3a27999e615e11156aa32dcd92ffc24452328c37f6c371afc457cb1e2f962d549992938979ecc8a13c6f16e53dfee4af291f2e232cee9dfadf95333fad74486230fa99ddc45e73949f58de0c0e68fb869e51eb97a2c14e14c6be366a51da4ea1a3d8f95f99e8edf13cdceaa2d1b828fc9a9623addc36d68706b07c87dc9b7cccd5face769c69e90078a2cdeb77df397fa676aa48ab9a39ce609b023718d89e07546c740154baa6742782a7872e6d1cdfe0f8442aa04553ced8417c4ee487cead526e54ce036c32022ada3301adb6b6bacf1c6c0abdfbcbd0fa8253e02039b2a80f93fa88a0c935bd9675ca684e3ec13e12d9f77613e99d3290963cc2e0cf4f70b88a31bcaa34750a01c1d9259bfb2628dc6bbcb0c913f55ae17b6bb0d1552ae55ec7c8ae0623b7d217d50d67a68a5db63a77def9cc21d96b322aed50098e0d0f6764f3a70e54a8ba36be72c9efd709531e8cafa3266f4a122ea1de6c60a1152c22625b655887d9694a14441b1ad29bbd3029b027728bbd4ee59e4877864534cf745b866b855afbb16c46856219eedd159fda0ccc074ffd64b9950d5260b8da0c4b1c961022b4a27c1440860d9150cd9c968bced247e587088c8c71c96f136085d03dfaa7cdab30bd08dcd7bc383dc1a57840fb39c6809fda74fe5d436793f2e69866ca5fbb6ebc342303c76c8628b02d509448ed23142d732c1849725ab2f76b99fd89954b4d498a015202cc22eca2b3c9b12e3c1af795c598934dd167d262b6cef4a7abaa5f7033578c55af6d107e089f3eebeece7df39e2c6e64cd3b8fde111448c31cbbd75fe4184af060a20274a73426f78ab71f1b7553b24b19673f1dd069262c70d4dc5bd5d2968fc3c7d942e8cb44f8599288d07385375a74f2e421db999b1bfdd1890a72218be542da7a084fefa1cd3e8be7bd9261240df121c19650da96c1386042823c004b3aefb616ec6701652d21a3b0985f949703a6df8c0841b7a2f4b55427cbe4eb5fb4e12a5f151652fc68533ea94c74d083251fd4d677f82a509a594c14e613efb9a5a484f6f095cba80f5fd971ed428aa0d71e826d4fd977bd61b0c2ea2aa1da172ae2dd699336bf7d48dcba447dc8fd7348c8181e3c7039e143dc6c91523797b65e4285e3886bbcedb3a98d5644637794ad45a29618ab269d47616c796052f980979a477ba3f2e79d6150ee1db0cf6fba1512d7673f75328596dd73358638fa9a7bc5d2a134eb328666fcf46bc180a907ca762fa9f318dd5dc03517fdb8d9891da0d3a780d51dc463c6940e193d9e9545332a42537f62c57302d8c0de302d9e6ad0b82299c6c87d0790c750a3b4653e65e63f240019c1801270de668ac8c7cc613c14170a7f5e78d94495aa2159c6548a05ff537db8a6988743d4d3e8f6b27ee9b6c8f6109fb2fb8a270559f02adc079f9d2be5d2221bd74efa386aebe95d35dd3d6fc7fbe19aacab06a229c234acd528ced6e901eb1e79b20f19c26dd183362294c92fd322f19caa7d36e1155fb417b8c94a6118600d7dd663fb18fd38a6d9776cdf8d06ce662d46dd14da0102fcfdaea8c0d53e2eef70ec63d01e0054c1b339cf8bac4ce3dd8b89ab4b733d58a63e7af0167b5f8dd3658076b2578bfde8a2675ba02c32fb479186ee64d6c01f0309a6f5028ea0486cc18f5fe319c8ded4477923f49a90da0a4f2e497bfb016c493dc7754d6b61a3b396579a76b2805535e5178f8f5a12357961e4f6c21ff89ee542c8c065a93c26b12c8728f8264465a326d89759afc6b3c92ff2b91ce15cddd5e4addd0f8d418d01c7a06dcb87ac9d6a1ecbf20aa8b39b68e6f1c297a1061845b614244c61c7bec0a861beac126a91acef4016900e4138c275049b430c2f2f4ea906016095adc92b48f08ff0794213bb0a07f51143c817b8729deb34656c010ff393da98a7ca9886cf99df5886f67300efcd274e00468aaaed1f0501184229706a923b9e6a3044fb6f6d5e78b3037fa18ffc98d9147457fb6527eba7b4586de8d9f4ad31ebba5f751beb8fc565ccaccca5d0b0c9ede86eca4794d70e2c6037a214fce0eaa0a68418bcbbe7ebba1000052dc96690091df733292a9c443041be99d4ee2606bf0c306cfaca086d420a82b4dea92cb42750c3f0d3b759385e5176f10b75dd6dcc9b1ffab68e6f7c54d63f00a5212f23e8c6002d2cff8b78e8220190a933387c878b432776826a7b3b284c04a128b20ca247b702126e6d05dd7d6a087278f8ff6c8ce1803e3bb182895971dfb2a9b03159b2f18eef535b14657c5b4eaf2a00898dfaf1ece15eb4e989b7200b7052f0e27bd12df11535948896f918c160d92ee62b1fbeec494a110fedf1c93ce7dce09fcf3c5554240a1283bf13fe0a3691180571e17603801b8b149e8acdfd5074108dad633433466de25d00204dbe36ae7cdd6d7b4040233102e14db3a6924fd45f4038147984fae927d9e48b00aa4235be255a2de3fe51da5e2703603bf76b8a233a4926d6e89ec7ab3fab50e4c4ed82cd4dc974b9c89de57d669e6700ce9c338489c2dc8e9352ea317951e1be95a1df1f2c266e8241a0e2117c63a58a8d9bb437393afafc2a417beb7243fc1cc9063bd9090ab3b70439473bb480ae7ee5407b8ddcb32606b717b2643e46b1ff8d4a14310fa1d462d522b4e8f8c1863d1dfe9dc1f3394df019cd1c29e35d8fa53f481a15ce450d53d2ba86aac05f3d147b59f3044e6b79cb7ee46cea3c5dbd88a72736cdea9087a932c92f68b0c0ec15133f7af546c441d9a15ab49c0298b09b0d9eab70b2659214d482559270d2ca862c47b04cebaeb96659b4e88f73053024630ee62e11c4a4de669a05439088993d600f7ee01ed0158d0a17b28e48e74c0c08bcaa7eaff128b8ddd472da843a7113564ff8daed25349962490b927d26f533c1e8e55b969dace1d14d5e0345f269aaac2ece5acdb6a362174b1463988b2f0c5967f3f2283e9bd430d443ec5f534de974a206ed6a8c9d9978e1eaa6845867252acf345eb6b23b640e6283c2176511e210be367fc23704117f7a94b2c1ccc5f5d25b7b831914c325be75dce9ecd55391fc2a6cbec2267239a2789aedac7d9bbda1513d56ddcf1f5e9745b4a6beb7c91c9d526ae22d2ba0a669bf65098e041307f068f9c8a4629d9d2546ed5a9b2da054ef74ecaf4b2fbf965e19feae8846cc4368c6fc5c3816e555630bc39da73dc4947b954635a58191b7fd361c9e51e8223e44751f47bafb2ea45bb16b7b2dba96c4e3afd3f26c9aa161d99bb687496e384e777e459e4b7bf0dc2d35802471ceb2a7d3f2aedbee783a83edcd638f214556206bc222e62e64bef4ba2f77ebf1cacd4b9f03416939b529b6460468255a96c2b17e61dd9339793f2436e6ed19342c6afd60238b602176b627a8532eea3d33c91e45c8292e9fad1461099c83c33bf396b82eb9db619dfba513ae36bda10d83c2f70d094a48b941654a4f7064838b7589cbbee71e7873dc6a56c16695ac4810842afa291b0bd6d452a14f5eced21c3e6d28bdc527af437750709001abd5719c92c3177de2dac4cc2cfea0712693dcec09a5fbc5962aa4d827252835eef04a2a610f2771bdd5e7fdb2622b3051dd8290117b5d642f07fab852c2b7cf31ca5a4d3d9bbbfa0eb401aaab0d52bc24c21ae6f9e78b6f98972c6f875ebf906abfeb9b7c19d9557e09b408013466bd121f9f404d7741f7fec6db4521eb3c0053268f22122f5aecc5d1117f4d68d105c6f10e7f49bb312254f2f9cb1e0647bd6fc2b79d8fc2695a2175d88434f932358abe60c873bcd99d7dd0f8375b617caf64acd2bad73d3fea24f0c6e1b8f39ca1810f15c288963bacd449f4675fa08647d94485c51bf7a749f38661ba9c582723157e4e714420dab5c6f60fb17d9d89caac6ce6e4d80eb013aa5ce85951d88cff16cf7de0379047f2ca284dad76d1796f88dabdde846702af9e5b8cd9635d8f108c417aad2e39e58a2f8b04b506becd7cff19307de1e4913d48c873a5b2b4950c2e1cfc6f92c496d23ce93ee61e2da9013a13259e6f8554b198c89e1bd693511de046eb12eabf9f07e54e456782371ddf0da3f955ac871732e98c64e0b3f565ca1b202c250c533a2cfdef2ebe7d15b715e79fdd8ec3bc223ad28999ca556b396d10a39b74cc462c5ed508510d7c44c08ae2d12c7f55da9d662ea607bd04dc2e802a1b8ae222e50e54fa6d1c01174fd756e7a64d0af7409d74f1a157f12d1271ead9a38d18ba951bd43a02a28011854768e4b9540759a3e4150bfadf0035cb99cd581762a0eb47d57682be91613f30ea047e2d1fbfe60ec52f58795f679294036b528b9ef322c598bbdb3fb24a4c53daa33b7a69af73730f507a5cace1a5f1c841d589e817ac8cee301ce7258ca42da3e4095d5014cb99856fc97127db670b5993468d1b6355920324ed750e63fcf8b710064d17153cae7b3aa382aaf7650fc52a190eda07473b0ed540da13c8f664856e0a8679cd3ed6a995764d6f724c01da5b25d67811d183ac6ffeadbf155b1b20002432a8bc4c2bdcd520d3c0e44e17cfdf9a64923871a00f1836c6b6d4d5a783710d4591ce5e937b8b82f4c3540a99e6b2f76b62a0ac30d9f3b0a9daa4c1e80cc6745c9c6ccb0b69a7ad10ea00540e44eb619d7d3d981fb7a329aa00ba923bf093ffbe30280b6d025291287426c52e5519e947b0f536943199bd0c833f746983bf249b4332821ac59853e2d3f895a91be22c68f8f3e484a42d082ac783154b8351da0cc1e4ac2f74a16a5baa6ceb1c34572bde9ccc5dc5eaf8426cd3b73a97750bc55748794e084defdd0754df1e14ebd9eb77ee090f911a7ccaab50993f62b2eebe3b3a8ea7e66d8ae90e013a5295fb81443a2b10e24b4d1cc42f9bb17f58fcec2b918af5e5dbf2399a99eab24b9dbc12bf857763897dc25ab64a3f6042191e8a3264f200f8c6061f3b19fe6969d3ae66803b95442960d370ca4f83f4a64517786088d0785414599e7a69d503211bba746a787cd895811c8a90280ba62c2c2fd133f3eda5e0daf1f0d19ea0aed10dde53993ef770fd0af9f2f8b60645dc1cd35a61f808f5202d4ce0d4cdf63d351d30838d5621cfd028ec94eba6bff106b0c7b33b44d89d1d19b1839c43b3d59483f4be0f59bb830ab5108c406bb58c9ba8d93158fadbb8c14aa18e557704f8b144be5cd3d642c197c760a6b4adf5e192ea4bab7178435d26cbe974ff24aeabd6ca0fc20ad63f8edf6198c933315940b199b9baf9d819d184e11a4212c29b0299e06aef2b79d3d797d1dfa8724effdb7209f3566dd4372d0c00b6fb25673341a54e84184adf08bf4744fd8fca840a16e8ea62c818812b6d000e40181d181e76a4c97cfca544528795b3b27df67cb3a878f7bbf3cc83db2c77306737be555de7a51b6e62e907c20000315c8bb09dbaeb6ddcff56a1b7a799a6a0d1e9bf1a3a312a22840b4f4ffe5a09e6f64c37d80b31c04144625d10f00275f1adaeee47bd1ac0d794c38772318b74149eaa04ee71af651f87aec111247c46206d22b7eb804558b54270a6c403deb9b66e121ec4463002eb1bcfbc125e924ed482506ddc3d3d04540a598957579ee017a32d772f95223768104762ec490b8b0bc3b074a26a0ea4780e2af5b863bf372227757425d40240a2f54019ee85cbb2abb8823e6348f978c8f2a269e744a4764e8a81dbbcd4710fb0970c2a45e200ed927eb4e8ee4d6a344dc92024dc97f1600462eb9f37aecb6d4702b9931b0735433e983c9002a80a56a4de97fcacf920bcae6c672efd8fe26fe1c8309308f55de4df1d9a554208b44d3a4d24dc2803db4bad0a50b6aa5176fd3b9a075b1a5e55203f7074350f4cce20d917e843155c928e52ae65c2a1a2c7c3fdee80fb89d0762098ebf24d55face5996134ab371c381f9603be2d38d870dc12c08b8d6851b74ca35ef1006000544cec0e846d4681819e6524410c5626bf32fd2a78a19d8dbfd12828a8c5c894712eedbff5585ed5eab8ad2bd424a8fe9abcd7f297e0d900b5a45eec9355f52b7e3be889289e81f06ce2f97c837f1f5a43916bac35677a80821cbd52587fd9ffa71f5d7ff5c3177589fa63837a0ed3969b739c80cf73b90b417e9a56373e5cb7c934ea57e18b145dd086fdb03647d397c1f9d6e6aedcc4bc02b467e4671f75cb126f6fc0ba44168841ed35d9d1bad180da81240e6499c4ff14a49807c5118554d575d9d5c8ff640aad8df426bf974290df3bfa7daa9caeaad1f8c164a6120858ded60a5bc8137939dee28e09dfe878533abd5d5edb074ce57fe35116d9516e2a9167a8695469d09f3d3c27b557b41b1b9c7bc5a7e63fe9435bf1933ce304d12383bb5fd885e9cb5eb9d5eded407e562b2f1883f26f6c79649eb5bc92708f291ce73ef64be10fd0341633b8c69e820474c6044838cc3f05aadb75902ee9dc00d5b23a30dcf13b13c430f6630e7dbd23df5adbc47ac615f8e0c3441372e3a9851aebbd3d9f3712852ec7a234b35a232ea739c6042514889c167f9ce98150041b5a5941599f9f0dc2417cb686a63349a1e29a97bea014a21f05e0cb1d2064d14e6e36ba05382210636e35aa5f967c0e330fac13875c72e5ae0a08056e3d2da71c954b3d187f265381cb79cc1ae1198c05ce3719417a6f826b416f0c8aba00e89d19d7ad9c88ad7d7920a7013fd0b32c8459b2df5a926ef1593510c9956e15ffe9947fc7eff1b483ee216a6911584c98934b8ae1f75a72af7703c1b8a2578cea713985845d6c8ad03e83d67bec35a4c779aa67c71199d5114f82cab84b9c1acec5ca2576be55769838192da06417665ec30c4a2108bdd336db8021f834e10ff44ad17065db3cf8d504dd7fe8f4e539cb9134fdbdfb104d9fac58646f917b8bb8cad3f47683931e1dbe80113be2107fbd9f2a103986d00f663deaf50e97e976f5d95f2d4fbf1d3c2e2d7d9635a31b785ac226c761d6302381e7a11ef477f451ce4d3410e4a1638332b0225c8ed275269e075340fe70522274bb3788fa373059bfa368c862b641dc21343c1fc0aaa0889af37781321df04332a02a1c774617ed6229bbf4fbf4285cc0f86bc527bd56e067e1476daef41c89cfc32cc31d40ce06ac4c9e801c385ddb063e441b87660ab0e55cffebf330a4de9d9a9ebb32dfce5fb2c4ae06c91a6a1136c1eafcc8bb238aa512939f687ffed48c75dc1e41edfcd08165eff1e058286daf6ba3910efa4900f3f04b326d06eb02b868c846f8d1d4c780a77ef85e233121f85e4b82a53ba4bf0130fb75b2116ebed55de1281150c44baca3d9b092a8672d84e27aca9a19669fab721fd3cc90122a9142f5dff7a9dc9dadd7d3ac5f92e7d38201a5fe702a69901753c4ec2d20c1a115e8aaec08b6261ee4e3ffab60a58e4690055133b6ce0183c7ad63aa4b8625b75304ed392d53f045eca05b3722519d23a2292aee688ff4a43b6ce3291169609974ca26a4f6485f067dd636f5d88dcda346300df86236e5e223efd236801539e5d13bab37399eb0b604bf99cabf6216141c41b8a0b56366f1fa105c9be56878262bedce6b82f2ea747be427431df5720d936a5ee1337334c0d6ba9f5bd0b8d5d4963b902b11a03ba430a7395d2601a87e063af5a629745be8e0756d8566bcac276741ef89e5edce12848b40280770314a90ac55a1e12d3b6fe0f0386d5ec2260a9e4a7cf1612456a121c59c9aa4ea043b0e31eb168372fd63b1741646e93b06437a779de6da1df12c863032ed65d030f62b18b6e4b66976514bc387624f8a63a9ba2146b720c2c8f1e76d678c06cfc281c45d82cf471ccabd357678d87c386a7bd08184da50a51f4f1dc33a0f6cb09dfd81de10a953379a5cd12029e4c7bcc0780f7edf26619ac474aab696678ef8ed3cba77e07b2d8b1912bdfac81d74d73cc4889bfce3000ac9d2659bdd5e5e9b256286cffd83a153737916eda1fbdc318cde4d84f95bbfb046ee1c5e63daac4fc8edf941d0fb4bd48da9eaf5a961ac29b3756ed500c7f565d3ac61d6b32f51a5982443bede62b48aa23e533ca3000b4a4e7a146d99e6476e1d970b5ec12e2d82c180f5e612c5ce9f9975e1ffbca5111fd0abf27427b90c99588ee63b44e1e5efc6c4bbdab8a8da15c69249fb993a44c064077700426bf780f81a3954ad39f60ae8be241fede3ef6e60c3f940f3cd07cd79cf76b9d43d68fbeee3fae9eecdae46d864265b8cde52b26a04c358c63ec99fc581a7c62b6f243b0eb4370d91b8591e17c24821795f3efac8512e2a817a818d7116c3baa88b4b19e3eac895dfd46e10735fbc099eaa7b3eab9f7ea31ec5583fcf0532b118d359927016f5711d13e1bbcd20f21557e5eba0334eaecab38bd7e6c060863aaa857d05c3a8e3a5e9f164d846b4368f1c8a55527ebfcada7d4cd8e1085375d3a8e44401f478717edf9187c0231e13e8ec02b7aca9a7cc1772712cc5497ff0c1d279e5e257c61990397f83c624333d0a347d31eb017cbc8844a21c15ecd9bb1bfcdee7a3a8f3a9dff307a849a749d52f30e6915526bc87b04054d9ad52814879abea557db6e4e90de5de63eff73d87eda7e38f2a1395e81c05dcba215a1489ed59de4c1338aa939001b5eb9548d8b0a45aff85723ed71919e11fbfa716518b0a30e8a9d7a61286ae9b60e8501cceb71461f1d9ad2e769d7560f977ecbbac80e83f70c1f792c807988d7daf9ae03005df1274270a3a43e43abbf4be8ba9c90d1ab7189af125f927c96ccc049136212dcad6118b91b7784902156f3e265c7fcb64bc6cdc017810583b8b54b0c604535ecc9d9dcb9cf74df16d0d18d26a1987abe6c175067c3a73c7553b064d68cc09fe49c7a98ede96622dafb2ee98eea7b81518ed0c17bc6fec2c0ff378bafb56efe628304390de41a53f11b8ce0d2740086d3dd9e72c8c2ede1f2770ae712703cbfe3e883a4969398577d5f87ca5ab87cd803d92b85a9bf6873cac105619f41123087c401d8b7f55e0290b8b1eda43cc4245c9485e75dd2731d40968a2f989e72f34a7e16fa02a5a3e2fa468eb03b1a706d96ac573e449ea9e46d2867eeedb61198be0405287cdd0af8b333f979b6e40e8b5b506d52b14fba3f75a613283d7a45a166754f48ffd94fbd000a578523e76dc15e835c916927774f9cb7880702ce3fc5041324df80925246a169305fc7da5ce40236b672304dc37bd5df8a8be8cbbd5c81376ec92bab5565fc3b82463b8a668938e78cd018e15d62616bdc82e2e519f69930d6078f4c9b9d0c50cda38a4615726a011e2f6d6f158cbd96b46c6fd1d4b48d4a8a7c51c45a02488036f26905ebe543f426eff244b90468d9d1892b39a123edfcc247cdf0122610ec720c67c31a5de161dbfd217a8e8a1f66f48d3121f5467edb705fb59d0d7233bf282bbeb66a1c7051a1e7c0f779ae9ea24081428329f6caf25acb5f1db451808fe3bc4fc6e616ae3877c917f09319b1031cb1c6f1ba08bef2716ecce7768920eec274e499e287f85c2e5fdc9adb2b29e78dea4c26f54541d1331b8d45f16cab2f9b8e25dcab1bc70b6dec0b536a38e8043fc5631f21dfb5cc4ce095cc93cf70ac798239c35029005a3f0e7ec7806ea2688b44495164011dbf40c7970160b090039f172044f8f2c5d98335654426c3708c80371e82bdf84c4e3db562ea9545a9e5b3a883f42da692b796b5e4775b8004b1f9bc46f2980b470c6dc0836cbffd2cf0422a4e2b790255c3b343d3c8dfe9e6cc99687e66a1d803113899c5a5d4f4edd035089e37dc89236ad5707ade3db31ea768a2b06f5213fdb6d1f2c8ba9cc8c9e0a554226e5af47f8dbef1c42007b887f4c2c505c358921addac819ebe429b545c9708ec94c3b10f56531c97a8ca3c2915b19871f1f8080b5efffe342f03538de270bd0e3ecf076f98d17bf2ed6d270fb23eec78982e8cba49f3032e8b245a674fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
