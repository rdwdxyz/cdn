<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff7bcb12b0c045d0103ef958a3a5f6631e2868f94bb28728be9bd5dd8d071e415f11f33722fdcc4f2d54f120669e411eae0a69956902690c4df9a8b6dfc6a0ff62b54c25ac27cee08caa777e1d207d13676e8565bb1911b8956c121d0eaabfd10b43a45122fccf868d4a35ac4e218d03d4421507a7984a05fea2c45b29fe1524332c14fa5507887a34e21cb2bfbbe42ff68c95b693aa2edc1f0a56e16f86978b3546b9da95c4f54ecd0535cd590aec973f79c2834be06fb2915b95f46ea150f9aed8d4ae859a199b3d505b539199ca7b37124dd53b6d31664195412994cdc00650635fdc27ff701f0b2d70b6c5d4cc5525363a2c719d735460afd9bee4ed180feab005f6ae36da3b75c8e396aeace97c9194460868f6ca81abd10dd5c1f4802f9790a94085931c9305778ac377a084d691025de33746df923b61767ea218629c5549b98a24bc1d381aca65db4bcc83e18c22b29d5151e315841e076d7fe62bf47d26bf7fae15982aa26956f09627583fe224d37ea41bc135dbd32f74dccd48670b18cb640971cd1640cb29712c16c869809d568bd4f45b0fe82f3a5d4a470db63dd0ae7c6f2079fc294a618ef1da19a94d6b72494122a726dc41758e7d98f506d8cbd85feb3d8c20e64f39937e341e4193c84a66675c8daeaacc1ba104b48bf56b19a2b3b187622634ac2aa0227e5201e2d3e3169096248f022ed99a17ba6d0f625f67f8f81fe7db95bb522c3f59d7b490c26bed9575b9a5bc6b5849984eba67ffb8c983eec6cb11d36001522ea4b08eb82932bc01d80fcabcd850c5a2ac5444cb4e00d6f342a7a9e86f0e8bff76266005eea4610f44f4934e359f66ec975e18b7ee6277f0ca216122f0fca132863e1cc4abd2899f6ff2e85857ffd47c9925b7d517e1429d439ecee2ec3345dba59d6e22db2b435052f2c394360537e67acdff665c3dab01fd5ba5d2d56b4b7db2535b44cd2d86c12a180440a8e4bc0df56a4bebc6b47b01b998299a2acba74e23139be2c3426d5b7f00af1a3814b570437e9100f34aec9c9478c7715651df9a0d9340bb01aa3c8283587939caf89208dbed6f669a4ba39d67012e14b2e674ea4004904945618ee5e71c940697d5f0b6154446631b4a75c09979c402b05efad6dea02597a51ba48d2d3b5cf516dc67d89153be8e018ffc67593ccbca68f4b33511b60d67ba97e8773fae36d5fd3148b478f411e7496d95ce82d1b1597f916502514362efc39efcbc5f5e34c808260f674e12bf61f250fcdc9f1d68bb2626fc4ff614a43f0c73a0ab1ae61e398e76d8dbe4f11cec618344e1e61b98d53405ada1f8e79237230878fc28430e010130e621342647f1e107dd23d7486456d1af16cdfcb8a764556ecd220510210a99937683c33a1a9de251495e538efadd6aed898d4ebb2f22316a35e134853e06dfbcda29dfc100b0c8b54211fb8a5f40c348e4e7f020dce4274f02b787b35638a0270adbcc5e9d81404b99202c2c29ced7b9e875f1199fc4289540776a0c5606b1ec5488f8a8598a42e5ec488a35d5112b0c81c399a587d09d6b8919929abd243801b4f3a842b107c5a1ea4c24f715f4039f1ef72653efc604def54d1d629ac7bfb0a08ab52360de0c8d46372e791e2334dd813ed1ba775c3fccf5edd6603f987a1160f9f2c136d926d20780edd8ec21f8589c4fdd4dea4c5c8a6887602e4693b4d8d55b53ba1fcf2836c93303a19b7b19e66db4b08df59806c8af2a9d0c73477cccf579b11e608054eb818c8d06b50c84480d4aa5e89b0b1f85463df48f23df5ffd31f965586aafc88f402c8078465a6a78c749580b4f4be5bfc6be632f6ef67f82f744d720ff7067e7989c008294ec2a12ac86f32f0048edb7ab0f7776cf6e9335c41b641454a90355ee180afa05dfbf77298cad3c5f16b78e6aadf4155a9a486750f2b32403a4a2b5cbe0bcb6f2164b4381854928e63256b9aad624ebc75fe887fb4200b4a923e871b0ac916f0c5141b3b3af679c1a119a2ce80d2800f40729beb32b1662f5c3d6a112bad4421bd6d9eb636b181afc053dfc6affe6a871876ab915684892ae008dd64902f45100a0e339fb442ef0587ee1d70f9cdb734fecbceea9c702a8ea32e40f7b8be72fa89d4e2eaab958cbec4a416fd175df17c1b68e4e9d0938ae9fc6018645ba7945c2eef1914b66cb42c87bb583058a809c648bb3fd1999c4533a7a8b2041c1f64c7398fe40941d61178ec257c4c829996dc10c1d365dcc641558dacb351344ccd86a7b4fcd6e4a895986b1088a706f556ee1cfdd61f0e903aa1432bf6f0f4dc95e8fc4b0aab1fe4c98f43fa2884691c4fb1dadc001be6398b10437374ed7b159f76fdacabf34620475f81860473856d91ddda2e07d8ca78310a4ab0c23033899ffdc0c42a527e51a8f3b03d33834d4fbd76babfcc013796bf5218ebd3f0a333ca65b8044463c332a2fa3014a9996e864d2fd96540b7a5849d7083aacc386315268359e251e91518ea1eed23cd9a521c3bdd89f9c1d718700f52b650231d4333c3fcb87ceab6071cd4e34a4a4e19876032f5600cd56a6c89652cb10ece0974236046de3033fb1198c0465157065fbe5885959652346fae72bc25bfb1570b52e7a70eb004923119e669d22870048911792d675efa3b798cec4a31fc44c3c422c021842c45f8a6d11d978b1270da08b062ab0388fb180a3cf9f8bb2b84f834ba8d2b86dd67bd34e8a8bbed32d09b8205884b7b56a2f03973fc1ee59c2bcac990f0c13477102cf3b38b51b36bb783ac93ec79aa48216604cfabdd995beaa6c9d05e81bbf84191ed86cf93c0721a13c47adb3b20ab48d60bb6c7f0731132d2cfa86c2b59427af243f1cb50f122fe25d7d0180b7e58bfe546e09cc3c3b9cf2368c7e3815cfedaba58c4d5dc5d55ae3a3a99e8841de7fa5ffa61387d60bd0c6a00e126544d2ca4b162aabe387ad7fd754b5e0b94f1103713ba4237bcee0c739c736710869c4e7f187f66b59fdf3ab087770a14207a8f53a11ed6c041ff50ba0c6bf442a2c40bed03d99eec23218b7a71c5b866a227a63f3a32a2277ad71b1afcf15154c16966bb27f78e531b3534f501af5e5a4fb487a79607c99a5c4dd6c206e90840008e12eeefbadbe41e883641d7dcb674c40a483024dcc7ca78b4c7067c27eebc359f89ae9ba552a720803a0a1ddf07f5e40f77327f59f6dcf9b0cfe287ad9ea1acd6ccdd31b22e0c945f12d3eb376fae9841cdb60c4bd5158d31c26ca3cc7bed37edb0af907482240b1a2e7f8a42a8f0834a104d8bf0ce0edf09130327d2afdef23959b943f9ec63af420333092b77e606bb172c676f039161c3340c3c8b64ec5082706afbb61114003fb453b1c017a830b188babc1cd6e9e267e0fd86d5923901f15ba159a6784d55d7db29924eaa134da1b5c016182441d5c8511069c55ecbfe2f8287795cd3aa65f414e61f98d95b473cdf299dd34e08cc548ec8015e848c2af92fc68c34e4f880ebe6426600e3745900d6011048fce5847ed8abac1e5b5433e7d8fd27161205d27fc2f4ff97e5848cf0056c71f0d0974afd49329dd398ce5c00f139bcfa22398884e05990042d9619a8ffcd08c72d0ff6768b29dbd5a4776ad700bd545a85a38ee3a0da3abb1d4d8e4161883d39386c146e9db5eac1091451cacb99ab821758436cc41d48505da85dfd942c91dc5d142c28dd9235792dcdffb1495bcddbe5457a11ad698570b7f685fdd1be99c2d81013ed7af146dabe9493162805f5ef41c68e28c4fb76d39d774f612483eb0a559b559a66e3ca3d4ec2a85dab231b8526d32ae4b82b0b50227b2ef827868315e52926b6d99f402b4588e5dbb794a96be3cc6c348b6e8615fd07f490a6fbaf2c06aa5e455d217758bbd75a1bfb396a029e8f969beb173e5f04571417da8bba83bc7596174542125703731625ca61f7a3298ca5b026e67c881e487c61b7e765eec365d713967e50a5ff53147f7e824e52e2559faa26b039349ab665ebf849c6a50e9d922bff6fdd0f5da73be6725bbc1a6c6adbd87cb70426a7250a4fd20bc7e8308a1935c880e72ef75cba58aadb4d126560fc5b242d4afe119c87973ac9d50e7db9c19c3bb723c9ee72ee022a4b7db7a7319c282bd122830ea3b19aa63ef0067917f9f75cc8074a8124873416aae7539323471ff371b034b3a93defcbe633ae2bf0152426598aea5422307a7b7c72e13f87b1395836deace160a087caedee6c74ed612dfe15a06b2b9f5c09fb5c444d4ce79b5d6e39c1e6b6eb01f52995eb0db057d57196e54fc43e66a3c4d7f3c9483b4f2877e3b2111a6cc4b2431c20e0a4c15e093a2759e3132e3fe43804a29becc65d557784da845d23d00c6c5d4f4e29395e1d39fb41cacc99d6fe7239f417f179251fee085f1225f29a48a7690f43bbadffadd186bb4a2509e513bdd3b672ca64df09bf99ad4f5ca31e2f9af84ddd1094864590baf7a555eacc1acada1758d82d8b6fdaba063008f32098d84c5d3667819e4d790c16ebd851fcbb7eb8072686607bee110f617625a81fc09a8ea6f405f2feaf935cb0c620494755e4c6195c62d167df6da8acd9a8c9298d48cb25f6185e2fe5dc0c92af4bf9826cf629c76f3a9718532e36576a4d9bdbfcd3f7a92a65d5b86eedbba930e8366b3c1998641c419d4a26c8651f7be160983cda7cffe942ba52199bb8282177675f0ae033d6abbb0efcb306375d8bdcf10f148fccb576c90086b92d40f2371425e317516bdf04e6510d745c260ba392c485802d18a06ff3645cb41bcc6ef7e2d3b348cb50d5b8680c7ee26302ab5ca9a7dcc4d5a2060ec9e8fc4d54957567c1ecbcbe792fa05f4cc61d0b026eb2e39c66949ae616f97b208762d81d232fbfd4be7cec793de69611ab54adcb679d8bbc5aa3063a4c5fa5306aa7f9fafba0a492bf50d2025d91b80ff30eaafec57f8c860df245ed29df322d44ec1295b9b5000476fdd2f7723de18e920516718d45629f3f204bd6f0ad316981eb8420862c6a4e509f08f6bd0146dc67a379f89b87ac203c664012c5ab650522159ee4621c69b1966d8558ef2d3641c6545b0eaaa25e761667e29d362b1d8410b8ef35c9575e08c105132ddf06d67556ec32179614a7aaea8bf7c55304ad6d0d55a779bf874f8c4cafc5427bfa7d453aeed3d45dc70edf72dc91bd6f2d51ca22af4be0b132753b7b4bfc7e8694ecd63133bdccd2c340acda9e753eaea0b7caea3eedef79d5882944cadfe2529d6ed4cc9168af1a39129207178568995de7efabd1704a4782a8770d66bf949cf44d222b6bd401f53035310fe07b12e4327332b13ceaa12e508a356621d7e44546376f2a55b00e18e20d9d6e653ba54071b569effb9597856638acc0bdec714c0884e041fe8243acde026caf807a9aad1ebbfc7a4ed9d248781b93b07008f8efa4960b674545700c4100fa63e327217633f9947f8102768ec3d5198f1ea64df29638583cd0c361c2c3c1d518417df0e3acc5b986e1e43ddb170cee8d124035dc80f4949c96b5f577ebf0c3ca5a607ef9f93ce7b13182bfb4af88b6e08939f697520acd78411339b2a01c47a70721b46a0912e3f33e6aed541d199e2a5f11a0054155fda3418dfb62b16588136e366b746ebfb2d709e82dd72f1eb7998b8d2056b979d50f7c16a6c6d2f8f3ab1b8ab866bdd0ecded0240d9939df6f3d63b17aa4b76f79963f8880bd64e8af7839032bad0e0f2dff950fa79584eb30078c6c42c18e3d28842669a6327693374726ac4951783ccc38494f354c16ca14b5b2562be852be2afba6e54f2e1bc63d7d44dc860e0bce61fcc01279af4405850bc6909a5fe7ec8ed0c9c1063fbd22729c1b45c8cc5ac5bf588e5ba157fa9802e97de1a097d0b1adb65439edfa979723c2608533de7d40dfa82f28cbc46703b6d843ff74e94b7fc618e5a68d4dc9565e9cbfd46409f1b96d437d926de91b0b7f229382fed40e26473b6da5547ae816dad16621b2bfc4c9cb3958871a1473cfd3ed4ff08096338cf91f29b41faa08bdf95c1c1aa63174642dce8a3562671a95f3a3ef4b60feac0974207c95bfb95912519b86590e0b46b6d1fd85a3a996e4a4239cd3222e869bd6ea8c225f34bfaab689d3971b681fcfada46a81d581824152354c778e279ffd5e6d54e47072a3302eeaffaf95b0bd39d29b6ff85ebe98930600e7b59262c4348c7069053d5acaae8f73e8a4169b628f7f969b782a0c6dab5d8fe4535daa607056429e5905b3d15c965ddf7ab210b0157cbac72667771bb05cee9a7ea78402c54d3cd248d78cb72cd04f2d3f6c2ccd6a88d3bc3ba0b90e33e10f445d54b166f25815c40d760d3e44e0bc47fb117d0ffc49200c364cff57cd3abf8b867d88952c1071064e62770d18ed79dd6305003cae48fff34991f89417e46fc7b50b88ea97828fe8d6fd9d6a339fe2ca003195d0dc73a665095fc859d5d1f5811cbcc23fa0c0c78deccd0ea16a19d9eb69b1ea4ea30b02fd5d472566915d56d0dfa848c914efbeefaa825d9c12a3a65c73ef8c9c02b19d4a76488fbc3630d9899eb8e6f55870788eb36ae30929d9129868c5a99d6db8459c951cf51865a239f507fa66fc23bc1db471e0b46b2ccf4783d1ae188e1fb1ed3079b3f07bd56f5b111d14761109362246b8f333b546b48275343a09125ab15160f448a01f6b7425ac50b0fbd63fd95499d843bc508556c64ea60af604ee2a376c15b0a9cf8205d46c36853f08d4ea7899ebee28ccfc936607e3cc02b68c47cb21fe8d6d0ea825f4dc93a024c47a0f02564d1163decd65c7771af648fe86e9615c740b9271b7c0509411cc848425299b6966371f63d66b08679c83b454d6a965f87c3db2ebbbecdc6c9e22741bd22814fd77fb19f0d05baf34e6358e0d85a6a1fabd727a2e2691fb165782bc26b319fa679256bc13fcc09f361239d598eb27b27e2c80ef270ff552b6ce79e0557ddc90f246e27ddaef7002a2f3966e9ea4d4ca6bb64bc068410d4d4c4bf1da295d6a70f7a4aee709c1f53832628aef088171957679a68c38a52d9772709595022345c2d90d75bcd6425c9f9555cbaab4c664febddeff891149d5cd4f1a4a16a3545b0033520a7a83e426f6ae33345dd43e4be809c79a168cf77f311e0183ba9a6ba6ce9ebf8cf7adab0bc4ec65099bfec064944d4da95175588456ea21815529818e1605005a845ca0c557abaedeaf65ac976245eaf1f318a5c66485ba0026d656266320db36f5c24d820d63c209728bedf5dd64c8eccf4d995f8c0ae2eb825133a2e28b5544bf17d5c129045b9106ab174bec11ec491faf7db1d889e5b14fccb8cb6d035c4768fbcc65d8c9d7a02cbf4e47386aa72f33e52231bf289498e6095abf416b1b2f816763f394443175a20d3820a3d0a31631658ce363fd3d7a29df56ba1ec9a33980043d5b712f3f6982f9f603bd1b779f56df3ea8574f936a8809247736c0de35cd6e86ed424193b9881fbd6045d12090bdc7ed37b9f248b388128a516b25f7624e92889195b8f252b89dce1e1b49e5f7baee48fb49373885b5d8a6ea7224a997e44a23483349eb58f7dfe9d15fa6cc8c25b20489051bd0e1c3fd01cc5bbca20da89e67b3ee2473f7e3edc192cb0a36a479ea4f89150bf2d08a69cde74b23ae3cb563be3f7ca1403d9ced44abc635b77fbcf32165b601f913162c626372f3a7112aad4f2d6a99f2c8850cd7e1807258a9050a3c3ce977904271d017f8eb6ed0d3095ee687525619f4a651efdd723ef427efe810a58478cfe26ca6cb46f1c0097d4f4b69b96651b4c6341020ce4b4be89dfb0a23452b4d357af8118002fa7ca5f9350186c2d3b330489df2c41b912ef3286e55a9662ebba2a442c5968cdb8e6d94f48ca02a13c11791afb634c1427c2ffbeae6117a9b093463237f5d7940226ff4aec9cc4752fab6f3ef41f375a1aab96cd1fb168117a251fc05bd96041ac72f2bd6e3e2ec549f4e365052e0e712d4e6fb9f7a83e5ff395eaa67758f734784f746430c820628d8462ff500b3e70ed65ac6e5cda21db47b1c1c6bcbed9c81f6f31922cdcdccb861aaeb0474b53056bbc828242dfaa08ce6fabf73b987ab5e8e05c0ab1c5bc934aa4ee2c1b7320b61c9c4d9e8389593e3f320f3bfaf5a42df3a108f3f93984bfebdf071b2bd0c9755e0fb4b9c6cb1c6997a49231cd2d2f5e51bfeb78d244ec1e3d7e9c5e4b42364227caec1807338d9aeb93c4878dcccda2c0248b54c590cdda8a16630f24c2fa16aed6873767649313fa8a07e2327cd37904cbe0bf6925076ad17693e4a04a28d214d3569c4a1f834766f8239fdbd60a978bc8a1d2a45988c63686249e51b096a75e32046ede5218a7e0f298439730f63ff29a82888db20d886062362203d390983eda897c8f4293146a7c70a30b53e3cac8a93619a803c57a795197ced4f34ffa74117c435357fea05160540779d3f5505b0e3ecbb1536fee61a0ef3e3149509984769814f2c12eeb10d0898c1141e4445701b35da6505e67627045cadbb0f16405150a771ebd72d22d6bd8aa04a31a8f0454b5ccdbc4bfee97fd0c0c5871ce16f74a7f89a5a64f802903f5e7bb0d83f2c1a153ca9d6a3cbcc0bcd73304c30d9dd6e68f0a55a85ca83972b08c2b08e14630a3a8b2bcb894d2fe62729a1dc77097c7be2ef246d8f57da810e094bfa9f9130122f59284a8fef37578f41f5dcdc246650c940569db868e33bdf60a4635502e5f05924a4b6780d63a4382bd6a5187959a7203f08e2876350c8e9a6abfdadf37c6c24a4fcf48ffe584007a84e70350e5bc08f319579034d7a9c263ee704e535a9955df8b7b3171a600601f4467d8b28e053da9398eb1d63bf77e8d484fdd8bdc572502af7021b1686815322d771d037feb6fbe553485852961a0d65403beb629de59f9eef846403e0fdcc8dcf785cccc6ed2306eec61e36c5feed5b8d2ad0b3d06b35696e3b3d8c3c80b2b07ad4c1bd88710fb3ba3176f021ab8750369b269ae948b5b9769cf52695aca04c78d4cdb0562d884ccdfa367590050f4aa109879334bc035a07d2cde44f56e9cec55fd76e21afcf4555605cdbf0a48fe1ddd9e824233cc48b4783e171de0f20289433ed04698cbe3ecc8c98dca84a9a7088ee29b2916c681e45be7fba05bac9ae91b5037b6d29a59ce408f3bffb2823835a0b74ed34874063e1db67b3ae35e8aca1a73278203a077f0b109c09d2e5a03e93c66db87e3ed0e5843dc9fa4c2959c6539fc3bfddcff2c4dbe1922d79971f9dfb87649f3d1f163e559571ebf81712615ab3b9c4bbc94c79454fae6acd21ff4bd92d7bf2916b440faaab225911906d89bddec57a19f21ddf2daa9358f2b8b596c0da2af45ab916b7cad2a6f192d69b68cac5e0b64a7002ef703ab3b31ffc631cfa2483ee47d20ea2a0685b306c3dac51a3d1efcb300fd68d1593956c8c6ad6b0a555f7aa22bc7020bc6726c6fe94ba7ee2cfa36c40217ce48fdf1790a60b5c27bf41af616b0a7a8e514812ad6d015d83d1dbb740b7d2129d7c5ab6f9c97f9566ad3b0b4d3e7571368be63f20d26f5be6672a5792ba7ab888258eb800ad22770e7a2920620b4c3b4c4b008b1d9c0ff0469427ab49bc7f8f65f0852352347a326b746f1afe97c69940f127d603eacd2fbcf9a7efa10eb51cc5b7914ecc4c5eb6c4a30f6b910a7ccf7ffde0efa7815f97bdbea69f75d656e38bf2fc8b9a5b8ebc131e9ebd9618829f1bb4c3bcda7c3032f49ee40fd10ce768542774a468afa35f9fabd8af0bf83a5a4b0a36948904877b14d91745c6ca24feeb3f7b42ec574dfb2f93b1932546f7683031072a79c8f1fc284e937e32b8472d9170f53c426185abe908cec7230f40329a4b0d90ff411209ca775c26e5a910ddd1d2233d8850cf76aabbdf30882ad19fcf531e6312ea40ba92f12728ec6c3ddf197605615268e8f9faeb6401fa2ea38e9a19626a443d5f979cf02e932cc6085714a1c87d9857feb59d247cf0b0d72fc138a76f963f233662721ceba236ee87061209018ad48aa7d3d409ef9f3cff78e68d34c255de705d33270982aa2e1bff6b78635cd44aa273832c5bf88fd255bb8e123ba463aee268558ff9a8deeae896d83e96d8998c6abe3862bf56fab35663e6af19f1b49e4683224df1a5062ec1244279ec7b7a117e80830829f5350c5e17fb47e473b7e1fba1d3df85df7529746496b50d7fa9f1f544ea5dafb0bb756a6b69ff0b5b496fa6527316066bccc922be2d895e30acf46d6aa1e433b7ffa6741a12b152d1922b3d13d7e017c162f4c285de134ab6955664fba71a8d31ee3c4665d9e9786b9494cb668bcbd09653c62eb90adeb8d58dcfc6f481c9ff39c4af006e270587c1d4e4e9152ce45a4f0adf800ddc983287936bd329445e944fad3edb64a0ad7a902789a3a13be79aa85c2a14baae85ee0318c030d0551e9a0c6a6bbebd788bbc1f5ca2b44e73b3c2cd6bb6667bda70e1bcc822fd92ad8df3d4f568ba20b2fc4d56ebaa365f3195917a7034033b87a2060b28321c831df9c6a7a4442df862c37db6125f52b4802a11ce6cacab3bf609f147c4e5d7c43685b38d589eed61262b0819aa750cec6d7396ef6b5c155497133106ae96806775d2e90f75ac2d189be967e2b92058e4a5e60ec37f3fd475d7ef57ca57fbcc3f8544cfce49b6a86b2e8c5be30b166fc22ab8107ddc062581dec8960451067439daa5cd253ae59eaf39ce11f59ea251d680b44193b48e26e3bf454e5f13d8a59d5206a00c84b1707c234e06eac7d4fe9919ec3c04d5da6a6e6be149bd9737d3f9206d07861a9130a0641ae1685385165c5e3b4bbff936fe66c91e85ba543fcd7967c1dd72e78947d29f4dd317b336c1db3d964fdadb9a800efeff5fefea0f384c34d14bfa2b95cde7695522360db7b6468e596290215f6d124cb38b961c0418f89581587974959c93f30cbbf2b31e1e6cf4cf9228077f01cda3a1309738c2f8e0ab3cdf8c6b116edee45f07965282888ebcd65059f11690698cb799e41a8f225e6b125025c54b8132fce46beb7e67bbd561bace493c00f5c452ec24e8129efdcbc7c3cb3deff49778a0dbef82584a5d09b80395355658d9123141747e558bee98506281d9037972ed3b65fb1dacf143009a3472c1c7f28287715fa92f93da99722b0031ef42ffd5ffab5a734b46ebf6713e4e4ae3888703ea4b719aacaedc246af35b2e3f42e52a452e824fe7038a4d004c40b2bea4dd3ec4f8660b6478a1cd53a39f8551e63b4f45054ac6d38d877050e52adecbf0c0271f5ca2494260e78c46127a77fb0a00cd8778dc9835269c88981e2e89433628fa9226fb1bec8605c4f38e0294d99dcd4a93db12046c85daa98093d92f5dc261efc1d6ce868dab3f819ca0facd6d81b8e9698dc5b3a95b339cda21322b21a0bb9885d31ee9c1bec7612fc0d8aec16f59896f35e405bcbc5231c9fa112d12daf32c32f85a2bb9fe6af6034a9cb80688681fd4c4f611025f880ebc994f1e4d9e4a2434c8d41daefa975381355d146b18ea93a4310c9643250108c22c99efafb46104645cb2cc0200b9c74659906a5a6ccdacc4cdd5ac20480fa14105e1b4f89c1a0890d144ff36d21c6df451185651317748f73813a4a7024ab07cfe78f4e7646db0a9f6090f36f80bdc384ab815e48ca4310bad1d1b2444723330fa72a74249256bb9d327e95947321afeb8bb64d86c93db5b5a69c1735da94b875063c4fb4f93de5957dbbad900d37eea2e0e0486eeac5d7508480a96477751f58a648c166fd66b948062f3a0060d4507d76d40953c9701665aab1109e7b7dbb8112565b103c0ab500f695bdafe048f6220325fbc7a8d23a633f6930578a6df4d0ff866fd023ffbf938b6b2a7cf53430b8e122861d528e635affdf5ee74e2d5db1271f1b7585cdb2154d0d1ffc5768463338dfbc4e63752d8690508bc168369700265f08d76a69049c0de17dca0cdc69264572110ff94f7a2bde928032fa40f03eb97337f27f5ff564fc5d0eee0017d6386057762005d8b2cd820b800ecef3bb5ae4cb94f30e0e0656a7f32c73395c4f232994dc4b617c5f310577afbd5c73c99dc207c57150fb95a5a08121ad4b2f6755a90b15b5cf0fa781cee2ec6ff65c8846aaad1af3493f5479786a5509473bd8583ecf7cdfdd2e3a32c1c30c3af26a38f35747f8c87d752df64dd7dea238097a159e42a38d1bfaea901981d704f1854ca22569e755798219341d862bf4d3362e20578f0d6103c087cda7e74d6f6d5a0964ce6f93fa3aa1b4548a7199f76985d376e3e0bd80312c6d64ef0744e120d06d859baf597ebecc553f2b3d245cdcae51580fbc5f8f77fd6d4432f25417ab7591c9e8af57255ad1264524098267f4754eb6c094420f34738e373543f01036ee22989920f47591f18bc023ae0db428f02bf6be592f0c6302f8381d2dddf04a359e06bea4724d5602669ac3ee2784705d183ac463640b34eb77a0f69f09329c14dd5f5a98edf77e0e7eda97e94562babf1ebb6bfaea0e5aca50ee2a13a5f8e60fd66a0d4e1fa635968e52641fb779ed57d1f8627a9138ebff0a7cc04d418727aa9781fad5458c73417b71b4d3bebea18379483dcff1f4edbc35963e9fade8c4da2d322374b220689bec05de2d76ae06bcde7ee0824b3a4c810d7c49612411d3ac36d1999c420777d9ffc4051fc5104e181b60d163b9343be97a9a2c633499f1fe515910ad71afd5371fa4d24848d0e18cd75596e8339b3ffb72fe2853f7a5d492f204c21e71b88b5278876f98e6abedb5a5c86248699df127ff5591f8905b6d9ee8c6b157495e654795eec34451b43d8d04cbe48e09e1a595be06ecce74c460e203bb45c54beb34cc4b0f4ea3fe5e0ae78629169eba10f2457ad17cdd5318ae2e5be6856b4e95b2c2b3fe3593391027992b9c529f6e5018dfa675e44bbad011fa79b8fbe20ea1eabe149db2cd8c832d2b1522ab9bca3cb00a7724a454b5757e205d9c10d53f13b3a33f4de41915265c221fa86bc8e1bc29212fe1872ac1952c1804b08047cf728d85dbc278c5c09aa2142d3adacfb11e384c1bae9c33acb6113bd096dc4760ee567028e7f31ef160bfda8c68f950f14b7ea72a51317ecf62b916235a318fc0c4fc1744e2c47ae471d7f04033d6a5ef79033a815e2a70b635dee92fe5d142a15f9ae7d4f5cb2803d47fe82977062ecce3005505966903d9b1e610d7be712dfeb8f4f9c8b7a13bed832b8618b3001d8f332461780412d5fbf698ccff4886e52a5d893f383e9535408ee7561685f9b46a739ac7f16c60cce9af859dd5a011d658882bf03b9114e51908479aca4c9095b3eb8d358924914db8296252db0f08a359029c15111205a9b4aab920f0234a37029779f2e90cb0e4cd19699519500fc1b3b5efa5ee14f3e129ef3c84694ba4231eb692f1767f474dfc24db77a28ebe6fb20eb709363daa88659e9515583fd41cc565de5ceadd4df22d0930a64fd37dc2bd6c19f814b25066ea2014beafffa1f2064c07b3020353abf6ab363cf038d78926092a1a07fd5cbd8c4de95a70fb2ce70518de0b2d2c5e45587f583cbc67f3da4a6e7bf722267e6e19d8983d249e41cb759d27e29614201fe2951052cff32fc9076c46559b107e80be6f94e0158b8cc6bec1ff8a13af8d972acb197875dcfe002452f50e30b85487cfc5d445b4b00f3c56ef9ec66457eb8b3a2b69f1e97c6e756b6536710b6e9384665aaa160f5410f60006cb8524063d23e95b56f6e5c44aab0e3c96096e5d6c7e71fafa11af3ec7237b7919aa930664b8d5e51dec63df7570f4a6661392d853111f2fcd33c8d5b9cb39ccec86872f5db58ae354e07366941f9421ad54ae1edfabe6f1d1780e7e5b92281977e2c9316c32065a804fbbe459a35f99cd9c7555f78aaf219c7777ce8d2f99605544bdb488eef89f541a465de3739c890368d897f443d46b4988f4ce8cac66d9e2c633fee328f860cea725f55656b8051b4c0eb433f73f67539cf6855fb3c990092cea49fe057a6643ebd805607526e8e729a489b7ddb305383be4c0d06cdd6ff881d9db84b79d7001872b09e922f933289843bb6a6b5f4b5d4a0a565856db5e47b8f5ed3c9bd04f0d9adb45aa05bd38b570eb3da5214c7129257d24c12b9e1109fecddc25c8f16d961242df55fb2d1f8bfbff78d35cacf55c40b101e9687a6edbb5c3a9f267e8a6c7308853f65ba51eda5804f84ad263534157a28067a9b5467812a49ca7626b4871ed1e98d3ed68f19605a2933e731b65923f353635fa0c4827e3ef750047f93837a23fd5e8a4dd6e339f59485a5213a7aefd7de328d8b93f37b5c2c0659e2a5526c5309ddf3f0bdba449f138adce06db63dfc9fe47673d3ecbc6f2dd55bfd81c0beb9449805fbd996560506b5b2f3872efc449caf80c6281ffa7e7e073e0eaae7b84becd1364cc340947584ce50ab2528ddf63e2e7032416a170cd9954201a5e4f9949901a5613dd43dbff569df7a593564f8fff7292bb66cd553a30ce4f3caaa44f20cf96be2110252b7d2b2c25244960286a7beb94278e6b722bbadd6be121b659e466b324950fd804fe5c9d355050e09e28387974de12be166390d72555d5712c5ea804ded3fc969750ff3fa12550ee051168e40b70f37184569fc81f918c82fceba2e30782c20af80b7df316f1d163361e69ad471c2b59c10059477fadf7ecc7687025349f2f899c4da30b7b9cfdd6856d83554363e71a33f900fbb6a7cf8dd6bff7ec7d963ed62ec1ba51ae92b9bd2011477018f24d7c1ccaba81449505bb6fce731e9e09393f23645e741ab29881d243fdf83955a1d1ae259dfc51fa399aeb1ffd687a2f0bb3c02845ce830dabe2d247feb8ee558d45127b8c8f05ddcc5fedf93b2c5531f1784ed406e457b59accc8080bfb35a942a4002b65b0d198ab163ffcf3ccec3c41ce82bd228e9f3af8f4059380fe417d3977de76ec5e4989a9fc2c03148adf950affb0ce21f4818598e795968080062ab97f0b5d09bf5a7c668f8ee3e3bfddd527556d1292392cc75f00a25ba95aefc4caee8c936866fc18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
