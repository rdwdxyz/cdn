<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d5d574dc4d4d485f043b9195441a80093bae7f7fb61642cb86487d231ad4e990a3bf2370bec94e276a73585b92e346ef8ae0638dc5370e0f808d4c26d389b554c4e2664366cc0cd0a663d059120a8bd3dec93e596dbc112969d35c35842dd6f84cbbe173d5f10612c1f89897dc631b723fa03512c3135e1b13a054f7dc3b114bfb23e44b6beaa5881866c70ea79b1157dd7bab2378071d7a471fbc6458a8299eb82f72e3f14fd443987a2545824887336c00a88d4d47e6a22cc1dad624fbba2167c26b01329deb2cb3f672ebf0c06638dd36946151bb0dbc87db5a911b0f1a2b005c0c00b29cb7a78d79d3f4852d76ea5c0d0901a3a9a6313201f5c778bf932f3cc5eddecd155c375fd7a8958e0f5313278a09750daa0b8ca38e43c99d4a9e343fe1f1bffb4feb20a534400455556f253788c349b8ce372af453b3d7bf68476de62ca483c9ddd4b626b905462ac44a92a3cf932c9c08241ec32f115794c736398588bb3776178759d35f7e0ec2edb5cbb7f1c0c22e1c9a4f75c630ed300189c23c2e217d78f67b05672b2de5229503c74925706e82e05e4e78d12ee2b9e1345bdff218774f2ec39e331a71ce28a11252e6a89bfecb5490f9e24683580a0c2eebc069cdcc5b9a69919c13983c0f1c6adbab7230185bb9c7c5b8b79bd7542ceb6370258e53571b5e0e8e715e13bcdf7aed403dd7eacbad2d2666c88a5fcc12657c6c4e7b5f2c673c93609f03e6b5bc698190c815da2c31533239814b3dec879fa0979a4844357f804056ae7692179fa342e159d845a7833a94dc800f9318ef3e096afba2e1aab17e15192b3c9bf7a227c27acf4000c0b3fd74f5b9ff6210995ad423486b1777fc66a6cc63bfd7a066538d1ee7339c13efb5197b02b8220265bd0e1956b24ea08e38c26f779cec68ee01222c9aec018c0c025f2ab572ab59de87e9a0a0b4744f45c57a45f7a7a830be5de5de7000538eb1fb1af3d35047ea8d7558b485958bb408268d7d139ae5343e4c593e061fe3c956fc7da2006153fe0ae22a75c9836fccc7e560159083cef9e1e51bc66f44f8d2d1a423ed2fc155aca394266592946986f6dcc2aef98effcf1184f6f621fe5d078870f379e19217ffa7fd35db0e214ae65bafd8f0ede67d67101caa9a23d64d1a29f51a11f097485a334526c37f78bdf1cbca7992e54ce10e03aa29d926786641b94492beedf47adf9635237149b251afda035e76b041dc831c03a18f3f484c41913b0d8a9978f8ba7b9e8ae03463ae89c4d2f7daaa7df51eef3b1c0abfc516f4c8e9c5f544ae65c644ad447732387bf8cef5f58a9569ebe6f5c3542a7b482b8d6870877d01ebaf4aab5e4d8ac24e1af0876f303d2148aa0752c13d1305d39ec23161e745cfaa9cce58cc0ac0c9506676689d44563904d58d002c18cb65abfebd9a5814c7b69237920e6e9378850f11bc1a225d3def1e15eb8e03759f4ed76252d207416258302466e5407c2e0787b5d48539191a8f6fc36136e90a4326deaac59d3f265e91355a608a12c42fe0308f0eb9a5ff3ec9ca67b95089f51abed62495ab9e80a2617337872b53c29d087cf557ad622a15f06a2f81893d0b162a8348d5b7b66b883a2f22dc41d162b41f986dc8e583da9eb17888c6b12f238603ae359d5b3ada6622b852fd91d931f3d7635526cb2b49b9b0ee74f0717f33a1b84906720f37548c8f5c5cba4360ad87a3e39424abb1105356bcc4cea360ffc52a860844044941eb903e0bfb12a27ef8b5e1bf8175653573c3d933ce3d6eb57ee85ac5eea8d73fc3352429028212bfc3185f91c5a9945aeca9840b0d9fae5f4279a82b5eaa4aab246fce8a6b07050dda8e9a08a91a86832cbe401b17ec0242a9cee1179612e2e522159531a4f66176cac3a7a386e43c0f06e3b06e75c81f00f73719a760f360633be430312a46c9ba92766bf4dca052b3d38bbfa7e62c472642a8edca412536ae664128b266c7500c6e1d4d1a8c4105cc0c065d52a09c12da060c171b55add9969dadb51e2f68e0666677d276adbab95ea9524dd31f94a5429def6e40763c1c98ba22ee4dceb68224b21f23e70360e6ff9f5389e97dd182c6a7c16d3338ddea755242acc00b38d43c7dd5787052ebf0ec67dcf8aaa5c847ccc9beab1702a1df449df063b853b7e7846d3623c08cf24c95dabcbcab440f1c2f6b4e55e3b3a4c2a0da00617172942196b5eda240af6ec34c762d841057f334c7bc6290bea5e93002abcee03a6e0bd01db9ea4d3c53bd99be5f0bb0cf9a8ab29d726e344860de8998dc9225d3778884f25bc086ae5341d7b3276756df67c3d609049867558886318792725f99da7634e368e9124c4d4feb99fdc3ef66c80dddf046816c39cbcc4368f542247a69f0191ade8deda332bf08346f3c77702a1a3d7977de9d723e4cee925d6d9d29d01e259273a723b7d4e1773b9f382e3c2522cdbe7e59798aaf03562aa4e46d0eb5f65ce754a081688fc4d033af6f752f70c93370cac3d49b822293610536a3688af1eb1fd7196bd39469bc82f62468e3de92e109e17a50f7e5937cca5b50012264b92dfaf1b48368eece7f33b0ed1eda51e5ef17509d001a4ebb52ee2023e83354c8887f344026c4a160af3eddb71d3a4a05d541293a748607e27343d1d47b5024a25c729b2f054135f4690623d16034d6e800af78ea18da205fe2c2fd3990b17b7bac720a3eeccdad1811351d6f5d54d9d439b49c51d4a9289069824ea38a8f19fc6bf3fdac51132859d3952f403aaa65749f8b630979c02a8e735c7917aea731970baaeb9f11cb5c1c3938501d112b4ffdfdabd4d29161415e7a4d76887a794275ad239fca980f422e3af6167f79cfb174abecef1a031af7e56fca61b766c0afd3db600223f1afdb3381888856830b5c366093fe3a49ac23836a33df141266d695ecdcf81020873242a4c52b328f2d93258531bee91b897ae37e8c05eb5a7edea83b14992aeac63e12745fb0f9acd404e51fa0979e53221a38097f7c0df8ed0226bac50fa706068561fb1a543063d88f8d01b4fc6cd32a6e6f898bf9a393670bacf33827e178ffdf23f0b3d24e622f39cd00e0172f2d1f931ccdcb5e1103596c6e2a03619034609c28856c50a5624920c25434db03922986251f40d581b7b40f84feac464d8aec2c1de13102e01bf2b5f17357d18c84ef22865a57a3ddce86d33de693707aa2d0a543764f9453f39897e4c4d46a3b6e9d858681d1c60bb3b5d0613ac943c06b7f93050bdc9aa89af06f4391d99d6a8113e7821baf5f20ca7eb1ccf9dfd8f8e557871d0eae4f46e8e47c1bafd7a7cf0b19fb815e1f72ddcdc80a35dc98e2f1242d953e2b67f2b14ad42488be7ab83538d0109eeba5efc710193fbff7693503cd8e3a5f80257756a079a2417106f8a291742eb16de22eb36cfc7df40fa94d40f74e350e248b045373abf179f401d22e0108fb49b61a68cde06192deddc733b68bb5083ea9090dd57d7d5e3d4234e1d6284f4bbdbccf5584c5aef183b8666ee790d856618d254c985adaeaf850ac237cf5a26d9489f715caf52dbd695c0335028d6d16a4466ed8ca62abd3d1d360501882c30117d9d3eeab49fea032d7d56ea4c435b51c5bf614746e23f6d03d1a20c03a3264534cdf580c8397a1cb4a6c6fa9f8c11e241100c9b68b70133599bca3ad64f343dbfa12946e05e8c02a71dfa0d06b16eee952793c9bfd2e09ed7a237b00ff9a6ca717ecf51d33f742a87ddded5cc53a146f0cad16a791151969915a847de39a9bc01f97504d1abd1405ad6bf21c41c312554208638fc38193f0c65bc6ed10de90c8fa51b2b472f3212da384cd661d94ac434aed35ec63f13dabfba504cdd5ce75e8476c5200d35e920ad87c45ec5520f7eea3cce989812a4b6dcc5f05d5fb04504ae20d00a98fe7077a524f4fc96f1fe5f7de6dc7076886060921b8b248a548fc7351fb349afd1268b7f0a8f0a73b9a4126050d232ba59e812e798bd91641adae01a1c297059aa5baca814f18a37fe355b3dff477e43cff8ea1ae5b1337be77bec7f402d29499be2248ed0a360e644ab708e31e01308f741a88f1d9ebc9dfdd746357dfbb0bfc07a8f86188e144546432e4c29391fb24bf03f7df222758ca8a3dcbd4ee6132f1c4e7013cba14faad72852d314490468ba382c40bce243721d025c599b19fcfb5b93aee3fb8911cea38d68eb80f797d84974c16b1bee96f5bac198a8817db34e764282a6a7b17ade1728ba2b4fdf02b4b1afa6fcc164f827fbb1e212df0e680310f18e0623618e06d49bc1a9eda4459ff380dd48f4aadcfd49492b0a1b46f900ba681b80c159bc47a1ac5224597c6684898d6736c971bb05f4548fa4877d4e981c8c7c9335a9a24b93baaa9c07462359991f2716f26c120be92858f146f3bc06985d462b9361af549fefec569deac383a6dcc300c8a5b4f0dc8bb851c678ae535e3b0f9399c9b753b0d00d71c439bad19c1c38962b22525f9f0861799f3237fd93472166aeb037f3457fa5d9b3132e8988e0d61b82b3c2e3f4bcb8ec6026fdd98578f90672c47db82b7dbd416e6972abeccf7769c0f1dfe48062d099dc6be2f4d6d6afb6bbe0d82c0425c756c8b28252e5f1c335b91366ca105efe8dceb93c8ee167973eeea9803eae13213eb0203fad5d8a738b969400133b50ef31778ea51701e281c1c173125faffcc500d76d03b947007cee3e9c78d132de887deae89b6c9791a542f6172a818ef3fe7071e2863ec8bbc3d0fb5ba26efaae18ee65e65cd7a8611bc1666e01dba24aaa6329bca748feffc2947d0eef2b72d3e0644085e86b5dbd14c258b4cc02e7a1f2753d19a538f425b3159cea1d1c0b36c5005b5290e8520b99b04fa937cd3125f38219f8af5b24357eab3523d6b8fb8c3ee83b194ba37f00c88c222406906d6203da19a4ef69cd8864270cc6dfd3e1df15896987a56cb3e93f60365acd8cd1c7a124a5a80797d2f971476cde526dd3cf8de146f129b2771d6d1dd7c721284d9aa4c57bc5dd9ffe1aa9baddd70c336c299dd32f7a03158214370ab100293f2e3e928440900f91c7b52e547f8c88e0969baf1967532d6ae1305847070b0a2517c2ca83ad969e16760a73d3e03cc1e5e133d1ff0bdc8c294c8982b27cf4c5a113ee8f53219268be0e1750eb17684b0c4975b3151656059013aa0f8f1dd0186b4b6bae6ffccbe06783dae9d642aeab95fb3394ab78057f138f1d67aa65b67a91dc66a27e5d7bc6fa0d47cdfd6ed68592d6c1c5120c202c71733844b4bd4fe4953311290c4037cbdbc24b72c25533087edb86c7ff06be289f08ded181604bc98cba569c30149dac513b02fd148402283fd85c3a1377bb292a6fd38071fc7e4a09c8c37cc581a4cf7c888eb1cbfb9fc29eb4edfcc692e7f18b1795e49d5df1966eed441439e08baec7650563b18ed296ed354f68f3f2472e9f34e95d84c08e6d9e48a44b0e4719d66a5a9545dc43ca903046716ccbf52fb70ae97cb817973eb577b99b55019c72076587b8ebe26561e5d0c2cf02dda601e48be6ca1e25fe0b52800ebe0d6b7e03b15e620a0dbda6fb20ef84f8ee4a113c873747e9d3db9685463594e1776596afb518feb2a55f926df3da781d8ed7b1fcaa67e520cc23b22d2d0dd22f493bb1ff002c14265d7b1f3dbf9f2e2d9b1c7e97d31fa72b2085e6fe5d2bcb813c4dc9eca886018f7f476bc7b968dc67d6857975a15da44a86ca31e46c0dc28e8cb1a7e6be9db63aa5e9760a61d672ab7963ea626632f881e9cc9c8eb61127e8b7d60a8ace615793c6210bfcc06570da6fc90030509a5058717b5e35531015ec755d2f7bf4c426579c5dd215b6bac4d401152429570e982f8d07e59d025e4afb9f5f94ea38934e21ad5463a2aa03f4364098882e64e7f15c658e69c8115ea16ce8338eff730518ad564052e34a452ffe05a55786d9efb3f1d0d305b0f14f95d18170b9d3ec8a028f480f020405f95429c3cb153164fe86b85ae166efe24909b0a8f1cfefeddcac5c0325261435c47eca6666868d9cb042c06193a560728ea3b7d03932a3a3f5cfe5ca6050d39d23a930676ba9ff4b0198d719edb2a1f8d71cec4d47d0af0bd4a0b25f10240d4571f15593e0a3ec09ed79ed2bd646bba3a039162a8d13f8e98f10692246dd1125df85a4dee37037b58a34551663676b566a3c5a0f4aef94aff567ca15d70a80c899122a83e60a9c69df6c246e14cdab35d06c499072a978f61a955d7d5dcb5eb231925da67c5c94eaabd26b3dbbe2fac01e82a8aa8dabd45afa8b4747dbd4ac74b04e155f74f15dc0c22fc5f1d8fef64c5fabbe2f9748ec3ef9a5895ec2b93caf2a8ed20546d5d9e0ab424bcc2f3a4ec33551d94f829045584e3f2a694215b0b7e45a895e6e0180b5e23b9764cbfd85b28134b8d19b9aa34b6f1432eb554bf7a953366fd2062e9f0fb6af33abd482c43fb8c58e1c937cc16543b1d8fa0ef01ae885b26e6dbc951f3e2a6fc2222da4c93871050f4a3e8f72fc4869fc91ef7d8304726e492ffaae1033f6667d61bd247ed5de2d988a205e97f2c268d25526916894485f8232a5a6929dbec0a4753599d95291606cdd1396d0d3893c341b2ed40a3cdc2f8927361614fc0d6bce69edead0d9e1eb7e03f1c10a44648e6d8323933183aa0e45d059e8c867b2e24480541819c2e84bb20fd8e1f48e017f7d6f416cbbaf198a4a80fb9da1320adf347eae3651a41746f0430c36a1ea11d235f484c545978c5866be9cfa29533c1db294cf9cb0212c6eb89ad4fb15e5c088c7b2b306cb2048b58acb5c21b1103e20073b3a39848361d0fa5b15a841e77bad8014b36a3c17c6de9e62cb27c6aaf18904c193ee65f804a0493bcbd9687fe9c4cea74c635234bc39186cace2100f5d8a50e3fba178dad039c4c114844a2b083e25f82aaab6919e327531e2ef5b16aeb4d5d56c497333df67243398fd3ce99bd64c1225382aad28c540bfe7d5d8684aa2f2b92f16d0ad51ab3ce25d055d8e63cb941803c1e0fede60de2333601cdb8605bd869e399937d1e3d70db937e5cf350d524462c4a8f8620378fa7e7432c8ec7a52c7c6163178c342043a9d8e7607fd2ceb6bc2b461c824e93dad71a5abb306eb9521b9ac2bcdf6197a283e87270ff8bb7f8f9b450825dcdd9bb026bd9b6041cdf49f4188694baa80ecbac272ccebd5512a4a7563028bdae1b6b50a444143f5ee2bdf02b1b0c781ea4ca940d582ad81dbb9310eae40aad2eb9892ceae0c11a565f1e87506be196ff1725a84e358beefa93f0755d13f25831f80e9e78ba7944d42fa3687be8f2f3a942d8b3db83b3c703f8e2d16db837346ad7e26c1ccf472bc392147c93e39acb4154cf54a000955aebd75f8dfc6b9465a14228778302f1e9aa243e6fdfb4d3cf3319994f632dbd7ffb7d4418243532c9be6d925180be3b004d68baf8f69316fc6c786a874f7b3170fad422763bc15a39b4898685dc7670b3ab0e6194512e24a299128c86896a59ae68f24223c6e8e61c975d2000a7a561c8c37a10b0656fd05c64a0387f54093c9a2786361326a741cf55922158c92f8a732ea8c62031803c04f8ee3e3ea7ab4087982c0c19d414ebd4308e3853fc5a0db7da7a8910bd256bbdc77d17720dd882c8f15ea2bee94002c1c09f70538d6f0b4512f19f49c2150881934d3bc4d96337c1dba3ef19619a3339c3c29b766d24ad9f728bc17cc892a933682ab2f7b78d2ebc19f3cf7da47f1e7dee47eb602e4d4bc7d2b9628704d8a6b63e560010d60cd9e1359ab681c8d74e965c515d9d9456f1362eadc12cafb03fc9a028059b3391869039a550ed624571178849eb1921db4fd4be3a68a11791a8bc1fa4cc2000e20d9e50b88b4baa3371e35c76b9971b426bda19080502dac724d86d28a6c227ab156f3c38f4f29b2b1516a31f00aa19b9c4f0d138fd7fa3f0dcca39de919dcf10b9d2aca3d3a023126e62b9b34bfc7f302980caa6182926a43b6be8ded0aa454e041310f2e3d991f3f344e240ce8a8939f770b8bc3784df042f99394194d501e369d9e5f6b3d3f72fe6ecd093f562bdcf246e9e8bde19b1be1e9baafa3f2dd76a5ec0d4fb9a8c611ab951239ea8d646bb8dcd570fe493c3896d18841ca4101df815e0d44ad3f026567ecd732d547e1f0d54b57038e08a05f2e4f93d927de609f7a1da3a50264300811f90549b0a0dcf719dfa4ae1a3194c9be9ccc1a181fc9a0bd35979da306a23412a241ebdb4361561e6eaceb4e65464cc757171995712de700f1d8cb0741d5d96749ea17d24ee0f37e4bd8b3bb430c15bb74145efefdceb135745501f047db8d0591b39b9da5f6bf36e5bdcf7da0707a7f33865d16683d1a8a64e6252fbbd5c4a8dbd074e99390f75028ab47e70fee050f8a3828a111cf3bdec776db1b05be30917f078f5479476415112130f00a376882596145eaaef74d637834a2523b497cd48bc4a3debf4ba3908041c6bbe0bf0ddeb688a85cca38a23718e74878634e2b56d4ae1b22b9f258b0b9bb03b980769f6c4424b7e8a859f62a4b20394e924b32b2f4b6f825165824e220abdc2a519e65e90b568c78a14f90eedaaf18113a8441188f54791cb283bb6b9dcc8ec7a815e5b61b86b00dcac581c1c3964352ca64fb0eeda88145205b3989f01298b7f084dedb54f9be65991bdfdccb0a089ac856ef8fe2231e4b2d4420b4807d5bc7ed8c145dafdaa2080e8ba8abfcdd0f51f806f740f6f298d2c22cbc397a77047becaeff7ea1aa11036e7626b11670ef853f05de3c7fa0a60315848332a44f61f81f9ab1ef4df679ab703461a2d6f96f3d2ef93921a80361ce9b81890395758a669f994a0619cfb04097cc7530393659b24052a4eff8999296884a1a5faa37427521922c12f5e20533e72fb401c341ec5c7e3dbe61062909658db86309168b4d3b62a6d85aa8beeb71518360ca21aa073e7cc4c5e3be711e29737f486ac94002a7e082cbd2b1daa8cbb666ee4e40d60d292c76cdd9dc3b8061999bd9250d6fe3eac869ee872e2e3948a3798992047024aaecdc171202fc11aab2e9d02e5d6c54388c48c6f3884c54cca31101e849ec8ca42266939d187cf290107a93a45b1672e403d1ea1e483ed48ffd96c2f13618e1f8897905c4ca6c45572dedfb0c1f6a33944068d26e8e308da12a93ac0cbc258420786b9b44b96931e4ad397056a8495e9bb9deeca0b127c2b0337357213bd72c23f61a9552654cb96b82aab80e6e2467c8bfa57725a360153450a26627f0b6b0019d3274d986dd4bdca77c2f3952d3e8761d9e8323c0c56a5ff139a1683c3d42b586c019eaf3a8d7459c604590e89c40891af37b5e8510cff8ec3673899877e6a0315ed693a328eeacfad3054031ba2b9833614fa9f352fefb115dea6d33c7792aa6354a64381e8973f8452183d79092fd466e4e4d335d08a45a5dc21762df3625cfb1bef82ae4cc7e313cde067828d48f7cccbca300c66b5b971847ebf0e3101387e0657bfdbb42d9d509356d8c9d43414c1b819edc4d0ce3ff5f6ff42639781685bbd6936e3d55c117d053ce36f369dbe789244f96e0fc13827d7503d461d70db4e5c87d62b2f456bb1518de762333626fcbd92ccc8c06a3ecaa264517c89a75a1ed202fa38dafa735ad159a93240195d9668f48cb01d2c93b94a6ee3ea97845fbc7f9575788c6cb63a951ddbb313b2991b77779c6885a4aff6045730d994d6a5a88eb177fb248f5bd6fd50f969827911662c39ae113f7d62b6548f6be2bcc607b80f83b644b86854ec147d11e1cfa80a23ef2b57888354c78b2e94233ffa90bbdb3e188bc0755a8b4ef6139c6d3339777f4ecb5fff328e2cdf7515ba55d4b2fe22532501acfeb3d6f104c227f7a094f83b203727a093b4f71b935041b54d69db609f280dfbdd5172775806a2df8f6e5c2041cf1e5373e0ea33addec093664b18eca09e5ed2940636242c6b1ad57d1d0eb6ffd151007be2bbfd9555f80061b7b2b538cd155d8548452132a649f40241519586918944e0b3d12917d819f8c85bbff68b2d7b8fe8a4a4f61bcdb69dfb4c4d7e6d8cea5e5d8be5779a7f8fc90172b6aa0ccec25c12272d4a669f3e52b4fda446264d4c77c8537c14306b565d5cc952b60f76532335b413d42bcfea5067c21df6e936f2fc1cc38ace8f8f2a1dcd2f0b35b636430698eb4459bfe6c6ae0f41c3dda2bf210f3f3988cc18bb8bf27c05dcf81f7c420675b1e71a4ecf1491db1ec1af3182c41d8d29a9eadf356d2235755fa738d4689819b0174c9a006a7b332a7cf75eec3ae1545d93a6953ade0401d6dc848ab7485014c39606e26b8a393ef295850d3ffe576e4f11bd54bcd1cb717dc45680007ff06f2a5798d6ea356e042bc441bf70eda52d8723fff2431b3473c6ee1e9b0643b2fa93956bc181468f514e0a442b5cdf7d360b36b3e18da4d015400949cd6c1f3be96cd404dff242623e80580f23281e23fda38e0ae76209fc9581cdef235f0a827ce1ded052ea3ee4ba17fb4e58d29506ee554edba25fdb1479bcdf3a2f905bace9efb21159e94a80ec5ada261fd94880bb2ea9d859f4c6e99b06d36a6e1e1671c2a0b483423c0c1199ff66ca3bfed23b59c66168494d61ad070489af33909ba1deed3fbf95bec799cd679f4ff05ce9567698214e95409f9d1eec15d28332dd449aba8ebe4fb10b815182926d829dceb09a2e83cea8489d0ae82af49406f6afc31a2d15e0bf39ee59f9fb2d453b92ce6f695a7999237911225d0c1a4b76abeab7b00ad657fbf9121195815327c5e6a4f36c61d360684ace31a0ef575bea2f191393697d13bac3f9213232654192a0e52767c3d5e4ccb8fa753f629809a18d2c0bc89c08f757d8ff39fcbf7fde948f362e3ef6c62d27ec585e702149e1c54fa2eacbbdd0f8250e9ea895d20ce13c43105e7cea93a6c185fde099bc84dd5a5c777be53f12da20a9fea1df6a238dce44b4a4c3fd46c860b33755dc5ecea68a06a5e4372805b0e837ea66ce1bc16b8f791a6e1e84185b5b48f3e3736d73fc043c118ceba9dacd5e9b384b100b1944170c52ad0f19e8e6c3f1fcea7d77e99db2ad38386153ad36412711b47026e780739058ca95bd919efeb95dcd980b086c7ecf61bc3a7f37d53711a1c548354f7380235d0dbee9f2bd5cdde78af3d84d1c31a003bbd0b1ab5faa933ef0dfaeb6244804c59486d562d8d5884124c5881f29a70b3c879f94b5c515ebb317858ff66e7a6e5ca12aaf618cce503bc51b7f42c87d6bc4a79ef45f9eaa1b97b8f94c0558144ce7b2b3303595849cf5bddc205600a46bd52d7170c9e4b2e91394f8fa93701d4301c8e108da7d9479919adbf74782fbeb389d6704e905fa1c2715a65e8fd85fb3e585c57bc7630566b0bbb9f0692cf424df2f861cc6d8160a231c3bcfa6f95f8f88f9c4902b1cb26d910b70364dd28c33c4fa48741662048ffcd93a65143bdb2404cd2ec43618e0f7a0126525ef6064a29b509a365b41f508c1179414b54eae223de27b00952f212bc4bcb383f412fb6da008e74c6cfbcb1ce2ffebd2144eec1ecb49f0bc2ca7c5ef10d82b3fbf17c6b51709a413a3444d015702e474c3bf9189ddac8a41f65c1d9995137fc832e18b8074a16ba03709e6d9a55e5d62b11620865311cb2518b10b67df3ba74f8aae4a458aac0fa89665350818806e5e67bae0d2257bd7439d6bcb341e7068296302bc370404975802d472800e60ef6d769a28b832257a230b6b698b0871ab718df804537396d830d3b497fb74837632d9da1dd55cbc7c237d6c0d9759814523bf72df261d5528e85a57718427c2c61c84d89243263326d4a063d3facf87a4cf2d1abf17f22a6e86c8becef80b7c37c22eabf7069191e4db74c21019fb65a6ab9040c9fdf54c5435bd97119e7b394f16c7218dd215bb39fa3e91a4e60e41b3f6de61d512c9956162aef7d9914e09c1c0698e6109cdff1c49b0e78d1a7c0f6ae0829741059d64d021002664bdf87e178117246aa46cef1d1ea6a6d30b2cc69eb5b340fbf992cffcfd6a9bc6a1e5223065cf6b9855ef4d65cdb5713a27c8416c005deb354299faa23a39803f2679203f0cb1182f3fdce5c204e019d34cbae48ef4d3c87c744dbb7df6f0557e0b742473be4a0ecec879562119c080784bbcb6519bc0f1c043ab1f72e25af7ef93d42f92920929caf7f58b5f716c6adbfaebaca819e30835d520b057c5d49c017a953d264a4570f3c3459f2aeda0632243dd39e09d98667d70e593f3a7507fa4444efef656dae572ad26c568894f79e09d6fa340a68a7ae217b1d30186d3bae3e51fb51657e49ab0f3162c9c3e2a584687fc2982764b33a9cf9d972b4ee6fe798780f4e3573a0b1fafe5c6be1517dffeb20cb43f13ef230145c0292bdcb1a776c84e4f76e55454418162facad21e455869a4085e7f1217e9f95acb8e91d1e9c738e960eef9ec81c501d1a93f57a8c6778de89b19c6828ae20fe99dd84fd5980e59b59c25d135ebe0d22bcc786aa424316073457c7545f01004eb7a87fd2a8c268534426eacb5cbc31bcb01edb78b19d9d24e14f07830c5567797c3c6f89be83c1b15a0c54cd1c450bea8f9fc785ee6d69b5696256024b49f59fa1281a04f274dddc82d99c714b90fb2c7dcdf43bfdc534c29a259ee5d37106811cda90d51c95322d14134912f95164a21ed04899fa0ca3ef34fb22c0bc257031c24114b95d8377198415f4dc03f8712a53814b2c12e50b4a4e93f530e577f9330d2b79f85b1d07cf97045b396cee83ad14604f5053bb8f31f7a8d5044425639896fdfe431d9ae6eb0a6b1520ad4642fb0b939cece0772ed46cde39a6e7d761cd1561eed22b46140f8dd7fbbd3727015bee0fc73ee739f88e9dc69c21f113b3ebaf9a0b46aff7a2837dc01439cb8acc2001d465115623dc88132c07af38772797dfa436a1fa18dfe169472acae1232af48ff8bf9c62a2cc99000a6218fae1024ddee92018474f80ea0dedb395f26d5357eb7ec52e08d56132cc5f1abee2ae49c3dd8de9b026cae09fbc8580931f76d2ca50f4d4a093c9a987d99a3a6f85801514fedfecb53808b72720d2a76632d8949be4ed855d79883a99cf6019c4b90d781fe35cfef9fc4305ead89d413de7c195b0eca3d4ec29565ec7e5980e8acb87d48f861b197a684f8e8d81d4e08a9f1e6071b84bc49f93f241128964ac8cb7942f4652b5e707b7326f13a08fe3ece6add05f4187932e6e717446bae291a23bc8599a262c3ab694a06cbeea4bc1c7fc5ec69280050328af8f9657fa956a8505e29e3e855779dd54786aa8fc5e0009e89cb6123d6a5db47d4b60b56b47b366bd763186c09352fe4a955e8bae1e7a3cd1e537dcc64ba8b5e603d89bcef5ec28f7dbaa617d6c6da72b0e4686e667b6e7769947bf7619543945fb63e1f3bf532151eb1209609945538dc194ae08e3c664dfaf4bfbb571989fd1f4a2e20336be97c09b1b95ba349642e89eef528a9c5a32c7d6e2160a47650358ad1c78c242392a0baf5ec992fcf1a0fd01425b1f0dbceff729ecea1d94f765d3e0eee8912fe0de24dcbf4066658be9faf30abcdb9644201bba52dde91e682ee1009961c9fc845f639540ea5bab7e3b284f9c5ea1f730ed975b3a90dcc99bae85b58efff059fad3fcd426e7a6aac7b36c6d4e36099202baa4fecbb306457ec4c6ed41c08eacee38eb0872dae9a4e83107f966323fdaa27754b840594a139d5c461f474093dad158921c882c187d0c556994840a5693902d443cfb49d071bc017ac03250b1384ef7f390a1a509f0250c97f4e813292b6116f34719026b3402957b45f1fa0109ec07cd3a8b558e2bc4c3ab3c8fa960ccf95da1295a024c3b4b9dc43263b1f3fcc285fa3a8773e99bb9fac6075be1ed3cbdcee549b6ec9a6f2b62d98c8e25dc3bf5a47dff9c323a6d8e1babb6c6e2f771463fce79647ad6f02781ea59e676af32dc9a80ce29b8412276eb444b1240ea241aeb01013d336f6a2fb440dce3cdaae2aad92289a27aaa4d416bff4c30f96628a18b5da73c5b2b5523ee9b7bcf3eef8078c2d20e53ce0fc73306af03bfc32fd4f86c99b7a8c82bd5f44c950c0ac7b7a230236fd5682256b4cf08383a81b77dd21f4020df283817ad27aa00db68fdb92e20cdea18c196d78c4a7bae1f3b656b68e2ada8730a10753f4e5683651fadd4ad405c2ba90f9d6c3acd4b5a45d94709c93599a2d7b4ed9fe4c172f71a4d06a12b13eceeb28636d6e1efdb4965aea9fdaa2eda2616040b28360a80db089d81f7ce8bb69be40b4a8d3a91b168257c58328635653688269f2b9ee73e4c75eb3a53961ecbce216288eb838cbe796c47e4f5a77a3cb5b85b170c9fa8723219eaaf0b341d522ab969d8e08f90e637deb08899c3a5cfeff2a4b23c51cc6ddc733d762d83fcf76fb11259c8d998c02aa5a158f515ff60170a36628b106ae0e71906aa2331459ef9ecb1698f8d6eb6f5536ad1cb212961c73aaf8fd6a0219b2fcf21af30f83dda939444d4eb00bbdf9a528b728d30fd93f3aa6bb0e82695b2e832c86991d5dc3d063851ce66470f08f82a583d80ca3b189b9af854774af79a4e292a8cf278c3ef0e029c4015acd84cd58abb57bd21c30bb7181a8e67a10571b6df56ee5bece2a15551fcac82e1a4b1b242cb5533c82fd2b95a472185f51f6909ef86a8cb0635f779eb30bfcf35add8c29ec5cf51ecd5a5804bac78fccefedab342455e126121e6f3d04f90ca03b1068350feadc55bab6d9a4f67f0e358cd8ea8dc2db150610140cf9a85f58623677dddd037ac55cab446f02a45246f71305add67e6682c20248ac737fc3d130e366e4aa0000dbe313796e2522ab4a4e8aef5453597882729849f0d969198509db0ba5476d41697a730fbdf2d316cb5f6f0b00a8b9fe52e09486d70a39c9713773a0dcd21a5ccd69bb40ff66b464ccaac3517f9069edde100ea77d12280bd5e84e465cac66b72a7f9d32a897e688cbd4374cf7ec9356d56721536f78618f97986c39e2bebc6415d332229cf7c206d1c587018797cc1092ddca5228affd7986b551b30cba34dd78b20cf9e49736f783f5a009200a0a975b1d7d5f07c486f6e5f5d2729f96f52cdd8b2e0c7f3fb1dc74d1bb46808947a5f542ade28fef5d14e12b76f96d6b6cbbc4f147824a3e42e7e6daf1d52b1cd58cd5209b2ac8a50bced5b00684a65f430d7d3154113f8a710ce032d653a14dee457375617dc404666b895890a2bc0ad9b35d3f0bb94567a5f1c752a13d71c923872ae2642289912a122dac2a941c7e8e943e1f361b11b9c250359835df846ec897fa65bbdd2a8505848dc4857404e38a4b399f46d684908c6c044b0298f3cad1ac053e3e8627f08468a7be62c99c376f8937b6cd875adc589b99a1b14aaa2760e9f76d06b876fc1a9c7e7bd03dc01d073a0cfbd5b402e1cc41d545fbc98b4897c56b562f3ccb9d1b9f077f2e015824beb2080166a7e679e71fded9c9d38e6ee5c069e7b8e10d28ecb936790e4f5518bf1a71df0306ee8f05eb09bebc438a1e8e75569928848610d4b3e1d2e999dc93d4e26da322435205dcc1deb09f87971e6c89600d6b383628e4c95ae1670976a408b081b457d46fab1f981137a9b7db373f23ca4bab203fa9287846857886f817941507405acbcb8926ccf5275ee26c6ab7b58e700d94939bfdf82558e664d8a9e1b4ae64fcf761204eb9fd7c6e113be1ce0cc0c9674e33716dfa9bf73dc309ad72eba811a194762c5306b0b09a17cce823209a8bbf958fe4a905232837c28cbd593ad77d3ee5cb770c098090122f899f8377bf2e33a969e95368661b3cd66232855a7782a48213caa2ece4374badf4192b164441331bd62f09b93236cbc637ffdfa663c270d2678fdeb676a8abac8f6ae6fec7d60718c826cf735a43aee3f5a740167d007385bf17730050fa8a5be45c6325f3df5efb757b2fc97195d9d0018089fece805ca7e699d3a2e72a6b042b046243cd337ee247fc6a390b01e7d69c454b5a2658152b946b929728c35d55ba3e7ad3387ac6651623df3698a8f3e1675abec7faa9b54963d53faf7f6391129758ea10f37708877c59e23d83a1e4ed512f47cf7feb2754749d93ed21b3efc78c324f6c3d95eb9fbd197ec38830c7af0a9d52ff78b64493713fa08199e36b585ad97ae24bfca14a103378351fb22b86a56550dd89dcde648de5e7173e25d8b2b32fc5e0250e8dae1116d249b5c0a75abc3697c0f9e9e9b896a45c9ba214d146ad5fe7e666cd71e1479d3885003563982cd40f3d8b91c7d8db9913da3053f0e732b346c0bf413d636e5e538c13534c5c6e79d61e09c672a124e126629a734826e7a2b749c54327dcc5bdb26b6b6056f7a839ae6008dde3a02daf4756fb6c50599a5e4317a4509d26a727acdb8a3e49feaba4937200f661457c448d44e5df27f4fc047e997b01a3225de05baae693458c3b0cd5717bcb1f9985b301ff80ecca8eb1d4e81dc2ca38048dac1837aa4348761246fdeb0640cbc7d927fe942bc9603181877bb5d3ab6661a0d5931bfa1818997970a48e10456d9564557bf16b985d2d18e8917455aaf17f700286b9274560a1df0efb5ccf27cb5845f556bb53c0d497ab8bbd332b428ec3dc96a1d563f60300fe5fd9f9a3f151cc0454f27152e0854f9044318613c65045f6c300404136a598a067bbb5831c4ac0d2262e40bbf9c8390d0003c2dbfe88ca03c88c23f50fb62891d4371a6382fcb9ab9ccaf4f6152f4040f9c1192383790de337c370c91728a62902af612262331838a721463f9a8d45aad31c4e674f1989b820c1f45cf688104d862d7ff0bdf9b035be4e2ca29d60acc0c99b9bbbf0c31d537420e5eccc293e197edc0ddd981bb5af3067165c9554eb5e65b7aa2c243f27f7f41df76d387ccfa0b03c6f88032b739833694544a6803026e3e1d814c4d84568a462ec7aed1eaa7b793bcdd553477f8894a7f77053c8def8bf5069d36d37eb36240247372e51340a416caa2e5c9ca315c85a235bd9264f873b63e96d8514b7beac61b556e5e2f3a5fdee4a08d2d2ea43c4f02c9dfdcdde4fc3b0f2974bc89ab15f22312005560348d7fb994ee6f86dc8d68e09afbc12f053bb277f1647a082c1ac2b0a6f69114c6c4a1ed869034d5e3b9c715618dcd305e4847c8097691d60cd0b71fd8fb68f0f22a4b6bb8d77b68f7b0d8471098e93f1ce2ef3b9f8515b0bae1397602901c56ab076ce2797ccadbf0b7d43f0effefd5a63d127c1d0d2bc244cb22b84f586cc63209bdb565f978ec2af6c7568e48e8e17d2b9bfbe5fae2ecd5339d4a01466f9f80bd634d310e60dbcf9bc730e05d260f6e124e8df7ae22cbff48d09cabc70e6adc64d457d456972f9d460b124f9d08532a26adcf02faa688922266c0abf95ee20d0fb281537ff35248da6116963aad268a7e773243ac190269f1c39104e7b1561a13999007e1121764c82e7c7cddb0ce1a3db4569b1661b9842ea5d530223416d481b9e7ac18cfd5e12ae327c936007214c7b6d1b0ebe8260591722ac3e9b9cde69b99388d09452441bf22738df2e972118f39616c3c90c2fcd72d2e8503251c26ca9ffc4d2eab88fc56cafcf841e13152b134d9d6588ff8236a77f0f934680c3f31fa574c13489b9e56fb9d886b79097fff493ae8cea20308140db96f1375f591476313e612c74283da1f3901d790395a49ad52b7206322fc7d9ccceae3fc89bcebe59de8b435a72fbbb29b66eac43096be843a4aa54aea7d114535dedb38827a20d84b127963cc2f2f4d8dd5ae86f85c7435981ba3a6eadc741c030ef0188dee7fe5a34e144596d6309aee39dd500c529f5786f1cb484f84bed089dbb9c90c9d3b92fd0a456ee3e086f01953f84c5cb55aa036acb36ddf1e42c4caa78d399981154397c3e31bd5f7b44dc3e4f61315a0fd6999e536cd7eb13e70b6624b38a8961f7621798041fcbb351a92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
