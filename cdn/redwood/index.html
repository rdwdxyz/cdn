<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f08db754d2337e54c6f9d5a4c61c7e935a94b7ded0168ae491c629850c6034565da127fa23e1e834ea3da4d603ca58e1783e00338b7d05f32fe3c280e56b2bcbbf180c5908c5495074b3bc3b1ed465b4bdc520f817ac84d2da2a715e6d9bd2286d61ced12db621f8f4d3cc5e5811671b67a326d2a6cdf676ec8419c394bbb7be4dd2c9c1dbf92b608dd6c5a9518e060073db5187f5999b5daff4520563915bcfd30f4ab00b2b35bfe16a35a896e94c241ebd74ca7c0b12a325b2e7011f6d8ace92b26afbdc35b468dc6ae4610da2436c8aab3e59e63f140ac4625a265723c715e465a457510a38f9f1f1ad1c171347c5bef1a3637dd40f7e2dde0556bea0f2bdf084e36cbe7efa58698514e523aa5c8b4b492040f2d073e54fb0a818e7894cea7df04302d3366439b6b17718588b296d7a97e0df1297b88c1d11d7674b35a965f53596cdc737be292318ad082439843a6817bae655b4234f008960c99c1f3825b3f6ddea30395e8e4077bb85b429ce75c83b1673b8bf2d61ee2d4bf2fdbee1f5d5d760af6c76e905cf10c76134775a251a1e8c6d13ea721c26c12c000881ebcbfad97e4cb44b10fb3460726240fdae6a463aab38f03a81da7cc1de8ea25b60a5f175a926ddb96fb5af873d5618bcc1a4081c51ac7a9665b1b1c5761f07c6e53311d6fe50e116f0572ec771aff215474b5f7fe3d9c61ed48d0111fc0c50b87149711ebecea42eb57c0694855a122a4e329bffc5ceeaec2ceeca9fdb4cc19cabf1ed8ef47be2de4aace259ec72881296847cf02f569443164a5cc9c9bc9873e5735e5402c59f52c68159c49431f792d98bf39f87be17b809fbe0f1284e7f842d46eb7feea3bafbab6785e9494c141ed171352f415e38ffd19529aaa13293e674d7462f8642dfc74ff655847449bbafb00150f84ff7a8cb176f46c06fb2bf7c6ac7171b2d13cd5f3d71edfca8352a18339c9aa42ff6513399638633aac8f6b2b16da31ea584a2ce70ba32bebaf76492b27323df5b36d3f56f7bc52adcb0f84d93f70b47713ca06b3ed484aacc9c7da34a79afbe0a34b67521a8da47f0229cd617654e0586591cb695fa46c3c48383b02e3d9a52d9a502e05b2a84ee46398fbb85f9d171662ac50887afcecfb662760b3a9d824c7be7d42a7178811a9eea4ac453120f50a83068b2af294ef8f8e73a4b9a9fcb60d4bec56c9f87a533b2af8b44b7f84b1157e4b6aa1f103fbf9a722f6e6b18308a758687fca1fce374c552e8d088dab45750db8589afb4443663694d1ba9d8eb849f92a7452f2dfa961f13771a022bbf80217671e6ad4e8355cd18037c75b31bfcd8e005c754c446d5ed46c950d1ed52a7e052e4269b80df2083b15316b5b59de5f22fd9d12fd6eee3647880bb3c7a4b595387e4164513800e05ea95c738071d24a6bba23363bb9883d2d6b14cc0ac9da94704afd4d6a9b15a7134c54e1578b309c06a6249fcb449c64c9ad13a87d4a637ac8f963444f0841096b3ab5141edc194e7eb2af2933120283f8ea266e9e2ff98dc475f3f22a022492cdf81ea05b458a91e7640e212023f0dee8b1b7b058d7df2f38d9ae77c2b87315638b4e5236664c0c3e4b8ae38d8ce8d2f377417aef2286d3a9cf0da2f235d2e2e8d5a05347fb4b5e2cc105f65afd42ec1deff0c2a6cf4a24710dc48d19a52f802bf28b329702ad1086bbc1f806d28b9826ea0f0182cbca78018c0c531316c19d29b5fe4c0019effba47bf564a972e39d726eebf42b14b5d620fe4527b4e0d53ca56457bd16d487b73130fe597c5e5d0c0b89b77720ba675a2bde0b571149e55bb99ff8fe9e4010ed7939a992189577dab2edf62555d825b8eb985271c4f259c38343c8def4f951c8c702e002cd7ac60937b6bbb1c1721092ce2cb0cba0fbe98e310d949e9ca10330cbbf32dffdf6fb59ad8fdf7caeb41d5c780c9e7794051a39bce30e778c14e984d337bf0eda1d63c8754e8db15b88e9749aa102f8d652d3abbf3297a4bebf5d9954668ac5bfbc7af7cb18b8ab414bf8656555756a049a8e1200b87d08b0e9081487dec34f6f53be1f1b81da18f8d61330a049f54e71d7ad65a72742a9d321c70198ac0cc2ebddc2f3e06dad3f194ee568e689c07947403c05b87677fe452b18295ef1d35437813aa8a6425482c6a86f79b6b8bee324d2d4c6ed9deff57c797e7bbbf071923678ed2d0a49249e501736af6e7cd528b0abe3387c1d96f53a12b5fcdeacd495221793af0ce9881cdc4980f77d4c874c4dbfe948a9e0a7d79d4641f340ac4f8349bf48a921c10cfbdf7f6e74ce5401058e45a896f39d609185edbd3a8ab8c35bfe447d84020462a00c12c3e3acfe345d0c5f22193c0bc4b880e0ba20da67abbd0f79be99678d60008140cb3897179b228c87c07db77cd78a4d4f290fcf8fef88acdd03b9794949183b8db58a62f1bb96af1db1a7b53c75a63e014ab5d9d41fa71ef7eacc4ad70b580cab02b1456965d39b5fb40cbba13880b5e7c7ef04ec664f395ee825d6dd0833e4827555e04b505a76278d924681249842af90264d72020288585638b3208fb285916554b1ef0ae411ead3d47b0d44a223f872f6c718e2ddee0e18899e2eba72d6eebff185701abc84f2f36411c9e446e47841076de5137704d8b61a6adc6b153c8ecdb790d4ddbfa2f7b7f50461839ffabc796e8f037596ca50ab43e156ab705738d5715306af7c321de197033ad553f6bc4113d287b0a8677559cfc9e5746d505330b027413c15cc1c8f4b756b69b49aee6aecaf9517fff492fe7801561cd1b2cde6e051315eb30a3722e1000d46e4d9875a7582863ea9926ba02c8e738868f2e7521a042a905894e320888951a786e95bb11e99c2bf52010b2e9352d5d16b8491caaf72cc954aca46581daced6c2e1ae87eef3c11caefc83efe2cc19698e82022998cb4003097c0950acec21328d15024d687f544c7c03ecaf4c4de56c36cfedac1ffe925bcac1735b1ffc80eb3200855c48e54e959dcb9ccfaca90012c844409e019f9f80e67dde3c08814ee44421b77433808705371a438ce1d02ed7d168b4d6958c76c9eb9f7c837225483d1c25ea6107a8249f245c2ea93dbf304aec9738dfacb4305ed30701ba78f43521934c1d4a693b22c015220a4703d21df505b972cd693a89cc1d02b6fe7bf247152b7a8ad93b8ad6de0b38084ed25a349abe7ee126223b711f3fc39274c8de9b93288df5fed36f86530cce099eff42e31d26d273d6e1acd8eb27d835a494548b9c4aa418d405a1ee3457092d186d6763beebddf61b40b4f9e318770dbd1527d36fceb926cbbc034f450eec00657a76bc983d5f2f90736aabd5c2b3039ec2de82039658042975f5245e4cc6b5ae84d3945352a6ea1e903a57795675df74c91940f31f6a54188a7347a7450bf7c5c65b0cb1506560572e1a8beb5f0745898df15e46aa9d8b5a9013c02ce5da0d6bdd46ed839282206fe83a7cd31fe12a38030d9bf34664f72e15e83c63803b18186459619a5d3b0d37882622e67d673b91340a4372e8fe97523c34634a7f9f5c5c9d273085d0e91125204955c6701959d0fdc12a922d66699a2a89eb4c4c73516601cb2e031de3bd8f050a702fb9e7b2bb57654f27fd0b813500d7bdcb6bda9a0f9025744eb0ea3f3dfd7349add943f185556b62f100e5c446e9fd87e8cfcf13840127f1fa4f4079f12b22940381836dfe956b364d498433cd834bb36f9b5aea65bd1e64986f5a7955c762cba1cb68679d3f1ee94ed7555ca3dc510f020b7790893fae952797296781c9d73a21adb611ec9418b54db0da636ccfaa04060bf8fcea79214f82db2eabc295b772a6a9b512eac6f95fac0becdd58df7a81bcb0cfffba417246026fb59b84d250662cdccd2aa595e826ca25f82871617d2c563a7f80a80648549fa8be29e8f1869c77df814a1dd0b834ed21a240c53edd55ff6c93adad6f5cc2cf8185ebd79ea833b64ca2b581768f2536d80f2218827eb813cd6f0577af316873c29e81bbf49d447ff49287542a494add0266324680463d22ca34778b17d3a0a4d5b1a08e9e86b2af896b069abe563f25f7e63dd44bc850113b9cc22be2f4bb3c38be0c090e4c0816dbe9b99ebe02540e20fb800255b1546d7da97de6d3e767b9e01c4c09f0f4c0610e61a4391591af11fddf3eb3efadcaee586c15cbe3ed946444668522aff16895f545c5666fe74de2869b62373e5c93b6d2cfa615c2a66c20bd3771d905e7e00a18d8234eaf180090100c123061aaaa2c46d2358612f04e4b181bccd78ca17f21ccb6d3684f7e99d22a509f159aed80197671a3b1a6215ce6cd3da8edd7e8ba6823772f78b1720b7a4725f7bdf928f7fe0adc1fb0f8d8462a69aaed650bf874a94ffa82482a9e3d5a4212e372e833c1f867ce1351e9d2b775656d8d15e5aa26766b6a168acad2258a0b25d1da50ff7c19bd1ab96c4c7e0c45a70c4d758cb5e63fccce5cf0d42abb8ea5d404de5727e116ff48a8a526234376d724c5572db821c57b96980f406355271f92bd2c6baec0e0d84694b1c5776966326779c788c0215826d548b6af37ddf66c28e3f8ab2d0436bd1ae57b679c0e4f4555a35f7881e3a8bbf99e683f8849602948ba70792c8751b6eb22bc464706a1ae811d9e8087e3525ad5e99e28615057dbb23f04e2174e1cb19bb2fe0871ebe55db48ab4274745817a95ab458eb02ea96e9667b28229595e687d62643de4b72b95a7fcb6ad29e4ab2f76e76e45f86883d26c30387c4486a51ef862d4f4ef66e56f027bdf568bb215778b6da287831172e41d5bd141ad545adafb8841fc2667c5897e83a7504a723cfa6d6a3550286647750c4d674d4239ec3d32eaeb4b84edd2139db8a7cabd5eff8bd8ed611f23f837a4552e2051c3608e9c036f53a308b56a7d87da9bad5060571a4c9386f4fa1f47742dfb8dde6d6953167722b4db2cffa94c1bf586e7532cbc01f51f3b9b097f8dc510ff86fcc68364729f2c56c444f0b1efd4b465ffc47229c4c96eb51b6f00ff3b142b9c7bd08ed56ac87a9549d40982b7b9b07b62e5413ac1a1b8a84d4c5e29f2cf9eae326c7e76121064911a9961ecaf5a1af6e7e2f334d1eca4907621a967ab4d5df222fcb2d6b61c034f21384aa6fbb14719f4a65259c473d05601e89f92fd0cd31e400e6ced5cd1b01ce1b6fb97db8bbe9825c49b1361b99134e536731762b52fd929e60e3f69684e3e74a16b58f289aa70020e317f6187f658dabfe2c2a2e8f4fe9e1b64c9e81c19e027b99566f0ccf9cea63c5213a94a60d49bc393156a6082021eac6d0b12c8300ef5b48c76be2169c818767c23098b113c3be36c1e7b1f9118775b972f8eddc2451b9f0250bd84317ada6c32eadbb4e43a14af2ec5c9bc97fc61b86f19e81860755e1a97406acbcdb0e4220c0e5b7e1c588f5005699b3e2d170e6b8cdfbd708f2bda03eb3f515ef2d130e5124b7eb02e86a68b8c40b985a3d6046fe8a43cc1743548f8587669276963085575d9923f164370af3db4c3636a2e1f90bceb76229a79ce75332c859e8f3f4984ca3701aa642108ff8b281fc1cc8b23a54352bf742c665cd2b2078f4bce63175fe38f00ec6df75f44a8295d698b1f31f89b79875eb6029a87c9845883b4014809210d1e7ba2154ebbaa104e2dfd61efc89f0b05fc630e22d86df2457cf3ee29c66675f00e14dc594404ab66af61fbe93dca4310e49028c7dc4727e2b99a53c70feb1aec48b12c74acd27b3fc2a478c45d0cf5cfb54517e455cdb441210c46364943b463c85c2c506b51e62854fa653e73920882922d873e30250f8b6f97ef40b5218456b29be95264964cda18e0a59eb055143ab773cbbb3731606e9cda954a3c3b9d2cd52274f4793819e05219cf0b7409bd7f0c12ba301f88d817a7f17f18308903c4fc8cd9d19cca3fbba2c5f3780f5e585b7b9a899cd24ba4089237bc36bf6fa02ac42494616ea6de86e7159f5ae94cfbdc19ed825d11e930f6d0a3259a5302388a514236c1df49daa02570f1e8e43b4ddbcf853e284452f8cb71afc702f3d2cc15666b1d794a3aaa03efb35353a4db23de93a22a5b0deb8830b511802b136f7777e2fce390b2325567d1533a9923c3caa68e40580244e124a871451e5c5817ea10d087c7b3007f8729edca63a7f6a394de57aad5da63a4de2293f49c11059b1075b6d019270397f444bfaf2e916170a6e101fdae48fd306d756d1339e2349db43ccabc2140d706c3fccaef898c3224ff075b17edd5159d3b6cd307e080660e1ee5ab268afb23d31d2dd39068c7868f5b2c7b0c9b56b04fd8cc18dcc0f4e391d700daa83a45b3686f3dcc7af3022729d1cfbb7a2edd0222c0209300b7a9fd01d5fc19605ec018c3f4003faf468e0ae8f31439cb68282245f624b52f63e90321deedd6f12b46e5f363671e60799803a0751e6fe35eab27b96720b249158e31d67657b1b6e01deaee9ed883c50b871711c356deb74ea01cb3b003fcd9f7d59305033e56a19a39d36241df51626e455c09fe97726bd8c6de3fc716eeb5d363d036ff70a3d358f9e9ac7d19ebaf296b8a39a7227d48f5e87901527cd12d10b06e464d1334490fc2fa99c15398de782904a9027112eddad2fabcd4d8ac26d187f782001c0c356d51ec2b167503946cc19b259d14d12d38528c22037668bab4a62f82c70a79c6816eee4e91ba720e24b004f01cac4ae4d668877ed27e84671a1e50be509c57c84e4596658d4e37b22ad4703d07f648a453f6bbb57a24621314b9488347c48a4b0d98e839ba70987c6271fbb1694b787c897091573e01f3c7f8f025c3f8a0c1efd28a35839d54e118f69ee18c46d477ef37a6dcee46b6d682ae92394c823428e18668a1d1514e33f9ed812ed1d6613fef536368d3dad5e0d7630214835fcff16e2d963e9df1b294cf9f2c6a8067bf719ff94027f2cc5a6e239f890ee39c5ff1c06e42d94857f57fc8c6c285f8eaa2f2f2bdcd067591f3d53c4282bb82c94e01013e146fb23a135e442e9f0a707263a67502c97d853234ae72c2a6643bd9af0d54f1798d7b1f76976a8831ead5dbc1499e5935b97ac4f87cf6290f72de0fe8d110a1423a68bf339bf159eda7797aeb8c9bc3576c3a92e6daef473e60a4a0e5d8b4dd07702bdb52d57765467eb06596cc9d932919b81eab7374cf080cecdc8cf40bc72e3b55d5c62e05c1c887a43a68e744ff769b6cb6203ccf12205a190d77b9bd1c05cb5b227871a02eacbd82295e1d10735de58f679dd13aa146efac0ed40596d7d67a52892e69464c24a60643f3f8378931dfd5243a47a55238ec2194966d54611e5f5edbd1a96dbfb717f547d85d4adb513cf05ad90dd13302127f29cbec230b1662625d3bb3b71840be4099f5cf52e3e0cdf8cad28c0311ca38eb7346ac59a444debbfdd4ef453904111846634c406e443dda6b31053a061bc71204c420614ed0106980498bfe6273c497aa4781278a16818f540247a29b6ce0f30c60b183014c7593c19fa5ee6a82b7a957f23aeeb50577dc74687e9f361a605860a8dff11a8154dbce51c5c59b56588e5845f6bd3dfec30ea5c169ed09f74b3465641f080a828ba4e73185a4fb98a93ed09e0ea49abf7b776ac9bb91e7d975dfaab05d5b78d38d440e72ec169c6db6a5e70260775af9739460a8cc3347be7d5a35a5977a4fded9c8d69a89cc0d2ca44b946381ad6823527a1c6e78e736bbf12ee4434e20442566e5c0787aa0a1ae8562dbab06a49c4db142c74063af007e16e788ee22bbfea2ea538345210812f4006c4cdfa90e1bac6b0af51f23c3c980d9d31de75ae4205b42d17307be414adb95ac52dfbbe826fe06a59656dda529b4d8b6f938eafa0a0c54e6f081fcad06e08914b5eb0857673d3473300f29c09a42b1a6692b10e7e68f4bf743bb8464fae6dbd66a626fe826157d40fe4b5d19c8ecedd35b8c55d06b48fb56345560e8fc4478c50c7051ce735842a4c04af88201d178f49751a52234206cc48a1bdbfd1b4afbeaa2e813849c0055a9d28feab6986e47525d5ca6263a965e5bbcc2a4188085529fd12f69b5dfaf7b144e468728d155314640118f6fa3cbf724a936c267fadb3e8ec48eae44a92a7e7f64ad83ea009e046b5a757ed56c3e4139fb791dc4d3c83e684e340a49aea42f0f5123c1a2a739d844cb2c579837b66b1f7ca8b30b4fcc69c6497e8c7e4b2bfce6b0e3ae77719726fddd68f7e8f9f640eda2a3b60b0b31e7a2fb56230a7aa084a4212e673847f81384cdaaec3c21ed259f3b9662025cd44648811019da47130a86e6828fc84d1b0c006d9cc7219ca87c60e663307192e3aed402b66e5cc7dabefb64a58b7f4fbee513209d652987a41def1fa99967ca5c2a9273978f29be627262972ef972828fa8ee47c3b83494154c88a5547c40e73047007510a6b8dfb05aed3caf8ad602cf8a3c388a07b18e2e430b5cd8f711cd13129bb4cc917df19e8e5c1e572d42207332132b419320b7cbfd0cf772663c083a9b6557f8c2a4ac1d331d60dc21637cee1417c54ab38c12ef599a6180e83c0d03b78633cfb0e6e0e99e525da6fc0bc3dfb383f7cd30daf1e0524b321fce28502f95907f7f7e4a8c6b646a13009487e1dd33d14f7495e1bbd5ec724e8859c4f7f5c1985c830fc2f40e0926205aaf77f59eab320a854fda71256c63a135b7093f0ce92059acf20861dc288498b9a0ef1964450b0672d203991db6e66d26309d235647322a12d9e06a1cdf6809647dbb9c9aec74329573618eb9c5e924eea69609988da9199f95a503f5cd90553bf91f813d87632d92e984239769632001422a97895a1b8f598e80c697f2c95a39e0d36c5157cf31a353fc5964d82ba87b92cc945baa8b6f186bb946a251b94842044d4924f5144e297451ebd908daad91a51612a21c5f7ef40114337d9e5003e7d6d723cff1aba57448bdbcbfdb9251cf36ce09507737d01f855fd4ffab1c99c07b5c540e7f2400f20b1cc01afc05ec3b706fe4997d15067cf9e1074a451fde9d009934b88bb07b27562ad1f034d42a46a4f400af8135935e8c15d36c6d6b38dac44a3fff337ae8b181fec233bb73ff9a637f4766d13fa467702a081403de50e2dfe2cbe2396f4bb0708143f3a8e86dbbe35a741b4d7564a6fcc10f85352d784c8d69a55bbef53d5af60f8811fd3e39404829214a74b8619eaf353314971036b9d0854ee6d9390cf12ab181b8ee4b74016696de72d9f346463f7f65e5373f2a46642dc93c260d8048ae793c89044146639f7d62c36f8714fd51505c4cf799bc06f020c82fa887aec53a794226f197ecb1ecdc09a938f78d77f979893e3d4048e09c43faf637562253fc6f36efd66d057b9ad9edf361cb21fa642612eafdbfd7ef950b495a1bf3dbbf15b8fcb53ef903e2b9f73871456fed461df2575365b63277c0a649200541900b685df0d61587d85d1bdc417fae9d88b847567568130675e111adfd3fe4963ad49e256d2489cdd1636cc82342a5d1b3c7c34456e7c4b113a3465686d818bc0c3753e6c786aa5ab72cbfc26096c904d8a6b949d445bbddd365d57afc0c3920bb7fe4aae69ac9531a2a10cd3d66f41c2a2c85388a8c6709ab6c9b6f2787f1c85b096c32a6ca064e9d8bc99ea710bf637fe50d0b59a8eb5e3b31fedb8284f0c001573936ab8f22e413fdd6cac95b9fc50298ae6c996f0e01e803bbec89f8f511ac5580547431ecac937a75782260580bc260ce7d4b9ad8aff94755480eb331a667f956ed9dc7608a5c3384d23af89e3e839cc558d0ad71b46a5e776fb8856c30dff90634fb80fbde936071cbdc08587f5850dd533b75e46a2d2d44bc6623cdc359209e2ad0bf40e56663d1d57fbf81149f1feaaec33d4388a9253a248ebede9e829ba3b8228ebc3ce0d215e09ff7dd637620db68a2cff02010d9b55c8b637803162109fb1ead107e30e1ab2fd3b47632e81ff1b23334b3506873b618797d4791269c78e2a8913921e44a50f58fe5dc266eafbcfacd6977e02ca648962180ecc01b116a3e8b8c8423b66dea7d9b7be9c5db8eae03626f511ad0e6e6764a10333adc15d3b520b4059e103b120abac0131465b685ff98e29e3712a26ce2150f7debf04bdb5f624cb2011eb8d26197fb7b88af74f805a1d0215e771a32583bafe741d2d89f3f84c647449d4802331d4023b37b9ed0940ac79d2b513970128223b352f70fa62ff9204ce228f0705283955b7dd1b7e0d75b96a4082ec4ef057d2463d4a2bbe1a1ed0bf99ab06d677a37334ada3ce605b2bf4b7f385cd1ffb699161994599a20289d26911abd1db241e53547acc8c79d4cbec8de2deb9270c45e38dde5082b040ffcbbd4fe3bdde55df332523ab1dbc52b79ec2874d2d2d6d9b50887c50b9ff717ee2d0dc118acee6e863b8ada478e9e28dcadfb523855b6f50e952a82b9623e257dc9636bed76fc2a1b8de2d7e434b8ca62763d575f21c31c9eb14b9002b79f633478f016e2f38a48cc1bd5dfcf3951737424aac15b44c087338595d3f4dd1f137b619fb2706e5f25cfd2618d53bc94fffe70cb71045911165e757235c6b8a6f3eccf8b8e5260040d630af133d9c5b2be1fa5cdae886e0896e72006d2f5e2c770fb53403c20c81f1a00cb06dd4ccffb644efc63cd22811ce31b58073e53471db8e5786a5873496fe0f7d13eb5f0202856dd63890c0ed1f07c702e459b63e0c6cd4a6941a8624fa26a7fa39dd1ed11d2c6704c3ca818725e5636a51a38944f5072a9986d291193541c3d043293d7b6a6316e3f90e56cefe46dbce663f35e4d69c40e984d239ca8170fc050ea6a9367006f2183b68ea9aa0b7312b97a501727c20b8bf31ac7a8676354db7239373b8d85db480835706f740eee6097a399b93aa63346fb4a4a743c3763c13b27b12b10a0bed242b22de29e5fb1399c9dc4b29a05d15de7e72e4d0be59fbfdb57c4afb38aa84d3e86e076e6e7b4ee853151ebf89f75627c08363252a9eeaeedbedc08a04791f879ee4263d0f5d1e1c439f8c7b0ef63b3e5d7e33d9c1d4bedf40ffc465ee3b99e8e2297219b7ed9b2b918324e0afe5358824dc395f8a1687253d1488294cc42b2a38b9e310c8c88dd14e6839216bc2352e0dcad94215729542d4fcd07d8b5da8903e0773f11e637807d32a0985d875d0a815d71eeaaf65b13ad2187374873569d85988f2f81680e47891ce6a43c9f1b1c05c394bd031145b15b0864a77e1ee58c5928c3ee3f7d1dd78b4124971de4d58ef9f7a5008a2be316656fb5950c42a2fdf115d94119786f05aa03757e7a0c9266230e32f4b3368a89026ecfb612713bcfc113ed2710244ed8442daf50823c4f4b32cfe77cf2034a78b70e8fa17d575289e2fc93d4d2c11220912ca7244f2275be3c0c1acd77c5cb5f67dd660024d8c43f3dc8bf90d45b0e3f406833da331d4e8cfd2848d2256ee2f6050ad2cb3abe45769bfde3c836e6050112c1018f707e611fec7af5dbffea20583beb174a3e7f86cd67e372f65d48dc486b054cce0d96ea0f059667764bc3762b59abc536a39dd29dfa77595bf7b2e59565e649a9476c57b06d1404ad071ce8b4b99d1cf166a75ac84fb2603c1e4f323613b5a6db96565c04852b983c50e2ebca781aec5650736b277295c712a3919637bb9aef3176fba32b853449f04750dc61aca1f82729b3267db531ceccbceb8a7d1e57658197b83b7c98ae248ae491b9b6b77f7e3261ce44597893b5f81affd18893df4d8d58ea70db0d5a40fb8f8b976e06106663fb0b153405bcac3932d542d7b88ed5e2dd945b221ff059f9d6768193527619699a3f51222c8d3a0a87aff92e0443917a02da31623169a050146c69c2e02fbbb99706d6d7dbad88387cbb9bf82df3edf9f64ea67f00a4fb0917fab1ed98e729f8d0940a13dcebf6e3fbb8c0ace426f757040a68b4935fff774b545c0c7b886b3a29d758afa10f89d86c84c8162f1157b4b74341e51ff126bf6bcda5b3983d47724700d6b9adb501357655dc1de84c4945eb4c5bd99b231ef0758e73925e73eed24b40a61e970c22252aedecc1bc12391cf10952d7a90e3d317777a42432011b0385e17b6fd3dd5f6ecf29dd1eda31076846e9abb69a350316780ebde076383212f65770a3fbdbfb18b2fe2dbc9c619a9d819381fc7f293ce47b7ebc51f76223b5774a50223b93e042601c82144ae554ac762de133b412d70f25b6f7d541540fe326b6e20f3dd7742bc836356f1e7618a662ecbd2b9fc24f5039f0cffefccfe0eaf90fce7d6665f83d4c85b8f157c2809ed8f06ed4c24855926e536d5dcf4a0d60606e29ebad8d6bb28541ad083f0832ef3b42007d0d4579334fa878aa3ecb09aefabf3b49a31f394b3a8cfe8226eda0506c97a5b0c570654b6968888654b2adf789ee8157d47eac6693d60c76f5f455885d0a64192f6acd60efc83daf26d5815ca28363fbc2c9f74075498a0c3f9d195ce7f375e28e1230019c2a406d6d9d52708523deb4fa4ce11b94ec5cbabb92f6df07e5136a0ccbe091f523b8fe5663c32161dd757db4bbe685db7a99fef1a8f406af3a789348d763f9eceefae2592b7756b00afa59de7930ff4a4207fb5d060dcf46a1e0140cf139fa357e89eaa7fb4078937677a2ca80ac422b0479d262ef35711f3fd7904768f8d07c887063bcad36c4ae6670a654c72fcdeae21f8135530591539df13730bb9fcf2eaa613ad9aebdfb91046b1a482edc4d638403ccf0399e949805e8537ca9282bb15f4e50178d44a82566236d663cad5b18c60539d376c9e17d7cd8c2e18630045c972e978e74d853d897b8de228edd18685f8f9569d2a284c7afe4198681e672940d608dee6fde00377391a9c3e01137e7ee4ba016385a1e259c642236e4967e1e28c13b61ee2c2827cfb4a8284878fdb34721937951fc607042e91601f89cdf1ae8b13b3c32ce3490a549224317d01c006ad2cb087a8bfd436ab40d1e8dff4e6789a8de8d7a16031ea1597e7b7aec79bffba239aa740e67e3d56c4a5462ed3d5d180d7f19bbb376794dd2636fe663be845d3c5eed341fd6e45cd16a8777e7f03d5e03538609101b30b371b4b235ff9274101011974ac86e046bb7e9c133e7be584a9b5ab9385fd5fd0787d4e616ecc9a3150ca013f29dca2bf13f3ba57a042570fbf9c57f636890225d7e155537acbfe9666fec4c98b2ab43120e75bc3cb9eb0a04c2a07c29478addc2ce43b0f7874616ebc0d24af250daa42fc777424047db32f860504567cb302efac441d6f47b54c3e4cd1eb40fb58a7e9170f3a9629dfa8c6b53c1f57b32707b54ab0a4dcc574ff1f654fe63212b9f6fce5c0b8a4cf38f64b585a5fb5e0a1a5e5865190b1cd69991590d4a5227501b9b8509b61d33e2db0afaafa026d84a04eea945d87f5b3f150c8094da8bbf729bfb5344cfadf663d94023cb0f1abdaba42629b33e7f1386da84f102ca290e13f5bb92fba65b083b454a5be33d831f1094b474d2bd578b1f024fcf979cadd527a9fc117e60c51c2d6787505cf1d9224396fb5974b6ab4f09bd601d27cb80807204d4e406a74310a1841b829b32be0ef2dc060a1f7f68c8ee659b5895cc80238f08f6f64cef9fbdd15afc26a463c329fee4054de7f1612a595e5e1d74be9ba3cd377c0742a544f13d104247ea8c62a2c66c4ab3801f523c8405677b69c04316d23306c6f92c4ea632f0df3882c2d30ed3947cfaebd36629142dcdbb1487237aee26bfa0dd9aff9bfb8b50d2ed7805c2303b6690ba2c7f6f15041f005c0b394d93b349b0d5bd4e2fa5c9e8237e62759cc13789d834e1bb4e88075263ebe4adc7eb32d41467f9d2e0596d042dfdeca537c1083f2c36211cfb86a57a2e6b081a8f1d7a7889de67275fceebb35228e48625810180d780e4d00f84e35f3150428edfb57310179376458f9131fc475c07cd51230cf93808fa892a72690263051ac179fd4bb466e253e16422555ec35401ce35f56038ffb7ff3a3cb37ddac22df152d5a24232bb83b51820d02e65fc49bcf42fbae2293be14cb17486ada9390a3025c631054a0dd752a76d90ca72e609a215b834d7866e52ce7833c589339e92ccc7a392d9d3501f919ba8496aff2d1374fa42a93399aa2b62a3b572b79774f04fb78b4e376c7b01e4fca8eed10ab0b0227911c711ef92cb32dc2f1a5b5da2ce362c14a27e3d30ed51b962328443d57a496476c6ab182c66b83b6fb8a60714d1bc9e58c10f6aa3817f502b27284477fa01263c363d8db2ad71766d16b98aaf2ef1d1e492642b49d74f85987cff7927ea0d1c8635c5f654f3365a619f45ad96e1ad6596dfc2a5aff4210840cf5b62a8b64fbd50217a4859a8621eb37fd49f16e9382b2e3cfc0a01a9bb888eed05e03773da55dc6416655f1da1ed12c2a3c6ed76d741c65bbb833d7d815f81f323cced453266bc124ee506b303b05a12631d943276b3634a4298c6a142303f87cf4c62b5ba77cd13c9d8280520a3d786bc8dac8f9e0125fc934ea8c3468369bce8199fe680e581cfc5829eaeb2c9613587fb16fe606f6e0429ba94f260b082c24ec667ca7ef38559d80687b01b36fcfacb9205b4b34d009cfafd62d0a60a18530e751abdd3f8cd3ab8a2b47a94bb0c63cf83700da09e0d6a96f1a4622453c8056ad09c02e4cc5cebe3c0841ce3422d9b16d09a2a0d4f9cc4b70ece27860975d86a283f228394b4794ca28c44a468cef9e4430c72da6d91daa69ff11e0bd558f1ca9b92d30d9ab28167c2334a2f215e6494679b2d5bd93180e86d0bc5c8d4f0ac60601becec08754554a42781c32cefca5cae95dedbede8449f2cd89507d1845682e9ad179c0f68928c21a9305a19ab40e603e6e28f8aff5b2ce755075551fd65e9eff635f4ac0798b38d1e3ee7899e1ef50bf09eca8f79a911ca82b44154a44359bccef735c98392c19b9f6f224224497f99208bbaa815da43829edd415fa842f73c8110b27cc315283e5e2de7fc6451688d5f0bbe759dcefe73e613abf3a3fc4889fdd7e7191a98e65912d00237c097240e34c7a5ee3e3384bedad5c0485c5fa0b7510f2e78653ada53358c9c9a0ab7ae7ecabac1642d2be074e1bbc68ffa5eb4d2050bfa8b23439311b9d60f7526d968b7b8f4c0d6c8fbe80da4a0088a8ce8ca0d800ff843b691dc52a6dfd7c54f7d189a8adf3dab583b52ddf5ee0a77e1e2c4d1bfe9f204570026a39807e485fa5e94aaae023c29afb0c5db7384e563b2e83350e816b0bd63c59f978ad3c898f525ef75ca2aea7e2233527819ead0ef5dfa7a855a65202ffe3bef3205683b12178c43c11a958fcc16028aad8374a9192ef88ab5d34eb115e6f8e5c2a825e86615c81db69ce8ea52c4f84af3d5b989eda79d8ea10ead5ea98647a472f86d60a499ca3ddddabbc906818bf86e0efaeee92f47a7c1448a89b7ee0a2cff83c94087eb0a2d52bc50807d5845ce15ff1cca29aa02f54a9a199e18064424c0e23b31b4b9abcc3d090959e87ac02e21bd7f811f5584b55e448dd133bae8dd71ece7a25780e21270645a2169d22c81e933a819bee0f1a2a084efee2a9a475725f6dfce616613186d2bfa01c9c6c98245ab263d9b931bf22ad3f17d5ebed96fac2cad4ab150fecf50233c423bbd7f35e72087b86a3873f9f31d1004c34b23559f86f4833fd172f6038a43526674b65aeb18fe74cc88b4a9de0b16294fba6939bfd600a5228e4e3cdbfbf9d63ef36ab7ae89d7cba5a4668fee5dac2544ffcea1fc47a51808a442178786492f8ec00a60d0eb9b8dfb48a30af67e0d4d0d8bf4b621e5eeda146b68e720d174710e60ead6c9e103e67c6bdd1684ad581fe0d274aa6ce28c6ece51ef5bf1a4b9b6127e165cdb0fb41f25a073bd4a0eca4436eee0d39a4d21506e1ae01d85f9f68022862c617b10e15334b6513a92380c6ff4dc437136bf2c28c90e8659a54243ad2dae6ccf572041f6a8cf08018d2e81c84e5d9c2d2174e190c0bf084001be5f5810425499f899ee7d89fdacfaf18062cf13c56be2d76e043504ac0f13cebdbbd0dfc1c26dbc857b67b93c3d1886763b12e82647e43649e57a66b5841f12418ef8bf34a62d0389092d424dd34a17177be8b4d608506a3b67a30b29be68bec6bf104438938d728bfd61bd3e65c2ec0c5d0f19274336fe191f7621582f00f1caa0d03974562bb1d620f8e459f9cb61d49de5198ba15be89d012f57aa8d5f4190c02f9ebf83461a52c6edada0a72c2d8e5ce555d36be136c72eabdecf8019ff9b3db395d8a34a615cbff067a85771f67410144a0c5e33d9de14d090a30458c99676a328ab51592094544bd0eb50ee000bfd0bb65c9178eca5845d82f66431f38ece767eef9a5390bb26fd195f85104ff470c930a9425657185584bdc65a3c6d9bff0f54715a6b54006013fa1135a3a83723e92b3ed11debd3bbb29f6dbe83e9ab04095fc8cfc2c404384853584fa04a918e49ad2bbffac8a315893b4f9e0311c42ed9efc08057e7f847f7a53c01a5d6ffc4483443dab313b074be234027fc94e6f031f4ae47e9e25dbc756815d7d5321843fe1f3bd1bdee6909b4f9735e3d325280dbbd2ae0997ed30ed3cdfb9ed4106a52382626a54b81cbed4422359b7954da64b7d9e1aa1786b05afb4db97c2d43f7adcda5a3d7452672811fcc542c5e94df19c0f1ec050fee6c3d7e480b416a23b817b828429311976b620b4e1f45c8cd7e9640b98b5cadc10828b48824b4f87f62f491db15d0f239e6ea8ee57ec482d10ccd8558c78c4ef556f623d12892af82d7d8166334ba1691d306644f2a2f9fea8176f2f3834dd1fda319fc743e6da8de74061b8c5ba90e8b175a07d7d5ba9283185a5093df072792b1428693166091ad61fc36494b956ce04ca44ad72b4cc2985258eb7e79e9178a13106f7bba6280c7317d9bd640efb205fd4c85f5325ed6bc396b5bdbec5b748d517b0cab113e74ed96c64b1df3e0b044852eedf0bbd31dab91b4f15116372da5d01857afb053a7d16c19065144f5dc8d2591a64abf287a2901a6341fb57181c25fa6693981dfc14321dbeee2e61307c0772fdb610a7105b25bed83c5b05bbff67e93324ee5823f6ac91662b3f4f08f280b47ea9501b95477dafefeeeb0af82980279ab6a5ed81d41d4afd9a4d6434a5a9bf00a2751a6655600698203363dc81b68f4dd6bedaac22d3cdcece175b708e2c7c06318f9710014d361f23709e836cdd4dc8e72681d87212450bbaad97c7b19620cde79c983c274b96470367fd58cb5a7bd2405befed1eaa95527b65b2c83799bfc0974336797cb9cb30c460ea7a62283ca4bfdaebca241859a444b4dc947de3c997f3aa85048844da248b45c09477208feb8cb379cee78908de50d68b21870ffe19664b2acd967a1c74f264351233e1cdca27eea9432b639f6dfb78d76d5667fc848d9b7e100897643fe4edf346dac59c45581903c568c65b31c18905a17a48fd4eafaa5d9d92cb2855356f863103594a04a4df6008e9bdf8265b60e60b4772b9f21d972403707a8cc76d1b5c758cfd3f83f606db9e0668508dd056535c4823c97c2b31430666be38342fdd99b74b3208f55cf5b9fd7766c63344692111f5eb3b8bc5cec33dc4779b928396024a9395cf03dd5d3d06df4ce3ea91416a4d5faaa58556a8c7aa4583609597ff39adb10f71e6181b0e40511a0381f1b1aab92c6e56be26c8dc8411e95796bb954030defffcf2e74dc7c4a6bdf382cf5d7bc3c8f3dc4e94af4880939f4d4ca7c0129caecf486d7954da38e031ee1c57b7131079c56ecb3effcc6987d2b4720c16be74c46a8813a622dddfe4d682024796056cd06caec6cf45fb709937977f6dd5d8263e6d215591ab38df482de3f9ae45838b8d576b893a3136cd8b431a956e6d873300994806d57d3c32e44c0167e0d22f55e5faa32bd4f471f5811b9db9e97d16dfeda0b2f1a67a06c049cb642d2fb20a1bcbc69ae52462630f4dad8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
