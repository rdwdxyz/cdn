<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62ee8967d149255f3ad756d05242eef50ce458c69f6ef938e5e474fd82e4aefeb6faae4aeaca43a418e76ec32dc3d936a9fe6081fc06a5567979e6084ed8da8b81b88a61d95655d534a4290dac1dfa730e606e62db268f0f63e31c44a84ab7a5ac972fd933aed0ad052642e74335183a23cbb06b877ec0385662c0a6668b078f50ce16924552bada61e5c5999126d4558d9a5f4ab1c980a5301f9a1de02d155cab68b767bc385cb443302cafa256f95271b0e705a03be8d0875d6a992e53720cd9c2ece2d43382858e2900b4150ff159e9deccb92aa6c3e8461e82bdf5da495842b33f0fd36ac89d829786274b43031ee261f63e7c7f740f207b023498097bca4d95e6ca1921daca1eae4ecf9a91af14c535a5e871b6a77476973f70afb127b48be443574e966e69424a259cc9f81fa05ba506b3770eb2455c7a45e1dddd9b766532418805a32eb49d4e38ef40a429e7773d937fe52de1017723c0fd71522ebe3a72eac0d08dd942261eb51175308c95a08b7f920e84c54ce7369cb957d1f33d3c8775d5b4e9ddbd3a86d08ab70983385553bb306bd372468acb032301be28194568b614ba13a636d7277511373375591cfd48e61ac17f7474ee5c91b8e8e55d933b5ed34915a3728e736a90163d9e67bc2619f3cf734b0be9ee1674e31339b2d372832a6355f00c2efeb8005a816d49ee1e8b36a57007e032891f57f8e750bf7956447a17d0eb53fb09622da44679be4de869ab6fb830117fa1cab7eebb4195b986e11d9a5e89f39e2fb9322810a362187a492bc1e7b96fcd49b4f1104a4f564641136bb28fb958d7084fce6976c3f7e7b7cdccd0ca3f1f5ab21503f787922041a50a0372a6fe3a4f6f6f344c2dd0930bac774b4d535d304fca7224cbf975c0f62f16c4133239e55acc573e1927d2611b6aaa5607abc2862b2807dd9564e6e2b42ba97b4aa036df83c74038547c6ba7539f73cc300ff1f1745e774ca5d0995ed806a279753ad5f4a8e546141d42497a9bb6701bb3862f52b82b4b1c8b636427d6419e483f9dce8c21662ca758f5a23e9ca3712ffe3db06e10e8358b18a12a143a0d9dbcf76070b83ab69986da65f73c5fcfcd40b1a29859c2a5c8cd5a29034f1f96d7634a8a724c08c071c1cff7f6bc18d26c809b4fc244e04f90fd9c70da8edc8ad4557c0fde25b1d6ce1b66a3f5f1df3ed9e944737586c00eed14bfb7df02d61519dad312271427d0e86a475c71a6cd25fe9e4a8a3f56ee677a4f14b938dc6e8d591386dea8db29578374b79c10899a101f08c14aa315d8d8c73f6455bfd80aed32c0c02aa806dd462132558af022657c70dbf0dc601b4e015abf0f995139509b7196cb8c15b9866ebe042a27977c7aa63f6974118bcc02c1c05028fe90d2de7b48cc81f392ceb5724db59fb0bb1e0840c3b502b1f9c08b2b8da5e677b1c30a897033d3ad74c19bc306a4045c1a04212fca6a99f0b084fb30c658e6df674988a463b97078c1c6ff5bb9fc135408c1ce702a1fcd703159bf1aa4374260a0abbe958a6fbf78764ed032f3502e2a7e3a24dbd9f2b447bbc4741e1df02b42c357d242cc3cabb5e2ea1ea44f4259f0f3aec9b5922488d40a13df137f7a5ec86a0530be8d29e308660e8b82a317486933b13d4bb38e1a6b902d2cfd6c476e379080f94e08c23dbdc3213a932353ca48905455f5843543f5e8e376de057d5df3f247eed43b28987c9d45eb39727fed42d56bb3f03d04df1fdf39f6fb8c57728fa0b91240aeddb374fbfbc043815ea4cc5b10f722181155f0e208a74f445bb7f9e73d0080d3c252d44a89d1d3e839204bc63278c0b1c79feb0aac6063d9251eaef3c6e01708d0bbc46a1bfc3c07aefdbfd5089aea58940c1edf1e0510a04609cab3893252fb7991cec8823098d3caf718bffedb47b9b0f8d22709cb6fe2fc0800e9ee00317fdc3f30e61338ab041e9102570ff15a2b3bd185f34377c933b45b732aed37f02ae39a045b6a4c10473227f7049bfc2548138fe798a0606ba2fea6f55aedd9c43342ea7944c6aeac3a9fdeffe88f5a2ac350af2544db6a0868cca31ec4c29bc4f87fcfc17b3d38c2c9e0e2637ebd851458cd5c785929c14ab9306be5f6f69156be6ad2851756b85801c692edd613c21e8de3f453606170f372353a1057ad451d09a08b9bdddffbed3874899c9bdb3f60e0a5b5e124253fabeadfce0569c75cf588920d9b13969bf8afbb197dcb61b0252c7c0e1b3663ed900aa8992d3e0c4ad89f5bb5d03faf0dd54b001b5aae814e1c2257ad2c0ffb298bdc6174dc6d29afa6432fae96bd8c27821aed55c7f5ff1e675f611cddb1f61c5e02771c07bb57a553635a80c736ffb6ebc7879fee68ec4a85f300e4d11f541da28ab2ac95b7d67e18d20d6cef215ce3de620bb4dbfad264cf266e17875d73644f5153058b1099f28c7a7a4f4e02ce7f31a8644aa063711b25a0f3366ca8c66b5a5604ca68341fc9573bb638072f377b8df72c4f247c9faf6e2b8f8ee7eb44d07972c3d6cb1abdaf9087e178151a55d05cd8d6bad48d6d1e3c3937157efc2d0557b19c8f55887abfad5edba2f6070eb6d5cf5183d1212f4b19a445e1802d3db6b3141edb84ff5555963c0db3b0c3b112dfee58acb25567aea552602318aed421c32f528d285e98c46db34f88099c6999cbe67479dbf27c730df416cbbb69e9e9d0bd34002a592fea936c206bd78a792307ad24bbbdd017047369a8f0dc4a622834c016337508d489873a89e5d7f8115c62d31ab4d7ede7c73f0f1c54a040c76c5707114be414d7f4edcf6468847450a29ce5ee4bd6d071066e158511e09fb95e6157e21d76347a77a75df8c8b9f17f7f5616a3146b430e19a2df71cbc98671b4245c56ca93bd3104d44648dbcd38446be7b05a8f222b1f9f7167646901e3bd393f44b68f67dc85654d523392ca4ed38ad01926233bc56f3f86528b4748d562be6dabf7f27658ed35e08633ef09fcdf77f0f306a47c0b080f557125ca72ca43d4209943fe2d35aa3b788488e9b289c376a6d45421a7d43c8401aaa215692802c6d829cfe980d50aec762046c2eff8dc427682572188bdbcc5fcd60207ef485b318e5f288fef1864e5c76836cf2991d5d5befa7f54a202aff3e9d4f40cd714eceb482a7ba1a0c42b0cb28061d23472748c4a5d1f0f5e11cf5b5d5c34cba36c643f5e93684c2ea742465be8ca182068bef11b859dd570feee3485fee8b2008e66ccfc24fdac411fa793950fbc82be5b8f86f60d0f526254956d5a75b2d01e178b41def0cc8a669f6c27024961a997b44076354e12be9fcc214e0f800a622c60db8a568f91d0d72bfd0f12ef2399544ced048851997de93bb8c8762be11bf3dee3907e2661a81dd3a17adc7ff2a163403a7115b79c7a718a4daf331e25e419ef9259f6116d643d65bd87e512d083bfecec866c95626c836f5dec9182ebf4baae4382338a81c60f1acc90ba54cf810d2aff0dfb27bdf8a64f600cba0a3dbd632c6b3cd932377b561ea5d2834dfca75a53babcce46474ed3c65947cebd9738805f96af83cdbedab9b2866472b0fcb862018a288e5c0f68223d883707fa2975a521c567ef7585b291f6f85826d942962e3b7e500c24f0fb57f673a12d579c80456625fdc27dbd949faaa37bc6fe8dc35a97da610d7dd2c1d7671fadd3c897edf1a11f96b8ec10ad07119513976ae674affeb19116f0d4e7ff21250d58f65ec8dbe2602d0ae3a7b5bee73ab55b32ac8c15bf9aebcefc40c0d1e8e87da074c921ba5d2aaa3d4f0eea35cd2ba86537a68d650770ff19609c6d4cb601b65c494fa8bc6b40a63c1c3c8691091ecc75209dcf3a8373f34afb18445fcf036dd3e64443dbedd2998b43237aaf56bf2bb43a3b28d40778953c8e64c4e1354b24580d0c1f86da6d88fc8c60fba03c0605b02f9d10313f07486c896ba58f71952c7feab0a59eda8c65c666fdb325c16ac8ecb8721bb22e71b72e213cdb3334bb12c7d938116523f07a2083d33ba7617bceccf6ef99cbe26caf88d4177075b8116782831e8f358558f7c710f1ba1ade10b1a281c0025b51c19b80762d8afd54e89a963e103a39764140657bf794c8485b0e161588fbe72557d6ef96922e48b82973fe078532c3716c9ef7ae833e94049d290b0e807869a882a01704b71d9f54f9db81d581aa93832658b681dc19425eaefa7c295f039f09225c0b3ab38646d4ad37e7f6c4beb03f364f15b6eb0fe707d55dc636813d8b6c3c38906c394c4c6259bca4eafc1c3cba6b2b835e58a7c34cfac1b44d4288f1169e5d0e01770a4bab54344b4ea5652b8bc6b08f4ae4afe888cd08d2e515f0bd6402d050827adbb3abc35aa0a02a2227ee42ccdf21c203c73042586ddcdb97642f6b0bc3f32dcfc1067726e919820f313d9ca51358acadded20caae044e52c584732f962b834de33931df9d005b24633740a6beb65dbd7b7d0eea13b37be8d4f4fbe7796fcc15253d12197cd35cf95ae9165b1d568d68ce2dae42ca767250b6b0132f0d85a7aa94ded51f9fcf1c98e797b3c701becfe7e514b7537b16b52eca9564237f7b473299d3ff8ec41043ef1a5693104c8a17e6e9f514e8fc8366a9cc8790141732962db926c81f2c7c0463b57eca20e8c92b30dc4186cd8e0c98fb38defe1fea1bbade9c0fe5a9229d7bd00edeab65f0cece9ee0f647b886e58e0cd235ecb2a05cec016aa7245c672d0d16a9bdc5fec1507412197f7d79c928de85bd02d14caa117e9aac0b9c34a862947e2955f36a375447a60c9f21607639d60fab5cd10f3ead572cda5ae66a9362155d595936997f431aa4fb4810744dfa492b87b1923147c94c9b7c7a6d0e7f592f082ec8b4b1d9cf054f2d25c09374c19390714e8614dee38875a03d97e5d18bbbb708876e96967e53fc6e9141995b3c327b4fe7da92f5d2a9b2c70963a47c9c21f23968b6e0e0db7a9a3ceb34bb31841638251c5d9b3e7bccd50209b87740270ae21bbd56978e230e9378e41146bdfdfd8f2053b2947ea14dba72e21285eca2c1325c7b3ae626f7b32c3506b36ff00b3ef2ff282b69c56e31d67e29015a30e13a8c30e2a6879cb437f248d6575ae109822b2674ac4b91b8136c06c02d569e481ac0727c44f51e6ae29a498aa0922ecbe50d6fd897dedc6ae5c8fff947c22bf4307ce77fd06392f4b744159518e0001d9142e83374a31d4f2282aba6b6a83c7fe126e3b1dc12734e2b3c6aa7d1f63fec46e131839f585c3882713de5a5022b171523558e33ca31bbe64b27146e9a537c658eb07e3119f8e511980d5293563e36adc6f3b434bb3a0294a0ca2696c21f4c97a4c134fa1b591d4b376825232c9c51cefd0c8b730c922f659b493f5f97761b65584262c433c3f68592e45c51a5a37f1a255b5826b7f7e63ebe09c138736c3690921b6e95aaedfccdb46412bd24aa3b179cf565f74ecf17db8f49a443ebfc7ac86041959d32a676ef3a53f547ad98ff65cfe4d0d42d8bca545c7635852d52da08a7ecda9d1fbb3c255985dea4660165d1d7e72c7903bbb4a2da3d28a37a51daf2c580287f84742ab9600b3940c3f20d766f606d941a23def71e2ffad0c7dd7be09f6ec0de83dceb02ffa05113e17df5a86b2387b0d1d1b9054b17d63197e2d2770f76950ee280eb329343852a307249008c34148f2ca7fb0e725a430ad8ed9e93683602de9622c8efe05ba0bae0488270549bb8af7e7ad016eab21115a861fd1bfc83b952ddf1b4ef5292837d4ca32e22dd88889ae0c6a4512ca3e49196b4d98b16240a847df470198422328c4926ee48c6d0420696012d288abc43bfcab34a904d0d61b417c451e605d75361a17f54f4b97bb4e2559127a83c1f09a575806bdc60b43cccce7cc7999e451bb95b792fd7a99fbcddbe6cd2d7031904d5ff8ce1e56236054d8a14fa355ce44ec2ed784541f287aff623387095aa4a2924c6a331f612349d0a88b6fc1a5d4fd09ba97392bd8d3f4ae10850171bfd2aea7cd2615c08d787f0cfcc3ad1f046a8fa4868754d0a099bd797d856a08db572fcc1590c91dd06ea11d8d93e9fcddfe1db03b3210dec1fda0975838218ece4b166fb016fcaa91081107c39bd11abd8a113219ec23563c6a14ead0650d00c4b53a5dfcffa423ace51a171961425a6e00b90a622f3beb9fb92f928da43ece3f3cfcdb603acb9363a70073773b478d2b4d01a359d7d5bf51288796d5b9358ae505355f491e43bc85d291e2c3cb1a749166a2f5683a6e54b4f91015d223e1556c6f376b1138f0c9802a9078fa7c7bec3bf44a8f67f26f57d72f30b92fa15c82bcf0bb4c1e0ab7e3fcf4212a71195fd300eb1846888471ce81f358c5e9bb6ef47ef9d4b0425f42c2f25876f86fcef788d9acc498177105fbbf3600115b2929664d928626a798f70090e2b9267582d5f3ce3761f36afc76403c82d95333017b75dca5ac3344121002bb0c2b67f3b8833ce5fe7365fde1148f7e9b8b65769670263d2bf6ef13d1fa01ac616c6416488c093b888c1a49fcfb703e78eb6c806e9b26b14d976303735c9e77b74802989e9a08484523d8947b4194b24b663dbd027e20605e522f65a7b8c6036a5dc2e6f020b6489a19fa54309d2083171ce00a5ce418034c1031d5e67b1f59b9dfb2ca9ad8dd4572b916eb40360b2ac158f49460b989ce4e6283e980b3808eed7435fb2ccf4ff368602ed855573039db40b2c8e27a9a5d6d6cb31961f9052b1d4e2996d6a8a38f8b6a6d3f4bd837abf9f7ac454e0b0ae47bfad44f2803c950547e4a7377ecb83f329cbf8d618cef272d8cb72c113dbf1c3c40e506f133246a9776529c67282ffdc8f5fcd31a1d1535ee41d02ce868db12e5fdd9810a3481a835a986cebb4ed80b381b67b388cf4d36779e69c80a5520903721560727a054f9f906cb9d1de8ba438272488afc740fe1ff1a3cb6d3bf7990e2bc4047ba5be1ee45108b6befbf4bc759561c0bf0e6d72018a77f82a2b169e0703394089cf40f41078b24370ffea32bebb75d96af1803006cad831ea2c491698d1e0c1b0b99a10c8898e6ee36ee962412d0c3dc7e8ec15246d12537dc5e457a1b47fc8533349d35c904593fe237feda845e94c49bd4b18abc0ae311fb7bb94adb5cd3d66529db0bb04cefdabefbc70c45c5b83856bc1e701dd6a6f502d221d621b4f01fcdc958374ca829c7e5d63af4e0a63f5baf721419b473c8b43bc3a348af4f51e740b878393be2d1723c5bd7e8c2093c8e030f0fa3525c63af1689d99e64421ce339f5b967d001958028bf1ced1404c57cbbc5f5f1055065480471c690d3a68406e56fb64164ea42012422252a093e06f2a2aa5844d5068b3c9d74453b2d5592531d9926dd3695339cceace09dfa3c40993a89a5e18eee9fa65b9a5b10a83d465e3382469fdbbf1c02e01760f83550a3c824c4f5604db593f2802181aff865f14d8789cadcc9853a63ce5d8547f9482837f603da9ddaa6a30ca0c51324c04589d6e1dce139cf73a0baad0f961a31e9230e887e077f2a324fa6c5cbd2e48f04de85bf90f0fff6d0ed70a2fbe087efb856a0e628bbfd8300909bbac4ef0a9e0ebc12d6275c18c15fc7887381541b6ad248b4f4181b2fee0689ef3629f13919b139b79fce1f6811836901be0825c69eb24e06479d9aa300c63b19b51c5d5f67c9c54a7c59df6725a8a38fa04a7c2456ab6ac1feea0cdbbda8ff7364012dc1f2cbc00f9607ee5b107fd2f3aead57852bdc675faba115a89dbc6656cf806cd70d483a654d222debf6d30c5d28b0b960c3a3f7c4f3cf3b5a193bd81a7800cd5d92176728aa8223ec370811ae3551a87b379f7915175112932b735db572b5eac7aac47062439b5b57439d15f45ae90f98b764dc56693e961b68a8f338ac145bc8c6b58b7bb9f1825b709a73495ce15769d88f8e2f5551957c3bed44013bffe38ab93e9a3000caedb97980f72afcc6fef1879bc73a3f80c5b6155f5c534b55375a39a52c37cc9bb117e9660ced5f4af20da6a1bb6fbffa5fccebca8bf63a972b8fa59e43094af34bfbf2cceb658ebcafc9ba96f1a46e24828feab518f385dfb70b4781e7c40bf98fc3a09e3b4780962fd909d3f5c827306a58cd9a9f2c2fa665444544d6281e62fed6d9ad33586b0f473e64006b2de92a9b799f8b0c516c84c591a1512705cb4e7ca70adaa5db3ee4270ebfad9afa8fc609e92b2ae5675829706e4ed4ff827ff4808bfbc1246058dfc4752104f15f9000397afe900cea96161d1e2811fb1c863a6b14e116c1a90b7d168eb37a52fdfdcc53907d70962939d44a70f93e221f17e63be4fb22522828f985a2a9301b10e9d01cc6c3c7a97a515a7f500c9b34bb2be2e73c546ecd513612451ccc3fa135e2328b250a4075e55f50f054af714deefaba4b896ee591dcc0d8069c8523e5d7e84076493e12af147a7e1054949977079ada0a9bd3078addcd81a6140bba3856a6a0b5be551a9b072eecc340a1ed821703aa5853cab1dddaf97526b5881e051bcc682ac232d32d4cb64a21961969b316f9041bf5705cfa48f8e19549fd723a9e02ce07f337e4889b9138d0cc631bfe7437a009d4e65f9e92261a94cec51eecc839bf3202b136860f2b3b5d31893a35c3de6b4c04c193ec5bc8e999a19b1bb913ff2c65d591c5a0f5316da3ad8f63cfdb4e9d18b6a840b8ea403fd416c94fc43c4653d10a5531e97d30e0d38b05630116480323f5b3c655ad369133c049b9bd07981916343e430eb3e8fddf79857f4d07d39a622147942fbad501999b0fa0fc6b1bd175bd7ee062edb01aff121385b1dcedb825c620621f11ee92124d9cde1e0bc31b3d4c947a65d63cc9d1c5d1a1b0a437b919196ed51a69a3acc456ede2ea799f01b5aed0932ca24a6d6e6d551eaea48f7ec4283c91fdb4410499fff5e8339ac71e684ee1ed159f02ceaaa416ee5dabefa0e5df781a4a248d8d71be53abdfc5afb2fec57a4c67b07df5c06113ff1b059697dfd911d28e8e5dcaa0d08562ceaef9eeee94b2e0dca0b2985805f21abe4ea4103676aee0c716fe626ee74818d309d01203398c8cc6553a021ca6be68feb95cfc46e72f4282cd73922b1c8a6c744d7169dee7eeb9b5403d872e77e942fdd942af1d66fb898052c251a439dbf71bead3e298175551d14d3fba53ad388fd0ce5a5f3acedfd8d7ba16750e24443466ae6b2c144005861c2aa44256b8ae92741ab6f4e4bf2282145f1ac5e422cad6a7cb57c1fc402008587307c45fd3d3cc41188cddb21823f8007fd45ca1957373be6e4e3460079568640c35e8f0d4de56865b8f42c68f7d229b84ecea264d47a6b656dd9b7c11c4327512cf3ac08506ee698aeff4ac77a807d0c16a3e3f1c8a2fde16a4bd474225afe742f79475432e1007f3c4a9dacf417249dc60e475797cc536d8d77af49e9a930ce02ae3553d7ef16c89e5e7d044ef97c6037c46539bd565a7c4a1a4ddba77a92d3e67791ed14411f07b653bc0c4c69628be792e4c64afde6be90596f18528fff23bd8624d79a0c9661ad653f9445b3cf461041c3735d5633d54b81890caedf114b7519575a123f2515deca12af608e6fa563fb5b0ad5c78e9cd76d407a84c5e7f37ab137f8011a61eea668f485b8c3da0561b700ec77a477e78be2c766fb0ce14c0d25e2b3bc2fbf4dad5d038ddc5db986b63e32566c607af4f05b68050ce3dc313d4351120bcbf9ef99d71610e5466391a8d4cbbaefb245b2423506c77418a0c996ffcedf4e5a87b345727bb2cc52422476efcd96ced3e557a75df39a5a446e142fcdfd1a8db0caf50e155758ae38c2da3a0e37b11e87642ddeddfc9d090b1aca16e30983ca73c8339190d250faa43564ddac2d8c9de762cf282ded4e379252805ebf1011c0631cef94a94dbe18988271194f9b666bc19b043f17bedbcba5924cd36f3c3eab45454b7b1726abe8a33922c216d01c1c613102206c1e4c99a1ebc6ccbf39c5a9d53ba9043bfebb24bfc8a1121d34709f98319bfdcb6a7d48fd8e1d8b08370ee73528e195ae5841c5a23c1e6c9bbbf348bdc6b93be9204e433163f71005cd653a431b81758688bd95a46b95a5a8e583823c78979619ef4bd564eda22a8748d4470f6c0ba5768a54c4938e4dbc511c107be8860ceb94b4e751eb1241aace7a6ae6cf0f8875de4b8c225c9bf1ab25040dede984641f3452673ba1540fa4ff394027740fc5a6c24efe6c18a52e27557b8d0db58a6e5d41af664b25aab03def436e258e67d9de74e02ad4fa18782d18fd5a0512606796330b5fc968772ffe412e157f3c4919a9bf228e661a0b906e6218a5c6807f15e2e9427857904a3c64ee3fa2c0901895e463904d69933bec314d73627e441762d18f9717118377f6189cf968f466514fbd1e9937816af034640ba0cdef4a44a172daf41e423066df1ece7684daf2ce54f045acf8668df26a511801397e87cb11e176ff7cf8d75ebdd975d7b89120eaa69affa4c63116889110dd08db2349f6ad380ce856c47a376c10bbe407c15a0c03fcf38ac1222b31ec32c97698ebb946f408c67ba82608f7ca1167f226d3fce0c8fce41ce0582ae2ef143c1631f2959ceaa92359e6915ceb766fb4e131d08aa665a4822fb022b42f975e230f0c2ac176ce7e36fc3ffb0ace6071174d54e2e32ddb87c7cbdf7e22923c1a985ce287b5d014d0a4e9b72b31ca0dc902e59a0f528e4f2b308498b1824c5b7a7a12aecf0a7a51758318a39750256394248c622af9261eb2cf4aed3fd9bf9d29c10b34f4815f6f85d1b9c32c44347b0f4ba7c38f51ace97788a7a3c3c6fe95169e30f32979457bc11d6bafdca361b837bcfe12be5bdf3528da549a3b9a605dc9a1e5fe8da4a66eeb23d0a533cc098927087a923606f0793c20e81680ee6605cbfcc531c48bc59f947fedeabb1177fc3269b111cea0f2cf1e2f266538ccdd4d8b5508c1b51ece5c9fac6024e7fad5949fa76e11ef6d05473a254c749eeeb2c3fcab9ec4991ecc9922a68e2d3e16f3cafda977eb659c1d0fcab81c818e5d7535580c55e80903c6a2cd5e99b0633350d08429acb8a9f05f124ce168d508ddd2ceb570405eea8a1591005109d866abe1a767cfb2e9b5f0d1071744c25ac9d4bf15e59e0f2483ba7e3d41475288801d6dd97c1c0343f64568baf86ce853dd7fee5ecff18da60e9547e34fb022aad85a2d7409d8431b70f644295a98873047cd56b9ff37a48dc933ee55e6ed1bfc75149219667e5bd633cf5004fb3d9c615bc6920074430d1287938fba919e22d82bb3b0fb1060f234371102cc41e5fc49e388e2b81a36857f88cfb5514ad3af6fd464032421437cc4171bdcb51a9778ff1cc71b430078de18e39f69636eeff9e95d90fb16cef450366f93df6bd1d43e4fde612fcd7e82aa261ed5034f181843325a5f0f713f557b74f999b58237e461dfc893dde7523572c7508debdab7d622ff0494227abf9fd2ef6ff4a6818afe8030b37039da3d7c3ce4b4dcba51adb9e08e75fc3cd996057d5bfde827f348e51cbdf491e984fbec46a1ad5fa18dc186c9da62a200a7446a5ab772673cd97a6bfa205c4b26256489840e74ea4722b51d851476f1e4c23f4db52955382ca7f7399d93dedf613674c6b145ffa18f863570412e80a5656b986ddde781f2af095f083a30363fbdb67b491b54cd5ae6cf6928e3469907a8eff285ed2dd588e660c93d373252422a7b16eb20e62a8b2e23ff34eae432bda794bc82c60758b18fbbf662ac0b2618795d67353e572112043ca1d6bc6457187dc10a110390f187e5f78b7b9a3b79f17cf76cffa41ef2d6244655ffad13cd3a34fdbbfce737d416974c78ac05c74a990c7201085f0e4583882e40eea31d35bc4d27b30f22f1e904c2bb59440a33324d8049d7ad14df44a5dba6dd24533ef934612d9eb74b44168a761e8b1751649b050ad9e66416163139a1b7556703aafbf1f04d256421e21a922e34ee64840814aa93e71e751a92f658735c828f7f765ee67fa0c768ebf40c6aa4272bf985e5c28ab222276b0130f0573f55b9dc3d4b3f8a6ed611dfd0fb1667b24069d01558400102a7db1d02f7d3e6387b2f03d5e9a86f51ed33f33aadc3da02fe590bd10ab5caba7045c50a6830f7ffa92302784ceb342c63d0d2ffd3b7191ee26f2f16640a53e7ea9b84bdf392328c0e4dab889404dc8a96b51b3bf56cb6fcc05d6aa6d8932b7446263e5f3de3ffffed12583126ea3ab26e75d4d8a6bcfbee4068d2af5ffde363e5553107c5cae76fa5b94c360c869d9eccf27ff148b87792de874aa394a5f8e5125a58f22a5f218b16fd5fafd3002e131c670819040fa9ff365756898fd7082280d0d3e08110af14f90d6fb3d9c002d4b2f9f810c56addf2a097a7c7e039ab6c23deb6056d15e80f562e52286fd37fd484f282d6ebe8d74bb93a77cc61da3ca71efccd3a82011e32b246db2010d82ba7bc33fcdea607b4df1c2bb8a495028d0b568dbf100cf693ad787ad67bfcc968e775e125432a0351547b3462b679cd8e4072a85d14a864e62e3723a4506811a88a413e209d55d9beb7fb929e8b8161ca3db2138ba3120be6406412e55cbd0d75a86fc5cd925948a040b40ba9260bd7ddb72984f470474e11781de9cae5805580265e62a397fa26f9f1cb688e16ae81253f28f608da90d041f647ec50a55402118dc1da28a8cce7a4e60083234fb84361aba2e7973ca441b06ec9855141bbfd8f7ea596dd36f5fe9bca6223521da0f941b107d1e305ee1e01ab8ee8640bdc3a347a9df2cd3e7287e3055cd26d9aebdedd93b22257daf95a43a9ab2f9ce936c23455680f0b004f2da6859880dd2d34f308f3fec022457aee9ad8231637db9ca46318df2ab3a6dcd32a9e1a3702c71a8eefac9067a4e1e4acd3bac01d7193ab2809607d03c75b4419e481fb7a7291ef8c72897df8508544cbc0d17b0f7bdab9a5119d958d31cf48a56385ef43c38ba114c9e09aa7fc41147b50dcd87f9770fef1c9a2355a4685cdd6c94bc76b37bd9a64f326e1d207c362e1e684ac18ff8f0ce3db78819a6062e8d2a4def981f3d5c8fbd44afd638aa632d96675b04c2180352e77d50c8494c9bfc26e73665f6157eb0d979a75381b1cfe8fabc2da67df59ce2164e6604f278b1a5b766447196cddb35e0f3656ace15585f71d00f8337cf92b78d4594dcbbe71a906e619b312d4be08192f23c2ff63e1d69235874cca7161bc0dd7a829b6881a683700b9a7e5ea5d0c42870fcfc301f5d4ffd018e61458784ee7437a3bdc45de88d8d0d5f66e45ad84c2ae93534eebfbf933ceb96d3812d1949263ee2ee8f31137c5b2bbd21968e47f1a36b28b122d9ddaece828644c577e35d74254f8761c6c606222837f34d67406a1b4df6c34e1b58bbf372857e4d46d04dcf583dff1ff104bff1ad6abc5ab0119a30eea421840635426cf65c3561804f1c168204330cd39aaa8cbdfb15da1f25b5a870c3b7a8fbbc8e6889edcd79711a2768c9674d95a0af27743f49df2f140efb6348a000c6baf055a4d583cae28eb66299d351f9715fb23c20c49f6afc39a3533c05d68458c539f22231b16a69b8e82469bee5a09ab951ec55acb384b96e88161556f54a9dd32e49ee401ba58c12ade4796abb22fb912982dda3af30556a1ac5751e0cee188484a62a1f6f83e6d82352cb845c88edc8486e3a570242522d81158e58900c79a19458cc78310d2240ed3795293ddfdf5689cd7f34bdb8379516e614ef02feb711e070f4b699561baa84c50af61578fb85952a4bb20985315c5469e06a39e477678017204fc300065913fe48380abcb08ba278addad2c715200659de11a873ae45775dc1ae7e0d59a49a4526fd4953688c1d9383913521fa5f028fb246bc289f91b5822a11097282dda060eee935e82feb2832ce3496eeeb121ecf5fad9784cbd61ba5c48f4d7b0d32c52f982ded7699ae1bfa54545dbf68b71377a583c561d943cd111c60f72d483cd1c7b02a58432eb67d142b75195afe209d7d1e84f2c4cda92d5bc6eac6c56da3c218d12848e1075e653d613e3d1e0ba71b76d24f32218340921ec763f85be4910f811fc562210ed2865c121731df1b84eb2d6d311003ec383d191f1f7cc553f3277f9e6da13243634c434d00688cd84a2077d7008ef44aba43346300c5a23221d803cd801fd6b7dd49b5706eecd4635648cbcb57186445a75868b018fbc8f867e7eb6cca2f884cac085ca1725ae8def350ae0739db1258f92d4d3e8c6b63ea514d216e716ae5dfd750be7ecc85386922b95cdfdb557cfb99268073b6fe64d2f28a7178a1429f8e54fabeeeea91a9437cc38a8186dcfd1fc7dd9e379fe9992f2b0404cfc7d11c50f2967be3989e765fafa9d4e3775edaa47cf7b6d9e8cc8efc97193ed8559d3c5c7dea53bbb6669ecea98d1d8a327bf1a349b4ccd2e1c787e810c45c340f122a2acb3d27c97b98544cb68ecf753b6a1bc70a15a26c82bc3ddd9e8a175c4671c9fa90fa118e0b95ee14f7726e4ff45a44273cfb9c89ef7cafdd1fcabc05429c28fdb9ff9aea6b27d26680d05fb8a87be70f09edc561b69a3903da66dd192e80b59105b5ac487d464c227b5bdfe0fef97e58470d4a482a154f324879c9226b19a5a508967ccc5b76e5aff7b5d8ab24e8d2e6a612358ca2e7e3c9e656f1de572b31bd4570ca73456bb92bd078e7bbf2c3dd3ca30f56401368e96fd934edfbca125fbb9e0f3cbbd4ead830add5c8b9ea81949a54c2932a43bcac4443097edcd41775e330d0b2dbc056640bfe80bd78cd41be472b7554f43996fc0036ad83fad64f4e11e997d03f4063e676aa4a2c2edd2ea66576a653d14a72f7bab38e7b601f627dd02df2436ed9a299d5befc414a7e6811b010fac44da56e0a1aaff3e9cfc37c1708c9049b2c0ba4548d320ab41dacfb5b7903886b972facfadf7e5d6c4ed7c91224ca6f2efd16804074fc7f92da82dcfb9787d7810c95bc211503be7795f8a80b4ee60ecf3f0c4c9a4ff545591f7d0dc6a4907205bf0db8ac960a44f493a6abfc85fc74b5187f46e1dbc4efe09fe45aa100125b17da619ac93f445d3ee2477bc6db5acda701fe36e902f1820fabdc7460030cee570c1177c96b96bed20af60cf0ec90c7926bf4a6aeaa28790afa2420d80e55af8aab65eadc54f10bb3ee622b1875526b6dfa77467d871222123c01fd308517563d2ef9e7a5cc6bf934a32a700de68b5f98937b24c703bd673d67ccf0278b979e0aa7c688421210d257c58f2994f1a39da9b8616a7c30bf31dfe4968cc3b879557eb45ce9fc4e78a8be6ab5657594dd200065ef24c12c3eb15925d6ff2e9fbd266a3769260ad99d83241e4e73c7df6e49b9b20107872f3fe943bceb2a72ce03588f4b218efe2d2c1469e025d9949d3381dc3766ecf28881917be69807af0ad89c7394384dcedcaf3e9ba91f8f94684eb41001b72a815579a5b8f1ff4ac29478a7668e59f89461ee3b21bd0f4104e3becf4810190a7a9b5672cd9d00a61bc5ca929323c16319ef6a5e9109729557758e3ab9f88d899f2525a66decd38c5e29f309bd2e6585a0e342e93edfa5d42252ccc697d6dc4cc6c1aec213e664d10a7a5a3a8b5658b1705bff2678e7f417c3a4ef2a1f7b0495c5476848fc3cb8bbaffc5bef4a329d6078f65e164117990da5466bd6198e7d27f398f436ee1eb93a20928ea5c3139a29b986a2f93cf2f1dd6154ef4cb65f3d1a09a7d3ad5e67750765a76821c8e467132e3215393f11cf59bb4418100251a4d2ad1183c4f3db92eebd606ade9d4d6477f9c7e310f633a576ac684c3125e4c6ecb679e664d08e01f094915ed7cbb2ee84840d8657222758766f097197a63e6162b63329ae4968353a66b2282cf65e9f1647c677a764ce24a04bc06d8def4801a51ec1d70b27583ee226a56addf78500cdba6cebe67e7f25e74215d0d2b5b7626d8641370388303d43551b9da4d3ea6debf55ffd36b5b17081fe7d29df9c39866f1d7d4bbf6390941cdb72fcac4a8c07c3e500d05d3106ba59cebb0535014c20f78a6adf955e865e41be4dbac783c194fe6a1b14f34d3ce72e24d3a0ac68e200a8390ef4f02c8167e6884600e51c8cf75ddae416134cdd8d8772d00d86e2ffc57d2fdd23d39a0ee4729d8f79c4d5bf7618ddda3193b9d7fe1240ff621d54143cbdb7c290929443edeefcfb2f5f15b4a19d3c5f5653f89db880246304920bfbf165bb4ad5f787c6854d2ff5b2c5dfd40748d335e85114adb49f1d8550557f6f95e948f19a62f86d654de89aacc63731062df81e734691edbc3292c51ffbffbc7c249536d784ea4f783c8388fd00fa653158ed89cb98662414107f8add825fc3ed768cffd1dfea02c17d6486dc487b93c204924ce89ea92add5f4c2e1d2efb0af1cf7ff4c84c15ad8a75e542a58727d90567efdd2f2dcd352ac151d361cba91dac1bdf3b9e31883697b2f5a16e41ff2f47dfd5ab9dddc74a7d6b7df90fcf854a35046e9afd3417f4947929098b298b4a6af3f27c7f48a262e35848ea5a756170b2bc393ed32c46e42edf2b44c3acdfaa25334b10f0483a36f0ebd35b51d17df93d4033b3dcf8ac1303e28aab2caa742f4cc4ef060cc134b52c2c46e4653f9474eb2abab2bec19e65f7a3510b8f5d1562bf747fb9af9946b4bb7c74d48130f3c0254846b3134d9c7259e3b4f76f6ffea2b8116879ffb2a66d06f9d2263f7c1db88f9cd2ce011c8f9f6a1b3b2c7064a5d034abf5e4d8558f5c0746a6e5e9df92dc00b3228c359e3b761a823f7a19d81e1d438c06f3a7ab9549551a297a2e8e89ecffba2013ea6dbdef5b185ab793d7bf2629444f6b7d281401de7c67986dfd91f2ab3e36c5398e02a0f557bee53e2d8903976c9817cb19006195202282619ea93ceb412907e2026b9169626fa126112e4b62d6feeb1ac66b94722d46bd867ab2e62997e1f6faa6d109e700b1ac3c91b1f2187bc74a14be7474a10231dee780128162edf286773bd0fd35b71eed82061cacebfe9b7f1e75b2af4c95c2aa1af464ef46c1b2b9b8a72bc57d66f766aeb37a12cb9eecec9cba324618938a2d2557496ea4e1e74cc795c4a1884fd412dc78f2e09fa00c3b2dbf1d82171e3cb917b162e030c376d86598a1c921281eefa6d41629b0f1ba5641cc5dfd31b1fd007f2ef679d98b92fb2c5fe49cc0c3caef6db33bff146cd9f1aeec295ef36dfb3bf53f7901a6c2cf41273afaf7208cb76c1bd60bfc551b126704fcb2de70d0fa37b239117a2e22a67bde525c14ad2f56315e03f56c0287d4c5ce1a80c9356dd1d65bf0428c5b0df40aab20a7f1cff116823bb5d47a8d26bbf846ed5b59cc0d7fb10becfb9339e5ccb56103b1140110a2efc67036e0242ac1539142513b118af0ad383cb6223ae95195a94dea4909195fad0eb479f490491a0c9c5a9f12cdc3ac3dc549e1872c418e8fea242585a3004ba9e2f9f6a776ded85644f22da39190dbd679f522c5b84177350c48972150bca04078801845d3fa02466c2d47dbe797567e93c6676fa40eeaf88313938309527ae8064bb437e2ec141f185df74a1d3159b40cbb6d75acfbc31119de75a911d62a630aafd16f78a4a8a08126ef133dd6c8afa81d833565b389f154a810a5fd36d7a87cf650a3ede96675cdd731c01b78371b993ff64ad03bdd2c3af913d8dd2baba0513c4f96dc973e392e4ad999c0af039bc0637f9134ba2a87564a61685baecd4406609bf0488179c3033eaa74a6e303a8aa56fd253dbcbe15535ff1abde6ccf72ad046d3012a3396dfcf6ad8b629234b95b100bacbb0cf883fac5a9345472b5cf8017d9374d16d86c9dd8cf2f0e0f7ed0333cb7238c47f58a8fdb9597d6e89c5ba52aa9a40dd545993991457db657ebd0144c9e1dd88cdccc2b10fba513ee39134a2c741b2a0c2acefea17f591d27f1384bf53657d575cef87bbaf78ebf651a73682aa8066d47b814036186c2993acf57a7c87533c9f273","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
