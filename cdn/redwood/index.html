<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d2f8b284d6f8ca9ee98fe6b0fa418dfed60e9d40e102bcdcfa5b5b93e8d2a14703268d3c5840dccd0164ceefd15ddccd07adfddf631bf29581e594ab0fb70447d4b88dae189ad42403edaf125884078471e4173c760f9c99cb55ed764e085640faaece304dfbc8c1f38d9b5a004edad73bb63e8b1819effac7efaa2d5b3f8739a33ee7ac3b7d55e87cee7076fb078bed6909d6a48836c3490685da05017e48103011fbd8a75c8affbb3d3fe678c8d92ddc0404d450fb5f091146ab25db9500d7720b6c7d8196fd3bbecd86ef62746c6928f049e93cad724b93d1bf5f6715c888e0a000f7b1a178cec30cbed5e923819509d1f37376da0645a4e2846ca15316d715e2ccce8bd0a621006efb4849b0b446dc437ffe08fd37526b94bdd312e5adec2da6be5f312d5e1fa2e7f68180f50f5e2c475c409266f29d9a3cdf614403b6302c81c555d933a15c9f1f9caf38989a222ad47d159130d7c01a92acf428b9892820589aa65f6e755bd6133b49ca5917ac61e65e016c0642927b067668ad37e0e9c024707a2edadbd23c8c13915738471fb2c1fa446c8a8c7e38163ef20f19fcdd9432ecd4de5c2311e2cade655189bedf433cb2bb8652089546893bf3d917eda764894ab664dfb72c67a36b86ef2e2074ee14f6a956d11b98ad1020116b3989cc673e5a5f1b2681caf7f1a8eb0d41644c32adeea67172ecc16693473981b328e085faa942ba2d5701addaf380de1a75b8eb215c36c14111613357753182257c87d369ba9ad39ecff5963a684f66a1fdffd59bebdacd11fc44569b00f64b1f89a32a772fec63c2f1ce22a3f372b47d683e6d9ea3abb7042dc22c06ad8f83eeafb55642b1c5227d23c6fc962f864b42eea6c0b51ad26e8932379891349bb3be899a03cc6c41c9ebe4723471e0807eb74c3acbce52349f1201e83b6a8708f71e8c4b5c5def51f3e437565b285e16cf460a5c2bd35fc2720abf19277e5036d4d0a0987771ac414ebd6692ede67166fdc85e63aae51e8a5197fe0bfd9d6124c4ac9531b8bd65d2676fc4b409f995ca9e972cf6b4abe28789c464c5a7d389fb149cbd9e07c2313263e7a2fcdb2103bd786b2bbc6dbd1a6be3af5c820daec6fd713192a3c07d49ba92e130882c4c04c291e2cc257e3adb13d1a88ddc6efac2bb799076ce1099d2a7b72658c7df8224e1f35fa78c738a8f588f69c9bcf8aa63e07e3960376ccc5a73f22dff2cc02cda899336cbe555e98f6a39f5066202693bfc061d51475e5a73c5ed37585665ee02fe42859fc91c52cc1a2ea84505b322b251c07533b1c58bcfb5470e3d078545b67714f1585c57cc91b86afda7c4dbd35d67a0e459392a32f1076745801857ac94d68613575864e89c988b78d6249dc123756fa1cad0ee3a516caa55a9a5996dbf94505a428ecef09ce6275f2256a503243b8f504c84c57aa3d52c8fa11445e70c54ca1d57ee120aeda09d60670a0d042675d52ce9dde6b85953fa4c32ed7aec95f48c5ea143ec0bc0e0eb1a26ebe03d1f9a5d84c07a38f6fde111cf1a819fb901f2cd7ce31f563fe37be277b0a52fbb90b64a23eb160a0cfb3096760b90f2f9b0e4114f02aabfd26cfccd654d84e6a69a37d6147213f47a8e54e7894932b6f28b0d67aed5eca431ef5487fe9a27a4bb5e3d26b217197df6cd125b387a1954de9c5b8c9c14f891255f1521a590c0270b240eacdee7e2c3b8fa2c982040f9f69104fa3b5c162e02e5cdf9ca0e225ef19d36ce5df5aa25fe63e664ea45e92dc645780255bdbeb000dbc49fee40cac3adde5a95576b341d5357c3ffb8674a955a0add6103f989bc9586cc2ce8a9bc85c58cd64f6f562c03727710ba7ac6e654874c660e8bd0fb5b1ce351b836a8130ac2b23404264632bbb819e885a30a6bccc6819cdb7c565675640ff131f7def6587d335c717c2ceefde080707401eb9a6b945505ad853fe5144654902b9164c1600821ff9b24b351f24dc6cd368bcda3c0efc2079f31ffba97170b7f003b95a843350e11d90c067f5167507b1a9e0a64476903566fcfece844d77de0563230fbbb85a2d889b3550f9b4a811a3ef6078d1fc4f724b5acca5e694f20ef24d237fdb9f6d1dd0449f0896852e1429651815ffef7f3f6cc5acb877965681f318cd94b08afb01b01cdbc1f85e1ad57b6de843dfdcbaf4d98f54558bfa6e24c76b4e9e29d3641c5da9eacb704fc33e01ad5807a70763534f82887781323d65e58680048be96af3d773c7d0f1470b3c00548b95666ac7b2cdeefd35e0da890f47e6a82562f0a4d98367e94b8e458fc49e27ca79e756706aa12df15d0b586b02b44da65027ce5b69d099283a870e548254a136f006ce031f55052bbc585442b828f5cde6855b58c57ce47588dc81dcc20aa5c246613c979387456717cfff42fb867cc967c6b0836543f09d551084d96374b2a5fe729fe455ccb8c4fb5f406fb123de5098bfe27ce241232870a7d4b7fc032d1bbfe734af1fb15b48226f0c07e8325e1f9fef3ee77d5ab055ca87b15b8232bcdf7736e556c18dd04b330981c1620ba27d3f3480a644755f99425e226c2112cc1622257df7a7c84231837c0bc04c5da5b81660f3247b3744af36e2bb4e135fc62f3ec64b3fe879e1fbb0175e0830db3f49dea432d6becf226d90482235d57a511887e77c1d261673e55a363f28ada285a512e3ddd3e79ea9e8a7f470200804de983ae2c92688209e07df962f5ee15b488077c5240773f38b440d2ee7e2b82ff8033da944a5459d64d6ea53773fbbd46ace80fbe2fb6bf3ca4a88903ab76ad9f4941565a12560d227c66d26f24c3cfc7366ff5eccd05170bf2bedd203ec380a52b829da40cfa8494af6f52f255f0370c36a225e1303f44623b85f456f7f5a31bd75976fc026347a729a529f69bb84d3479b3f97e71042011d5acc6e789fa92032f6b514e62831e13fc6da147ab70ee726d9424d04b14439955781f91f426c5398a76440f89f8932807a2ee54183b896de18f866f48acb002a589f024d5ce187ef3203c5258115445bb9cc3032c48393406f1b504ceddbfb7e13a5d2cb41fffceadb434a3735b0d2653bdcc884a4626c28b6f4bc184437b0cf227ab2908a25a6ff08de7ab6db55dc3685886a2a6262ba969c381391b34d20975b0f0e0e7ea294972908d1fd35a2ed6806d44f663a2def86ef0dea2da25dcd5f0fa51028b93171628334330dd502a119f1c130facfc6c6f9f2bd174097f9fa34f857d112b650a5ce5e1cd9ce7f04ead629a60504891feb3820d63f808307a74f84692130d5dc168f83407436f3ac9f5a3278116ec39618ce90ff077f32942e02cf7670a476bfa9762ea3e77d5c6f6952605473c5468ec13782d50d89ea126eca1de4349ae8278eb939927a313919276041807a176b2378ccfc02b860709fd31c6bc8bc25be965248893e98014ed1857108a617d21f7875fecfeb680e193ad115dabb75b333083bd76ae9fdf1fb5dbd48d7b960410dbd0d5d72365f5f8a7024f9b9399c8767546e2ddd650ae17af153feb0c589e4bdda9d8a349ec866030dae1ef039a7b899b1a02ba7b78fc6283f24e206562c003733101ce3c18fc4079bcf9cb117738b603369adb920e69f50ef534589dcbcb7315c687e52daf1ed21a6fcd3c8dea574ddfb5dd09d77f5fe428fbee9a89445cbbbad715bbb687815fadcc336fae1c0e7b9796948e8daf8f147f42d24b5a963996ee9cf651384560447326323559c48efe432cae029dc649ace4326f2b181d74fa753eb0bb60fb6af973d46169bd649fd78d16b9f957c48f3537a7cc133b3730666be5edf1daac4e46af70531ddd2be29fd23ede994271c324164b02df4f6525881f98f1b04516a8f0ac6f0aebbfdb65af9100234dcb85eb6ea5b39730dd5516f53a30617a23b06831fc04f1fa08daffab04f947e97d5fb8a771c30c220c931f269a7db14e2e6b2a93dd4b4f47283b677ed6c5296c16219dd8509e4344302485a2eb8e490769312ed13ac935c9ed861fb74a8baf58b5d1f806c1222763fb91d8fe3a09b6c86a12621af4a9000fbc90a7ca3588225fcba29c2b44508b60c5c58bfeadf114e43647f13828c127cb5c8a2aaf36d1389ff90341c2b9187600072b5cf452ff270cc2040d78ebe97b936c45561951a70cf6947a1aeb2d6fea4f7ca31509fc4f2a80d697dba3f8225824491f9182b3fcb8a7debd1c56f177bdf9f7b5536d346040a436fddc4abf2d4b47b04ebb98913c26a41cb19fd49c1e247216833410e9b525e687f2ff3d159c15b4d578ee4f5a3a6cdc01a150757885844a77655b3de8db7e5174266b79500414b98c786aa1e8d4ee0d40409b8c33a3f1c339a9188cdddcea4591f8ad154729db3aba327505b3c76640ffcd73a7ff53ac89b40480a82e07539de051e13de89a6fa4bbcf7f8935f6e0b33b4c2e13d110995b590832e706588c7e1c7978d91c9faa982b052c01bd6d2daeaf58aded106f53e22202975d48fd52b6baa83646d03c07dc74730c4db9f330703e53fd3a7d78005208f13ad83909a3210409bfc48ba9dce1c008e4fd9d8895b0dfc7b195b51c8aa61203ecbec4239347fa3c50bf3570569277c99ba68228bc565562cf7c00d29e91d6dcd19ce4153f66987a49ede3559338b4e75f2c4d701f9d71fa30a615cd06370aa62423fabc85d5b9d27e71b7a3a940c97420aaff5d4234b9b528e7001d0162625828f84ce3742dee05af03759b6f2703cc93b27e91756e30d0af26c2ada58151e8b0f555f41e9b34b550de8b92069c7321077723b192cdec31d0ee82a8c963d1b49275aa6ca28cf141b90618c6cff6db705b9b992829ea3e0c6d0d2a27c18013868fab90bb73fe985e73c0094e4cb39f0ee4f5806b3872fbf21132e639261cbba9a3db8384980a8aa4ff0086065448f20f7140c9c7fb5dd4b56a22b43ab34303b3aeac10f3e0beebbac69fc3380f43ec4e4d91d67b1512216e8380db01b00ff11d51dff04ae0ab3c3a4c36ceb66e1c8adc82d74fda64605a70ed08d5809a236942fedf4096488b1dbe4e60f08e1d9cc671c6fb03cec0a14493e5c937176575af9c07e4f67c2dee657dc5e8248e726f39a3d2f6319af8c033076f4ce3fecf27535425845cb3fb73b41a336c71fce5b984033c0e46a7abed4b4ec09e1d0f95117e11816082f283f2bc148546ac9a1fd52d5bd5021c6729954600e61175f86e1c40177152006aea5130907bdff6d3c38c5a29859cb19730a58461a35c6add11f3ba33be8094eb8853df1b7384b6e168e01e8e5de8fe0d198948664a46e1a74b6e37e50e1bfddb84869910b73b16607d7eebf96c97df8dcbe1ffb550398be15f39078419192c0deaaa9e737be63564d380cfc3275930186daba82e67f7c1d617c4632a7318c4fd5402f22cd16068e3f6a60600ca0beaaa5d87c9562876e5d40d18db49bbd7a22537da01bddaaf5ec640711ebaee28263a962e638b20f1bf53b8d16e123a2d2e1e22d2b6ce22f619567482fa86b6532806e5d83542709d68da28c814607556f1db01994026638935890798eaefec09f9d9ea1eecabdcba763c26b783eeb3ee707e9309dae7121918da486e59feb9a2ec87f99fabc9e29d79160a9185f9406389567835b1f4a5ae003149404d9a2eb5e1ccbca7528203bfc926044a5d35a24512b035674dc90fcb3ed6aad777c67a7d4fc3ed4c712ee2a9ef8e577605e21981b0e795133c9e88b62688fad54bc20cf0dfb478155310a4edb12b5e5f96c7ee56c426b659803779aad2da646906032be97fdc1da7cb32fb8894059eb22ea73455465207ce4281d4d6f77d3e9a7d84bdccd6f1300d0e7cde8f3290ed409ec3822311060f6c73e665aca8e6b4d23093e7665b075e0bba340a5ccc309d73a7210f16405611a4616d30c35e38ae38085e2831bb0198ff914738bebce22e638b10570894f6592f26a2c7031d3e741ca7f9f794ddbdf8a1ebadb6551c2f181096119879211834beee329194d0022bd09a0e797ca943a79f4912551867f1ae5b7008bfd9a9b37662b1d12b120c179830020d71afd47682547e60b3fea5ee9487da358ae16782341f24394a4867c76870589afbeb1807df53b175159e6903cba0e3bd617fa0ecd8d817246d67e01187091d417d9d249e98fa424833708e73ed6bd9afcb1d8c6113780270ce96f103dbde7984e62937d25c195355f7bd371fb6793f5c8c50e9351c068080ad0cfe6c8b1e99833f841386c97ca262bf660669ad26efbab3490ee777cae1c3c4ab671bc4a1c282c90b09324142b90a26198eada36823e0edd41c73f7c74c9b8fdb9446e27e6db50666481d9d2e33d58cd074d0d53857247bde74f13c0324b7d98af8a2e06a5fca5b49e5b9f3be44baaddc2fc314b9101d233933ab6e8698a29238c4b50aa8de9301c299b8f951bad50370b5ab234ebe24cf0be7f08168678462b38f30fcdaaf2ee376c0f1d748baf5aaff005c6ea5078fc06bbcd3b6be8c62add44918f071cce1bba460959c28f13cdda1d99ff5b4030dcdf3f722dd5edf4493fd46811a24fa643dd873aa32539174d920ece77b6f4e7b84d563c79e523eed2e5f74897a797de53551a33ebb7b1b2392cb2ece199b15a965c383129974260eccb1c4d2c47af96f312d2955d5f72a8320c5e51ccdfcf8082579695057bdadf4878ebcaf1f4ddeb673c55e5712530e7f0a7dfab79ab3754d4d6323d75559b629dd256188a2bc02d0f6d6abb7b7a9fa37f8147310ff32535956d2c876ac7776e4c15b0123b9f089fe2d46057e995682940f3973b4db8f53c20cd5daf71b3da0ddffd3f6f926e77f08d53fa8467b78acb6a225812abda122d2e980157970f5860c783fa62e9e6b2a7b861edf00cf926ddd832ec7675969a98cfa49563d9b4b83c86dd3e1e8d2c03f6eb50cace213471c7808654b1564c436b231b36acaf7ee383de21c4f6587f4f9626687c07d7193d04bbc1fb63e2fc24464c5e115ee68bf8ebdd3f4202fdc3853b3324fa95901061039e25ebf2b6a410a68335c4676279b171a2e95400c0718af467021a86589c9427e22536666b7f320d9f04ad3dae648c27869007eda46e2a48b00ab3934e5fb2b6cd4245dafcddc9a7a901ba367d4ae7cd45ec58f637ff69d381cd3d3f8b7cc2900dc0717338a771a7bd7759ec5097c6761ef8b1d9d5dfd3466f2961078bca86c9b62bbd67a488bb357852d9edb6317f1386bae77eda472203df678ee7765b0f83a8d3d57f33d945d7a592f04e93c2e1b9caa0d2946261bda80301a843358a81fa601939998a60141947da09d561a0b65372dec0294665d512193e0f961f4e497ce58a92e3b4faf5b9cd28c5b495fb9ca4df984cf24de192d4e312b047cddfcd6b182a86d271443f9904d979533f02a8fb649a6b719dddfb71f0716a5fae068863164cd00980dbb2f5968cbc7f4cd53aac668ca72b8db158d907a9856a6eb260d4b0162d5e3d2e4c3c9839938fc2db920818513b14bb79970f216d7304c5c9a1821ab9f5eb2642d839a84e7f55807a7196ea850d09b5805ccc12f69ec4a101c245958daaf83fdf12966ab64a5df40ea59d68aa265bf36da3d5bd42ebd7ed3a4fd2dbdc577d28bc016fdb28c8e5a776eb95dab0407e0f10aa1a40673b0556ab72277b8832558d9f027c3d74795e9f2d02aafa9771b17640998b021be0c07437ec7e7ef8f2210188fc138e72be4a6315b86124193df95d3d1eccee96a213749b462cd179d0a351545de8414c2b45a85729b7acd8554c0891dc89b368f990122e462dcc8c47f5302b367916dfb6ea90b5e3cdda9c8b4224ac2c158bf617b1159da3fa8626728dd963d7c90cfb2cccf93ab40d1f88577bf91e42bc726bcc803b12229bf01e5a41d5119b06b0769d5a1617857f5c4986cef31171d179665db5613d51655a3adeedfb929f88eead8a1f5ffb734c5b2d35decc4cfc19d0b9cca130658cdc5257e5edda5065e5113fb74a37080ad44fae8d4e029ce83887c471d43cec5e6ecfdecfe78cdaf01ca5bb76eab7cb399376058dc6da9de03d52727dd3d5ed2852870b88dd5739d463140384f656303563698bacf79f233be083e656507c5cce9a2e6c68403b7757ba0d55556b053669e7a37287ebfe2ccf3bd016407ff47470f6c353475e7f16ffb819336130612ccd8e21db0e76e177dd4e9e77d903b275b627ea2791ce9020369e0e255e10b2a95d16a4dd5a20d6a0603b1f111ae9b3fc56cdfd429f8859ce088ec400818f411623472ee20d7883e2a19e50550bbf86a22c9bfce139401570489e036a3389c0f5186dfd21216251a0ff2835031b3121014617777c4f9dc08d2c3a9872523d0e1af66d5dd4642ba848dc15bc53d319bb35d7a92de40a5e6baa6e44b87f8792701a91b442d713a27a5335a6d189f8536544fa6a8f9c8a716615ad23c03c06c78706bb7769591495fbce0147435b72336d46982cdd3984cb84c764ee0fbdbcbb601664e3aa67df33f95d57200fccfe8a5248846f9716ecbe6a5a990c00bfda7a4d49e369e9a03d5e3cd76d6e8225bf7b58c472293b8327df372a2b49cde61d6f29d932ad5646ebad45dc23b21518751f6f2a7d7e25c85d7fff3fa907d3f88f0d3a40100b46e78c0f3b058a694afd4f5ae2dbb678d37e8857801508ae17fb8027ae8da66ae42f3ada2846449c3d9ee570d3f9b31fca39b4e5e0128a8f95ed1743e1731667fc4688330570d9c00cedf5c974f9dcd27b04a3914d4834eded29d6a3b8d2800566b46662a16cc720e41eec121d7288b79b504499af9f61bd829d4f15251b32efc4347096fddd1fceb56a7e0ffe3cba3a8e6e14ab56a398ab0877fb82787f540018991a574785e947b45349f6bcf9c8eefb5d05344721e5542bb2b86be611198cf592d93ee81792eed17d1ae606c0b7c8ea8c2fbe816f56ce334e4216d538bb089ff1e69a90ccf8176e363e6d4a488aad28c56922ed71ea1a389b6441ef2ba03a02a2d1ac722790f70d92fe4a38de0dbd6bc44fa6daec8c369f29b4a75a5a254524a3f83fa719709aa32a59dd4a37a066f547c6d693e2d50bf3c22acf7cb5bbfc02fe243ec313be1fb2f0e789fc93c40368232c4129dcdc7438618bb3c02887e469f170202cd4081e787ded435e0cecfa4a8a57542eeaf323892060834491f233c49a6fe8639c200894d2afc9f8fc7c6bc66cd8570b1665d10e05c5f42363f977196472a4702b066591738e56c86079e95fb6996aea9ace63597dcb701ab617563311c235fe16a44d29c782828a592fdba96ab36e3c2b7ad95ed4c4f921811f89e6d03964c6363c3c005fd24ffb219e6657e930ab488c9daabe13ae72719c6672ffa4918a317e97215abb45a3fc8108b4b471364888edf6de2abafdafcc015a6256de0a7bacc42ac2d659cb278e8aad48da0aeb3585fc3c065294013d2f2f913b99bdb4007d05c994702ee22bb41ad58a69111efc83175de5ddf7e356f265a01210dccd49c0b14f9ceb20278b0f473501485a2f8714cd66927f759d65d2ae63866089c65eccf3f9a612300acaa33238a30f0957f1b8daea3eab0a9022514c80f27ebe756a08e6fe60a68ff869e9e709fe2e0941e3e073144637f6acb9b1b359794c3eb7d74e20a214d4af57e20e25d61b95c487fa40b02cee038fe5debc47dee9516c8e9e5d9388bf822759f9f4666712e9475a6672c11e3d6fbbf39e900a70933509b62e8d5c43d6f6ddd71380a86c18af384baefa81619a17d11ceb7ff928e49e12b508a191f38e299243d5b6b2e649dff5acd750f2173066eb450e4dfecc225943c08d50ad369d43b0ac3dcd374ec378e2575c8c69387e487af6ca3419876c6b0e6ffd0398f69e4895afb3033846267382e2dfbc4b7135bbbcdcbf61572debfe3d29d953cc41e8390bfe34cce53f7704fc17ee02ef2de0d374f7159ab5c63a79a34bdb2ed09dc9eadde4ce6d45f6506c0b42ddf43f47928e9f747b1a219c4e0154a95031941aafcb53ed41935bb75cf995247e70f640293bc44316f8f20e18272f9edcee145b6b4389acb2ca787de081a6fcc3cb9093088dc808af57f7c55c97a62418b348ee8e677eb7d36971fc4db5d43e60284e080cef119643168e34d1cc8960ca7f13c89dc3408de734fba2a53336a4bb5d566de44e23073f51bddf5626418d95ba54303b76e12937567d0ac488a33afa9faee1ab4f5b8201ac4c9b9f977ed95047a2a35b02fed7659e2399d279f0f5b791d9e3980fb4efed881fd87f6425ca2f3737bd049e63ce1526646c48c90574f106ed52ddfe3b7260b4de9d807f6a730d71c51306b7098897f5c496aec1d666ad31d254d057f4bb7026864c53f1d6aa4c6b414790dbd84a302ac3b26a5c6ba56acf36257625fdfd4e7b5001d6e1143db80442997b767d2670a274a4b2c2b4d0e822c3a208b7ecefc41c0147edf1a56e46c2fea9d31a8b15ad02f3949596a480983e277863ffc7660719ad0edee6aefe28f30f56fc6533b507990ca385fd1b77b7dea58d1d2351febfc03ed0f103d382e317cbe11e14f5dd028ef08aa1fea3a7f35c957139d70b08a578e1d0689b8f9f58f3e4a1298a040f5bebb6ab0f55cda28eedb10d906aa17d445b1b568a6083966a2ad27e4dcaf06645c8a2299c86086ce97976ec8d970ebcf5b82a7acc737e760401afc79e9ffa74aefa2c3f49078ec38887705bd594da621aa3811c749c9f10cc6eb0aca48c228aa62960c42f77c7aea54cc8be725488c8b789ae85792713ff28ba9904d08a19732790479acac18a32f96793854e48f4eb754de7edbd3dba2d6c1fc52f7f937d43ab8996a01d2aa718421673425779091bfc1ed2582ef70022eeaa077642c89a67cd48893bbfdbca0c609a2f595fedab070eb698152e072b44a8e168d775591745ce42dfde102a789d22612467a1a99d9788d4d6d790b1fed97a9c0dfb038f677a66930391aa884d6636908e95bb14857495bef0ecf31dd6f29b04dea5bb55c35a85f1f8ff837ac340bc95d71205395e53268e53652538fdef4724394db8762af741c8ad48b760c25bbf46ca5357c34c8aff22abc787bb6a6ebf20a23f63c658d4000df81c6fc143fbbde4de44dc3637de4f8170b5597812c22d9de561fae00126331a031699ed35a2608e8c05c8770626034e2b6016889c4609a8e2d95a829954d3a19d975a227f0872c207b1b7f7cc78ba1eda5ac859dcc313d08d5a169d7a3c5395de863b513430b9dedcfadd16e6614f4f306fd6d0e8aad49d1177c2197ee799b0eaba23cbf8b1cdd8164c87a7a9c2d3df19e0a62977bc9366956d8ea02575da9533f88403ce86b9ec7ceb6f92daeeb525dc58b2dd7dca59d94ecd1f52ce1f616c280c25c73c78ce71a61a6f8f730085fd9bc07e91b51207446f4fc966d100b89e7e44f3e83f4490e80f7ac137a2e4d0a0dc16010380929691b5bd3ec8b46f40438a140403779692d2199a4c64e69d56c35ac10a746819727fae39a718800c85309a2ea1a395dd3396a7fa024c480eefd4934db4565d29db1badf325f79e47a2f3d74ff5b966adf60b8af3f2be93f66f1873f04986127361f6086ec654afda555444aea3e0d0d2e9b8dcc7ac9d3ffc95be0a664b16e6d68a1a64557eea2bd3953ba36d9706c94bcb24643e67ec4f4f0c80e9ebcdbca9544d46734135358a2e1195484817013611d716b6b9256270f7faa65fb6976a0d1016c92c17c712b0846dc1e580d88d425e5aa1c09085ea050b5d0ea3841683399bd20dea21569d6915f3a6d14c7955824cec7516843f8bba32c0aa3fc70d72f68df0b44ce543f00c9af3c1e654af8bb8e844b1e41f46ed894194cfefc125876b7eeff40d8b4d9748aea57085525d3df2837530005c1277f310a1ab1b564c66c76394c4d8991ff8970311eba3046b9d5287ad8f4d83d796dd2aee85ec5011a0fb492eaf41e04994ae6ebdc23998ccc4e2eb5871aad8b2cc768c8482728c50c56b94c41566f5c016cb20a466bf0a68f7fd86cb106a9650a96f88ad6b90762c34254caeec00a826c00c2dd623b225031b1c9a2f307b135119808d269e9995d4cb119cedd872c060ce47b271eb7ddf0754ae9f308af2ff090277880322c447624974de75c9e7b6c03e03ceafede3090562732c49697a49c2a3c594c505a7cb4bc4e0869b2cb90a0c8948855e6cf8579b8bd12c7b87361bbdcf70680850fe370ff6019a925df583e8231fee67b8f7d20432158b3121bdaff7c891f8c6d5ecb986625fc3f7f446a38c08ce92503155c505d8e059f5d6be46e30750270517f5c1439df96a14bb12ce98302ee65812c77b34a327b664acfa77bc455dde6adf70d4b9e9bdac46d94278e9cd7a732e78c68d740a500935c10d86a3bc8fc1851ae8c377f7b1bb45bd3df16e3ef00775e745a687a5232d5489870bb1b4c226f1d719e28d067744f9b5fcf90ba844c27587b8afd694f14a7ad8529912d7fec0bbb56358f86378adffff3ce108c5a0e9f3e6b50b08573d84f2efdbbc399c41637dbede8d6cfdecbfd7d8dae1b08c29c83b9571fb2b9430db19dfc230fc112246441ef42d355d9c85f308312ff6a9045fb18157f5f13968e1e595fede7b58b67d72541204f3595609502a7cb95c47e99a639595b9bb1e4ddb25f712adbab47574ded34e743c22bb6f46aff66acc9ddb5662e38cdb8e8d8119224cd1a3ba065e2a8951b58a2ddc3a98ae7da7f6a44f123c176ecd22ed71c561058f16efbf8e503946ca6433a482bd9910d64735fe8c970a904a5b95f06b03d8525199ffb5d8e408bb6a5b185e305232cb84f6d0122ccaf95e8f4ff832d6046018afcfebc1a89f919e2f1a04029cb8b17e7301f83c152d28a2b45ebc44922c97ea97316dd3e6cbedaf11525d84f7991c14b22c348ddb10734709c66f369ccc4ca496c1a100fbfc0d3fb631981165dd7a9e5d06bd0135b284c3a5424c29b28ebc0a79c395e95a5aa0eaa597a7281684d019fe9c121ad26fc505a4fa2f017f472bb3993214262455a4b0cc5eb7b31831713bad74fbf53696273efaa789b1c8e1dee50dbf78678faca80406f02919a14eb5050902976070c7b2d83a3edbab12ebbb589941648673023b76f90596a68b2ec735f3ad5b1614b8678b3dd8fe80e0b1294eae5a6911153176904ef7b93e589cc8466c44ce3a469ccb459dc7b8bf3391d57eb6fc2fba5d36e1e78513f05d12c256e23c945a23033bc50cecae72389b4d000cbd9908713fff0475df618c54d38698249de4e82f9fc9e6fffb550f2687dca35e9b05ddaa1af6c6f499511c283bdd1232f0353165fcc5eed682bc5bdf50418ad5d7bae8d8233c30ee45cc39fa7159e1f48b893d83a2c3f1002cee639773c5d3163e0daa5b7f26a8cfea663432d2c6c273a846a56f17a2cfca5e58b9852171d7467c1a6c2d6384d9b6d1d9159ee3f18454b89f3f5fc8421e94c359303e97b83308295814761e89a6b32880c9b88e7f704904257f79cca94e54d6feb0872e6a1bf173b54dd459a7edbd01902bd91b12cc4628fcecc6ea9dbc63cc160b26ccdf8b327ac547f24075a4504384ad88413639dc825ea429b73ae4c8f30399b524017738095fa74bae394071780f8c2db140fa7e147539436e3da6c7695b52ed4b75fc9dba6c855be69fb5769201d2fcf39c92ea2e91224f5d37b4617890af569bd7264c95ae4f92f677553897274fe73f0b2724f78c9b3b360536790a55af915306a26939d58edf9c339bdafe3faf188693bd29449b3d2926cdf29f249a67fa0d037fe91b6a04fb7bce29a6a13771d2a9bc60e3cb00225873c20d31209fd70d87300746eaeb818fb691119a89dca6421d1d1bffc917c4d72c993078e49d0462c674b77ae5c687c0903b64c235d9349b6ce7e5cffc6327376d7aa688b1dcfc395810531b42b4add90178a716094eec861800876d567ee61c68e301c4074938a1a4628ce02b8eca424e6fd25efd38a07b94778a0bfecaf5bb5d9d6caa639ff5fedbdb3b8fc54a88397068abe750688256cca458e47d16828b51924b872d7842b208a245dfb2c9a6441c5bde45df60acda865487fabae471c7c0729395a32f4016279ed71c8f6caab3bfb5e37b8c9c9182ed480dadc76bfed05d2e0f2ffb11d8e3fdce38894eaedeba5dc6f419ef178c2ce187b3d90512961fff2dfa3287c243769d7515705a51dd7be9d63a7ddea2b17371a5baf861ace6510eb787ef31902fffd5d8611713d77206a64abcb7705516f54768622c870bc50ae9ce050ca16c4d7416b6d3ad87195bad749ceb862065e3c8425c954384ed1a24583e783b9987a8a2e47e5b90175fc17208e3c41f0bc9ed6675e82dbb54f60de30b4813755b8194e24b7055e38f5325c0dc888cce0497b223445ec07ddd1c6fdb78fb0bea0fc3cd25d8960040738103d2642c2cd2b62986d264b55de17953111e15a62c27f8e91bf612639591126c11b41f0761e5c195395feb967a153c299993c602692159548ba72856b116b9aad86e39ca362016a494d7a4bac93694d02ee624c8837f79d5db73cfc4b54c21076e1ff5dca6229672ac01d18709c7b1519afd3e5e8a06f1ab73eae5e972510664e130434294d47d7068bb8657ee2345278a094b741e94daf29e61785fd464cc260a0068fbeb460f260cdd40faafdbf01ab72865caf3f317161a618f60df48d61f8ed3c0371203664aae93ef1546dbfaac4067ecdfccc80e7e96e291ac3a461b608b9393f532c455dcf3db62c244cc1dcf7dca0c0e6e4af138083b11cc7b0052d9d0a6506196c73db5ce7affec1f0fa91f96db9789dacd4f9666f90175fe06d14f8148223655b8e05368d86fa537e4a53097678bb732e4c5d3afb01baf61a771db130dbfe87347234c18112e738f6985841ce2a42e6da3d9205118b929aa9f271ac8c0565debae8c9e92c765877182a3d7db9bfbb647a5637cee0607ad4c191466f784062daec5f01ac38fff432c68f67fbe507da8809110fbfd93f3111b3ef0c90f177e759e992bed337b46f3775b00904b1701feac7d0e00d8271986e1cc46ed124b3ed2b73aedb8727294bc47d9ef3306d2b3894773639add3d344cf033c7025667ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
