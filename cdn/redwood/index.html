<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6480ed729308f1dae924bd8ac53a63d6441be141b935dc8fab8f453f61c685f234139f6b426f4161f4c4cdb9ce06bd271fa47a8582fa336ae9514ad1539853be11e39d6da1fa5f266f3dd6d43a1be3a5e4719df1a476888c265d2e3b234f75c74810e0ffe11755cd735b13a2b2c4ef09cb8d462dd8d0db8c1e8c8a31ca00506bf511c5a39818b241a20494e691ea00b2a47f0d2b763e30766b4b19e714f62f942d3d43c92e305bd8dd8857a78d93c78a9803721ddc57d62908e26ceffd047338fb0261ea4b0df5cf67988938467668b4a94675315bce49142c99321cc64cd5136bc93f578810a116d6ef866b069de175521711d6b6e9f8ee48b614f2bb3efd0ef57b8d4cd6204f817cbfe1628be8099d61a445ce63736f000cce0116b58e43c14cc7be2d341b935c1cc3fd5aa21dfe822e66fdbe3b20d625a02f6779d1b59317ee66dad1b9f6427106c25205aa1ffd5b4321bfcce76b59571a9daefc2cf4dedb38a745cefd0446083277436e2dc796f950643ce6e917f2de6cece0612dd78ed3d5ebba331b8ed6f66bc70e546d06c6619c51df86f09a20b35a82dab131fed91c2402f69426fcbb757459f1a59404e415ac6595f44d31f7a0e262b75635c747af9526d1b563be89428e9c20fb3dc6d84186b31e4b757cb27f3c252d635c7e61fc9b9d7bba7215e7171add8c007bce4f1113d6d6c09efa10ed8e6d41ed8a0ebe4d8db4e33fb9d1ae5b10cd7787ede2708691caadccb82edafd3a9b5bb665b7cb8e167f187b5818e9c16fb0583f0edcf1ce059d489cea50f4da6d7e2ed52db7116930597d9da97ba0aa37f58e588a6010005262f97c2f548e9e5d8d299040699cc62c3bab56dc149c3478b1123fda399debdd07b40171f81e29aafb067218f8885d11ad1a09d9c4f8c7ae1fcf09248749bc6a2cb406b3478fc19c1091a6e9282f1fea6df6d16aa2401000ed63a646daab4ddf229e61d7f823d022c0a56462edccb3589e9038b5b18b792b61a90af7d6471426479ee3cab93bd166594796c7ee6d147cdd095a84d2caf3ff228e699060e2b7c1250c8e38b612e228d89557ca380dcb1f789e7a6b675ecbdeb460fda4b1a55e2ab5f5dbe05048d4ebbe8c781d3e59c7191a3c69cc77bfb5e82496d7705c6a6845c562ca0d728da2eb7e80f40994ca713326cc86f9a8255373633e5d5dead15d5fb6b3e5e851e97ed9b1f6c336beb44b213bf1ac9a41b6976a77f7c064c110d7d284df59b14798477fa353c74e6c222ef78ee73c30e374694d5e4a48124f5c18ecd628ae37c684011b9f32af4b39d7a577bd46fa2b67f089b646ff219a912730ae6f9f505b93b85bf5fba8b8eaf3b66b285ac00d27b2b47c0146c668b61efacbfad6772b887fdc61cfe93537c179313273dc0148bc329c908d8a512fc2b2c4a733fb73273aba2997d1ab2e4b8177b4bafab1c60bdaa6f209c9eaacbc89570e8b7e9e0b84c53af31bc19d86366eca8abe73ed4aabdc52724d7e39d153b90e012c22e5e2175d01e1fc91e3e2485c753b872be52514c0b54c6dc4ae82dcebc70a48e3df023d051ce39ac6a3add7e9982977c71bb3e66fbaa474b68f86e65f27f5bfb0ffa6e750a8f9f534b56b7e9f46734220cb4a10ec8cab53820f1928cd1d9dbfd234658b3f5ab1a892c0e002b13d4053512b7ed70667116423bf9c4a0f927824270fd372599e2b3bee3ed7f42103c5d418e60803b644e06c5fecfb1fd9c9a31783d871dbb459c55f2c7836d19af3c01857b992288ed8b9538740f23b8ac49b62c9d9191374bb369b2d97876323530f80983507ec7c16c589811b87b8838c6df238b9156114ae17c4a39af8fb0cad95a9f2810404842080066025cffdb75bc724a403fbef8749e5cf085390c478f9ad5e4ff2b8b24605a71ac2d611bbaa1ab2a2876f408b42ad3c414baf4f7f845379ef6380019a02d4021e2989381da1215cf8b9dbfaf6ddddb3012f353af299584ec1d80503e74488c63439a4d5402c1cdb60b15279b2462606a96a5e89a206d8c9b3af72036e98bc0ee17952606662645c7af1dda92e8875090c37ee764ffe20d5bf89e77d5ee8da7a554d71b1b87b96f904afb3ea4d56da94ad357103ce89015b46873dc294b7bf60d5ef69eab6c0ac0bc7cb905e95bf1d1cad96b0c89868ad3900607087231d95c85e62f37fdc96ecb6eab0602f3d5a6e827819f3d4be80a41640810546faccd16d6226228d78effc7e363c61d930ccb6a850dc56da94e10c0628fb9a1aab85d5ea1d0cad3f3ac9e0859170708607a9575efd2f6d1b74e5fac98d68831f78bc657eef9392d872ce81e05293678cd66fa81feffe4c81b39f38579ab30d603c4945950de04d00f45b54a45dfbae934b6e45302b2db6ef3770959acda3d5fdc8cccd2d968ee4c32b454bb667e1d1d9c9cf9ed99f9a7de8d0da980a0e036b0fbcacef6882b40f5d85d39d3f4f2b7a7d0cc1117d6ea22cfe3af5f522f95689134a7dcaa60cf8cbcf9f4b4a492c20e265b186e88ce9792977bef76cb7f7979478889e65f0d6a5be841c48bac312d1783f33adc1a984bf853fd8c4a75a5a643e7535304e901154ae7e007251d94b6f4f880959a68cdddb958a03cde93189f5e8aca0b0a36178b25a3d071bedc397cffe1b54668ecfc85467e148995bf280b25023f82859bfc57ca82c51ebc260877adae4e6ddc28c1e1cf7ea81c6298f03f78eda9bf02962b9e0820529cd4da59474b932107d67b50b022c8e2bc59393ea4a5c525306ff8af7952618f0da48aa17df596fd724140772983af08c7637aa2c7521d4d566759440110c1a0e40487d4c464e320b6ce32afee1be8b13a74888ef4e9000f5ced40c874fd1cdc202db7cc728e193f4a037563d5b17d1845e1fa825b1bb8b1ff46bc02695e5afdad6ef275bdff0bd33f01db7385ec5caeb2c36ee8d9bda46cdcb58c4eb48282f6b7c47a3190592f3aa6628954e8d7def4a5790465bc82888f07524a7ad99a436370b6a462b8e6a77cc620442a1476b805b521ab37dc3335619ff0996524b28622f3c042e4ee482e3a48dacbf1b13d784775bacde3def9dc516f094ed19d2df5f86686ce3e37fa67e9566a371dad6ec0bec7a0fbee38af2c2903d7a641c9c389d366dee8c9318b13bfe14e490cbd07950738bf8bc5e57b5ec592cdcb36aa3262d64fd24d052ba3cace8f93481e257a019c0b7eafe6e108d0a405190e13fdfac31608112a70ce4da4dd9b63849abb8d5a7f8436765fb403c7e168edd86f29cf7742bc35b532fac12016455a11d91303fe329471acadba1e39b2d371a800fd1e89b74224c59fea67f3381568a58aad3e5b1d89f19d45bf55f4a383d67ae275a7877a6fa150dc1c585aa8f42cb88150fcadb7a5581739fa3a3dff842b302ce4e16c1e47f14e8f39ff6f78b9ba8ff35369225079e22ed14e743a69dbdc072cc19760057ccba8121940abd20a5c00650df015df064b4c35575049e86317bf35b4cefb35c8afde4290fd82981eff8ed7e5f9d9df69e3e22bbd28123621096b8ba57cca80950fd32541f0127ddcd8be5df6dd6140a9d050074da63df73190f669fb91a0ff58d310defd7f4048da66c45bd67bf7b211cc872aef16241b13aab3b4553d8ef0bbf7e68e4d8ac9429b14b16820c02a36213c5c53d479e47f0c2ba1b8bdebaeebcd4fb7104e69b67d4943f763582fa87009328c58f54a5f60a477e5c8e6d139bcfd5d91d75f5b1b04f65610244be8da61e87c5055deea217e854cdc094dd32ee48dfcfafdbb958efdd435ee51f9d03c448747ee35a251e124970fe9ec71735d3a7ca31eb1299135d7a1b9f6bed1ddd2d3fc612f714321bf9e2473d73d4a37cb830e565742bcbcca8e3eec0f0197d408beb425e3d35d87d3b6a9cb80d1ba5feca53373510251d6f0d4d5df34f190a8938256e4983acaf7b53a40b24041c45c18148d5af0446dcbcafda52b668e19c149003092f1544797248b465be6330bc9f12c4e66b15c50a42bdd020da096cd86b92bfa142b130f4ea7e23b4632c802d1881623111745e3ba8d3cfaeacf1b4ea8c55ac967498228df1303437a93d9fdb9cb6bfb3ec4de581378341f878f78fd3b0f22293a66217fe09613706f91c81566f4ec3a6a4e17aac466bebfdcf26de0f0146e7e57103f7e86a8e6a50f769200e2632e6b81af7199e2c4dd389d41200197f63ff215b53b6142911471681d32f74236afbf412e2ee92f2ebb2a8f48ae313c7832d5987033a29486397597b9f8779b300bb1a4711b6c5cff764aa4912b06afd7ede24664298488cf22108a94d3c636e0f35cd52f5e40eaf2798bfb984a3c16606f60d67460496b120572c840d6fc4cb61c7fc328f8d336fdeb49bafe581a43e71e052161d38722f2b6f7699506215811372e9144234b0d388fceb6ae6d3d6a031967165929a734fe56e3264a1926574d5b36c7a36e8b4771da4a55084d77995372a073dda732552e516b30531c6322b25453408c2bc949aad3f0cc34305026843f42d1ce0db89dbd1e71ea7d935c208ac5593e09ad12a135473f9f3a9ca9be0f9fc95ef197945410b0d65dfb84860c67b75b952d39a6b76f93f568471fc92392aed52a0c2a15ad5067a6df68f7218a4834d69e9ed673668272f69d2b0360ec6ce75086dbcb295eee46d85b1818fa47bde3e13e672cef62c45034f3b9e86ba7c011a99f7ea6955197b20fb8b91a5f3c176b624347019affe8ac7a9c4c84638be6db44844a4b20c99ec2299eae4a7251949b95cdccb366c7fc997919fdfe402ecd64b38685086157669b56408a4515de8b31d71cc1be01d8106e421a034efb6410f2dcc3b304f7e6ed08f38401f7cc345f6ea4a7739b2b4b532a1d985a4984dc8a4607aac23a1d055490d8c5e5c1af5e5ad72e6c7bf6c8f1ab04ff3b9108a11e12710c8b28a1ea326cfe133ec50f2df22e1d0391bf9915998ec0293a3d8e5243188830a9dc7d0bafdc0badec3a036846a9e6d2ca09442d2720936489c6b52fd42459f573174a378fdebb2f39a887005cf494abf22ccc4d0518ffa1b390b992b3350683ee8c0251b6d0c13dbd0cbe932c719ad4e61f7e6e1da87ebc040f99bc3a3a0e24d88239a9f9b6aa2f49cf127af84fc8b67c4df807b7381bddcbac6e35053972187b68d7767ca1e44a9e6fecf060d0d39cf6f774bb5180bfba327584e53845893686f8f1ba5a5a448b1697f2873af41c3db72acddeb68b0dbdcbd4ba0cd2f5c5a20204092115ebe96f07a60bd700f3d5c9c0d6a12babc7b827ac9520d8f8c7775cce897c04d879521e5fdfd9be75a5ee3a9e65ce1e40d27422e165fa4f0cd3b240486b7bac3d756c344906ad91c39b0eb64b74d11675c6c94d9e2826943acab0e7ab404d35704551d7fa95350eabcfe6455ca673eba57402d6d272076151868563cd4c66efab963351257af7b3ab08bf6f5c74ce70ca9c3e6f0ca0fc71f89f1c132da73df872260059b4837fa35146afea8658b72d7a63ca4f9492086d515d11a78d34ec4e22fc972142f5e2adb69bcef948e07868c3d25cc0e9166ed587ed23c4c6104c8d0a5ffa89de5152fbf7fb7df1bf84f2be56a20610bf75ecda6dc757a92ba5a9ec554cde251c64afa0f571e06d0c05eb79143d1f2b90fbab495c5a25e635a388d68f3a4c395555e6eb01fe8ca9316bc36139911f15f35a28e83c36b688ec14a405979ef3b26295f5d533a04b28c6ca73df4e9174875184566a1d2bd4025fd872323110277ad8eac582605dc35aa90cc08d7229a6cbc2e592c24eeb3cfbd6b71519aec8d5069039b3fae56e821781b86d86d6bd041b8e476abb2e7f48d1115aae68e09e172b07d7be64d218d0ce699f09652f5ba69105a3d5a1b48fdcb4a6bc586da363815dc80fe0947d8963e139b149db2b85cbf10b39a15e61fd98e6a2ef84518e678701edbcf2c7b89482265fc1ba156be6273369cac1686c93562cbed0a45139aebaae843d5d7d1130ff50353793314636defd76ea53ac1069920b4cee3e159629fce80a7720c1090dd97589ed192719aa913e6426a84d12c19a5a5919003e397de278a7760fb89121b2aa16b3b44fa106784315b939f6596de4237bf9f54926f9981a6633ddc830600276b3cb1623f85a25835598c517b6245b79cb285d0d1fad2519ce2062d042b2c45e9853004640b9b43acd88eb15aa2dc1227083e708dae938f0205eb2e68149f10fa6ac93c042614d6e6678dd87e3d2164b1c946ccf131a11dce77cd4fb29dadb2a4a8bb0f2d25590cfafecd00763ebbd12799dee79d3bc1e5a9b7d443deeb9ca09472099823fd82e1a196af6ca5db911cfe7966b3fc3cac7a273c3407059e5ae9e501fb241ffce4b6df9347c2417c0f108b397efac2dbcc36a1426a18e054971ad4ba4671be4fc515ada65100a5f6a96037e4e51980ba05210f6448f0a8bab71b4ca4acc86fa7848170b1b52ddc49e128da92973beadc2d28ef96115fac898787e1b729c401a45cbed33405fa17d9a0cb64db65627621209773a8e70aff6aa5c84d82003cf024526b2124ac6e6ff82b215e640b61452d2831f8ac4b897ac74ea2262edafcc0bea13692ea4f84d96cb252a8abb720080394adb1751fe6496b74bb4d094f07938bfb246b921f2e1c559292d1d9e62ac0f85498a0fe0930198413051f05803064cdd0a3789f2fe4d49a4ff296e17899cacbb7a2de71d1119a285088889ad8e0a1fde5137ba1a3e423181ed38d36ebb7d026395f3a75aa51bb3adff64f27d41da9c5912f5d8a5bc262309bd31852f9c095d46ba87ef345023c26e773a7d848fa6b6e5ed290aceeb833a81ee931dedf14a7041847a28b41fcd0e4a8f110a7eeaf38e2775810e9f54fd799adea9058cc51eaf6e5e54ae6068e2f3eb69301bfc4e305181d02f47ae841179f198d5e1a070dabf85519b27698d9e0c2609ed7560feebeb19a02c3e121c60b2e6c98868bfff082b34e710185acd1d346af2a41f59faee9abc8de63eaf6ffc051ad3d2e7bb2eac939c2c1a203bbf1eca9eb33117d15339c3c3a13b8c6500c205e61044aace714617d3c266a9c89d2385450ae5f03898fbe28a243cb1cc3e963d08f6a2e0a7905323a1582a0103f508bf7df501b235907d4f51e0da64cd730b240f49eb90cd908a8b722ddf06469bdd299f3e4f5d654d74666c8892c47d0083baa5fcede8677ac9df021f44abb6b0ce4cb784b12bf1ccd61fb6dce1cfa089d5b465dcc53203ca33d63e9a6483daddd3890468d2ebb815352a7b0b6331cd795c9d24196fc7fa70024bcdf736e476fb2fd5658482bd31d883e8add3b9d89db56efb1e6f86837445fbd505dab520c8fe75cbc315d2cd603302283d0d43ec5b4be99fe5566abd0f854c4095ac32eceae391b7a6c2782538da68cb653c34c67feda6cf16ff148ed9485fb7b87e7537c7d51591e800a3942085e306755b712e8f3011f0bd74c61d178ac32311c55a082b6cd8cb7a665b7f40a8b28cecef3a3b8bb96c83e1db78ee5169df7d04af63a300c4001bbd15a716316feb8cd1307d604f3d4aae919ef310b6adaa43eb72e1643b2b25fcfecb7cadf57d3ecc75a6e6ba7c9f15e4c0ed3bdf0f47f2c78ed687cd5de60bbc070f2d2a5d8d703e1ff1d609a59c5b40f18d7f2ae9a943f34efa3af10b216505d8c4a64da837d28b9a1d97ed655b0cec4b778d386c43f5503f86f050d43e09b565c2dcee36497912886c98c52778b6ad99f67035e225c4b61c355edf7f24449c095047b3ca5ac2cfda40c58b77a4661c725a44a984996ea341da5cfb1676395a1546490c24e19c2f4f6b1705515fdd0d8f9eeb2c0234a0c18897b9faac3bbcabac2ddc0cb91f08d735799416535e93efa2423df4dcd727651c97fd05c65951b1489b18767637c573f80ae9e1deb5badf3f06894db7f36b7dcc64063a4576be284c3ecc9a864d378e8635f8b4ec52de03b42610c0292977ceec511432d5b2158f22cd7e0f7fdb6f484a4b7b036bf325817554097e5263405200e52e33e1976f575625798cc523de2e11877561beae4204ca3b3537b51ffdaf9ca483cc9ca9bda47fb073e5ff29143d47933721ff5642c8e1b7767a413e4fbc180bf5b62bbbe1d30e851994e9bf743dbaecda73afa872e09910a3761889b25cbd136c2bb1b51185dc0b9d6078273c3b586d6bebaee975b39e0dc477aeab191008b9de252c5b3d73db810b1396482776386d5b8839510eb818a64c01c52ab363df7800bdcb890f4e08a9cde3f0e995ff210ef3e4e6a94c2793e8b3e77b9a0b13a5ed0ebcada4ee82f7f97faaa45d2a152b14c78b92c45ee2929e7d71203402279241e022321122f3f3d308e95141343ae8155612b621ff3977752b4ea2c3c232cfbc9b17e533b0a4bf8d43f62290374449662c634fd95fa7fb3752afe97945a927ffb7200a1378229dc819e25ada103b4c286b0418cc7312fca29f5327e26442e9d036237a006ea8998883b7f7dc8b8064fda53f0b109f183431e273ec93ce77efbd011ce48d8efb1deb0b25d228006b6ce763f4c3ec94c557b58a7fd9f81b44c7a7fd73b1b910e6bcf9980b48eb64eafbef15c7efff539f9edf2db70f8cacffbf940e8e24be00a413a9e597caa1ab6dd061ccdbbe8e7fcf1c271c1ec95bfcfebe08648ad83974a0e07b02d667d71a1f162db30c794a26152e17883bafa08eed404c2fec24e5c075da5ba7eb42fdc67a84421e9a9aeb6d12a5239ab62c829cb996afc7a9e5e93c4585c091350328d5122527a12714a0f9208a00909732e5a9b559ed35fccedeee7ab4712a580ed24a7a7aadb371b26024f15739d2159f31c6b1ab0fd3522020f5b758cbaec44169d4b7670d75c0bbe7ee21fcc2b9d510fee7fb753067ea33fa49e1fb055e09ea24ca6bf6258fd056b87d202e8a1f03af52d80007dc6e2d37695920060b7343bbc16a774fdc48e7b6954afd5af1f4fa957b4f69aab3c38f9b123d05adff3aa518093b6b7d63622e04aa7fbd0f73414b6cb3051eb5a90e6052ad0282510cc51d92dcbcee022563158cf95861699d80ee2becfc5160f8b6476d4d011db087ec1fa10bc4aaa189e5da298a187fe4f2c3e59578c6f3b082d117e2e2a57474c09e12f11b28ffc024e8694ed37e4872f453f4361d22f12d0961777df94ecf196f1aec9d5c5b1ee54ab801bd6edad6154192ce32032029f07eb405503e23d6e7afcf752723cb075fb8f4e7115cbb62fef44d931a5bfe41d402d62c84f0d0cd6f72166753cf710f26f76e8d47353941ffde44b2d19c7c3a921e3296349fafa46c81c3fec673eccba3bc8dbb24b5ebf3deefc9465fd33bf066cf9e24ca52f5808d59b2d2fbef37b50aa51e0526c4dd7e5ca49eec13f054847f104337866bc8b34dcc269079b4efda6d3e244b784d23576bd6d828a7e738dc72bd33deb52efa98ab2c6baf89dc2699c66b361045db9f549666c6850e5b3d016470c5a2035efbd4bd8445591114d294c661a528bde79b541e7034ad5d9cba6272b87cfb528c0cf8bce617ff270ee7c2daa5e3efb386389dbd96e862a6b93351af45bbea5d93f82b943326cf6d4268d89c7fcf12522ff7263bddaa01e99b10822396021ab7431f11f94320492e36e8ebf208401b0df4b9e01137e457aca990f20afaa86bf79e711db73360f7586a57c7de45ba8513ef0697c381204c63ab3715dfd9afb0816d2416e4d656ef896e67103c0705d2acc1dabda5991bf4c0320a1a8c433a16ff224ca4c459b2597790747f3526cea3965db56e6601abad01c9ec09c4ea9576110c81abaebb60f705d8fc0bbfafd5946a5c2683d66fdfc5a04964ee1e7432af339ebf4a011d442bc07164893013435e0ba58db69401accc9f22a39732a1fea85fae567697c6877be84d087498a10a735f90e002e5dd4d233f46476d4880ad8da49027e24a23f34c3fed12bb66930205d3b64c6aedb9931cc21a6a5cc41bba77979a9a05cc8184b62c454752ba18cc73cf08109f0ac372500d3cde3e7dd4ac3cf40b6495fc3766134230b684da6711956176a1d910bb7a0a93d764c453e9ba1f6e709571449c1acf3cb28025dd8946c668f18e65da1cec35c0ec6cde79a45862a4d05710e668c2d045de4df0eccbab89a203f1c5cd8fdad0e744b028f3dec49ed1e351a91e278b88e660feef826f832425a4c31700c9dad85a4d4eb6c875ade7111bad25ea24595cf302a99fffcf28f1a95c1419bfe95a630ec8e4a4d29e63ed83e00bf59d1c4cbfca41e87f1975d1813c7b72b9b65903736988e5944b0c667e602f679cbc58db168d6638b85a56065dd74b5ac29df59dfcc061705a06c18319a0486329dd4eab14caf1eea7203c331894cdd13c88d54488aa79f7cc2d0abfdf5d85fbdd8a972c7f46755170ccc5a3f1c5e3fa9645a1944da0cced78cdb7b6be78fef2775fec433e895f96c8f31c3757445c71e4d2c5e03b270f23db717351f6ccd402acb7d8a30e9d9cde9fde26ccb3e46748a5e51995c50b2a1e14aaacf670e47247436fb19f86cf9499207d2b4397881d4db91516a221892fe8d6aed4da5e1880fa17828fab236334524316ccf2d6a5241f874885768ab81001e166309f5d34427342df8f28ecf71d7705d7739b3ab2f825800313e776b43b4a4c7274bffda0fd431db0dfe3e61e9394618b3279cfbb314a0fe5ed727cb966ca3ca61d132774879fae919e207c22fe77a95a09ec7e3e4ee29a87046c816af2d4a8886be7350cd78e820074cb49b3d87955bbecc89d31721c0edb89ea84f6d16341a8c53b0a5807e4ae04b3bb1c50d1177878861c2256996e1a62ba2a3b462a006106ccc3cb93222b63f808fd30d0fcd35dd8ef4884429d73ef0a2ee026fe9cba550abf79b6158eaf26f3ea8b98f620071c0bb95486456bf0b7cfef32d6cc4caa0bfa1e3d24834d6f42786d557f7bb6eb3bd05c2a2a8dfeb2a11da25c08e9ec0bbb9f6a62aef7b6688cfe99a6531d2a94aaa68c940eaaa6ff5ec422b803e73b92edbc6911ee5e1f1f81822f6323138020c15fd36e6b1846e2a74555df3d20780f1ab0b75e5435a1a5f73a5a38811704320ead64d43751a4bf39bb53f1dcbde99643ccb8527b4e4c8aca46d9d4837130f09dbeedb35ad70e304b47f7a3902613cef76ecbf2cb1d1aa0409090b28d5dadeac6aef5ad29ce07c82448ab6692e012a3d8854ae3952e5ccd16415daf8f6629c966eabee2cde83b529edb2cb41558538ddab133972f25c57dbb9a7a88d534ec908b86f6f4a32059dfea173d4308348e43e2f99bcb14e7630e76f908e1f69894fe3c57c5bd560d730a8fa2fa82b5de1d78ab72fdf9dfef4e48e0b90898ec6110f739349a7a0ab86bfa5815c477be6723f06ce24ae70bbd950f39ff8f5071195b1e6b5b6e80170114b91d20457dc0ef80c412dd988c924ee50c58fe0ac0c6bceab10a0de383ff34c8af849cf0e792df1f55eff31c00f37b9e06db100df17ae697da05a237ee147a89edbd4b0761d55c82842990793b5581a236331b7250f77b447924dedaf4368fb7d552e9fdc533c41f42276194ec03cbe77bee715e0b3423fe45ad9df275632d7c7aacc35b88ec7b82d8c05e4423d5786e518630ab19347e8d435aa7d5d0d7db286b2b4287f8c5e22011a229dee9561a716cc8a140ed5e3bcb8bedaeb1240d302f6355908be095e5a10849f8804dabaaeeb960760a63faa1dea11f564d2cf9a0b1a14d93024d2b8db8ddda5b0854c376aee3f7ee234de8bd41c577ffb0f01ba719e9f97c0e6c124df92ca6c3651c8a1cdde0e6ab3f137214d9181262c60a6465818fecbfe1b5a4241228a23f75449fc6a3943b247f09ca98c215bfa66e36206a896948c32165392d6e7b294648e123c611d61313120673a55b7695e789d322b79c04996e42cdcd48af3cf7fddf37c80b8045668c89db591caff6da3e717e0b95731d0be14223287667ebde9f1453c05e9203a288f531e7b78a861ba14a917c75793a49b78ae38627677ec7fff1daa73bb02116f2605ea89d296c78acfe7970313f3e27ebf4f8caec972e9d7a6d317f9d12c2814a88b2edbf0b167046daaa2b37c9823eb3791fa705a3ed23e9ca7e66457ddf94c636616816cff8418cf87df0b754213a40c07dd641242adfc1f8fb007e0c59cea602aa70714894674da9b5af35f1c709622ffd20bf8c6aae06becca8b8b37c1126d3a4cf9be074be67f908e60b1a40dc3f05aa4caa71fbc74a1df8e0200f147ceb0bed440e3d84557dfb0ddc4e23e965b98c201503eb19756d3b7b28716356a6024984e29157de699cac37914c5ac6c9ca69242adcce9259afb985fa0f4c9ba4acab44813285267c0d454a32e0823923c415f76fbd996a8e110cd4fd706ce5e29149b51ca64b3a14a561e792e84ff646eae799a7af993d2b0fa1e2b0b8f142402c7038130ffab4e0f4512f11410ed7f13534b470ad848c4b472cba6f59ca3928c606f10bcda109e89844875eb8843806dd06884c0f954d44484c319ccd5894c6d46d36520d96f9b9d89d6bd7912ef427b10eb97e545bc683a77bcf4996d6089f81ef1c649d2c5ef127b09d7d3a5110b01244f41c7ded59f6cebfa91f93803c9e44d1ce92a3af37a188a8133cc2d5440275d146c24de824cca9a9e592ba1a334c89595c77355dc8e43be555e719432b7a6c6586ddc764c9cf933e628a358a1f7600cc10416d782bc53b402b8d7999b614e0ef282b36dc1039c527f5314acc954f8bee41bed980f1ff351bc1ef0971d3c2ddb9fc719a5d4f646a281f7ffd0c0ab12588726652de981fe7f89947442d9f6966305a26aad3b086a554d4beda533b02554199d3fc24fabd3b632be392221c84fbcbaff464e6d862baf16f9d929249989580dc09e33d63f1ce26ad1261d413dd5a5112cd14da2b3aeb19bcf503440d17584920c70219e453ea2f710f3e06edbf4962c510e876f2460b5c5abd384359e7ad224539a5fad5265657ad179089ff2b5bf11ea7f01355927bdca022bef836ec28c2a50d77717215bdfab01a0b432747ab725f2761be970bba0e0127bb8e5cbb53ac2e62ec310874db08303fedf27d3a300d18820b86d03cfbd5ec3d053481e8b84e49ee9a4a12ed44ffa1f7bf3327a8c8af3618a1cd072997dac33afb70e41d1514e8d908e598623031a968f454eed4941da85f8e3cb6697bbfe785684321889b6e4c99f8eeeadccd71f593c10a96ceed1ef7062a21d1d0059d1105f7d30861fb882717603db4cf1584e5ff7bea4d06d8ec22aacc73d3df2b4c67755530624947032ef2c522e3e6f779a99b31ae0c78ee03223e365fee35cec28ab29ca90693a7105681c5adb6b4e028b31d323a11cd03f8ab374e10881620cb7c5254c4c05fcdaafc14c702bbf4435bbc774ac1bf16dcb76c3b81154956d300cd07b1e5e8db99abbdb83e23774cd781ed76a05b3da065f9a6a5a7917287e8be1a81a6fa6868e4249d0c14e3ee82f8ff717a434bfc218f85dea42302d8ac226af083658a714b7e0b1aa5602d175b6e4d0616bd22b96ee5cb351f2ec833da3be3f67129ef8f1bfa6cc979a0d19e4e034cd9aa0fb3e3d2cbd4507999ab5ca3fa195b623099a49f96447e98eec60dd40b98b1cf69b390ff699869c72149623b66b1ef4609884d6ec9b8c15480550767f1e128764d550a56ff3e15679ebc207bab423b6689cb99cf7c322fa66d281ac9c3cbd82f91bfe553c7f554f98e7e24969c3fad201f2b7709cbf41d818171b4da2197da9fdaa008a03fca3c4bf84bb6bda4ba598f765177fafb6049a856c92f388b46287dd89a55dc5ec34cb6a3f2cde7ff00f2be6bb9fe11c95a088c863ce8f3866ea6155475b4399ed8975f4fc81d72e3c7c3b27f758610b23f4277e5406b3e0de89eccca06fad3c50aad03a65c75283e415040bfc2986905ecde6b20e31287abbf5f22949b2e772989c7067cf003efd74a79986652f0ab1b90cac05365ef05a34be6c25aa7f4526c6bc232e8e5f29ca77015fdfbc7c7d4c8876f0a06a17f2ae87511cde6a27cd186c0b2028b95c91ac95c2c04cc20ee0a79ec5e857bbf5e169329288c357f25ab18550142e76a146a5d08ad8397439cce9ecc7f964054fa2303a947b1876e4976fb65bc44c3df148ed21243a80265e49e7e93e0ed30d5b3443985612782ab085f3cd5370268c7aa43ec066040c190824d517c2a51838340212da5797a47ad2f7ca3f824bb0565a9c2798704540d793e168ac152760093d6a6a649cf8646bb35e16cdd24c6b292f33cc8cb5c2d2ddb760507fa7b3374a76d20f5518b6e624bbf4e4700484aed9f65e092f86ca0d9141945941966a3895f1a9bdce0846ef3032bbfb8f6ed8fa3c7a0c3bfbee59ec4372444625539085acfdc47b58392f9ac0d1ce0d6dbe4188d4033f67cfe0fe52002cb835025060617a94983b72a30bb7975401306e940cb1d7ad1c10a998611d91d478ede07cc585fcbb6a736513f3ff51729e37a836c13eafa0342fa59815ee6759ce67f35621ac3e1ed348e55b72584e2d5bf2c470165e4c89d33eef5a0c60bba02470010f80ea5a9b48dcf709616277ee7cd22f3e233b3b66d44a469d2927f5e50f4466efaab2beb2d503cfebafa50c4905b953c5058119603f7f8af3ee393d4a33b833a576ae4c787953c26316a735fe510e6249202e87f6e4bb232ef4af87e559fc5c1def549d935fff5bcd5a66bcde3d2a18b99cd9dfd57ff017e054940e3c28d5767851901b8535205af4c85a143368c262d5134d68f52cf035f643266e750540aee03192023e03f20a55b25c5d61fac3058e9a8ed1f53b698c543c1df6163015ddf9badf51d3a3e76a0e17f5d654ab58fed116334564fb643786528ed7609584bd5e330503dd2035c2bffcaeab918c4fb9c924b088575eb9be57b39db257cccdd317e8a3add49e43585e09cef56f5966526b2a6958b63fbc109c9bcdef8764d3495ae9da38f5440d5aed52b705ee8a8310de2a944fc7202e482ff2a9d59820844f5a5520cf9cfc9c56f17f70b4d3f1f88d9ac81935fcda3ecf97838de150b71bbc325d175b67d326430ead85a438a76474c4ca4ea9562a5ff1d941ba69c6cc1aca06d36727e206d8f69afabddd9278e9b58a7a3d1b0dfb476a4da90859f7f769b37bc9faef3025ba8e99d8e3693fff21d4c4a1ff6e3bf02fcf9897fac652769426ace8f1cde0221f5634a771212cdf0e148367904c432da3b6abc85be33750f11ad466ce66a7a720f60b4be78d6e0f4a694358b3f2808c3d646c4dbf210cb629c35397dcded2fc4ee31a2d28297f9db3ca4852d64be33125aea6589c6e2134d4014bb93fe156e1a5d6b951aeb7e89280b976cfe6510b3c493f2acea4315755e295721247c294bfe6763a4bb3d97c26b5d54397bfb800831f084cd2763d99f4b09216b7eb882160a1f46ba4959e5f19fc5236fe89aa2c32f878ed3ec518fad9932afa7bf7b4a07427a4000443093223ae61ef849a7c597efc7fab3f87b49f0ee40c1c223f26dfeb5f0c4a5dc9d6187819ec940e5485d27ccf57207e8e9db145a35c4271a178e29f8218a8150977e97bd0165dc962b147d5707e268c17f723e0f3e2af91d5c9d4616cabcb57268a7bae1a6b2c77da2ea1b9c8569f2919cd4dc508820d1620c4d122dcac0df3172ab461f95a474721410bc6d2a209d6f5dcd46261a34192b4ddd6eee76ecf195864fa6e1ec374726b58ebf8a74680c5f46c1c65176306dbc0043c95c5d4d9b5c3e60ad860a9af50d6252581d400b023e7f0374ce135d1a77e3f1cb6398e40f1d920edd1d1b2893aa1e0d345a3019fc5daabc8eadf276109e362346b178885c962e9dd3b0b0cc9e5c8ae4ef885e355db7ce475f0f4d8736177b94e20eebd88746387bbe6a6c0636653f9ac118baf4bdcda794f741577af8f2f9e1394199f7bbaee9c1ebc7a3c245bfbebceed16f79ce54f4eb978090bc735e6829d8f80d8eb90e76e15ee60f3662798ce04905c49d8be6d9985023ecd4e4358a5509801ad824eb25ded028f976d12ee4ad6a4ffdbeb426ccbe187928e6e7e67e46e74fb43d6df5c22b2d2fdcbbfa5c685b583d0fced9f630a1406ac2ff553293bb70b48b181e5d896f5e476a4084ec8471726e8fe9d9dffd3603542c91f7aa8f5e6cbcd90aa74c62ccdb605761c31eb8a97819e872c21f3d79a4e33b7e020c403563b670c2c46c56e606cbce3a8357cdb75bb821c2607799c31bf73a7b95fdfd19e5b23f0da22f1bd88cdd44d5ece5c453825dd95e2a41df98c318cea5bb9ac9758c800a347157d59db83184f361a7bc4bc55b412a58d35b3c97ec128d507e90b67af40afe859e80d2c45a8ccf88118e9264da038e44bc5405911a328829d40affe86fcde0174d13ebbbe8735766a4bc468e5f26d71b672140145e6980181704ce2783b00be5350df4787719fe56ae3800e7d712790a7022959c61c6092cae0f71ca78e51985876271e165dd7a37b5f7c2f65e8e989baafffd0b72fcaea31c40ac7507e5df7b26e809510953eb61f28c5e8ac4dbe2ea5afc6020744ba34e51e5b3bb941ac6079351d1cfae7c62a5b73791bc6bdcb7c6e5c47b81918fc5133f28bb43befa6992678a4d67765160977b37293f06f18703559d0c9360a94f3906968b902ef785edac0be2dca9e229f37a0ceebff21063c4495c1ae7f6039f04b376b120b7df8d0933fd2d66c597ff6ecce01bbd1c7281f778ff440225637baf8f5358c00528de80e492f335f86c49db00fc468daa8ddfca9d635a31575e1f2ab7eca4fe9918fb1dca4b03cf338117b14e51601b5158b8d67bb0a17810317e7f9f70fe5773cbf412c51ba69545cbc45883669a4179ba5231661b451f0bba47a90aad11ff5410708fb00e8a2a87dcb223e39f2dd01e16c37860f3c8518dae1a013438d11dd85b4dfc18df8112885fe2eb5b581fcce445077592903dc096df38af55da1f8df6d1a8c29b9011a613fdf2629258740003c387e8e8e6fd3e3e6a990981ef9dbb0e50ebedde1361d64159f07dc39cd92fc759eab3bedcc8b79e0518270fed1ee758b5d717608c3b879d6698f09612094285a3153502da2c6961b4019b5d7a3d3d5f21df186ac9defdd4ced0fb65d23df82dd4946a2a6ec5cf57a42a2a7a11e26e112534463ea8ab7219a2e2102d20d8772e65587650a29e49d78f2376e70a64b8931378fb2e6f297fb78a851e1f3ce5789d2587619db77ffb1753cbc68750df018649db0f42ce9e9df8857c624f8076b72b8f5272c7bdb450356a5af3724123eabff2aae61c53ee4c787c7a679d8337e10fcfcf25645a0bd05d264d3261423ac94537a1f69ac5bfc149ab36626c65325a2cbcd19da1cee24e263f45beaacebe10e8e36cb51ea151be6bfe28fbff3d797eddce963288f1d2c385c58cc02fd7380530231a856ad751c73057359d084b12b4ae1a68983629b4db9a29c0b8bdc57347fbb0ca9ef4c2d57b602d6313b8989107a461ea916aa62141c19516847e20e35ebea4b155820ec893f57480c26d63bf1673a891e32a2f204645309ca30efbc8f2b8c8b32469a5a8ee90a9a709162a74f2ff096c71d00a664046cd4a39857d12d7f779d28df792a2857065bd9cf9d54cb2d87350f64f1d24b3f7e7653bd80e9f9cc98d8ad97563550ddebe9320dbbb2ddf854a499de49ea55a716376293f7454cd0207807dd770526ce16602419ebc6eb05560adb4b8c6b6a12b52413922acbea87db052cf9296e17ed8ac446dcae6f8e192e59a715878bc4edf82e42eb84d744747c2bff9cead8795a373a2fe69472eb3705f5a50e7f7a452fd13d99451977357068605df251e82438d28dd55222b957f8e91b1f8e2d5fddb10a6d6cccdd1b04daa2094c4cb9a85bebb243a9ec7a260cc3c0ddd0f8fb9e10ee12e2a59fe811b878775198c435f7fc8ca499985ee81bba53ebb455c0aae365a18c709b8a6b2d92e7eca4f9846b0898c2d0a6662d5c4c01765666aee2a2573e9c9118d670088506be515ec7b87e397987a8e126d41efcd7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
