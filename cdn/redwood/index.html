<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5090c40497295538134cade61910434d09e27f92d86939ed986f7ed032c8bd5b95656a723c32d3ec1b9c0f8703939e8a3611c3ccd78be93b34aaa34ae6a05a408c79fd0e1d46deb38cc6ca6f3957578696be9e6c9f49b5836d1e450abc865d93e4e59d49568c39e4c81bf0a3ebcbc8692cb436ab17afa710859ce6397fa7185f053accffa1b4f0a49e0b0f74b25e59abfddbac48c36fe472c3b854ef9d4583964b813a71c09f9ae2c79ce96111d24a6d413adc58af227a67a986a26a61f1d534a71a4f95e083313cc2b905798f0c45e4ff959f3814bf4bb1847220f125abe3a84b7f3fadf51fd49f10ec1f70802d8b521e568a8a5399b6ae163593d399aae89323a0749bcda0bd98a62b38c61075a8a1b142227f7730622d2ed6489b439f054e78cc3fee888d122e4cdfca739a8fc5b3b2e9fff52e1a6315a436d4ac3d2f525eec6307fa08fad311c2c83f679e25dbf589b6bd3ceaf790f858cf1476ff79d2b2acab3510051db372827358d685396675aaa9cd1aea9e01d1ebe38e4a38ad0ee704041497553dcedacddca9d80f3b337913f18a0883fd1a5610f46c0296bdadc643d20e9d29cd4e672c21745ed837e2307cfae12c5addb5b83836849e2805b19081a0e647eae95da353b13d1bbeae7f7d712f17ef5d49e3ff1b44a2d3c664a0be21a6d7383b19a33f9417ced0e3e403aad581641dcffb32633d922d2101dcc878181aa7aaad0bb4f1046fd05ad309f7c47f3bd374c95ff7bb2d2452cb85027df53263e993aea1b16dc8a287b27bb77ec26e155d323f71d8f8d4b3e321875ab25a76e169c287643c1631bd7301361134b639c8993ebf4445bf9779214d2cf4e10dabfd3b2ff28990248a8e07ba409d3fbb7868099ad494a87d153a34a47cd55d109206e32ba90ec882f04ba53ef2843baf5aeec1db7717c16bb95b6766abae1881f616022096d08d5ac353a0a4df9e1de133e78e965af27df74c102d9102836737af40deacadb942ad1e12105fd10ea4b316d254ed830ee2c88c20751939a96081539e3ae424f00fc0ba951c7ed15bb5a20b299fbd16ad672e8e38168bde3a490c31605db809c33c05a6906f0fb7c3130ce572ef449bd9cb3aa839bd7660241bd2288d7453e6ec2a0391d13f77e368f8be1fa2ce918959d7711e6401fba9e5e93d65d710506a4d65303d74c1d353f4c7d31c98b8238a498a0fc158ef25dda6e04238f235598467f5bec1b9a42951bde4148cd157fff0a4cc270c46f273db4a8c9b242ae21d1b637c9c20338c05ab9fcf054d910cdd015459282cece985b4dad82830e0ec4ac552b5e0d23269cfab0db4d229bc77e0c88319bc5be85f9a3a073f6780b13c91f54e0ff8c962608cf661e41d9ea8110835ce14f0a6c4af6a97d7773be94300a5db954625453ef45d4b3a2435535fa07a195cefc0b7898374f6027a76832fb886288fa6c5412444b3bf8f16c62f901bbd290ae6a2c88f22921410189f7e6994ad4137163b3d3c3615bb518b22bc173d868ec2f7e1feacb20c7d44f1915cb13ab13e31162bd1efe4b75042f3846a64ac73a300a86811b1b95525f908362d8d52fb709d7faebf7999706b061f09de2eb6c83765cb9a6b4dc14019f3229ffd920726bb49870f96ea7250951942486a9675532e541ff4bc0a7db7b42ad81a2f21ec37e514daabb29807eaedac6f5dd6224008a3aa58c0a1b5fe3ae8cde88be42ef1363a1b8009308254bcfea684d3cac31e001591507f612122ddb18c99784506a0d3fe5f24821088e802e04e49b2e3fd5060c2708057bd2b4bd3159f02e14d749ea5982dd8d0aa7006520e4454cbb01d9b0a34780a2b8f91406d972b17cee8a08847065faec2fc1a38c2d74771ab8b1e8c1c2fdd83e8ef93d211d713d426d011dfdc8ed74a39495c6714949bf5e33cb223bc90df27c84ec66e7e0ea85e3023d380ae43d6cc8557bc1e1f738014630e91d869d4d5d7f0f7a513b8e5492f830788f970efe42983e5e4e7a7d21b2a8c954aaa204be4a33f804b18beccff699535922b8fedef269177884c7be9587c3eb076e10fc01343032ab0ff15c97179038e02e754b8cd428aed29f1b1744793481064f416ddb16db56237b9014aa775a6f0e5af89895f1d2f83525d1f927ca18fa76626d5927e1b9e9c3a16bb1e66bf3bef3ba00ba87510d7416b94416bf124b5b0bc4f0a7f1939f8e659c05f84fb63e2b8fae0c6143ca63e86f8db24116716202dee49a715395d62ed88aa8f63add10fc46cfe6f7533de6bb6d735ee1d185a9780635811898d0f703d13bf1f55329de4d9abee2cb239bb5c55d2fbfc408421acc82760fb9eae222267985c98624c91801a4ab24ab989586704b8dbf5519625ef575934562c56de09af2f27e84094b27e25c982bda1cf6c2f78293c1651a2f495278ed051671adde1c5df4c57fdc7485168e23a7c75c4512498915ec7faca86f99e25cbdfef8de09f9215c98259ecd3ba4e0ba21fb8a1e7c6d3fc07261796f807cc85ef4950df9676117af73bb84ef945346f3d26bcd2411aca8f26bc4c605590c4e55d011097d8b89cc7b67fc5934b3233b4711e036b5957f1a1a9e594964a6a81e09767848dcbf5c471e7926b9cec3f209e7e163f12f5374243efd1cdb0592b1f01fde0762deed1ba9575d19a87d58d7f3a1e97fbf77b1875492b68389fbd1f131be5e572130a5c3f9a5ffe89f2eb4f648d26fa93f56c64189a5c177fc5d4fa439edf8687ca09b1d52cd4606952cac16ef2f5dfff1a2914dbd728cd2afb8b90eec96a735bf558fe8ee492cf22708a3f24c0742304b84e6098782109bd5c34afc9bb00bf16bc50c3ff48ac0ebaab0f35b7e723814b4f6935f5d5d2f4d735f591a9b3e91df1115b896e8a72bc22424508f0611c23e0d91088b58b7f0260308f4d7afdb55f83c9e2d591cd39ba04629133d94185b7ec9e90889853f1f9784dbf9011c4c10b9aa0ff59d31526308181ccc02ff002874e57ac74ba01ff2ef0f44f992cd38d5ca303d4bc88e909fd125796393d9ac578782aac00234d9e7b512eec1d267ee3252cf7931acf8650d9f4de467cbc46e48893d484d8f31fd674c69f661a0a7090aa8afdd7b1e0cddc899d2e73bbcc5c3a18fb75907b9d9343243fcf878370993387e01ea38c41b93e5b73b9f7c48f72319f8d824f3aae98b05ad563edf58b759d566a42d39438617a40f95a913aa0222e1bf28ce3c48fdc5281e6dc7679dc063d99b450ca4cb441538a3913b72a8b0d44eb26a273f264d5e72b2d2015ec43badce65dd5aa543f41192411177fcd427d115639359c9e2ec37bbc40de660ed384a5a4a9ee0f9430f0342812e6ea0d0d3a19b4e1d4adc0dbe57b91e8b23f2f336e981bfaed0e9d13b07320b0db5f321a15ffc1d708f55600f338bf7403e68fdc5ee9b20d21d9c6a1d0c78651279598e1db71ba3d196947fcf8607f106872c43519e9899949e85137450202c838c4b36cafcfb505832f890b8e2f84845dbcee2aae33b91a6f964d788b7cd99abcdfe9e6485c32dbbe1cab58672b803c5e672984eb1c3ae4168b14aa4092f2eed224f23bca7017f3d596830a577205b6240f5d3e54a3338687045676fc834a72aabff2d66bc7992f25d4eef00e8364ba621fd41b4be09c5b19045952daeaf6f4bebe84a753a153bcf248cf43882aeb718d0ba2c6fd67e5ed8de07a90055889353a479468910435760e331834f8b9926c21fcb209f60e0e5d2d04a2627fa9790baf6610c64eac6761c6ed5897e0aff3af601b0a098aade821cdc90226e3b8df3cc2507e89456f722323a6f74276007c2653c716b11fbbb35581e2a9705b573d4ba7daa08ad54bd0bf5a961f6e54040fdd20a709b63c9b946a48948a6893dc498a5809e50009b56ebb4554048e4fbd12e82fe172c329433a97a5dc104883f8ee8c4b1b5d0eadb29fec326d11f24ff3095aa9c0602b09dadb5b19aeec5849c203ecd5a4c0c2ce2ea5130d7537f466e8499e4c94344c15e8472081e44b0451c6ef33ce7098d598e13d7a7f17c277b03616f9157fb196315038064b39f2547887796200c1dec98af9bdf836f5b3b3c6bfca9d2d6b95e71bb340c7bca413c33985a6ffeeab141c445fe382813af65a54765ca64036d1e344c47780a1ba12f345c5abd1eb1e882a3f91ade1bc36ae75ed35093b5114f7cfb003e6b161f446ee3b27c65ff9402bf6654b85a8c2caa753f67940d353bfe68bf47fef4ebcb2768e69a27d0150f37f72250e7e80f8c7af777238c64de9913f8ec5711edfd10d5e0b887c28600bca60643d5040dd08be4a2a926acbf7ef5c98ad9008166d0e78f07cbeeef7df40502b99665cbdda92743c6b1e9cef843ece99eaf1915f8d10a4d492f4d29722802df0b1d9d76649ef8396a3564cac7cd65ee0edf23a24666bfbc2e2b90d0c78fa1cf29965e62f03212765d1b3845666c7699bdca2d9cf9cd678610d097022f334da7a09b89837c377c6288bc7cd6ab2956a2491ae82f82c4aabe4de7b568cdb7a8bb2aa0b8a5201048406760cf8e6fbe510ecdbbc4259a7046df23688ecc34954fc8a842c2ec3f15b604d646a1772dcbf5851fc4d060f7b1071d65548d1ff59c00840a8e7c7ac0622b8305470f5e7f23706b7b3615f9cd7fd168d99da0c329382351a20d558b930833fc827cda8910d839a74a6fc4707abaf97401727b4ac7e73e6dac485431c4a57392f98fbca67e2184ec60d17db2c28aab3c25e08d4fdcaa6e3d2f883740b2b6def0f649abead922cfb946ce3f32215cfd7f21d78c1fee41fbc582801ef3d151bc40f26eb7851b4b15a441919aa0c19af6042686aa0fed0029074e3b7cb70690d7cd3b72deac25a58ded9b494f28191fe803705a232df16b406f29371e060070b74a0636b62c83c3f96c248585fa9e1e41dbd03fa104a49d943ecbf24e9853890d2417be6ebca5c177f6ac1eb6bedb08a005af1e626bdfc9d9ae66cdf2ec8b7f2d9ee26d9492e3df4aa75a645e3028ffc355c44d90ad92cf49e7c5b6d3940496a6e222ba06e732031ebd25dc44f1e1b68b2d98fa7de83d122e25782e24a4bb4ee4ebc813b3bcaa3abd9e84e509029eb6211f92411df9ac38e6e3537af580a3150b0c78f9921e8b89f1f672defe0eec1b10203aa37971d3110bf63187f24038baa81504117c4a3aa08dfcf6667563ab2757bdcd9d40b23493f65dadc1072b84dfe7c6e8cb068a5a9fe77cb7532c796eadaf15076a2d2e6d27c1fd64681382f9efab9dc3e45f321a8a1388f3b059411b08b0b7410f78fc2a5e7a1a6844d8a487be9aae72b4dbe1060d13934623d65ee7a0fa510c12a4de372a067f022004c88ba232425d0eb15933eef04afce321a2f53af30d8d521e6ab3cb34726ea5dde48c47c9ce82e40edc855a44588c8555a4dd5e2c8a4747eb8251d146e534bfd4eff49b0373bed34182bcdd0167d75b28cdb038a4d786eb6f52b5425cf28b3ac8b3aa004572909790d9bab8d288c861f3a60d0ce5c70e498bf6a8203ae7bafb02eaf3db69f0e48a017546551f8523bace0d1c1b93a954a85ecfbdc49dedc551a1429aa9c43077544052a95e4e5194f7ff90b53ca96cecfdc5cbdedc3fc54480a40591b9c3045001043902b192cf53e3848fea27ad701bae675d838aef2baa646f3994e86912b7ce96f921d1149c32c6f6927e3717bd78dfebe6d6135f1f6f5d3506d957ce221041d41ce3536574a944a6678c648aa29e4d259b7b8ece15c03f7851af705cf93cfdbf4e962f6e83b5996e380f372a39394e9b07d1dbc90932c30c5d70034d084ab7834e835356d5f7ab0105c87ac8218758de6a3302f8a816b8a425254cda25aaf075a4ec50d7bde17052bb78857b1b5e584875a9c26eb5cc744e645fd1c505ad0cd878f3ea46df8d58add6ce13bf453b19de79f17005b8cd8186c70b880fed796c190b8aa51b254b3510ca9e6b46f8a46bbf4d7344c8aba939535220013d9b215f6c539fcf0baeb84025950a293bf000faeb6459bf4207f91ab56e048123b996769e07b7cc8ec59fa06cad91ed876b047278319870ca406b271db7e0d61071609bc020d6fb3fe554f935b380bbbbf40035e37c54654a43506f35aea229dacf50c20fd29e6bc910126db9fb7ee901fec316f89384a2292d1b27b1af7735ebf7165e179e8f49688e163080dfb931e253b30cf5e146ab22351e4205388aafafeb2af7be554f79dfc4220d8a9eafb91e1bbcd17745dd84f4883f6a563a6e7a30f9414beb68522fa5e3d9806565652e150b162a1ddafddc58301286fe30ab26c068c22f8792991fc8d01206e713644a5f046dd5149775ef27e1cc530081e5ace85fe428c7d93dfe60f3dea7748645fbbd9fa60a84fa34cd4b50c1dc29dab585f793c09a6d50fa22732c65637c51a144c3423fe73b4f92e2cf96eac846667fb88125c36ba4d59e37be78e1f9c9753aefa2d925e475db6c000bf019c4c6d88e2ae5a43a3dd3f6cd87faf01691b82032bb0bb9b5d99c821451f54bc79c01d8a9f54abcfa3383662aeb2ba338318b2a9b6aacd6b4b66b50657a72ddcbef694dbdebd4ee7a36cfca1e0bc1a8426fd081d9caad2af783cef0c1c2ae6be17ba272f03ec82cfce5962462b6da5893c8da5f71d28bf7a0486761a026cd4e8d3380d22ab71c496751a4b27c51e3438537f42b26580b6a73322d9b55e62de207187fdb7b32c60b15ab6efac8a0530d937feaa316af22ca1c026cbbc9f0dd0b4338166792f0aed0bd3be4446e29f0dab22fafedf54ec6b42c21f04cfe10034494d513f339f274c5e9aeb93e3ed69a93b3a6c288153dd2e4b6c84edad2a9693e425d9650b60dab9f3ad154ded80dc4cb5bf1ff63ce89eead46b7baa2b90d87057b463e0dbd97dfc0b7f946901105e9ddc03fc333f62a5b47b0f4392f8fff58f5d0791768894f41c2bc728352ba6305b20665a5a76c9a441486484b3a96862d1190f451f8af4e8c1e9a1df36d16c4b61fea31841569d1678431c7834bb96a3e40dc50472943c46be0362f908b8aeba19030cd12c0e9e7802be366b379f6b4fbdcba95541dbc5bc1feb0cd29217ee60123a111399786920a8d89ada404d5cb830632366ae306acdfb3d2fc3d60f1371bb2c382bf559eeee926e872c013948d6ef447260f219038e8369e35c02c7d2568a14bc63ab365fc58377180226650799954b1441f040f11693e7585363d548dd3d5d0b36cd3727d73e991c0f8082b73fc1443bdc4869ca9f58822bb6d28095061608cf4efcd61ae2130e5f5fca19d13d6bea83d6fec2733d841dca42f3f4c9bb15e326b72ec0e99c972323fb6b71515861caf6260427c475104dc9cefef4c3bfa3ba30bafc7d3eb30f69d6ac1999b2a17c5a2160aa527696dbbb6f319ee76546f63e799d1a849040df112fc007985817887683c3f75700d75fddc90223c4aee90789ca72380b354918dca85b9917de2ad1e2a26da3ad9aaf62c30f9d4fbdebbf3cb6263710da6e4917951990cb17dea74b1aff50c956e39d10200d83a867924543e24753abcdbc4795b208a8d24a71c820c619ef0ab76db94171c37ff66d897bdbc7a0be73870fe2722ddb275dacb3446d2cb97a38e5284ddfeb04cfc453dc153327f3850f88a2dcf130d43daf250e5bf926741659e63689310f3e898d3513841117e54da52634cb7e0f42444673e070f0a1b455cea08f62249a8a61cfdc1e9548e0bc71b674345878a95636857f0ca4cf4cc9e26fcacfe01ed1f0db41941b6be25f10313eaa0db8063549d12ce9afd835b4d6fe98c37e77cde70f8f643673f0ef8c8fe612beb2972db6574bec3ac6c00436d5d3e8f1e48485d176739a930e6c63116f91619ff08dbc772b3a2ff7f5079b51072d39d7fb451902f95b48917fec872ac0db111a790f692eb31b5bd852ccc10b94def43884512144db0273609786ea3ae11ed7281b16752146f90ad4b914eb5751991b28ba0249bb87c4e20d111d80a16bb903d46a0ef60a2b88e270dd50af42e14d95076959b017fe533190c1b4cb677265700d63965fffb1bc646a5f7b2a9ff73696c64a0ceb506124dffad7a3ab61c991870c133fc267ea8284644f3bc12f7b5bc5a1b5d98b775fde8167b88fe8b51874c9a682279aa6ffa3ea810451990cd22353198229fd8586f1f739a8cc92725f0d20b740b947fe6d68aaa1f3ddd14daea29a3ac0b4aed3d9666694c995869cabcd1916fa50144023ff9c50410d8401cdea985ff711d5015475eb9284aba4a7360c28757a2dda7458f83573f24311605e071b2b0fba61b450604a34e172f8ac8ca0e2924fd4274fce51adda23ef9d15db04ba6ee65637762dc07ec1d331d07f35e00803fb7bd26044f5f84304da5c7cbff91579b31d41553e69dc4e4b30e536f8f6c53e162f2701b860623ee0e07f18584e3313d0458314e27c8b36bc5f072e879b33fe2c89f243b6fc961c0c86678f2333237cd7d56eea6348fa871393ee63161ead2ba6a04a6f3c41a45f5c3df0723262087434ec64cec217ebc77cc335d81777377a23c3d62762f3d80208864ebdf40883fcf2a15c3d6e9853f6d9c1a3778e6f34d206f4ad2f90cfbfc59980cdc03ee24dab810835308f0518d00106451685dd0a09b8f67d872e406818f8c5c76284ff5fb01450e009e09b05b9717f3b408dd9e78d79db8469b8666e2f617428721ffe81599ef0eda5a3f1d5a5e7c7874709e5f811bb40fe15346d2e54fe0467a4d23d0499bcddaba156cb10b55c9eef53a3511647a5197041bef07d6851cd53e4c2a6a16f741c662cf5fe33c51f2dbbf36a3d819c6c977a14783fb33c7f11f134d97700ef01810316c1b57571d7c4589020e4a1b1ad868489a42c119ee87adcf2e17a947d85cac98c5bdb28f1594f0ebe5558e2aa4a101577ff8d6c0ce8ab95520b98a323f8e334915e1457e898715649d64658d80b57a818f1e5b26986ad820aa091f7023e1335793b4002a998b3acd324703f7189c97bd97f6e7751f517916e3d17bc6ff137a81ff8273cbbe1e8443d113d50da07604867a536ace2c3430558736d44ea31ca73e6d0a9908a44700aee69db6548c949273d3aa5b8f2508b6a47cb09f3d6d755069ee6d0f008d8c6aa37a9313f11c4b8b250c27c505323931540a339c724f23ffd69cde2e0742b12f0317696fe77edbafeac2c65f85e9e6bfd6af1ef7494f49ba5568ff3a196c67e06938be86a1b480d6b1f9fb5ad0759d2a4b5f3a1d76bdd809ce0e75d0c78132086f578cff209a674c844c41e6dd0a694e9d658653a09b56c3967188c22a67a26353e876b7b05814f8379b7d7f4264e6ad1358f734c3d2daf23536758c3c6498e35a7cd83f012ee8991a9073a267602c29fd23b85ab3be23c7314f39e4c7cc0773d49e7df22cef18ca062df4c63f9da7e9c97e80b5e306f496e674be239538642b6bf56ca2a15e2d356b450ea83f97aee9ea05342c65553e7159a9c8e886c72438f5f3e9033e9e84b5b87fbd586770e80c5fea20e7e2016afaa0fef3c37a3b9f32b03dc81c9d1ff96cc08bb8739e03ec2f6c78af37fdaa4da75af6416a2aa93aa3a5546760b73cd614a5545e30355692866692abe9542a45a71a44f5010551b3b3af37aa67710e87d051c1824b4d7759088d0f39fc000684f700b8ecfd65fa04e6b1459e1ea5ee2541b45a028c77be718700c9c9ef2a02f2c052fe56d1b9311061008df9310867ea0d4d253716ccc2a48ef15a7ebd532e606f137d7b6dd8e66243877a1941cba1432561b56d8f4892645d136670db18c2c173f97f0f52fd2c20b02a184a8c4b37ae4495cf184c87ad75ca50259395f94255ab0c6ced4f1ea83a7502992f6a0b4885ab961e821734276b8119ff80a80607b9057e6672e526a708533f8f2fb123e6418cadb72521037adfb641e2f168d5c3a4772a5b78e63b4a7eb4cf5efdab68484658cc6281ae1b202e47b2daed37d92f8c3975a60ca76f89209785db7228b19c531958090f546bf55a508ba5ed1bad808624fabf60ea52cd5730fb053f41c8684c89fe88153a48257684eb905fda9dda45150dfc998c48be092a7bc00c8a05cff121b47d03da9e6032233030c943fc40ebb85ccb5739c178a8b5536693f4a6820176030f3e3c53ef8e9fa0732a4992c192dab59a3c3ba54fc78444f5ea870211f7ae08ea7737e2b125abd8258c6a25ed3770bdca53a36ce5a8db9e576684d95bb1d830e1e8ae9e509582301443cc084bd4686a300bc49f8bf2fded408d1cab2901981611116f92c5093998c2dbdce9fbb7f1ed6e9d1e77bb4dbaa97062c68363705e1575d8d1508b6f831b4ec7ff912fe990f2f7c90b1e16df537839b8c86444a38e3e70d6c040e7f82cb68734921e7178ab6bcb13ab766015639739a573f76260a506371b22fdebdeafe705138bc7c44737e2c4622d16371c152eb93fc49d06be94409b38815991ccb8fb6691f51fa3af7a38673ed0c6d269891e3edde1fda071d10114b4dee0920d66050ffdf456b1331ca70778eb8697d0fcc851e1abf98a9920311d7a13c4c85edfe6e0d79c9dbfb508f5395d8056b5d6753410d7f9aa29b43a86d1bf2e9103aaf83b896c578b5f54b405ddef3849d8b51f9fd0b88d0e8db94fba08841d35e9517d5933e75a774693b54414b0123c7bb4414148f016c8efc7389291ddb45537e957916f5ca0772c3748a6111c70f3ee47aefd53bb3b44028b9285be33ea60504b3cfe4a81976fc90c4308aae979a245e3a9d1aab2a5ff7e538f341a6ea24bac92d82d2707b1edfd18ecebe5a60a4a1cc12f45db07264eeb21f6fd0286f91dbd81e2c22be1d819086e2479df9778920ef8fa60ece4d29a0e6fadae8c7634025c98d8ffb4d2bfea5f7eeb369d1a76233da274fce69c9b7c91a88e0f3de0d43fb0e992b20d3f5adc1f4deab803c0b6463bae29f40452d85f3c6240d3bbb95d79f1784b11f6dd9e1d47e26b4f5631a99b66e1c02a411043d5c2bb73b8ef97cfe91ca6769842b1a18931aa5dd68cc4b2c9e2a88fd8040e8bae5a979f4baeb40ab530d7c8c048cb59b3d6c217480c09694f3e7933115e7abfa0f2066a10947c77a3ebc0dca5b461abb0a36f523aa39ebc5f846a91a477a59b55e0ee9efc10b9733f7206c67737e6027fce9143d3af2605ef9cc889b33de47f9b0563e607533f05fa2ef439464d4650a0a8233a7d65537e4022248814df36e48dc2c2a6ccf49be26e98d2dd48674d4842ddfec8acfff35ab685119effe2e432d76ff85e650427cff3de916bb38d54e561a8d158a6453c7b8fe2bd1048e0e321f200de46e075c77a072317e6486732dae2ce969c60e857a88f09926df3600e0a8bf74191857a11e0a0e9cfa5ee343cfebbb9771d03802cdd1967f3f8726780bc31f33f79de2fe48545a452a18516c098abd7c4c02c2e544450cd345149b9daa44ddcbae22d739cff7b5caab8ec385266f4ae5dc01e3a3ae8c614757256eea2ece4dd07abe82fcee8920952810985027a4c3e6e982e94e500ef1c0082eb591ad18c1c199a9d1a7676ac9c635f69360b02fddb19cb683eb0fca4ce74610d8ca4b77c10d015572f9d98ab704a6dd2dea4e36f70968743d813610ec1ee58b6a4d51324eb1b6c16b3d58b77f3ad11c48c189c6c7d5c6426e0d294b0f70f6760d7a1f65912688df82cd660ff2443f231ab97bdb0277a84fe2e24340c7044f85f9a1509d3fcf7eaf5ef667c184c9fdad07ba9eb80053fe0b8620b07d700b544deb47fe0cdce05d2fc3fb04b5bee9351cf18a88780f46b7f3182e9240034673372e0682c5f16de9469609445f2496b5955f912e6bf3a29da2709691108d995b5373cc009b751465fbf08f05879c3fcb5550ec96a85e9c6f2dca6bdc27617b5714a37f75bba12ea2c50ea0ad2ecfe0a5152bef79f44db47701f6ef2a93a288c35aed8652df03bca2a3cf9fff9b108bab6f0ee9b1d688b9a1264f6c97db7e1dab7e54f2f26972e4980fcd4dc1ebd63123aedbe1b61ac9e76152ad7713b0f57fea032c60b17691057bf304c01e8e07091c129d51fb62921b5dfe574b48bb57cd2838641984b202a152b8c798a8e243cfb98fe62fcb32f14b6d9b45ea6c31308f1b4a0a4bcb066012517636c2604fa4ecfd58e020c2642a9f33548771ef9618a688482ad941f26ec3ae829fe8b3aeae0c6b2caea7a66843a11d7b8be13130600af93fc613317b6663782a02f888271b90f727c01af843020ba4a1bb48f1e85586b1f07500fa4b64f9c6ddc92dd6b83cf1946807d9b1f01db807aaa4f9c87cf9b7e7626ba11d666325b389a2f2f672b3398d02a30fd77d9aa89b4d1e00affc61bd8ff2802500086cb9a45a8149cc3cb75d8468e7dc49c92ed02ab808b9593e082d171e0fbf8e5121d71b414cd93597d66d9a9247d66eda5385ee0bd371854742debf988a653e261b838f6c0b107f28b0480c0c0af3fff00f150bfa6e799d156eaa65ae756d575dda3a1802649958604e1cef2e76a0c080232acca7ec1cd6a1b3d53d14c03f113a236bbc7ee44c708c0dab348be992fb9ed9e68a4287edf659ce2b1466ffaae070201bad09e54a43bb20c8574446a2a2329ece21cb906d7ec1ecc8feb3ce6146fa3484cfbf045ac202ede98c840d1f1c62e79fcea410145e4a6947055e27602fe439f228ee5047c17ad863c3357ba7b39f5c6276b70a41934b9e8bd015e0b4e7a420829a464e865655224e1a6a66f19ee2e36e84d34644e12da3012a1cc85d4f98f99e8f010a262bfdfae1f28c74a8f9a65e469ffa48f9a786f2efe7452b41c1dae53051fdb76792b9083f2bfadaa4fdbd0e7bb44c050a6c0f3f8773edca23691d6cc5824df57bb282c84d5f04fef19cbb011cc70f81f77d1bca8ea50f6936814d0ed2a13f03df81779323f7728029df3df719debaf2db016627ec816ea1d3fdc7bb9757c4df9410d836076d3e963765f98d7dbebef637b494c612deb950f4611231464113756543a983a3b73cf7b3b222c6bbba4a54f102fc1ec5dcd9c3729f4c51bedd0cb249f06422588af53eb5d711d31562e26945d10e10a409b34269a4bb956d737905253ed6899de1126ce7adef340aaea4b417b6d961ca934081e287be85a57e4b0f705136afb0a953bbe17bdbcba8271e6d7fbd84fdd56f669c1ba1a300eeb5ef0963e326f8a3e301bd47467c12491fccb8c469f1f5d3d789477b56d3ae413ecb4d066e3bb27e8215b9baf24b6545589ce8d7d6848ff0d1f69d8bdece93d5588c2bca12c697f715193902b34ba4ab493d6a5cc97476a952f59dc2c7d3b56b6fc530de0c695411c1dfeb48eee6a7b1b110310e7e0a08d905adf05e6b812298f3e531b8ddb9618eeb2a9c00079a36b38fa713403e7e6ed48b0979ee39345723c06bc97210e8985f8064e326a25a80c406d1c8734f58b86579e91489ccb890c4f05dec61cf5ff57355590460da7a805fc5940b1ac87a2ece88454aa943f25e2b18155da4177edc54d29970929ef09888bf046108559cedddcc569e1f6c1bb4f79df06bb565a08101ffe24cad7bc34c1e057c167dabb67481c2a466b5729b4e9eeb170368aae961712bb21f0a134104a4e0093a5d60806cfbf0ce8de8310fd71283cb36c65ececeb3ea3fe149125f73580fc3c91649a93ba37067c53101d7f1ec6afeaccb3b141437e2c665ce33dd8f278033a72f12c46a0f3511e254fa51d7e9ebaabcf0476c43a39ef2b04020e0ea81a9ee428c773efc0d79400e78086b62f973231b8baec4138f6e235f8954438598f620c39df7d29515423c8c963775d4dc303ef89fda644ba050336d3474707573615ed9f6381d043e16f4ab81ff4d130024a349b223f70c79aefbc24ab9687a72d410294d6a2fdd0e94f8af332b10db3d44f3b4fe7aa95dabe37bdd02a5c9e8a014e81f471636d7bfa4592b05c837414126b8aa25e5fbe67c36a8df106c79a9a7436b6a6953ead2d578e6da43eacdd415c7bde53fc2a843435cf0234f84f6e40ce74bdfd4eddeba6342c23ea6474a25942e278dae4ced2e40c787007c727be9f75f0be6c555e4c9bae11fd8bc5cfc1fda86efd775942da9dd3c3e5b39ef6c76c2cd603585b251f38d032a035a789439d037ce6682755a64a5edac472ba6ecb59f2c909056359cf4f1f4b2b7b588be250812dc35157a39c0bad4ab655b1ca4679656907de00a9faf1d2a67e4bf38fdecba6ef78c486eebaf18b9d96a664084989ef50da7eafbc3e440d29f96c62ab8a6f59664a7bfaf8be50ab63fd699e60ee27a2ef3d4c6f6286d603dac1fb93de851b260ca3a082e07401cd21060619567b38515e07268338dd98e6a0cba60a344fecb95b80507d19075c78a157f113a259e40ada6696dfc181ea1b95883ec9e50dcfc89519b767f1dd1c08c672f335d15922fce515f03060a4217f0c248363d7649959b37b4c2845d8dde6b6ac5e2d009edf38a2b8664c5bf8ce84b8772565f10bdca1c0cc2d85f4eec1510a617563378b1cf5986b987d1b99ec3dd52eaf68c9764ea4e541b83f6c5cc7b1a3ba79bbd5dd34a27526a140a66709bfdcff2f8acf2ed9c05b6baef9d4e6a93f96fda96e6cd49f37925a18289459c097a980a16642db90ede04b3892d81f9448bc652377aec0815ef425268dac0967bb2a1ec617bf2794e0a1b73407fe75816c88e91c1acc2af10fa645c37a73bfa2206a3a5d0502346bfee290683bdaba08bdadf5b65ef6e4ee258bdd11052dabe456c2a2b877e5d61de0fefee27621311b9ce8149227e0b3f0c328e61ef96589e38ca0b0e6617ad56017481ae2d7ca7c917c47037594cfe47d520f00352bc5912c03d2ed8300a55e5057935272f4d2186c9a8bc578603d15a54f051a338fe8ae1c679f08be2bc5ec793da3d898e4342f18a89ff56e39343bdea3be5cd77f2464d03f0322dd0cf8b991f411440cb516ae43a6d490b9d6aad11ac1cb2240e0698ba605ffe8c5b90ce573da6fdac62ae20404e5c7b4f1f67a02617471e4ba002e9b7c94b16ca1013f59388de8416e7583c376e8a51435c516c9fc7bd9a3cbb1182153e69df7aedf635ae87f0e3cf84acffcd28c3acc489fdf90bc34e8a513d24d4f6a87af566b02873ae1915f41fc23850d8cf8a8bcd8956986981a6f74c0b06f106c9fa7f2623680216c8cbefc89f98da40d0e10af5527628197c21cd46fa0105cfd46423e648e30047605dfcf22b4c8893bb7550a45ffc75938e58699ecfd23efdd4aad4ac25df1a081beaabdea0b4eb272b3d0fd6ace9c79d960c84430f581ac6cb45e041a0782150a98f92dd09c5e7823aa18fcbe2f39ab851f91e8e0641b4bfde7beda037e5b557a391cc9ee2c86706e28f4eb91d533fb911b271dcb043645347ec2d3fa95452e7899904de4ee4c91077f27e42c995ef3aa90e68ee47d2f77b363cc97a35405bfc05de01311e849825f96beeee0a958fce574c3cbd07daefcc1131cf902029a205adc6cf3058eeeaee22bbbe0a4733b4f73a915b45549d2d7aa8cf45966592e0934fe7c850c1c1339f6015cb69020d2a33a5c9003640368c9f4f81e507c6b4b0dab3ef8f0436ce240887b4cdcec10f3f223e1050605558b78e1546893241b993ec813121308ab6951165c4e64d3dbfbbf430e448fb513db2a28aea9959faac64d7c543cdc0e9f3f8cda6ce222699e406b3ce579f29d8b3b414ad9bc5c578b0aadf14faf809697d047e2ce7d0eadb4c3722005a3afafa1da1c90a8a8891a4d6342c040d98e52adc9829708e8bfde6c2d689f648d10ac234c7b0abf5c47bd3c563589412aad7d362f3c4e7e50d00d2bce1894a0cbfc71b743668bb85c88e00f21e8e61388539a43cb80f6710fd50aea9943928d1b1038c98a8b965eaf5b68b33f6e52bc5bf642525816cbecf5f8b8ae781c91309fb3d97931969136040dee3a3b20c0110fe4d43bb589d10ad0faba6a17f230e9f5dbfd20959055eb84eaa6b28f57796b3d107b78af4d06b5de4de940f35688753104468f0bcb966c2d14e603aa5feb36973ef540fe5f95196469cc185ae6183512b8afabc6d71342264c75c1289181b0b0fe43b1d4c5b135dd6a171d6c35996fd593bbfb7c8c4c50fc02763f121490048a4c3eed5a3d853b2eb66c8ef6519145fd9f5e11f465df2c5719722b84d0dddd85157e6c131c942c6e23621d88dbccfd4f6ce2d4ba3043e67cb398fb7ad01679c5d357a722f46cb654700a3202ba9ed5ef7d1c611ce1f4c4a1acb39ba74ab82e6402aefdbb2ed660982fc01ad6f832e9b5f5d08b122d107d5bbc20bf397ea3b0de3671a05a6e7f6b011ebce653991fe3a7f275baf47dff6daac436cd6a7f196ade5fe27e4a5adcedabf2519fdaab533213b57f7230199eae821359a76ef169a60799e6b97486a22a911cbad524edc1497d7e6056e84e132412ff7d97b0961107c04983787315d49e59b74c19f6741220c909fa07602e4939e16335f7ad083f3f5d48f87b69ef77584598f9b331e77a97770aaddf45856384c5be991368fae827729cf1a379624fb5e6d01591c3dea4d5ffe3a72dd1918416d3d01c563fd3843fe26cd42a1c56cc4ca1e1df8869be3bc84f92dd7ab0c8dfbcf141a01ca59a0bc91edac68fe7cc28589023d989692d4df36cafde2cd89607bfccc6e9458ca80b552d81464b28b4f52ebb0e325cf9e0dae4426969541f791f6fe71b7328def4b110b6c31bbad51bc4bbac88176202b0e363d1fcc0d1be45b9a631a2ccf38d52e37b46ff1247c9cedc99403dd5e90a33b8eaeee6256b2402ae7ab07bd32078a29d9ad540e2c14d8134411439765f3687eb17e57814da73f881558358c3e9de82ef723d1105f3c43e98e0c311b5ac7b1f30f89ab599db0ec6821c971af0b5ad0250088e38f988930e97dcf8bb29942447ffc99cafc3d1795ed0e0e8d62b3e3ee366cf8413b670148e07da6d84b644e5a17b3635c1bab08c7d38aeca16d1198576e14089559a5699363b99e9058a736ad2fa0a852da54d3a40e56b5006e78b3f1c4fde7265a36cccbd8f74e5863ca85c84798d169f73ee36233283cd6b863770e3c9ed4a42d020ee4eef24722b854f8e7650048de7c3cdde7fde7d798a53ccd229adaa5b8701739b3ba2eff26b5f4a3f154a9d91f81b08ccb0fcc6d34bff0807983d62d68fc6ffc1188684526f3f4a7cab9b93e25a6cd95993bbbc6a3ea814bec5e46c7017b2abb591041c5b568bfe2d955b910ef225bf65d33a54f19dad3db60a89ec1de05964e3d80002cab8bd97315a2e600dbbc631796e8bff5aba1bcbfb475daba58c057fe4699f7899dab0ecb35ddf145c3b015b2e44964e3296a8b37754f0075bf603443b6c15e834bf628296da3573e1ba531d198f31d2b07a40929fcf679abbc7fc246ddaf94fa15175876c27d296dfab06a8a35be3197c5f438ae6e52c7f8ccc61e0e47d8f0b753683b2bd84ca410099517c3bdea6a9b60b3cb44136ce301861cd1abefe23324e7bde82dfdfde88ec64724108a5ff6498ac88603de5099ff104b0f1936442f26e1ce58fbb18ad09026941cbdcb47f218fe5fb6d834c8ed267599b8b9e214e29b88487d99047079eb9cc308430df0c66e5f6d2e0c0a758ad81ea81c7e10f64165b2d04e156d80a9ac30752201de1da4eccac4489006b37382a803551d782283c5f7a8b27cb5a1dd972f13ec0ee2def48566330340439593623fc3ba97350adaa56e505b5186995c551bbe397ab1afac3e7b5fa49ee4d1798a3bac88d32119150e192fa668482740e696af7fda7b6f4b480173134259d7c7adc6a6dcc1fcb4dfd0df8b836c57fa8a93599c0530685aef7918a74a831ec2d29344e393bffe6657d756a4e812bcd3d3fd9547948e110331ddd6486e6edb5af684a6ca19e2542cf1025248ae5bab4d938b1efae618eaa302bc1a449139594d1012006ac07ac70ce5a4628a97ccb533761e8b3cc4790428b26e7b80a13788480adaa3b89dd8b2d6536122c340c4f7eef5a94d41650ef5f7664fdec3d801ecabd285c385d456c1224280f79","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
