<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24d0f5d227ae16126bf5af92a5edcb4b6717e1c4868464711b2a51b81991ee97d05be7d9926e8bdaeafbffccfc1c316b1cb25b3548f05595f74b9811474579fefef59b34367d123fd66f6ee547ac1d66162b0139a9e5638ebce2494cf28fb54d17b9a308fda50bd91ae76115be2d3d9463c4a314d43073cef0431746a8f719f05acd2061dfff23fd9eac0b12428053b5e8bd49905d690af829ce67fb44488d143a999bbcbc7459916d94689f6f0e2e9078adc305f4002890a49e2c004b98f8b48fe3dcb2c231d6a730ceb8960e2b26af07ee6f3b7db66fc965a6ad8ce68f2923fc8cff7a2226ce4443396fa14a94e9161d79f1bd1810793443f29bf7237fe1a1ee25ae8ce1fa4b8bd000357139a79c084ce678a033002dd00a488f85d30e99e0d9a4db1ed1336e1b135dacc4d7d60b4fa51b64f905aec02f35f426ebeca8146543e6cdcbbb7d239b8a14953027746488385223c681fac6343e43c83fcc25866acc21dab8f7b8c97f6af1e463d9a0cfe2d14cb54e6d489079e23a9e4ee3f4508676ad367a6705226fbc2b13e4c4f60500924fb5276197d0fc1b77963b737ba3c373e7e2026419c9d5e356e070dcde918c69ad8355900c01d6c35f465323e9cdedcdd77707675f6da34ad2701f72f42fd9bd4ba1b1f10075e1da3a022b3f5c532033594f3cadf43ea8765614791a43db2e6fdfd8225c876364068c1b0050d59a6ee4a26378ee2b846b357c5229a65596349f80888ec488a3a7223f279a179becc5bb7af211bd69d54644f5f0624f53b5b2247c831a479af042287c713c267e1b58775a852148f63bb893aaa47d86b59d3a51f44a0e45fcc8300ce1c444e9b0186ddd7d42716b043e3d516cf339f3ef09d468a09133a2c5d4dd98653b12c2dc778aac09274cb9e755cc12d750f2e9d06fde6359556e96281dacd720af07c8a7690f16a4100dcee6f35d09c9cfa1da24058340f68bbe6ee22d1a997a069031a650e9817893c143289bc47df05efb8bd6c7ec38479bcb6abfb9251ae77d6f508a27f821d9416e127d07a2111e05a19aabdb869b4e3c65100efc60b45f4294b5e52db0fa0e5cf6f241926f42f58011e379348670fe8e4f4bfa3cca888fab54c19c0602d0995f4a1a77861c1730eba899f0d29a521dfb01855723295971f15962f861334e38f7cdcf6c59b9348c8e6de5319281bcbcee74eedad90bef388d646af9b3d311a626c9df6b2364681b1888fe3b5eb3be3f972fda3da248d35dddbbf2318b1a962f79acc14c20680c3ef524b0a3fde99aaba2a15ccb5deebdf9155a38b1f398ebdc8f85db7c3b14f527ec468712c794c81ceb61d58146331871ee35d8e2137357045840334fce878de35f9b293dfd5fe7845e2bece8a0e784623ef33cc855d470fc4b80ecb18ebcdaa2a39f5d870802e40cec268f237a83c0da10c3ad886dcf256222b2169b6c67c0fee5c4fc57ecae935e2c8522c139321c0fc086b998672e51fa58c5da7e2eeafc91ce99575872cdba199e0502bcf34d24bf6aca77e3f8f3912fe304dfe3e3d8684e88421c4f8cffc54d9276de4ce594aad04fd7c63886ef1899cbf23e24d1b036e681bc12a7bbb9220d5ac4614b6574cadc8c9102dec8301f6237c8458b05d90f334e5f980f6ae932f0454df1b856c58d3237265287326c19ff2299670ace8131ed32f4d0a53a04b7c56febe03a9940e06b31d61290bb14c4119283b3bf4d41507ea48c8c362e0e5bcb4a73c1f16db8253f3326436157b68af440c6e518b9ba1c8788a04a59c49b6efc86e1b1d469f05f55aa9014c0f45e7814f1cf494acc9b2c0368ca30544bc3d78c4b229d59ec25faa462e390dde692e78903f390235f40b7c847bb807bad0ad2050173df4125e7a2c60c5f98338d98b12f80c292af328933cb347605e470634d87e8cfcba9a89d4cf67c89b19947dcd13d7ddda73b9e18c9e10f9c26bd037a9dd0abb7dadc3bf0eaa432ace06179367f288736397ac7e3cc229d01a1e7bfae6cdf4e848bd241ca260526015119266bf70f2109fbba67f31fb07c5d0b40278f5a87c80d2b939a4178b6700c5b23d0b9a839ec06be2567c4ed105e7a816c4918480cc81d9636de1510968c6d50570c0ae9781e1ef351484f7cd25ad837376e4a611cb832aa01aca3858a176fed530cfd30a6c200a661ca05c626d09d7c125439100956f3a8722b381ed5d8d3f64b4634fffbdab8c4bfd3a4ef3aab170527d54da564656d73f770e3a61340d5fa1c09e5091cc53b9fec070c661f581377f989b69181f11291097bb2ef5b054e58d637612a92360e2edb429590cb563667e57c397921c2a055a8952c6f8a723def696edb0c7180947f3a66357d3b5a962e391749e5712d2911d25a357ebd879d8e3819229e0d4f28069a8dfe0f1aa9c4b8fb50daadc8850c716c23f07cc7ca13dad1fddf9eaa271298d6e80e2bc13b6ab82334013a44eb0ed554192b2319a90b5c7a604b84c14e171ac0c2ba3fbfd0b9621d34700e693adc9f91e51fb212fe087653cfe9976eb42fce332358b9874c6f04e92a321e9b27055b09ca37a15036a1c349bcbfbaa5563ed881b136c85665938fa7101e230682aeb78369b27c18c233405fa7671d1dfca7c0dd2c6d6fcf8f54461537ef172a102e2ae8a74fd6cc9b6a2553c3cb976ef8d0636884ea96ae780b50588d05f7f9971a7d061fb58c4f8643c77c6525e11b5680d1375b2016ef4b6606082a812de558849912c8531d1481d8e4edcad691388ffd81c09691bfe4dae1eb23670d3dd1679a4bb3d5432cbb7e349b0bbf51274c7821d34cf957a9730738440aeccc1a3301eb24f3093eee4455e5596a4b9824ed5782424eebf5098123fdcb48ea20de5a3d58514b8480a3baf17203e85895ea5907dfd290c8ceb5217032e17d17a29cc2b93f10afc98b55c26a22c176a8f3b668248ae77169e864d9dc21936ca019225517cf5cb7b2983dfb50927289b3dfcff0a44d71b1ca1d733133d080dba07718339d6c0a8cf5f625a534e293f3db220609b8e6529effe50cdd19e7d49cd0fb06c280f4c6467df961550cdd624678aac4db6a9b1e7915bb773b485fcd6233ca27b6e98adb9fcbfea0afe9c578657444385a2b3afc68f34ea3df2091d7d5a0057e22220ef84bbfe6abebe5e00e6be9c0255fb3d7d1e88c651c1b2e334032557715e49804f2b4d4bdc47013afeff773154aafaaa249eaf50a0db23c7551b30b3aac6083cbe6e703f40e40c8c54aa968e311b9585bee2f0975c2d446ea6cae2da7ea3a522625bae2581908fc8484403ee68c20665c200d138ded0546ba58d3221f58978c5a7275bb0f0e33c03c0a14ac8062eb08e8f5f331a2b5ef8ef9b777b56ec34c0eebdb0fd7d7ddfd8e855762f21ee414e4a282b94f003109e3569cd35dc4aa77d1b66f12bcc749520a343bf334560308feb76b4b1c4640987b7a694c05aabaed0276fe828e5871e209f2f2981dbaff74220576ae328d628cad1088a8cc35ebe9fc8144f62b8ea7fc4ff6b622f92447c4dbf0611154c2e23e64b97b187a97b1db67694310c233434883358255d387bbce2348ae8a9ac173d42402cfb18b061a9138739cde89c1b1eea67f140026b4cc09cbc25393ddb6c90df5bac510d50ed366c048cc9e697ad1b03302cc44a08a1a95b9abcc3296f39b5e9d8440264ca0109354f0e9152f682d3f0816bce1822fe20f8e485ebfb9645cfcea584f2113dd3754235d13384a59931b980ebe06d3efd35344d0f48bffed811042a8038caf02983b4f65ccf20a5e4a14b0f1ec49749eeac6a3336ef4e3f15ac918f918aa2c57aecb9f8e737333bf8ce0b6c6b37938e45dc7c380f93fc9e977e03f295efbf496289131d3b07e4cc6c2f2747b9b8cf9445348ee1c46b1bb386df9748943d456794dd81486c708b6260a53b42d4c490ef0e1ae5ddb8bde4d3029172cfdeb8f08a0c95b5e58da76342b8cbc10a2a89e9dc33f7572ddc8c1112753ea5af8453239e9c429d61788a0cf68ae79f4314d9cec87afa455039f2644f4e87f9fe3fedb5828fc0e5309e93b8725365a0b38750c553f6b7cc19a7f70270d3c6a30df44f8258641545a729dd95d443710bff044831a7b0dd7fac0f8a8b515a9f931e24def3ee6556dac1ba155aa7a7d2b830d2ad8a4d405696cd7da1422e8489afc71ec83374c1f451534f3c8dcac052ea2b2f12de81ab07bd8dfe86d10fddbf77b28f3b79313e93e2a5773f7ea34859b5d4021a50eaeb46da2aa4e8d5833b577cc80b319f63bdfcc0c8803a07be171db8a5536b8b5171bb0c91aaddbfbae30d99d997e648951070bc236614e9de80bca476ac1a710cb974d1dabf8704a8ad21e520ec4c7b2dcc04ba42e1f89e6becdc9c16d9718affb583e24999bf0daf0b4775142bbfe7922fad4c5275bd0b87879dc0e9e87a30243bf2ca435627f3f4ec50836d003b9f15d5b11c676d03722f00bcc30a94101aebb1f31f1cee9f47fb3e73e70aebc788fc4c2ea4e6ec192a6249b4940e43519f052cf27534b37f4f53489db1292aec26d15a75297b23f3f796740d85cda3c56e80bccd351ec881b8741afe9f2d3b5033ad73f345af4f247c89d117d84c8f9a00c8c57a8fe91ddc9075895643dc5364a0d06dfb3bab0ff15c39b566555217b1073440a51f724944a2dcbbd50712dc813d3d49dbca80c59874d7f97bcbd1cf3caf41c6d9b9c2d59fe2acdc035ea7b5e6bf454dc135b42178869e9bbb6a8a4371ef199b11a169b2bc5607948c29484f22dc6dcc9a138f9b61707e9a7d754fad59c84b08ab91453d867acfc4677bcc001b46b267d1046943baf2539255cf24fd772aea4fd5d724a8067dfaa6df9c52582d6a47bb7bdfebf2a04c4d26f31a831d60b2a2b3f5a774e2d064aed9ec6b84c0472bd9b3549ba72eea6096af03a1c6033d3dee52692a890c06999996f99b30c0fcea09fcc05ad82b5f85b0cf95b6f9d26e41ec6ddc712545aad2528bb15af9e7485058b6d34d27d4820973d9db5ec54aed343807ba8efd7e53fdcf1d6e6ad01a7fc3af23c91ccd8adf5479331363f62acb62a46d69888ee9bb9b7f16d4d285bc977bb56320ed8f113bc8701ebddbbf28765a625aca12a588bda6b0b5741f50bd4e51b2f392352b68c06245056bef4164221b27a86f516fc5d12556fd2ae5c171b851c828fe9bc0e2abe507266c9443a6692215e211cbf43087a8e7b66f31be45d2552cac4cb1d707c86577d006324c308650f3280f432c26044cf46a2a14f8e7082ea258ce6c49183d6a844bd82994e894425a010f5809ebe423349092864fff1bab8235b6d47745057d34a0b1e3a1ec9e5d3fdaaf2d5a201b40a6b2f153af06dd906773c383a30a4b81e146f2ad2b14253b7a16a89aa47e6c29dad297d4f04945480efa040209582e688a5c34b89ff9c5973a582f643673188a8fdd72ae98c474979af1a5ef9ebc14e88d3af73361eff68e8c8c683fadc5b41d179f51ba44ff7ab63ca848bc1e6ac5a72a69e3f54f323f3a950991e891dabfa1bb21fec3e4ede8501ce5bf8e33b28fa0db2504712510c092eef5ef4cb9c5fc8d2da15a75cafcadda039c5c612ce33e4fc58585d88ef75f858363ac4a4202e98a334e0df926329b65614562987d227726bb506a1c085ef757b5145f37ab914cac82b4e0c9b734038d3964b4b1365aece327e3de1fde8a8add2a1af96888adac91988af12bd4fa2f779de59fbae931b5e95d8878579c226220ac3b3dbb435e4d5d2df9cf3b6251c29746f96dfbec0b3f52277444347c3055632effd61a3680e3d701a9ccbb4f53bbccd3db156ad5d7ce9ccc1f40e28f2d8fcb88346b17c47c82340f262095047b2eaf99d6f0cfaaf61ec0aa79be8713a4fd41e55b521e638968ac14049684850104461c3c18a8eb994c9da5d41c506db072a1bb180dc7eeae3f6d585235db77798182ae400805e69d15b6a5fbf0ec0691a025d400bc164124e238927d22355939a55e64688ea8df142e9ceaaf931a0685b9216942fe6449e209f49d99234728a7a0c1594dbd9e258dd37c8ac7dfab70b6db8bf13414f6ba6d490955573a6df644bcf728ab056faec30c2a39a315f925c2f9daab62ba003f976ac4c9793e0104612b0e3bfc812abcd4b2a2ff35a1756e52e4a9f85f93d5148139bef247ccf917b67b05eadd6431e43633d8f2a0c7694ec52bba84b3d95302846a2e446d95b83d8fb829239d751051d499d0bd1d96b91d5a60a61ae3a1da704a6fcb57833759fa13f17083c1a4c1079dcdfdef26c8a9cab743d732c66719a6a636d9f8a88427b1eae043859cddbe2e63ee56a159147f5a83ff30f9b011a630a8df99ec196ac5dc75ec9083c87f94d087c4a6e68129071eba20cb54a6bb0160aca4daa0ed5d33dd493f9973763d11e9c67518ea93ef4cb145d03074adde60edae3e3486718acce317b4482c62b20736b8b7896b7dbdc81ee84b73e1968a291eb318dc57989e323f725732d6192ba46028c9bbf1bdba561070cdd710ed00861a8f1978115a96042de7cc9e8acae4b694990ae0e908f7940392fcdeeef458e8db18935de3617cd6bfd22092c715a35c78c72bd78b16db1fd81ee6464d037eaf9bd9a7dac3c5dcbf9d7b0652edb78ac8d24087dacb2d82c307b3355bde1e936c36743f22fbc514c791fbab8c01b2d3c594369f14d04fcda36d5a4fe6a66da89fae30feff19e8ae876f57a8c2cdfd69fd0a46773e538b1fc943143df2f1345ae50f861dcd802cdef244556a5fc982e5d0b86e53cae3841eac26c931b74c6c4398f16d39a151e1b87cf1b0f1556e0a992fc6a388481e5ff350cf54ce4b88010d8ae24faec590c3fe2e5da9ff1a9776232d932a20a0768f661d63e8b1a86c503493cf30fbc7b248333c1b7d838ff90bc9353f4d45bb6e1138b4a139892d88f93e108aadeb9f418591214f79b19fb8a60198d81f60f5367377250817e5eefc47a0810028b7ae262777325004163c5a0229a9e3c58909f26f4939ae5fc1fd1f8f8e6bc0acf1458db17ede339eacac29470d24f07cdd0d413e6bbf6fe3ff88114c94f69d09b71731cf8f33f98728bfbf5b45863ca06d35098ad756c42176a48af76a47e33449f2612cc9e9d5c4322a10aa91850e9f9e92654789001f15fa014c4ee5e6960174b04e4955c279ac6b504e366f2370fb5c12630e5d51fe4a5497de3c811d066ce4e06561fcb246b7ad2e02b77be7387238b4691ade61b4d011021af844a91ac582bcbfea3dc004e213b5c6f611e01efc987bc558c3a94ffdc8c72fbbfe7faa3bf2999ade315c72a66e43020922b34cc79ffd1043a0feb58ec1ccc987250ce242be7a1cfe6b2238b260efb85bff3ee840a06f559ed3f71d8690c359ede0362d2f6a0013fd737f0254914a21805309792853976a4015e06aac403d3348a7821405dadc82441e50f1f209a2fabe54f5c9ce8268633b1e24ce57f6c2ebc88576ada823309e0e7915d0bc84c8534ebb7c1c1c5c9f8dab6a04f543678e6b63facf889f32aa6f5ae4748948d1f634589d9b5ba178e36188ca99b1a3bab22dcb170feae635e0ee79dd61f5aa737154a5684a974609d9aead07dda0f7d329d27f1aa7cacdd4d3bb2ca5c8a95083c71e26c8a0e270a9e159ec8878ef1c6586eac17bc2715513c016c47479c4a7309bc401094b904e1cd9363c5993875ab698112642373d625ce0077fee4f5d19bb9db87f7f717a09bb830176eeec3929c36aa6dacf308b9e023943d9b294e1306ba2cd9c07df6f7e4fbd6e18b0b0c7d8758c96e518a289f5ff0264b692e24c2a6f4320bfb3a0eaccd5ff67bbbfbd675b2c3b504d575065aa949e7b8bc47a46ba521792bc56b3348fea69938cc30d16cb6ccaf910d631f8a9d0a3a3a9638d668f723d5e04b803d8ecdb0f25de7f285115864f5dd19df4d11a4578c863148068e4725a4aae3cef83c24e19420c4356f9a37170f38fc72a45865099b33afb5fd1c8173184402f6b20b86f1dd6e4c9b7ba4b1f11cb4a100833ffd5c3384ba8acb37d2407174bd9f409fa6d2230992f289027326b7056f2e1294cc0ff1c482889d42151b74455ec3d3ef59db4a637765d8bb00ca0d1abe06b469f0475c0e2ed53eb4e91a5dbcc7fb538f7f19dd90d376613a126e303092acb512b055cd0c7ac67b286563dd06218f806a227b7796eaff1a1854fda8168a23b7d096c1566eda7937be2cdec0a411dbccf437baf9fcfeaf24cd1e9da21c03dd7ef449cabfa1f9dd31a25b1a33b5fcb345ee0fad2179b33a5b89963dc2df949d2179193174f74dd44d5e2a1fc3a56bdd9c877a4baf043cd3d0e6c21753f897baa993917034a220df4add91e0db601e75a73020bd8c932f5e8e7ea3365a8d5343b8293eeda49664938e95c33222fcd6d2694d98a4cbfdc71670049953f20be2b0cf74f8ddf83c3dadf1e4e7eca7c86b2784267aff752b33841ff82991d131ae94bc5f810b60caf4d54feb105e56080df562ecfdf03995178af4837f50383e7c214b9592340bc59db0e9166e616d27ea98abba45d5cbe2779bee94e2e6ddf950e4ebe592f2758555742f9aebbdfaccc55b3d0d6d96c62bc3843e70b2e36891cb5cc89eadf5b2abe9a9664a03ea72173aac0409763a1baea65654f4bac191e29d3ee2e206600a2855ce0632435dd38c526cd235bc44ef27f0b3ca27172389e6940dc261e9458c8b5b48e28ab4353df7e23b332c2f9a710a36b30d42b21d7e1e0eac9b4a395bd022d469f58f531c887ffc1031d43902cd5cde63478a44330851b21f7524b892671bbbf0571dc688219bb00239c950694b305071ebee8d450566f071f8e7c66d00a31806c4f4a82b25c08b7f83a482e2146f2961604b0ec68cf8f0741f14dae2b4a790e1c7fcc6c3b2fab5ee8d6ae950cf91faa831d7cfca572a0afada1a4a4879d95d724848a3ee07d9125dfc0ea697d79efc641cb02de19cfed290cbbf3ee93f82944ca13cff1f7a86dbdceb0ed9ab9b4c977c13691e8a8c7e04a438fdf523cedab22d7c764dc6bd0ddb1037ddbfaaa69f18eab31e2f6b8e23648d29990e8b9da3fc23c4fa23be931774606ac27ccdd9f4f4d7de6e921b94863085f8215bc5913d470bd7e39873ac6db6f846950781c9681338d1a7c1d17e2b988bc7c09f8fb0da09565dbf1535d44a7e51e13118fce2f48953b7e2bf4541e15ae8b6c501fbd139279b0667468b88bf69092b87fbb2074e9080c09e302b0bc2bbbd452d7bd4a7bde98516b722f9a67500f9c98ae2c6cfa4fcdc95c7ccc419da08d5eafca273a34c7dd7d538e70ecb7f0eaa1a48706829c1f259b0114953a0c68a86099538afbf4683e44967c31c77cec2768592954e4277a0c9b31268143081bb47199810aa95ebaf5c33f75d582d6e3c9f73a32cf21692caeb9ee1563b395f4c07685489175ea17637b7c1c362d0fabde5298ff84bba6e205cbf517cd8e5b98b16ffee09c4aec705ca766ebbfb86444b0b1b8ff6ed4043c2c4b24fdd84d1127e0c751f9e5ee7a90f1f25e89c48e4ce63a2a03c05a9c1e89ad451654a85147769b10ee70c0a8eb6f842f8b762d50bcc049fe1e8c6fb33d2a0c58b912c2066f0b52e3999d567c5b2f41e104dfa3f8ca0ed0f5010ea6138d9505aacbb6182ca54ccb03a40374d2947f476b3dcbf0f0aaf5b4182283dc8fdcb1199bbe2787c333bb642c7af88f095552f393d804ad2661611ad43c5512e0bb62cf9ebb4af81a51b81866cb60cfa121b446f790630e6c0df6fec0fe4d94db4120731cd84b77679463a16c035041418e981ef93ca8d0e313288bc1aee69b369c27b3381ed7955afdd18ad25d6abb72c6177d8d143deccc92e17630ce299831a5db16635f31e51e1b716b7402148b66e1b504c086509b65047275a0574583616ccb789ece8372323eeb83ff69ee5639ed08413e6e0f1b4cba0c3f2af9768200e889e570fbd01de712f91c93f2ee18503722b919653be2b621d6cfa2523bd02f507c935d0c0d89d88f430e0ab18eb875c33659715e95081be83611b388cdd9c66ccadef401881983d84175caa264cacc83ebc751f24e9fc87dc9368cf6e0e8c1119371968d9c5797cb2f865b36fbc6f411e1ce67ced39341e34f338895f5d8b435f68c58e081dc3076da9feccecc3e9c4e4d649d329068909830b4d09a34efc06169fa32def7083b5df2b1aae7b21394e758f33e8d2cace9de1545d3985e6e7fecd4c179ad66c45d3975343e41e5e40b0c0309007a8529eee3198c86ae2f65aea99635677fc691c8a1b7fee6a16a266bbdcbcacae8991cdea7b5d287a0aa4e0ba84f41f1f52a5056f78703a67564243c8ad0dcf7dff981ebe506748c58f64b80749c8b563444c277466e53499e1f7306a0e74d79f0ff798d666bb83f4fc6d61b13d0ee15e9c3c8e16b88b579e3970742f6cc6ea60836fac37bada3bd1aefdce179f71e545cb2c915016a0bd5de060351ebaba67f22a1e32519b4214c85bd8445b6e031ce21395bd2c6f4b4a63bacc445271d22e8476721900d472cafe8702fb10fdf67097c74a22a1d4d41dfc870c3dacc5eb6fa62fe1b63b4ba4164c1a7ff740e2833b97f58072739ed82bc623decefc6094e2913054f0833c8cee20be4df528bd2ae650a4bf51c96fb10d1d70cbdaf6e734430c17a8017ba000e8f213f67b1617651d3b0c96627c8d5c6ba23ec74e2b3a83e9c74d86bb65be9d053257712c71c6769994d1edb8d2bff37139481cb8c6459725c7894634410eb58bb767e725efd8d0c67da2049d1b6c497884ed56a7fd18346cba9747b91bf5da80935f063d0cc4c951c31a5233ea72213a634e4b3961ffcdac85ab594f62365a3164fea13747172c146d934ce9dbaa7cfb3155f8238ae2fde69aca49c81ab7f3c5db46e1bf11585faf967c27cbdc14d7a8f1064a8847f0913a59de6567f64e3dcd996a99e6ad3cf703d448ed01638158f77891aa340d5d7f8232f2c18566cfc1e581fe998704e83abefc1454c31c56c3a315f9d15dc02698513d89c3fc84a65ee8547da213190e909d84e01c047e25c78ab9c1506bb612cd982d558598ad0f24a5453da8bb7e037af4372fc6c8c845bfa7afcd8abc1133b8821603152ef6f0b2c04d3d9aa4f09d0d1aeac39faa6b901b27c977deb478682a03ffb2b011607d77c54351127d578c02b7ea3117b581407863597c3f21a7782687b9d58dd14cebd592aa942dbd9468a30ab6f5b7feda55b903552779a8b6e11aa0e802322aa8bb3c07fbe16bef4f608c7d4c163755f098b6450885d8dde90a4da40cbadf9705e6f9f373cf17fdae158550923bb7e445727321ad3ee0a1f35ea85d3fd198326eb9915545d4c2dde7dd92ba4079dbf335ddd16c635a9a4f9cd1e0145a48cbd7e5b73368ab89e3b50b9a46efb09e72ff6ddf0be261461bc116f05814bb6029909ef90f0aab9b25d1896502ac7ae5a8f7fd83f3224d4932e12d5450c5313e67903728c59db3476b8414796811a5c244a19420a4925652cfd9995a8475534c0f5a140d5f0599e005091e1d1d1d16ee3586ddf572341ed93fce0f7e232665212cbb3871747c56e002fdd52e6177991c95cc266827260d49e49a14a6fd0d71ec3ce45fd48026850256ffca2465227b9fc9875b9ba214cd157bac08f796caf5a75871c6c40d6bf21e98dba1c733ad95bd6e539498deea78f47b200b9c323335823970606a06dd8bf9267cb139f9429bea04fc4d432bef195c7ec4201d712106f85a63e80ec279f305a8fa243ec53c70b3cdf75b25693111f5f598491b74e7f61698f0d1eed771226b216bca93b8d53e969b746947b9360fdc76af38934153695a67c3bab2a868f22ddb9b99083b0535620733aa40766a2b89bed69f87db65994fa7feccc07b763d2440d43143f5c4796298c8bf0dc71ef805be1a4526c475778cb2b42270ba103b97e5d23b19b1d514dce5174312e4281050d1fdf4afb213a8f08bc94f3c6d3e125e8d71510555afdd0947fabe6beba0b1b67130f3d7130c6ae688ca1ca1657de8fd105785c3eaf8f5ffadc1b242aec07f0bd742b6d0c2de9b5b449f2e7fbcb41bdebcecbed57e1c358f497f1f4e39bd58c6a85f371af01c6aff2d85559b2df065439fc8412477bb39262dd144b80c99d9903d172ce775c158675acf086ae42209265bf13239da8ab45015acacc8276b1ad7a4d9d2367aa99370f3d609c5ec0edf01927a1223572563c9760a4e9f5a586bf5c0d79a6216bbefadef088c6e6602629fb7aaf036d98070d1fc9697d5c4ed3f3aaeafb683b1a7ff41fa0587ffebdf7ab8a302cbe8851682f3e562a0eeead5cf81f6801fc5f3043b42fb8d33ab0fe61ffc2cd9ab0b14e15228ef8d43d8c0c776f58c1d85d327bd0225d74fdd10cc97226d174b611130fe9952845e211716ea41479939307eec261e04a1540b2bef0b67c582a5bcbcef10c19a5b46956367fb6f8fe638c0f83151204b82e4f9520a8933b748664cb80af345f258b7ac5123ef57192a1f8c4c622b22d517ed03f461264a6668bc1b80497738b40143b630f29fbe36a06e569db203be3649f7a89fd12c38b8c0752140a31d37b79db2612c1af1442edb5d220bdc04678c6e6cdc0acffb7b69a1e23b21f0ec6e624ad2e6aef9f1a8fab120317fc20f3ce140691e8addd273827b067905ecbaada3613f393eb5c45d9f993ac599a1951398cf3bb18aff54c19dc8d67ce1f87f31218600b21c4eddf65972363dd1d824fb06b7e7c23ebdbf0d9991ee088621e47effa07230971269859af63ab6ef5e2056ec603037bbfa5824e0fc58be8471ad957e6aa31fde77ab0fc85d3f91939f1023009048e158931b4a58587a7f653bd3dd096926c0b21af93f2908ca4a1e7632393b226a51d2ec8b1e4cd700d031d0985aa07f288812b940bf8c64759179d7ef50b34b5e932f25b6ee69a724180d13b0b5610aa5e18e58de27bc3391c5be39e51fbb276c1f4d921dc4d32f0c467f8898604ec9c96b9bef4526e84405d3ac4f5c2331f94e7436b50c8053c413e0cbcad3c4a6167ba7a0be131ecf4ba26d8af6c05a4fe69ef1f5637dd7209868af74b1daf87b1e4665513d42a14a80f888ddfb5e00a8c5659aae6ef34711960c22727ba033990f87a1a8606d919a037f190f4c55e76e3537ad7640158ee4a1874111aeb7185906afd037f0f5dfd0e46c95b3642949b2ccadd3ecb07ea3944e0d09ce1e607da91b761c778ae59cdfabf7a176b452e78a90235301813959326faa276e412547a49eb5273c1303fbc23e28c6bf707f93e63cae806a69557004fe6c02a31a01009e8a9b373b8167db6a46f207143bcd2bdb2d590d36ac80ee8edf6955c7338753da98172a825736ec3027d4e3b1aefa34c9a87ef826ca3166034554933a18d7970c50622da1c4b20828564138f5408784899a47a1f1c1aa9dd22cba62c7a47475f5e1fc70114b69772bbf7b4dfdc42e44208518ae5ef89cb07ddcc185d9d5646d9dce729652d5f7a9cabe714357fb7231933f2739f59731caf1b514c4c8ac9cc0c8f39f0c08ad2825792500cd68369278de0ca7ced62257548894ef59d1654c35fe1b4606b84620e8bdbf1edb0badb1589c77a0a56ca2cf58d0b250b0d5c312639301cfd92f91a898c0849aa9005356dce5f6a622c78689f3d283b6c88e9349f513612bb4e5216a04c2f976208e9f592879102588eb453137f62e609797e0ce7b34f20041b44937d53a7b52eec875f50ef9510d213a3026163f4987e843fddd0cda8d575146c8df9d81b70f0f33791127b7374d3c9bf39c36d8fb5b928704afe5d09aff2ec2c411e1572891f02814d5e1ff72b0a6590b75531b05f13f733bc6e1dc63eccda5d5576cbee799c9a5fc31b704772928018c4bc1063bf21cbc61b359859eb960d335e144626af326ed8fcd6b242f78b0c6e91f8cd58c93e50dbea6aa341385e8935b6620e3fdf99c6a465ef722838132f994fd5367f46e637c9c6dfa0b40c14a3fa6c20c90568e0421a634df8785d9761e499df924b1c3329369fa650423aae35252ac27b05140554b919b6161939c46d8a7e63161785c44a29c9b633f112e780b7c1962d5bee3ca26d12f9c54c9759d1587a768eddf95e58742119578263da84ab4316c730df1f9bbf7ec167afb7bc2796a4253eaf1f245274c32a2240d319322459d3ec37908cad532ae0b5d32bb4ffbb2e55aa8c5b058f514c2ba2c8e0197165b37bb8800e415b43c49115cf58304c4455cc566dce0e01684b9085479eefceaaebab929c97c1a5e91002e8f5a1fa7aefc70ba50d132d56ed0762c02c9c61a8656c7bbf888b7c6332a5f0ba1d070a163d98fbee9df55be71e6f62fe2b6a374f81317a15ba3815a9a59dc62590443622d00b9943744b794d25fba1b4d2bdd074716893b1a529acddafc51f9dd76ddc47b436bb1382a49f501bac25f06bb3a2e159c3db6618c6d412b3621c7ae535ec68471977663647d738150b512da207bf9fceb413aae02408486358c790e7865bd3ba50bd10699be903302502137adbc8476bb2e1cf7d75a38aedaea81acff69781a7c7b735bfeaf74e0d8185cb50a3bd90bc215ea3a17d7ddc178fbe4d2875774952e83fe578e4c6a8b17de9506e50efe36806fe5f3612e855aab869c87a6aa77a8a3cff5a73ea2cf3539eb91d74f917c4639c10ac83a825b772b23fa63bfd6978e358cda5a40881ea6861434b6e981600deec9194fa725748ddf1daebfd94b60dfb197808d7b169f9baac9734ed86deb3adc9ae33af5002604b694d2978ebf6235916ec116ec3358a10e2279e1382f6c5d7279cf6cde3d018c285567eac92ebf930745c7be03fce8eabc7fcabe77ae744c6ec678d33a551f08c8125aa5e57c80837b434c28627e5ddbd860b62c4927454ccc3abec638518fe08f734d89e16a17ba35cbe00c0ca893cee181eda180775f74c05c53644f1788f443b5ce6edd283dce635eaca0983555c3498d2dd2e4723ede8c188269cbc34660ef41b7a73ed487129f9350bc66c6102984bf97102e230abb0b34dbf5db9c1814603d186902b792c125bfe8c675db771a357dedd9bffc828e1d72caca30dfebb676be6a79f47f1ccf66ac4ef772cb973c87ec1aca679ecb18647b3c7b9fd10671478fe93c1320df1503c5add10a3717a4f9f29b8f6ed4e8357a707bc8d975f2cdb11f9705ebd2c5121de91b2f678d9a210a15ca64eaecc44624f792a4ee676d56de50b7217b493b070715c9a78c32a3de65da3f07b3fc7549be7d1d3f257e8e28b1ba8b51cf07a328f2704fb8b297c8045861e82bae2a6f4c2c1f46c1cd439817641986bd64182380fbcf06d5a2b5bdeddc97001c77aa5590964a696220010eae67cb9e682e62402909940bd7727fc9866f9d0bb6b56d00c2afdab02325c5c94c167ee473d994d1c0fee7d45e594b99800568dc2cd414276c8a571b9ecd07ce8de33603ec45a87e53845333903e73a15292a2ebed7dd6a0461cdb0d67379f82d6216655926f000c79b9dc2e130cd25bc5143a5f6c87d3036a67f367b09fa8872bfce2998af2ee0257a716bc82209cca2c6d15e0955333ffd394b77e2e3591e33adc005368694d9470cd19c1e85eb364fa5415b404aa5efd145c82c9d944a23108b599e12e1f1651141f40add41d29b73924a2fe71b1f8b564182e80ad09495c185d31dfa5ae5d33077e5b75b096edaaf14d833d9b10c46e95a0731abc8ac811e3c033d2962a5b9eb13029b2116849bdbf4488f8f69ca2553d1de170b1a702c863a996935a90d02ad20ee0885fe7e92256c8f5ff5dcecf4a191f4efb84c1f1a5b6457717c665c14c986174b91d8e76b654e48a0248de777e92ecbf55a714d75bb1a08e2b8417a255e1153e0db2939d7ee4ea6d959d7d963be1d3aeb8904f29a897ba6911467b4dc60886ea5f3198a1c4e82139af0859b5480833ee1df9f2fc15e3cf1bdc547701cea860969e443c60fcfb4bae25f46b017fc7c88b27740c0affaf16d9cdccfeca2ffdf4ea2d7e46ce78f9a538ab53a18de9e54e7078c8a202d488046b5e290071c1184335afb25748b83ae85225d08f99a7534d1bb6c85a46f22f4a2c30800265e765c78add9f8e8714cf6e39fe6dc09a8017ef54c8582d54f80958c255841b4b7b5506356a3b3ded6c8cadc3b9374059a13b1becf0e9e06fee651930a9dd7de2c18b06d7e4008b9ab0c2ae76336426cc2ce4a050b93944cd78356669c8b2e6cbfbe31c9504b35cf2b30a1d7139e982c14fa88a9e56f35e68b5176504a8f4eea500b04fd8084fbab1016a8e5af5339b7a6010b2dd5ff04366f81a7f0d92188d8d14cad39405ed766d0357679a459a70e233535d94bc404a1fc742f6ad1cbaab3bf64d94b05a64f019701d0bbc3bac9599bc2c798ae962cc5d413dcad7e86034b26d6a057bc6c4d43e47919464394ac59ab5b8478cc4ea387e938cae77d074be73f1866902957d50ebeabfb137b145a1434884d8f4b355ee0efbf32d325f53d29ac4d176fb774850cbd1a32622af181ba0fc2daab9a44b82796b717dc8a175770147e74ccbd2c43f39e6b1c8ddc23e9cc8bd9a507533ba991c917f3b20c33c12bc09073fabee0476a2e1ed39941fe1d985422e9a2abfb32d10b83f0ed1c1942ad221ffd0e23f11d6541aa0b3650bb59b7095c07e1d34fabfb475bfb589755ed17e430f87969521f3895b2914b9414b2c71f413158d1499c6d2d2081400983a3578e287f76e95158a4335d286fb71aee332cc53f8dd8fc415cb096a24137414766524d1371707b5299ddcbe1e85234d3f55db6ee0d118cd14642720b6ef7d970c1a4afa2c18ce6437a7eedb1df3270d256dee080cbe84098b485977dac0ff4ffa22b3b882ebbea7c9ca4353cc837f3e8aba6e02ea6e73a21df71bf7655428ffcb23a68f70d5fc9bbd2f8c6f3faf0f47e3998927a6776b37efe33bfca04d7b6b64957b79030ce4b7e02f93072f4d6964117a279d58a936fd203ec538a12e4a53f82aaedba793d182e7e8feee51547abfafba8dfb5210bbad75fc0fec026fafc29202d519292473127a8da9434e19e3e413dae9b225d2d8231fe7239930ae45b4c433dbedc4103a42129b67b21655b84dcaf1ebf1291832f584d1f1bbf671fb37da3cc1bb7ef56eef6b469da423dffe3e11cca1fcea8f9a126cad45b37b7e8a7cd66b5ffd563273cff40c2cbb5e5b6c8a5ecf4b6fc5f3fee78eae59554d81901da2219853ef4007f75c5ca24313530a8397eb417df8e919d4b45136150adf02a2dba142c3e6de717ced23f0a5fdae3e11dd733580cc3f1b73bd404ad527f34b339b05597d633db87eb4d9d29c0bb9ed5e875bfac9e88883ed4aa5c8981db922d86da4b5a5009124af10371d008327019cc160ad0322a1859143b728c29bbdae103efde15629947d2a01af9768587e2fdb7223b20c291d80d175c280bda6f1f403d590ed476b959a98ca3f0c2bdf2bb7685de03ef7d8e786381d78d151d9039fcf1974087ce1afa255b8e48ee876bc07ddd347e8b646febe04d6cf79032ac50b9ef5334f3ba4bb5b88e792b7c3df878ad354b15d552f06724dc011718e0d2f7f41f1a2f3f6a520e51bc3012783bf8a1f8353a62f6b8fd7be5763199f9b8452e22268743576b53656d36431477281a5c8f3df9c21d913b04f76ca0fee8a4be9be46aa9a8379f425f4ac4a1fd5782a3f6d930ce432a4d21cd603c189face6de393fb992f5ed9d8961806fec44f0cceb7ef92e86f3e15d1f8c3c9e08438074ec566939615cc5c04009de02684cf3f9d83ed81a30ef1fefd9559158265ba34062e5de4e27b1a7b4ac6c229a1d1a2f489ee5c51a8437c50bafdc9e9abb05d6ebf0dc9b46bc0055954457cb9ef31ba9c13d5f8ef25834b1e6e607351b7592bf572d6640b31c35cc59b998c59deffc92c84190f3590b1226248ec6b996e28c5c0242bf4731c561bc94245a2c6669f58c853ca81dd09e5bdf3a563919acdca7ddcc0d6a20ab73e46d68658b477b1660c0c58456f90fe50ba53","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
