<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3878150b1349ba4a726422cf7154524470c73a78a5cc1221360fb9dd2b219eb3bf3ac06e5778f50d8cdaaa864a201d2475cdbecf46c483307309b139dff7ee15b44179458491348bab9dc7f8fd84fd2acd4e5efe1b3a7da772696061103cc57cb01f346a914327561e6706064c18b56ac031ca2a37c517c4f1a582719d407d09bb8198f4558ebed4e1b986b9fba8fd9f7d1b79c3b537c6cd072a07b3db986e36a3dcca8ca479237bfe3f5226925ad4b11b4a83c039701dac9a9211f29718a504ef74bac596f32885d9a812d9609ac16e19d224995526293605704a54de352a5d1c7d6b47113d68a78b61e2897f13e236bad8a7f7f375319c8ae06fe4bca70354a2d494d998279b021213f435026603ffb09e7d8c48cbc339885404693c99bc13d007cc27df4c079a72dae87c0636aa80fa1267ad4b95d6d814b14f9162d4fded4a78a82d7b30242a93d2980e3d86c6113f21746737b2e14a211679547afedfbda8ee1a2c6c0a7ff767b5c6949ceaae8510ef25cae07124072d85c45160343f21c9fbf4bb19a1c52549b6e94b21262d2373420f1904035a6061c39510098a42dd06e055495183e6fa762bd715fc3f379395abc667fc072b023733485fd8de087340246469ac480a5145c1780c96c00b6b3037b74f33c80e922c2c0e9ef1cf88a8fe6736afc85a0f4044a328cb5c2c2d7fb19fad6786007f688c14ec6e8b654d129e466246e1d98a54ccf8faa238799135f248d2afb14acdb5bc23fdfdc816839ff15b4cfbc40388ae3ad2b5ed108b35c76a005a943a0c5feae199fd0d0e1a0c14a232596ac70f112bef31d0a86df6ed634ff44663ef507d08a169941a37931fae32465a8bc5153a538cfad208c22a06813e11971dbd4dcd82033e6f1f38c5645d66581c84992e5c0f601dc3f9f67a5482e2525f770df74426b70b5c225d720f4ec8f7fccb2f8f65b7ae9b0bd83990fbe4b8e5581548c4ec537ca24b97c407ee4d3213866155ee5163aedbec38f06dad8f80e94d77c11fa964dee6b2a7804b436f80aa41e3ca823f671256684fa1bb2e62ee4caa7892c1bc26fc4a579972cc575873a43b565b08bbeb0f3c6a4a3407b94e84480b8560d84819d53c958ec15d7399c5b8fdfddfdf90a77d228c85d382a72d05d80e06ab703c6e900f469570e2dc933ac7bc7c5063411cc05a57f534a74431a68339570874ede659a22bbe22103d6bd7ba91f3ed01051042d9149ee01aa3bbc7aa87ce160f0098524edb9c26f7da422b15a820b9bc2ce389f98e8e7539b111561d7332088ba13c31f0fb4dfe21a65fcf0512eb5abb57b86d2857cd67bad67fa1045b0b9fa4ced9b1e35728aa8245e5a7596a7edea86d2c7280bd186693a27e95190bd73cf554767b5e3febd2a6fa46e8b6ee435a1b106cbe1e8384e78be9f81649728adb793e18b978efa8598105c506c7c3984269835d943038437a7a64d6fb9a8c2a8cd8bd3f05500048728d20fd1c9ceb7bee7f7c7c491f741157b8a47b1869f8443e314dc52af8fa02384a8731b0f64fe0b6ab3608bb7593343ba1f15f903d1b792c27423f1e0fb8cba9e01471d6bc68649a13918bf5fc0565cac12970d8239992d22ffc7b31a5236c2be724b350295c4b4e3101298a4f8b7cedeeb5d92a0c8d81903f7a2773b797d9207ca37d7fa1d0734ee84d84037738834cb26e4e81425e2018316f104bb5ddd900b29f7dc9c35d59445eaa79e5aee1b1d7175599b31da8d56b709b42786411507782dc9a44da24aa08d4c2368bc56b2d9fa647a8213fbdcea4ccf81c81c46397e19deb7e917b1e40b11bd22bbf543056652642dfe7fefc75acf1b1e988f9da2c1c6ad089d3e43928c4260f8577965af36094c1aec3216ca42d898c1cd029552b57e57aa3c4c2e67746cbbebbaee8b2e552cf81290203ba7b39fe4084e1822fdccdef791fbd4c6603c97db088cf9684cabeef458e4e154016582356bb5685dc6231688a7b8ddcf4e0ff09dd450d0fbdcb4b2b14ae47def383926e5a36df6af14cff3b54c29428d6ca16c55a4e1affbd62b54aaddd0ddd3b04e0ae4639a43ad1041fd584d07945d815e9258c154c3fd357a0294fb0d14583b698f312bb3a312f502608e9ce66ab18a401fe3633497c34287f6732c6f84f7a7d5f6490b5e85f55e1d7c44667e699c32342984cd9f4e4836301975308d7be81228d5d3b52c961a1672e0ab41e9e6a80b8b10b4047d629cc912fbc0b1470268b426cbbad90bade938479d0870cb72e0be65fd87c3163951dccb38f4388590af405bcabf5c45d1b358eb581d90c93e005bf36aa6240a382bb57e23d655d44224b3d126f60cbbdffa488b55841704ca025d8dd8183f19e15660f688ebdd5afbd85ba43eb3901f6aaba9bfeba99f1b05423cc2e4debab9ce0c5a17f18471233d6e2ad8aa4536acd2fd2eff7e3502494323251e79234f8977b121f956ac3ab6787cd216cecdc476b5891afe40d23316a6059a9b55d235a3439dcc139d34f05fbdf3b98d9e40ef233a3bf1c514f5c533b8e1a07b3e54970f92b2e6f19297adbd0556f8280664b84328c1828dd5121b79c22762f695d20d8a9b1b7122381be5392907241756c85057a2eda9f93095c50f961fbe4c34e3011b2a7ea26593b1a8d152599ca967ea6f04cf881cf659f84d3693a80360412ec77f7f26e110c37c33a604465ecc7b6eed12b9f9febd0a55af61d17c5c5e7ef8a90155f651d2e3281b6bd5ff1b3d305840207c16b7c8557f45e9c69a28754b999b4d4966258d08329a22ae2cbbdcd3f5973523a7ada493632f520e0bd790f7888f63da644271e4917953e67f6a9ac146a5f0eed25887d9fbe9adffe4d9bebbd591c5139770b576cfc58eeafcbd12df2e3672257ceeca504e4fa409e3bda9bebcff7eb3e39808dc22aa7882d7bdd6cbad445cbabcdd704da3be768ff7431222c449d8396f7d6a92f31e4c0911ce523f3acaee6ca8fb1c73a36b6893d045d89723684830dc82c4e13c74fd475dfd5853561defee3c48c225949a1bb760a24846bfa741ac33ad1864fa39f9626fadb18b0b6f4e823831a465265361c5cd0688a8c7892c5cdf3d6d5878217e6ec35878ffdeeb7236bc456626ea59f646cc27b8598196cf4493bd59eaed855515d385e385049fe75f9638d363314dfe9b2993667cf447d1eb109bd875789339c3cb406f6dbcb4828c1ed80e943305dd56bd9eafa74af8e1347f051d2ecba26b62d3c84696939c1ccc33dce75f4d8447b187f94ac832283aff0a39f3e03f03283b5244e717fff984cc50ed0dc71e9ecccb05feb2a7188ee408ea86f0f6c3560f8559de6f19548d884f0bbd881578946eb6e265033a13cfbca8b2284672ac70fdcd7dc60491192dac658fe07b78f52683693bfe1c2eca301572ff46d7d36d994acf8da576b5ff25b1bedca49e5b446fdcb5fd6ad1c28af97f005490073d842a9b1f235016f2d655c3981df6122f1247189dc51ba5024e9a3f8f1bf8e95efa94917c53d563f45fc755e3f179ae699b908b9db963e66e9f8517722d29afd9db4cf83a7e2123b3dabbed1085c64891d8743cd38f4ed730a34c8461557fd7ac269333244428263b367b2a2f5002b216d3c012213050124847f4011860647d45d7acdef2464d5a1b4f1f8cc1240a791226a34832608e2bd6117984c99bd42c5e334e3c48f724f8a9677b669270704f8b8a90300aa4aae8aface149912df94a6c9ceb86fc277b0249bb285060f6a3663ea95cdd42fe3be4e9704d81b5f232a088bca7f34131f4acc3e73a072ca321af147b7c36fdeca3bed8ab6407c0e979536e6fe92da0b63e86d5d1dea184fcfc03e2b3a5e0b11e721200e7f0e05d8b66401adfd97cd8800609a51b583c1529f869a16c672c4d7e7bfd9b1b798315a578b87523269b1a9f49593287b0fca67e76be34b003703f879b453500beef9dffd7d3608248f8970ebbcb3cfd0df33ec15b3d45f48c0ec7ff6d288d1949da29cf2db36beaf508b550c6522668d1e3b16e1d3483b5ad5b4ef83ddb82a1f31b06fa808c26f00db4087d7089ebf0a3aecab83bfe83652ffed5f566656dd7c2c34e2c72270d11fcb75c00019b9bef5dd23ffc9b0d76d7b2196b896ea57256f2338ec54d45777e6e24f4fcb3ebf0c5567a59a0e58473756ed2919607afd2032010f82bfcc5f6e43047a16504f8f003c8e0bfa9c2e93800e031258d51db447af8b901eee0aa53f395c7f175ac6ccc4c8a6751dfdb6326107c1a297d6c67f6531b843477462481a45257c96f123ef3ea7d985580235f4258de90467d777faf9343c6bbc6f399c1f63ca998b315a4740bcc06dddcd1e8f42bb642bbe60cb6064801378eedf14eaa104d95ba5ac37624f327013af12b1a20146a29ce086c7244fdcf068cd07315385919835c1db18ed68184c984feb5157a3672019668d21b32ff5ee873aa9aa68944046a3ec925963dc220d54ff9941265ec12d964da7e81222f9f85301709c2a4bfbff281b5156079da5a9dd5d57a8a3d208b8399c587dcd1a1526800ac7d16a5de07787d34c2a1b6fc1cca36649d6413ef56a8e8f310e0e7856fbe3a8ba3cc7c0186dd0e6fcd3bab48470ef485aea22f4a55360f7ec06693d83050017ea69bd6e91f6d840e255a86bbdbab4689e3b5f2b58ede8d3edd6f82c64771a8f2b76bf19ac1aa77b60fdefd7be9f2c3dcfed00281726b13ec389ce4bff119f9ce35e687c390674396fed98006f01ef22436606e9b2955ad7047f867d6de1e8e763f4458d412b56f7eeeef48262ae5a7b5bdee8074c4bb46a3a796d7fadf5a2b2d07fba9769bedd00aff3e70ec0c99760db5441bcae5069c0642bfd132a9bbf9bf6e39055a88fa306d528afac8d191ad9a874cc9a14d0b9f5ca546bff85dcabaeb42fc0ca36526e3d9a15bb75fd313018921bfc026a5138ca994d8592a5269de02aec3a1d2231e9272e517be71a7b7d33fb9f2658784e8ba5d1dd2f06df582b58f874a3ed5532e4569c8407219e513a7ced585b57d80d30c6ee0a9a2fc3c4fdfc3d2d4899084036a75d96e8bdc22ab0b6aed43483acfa5910cc5128a96b2ebb790bd8aac2045f4a039c1af53648b3b6d0fd60ba7b30c949138826bfb5d442fa077a586c4973a5d12c711f4f09ce2c544df5977adb6a66655703c160c512ab83ad99580d946ef63b5ff617cce0647f7d3972211aa41047736141c93b9c7b298c1513dc0dd325186dc43b8aa71fb9982a4398cadabe77238359dbd5147d196e1b3468882f7350a7217080f17461641bd3e40bebcfefea96e7633600e0623a53cbfda3abb1354c5374a8af28281b6fcec792b4b5f50caf11e104966c8d0bad6b88e7506c0a1290d2a81415160adae4919d83fedb026a363ee5c9cf03c4479d3872c064f40d797086ddf02090a637e2fd2a494078cd5d8cbf8f6765d184de4863f46005df0f1430eefdf4e8c934274a457017304cc46ffdac427839f1efeb9e70d8a3bdbe81aae38471e9f3f04c664dc1e9c0cb8e1b2bb4c595e7711df631e428715bf027c112869d6c4fefc68228242b4e687b1aaec127747ead40052f0e0b0d859de5512a97395151f611c4de5245561b9aec4c7a55ed6d187631a3936ebae61e0fa8658f5376a98a54faa20aa446119a572805b3e220fd67c5a50879cd4f483997951503fc3f727e7a86d65fe9e745b9ec3514d649fc6109510fdd207b98e1b8ca53d924eda1d2ec30ed2a7e3b035ba7710fbe3a90c8c7120505b78f93653e73235d934b524e7f80ed2e2adbe9594e52591d59579c3d946d6d9c8ff9d35d536465c4195f8360c18c26dc856ddfb343c30dd520f297a15688f2628423440dcb5d5e0e4590f1fac2872bd4c5a2841446edd8b47d19e6446f1e900031476a2770706b8d33021dbbc846708b0e2f7fc78a6f539aec83e622724e67b7769bfb6ba3c1a3b673bc21ca2e92e3fe0dd04288037ee0f3e9f4215b9b808bf2208c4a1b9f68e04e3d04a4d8762406be6918d787cc406f5e567ab7c9dbb09af4cfff6ac8a80211a6b45faa24506c7c9b02c1b1f05bafec4e9eeeace6959abbdbc93b468eb770a60305dae5cb90a0d19b0f8a61e039b26aa84b5ac1d35cdd75f90b1a69bf5332d76901c47c87863c65032ebed9b654888f365c9304916ffc4bc50c99aecf27dfbe3055e4b361394e78569bed52915cc64f200a2b03467b669ed6864a96a934b6169353ea5e38ad42a875c09e8505c23a6b0164967784326cf2b9ee1804a32b5870d2095693c1924a65e396c2330eeebf810394207acb8635561f029eb797448c1bb590f3035fd4a278bb68a7351e95c02a85b6e4f4aa908ea614cffbd2771bd8b32ffa378db2b64ca30e9e330d2c046b189e4e6c617a1cf32ec820264702c3aab8b1f8187fe57a9f029f507c9db59f09fd6eda4d6a2096f825e9a3714809e19af52ea5d425dd357e7765ba414d7313d9d821f401ed22e1c087ac4fcc815adf3e111a93ccce6dea9e54abfd44f6922fdafecbd96e9580c53cec6aa0973fcc1833bd1ef8b07e9de145c79ce63a939ec0384e51d008663c081724d32663705861f47b197bcc6f775dacb0a05fa1571753ebee1cf8a4843e99eeedd69e3cf3623a15cbe062b7a05e859c66b25817dcf60004708c5b81ce87cf13d62eb48c879420f4ce20c5c0641afed441ed129f3673778149478cf8a1e9979d87a9858ae2873d59deed38620c0a1bfaeb4c098ee85fbdf536e560afafc12fbcec95587813cc6952596f5ee66c4ba62ca22ebff38fecb57c74e4b5baa2a5fcc772987d55a69b064832619036866a687da7bf61bfb67692274e499cc1b4617c22ac0cddc64c496d90cdc733e15b6595762e8c5bef149da875e9b53bdbc5dbed400277342e2b4662a93f50221cd996243b470eed2001e33f5a8b83f89e2319b9b45d79e20bc224792f8859c3684626e96f4f4ca46acac4ec4d3c7762ce6865dfb6087eac4501544f8aec12f73147a7fb8b0bcafb590a444224861868ab002bd7720b6aea77d8dc69b268c5b778d4fdb68bda0ed4ebdfe0729d2a364cf4b36ad67be8fda8b6268256fe1c16bb21657e5270d698d9406a364a5e60c4d0bb989b2c381663b6c6ee09800b7255d1b6491a32c545e607693b03f84750fdea54fb0be8b933bd6561da8ef39b52c4d74213761f68030aac017bfd08e6b4da9dc398d165df998f041a8b29ca93204fe882c011fb996fd6ba6bd556fbdb6b95e988d977f43bb8d15eb660332f2a81fa55db24dbde7d56f4484c69f5ca71d410c2a5245917db228c3dfef151776f290d93ea809ce1a758d891d532e8bdbacf51558f9263a47f1811a4090cb50c0632c6863f597cf5d947c4b7e2ff1b0638654510c1f5ad87db465354a534df653d6c61099fc3e4111acb908ac2a05f4a2d7dc70a31ebe72524debe3e25ea95c805911379d3e721b356279f317d7329f42f5ce33dbef0c2323dda635faedb214727c167ac37ee5ae51863383967d9605bfa0aef06ba5d6a5893f8334a78c10895a43e1072207c7125f0f9c04cfb7d07a4b54bb4a31c05bec14048bc42d243ad23951d453918af98d1df03cb63f9d99b03258e299da9d364c42f9059c02eb558f68310ab2bc297c8b9caada2dda593a1a8a893ced97bacf6edea36e69a83728c3ec62dc2463af17d4b4917813f476b5c7f2f79cb9aef5ac26110a94eebd00e4f9cc90186c8f46ad54c33adc4cb4a9d95fd5033696d8b72bdc420b286f3363c23b9da76ab154278960b80461d0d2dc8451c3362c529081e627a2ec10484c1e76be38060c3820c2f163d998ede6a6825f1dc430acc2de803643c05dc678e87bac31dcddb8f911a9e1c06b237ddddf7e4c0da9d8a3ab44d4ff95bc49908612750d862d5090d6234c1acb84b0c65cbdb5a8372c430ab61017beb37adb51f43ac8ed5605d6c2503c7cf2aaceb94db377a869079872f7200cfb6a6400afc01969096fb208f578d0fe4e54e5f5053c84ad15218ef3bf627d3f238b1d8e879fc26b0092e41080d6650eba09d8f7d14ed7b4007d36971db1466e5d6dd244753d0454d6d1f1184f9985305e86f0a32e05716231e39d75c53d1e06ef8a905561251dc954de28610ae87959f459f4203d79b6bf2aae3e7c78a93b9f4a0a652d4c939651575e621d9cc06c36442c8139d03605c7630eb9fded1a934aeb1af748455cda118767622b6a11d2af0e99e5a3927dde2abf542e088333c66c636e9f817010380ca4edecbb11ff39e9de5b5ec9652319e6acf41feb555cd72a990d209f1ac3ef6dcb7b555d26bb55ef7640c61edd72609eacbd24868535fdd3e34d6ee8ffdaff6367d1670682bea0da39f9809bf37b5325c38cf4a9fbc7c3dfeb0c8f2ca7a10f42e9249c8e5214894161ba0ac9fab049c7f094ea11aface57eb726cc08e75c59c51194a53bd9e5d6d57557eda734e4892820752ed060ac20c04ffd729203e3b41b09a01b42e9d5cbff83f096835d7ffb340ef742265115c6e812b226b961e8e23e3e2107e718e098ef48788d278c8bb578a7096026732ff9b5f87c5c80e6893ff254d219997f8919e14d49d2b6db209452feaf60b27b77273115609a9727217dfe12506ed1124b448f5ae7c5bc6771be6c3ae410df7bb0b852deb84a4d7996a8f08a4f4efdf08779bc60f769dd767469bfffb39a5382b4e2709c193f61d359a2261d2e833392cf35d04b676988158b1573e666a62f456bb639b555ea9cbe1b88dc34886a2979b37fea41eac9a987f4689587384c6ff3adae455ea8e8099966edc75fce0936b3b57bd60045b6dc46ff1597b4694d80acfc3873495345f63862ec74b5985e7b009c357de0a17fecc6610cc82ba2692d808160fea9ffd1c86ac504ebc05d7ff77459ff7453ff0efd851cebaf63015a9c46d9be5dfd0da05e9aa27a9d0bdf3e9bb7ef9220dacd4da499d39ba8b6d18edbbcaccb3dce0a377cbd6d4a21893e0543fc361267b1357486dc87d7f5424f1c094dc209849d4be93ad73deec29c27df5fa6b151e54052778733768e7742cb29dfdf916f26a247ad099e80ce00f8ae3061af31d37f560ed43f95808d191c4db367473e950687d500d67b2a7700fb2daf54ec8bb3b8577b7986d10ed92e892eedcd5cc0070757a8283ac2ccc86a771208b3f537c189a5193dd0dc1876f134fbbdeb47a746c739647fc9c4604ceee0e28641f18098b2db3ab690ebf62425b3a0bf60fbd965706fe95edcad5958ad211fac00e2bcafd40ef0395f989ab5472300ba605cec0b19cb2ca89ef0bd135bb11f3e00349e8b6b8829dbd57ac23544da990de0b74250c88b9bb581101dbcc6e4ab476c8dd2463823af9532a066f482a88d3651a4c118b6376194bfea6dcbdf20a42ed1a2b2522f9593c611326db72ca02b4783f927cc3a42642a17c9060c64fc999a3e421472ce8a8bc40de14a2f17dbc5b78c9023473d8866d65c57d0639fae9371bb38026ed9eae9b4555954ba17e736a7b73904c011199be988a49c7d7e8a24678268f47f8bbf5c575ef122551257cdee07b59e2970fec86ae5a792647a37725f4964af8f9f4f8adddd56abb62ac8c77c078dd708585406537ddbedbc497e7ec0ab37fc4af38e09566dbfcf3393e5061637762e66037f9bacfc1f5f1b0760c7c2c430eabec27077571c206e295913be73459ff67714c681151ad6c170e00aec481ddcb80e94a3274d522129175163d1487bb63a120d8913c474d2ebee369c6e7be35e42dd30792a8b292f9acfe41c63fb7f59c0d67f9f0bab5360d03120e14d83ed59029f1628f47cfdd62e104e2cc9f5c7b0f47454cf22bfa74a5e002d540a0b85bbe48bfdbf75f936997386bb66b88a5f9b32b6c0bd9a692caaf19ac0a1392f558bae68822f68b602f2e34a7a1f88bfe476032adf23b6f3f3dabe1a00824fc84ad1c638c00d2daed21af037fa9cd05c4ab08f21ea9ae85c842f84c560c44d5363614205d210c9d8d21aa7daa2467e1ad563126d11220d692b32245df38065befecc15f61daa9c2fce8434bf6bbea5ddcff3030acf4a05536f384bcfa6404c3d3b072da8f8569f4553ea7dec12fb91f435e9d66f732e601cbd9e0baa2b0c05b3fd4fb597c10e59b43ae7cfb3589d8b392ce26c3ab046a62474c7a85375e6aec289aa21c7bc889160a69789383f3c08a482ce4eacf4c7865ff9b360499122208912dd498faecc305402045f46a520272d12744eff41ae259071cc33f266033398819c5b264a28706b4cc73b8d3ff0d1c50ce7946bd3f9ac269730e7f05756e1995b5273fd80f13754548ccd6ba2897010b4deb5df29f207131a3df4f1794ec9b89ac7f9d2732b59192cdf164e80d7cbe83849cf120eb2fcb887d4db19b06be7c80a984c006873e59d5943a4a0f61ee0b2051bfe9330f7497a67b84e3efdeb50d5fa238b48e3cf2522186665efb6bf962c8efa01c3e26c9b39a076e35a7d5b125e64336a3c3680ef37462e28d490fade797cb96e8f5306bdf4fecac3fef4132f50e4f885372158192f0f0a48e089d1a73bb57b50c7da1d6354a504937e16bf607e397b91a5c7fa52728c954aabfcab5f22040ceaa66164557b0c484623e9c7cff908928e29cdf35d3bb98d3a2f09d1658be992580bc3cf504faddab6cad50c3b08cc9c873064f0c24f5920dc4b0ba47511b9259278cbed98f8c1c7130118e3f2dd8f8973e6b0423fe935e0066bae67818f36dfe0100e4a01bc99aa887292241636b585a38bd476b2f67077c4784208273ce8ea49ff713b82b41bda2a8e434d4dcd6d97a7d82001de2d04c51f62110f46fcf8043b2e64a0e9031fd740b052ad53affa501090071c4402fcd14ce8d52250010872306baa7609a41a848b1a35e36403f57d006f600ffd3fcf38c37824c27b5b19aac002088b858183735a991f3d9759fd9aad1160fcc849469f2b0e141bab7fb0a9fea396fef286bcd9dd544fabdd6fa56583262cb461c1963feb861548af87dd76dd1cd6df23c1b97bfc159381d3cabf38ff5c5a92bdbdc90b0f32cb750a6e94fadbe928a41ef0b82e12feb9ad8351d4918ff5b3b602a188f775723cee34571d40e812914d33ea02af83541f2b31206f2a23c03b7524de4c491128071e68c71c43b0260f23075b931e04ea7b2ff30d7593a29af2e49d32ae302b8f7865915905ec22c71a1938d4519a5c10a90fe8a818c6fc8e1b4e00c470b60c80238088937cb4bcdf1e51052f9ff7138757737f9e786c9e4f5394caaf0b9096e38001f46c61b2341f948ddeac71986a434a8669c6c19e8a172c02c5bf7934e5abfc608f77bf57c266defd572f56615123067a7d9e437a9e8bf7e90d6beb3c65a2ad5a703c5e2716e0f6cb7d0e74ff9f1f749c55fbf8b8f6857ef231fbdea8e104ead42012d03b98396f3b58678ba09dd4a0228e31faeaa6149c2f4a418dc678abebff0864d74707e39309a86558c6c157480fdd7f4cb534546cff5709a64518e5e65fdc4e72a3be321132ad6c8f178a39f2cd86d4ea51f42e47b17c14fa14943cd3d349d41b9f382605cedcf8cd5bbedc265c11f79dc7a03ee5d4edb0c27b28aade2ecd352751a2612c20a315922c9df2b58d283b0948ff807ca6a543a5f516dd46e268649dd9adc4ffcd643269925e26c0e0986061171a3064ae21a1ded10aa6c549794a327471a06e794a0c3a497fea4206edeff4e5afefc29ef4b6b8db70b8298b5a2a6de327b89fe033eeeb911c65366c4919aa0f7fefe8dd90e4d646d0229133b5946041a49311256dfd582e915f45acb6782343c3a264a4a013c2d2a2eed4cae5bc89af71e678c92c91fcf5c526e9ba7c4f9656131b09765d876d9f200407dd950ec23708f8c7739c394aee809527eb2660194fe9b3a53e53a681001f643629d9f8f293355c3e2c0c493991c5b1e5fc24233f4df10667f133120e9a25c408d1b12d796d8fc7fd32dd215242e3ec1f27ed31ad5aa694648f778e3cbd1fe82d4b1de324479c76d81e7e83723506ecfe161196c7c8021a23acaa8cefcfc4caae1e496d44feb32edcc07dbf62a7234a63741dbbd39dbd144e47830c707de43199e2b3075c510ea6bae32f3d5b87bf7bc5950d0f5fe073b258bfdbb309565ca84ef7a416d628650f7c308a09dd52b3589c4f579513aba0d985d15b607df5107478b63e0a951d8263eea8627ad80e449982ff5edfeb53834f89db95103ff5239a7be5ebe0c8d65a097e52f2ebdf3b7369a93f7d30dcba10618145787dae412f35f2e0465d2d6db8e515176a7655899ec0347d873433a38a43bfd7781480c7f578fa5431f49c65e64c0803b19d4b5c8e4ec5857dc4e62a4e99923f92f1cd7db59bae044a2506d2de141667c5fab96b7fe6572951cb109a6b0cf69cb308759dd6e32b10fd2cd894174e2e6946f04b8b121fc9fdff44d9af82f8ae9505536fbb175062886c0173196e0b9723b23ee655254fab6f78e138703aae1a5d7f30ad0ee79ad673777e869b2f82186287e551cb85df06efaa1629a2946a865185d2c9920d44de586bc5d11bfcdb90702e2ecbfd0dab7b802e1e7ab1da8b124d5c01f122ad0be25c70bce9e1d5ef18c842a772d2eee90ae9c704dd1ef45635f0465cb821b7ba9c0df08f7ee34ece9c840b7a85d64912d5bc9e03a7e7313319f5274464cf73a4897d520215b215ea72f8e21518b2b968c8b18cb6aba654567d706279a0cd36f7bec1715c3f6d3892bfe9665917529c2267b74fe6b1a3104c14bfe520f3250b703497df556e7f4300be690a41e083489222b535f9512dc98de6484fb68b4d47f0d92c91e6ca3fc61d1b94e8a261be4c1e696f88b9476f71ef6b3bc28888d5d0e95e13405b0040158e0807c6b9692367ffa0aefce1b30bcc21b4b96938344b04acb4e78f14301214790de8fb265c2f0e0c1890445df32357890e11101cc6f24a05d6635e64874fc59b9e9f97014657dc322c73b11680537b8ee363617e1298d40aec4d5950c2405b902c0d31560ff23a544bd181f8d22c5764e34e2af3054cbb9a8f7be0b277449298729819e9ebd32eecb2579973234adcba55bd58196d0d5df3b9f04b816549ac5ed77e923fe7bc78c65b34212768e60c16801338fc0232250e41bb0233c75e157fd65958c08ec5ab321bfcebb75c4f7bf10425700f379e5365d6f02222196f6658bf46a7358ccc77e791f21a1243cb77d3006d00ead0d2a88ad295ad65b6e99715bb2d0ce3340110a58d5238808a7eeb738afce7b65ecdaac436d789db8bba092fc4b033b139fa917e6c8b39639319ed6b324f0b8ff437120059f14999d0a87d691556049b5985ae6cfcaf47746f3f627d501cc13bfa93c76a2d71a7b000539ac96bf8dcc0d32305178adcac5fccce94e8c84a257c863ee60740326f4048c4bda715f08a60432ef8662a0fc83863fbe7638f205fec479a1a18d9ab99c561031e02578cfc130aef799f703cb261af7c30a3809caf1d347300193758cae971faf445ccaa670b53d441e2d94971fe5d76deb0d90dd4e04d876748b10b2cb2755e8ca9773569e15a545dce7f8b94df76fb148d8165176293d951e6acb071a483a2f02936a5dcfca00b9da9c16b2d4437e8ef7d0d846a03b3af37ebc3dbcbc393cc37535774e0794930d2fb8d4e0c60e362ef6950208af48dfb46bdd7e18ed06bef46ff77802368e6a3a5e638232e4db44fc4790380193abb6db3acf9bd1987e23fc01e5ace3f59c7fd6b076b21d9bd8c6bf6fe6896dd20f51ac706fdfb62cc745dab8bf4d95e135a306988f3efc661a9eab22cf40a01a3e06979922e58f16a656b8eefd8c3475e8aafc8eb441558a042bd5e1bf4c52ff2759e4ae40d3836512819df6eba416aba58820b6f75fbf0abcdf97b8afbde61370393e35598df5ac1b5ee2e23a1dd7e01e7c94b4ee3f1f92e87b5bab0dae8b961db78cfbfb9068747a2ff840451f0ab2e762512c7b7f2dbdafac3ead50d418166639babe59cd602ba8427b760d476121a3d3fc8dbd482b6b8f9d4ce6341683fba2581690f1316d85db26f7454bfd7da88bc7cbc4956a8ef950f44bb54569fcc3be6d694ce4bbbc574ab1f01fa72d424e7667525274595bf161ba188093123fa213ad862f802d4293e1302a9714f795c08010a7a00a67ab4ab8e395ea4d9f0e7c7f82a1e00a16dc0b73f274536250f635a0e5d55c96fbbdb909afcf2e991607b486a44c6f7d477b7c6cf85bea8a67dba5adc7992ed9f20c7d4bf1981d23c886faa82b798b7793057e15b6f98e83e10d1e37cf3eec7554995ac50c0abb7547cbbc27590fcb451d8b52f8b0a8fe54ac342b7e9c446c1c6566dd1ca2fbe6b6fbf7c1ba17b10703abcfc7b93baa0a8c03470ef9613a5007f6539d8848254ecb239e58d275e15cd242bacc872be82e4575bc0ea2bd14620b7f8c98e9b1f5e9a66e2b4c61a91b34a1d17206a40a087fbeba4672bbfb3359a068f2b9d4e2a1509a99043e230fab8637bde467e670006e6e5578a98d8beddf9ca9b34b9fec5f587fae1eafc77825f9a60910d3ebeb6a33c00369ebbcc5e28a1bc69eb0719db73a9b5c2eed8679d142e77a34c590f659f8f17f702ad5f587b519e1191360f40c1cb6926f639812f30f6b4ab8e4bc1861f4765f7c1782060f8519122eb7f575b7c196bb45746b53af8c358490cf430fc43338fafd49b00bf8bf8dfcfb55b62cfd9de22b681cd10aaae575e609dc7b49b7da40e4e21dfe16d7a918e3cb3d022e2e346dd8e0449f99a91619ece7c6de894a0c0f0a190d49edd1c24b6d81bf19058f6677731b31491f97473271b3d1a6c1cbc65616c971c0d7a79f6c484b8e338c64a434c3f152f9cf2703cc034999fb1a1cdbdc0fe6217a4d0fa07a868ad7359c4d1dd8c9790d780b50309d288dd2724af2ca48609d38987f471e685f9129da7a3b62bee2eb4bbe3b4afc7d301d66526472888ba765ca553e455965b5d01c6a4c7552b6266d98048f1fcf3b8656b34b42056bb96f40dfedbf5643c010f56379fff827ff1258750b883f3cbd0fce0137e3a60b631f0c614d51f42146d88fc7dc1a48c95080f114294a9df5e64620af8ad8a6534162219af8abaf933b5351dfc7417d74eb46919c93deaefa4d29e92901e2f5adb1ba870af9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
