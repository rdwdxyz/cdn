<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe8a73b1568e434bceb837761cf85ebc89333b0d97517a15870b283e48172679161893b845c8ef484b54683ff4a454dbe6a4d0a013020c32dfd751db62d5b758a2e56307c3a4d4fdb664ab84b8f88e2ed519c2cd7202901d23bb664428e0810f916c8595121d07c02eefb267284736466c3ec70f5749a658a4142fc1636265e6fa72edeb59223dd235a18cf2f8ec71c60317822c6fe1a5d468823cb294c8be53aae8e635e2e10470ba35b216d90b674f2a935810004be6e7afa19520c75058ef995f159c0a9a553ce65709353de6575cd2fd85650f0e8150c40143ab0d36ae261ab7f01a54df69ed8642b2c3d211594ef20a19a7a7889927c606563bb704356637de1dbc6862fad5a05980c4f0097618d8c7f6c4571336df549b5e30fe7af6088b4086d221803f9a3fe5eefa627bbf3c726d2d9450e6bf7d037623f6d75fcdd8a9d78b08d857809f41cc0cff6b01d71f6b7f1ade98399fb499d8cea917e6bb9d584da8ac32e7381430aba2c30f72dd32d84ce50dbe86b0f6194eb28b935c0c6443ad25716f34cb52d8e7d876851fcc13dccb0cae937eea2423eb4ab740cc3d04ddb48480c4213f0ed297890106c0783f2c52a11febeb49dee3dbebd0f58400a66c9e2ebb85cfac1361a324be623d483a6d15a0e0865904996df19adcee4ac3cf6fdc9a14b320803950b6e0866897096ee5c9bff1f63f16834171c35664731aaf0a6bfaa0e1ffe1e7b746bcd42b64aa63404a489351976c84ea77d49d416692214f2e18843089daec6950c45b69d33eb5bdc36c13a0ff4ff10a0cdafb6dbaf0a0a4a186d5a7bf1fa88d4c053579de12a4c683ff175bdbb21b912a7223653a672861b95194c8489124e305edbdae7e5f9f3aa12aa4867fa6c62cdf70d2916ac3bf33d649e2456e7408f6290560348deb10321d25e57837c39418cfa25b271891b29afba66c6a3c5ba378fbedd292237306aa4d0becb441d0741750a6a8a9fe89726e0b9e8c11dadf347ab7459628d26e39b067dca2075da0e0b833bacc089718902ec4dded20e8bdae46bcb57acde36d2f6dd456d2c35f8dcaeba1573fb2a381f76f925ba318a0e22efc640a19965fa9fb74a38afe2a0c45f18125952b743157b312ba861603e737a8df5b80e3eb30b62d65a5a22af7c81ac77f3abb93f1cea9a64b3578db5e466afa04a781cf1afc7d5ab35978e420e1aa881673519c326ac5803c4c7b3f678f74001961d5001c8e1ccc5ed5f7d4c07c55092cf21a7e4a5bdc72addeba02ed2dfcbe9c7e71c05facea4b482bb6ca4b5c1de466286b59515f4e6e08dc6f01e48b5da05c2db15142948118dd85b794e39e2669f639e6e31e6a64af5e14d518cd0d8e738397bede398dfbd75d2e40933221c8b0ac3d7ed240205a2af026cd6932a066db8a39ce4389141719c323eb9206282cc71932072f244f6f3e710936c8a8467f2b0f0f580241837187b91e5e6f207a9ab61a788d5d30dc4b582c8c00eaec44ee5cf4d5b84149a606968f2b0f49912ef57a0ddc9691db02fa1ef9eab402c22e8a4ce10db28ba2d440021e7adfd8e9aac7d67e9e49ad77736c62f335f26166a87c539eada5e6a6fa8f73793d00288b7028ecb77113715b62878f8b13e5ec122630258200ddf647798dff0df5f2f6357147c43955dfb8d2504498c460d9c58e15263d9744e6a5dccdee5430dee5198f8b3b0816d6a4aabe73a9ba23190d2c053aac921393b1554489366898bfd11192b649462ec780c0924897167963333ed8ba38c76fc29e8d4ada3312d412aa4f86121c0d7d35545b59d9ac2d59df247e0f671270e0c2d97a4985842991ea7a74808ba6268a02c8a5416876847ee119776c4d85ee692b260cd4a6355a0fbdf3fb7e618f2ef60a6aec0c766800c436a60d720d50b93f44a439a5197a6e463f1f13f6fcd90339f880d6975ae21a1b26dd36f85910d064dbd54155c500bb883bce0a31ad04b6ade86d517257d073759ee7d715964e5cfc8c6f3ca25a06506841846167dd73fa5b5207e228a7821e4ecce8bb73724dad72b1acb6bec3c060c262f61b461b5076aed20d31b03325bb1d7d1421bedf4f2eab30aea1f449a9fcc31b69828d3a7a44d6b7003e6cc0a8568d85221e525282c2dea95fd216dfa55f2219bc6e8883f316935d5eb8534acaf9963265e90783c4a26f4b9e255b5a80af21dfb34168fd27d66016c9eb87c19afe334a20fe81cada1bc8adb5676d14bd8271de704c552340081c4772fcca3a281d03f6351986c7a9ec7fac8f1cabf4110665d094aa52cdc96e9c9ca5f53a187f706d511e995d1f66ca5d1f8f6abc02a9211eb6425c88f49898fc4e184767c7f07f5354e178d7a0647e74e43f760a1b26bcdd86c9d7eb8d685d734ee1d6441bd86f305466152ba055966c2774a8aea52f63bfa43e9b68799bc692803f44ff076ddad95397d67e8ac599f64013ca8767cb55e7d33a09026a361ccd48aa660cd9609d5d0feeead606bcbebbd6e0bead5a9fe86c9a191158288bea66371d5e09dbb1916ec6ee36b6b3f97fc0524af5f5230819749c3cc02a3a27d8710f967fb8f8e438d360bad00e0cf8806d6c3cb87cbe11c5e387f0a93668f8ce79da6bee4fe2bee1b27a6e3d926cb2fe34f54e391834f94efd33aa1bbfc32ba3ab4af229c4d611aacc3dbeec1db4c680ca428f776fb3d8112e4461bd55f8fe7d4484d12b4f1f6ae84bd64aafed7bc7351f942d405a41c74b038e4c705e2ae20a5b6be4a64f1a17f4128cb13f80cf6d082e23d0c11e01ed26c8f43c4db00abc76313018a18ece56ad4af7ae9933ef5b9da4da7eeab5c34cf32cf71e766942ebffc2085d5762f83b23e297dc83a09917ce6ff3ccf69f96bdd531c138aa2df2190b3c4d71c0d0cd25dfb4eb6236ec1c86afbb3ef33c5198d7c9e5df09cc0346a7e94c3312249e032ea70b03178f4caac0e290350bcdff2402fbc7607e7dd491b15103f7598a8df4657d25a4a20a61284ce96b135680b933c3674296e2445a7cfdc81aa18a84668b4c5f57ec46cff531fcfbc20b063d9437c045f7399a11ee94513fc00bcafcc9e47510d1047dc657d959391bc428e9ef9cb5f2111e24c0c08b07680406dfb422e86afb971f0e6340a1ced5b398e5b23e76b534e14d1ceae3f345971b262e34fe4facd8ce4f5306806937d70bba2084979a336b303707393c8bf69f04c93a57b49dfb578cf4cc35be2e4d30216a62f9bda767d7b61b42d8427ab7a1bc56f137aeebb61ed7c21cbb39f535d0bb590c14bb5219f1897502c499d633af6d060356c6eb816cfa981127fbb568f0f228ea157430388a09fe8220626011a872bfc712066c982a3f8bf9c1b2503f6e71c675207cca7dbfa6858d9d2299fdcc414e4802d2865263d9df9e7344f95b42fd9aa1a06cdc31850290600f1449e55965ca494e93aa66e51bd867b1e9d7876bcc36298a713859dbcdce2970cf933e48c0dae6e144d12f3288a2f1dfaf2f88fe03149d07fb9d9dd6599b9e4b669914f2b8f0f8144939734bb4a806c6349901587bb968adb61c246e75a316208f19122a56b5ebe47c08d3d83e9a85ebe409d0e598e0b8112a47fa69bc663aa126f5f8b746658977bf20a4a80df66b44851daa0c5736ed3b61183aadf634236711009571e95e324122d183aa78c7bd69e0cc67a8803785c0775467e45c15c793bdd274de2aa77bca1b0fa7bceb7782f65360367ae56c236abbedf1887cd1930655bc9f9805a33d3e46d36a8e4df32443a747d52e73683fdc4dd2859aaa380bc584dfc1f9ac20b9126ac58f5905eda9edae576af1126df4c2e6587792d4814935fa6c5bd084fc1dd5366e8418a4f47b8344a098954e9d053892be685cb1687890eccdb8ebf19af7b6685df6b1d1aeab852d67e5e58628bad3dbe41dcd0aec29f7400870862cba332c5f7f6833f288f4c54a6fde82329948bdf453ce6f5f69cbbb4da7a0479477748628cfd623a5e2453558f66a3d814c1e858360c72cac5cf14d677c5fc2c33733c0aefd5f1cbeffbcf675b2f00946ff59f28eb44b1421b7130cd49c3297b0107f8729b1869913fef6144273646033236b615de339eeb56b7195a936374b121d619ad249307d7064111fdbcee537403194d1aeee8e4376f78928451bfa527dbbba921445fb80ca8fc1f5cffc41e63afe7939b22ac932d43e8848755531c80ef67b273cf8157a1b180750b2cb991747f2932846f3ff5b9c52af3ce7e37d5f0d21ed3e111de21a0f59c529925805fad4054829bfb74e4f88e4294ab43d460066567810d9119416ff63f9335e992dd0137914d26b3ed17f920880b568ae24de2f012f56c9367df33acb50e50c071278cd2e4d1a337b3096f8204ccd8cfd08add2ec4f4b5e0f386ed340c69b64a59c5a0e0265771da1cbf75740d2b3a3c2ef39cf2175b44720cf92a09b6782668f221e29f407230f785c43be567ed2b5b37d387b048d83526fd9406b83c36f20e4cd7138c1c8e76beee821e3ea1065fa9a8fb70e3009b7ffd4d397ec46e172db6bcd910dac54933bb2ec492e68c8eceb154699580373a3bb9009da9033e8f786d4d106716b3dc804a8772185b2898b4f4019c09644b28461797a93df59b29c6dc70d060821b1f510f20c3e1606799a5501f1c35c25a27bfd2e07f68f71d760552c88851c9e75ee382fc807d973427a811742d7d712dae41c6dd7cfb73e0222b9341e27b52d0f32f2ada55ac94b3a010008783cb126f94a584c816dbaa1a1fab3fea964b1b1d3f2f962c2a0a26e77e5ca01efee35320e6dd759c3b95c68f60b917e0dd40002d991fc2f87148e0ee2ad12efdb83a9eb8da9e9788e9d28f43574a5605785b9eb2cd16f8c0f0dd588fbebc8f367f3842d3c0df9aac89fe4f8dc70d137ae80c4b27771a5b53affe7b858b94986820b5b7015edb3d5d4c5b5de9154f9783c928d0f37eb313fd0eb9912ec737723ffbdc0dde04f69de5476631e1f9712eeb6b15f2c579f5f4fd8a61969804a5b472e6e1c04c90d9be18d72a0422cb9a4888c882b90e0a36e73829b25e72e21921cedc2a6b7bf2384b6880a23943edef3a0ada14aaff2061ef9058c9570404af42a140134b76069ff9b2cc49ba5b453ba7aeb544a1fbd7fbdf518b7e3b043981112d477d2e87bf7cecdd07b7fbcede34aea169bc9c8b02b3b8bb3f6142818c3949fe02efcdad13094b23ce2a14e2bf2c00a8c2f18611b0fbfd3ba0b7a20a5031a0df7efa033f0239a153c1acaca570cbd8e67022a0d92bc09e5809574c0d091de51542f51054695dcd1ff202155805843b4689c79207329098f3a62e53444602b2dfc7f6d0922e159569e2c7fcc9a6292dd98b32a136dbf01d92462dc3eba2aef208838c4c8fb98e1186decb72654e159d214a53db325502e41ef5be4fd401cf5491b67ee2530cf7448789dcbfeb5378f9c7b8e7110d300a0e3c34991b13d82a8f69692681989fa216977a8aa3e409959bb903eabdf371aa6b9c30e52d048d8535edfa0c6cd5849a904417ea423850d07ae7f692441819c0df027a451957b56fb64bb6cc74198dc8f2d9a4f126d595abbcb68121a5da726daeb3e1200a1a41955b877b4cc12ba40d11715ac9f3915e8ac794744efa15d74f22e845b0c6961042fa143adcb03aff871bb6b2a1b413784f676b19c5d4e1d9fd57c280de6fa170c30d3942cf2f41684d19fce6b441fd33b079dc70de3667b180075850ce3a6450663e28820eebaea51a113978f58fb86e162e696f54f9241ce673a07c7aa6b72e0ca2da36c6a5a09d24beec6d130f6bd77c30f2282af50afdd409130ade852ad1fc3e3511ae26b54af5c051e1767d9dd088df56c7b9fee7524a658dbebd8cca7af501bb6c3c06ad5e65f18264022d29960ca875305d43760c8dcf908d0c74d8b098fc463052a766d60d1f5dbbc1f1cc9c23a83dc6d9250454c6b6d5ba16c25049f95608a2e146b971cd7d112e4a214127cbcbaefc2058469dbcae78a5fcb43040573037b9bb07475ef468bbeadfaacb46d9058f9b493bb0cee83bfe6a73cceb6ccf5bbaa1d77fd4832185b89aaa437cb30022db9a279f0f41e3a2a751a317bdd95a6016a19f08fbed04fc0fcddabe2c5da96826c35385d812397d721ed1b4610e0128fe508e50e353a3aaffc226f0699b5ccec114e01b192312ebef45190036747d1555b87845bfb13e56ae05ace820c8ec7a2174d6c402c58b988992987b383647ff84eb69bf7ac7d84ab9943c18086df769ceb8a7271b9b163a793da639ae03f09c584049ccb353c8f2de8120e687d7e532c4547dbf172d6967ae82974b965ed6053adb074a8f128ca900c9efa6dbca5c413ba4b6b6717e18c50a6ca218dbff67bdcbb8b04e0ecbabb9dfebaf632cdf466bf20fc6099835c275b3edfeac3a155645a66cd712725bc2bb32f46e3b1449acbec5d699e6630ae1b82ca0a4ff49bd45bd934ca5d0ee0c31fc53e84910a31509f1d74de49b8c9f71cf5a46b3aa305ee4a2c41382730e68405eb4c29c8d6fe28ac38357323673dcb3e9cc75588323c77f69e4bb3dbd4d261146246b12c0d7bb70666aa8f635e99c354750512ea040c4a129a1f684fe79cc0bf7f373e95e01a39ae6274c43cd6f84a9923257d291a5089f8ab842e91a3569a81a7945234ed4c0f343b6246e18d8bf8eae0d6190edf0b8b43005b5a629eb8bf10526358daad60862f142821f4234c426001c2088745eab6ec745fec56abc802a4abb4f65bbc87cf93ac1ef6688bb46781ab0a1c69cb0d87f59e77b3414eb386eb2d8e77117486a525ddc236ab59b1191231773b264ac8b9a61e05d197c5ae45d09fda75eb3ff97c7d2632c8e9330b460b5b24013534b39f5be93f05244047f485ea46d746447cd8843af3003b02196f6b999c63dc07fa08c3b85d127b3184e27a73f6c32938cb327e4e465834a9cd9511c8ed028452aea6958f89d92b0d1ba73b16f3787c9df68f9b210a07ff0fa7ce7b6ba09c6c6616823d0124bbd49ec3621beb7874c0dc168361f36a37aa9885ecb608425ee11e9fec00e448be3af139ee4e520acdb958cb5f6ca406cc305f8534981ca71dd3168b1c6a563629bea1f4a42f89f407be53b66c6674aff7b83b9a42cc3fd9ec76f769d666d838fbd98b98dc3cfd6db8b6a38367cdeaeeedf947decf9d20d1c17516a8eada1c38da6f32188ac87c6524f4684ab9a1610333f23c30ef79f3ba5ad635e07142ae7722ce276924e4e29153ea26ead9a376764dc3d6e49d026276d8210cf7129f1c7acbaaf1916778b810ce6ababc480701e8b2e2090dab86581cde40253ec6053e8b5ecab93b8459b4bc4b431632d54ebf4ec28d20074bf152adf0c5c11492afb6c50a3819bd6fed7f91d05e2d71c5905b69c0f1d0a0e370ffc4ff3c0184e78ca1adae2ab51a9031207d1906fc6fde7cec02ceb83e6dfefa8b9e3bc7b1d0fbf9e8717fbdfcc7fadbdc629baad2a8d7563e55bc65ada5b9e23c0687ac56b67113a4ba07b77fc9a74fef1fd4b31053655a58da0f24967cd53b53154a1d4029dcad67459dfe69bc2f49b2671e16afa463f36a5adf1064ffc678aeab819d59af1d9548c684eafe5df5a6dcd6c99e362dffb3a205388d09aaf4a5376208cca0dcadd0476ccd359beb069a461f98bf7946650eac6b330a2572f25eb0b7e8d91217b9f2660db01610db303c33039c15ab597e0788857e57744955a8f6d8dfcc9d4f60e98696d5cf30acbe5682637de1c8154e8efddf72c317660fd9b603e1a4bdbafb107a6e3854715f20b5aa8b87f3f8662e7a9228d7390c7e1fae244ad3960307823209f19374ed3d728ff9bb36d0c72d49d2f15764440de42586a184b7db7d4b14aa0d0ff683e3881fd4c16624ad0b59da6b412ce2bdcff457ebd5a6ad016d98b4dc86f9dc6a8461898e7a55e8ef2dbefda31223f8288314ba7c5558b167b44048ef21a26dd2a97f5fd33fdb99ba69e224457f3ff0db99887c7001442d69c2c9b4117b083747f493c197f05bc7671131f1b891a8bfadf90489af321a9af0ce07490d93445a123d93794388da3c358def53e1421230d4d5ef4a73116598ca0c7a5de1b76fa2a9814a313ab821b2734eeaeddcea3ac550489f44742e756d66adffbfee7d78ea5ab2bcd9dba0845584b9bc4b65d36c391bec4d9810a23ca333fa2af6bdd636fa89aeb64928c36098eededfde71af985f19e33fa61300be650ccb176c816c820078ec229e30e916053d64d1748df5c429d8e8045ef6dc7b3cb2e3c22ecb10031e9761c0726363a9a24d1e973bb89898558675566cb4a2219b97c7637136caa7b09937956e6eaf10bddf4bc6de710d251c0580a150aaa2ef3403c0b8cac02a909be878ee1e6ec4fcd3b575504efb727227c29072a0fc3ac95f611a5d9b3efae3795c806cd7b9a459a281c93f803ad986abef4c3adb447fac8d95cf43958a124d94fd37083d760afbeef1001bb59c148fd5210f1dbae1b938ac6c93653aadd5e1fc3088389a28ac58174a848103396812bcfa8e5574bf40d729eb22c199c6a411043f10880714876b2bce3d88145838ed638d56e3adfa5be00713019177344ad9d2192cb5082a397892b4d522a035dbd2d72746990d8751499c2afe2fa576dfbe63bd60ce3e5bf8ce4c55e18545244bbbc32824e06c9abdc37960c635216f6d412b87abaa9855595d6fda9e63785dfaa8d50adb049678828351cc12c96ade64bcd488b1612dff79c89058187b947d9e41273dfb330177bd578c34e2d4469fbaa1868634fe30f57af0297e08be63255db73ba7600ea4dcd7cda09c6cecb7e1d61403873cb03c0749c60ceb315709fca651d347a4253ede776e14d27d9dce5dee5ab89e88baf8ae8a46d268e32f9fc3db52ab59b6d48a3ae949876857a7841f669a196e049c8c424a327f394e18653386a401e2fc5dd230668dc2d4db12cd80a0cb036fc4ddf8b35fe2f608e76583050dfe1b550ac18f699cecbe523970bb484d2837db4ed6bd3a5ac73ac7f9fdb1a481fa8d5ee42258c045f5eba6500cb187ddb48bfa7066d1ac182b2ce9a8fb47519ce66498345c91436d75e86118debf0bbb98c5788c2b44e6203bc4fe061de049c91f963df0a5ef9d79f6e716fb8cfcb17480d37e9983e8d72fc3bc8b888efb3daada7530013bfed6155924868f589d993ae6a8989842001e6e05a3ec53bc544c438e2e59e9e9eda95771f371bb53610a6eac22907ae270f6ef2131076d354b70d3e0c923176105be9228a8586383f3abb46e8c5d65a93cd959af7387f4231450dfda14a8af92ed2da598d257edc3d974c7838b63fed7936853e8236754e8f8616bc7c2c42a60b0b45edf1b04e61d2fff89dd1c6c8071f6853b55cf793819e4dcfe765cf3e91c2ad19401f0a435e1771eb5f3b8dd88e74f383a8d1fdd35ca789d2c3edfed3699a86b7291a699be9018aa6094440194390b1c3c56c2823ee00c62c3902d84606c3164b355a4446ad1aabfe0ceb2ba609d2076f906ca5e064b95a550df6aec5bd004e12d15a767778742f3610feef9f56ebfe5125946ae612490f65c51da77518ca5ef33214c1e628153e6649c134ce052b44e752b20ff9734bd3407d284a4196a3f66bab9dcad4bef80147901c4840669a7e6df9b41d3ad511b10a9c62234821cb7a7d848de6c0d8c021ca8516cb3b2af048c27df37485601de8d10b8b4e6bb6a229af7340a5d74c5585c04a6f0726bab43a97bf7598b607c345d29bbb6cb4b0a0aead4456bcae7c180f40c4a5f9a311c2b711d4dfdd45cb7e4c4f86856af7600cef4f50cbb980a6ce76fd415739b55f745a79c96c805175b7eea91f4b77b18578fb9f8ca495be4e653f5fb459e0dbd60983a5fa865f31b777ea5c6cb999766120a084670c3db7e9631e826b7357cf4e227627dbf64e5397e4fafd981fac97243bf55de307dc53769d8d0bc73d2e44ca0f60611a7ef6090537a4e23ed262f3efe7bf9868c02fddfd6a4e3b80d395c4a080d78d40b9c7260beda91228c898fbb34e27e39fb86bf016017918fa89b093bd6ea63983493985ee1c1ff88e4f8186463cbd9deb29a13abc94895d9c89b8e649c4b96eb544e0fb2060c8c71cbcdb61a0a056fb421af8566f17196d33c29963b358b70a874240468ae96be699ebdd935ca82703bf35084ea9c43ef2586f03ff87c35182c9e414a89ec4d82507793ce0943d0c91d5cbf4160d3c34b9d627b58d74c201c52ad9999ddab50cc1d1adcb74aa94bf742ba80a36573571d7eb7a5e2606721eda6460e5fbd08811321a8cc18eb22622b20cd65157d6c10223cd69f50adb7a176e31fc99842b264d353ab0a68e284e7a6b35ab5ace3bd443efa4cc81998ab8f2f574308e35723258be56295adf460d147f88b4c1e559db7e448264d005c97ff2913224899edfb5fba3d4076cd953f1326082b06d09ad02299052c61a48b5227948c68e359b103c9d592ebc84a455d892b6cbc71902bcf5f454edd46d197a29972d87834391d2edf69aa314363cef056fa59a4542dd48bd87300f972f1fa4d7c73f23600c9cc68482f55a17b03e4307716666d4dee7c47f0d862b436c32639ee88b6ddca40132b2766abe6e570102f8a71f740e746438c1b5e7c3cddf7ce8bedb4347431d244eb8b8e09dc0077bb728c45cdbc2653c0aac3522740c44c8816e84e548fe44a4f683b24d51e9d6f9db8a68826aaaa8cf12a26e8cd82491321c90728701d5c68f5c5c965176bb998d9da276f55c44e4a53a467c680e5d3166bb9ac9df976ae58c5f1a184b7de5348196f4e542387bbd2ccd306f1097c196fa2db7d0fb57f717d3576b8cbf49fa0ffc89cf8b4226090981ccaa3d2be216acd7384505f7d14727ace0a1b62e7d9e1f0f25606de29750c5f91c7faea1f709b93b666c22685b92ab7ea3810174ad93df312a7bf316acefab7cdf95899c18e8fa6ada735bcade47e39bfed646eef8cdac8f7606fcffc88742be5d5678cf587844aacc6c74c643f1126086065a97834cb2a7d08d0f73c2bcd973acb31c02192510577c618f64b2d94ecd88c6a27edd7a04ccc8d6786484a663d3036b54673c13729824b16ce1788d1efc9fec057c4f33b3de9caeacaffc65138080d43908513d514ac7ace9cee09d3cbdf5edf41c1a86c64a13f003df50940e75c48005dca9b0dab648d8719fd71bb3f6673707626177755db2eb915ec80dc577e0c51ae5b68f8825b7cd3d807f36a95d7ab6ec1b91531f2c5a7cca43f5c90244136ab7bb3c88ac283a5cc8eb28ebdbb3ed4f5b79b8f1974f61df2396e6b3a7526fb660f786339a28964291c450451acdf9e16dfde4e9274ea7e1037573d89fc4ee0ee98a9de50907d60376fc15cb95582ad21ecdc35a4e0ce7b6a2a469d2ce3d30d38e53d07b14e0aeb81dcda1e2e15ba5176a2878ade2920e9020cf73349f920cc73ef675fe2e6b31ff82a83b071f9ddf82efd354e9b9ada1b12f0eb5027532f6ef87674b6d6bcda86ea0ac77442115fdf2927cefa4bb3af4d70262673693717cc4392d7fa2c8eebfd4ee88d4826a9f9b1a0c505c027d11fb9405878227857ef01a8c6a8aa5e6f96acda6130bbf9e27f44b70568d70afd83578435e8c9e3f03e358bd226f409fe128459a5315cc54136aee8fcdfecb81e67fa49d5e36d9428d0ce2b777ea16e57d6ff532d83dbbf57f637b37651bd5867c8c2bfcea7ca1a6b7e7ecdbcb0f89bcc353c4e60a5815b0075712cd1a390a3b16aa0f73b0e12dd9ae0f4f1142e92b63855959156bf3ad790704bc0fc418d9a04d9d65b9f88f6e3f89dbde496259fc920b7640c0ca557919c8d3bfe24f23a85def13cdcd84f8d4006fcfbe9ca7d3902052697fffe6f2267ee8e7404051fe72ab867c795b1004bff90118831c375de7576e398530e832ea7328507b5b554020cc3d44ebe75509b1803cd44967defdbe866905b4e65f7d8d0d82b418fb44613a6ac07a59d7ed6d59a06c462685571085ee79ae780298f00667b276b0a922278fc2c3be3fb7ea116d50160eb811bb0f23eb3f86762f59239bd605e600395e51bdb827244c2869c24aa179e27f8559f95a688c420186518498717a817c8dcd59011146bf336a05d267338a1f92b540078e8e318901ed6c6e07530adfc2fbc8a3f50bcb251e4888bd4288c731af5a5f91195485d7ef264b0f87dc5b57867bb60d5ecc493e01f2e161f2e55c328be9db40bdb1edaf87057e142e37321ee224fa642fc6c050ecc52e2769a6cbf66ef263fd22a0b877e88895d5809e90df93597f7d76822fd1a516e6a6c2ec0321de248a953862f29dcd13042b8e09d765865dbab1e63714f3b82ba857708551b327b7c30b82935912cb49a3b15e184fd36f1e72f092859f6ee68571b0996d101ba1817691a5e9236c9616208ffa7761ff9b971cc0fa63c951cb59a471ebd42d163fd84959e5bff981f79618a2beb115108d5c8ea33422b9113ae10872bc538e77018ba58baa60675ae61209187cd0bd05b89c40343089f3e78c7c9aa56efe94ea7bb614a307dafd92e0b8999fd0645325158316fc6889aaca793c274c4c82f982825e0673293445bb48f7fa9b1caed87bbc1bd27327b9a5bcf7bff8b8c6f085e06bac1f91c30a7b1d4cfa401dd35715e36ffb6f503c772bfb9c55be9a1d82bbd824230530ec2bd3937aca49ad0a83c13992bc6ddfe2a8b35e5772f3c1be14ca61cb4f5b4b619efb565a93863fa2350caf9148091f7dc1756dd2ac4a801c5fe4de485a1203c19dbc8ed9259e5bfd9ee1f855359c889a73f8b75687b7728d4c6390e9887be4c525bfb00ee7afa871f7a6ef00d7eca61642a0c1a254d7b106be1b1c7b3f9fec4a911647463ad275b928974d06b57f91ba0d7b64e415c0b73f2ac41bdaebf2a05dea1322306b609a9fb9d92533bc6099e657e5e66952f1251c2af1618e6efee6b80c08b290cdfdf465b784f9385b83c21d8de4c722d856859d4c459ba2d591d4165b84c540bea8d49b43a82e102eb8b85841e03c4545f7895ebf4c4a65644295a40c0a6ba939c3182517a60c466fceca578602f0aa7d258a211c0fd79b253b9e9beeb54f2f93e961e36d048b221395bea6e43ca1b5cb7dd1783d660593401a83a52a99c29e87f7f5551ecbb7bca764913b24ad858039602bc9b221cfc5384756429f4ae080825b98c84ff7cd3815596de112acf04f6d6b7211527de0298e848104cb114eb37b306540c58aaf0066ca7b45f296a3791b50760a8188404f837545d90c40e9969b7ed20b34a2d7eed39ca9716974a22604dfe332a0d4c6c9d150f385b5de34c8478c28e97c0fd992f2d13c4c5ac3893828d9022c9a88228124b589a5407c28008f9c15658f09f20b3b624f0af43dfb025d7103877b53d72e511943439524ef49c936a3eccdb0be1ed8fdba857182b0fac6edcd236d9d14d3d77118785c3ec821469095d72e4b77ed6826be4fefefdbfc92194f67d260f350388f5f9972c62104b873bc87d4b972f131fff1990d4c1050ee4de40aefb2449d21f9c1f8affeef0d880041ee19f0a3ce52557edf52a4010dc4114ff738ec1174c808055ca7df95a46a268f9ae037741a0f55c9f08690f63130fb99c461416ce4bcf6b1563f139b7c5ffee69cc68254d83146f90bdf9f78cdfcb4053d9850936c211ea83948c77f8bd927988cd618bffc7f3d88bc3639d6e41d4fe39b9609e05cf58d43e6fe75b07d7ccbb78d5b5c2b9cb4f279ed15ef904b49bf590806f898d98a03052072f4171834309b67ea898e9011431b7c08bd6894f646936b23d08d3971abc45bad082a3241210eb7ecd799f07317270c68ace9baa11b7c81ee623bc4dea57d4879eec980687a800b77ca3897786e633b379186941050f08326207f23e911668e5aa4c7d5ae074640d35365181116693761414bbd19a617526dfa4403b1ec9c0863c8563ab803d84ef7a51ba31f303e23f1a88c4dbdb25c28300814d46f754e15a87c78076f73c5936c0074b3a84e6898b7a6f193cd645cf30ec74eecf597d6b364b5f13b5ea72e9e1a42c943701d5f7bf1947d49ba0fce66968d430d1b1e44defbc700451b9e89b71b7da0e26c950db5f24af2683994d9bd298ce1c67ae0e670f5d085514593d1a0b8d8712202567c230389979e0f17154e47fe3121b680e2ff0426d42d46aa92c4eb5279c52000099fabf0734a1b9a5be3ca63d5d6906df84781e74036b6cf87fa98872913cf986df4be750e453add125c07a3dcf23f5b908804c9f81788510677e38bdda0b0cb0457963aeafb1a4356c44a4b50569ae8d2e31e3030432a507e4ba50f37d16849a26147a7b63767422ffd293f9ea5c0defb8b147e44122f79720ffc411b74d8ff3e96aba6a3a254b8a8f294a615de7470c777e6ba7f4a859e9fe89610405b60c034707c24213bcca781b84c842b5b1b1cb8e76d96ab0d073e06978baf5d8f5e30dcb91d6bb62ed26cd665d9d2b9e3bd94d8dcfde0409781b7366c872eafd664f4318ef9b2e31205c4b9a5e0ca16019761689c19abf714b1369161eb913adbf2bde9cf7efb9ec73e915a6dfe4309f283929ce80e815fbaef35a6101997a9bbf49afbd1d5a7786f626b670a0e52dca2a8524ca4a8f764149af568ad9b8555f9de4bc8b9535d44929f805d05ce2d54756b1136b3564afddcd8c3586241a313aedf00d528f04a5d9bba4259bd867847a0c9fedd94122a778fe1fbb41a2739c7eb523ccb36a5a7bdc6aebd4eecf973614c67917c4119475acd5dde5a3d1a6dca71ace8fbcdc8dfa1419ed02610e9f9fe2a576f86e599d4fd9f44bbda796cda76ec1a014ba49b6df19565a9efcc6bd91c32ddc2065675fe6c4ad1d254f939769f56d3043c23f559b64aef03a595986dfea475ef5a52ae48b8c3472b6e99350bb2ce7e18e045d3758eae032d0aaa1ca206de5c013a736167a15ed0db1b601a527c72fdb7acaf743a3a671076c9190f1aac238fec19ef3b1f0ca3883fb9037f87d54c86608fc9aef07ba9ec3d3beae20d29ae8f205f3fd50979a57ba2daa848d20713cb196690c5edc6faa47cd599592cd2c8dc43486bdd11efe000705a39e4fd58c801368838c185a3f10f9f035d0282a4a29f997fc93f4e430c10bc57563567972cfe6f3832a7fcb9d354290494a63239b87a9316aa511590da7eda4aaa706ccad229cdb1bfca51a77e1f4e2f308b66cf0900e80ee92e80c25bbfbfffa3eb5547aa0bf4d1db974b7f696ec893c334d468679765b9c34bb90a79e7f9812e08434c1d11a1998669c28f71004f8cdc2c1c31786e132cb6ceb08180f14d1ec57b725a924f7de72dbe9fc3095611f6ce637f2ba6d3c1a276b749a2e95be5fa3b2cd2dbe1a51b16cb867c405c09d8eb600cdc9738cc77d13b4f7f0be553618040e0e971a4f6baa79de2cb7b78ddfee0bae0917a35a5eb12549351b946c89851509b065a37ff39609372a6e2e2bf79440000ca8f9e3e1a77a82b99a20069265bdb40f15781e8b13a4cbcfb5e30c5e6cfacaa38705c73b8ffada7357bd074c89ca727405bc2cec6c194dcb0295e8e769d9c06e1fbd69be4065adef49407c9516283f09a97d7f5d247c08c0877811fdf6f629fee7e4e5433f74cb12d4f44bd58626822fdb51e511d5765baa755b141a2ecf32921b59620bae226b5a5803ce334613653f595c8fe782b68bf3aaf040cf9810d9b87c4ba510f5f4f3cf0eacf28f66751e3233be0125ae91962a76bfbb444a09dad1aa794752b530852d5ceb4191ccb746d0b20b818f93cd7ba00566cf0aded7b499505a865e422f3785550ffd0fe75279de0021c0bde4668497b4ed6b09d86f5c8d634bcf42425f5f5ba55991af70dffc1a7830dc19bd30aa5cabd6d3c5f6b5d0f49216fa13a89ea9a3d944ea6c782afa09e2d46b8de6586982453509ca9fe3f93d5878f08b0c147098a9f5376a2857f61af6d857848eb8f986b45994b717b33c121f105b3f46023a0e079b3fe00ad2ce635f0fb4c08103b450f66d00686ace25675a1a18d896a41dacea576888e691565fd4e79c45c93244976a5026e22b3e9bf77e0c41ffc91c0680b20c22b1c69c2ce9be82a8efae02dfb51188ca668b2cc91ee839f1bd31a0b209249785d697783c9b7a0f38b2b1623adf7b2eb556ad3bcc7f95ac24ed304c5e8bdc58bbb53715687c368aba94c7711f0ba4f3f71fa8fbd9895109d6172163e9cd400308489f45c807833210e40b12540dfddf94892a7603822093c45192c5f4204e763e3c47fb961f47f6b28985b61c81214039a8d7bf98a2ff01d1bb2e72c89fdbaa972b6e7ee8ef559d28332ae9d070771f2908d863c32e8071a5712e720db34e13ccf930151b0c5d70ce4960b8896f6b70df0675027ef70cf08ea549d8b31329c8d0cdf2eac1c60952b7e93268dc0a25f85dfc92ca38f848d5b3ba9866080f41ab1f0ff03cbb58a0364273b0225d6cf818ee651ef70e53bcd17517ea9abf24d0b4eb170af692b5cc73a950c65b082dc856854426284828a718fdf673953e9180df944434f880f91d6c47c31862ff625b8fd440961b5fcf72116170a6a12f9404066243184efe60f73e7de0b3196401c6554eaf26639b3142cb2110ad79dc0cb337dbe65e26c7ee9953662c796aac146f31001e437ec8c82cf616d9deac0972df8e2ead276eff87f6e4743c30864518a951061e72244d4155673f09d81c4139f8dd22388ea8d428a41133a653d6cb67338ce86874d00c1bbe7dc4dff20186e172c5f9161434fa4cade94cd74a54c2d7d043ecf11d9e66e3c567b4ec8972e623504ea60bd908ca2f5d82db4521b0c9ff4bccde57d00c70ef9dc6382c23199179b35a1fbb821149a9c0f95e64cf4dfba9deb5e8ade819f66db12143fde609a829be1b42066b98980bcd937dc6a4d71ebbd316a1356b0b290384c38c115e5152818a46725908eee6efd57e3a879130457a590a1ea0ed323501330c92f5bc7f5099885c64a55206a14ffe3a1f0f2ea5dcf0a08b45ccc3b7e145de9014b1171bcc479e865d1ae0cba559d1ebb195fe7b0754e197adfb3755385c802c5d75c951ee66d3e8737a18f4ff7e3011d021d144ed19e39f12a97ec5c83d79277ae78d96b115e2e6a412c8aa523315f4a970b9908a5a652922239c107e98eebcb544bca65a069cf3f902717f8fbe93173ab4fbb703d75c4477ec0fb533982ba745625fd63fe02a79165c34bf04d2765fddcd41d278b0e627eb97c549fc8b1850d125035ed1ceff2514413e8b41c15f7e4450246148944c92891e7551138ac9a5b003043762a502d43e7beb517dac6e501a4ba1c7a1cdec41f46ccd7e970380cb86ddfb9948df5c8d2bbc8117d79edc3b6b8ea82e7b4805e507f0345140ae15c4ed73ec2619d2282b55417ad7a8cf7fd3a315298f2343d1e9a1e128217a1320efdeffdf67de81d260c6d6802b92040c8f3acadc198f5915bdd63fb91d2cec52b449b1a2cde138b9f8c44175f28ec72628d5f96a96f354f9f2057df3e9c8f44de5edff1108fdf879fce091cc3d4d228373bd75a713b0d6daadfcbb39024d29aacc6de5a2b4bbb110c5708d8cf69d656289646a55ead7f9eff3f9f41334ec6a654a794f052bf03e97184ea8d8db7aeb8a18966bb1350990455da87a0683e43e7796985673433d72607303985cb08adeeb7ca950c122ee2480ea01675d0eda3a1e004fe00ed62ffbaf96a1194a0fcb91859888fddb7a0307493c774f805b93fdfaf216c1520250624ac3f0da4397aa852bf874632e5dc87a2373b52a13efa3ee513ff8556f76f2635a935bb5f93b95a191db15f38c8a109d50852ba8e92f68a8b84219cbc4bd82d524712587a6c5317eb321cbd8e470fa987df7d9e527de344251169dc1820ba153f3ef57a3f6b38115593d2237b75a8873891eea9cf88bd244900cd3281cbd3af6ebfe2f47ea5739c042f84391251f24b0cb6f05d50d94bbe8945fb0407eed0b6630f009455e4b28f9082ddfa628ebec5c2849ff3a6b3336a53bc2a6c24fd381d5bcf85bfdcad1fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
