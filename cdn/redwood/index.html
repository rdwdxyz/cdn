<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2694fde8afa13f9a243feef0d42383ce43f395841a9f2ba4ab3d7860624fadcb3717aa889edf476e07cf6f3cfb1a71937709f09dab3482545740c8694a490e398a95f5ca611e9705980e049b204dee985d31e16918bee6fbbb8a840b04fb48c16e990fd7b982f0e03b07812b6ca422e36dccf01b21c0e1e52455034e5e950e5d789bd21a848ba6a62940552c1610041fbfb45b9c3497652550ba9a3d15b1bf858f9329e4e16085e36d661eabd3352b25af7117ed0693933329f398219794e3c974acda68303e02715bc8f2bd4c6b1261a9df71ae7d820c3c8c6afa983ad19253e499304e93e55e0d68ccb1eef44921ab4380909d4f9ec47597839c983cbf68343d5429e82914f81d518a9a95e69f7c3583be0e319a1a963315337f625939876760d777c54ae64a2832ff515eda6f364578cb6a716350bddcd166fa88d75836a32250fd3b58ae31cf13e00bc35ca0c488a3df46fe094471b36f7f26604d941d32a75b335405f4b996f0de4e87cf9df023c86056ce6fff1dce65b1934233719a22578895dcb138c3dfde9e54db3471fbaee76c73beded972990c30a3ca6b5361dcc175f678192a194c54b0f0e0d377b2f035ed4817224904370d780e87741433c4f26e1b299ffb75fc320867e681996fa0fb8505d9d219776cdfab0a8704d18a8096b5643cac20be8acbb1a6b400ee35529f3af54be938f35da630e4b0a9375c3a6f2c65897e3469b801adf02a427abcb1d7f026c18a1d061b7aeb59ec642fe9458b5fed683ba84ee41b393f41df9ce4c0e380b949ba678523458c5d96fb355f6be996768adf20a1436cc4016b755094c53188c144266479871b88c474da6a3d1617f4c10ba30323e60b60e6250ab939d3c6431abcde743e858cbf4348537c34aac75ba609b785dc5872fc0a90324b53837e41d90d8b894b28ea7ff5b4665649f5a857352a42dce6507e514d8c5ec5ed5e80de2e3ba345c290b9aaac6e201b142924ba054685db8cce8b0529dfa153f7ba8d1036fbd62bd150b23a430ffc2cf9d59dbfdc947482d08a1d51343ddd3d67156bbc8405affcf77ef56d25a3c4ef03c9d727b59384715d13b18287f3b4c22d9d9c2bd0f2ed7bd9c274a2c72b538f1fdb4bd8ebde29238299ba0232796c94f4cc8d11ecdf337a79719987e38a5fc20b2b757f65c4b326f33af8a3dca34ee00eef11a4d891a238a55c67e220eb1b35b73bbc238aa0458a4e6c535fde66437b87b7add7de2cd63a3d354694741dfbd1c1de11af9dc82d21420ac99a9d2c12c40d90504e56ac19c2001309803de5e8f8d5f174d826034c9192b55edd159e577eb0a66874a4cc7fc4cede07e7a300b6c49861efd5ecc4db468559becaef5ac1129860e202ba7f9d33ade7684030b316af153180250e4ba807aec00c1a07ccbfa3944b7be91403d736b681f7f9897d67fe36240fe76886ad98cd298e51b82ba9b3153553e35ee3d7f7ca0c40c0b4ae50dfdee1e61f92ecc3d0709ad2637f82956af8308440b2380574d39ae4f80494814582e0707b6fc435e6f823c93d3a66804c6c28ec358507fb70d779f83497a857c6ddabb2d8c60eb98e4526f952f92349ff67c91a44d6a31140db227cc7ae25f1ddb51f574e18a5df78264ab5b79d882595ea61c1e2265de17e7fd0d1529234654f6a97a664bc1a24d62386523efd278a7dbfb3bafbc55ae167fcc8708c6a13e31268c766c69409ce52cec21c799171e57e495e0953f725591d235cba5bf6426692fe2a2a7829d1dc746b4c872ecda03e128434aed3fe3a62af156a500f7663154cb2bf5ed18905309916ee709ce1419576d4ddd42255cc2988bb6a42de84869f1fc1b053ca219b50c5b50e59fdb911eb565eb436f47b9d7c730d920c6e0ef2160fc852fa829e1f4753c8f8c8ca752972c25ba3fbf313ed557610acb3941eb4be8b2a4d249d5c7da3e4db0784014d981053368aa8bab3448363fea0fc9c7f701b5dc9ed35a647cafe231c86e8564e257805ad3163aa6dd35ddf149d3e9f545f6ac374b50579dc41d2c9ff1a3bf6db030c69b2d158b75dc979b1c5fd4d05a0f20977a01ef3a68b14f5f3e2fa4b09a7d3e7df5d881fa6aa68b71de13537de0f76dee9632f87363c8cb575252c44461da096515a1b423b7870ac0e185377421d874b60c091cffa43745fafe3c4c7aa1750cc98b837ad7de39c7dd05a49b636eb77896d6dd7931a92ba92cacdec2f4d520ba9342cc9a53da533d62a50669e409198e9a645ded0ea73e3106e54ec7f8e4ec0ac0ff7743e4b3994deef7ea5c4e4eafb8750c7b81bee116b3cc62ebf829a41e8e64ce7ec8e7a81a395753951dd8ebe209238de10561afc797be90e2a837d396e3901fcb940711ef1947c4ec2ba54b3536decfe1eb4a2cef536ada24c94e043fbc8742ca997f721e9e50805c4a2424a5fde79f811a77fecab6d4ffe57339b2d1497d21769a8e28744169cda82e190666a1e48964e5e29b2e592dd2594d032b811e563c41f89157a66587a89c52c35c81e3941fb9ce608fa616a6689ec9b626fcaafdb0ae322611b4850224d5ef89e3caeebf64b447e94ddce2e8d1276c4d295184d6ed5c128ec304e0588bf4d83b3972aa249c9f96f23cdc56eb89b69319345e23ad94011619752ae53cfc9a2512e2086376487593a6c829266fccef8347e2c96721bfa58b213401d3139d22b6a8ae9e864033b759afeebf63c3256f6987df777ded8f182db9a2f3d99aa623d562cd3da3df832a6aecf11be13f9a78f7a341e821673e58a9b280f58fc520beeb5209f2eceda3ff5be3065683daaa501f7a357b63f14baa3a86c94895786a70b49e083d77028e564bb33ffac6f4af6f0fbd576bc8d6f4e1d4c0411f24707290b3eb60809ade74ef0ecc033ee96ad3032c02ea56542cf96eb664b9efcbf9b3537eb9bed59fb90ccf5b2eb7b73964aef3312c84addab51b78d4e552d4b82deeaef9c2cecfdf64cc26ed36b10b73b6b3e8090c98ef5e47bb0b3478e3cde2cf4a629e6dda5af5490dc3c89b75cca6ba622fae3856f82c6b6cd0e5a6b4dacd5dccc96445659d401aaddea72460d3756854365d2d2bfe4b773e9d7ee81b858c381c6096e88923fb6feeed601491a459e218828d5af2474cebd540c51a551e593200f5a499e0f3ccaba3a8b9586f56f50fa7a821275d699e314c5d01658fe4ee87abfa596d296178763b972653f10acdd6540c6be306e9326f92b40155032d2a299e0d6c9d8230abb895e0a908524baec1a50d9db62d6635c76c1faba06eee9db37d3a73c4dcae1059f2ffbcf6e74374aef15abb4f835cddc9aeaec493f8ec851ae652d2107906458520518201e55c6203b6beea47bb205992b037570eba18b29515537ad61e293cca2f528969bb949df22fbf66c28709e71327e5261af9511a9bb70e71edda7d736babef79ac6af1a2a369872ee95c7bbbc88830d152a494e58ca4adc0dd31a96d41664d910adc4c089f37ed3f6ee9aae9dcfed79a4df5757cb9dc89034f68826bdfd5c17bfa3c5c86fed782186446a0d7bd7b473596617be20838cd73a383a49699287046e39c7ecabdc42db7dd79b2df49f43b51202450b24ff778711f7fa2d09deaa2039a0c6dfdbb060bdf289cb0e40975046ac4545dac894f29857a428ea4bfc79a8b6ae6d831d5a52d30af5556f2467f12c79555397183850928271c6bce447fa99c2e187fabc357504109c23e5888cdf3c674f8b7c422e1d77c9d81487e12baf18281f5cd004a7b722220078466e97568032ed9b16cd782109dad05ccff32831d79019272a89cc48a43b0e25da6aca27d636ade94b38bc8110768d4d0ab6ac4d93d3634fd793d2a01b20802600ffd20a861e98ffed430dee712869e2a87171c0acb4078941e8702274017c0df7131f55fc303a185567e207a824345bebb080325b77967f6b8a7d72b1e1dc230b6924a13198dad2e3be9c39ce9a1825e73dc19b58594de9ee4ccca15c6f5859989f2bd17908c04d6ff975bc93dc7df2695c6287ef0ca41be2c74d9bb93d67bb1ba3da92ed3fbb05ab0056a8ba73aab9ae3d27b2a35e5f91821a1e7b1499d3d41bc734d89052886e0670df70752b9d1fbfe3a84ed61592b0dc8497c5705aa957d27a3f6c95813e4d949a3fc97902e80f98d379a14337bfa89bfcfca64a7bf9b39bc4b11306f9f95252e571bdf247ff1afcecf0a18f047b372df4fd44816d642e9804687195436037325b9ae0797eb8f3675c0d208895999ad83b0edbe80906c62139093e11dcb050a67188ddf42f6cfb71e7448951d0410ce70a8ebfe8532bc503fa3b28574f57481a015dd2744b6aac4ab976ff6fc77b1b27eb6767f50a3c8b8afe5c49f59a4dd6e17af0a7ffa3f07d12e705ba4ba7b1b01005386eb73e403fdf2af43062621889cbe93eedf7b753972bad61b29e50802096eea52474cb93cd69fc9c567bb0f9b2c80cdac300ea3f82e5fe2ad88d22c2963b446b124db38ac0ba4384c83a615ef8b3417585a94330fe7ead5fb2213c753e8c11e9f5c60e8f2d03282f528c2a2741100036b5e6471b8f1ae26c7b1a6563e0dd526e634838a6e042f87227f7a5b209da7e0f03903cbb8ca3028474004ad1f869fb709c724cc2ea95b1086ee03f0c3b14ed3cbbb678a90a295ec0bc28c341ec63014f3448824c7ef41eed3649338d2f832dc395127f0e73f4cfa4ea4ea108e753201e97e1a9a541115511eacc1f299dd23e13e4540ef502e01f95c9c204015db8e80d36ff83b0fabdd2a1e1cb625a03a4234642c5c63192c3da710efa7e006608113f5d950554cecf5111667bcbfd04de55f09a4d1d2014d64f37d1239a81920c2cfee64d9c6bc037b71ce866b4c8c3156d993f0af5c5b8f04fd210ae19feb60e638c148c643da91287ba4e007979921af744a9072ae9a49e1f46b76350ef0d04cb11ff2bd554d51896ee62413c355ca9277911f20d257278e0c7f8a9f06a1a5cb1f570318c28cb42c1d05ff09859fc5ab8ea4770f541772bf7f00d527b9aae0d126596933828bd5cffc491d0fc7f7a61c00274005a021aec200316d29efa85731fb6573c6de4b0a269517067deb09c5c4b7549f59cad1a51b89336dbf0c428a8907f6ea8952aff2ec25a398db28f5fefdc65c86a260661743d93fefc4cad4503b7a4c490633dc1606b4561fa629c491937ef578bfbbf593a3ac1bd58f1be06c8c9ed7ad4686b1f705580baa77024aeb7e232034ff405a37620a723ea35815717a75cb518209d74da29f8843c1b3141f775d6afadaf97e4ff3b95dcb59e4a5faabcfc98754e13f9400b631314140d6c079da38cc0aeb9caccb47f01cc4122735b4fd9f325ea6b80adcfb257a550ef75224580bc39d6057c8c835778da113a5386766f3988ea264060251b98fef7aaaee6f75fee6c08dc6bb2c6c043b10e0058ef912a408bc0943197cb991d649f20f072c5edb56e3713425de3e9f433eb084390803de5f38ee9b4fc51e4e34cc971e82697c77b27267453b42db87dba640fc73f4d64fcf5884c8345d64cae571170b7dbf93d03a2937dd039b1c536c9cafe93d95b313dcbcc7fd179b660852a754eeb59ee84d90cdd555e5c6b638e3968b719a94e2e148b7441d650496365e63c2837c1c84467c9e092fbac48457c21a10021ecaab154d0ac01b29f3867e7117c76cd807557e16b50614865fa23c4403aeb4abcccee79d9d0c53b79d0d3f1bc64c8e31907db332a6c809b8d61ec0e62701de511bc0edaabb5ad55ad377f0927f3011b00144ddfa3ae33ef6cd176c06700dd9eaa3c077022a814dcc614513f8d7fc5bc97d61b50f15d14cd77665a9691826257cc52a996b1dd02da64d754b664cf4ea63bbb38c94af2c67d0975ee76ff641e5fb174f620b94f304797d79534c9d829392d66bb78e4b630838505951a391f6ead83b081645afea1344be45beca60a9f05f37eb69a360dcae0a3a5ba3f553d18bff111f286b8cb1943d1f1b8ac0d18cb4c0fc4fae44b980c78c95b88991c78fc08142f6c0a12651e86379edee3e4dbce018c7ad08344941e85fd4c11d324d36d43ec5050ded1c081750ab14a4e1f10a6d928bd7120870ca824c934e18c8a0687592a2e1c26b2ed0b9f164997e7a1bdffb668eb9faca7a7b0218263b43e3b58bebecc897ea8ac38104afe54ac40ccddd58e07f7f57b1fab177645ed3b58ae4a83221962b56a0b77caf62f4b5cbb898a4a3e00a00e3dfcd75607b51609d107acf35f98df871bdedab9298e4b217ff15e81c8e6b3b1ecb6bbc66b38684c3fa7ce9b2c831e5f27716a2bf0be4dc1d14c65cd0e3c176971358763e5f3b63f17b52f9db7b583c9a5af5766386d6d194faab035ecbfb281d7f899cb0b03e721fb6dc56fd6af889cf6310a86545ea38d6627f6b8cc79d22d03c8c7f2b6ab07286ae4c4d0abf1528d9cfa3afcb9e02631342fbb5ac092995c58ee396872ae6ad8c61a6d2d14023b0a326645fb86d94639edef9883233fe7afa27caf5a45bc5ab21a24d894f68fc0c41df1e23c0e286b7f441ca8e6db540b0a7111b51df1775c729b594dfa06927499c6f9c5f4cce3bfc74ee625429433299e13fc19ec78100f697b7c70e6d13f13451638878f538f80eed8634d9e6645d121bf75d56a20535ce240ec2572d568cacd321871e641b3cb8061af9e18bafccfb90fe14232baa2664f4cba44541905d6723922f928f79c9721204fc3b5a71d6c6d8d2a4f8505507593976909420e71597204de992219e72d5d1c267afc7dd6a1c886dc854924ffa488aba030dee79444da058d49d24f2e20554ad4abe9b383fae11f57d6a883625750224a1f7eb0589cc458d4cffec5fe1a1f584c0b40fdf091ff1ebd07e03e88e4b63b008eafb9a5cf7a27c0a4591c8e378fa9e548feefc3707198c4e09ad42ba13f2ac368730f6bb1ce5c06464e744484e54f847b68d7383647d1898f4100bcba67215a365ce4ce6d44af9a9fdd5bf18fe4033dda5ed8ddbb3909d164eb10cc17718babc16c7ae73b44b55966288d31103bf9873ad88ac0b20c8f1683bb944cfe98aed9e1f827501546deed4bb6a53cb609ba75b1a05b27a64074268c88478b1419fd452f93d1159ee3c74dca5ee783237fed8773161d4f30cd409fb06c86b648ee6942dd27f5749bec78f308dd95b829fc2c923c37e51effaf75bd27c44e57cec75907dbff9c1fae3b39aaf2929b72413bfffdb420bf8be14df4f459aa78b6df74184f3fdabf1b1034f3ae2fd186c1e6c5326f6793bc416af904110e8db8b6737e52ab9f63283886e7ab2bff14bfd85dabd5f6b53b2bbd5d7b8dd40f4f20e264f77015d7d7016e8a41b3d9d5a622831e48ca217cc806a304d8dbfefb5d5fceff015732757e0f7cf5db8128ef58c8e1d0db27b2785b3e8b264273e6c90be37fb2e3211c39215b4b2a2c1d0dbc3f0529b74e99de307ddc9190acc6462bcc88f232846e271bbdbae48c6315e58cf10fd5269ad9aa15906688d409d5edd8ced08faea0e660bb61e8f1d3f8d30d4b3b271c50e356b16f1ca1b61afc13e9800d1b7b6f762c7fce3385b849eefb480936b18bb998632e7817dc5933694ebbc93079245e36412dab28e42732602cf3f34919a4af7c67b8b7abc72f2dbd4f827d51cd73f13c6eac218a7274c1a61c6ac7013e3fc26f82a1f2c865b2b21181ada35e484de6c39cbe0c2736abbac1ee8eea19957698ab63caf4cbb441e59af7a3db3da3f3d32e339382e3c7926de9a62bacfb6b93732ba8776e5641d603684923592c42083c945b6e3e2e5a76bd1987534fd58e84b3f77bbc514ee2fe372b3d54bdd3834ec1b7ffd7f257764661b6f8323a292fb9149acb01a61d9a71c79f78da108ba58ee11b206751dbfa367e7676d8902b4af41bce41fcece412a6f5d4ad1f0639e2b0351e0c98cec9c5d3714653acf21a732d77ba75b39a7c075d290f2f2b1bf61f5d77801c7d8bfb605fefbad86e8b2ad7b2546c2b93b1ca90825fd1944be16f33786c422acd82c55baf02b64ea9600d65fd1ea516077f2834f96fb633ef66657c35a2ecdab0b1e830b5f2f46b88181e0f81fc5cebad24f42b95f7bc62326ee7a18c18b865d6e94f000f91235d96b72e613b6ecb15778df7c6d49638790bec7f2f7c96960933150ca72af7ed76951a61328a0b1d719ff1072a4223569acf17ef8ff3cadf41538076522318989ce55abe4aecabe9864d545ab030014f67d5f6e442c89ea058d52c126e61f258470709f141fea4dd332136bedef6cc809ebe4b25b2466c563b6309348c185480e3dbeda331b1273fade77326aad8464307022759ff98e8e3053b0c3c98a4f0bb49cc41ba74c2fe45fe1f893e5f350baaa2c7655eb7ef344598a0ac97c7e0fcf541a6fcbcd6c39d579e77fdf11dcb8b4ebd687120732f9bec3e9d71b28cbcbe5bffcab5c5a6d61ca8cd0aec044eed7c43b5a48a8ef6fea29281826e97c5b42e0aa4ca7392d02d702e6213ec2aba4170c8581926b4eadd302276c33b3cc441c34051cc4663f714141551744b7273d16f9370eabe22c24267df4793bd2a9ffc5066aa6c7249cdfbf26de957652305b61337c6eef36b1ed46e5d54c0a99cde951bbd6b2da66e22315947e197caca159920fdcd963e5ea0ea5b7e91e3d3948b13053e39cdb27ac0bdd6120c175c36ebd6eca0d60b8ab3fe6db9a98602dac207c3d4413cef628369eac5611f4c1aa5413f3f394bcf39839b81ea8a4e1853699b4eb6f0b5cef8a496abe123035769ebe8cd35b9028b341a8691c7f6490c5c7efc89cb23c4dcbf1febf334a60adb4cc152b161ca2ef4035a1b9e3003dcd77a8c2b554fa2b8a4fff01cf2693410ae0a6830f53c5bfb71f7081ea41cd652488e4b677f7484240b546373df3e7fe7688895ff17740b2139786f6e7d60f2165ca104f578af8f9497dbaaa4860b597e57530956519bbd4a5085c090f46746120bfbdbe5ca0d96ea1074d568d6c8200d8a48a19dc1cecc48bace2906aea5859b02a5fd6c812ac3825964671d0ff4d97d3a8f7cde65434eb82004bdcfea220989f32ed686499673c6f41dc42110a528d8a2d73b6dae4dce7441fff21117d55b85c0df31101863ad385ae149bd9c479fc4434f0605163caac6af7522034cdcc12c85f07b8de20d15527a1b3bbda50cf933ce95e3da567c67a14bbba836f89f66f213d95ae8be84667e9fe97ce271b8fc2a9787febbe7a5529e852a1b3d9c69851dcae7a197130ce463705e07618a5eb016f4498b1851b841504391e9c095fb0ca346465e763380a9cb6937b584aba62e8efea66cc025d78bae72916872c96df0685722dacf720bc8da7039f680f4775a5f909b974e4ae35b21c916b8ccfebe8b7a0f586ed8c79a629d4aa93f6d3bdb4728a4d52f29eb7935e68a5a33e7bb07c9d08ed4c61b05ccb31658bde8f62ae50b1317e08116131c809cd6309e892e364100496e7e2ba634af95a0e5573a2707ad008db5fb38268c2962f71a9b81aa6e815e29b024a1cb9e83b26aa2ca46d80d866f6532194eab18e41fb31af4a9107105b901d4ae13aada89f1bddf814c014b3c47920c31ab7776477a59269fe397bfdd9d63cebbb5dc44ba8304432ab31c5bd5fc80995586840c0461c529595317ad01297eb98e452df004fab7cf625de1f4eded195671134f7255a20531cbf6a582b1a97499efc3083a64ba022f95414e3cd25df85717c2aa509240d415d40f3f392b016b7829ec1b78da03d329b62379cb8a14860543b214213181cbca0dfdaf1a62e51f8549d980ee3a9564e2168ced64bcb9ddf0ccdcb6a8dcf1d309bd6555d93291e5eb1207ad93092516ff061376bd171d065ed5684074650f1679c22a06ad94100c0bfe1c90c27620e10a316b8231aef2f3f7d076c7ac2dc6c9e7c53881a63b639ae596bc41b837caadb9c3fd821b415182d4de3634d4ee92c2eb2717d8fad37d170d5dc2c6a40ba6b92b1b13f35ff10acfa5bca5133b6819e179f7356fdb353c463cb2b30d469b16f406a0e1fe0cf2261c60f9506e876b07784a019aaeb89a7e33835f5a0f8e368eb3d00152df033a6cfa29ec531424a99383048564d10b802b3fc66982c0836cfa130ff55f366aabbeb294bb3d5f4dd3e0fb1180adb60c5753ccbe80a4e2f61ded98285aeceda0a0c7a296d7a32f461bb4776de88b9377c77d428ac7a85a2322190ed370a375e6bb5fe4ed049fb58330b161bee624dcbf77f129b4ef03ca968a3a7a4ab4633db9d4191971059c762bc821bef4948179b868c527099bec8908012d27762827ce4db1e4bf743e7620d4820e8f31cccfb65edfc2b469a1505466278eb285cc6de1c3b6d75371f1517f27b3c9c16d4c8e1319121704b6561c17f7519e7da2365df77a1a60b3218b0c6eebfe5e0ce6fd6ebb91913d7ccb1d471e80a0d3680a0f29479a063da577687a8b73e7356fd6b70dce2d9fade18ad3db79cb50d7d02e1078e15892bf743446af9f93d4ffcc0b7afd89d1c00c518af6d39509767dd17afe7adeee29dcefdb61af436e897c3e1ca6868aa0ac79bf1f16f4ff0c5a23cf375d0b80d0bfa55800671f9cdb7607fbe916afa8aea687b72b354456b71228e0e5ecc26a437a1512d6c8fdbc5613a5ea9a93c8f5a84b67365fd9e7b2dc6f3ba4059b400ddba3e6da9fb961900dcd90c51cfe2b4bd0567cff539ccf9f7a31077cbe110850d88274d21ff005bc4fa256d8cfa42ffb68fa7e95c3e4956c52f64682abbdad04e5c4f653a1c199dc1420f5b1a102a01902b7326f64048426dd3eedafed595ce76cc9d53b098ea6282210dfb44b700828dfd164961442ce93d76a35b64ec5f6ffcd094836ceb337285594be7ec8dc40c0114c4bde37c64e92b6efcee635f4bf306ed4295a335b86c39a12c63cce1c7111ffce33f4dc056ad05addbb4c9d40c334976374305d75ea0416aca602654e49fc47d20c4ea83e21ac3523cd1eb6ff029614aff7942c941118c759c041ba12c4574f3ec052b8bc7f12dc07d52adf6af6531df49cf7f1b25636e07d3414b83eea488188a08ab40578243ab2303b6e9fb5d03ee4b680c1822a5a0ee867f210809667ae6146db736077a02455f90b1f6cffa8f892a5461da5f2957c05ba26b133994c57c2b59b95e7aab15f8b370777c5f45385f00f5b3f26bb915d22fd9cca37d749176f12ebfb9794863759ca57126e59a6f479f2dba94dfb438776aaf53a3b1b8a6220693db21742414db56b0df5d242900ddbbf6f6eb636d927cd004a31f558bb8357e6f562d964b8f6c6d07ca5e11e5cb6ed904f0228e83ed657b516b218d6192d869737299ac930db5aaecb7d84f46699cd7c9b1fc095c1fabf058f1166ce44e01819a5f91949a7a8b52f176ecf8cd357659e82bc7bfb77399a8c03831665b602521c225e9ab0a0b7e4a8b21d069a727d67deca9121ad4d5c774ebb24db7e2fab7ea1added6e3700b9cf0bdbfc6a208d87000a7c2c2759d83421a18b8d38f699b80d3fb6bb78d64851747f11d7cf71c90e5845840040c6f7b83ad5d69ef7b3aec61c9be7d453ce14edb7b2d677a5a78a3873050138ce5366e5d83a52795190e607807b08cb1526dbf16cc7ffb65d345d80f81f72deebad7240bfbfd4899c45f5f84ff062bcf1f4c7baf20afdd9ff8a1a46397f44dedd6dd6276cc2a98ac4fb2f3996969338509e11654874f3a22fbba717a02465f4145ec5f4ea23ea1d3f2b37da3b6bcf8cc554342d8e9824bf60e7a1b3bed0b4ffd1c9a49a63feccee4482912c485d1e6a01e8b3b185965602cc0e6895710e29d9a89d2462c9f99f3609c54f5e81bf215965cb85ec2cf560269a9cd031f7f8f0c6e48bdb0ea5b5786506cb68547d005f4c10513c1af547af0d76cc169a51b253ed7ea9d52c09d6ce0fae47deeb260d982ff479a9432abb572665e36ec17852a33c8f3e39ba5f6a7cbf3574d6afa624dcd9482804ce5624e0ffc2deb99efab85be21f58bea4dde89411f76e97ca74ee4a1e7a98f894b2f5c59c7ae48acbd77a139b03ff9eed1109d2fa60cee71a9f1ad84a15c947b22b373d9e564f65ccc88f578730cf5c65da17ded205ec28a0391bf4203075b06f45311e6e5e917636f859feee4486b741b104c847b68a94d61590da176cd5696db73810800cf70caf9cfa4cb3dc56fec6f7e59a8f218ce7192a1436fb04f1dc122ff90e8ab5832499d7fd242caeee0ff4b073f19b548cd3b65ab1b411c963254e98b51975de8e563132aacd982d87699507a2d46657fd524d0627bb54861ec97cb2552b3b039957cd69130a97bd359f444155ced2d579d836faf2ee81dd5809265f09b1e60414b51d9fc04813b79d0aef92eb01c4c86cd146c3a63fe0ecb2b7981d8d8fad90b634b560d9f2c109ebaf00326511eb3ab791d76c53a48bfa7099e6c17f793c248cc4fd27af8101e3f60879f72760ba0c0bec693c0cc1b1095b6b1fd1c2a2912335d461c98ffb7ef5a25f59657d9070584b08dba373afeceea8cbc303768886377e26a3faeb0a6514c8d49c5d704475d66afee13057092c8bffe6720fe95c7ae0b5aafcec2741e77e0a6fd1e6eba5ec679a0a42201e04bfe283c7012d4a27a0cee1db935e73e7de4ed99d24425733b58511bb789a04f806652f6c00fbf36b38965d573cd4db5d97a0270c45d13f3ede875015568a4108100640b690a21bb300d26f38548b6864b911dd75ae6f255c0a728c96a04f9c35dd19947ec924b1ef8c71fa62b1e4dec1625673df18280c6b0eb9d478dd993fa422a7a47f9ba6b09e524f949cc88ec936b8d7028a8e6b4f5b914048d8e294370032ebb2fa182455cba4fec09f320d04b67c8db6efb6610711c6cc2941de9a43b39732f85f76cbd187183260621ee8b45a5d170336c754583f20962b29f459c48ab469eb32f0297a09ada106aee68cbac524ddfd40dec7256e45e91e324e93c476cbdb7bf5bcf0952bbd11fda959c5384ee02f22852645273f92df868ea2e058297841514c97335df0111093db325c5dc1648ec323cc5f942b9b8b347711fee9b8fd4a6a8c12ab85df593c7eaac4c3128963e560839d380383716e23d49720b470632c11bfbb912138f65b478c6528b8b55822bbd38f0954c268fbda2f3e65079098004077d2aa3758bb95207126c7c2569569fae0a9ce9af6ca401da1f2579dd9b6a363c1b15bb1f9e2365cf9620ba2be94d90157357004468bdc4a64139d7e4b51d5a751357ceaa6be3ebf8926d28ed4f7de2563e664aec3a2d6a0a36928f4eeb1db25f34cf546b62f8d9c4e66c0218f518b06a0716e718dd71cee8e6950dac73ebcdf4029edce3cf8ebed8c26a81151a45cefc9518369205074b51a053ffa234911002b66938bb5d67f8c842f4b792c1dcdc373081e1c5c8e441ce6ce90ed2b4b511d46b5b5c9a0b6ea46caf09050ce6b233bea14a10866d9d2ee65d2b36b1aefdc81fdd4db04bc3a1c19c8a5bc938c79326be450f17a9b55c1e44a0c1601c01aa44a2ff2e75fd09d4d03d8eb318916998073e88dace6a96ca121234510735944d6ad8422319f90fae159fd48dfeaba920eb73f31d8c2bda1a68b7dda414dcbeaf5cf8a76f32c4a1c462bd42112465319f6bea0960dfe9f740f65d1bbfef39b386976cdf791e164a10822cc72e74c8f7b516661a4b2fe5561e9b3d8c318b1cf818f89e20bc04b15d7f1d8119060bf74bd749400303b4d0964c1e0ca34e904431312d2d2e6d0c030ee32bf21e393ad4fdd97f6cd505f96dc33a6931dd5bf6a2147443ad80c6be6fb53c2fe0f15ffca6732881612e5c997615666a9a6852ec4d5c070dd240dfc61545ed83930eca79470ed49bc65f3fbb85f3dc95ffb77d39263ea7593dcf66e44fbeb767a19cb5afb20595fbd0c18e7b85124d5c7103e72e79c169ee162e8e8de7d6572b55ecf2f2582cfc4e5c3af56e733520f035611c4984abb882ef19c7edfbcf352fa3a5b508e741128cc3b3548b9033cfb37bea803acb556365ee0d33de0cf22d2472d1ce178910510c5ff7a0ad46836301d3cea92c24f5584e24f9e388a5875d1a0bceb337c13da446389d86a1c703467b68c4f183d0ba1eebe3862d2e1323ada7d1d6deae4df69bec05227a4d06e10ce94f96fe43a1e211e404eeb99a0e43ce3f98ea53edfe41e57c09b6f29f1ca3a1aabc80c8dbffda27fa3cf8c0a117105a5fc09f12e3cf13d3c2ce8ff6109ef03e5b599936c2f69afd894a8c9fb54d6b7d17063eac75d0c0df0f21e29a472ad75d3217a9102571572deba5c8dfbfecd6bbe7b2aabe009558d48522098d3110b8cc6b96b197103aa7a4cb7ab072ed7fa767dbb92dcbe27c2048f7555850a1564c69eee6a8713875d8b2efb626e44ce4bd07ee9ed35db2e0772b5be8f70ecad05345136144f4f83becd12c786685344e03f8844b957f358a68efa199ae129e8b57d39f78307aeee270b8336a1cd0c215848fe769435e3c7246049b17ceb465083a0558a88db29eec4af75723ed19f73d0c1b2e08f164df75faa10e870b3016f0b484ea7937d71c6a36b70806125cfd2f99c3471068b84ca5170d4ea00688226bb0225d4f4efe26f15092aac9dda2ebe3f8997de6c51de93e7130a0b28f06d0ebe9db1fe7de1553532c2e7e2ac14c40e55ea1c39cc9c1e24534126ffd94520ff8accd48faf49e4c806fdc8c423df1c356dcbba121efe5201648eee89ad94b1b258a000398c6d786f6f7080035bb6db638b10df3856ca2830148d988fcf9de77d7e1ea1d1eaeebae31bda1122f73e681788d24d5b238835e4e51b92782a2bc4c347e1753189463c1d90be773ff327df0b722729ffd29c00d0541ddfe3f1347f25ff23ccddfb8fa80e09e71e349efe80e720ad0f6c75155edd96ebeb3e9e268aa061af39dc5e7314042a08ae418030b00543d4da459172e69685c8239cca250aa7f0430d2ccb476b11ed73492ec9b2fda7d1c4627c9b4bf156ca510426ae959d29a1566c36441de2b3e83b315098438b36ab05387e91464648ea562176ad50613a976eb32f82fbc262561153115a8b777604b272b63bf9d688c65aed72675b7c4326ea8468d71c4a0fe50f14660e3f59b64d8d67c9af28227a8f89638807856606d4b85c3c72d154a25e3dd6160c2e3a02eabd7fbe295c2a40a19539d42cb25a00fd4bcb80a787f36f2b5b790be5c15981c35fa56240389388d343137f0b3b1aeabc6bcec6c75148107ee44d92687cdc68e5dfc2d37e941a84d173978abf6eb265f0365c335fe3ab6b90bd0baa0d9049ef3da9518eb38ddfa5068ac2e05d06c7890f44f1e9a0feb568b9ad588a29164ee413d9bd294c4b0858bfa06dc7a263134974637dac6e32ad57fd2b05a187b13b036fa962c67bd33dd247f87ac5d7b5739120d4d99ce77636ffd562bfe169b655172591a6a76cce3daaf48ac2d2d26118f34dc26569ce322c01aff4f0075493a71b07e9a4284b896187aacc0e393e7c2838e28e085d3bbbe1ef50a686583c6820d4d928049bf44540feb7ad526909e2a8719e4f4215869db709f1aeeb03280c559035beb22acfa692892565a250974327ee266b0dc4a155f7bac55ebd768c8f48ae1ed4081f055c935ffb87e5c1fc1a0cb32a2fc931774ef92837b65ab32a1ec0659718d020a3930e6418c0c8dd811aba895fdb40d961b7310e8ee09451648de2fe766a123809af228ecb8595bda4947532d2f42662573b2afd86f6723443a8237a68fb9e0a48c837c3a279968485e8991c876e9cc00b80c65ca0da2432d7609eb7e02454abd1f2e13beff930fc1f321c5f6a270c29cbcee8b65fa8443831d2dd1b77ec30d20a5a7845d0d7c727c7543d3b00bba4b70c9e84cf2e0760e12c945acdaef5648615371963d4e987d668e906f13228ec8b4be08980a07464776f016f01557597e95be496e9d4a9350ada58708aa6e80a7019cd604973e6d2887cc4cdcf6eabafa6343558a3c627d3808367d0d27438191aeb41fbb366ba8e4b7d94ec8d28f4201ebda3dd1420c740c21978a715ce20e9c9607b02600dc0b22a2a472115e9fa79fc29e7c24bbaed84c456a1cb9976cfb3f165fdf3ec03506efc29478fe69fbba3d9fc33ba4d09a61608e85cddfd9eeb6618fcd60c95c47e6f28924eef35116e131cee4cc88717715100b6be1c017af15d9e8e14920d622e7848f3268e06882da305ede43cca3b2b872182f02bf9cd0a051755b86d0c3b349755c14e2f430321331816ae16929f270054a84c125bec460fd072909b42e48b434e93a280b3560c319ab9d323cd5306467678a26c975527716663b327963f23a9f2cc4289df0f0c1194e5fd21a724a73c2294cdfe78d44ee510aa3367da20f50eedb90f2bf84952943056103bce82ade35a2b26d72d60244c9cda67ecf8105632193fc9fb35a8a8c01a384e4a4bad53c50aa4a76989353b194d3e1f22cfd85eecc2b192531cc5ec751f44370c6b5af56879eacf60f78045d3e712459ba96e1771b63f896f0095b6234eb05dcbd3da13763835d56e967c75a0c312cde72f5f81fc189bf9af8715099b07a235eb1b204bc5cac7eed2d106bbba069d523df6f800ef49a40d0a34e14cfe2ae611048263fa163f0cd7ee034166758bb680551bf317064ca51c5748fa68cf79b478f0b4dfab10d925e67d621936d73f6798271ea8356d45489e42ed4dbae58bd611d3ad65be6240913564ab656ff0feb787c2671632bd5d2c0b49643ffe991d0d2d710e23061e8695caac8a81342f008186c48224228b31aef0666dad798c29c68dd04e820dd34f76947eb8d2a70e488f29948e18c2c7df72f1dba666818649a6dd4150a63302efff16037a8d032b1a793ba6c1c083e45faa9e9b56f4e03d6586a16b6b17c54da1b7f573031f192dd286cd8dca43ba9a600b45327901e3ec6dded6a6bbc7cb4bb194b6473f1ef18b26de6b9d91151600ffc1c34a31abdbfd0af798e3f8e1bce716fde60854bb29cef02876467b3f58d9770a6274c3a27288b334e8b4b8c39a2a324511a1dcb58a338f664ebf44ab7b228bd11dffaadf4fc18dadb993f078ca31f80e2a6f0f485124d80e7322218d1faa5fec61f007d6bcc84d2ebb5ad8e4e5d481c144c1609dd2249565378ea104e3e2dac595c65d3aaff7083a7f8800f331842ef6f7865af66ae40a37a7deb483465b1e3c117b32ec69f50ddd6ea863c3e2e6692c2890f6f4243168fe373fd94a0bc7b2fe8c0a79e02511eb5fbf499499f28488f81a2f7eb5bf874342428e5cd3688279a7f48ef4ec76357218581739ef165db83e44654a32f12e826abc63416daf052742da724ba2a5c1e92296ff629022aeb602c9775dcfc868c464160416d6074d0c7749a5c433f7f0ad78c492744f871197039f56bd16667ccd9898c67f68a9eaa579f973476ef7522d24af29a3a39f71926e6e9f3129d546ed7839977bbb82a471f8d6f76d093474e2fa4e5f51072495eb1a976f6a2eefd1629fcf4f52ebc227f0a2394aa98b89d463ead2c942ffbb52ca94cdb15223bb6c8401e736ac8ec75f672039279f4a6bf42103e51356e7e2600493358ba35e0b11922cf0b97bfcdb8bc215da8d0ec63f806cdc57b4c7c1079728194738a7a84fe89992695cf713f921a88382b31956636e860c551443dea225b2a1e9c550077c5e0543def1051380765cb779af12e79ea8a8309966b7405dfc5c222bd390e3751698399d65fdfcaa9dc67b838f43a0dadf278b079b70d57c19d5d96b449d473ef3f3ae3fa27e9d2e939021ddc882059475a8e51104f862b8c1dcf43740511fa6e86f9fad517d437cf9788a47d7836f1dc2df0d193b1e370009e24f24e626a15dcc3438f93c406b42ca14f1e3fdbdc415fa6e82ccb0d18487f01509c4e7d01f234b0e0365c6f8a2205e7043f6dd5d6be5a451bae47c1bb3266d27cbe0f21856f9aff8631e3d20d8eae7e6ec5c4c743b288f874e5cfd18f0fff64868923f0e5152096c630bc1680493999f2b553bce197608dbb25dd1d1f38c7a7a571bf65521e677d9caa3c14d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
