<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5fcb057ee512caab693c19cdbb553d2ad6e8506ba58e654a75a7ac9355152b1703f2dd01b3b6838e5c088e9509784eac375afea485ecd73d9e44002b56a073f39489f06510eab417d43d8854dbdc470dc2830516985da26e51ee17d1d549a7410ca14e5ad7c0fd6df580e285fd049f39f394f3fa819808953c431b6c34849069d7b615c7751d63a05b9b6776928a2057f655072f2cb6b435b8145194e363290d070a8934080ccd131f33d4f953dfa76d26996c3631a58363a25d092eddf3ba2015d017f6a072e804f21865199e392663f36b15194618ff0aef567ca55f8ea0ace52135722c9fc74f143d6576daa4437f83435d44da55a7a616ca7c1bf642a15ac221ab07247d9b62e4109d010eb43d57dbc2fa2a4c99a168c338d949bcb6c5d3265b466bfba87129da9b19e858e5fac511828079b1c5a4e40fbf4152ca295104d00b7afd865e2ac0d1a2ca706ebf97ccfa6e3c92448d7cd899fbf908761de938fda2b7dc881aa760ee45d2663cf0fa92ae5de7e7a4825669e9c594f4e35aa8f4b9c7388cb87840350109e0d13ee48d2aafb9a9f420887a2ffc755d7390bf90b8a14613773181f6540827fc80f9eae6d33bd6fb0c96b9d51f19ad916378295ca0868cdb01ca393c6be7ea52e1109f0c554bd0a23a469339dfcd334e3c794208090933722cb791e04394d15b5471682ec57e7ab283abf3faa364bcf16a734422eb787147aad8216f9eb97455c997af54fa660b94a205b915048296429bdc11227585e840e91ffefeba38ad0d8bca3eaf3f17387293c23427206bde42cdfa476bff3feae8f2ec27aaf165c157ccbc45c492ae4735cc1f768044c08a2530590f273ebb372577a0fd6d7859ea9a0546dabcfd619f4cc300ee69b6f33df577c7c58dcacde471cc451f034afed01640cda658aad90480f4d4b85097baaad9093a3c91046ec5cb5b3f97ce8b8eabc92eab855fca89b1690f2c3e66c74acecdd5c1cbebe81f8b059e5db29d1ba205955eeed1f3e538f1fb9ceadff9b94a63c8c8341d233318e4374d028399dfe59d956d6d983fed0dbbf558c4b7bb632a4db25e23b11e995b0b7de572cb9807927987e2cb25125a79470fb62776a8a6f3eccaac63c70cebfa098f272f01d2e761e912f723f8e7eb527654fb3eb6ec87c216480d990bb9824f529879a1027275a7255347d5d4225864868927b63f77067578c976d39dc1f31657f9f234cd38bc07e961637a95960c1f9e9332c8ec5a2a5051099ea3f5ac6c5c3a2d0b4839c6db44785cb6f6c4f7f23c3b07f249e341af1f668375f2e2b3b14e24952db63ad99cff3c7d17b6811c6358a2f621bf32e2a38f0d0c4d9fce63dcabc9d22cf5a2ccaacee3a84ab62a4f04579d976c4e9c1d56cf55cc53c06bb910767be63215667a1c0cc5335d92e786ce059c962fa1828031c57b76c4511d48a1367101acd04a79934e1d2d59cc1de9f8bded9f9a8ca95c62aeb99963f90a99180d724a8f375881d9e90c6a29cf3aef7c028da0434369cb289c50d6cd9aa2611012151cbda17ae8a2639d998eda7e8547c9dd1535a3a31190d3c1a04977988362be6681f9fe1efeb2fcd5f46dbf3ddff0a446904f1cf5cc5255e168a77eb88974e7ad67f10e475ca20afb5901fec301b9af76d53056620e83ba3a4efbc18f0eb8ed2d13637c710cd75e64082307217f1e3972713a96087fa3cb8ea88fb1c6402dd716e5975e80effc2f1ec3b26c696776b642450a323db236867a887d9f50a6167b74d54b87230d8d94e04ff7afb12f84c611ea6fcc898fbeeb74aec5cb61f017247e7c88ecfea8d162b9b16110d322835fb578cc89c9a92d2c2a158cc02559a7be4067c3dd10b3b497b9f6f9cd8266979102fd8fee715856a29e216704b47c3c6c0b27d9a6d6613a1d341e1cd09d39b227637f33ecc33c7bfc1292a9712873ccf682ccec7449f81a771d91804a3f69fd85715fb4a4e96c8897ef80555a77fb2e8749645ec269f008dfc6188206a9b70f84e9d2cd84e8c0000e147a38766704b3593517fe2babe1d2e9bac6c7f3bf60ec23ebb7bb88be86e7da9f9dbf53b1e5661f6a45484a82c13fd23b7951c3393ea9526d32fbf03b3b9502a289af7fb11ec86ab4e00dff47e7cc66fe7b9471cc4e7b0e62869c3908da6bf73b1c1551b787037ce8ebe41a8c7b9ab2b622c2ee571a651a8f9d83c0d4dad81d43fa5d978ea4614fe4cf1d0e01d039d698ffe15723579ec353420f61cd8514220403631021eea5e788dcb625c0e12a25d4c347b948df8243c4aeb19652531bed5fad093c30d39c4d7cdec8970832e4e0e4968a6d6660a6811a13012b6086be974f5babee98f718ae008cb5121df7a6640468298cade0e701192150c365f6113aa47f15a5ce315149b4ba2b76a52607671b3c236c30e7ef00f1255900e57b3cb617dbca3b3a04c40b5d61dbd19f0f52ac116dc8580fb9f811224f8f3161e567139f992c6d5fbed56f0c63584b07c7925fd07dd35d8345cf715edd52d78deeb88454bc3a4d7a1e6daddf2ec2c7b76c11e0074d999e9f40dcc5e4b3207107a6eb6cf63baff61bfbc8b5469d085f57918fd1b806a0defd5b200f5cc570edbe12751f2cc4439f90d60bb3bf319b2c642b2026b6b9ace3da4b4f0d6a4f73cacd1a444cffa21ee30e8c54674327fdc405e37810d8df1bf205e040de2113024363c93c0d5dda143af7bbd864705317dd07d8f46c74befe94057307b1c088a242a9bfde76f0dc41ec3edd20b9ced557f2ee423adcba2d65f07c54b5fbef24b1bb4ff063b24170af879cf29bf74783e4c9a152abe5ab3f7f057f2cd13d4f6055af2f9b6dffdee6a20cee349ce27dfb06779d4b3eb39cd43359c1ea98ab02be777b58a52a2613378e21c31c661ee6b3f4418bdc474ccd8eb33a73d422c8cb3a9f4fac3902a1bce7eb8ce36baf99d313d207d09128a3ad30979e4a8971ed559489f7a062a99ff73db618a32b445ccc3ce3ed1222d5cdbe8ec98e19f3e4791422304381ff43d058db22ad551dbdbe02ab2880b3cfb25f188f95c8375edd7ce00878e158c53d78cfad03eb60a8c829eb03a7b6bf0cf5e89e781b695b9aa3606e94a05fa515a39d472f478387dce10ff9a1f3a8afda8ed43864dc98d4f8eef98f5e9456af0f203c91d36214742d6172f3338e5a92fdc73b334e4d9d144e8a7009ae3093719299e89072eaed4dc666cf0841a04c9fbea0cfc188653fb289c792cefbe92df0b4c424e383b0414dd974be567fe75ee2af33daad92db14374f291804e8e8ccb8be3b70c409cf76e33fa0c6293421dd95c22cf471fef0274afb3103ee44ec3db27844bc6304f2dfc5cb545abd1bb62ae3167d26683858af968d467d14b298c6220b764d76a34e85009bb52827c28feb5aecf58723aa5cd7b3a8badc86b4b17ed6f4dafeb9ebb2d2a5ab0761967e33eb9b2c995d4bd3fc885406333a3be511c7d79d8e2c8e247d590afd8178cd86ca9b5fbc92180604d05b0260987811105dc849ea0d2d05b811b4a4894fbc37ab654dbada9fb0c6d738c35dedbc902870f36757e7d8286c74c2bb0d8f06f40ab2c90720f9b42f1c5c8630de1a9e871d198aaba919252c0fcb3dca97750a4630aadfa40680e6434d98cead0d29a2c554ac4962d99a3e960110914ebf426e95fde011692cc878a44ac9cdd9c47adea975c27ee4304856f0d569e1564ebc266c66c4bbe53b9b2767e84bd68d62014305a1ad8e3b817d0f3d93a3563baa457200c5812fbab4eba16ccceca0d41f97692523d873ef28ebb50d403d2b8084ddb5637990b160f0c2e3f63b910b692de9739229e6ecb9ceea04a4e1d911140d1ecd4c50d9e677a64b4b39dd4f6cabf07a8fe450bc66b670c78329e55946f716e9555656e82c89f2c21835a3fb47ef64f0711ce5df9054574822f07e30550e6d09927d4207ff22e720db8a4872b63dd5116bebaa87f034bbc1d7ed95d2849e45b06618cd276aa620eea8ef5181f08070326118b4fe9d0605b8d6da9dcccc803f9cf47702ee300b1c5238ab49a6b81436be82f3688a998d43305dd784ae006e19bbb128940423f70458e219fa6663ce6bc8763e1df761928b9529c9595160b8c09bf86609ce8c260279f8c14cc35da8e0247385892411abf4cfb5401141110e39e991e9088090788627cb254e0c2ce34006adaf5543796e1d33766a04e2cf6f90882b57a6516a08fd3f01fa9b3a6b9425f40351451f505bc91c5b488ed9a262215a1b26d998c3501dd54de4bd0f8584b2a2d6bacc43269cf9ea163fa65157715d813ca0aa27b308119b2819e3a86acbc6fbbad1ff575d4618896188c0f089fe99398f1cfe9921b39ce9fcab71b32421c2bce530318540250a0229302a2f766f63d6dc176b65f052cff6d62e488e0b63f80508e506952146ff4b5e54e535afa1c2fb7a62cf3ffa531d8055795cfa8c55cb3bc52bd967fa1fee63c037d92a63fca34734df099d80ebae696bedc5e5dd8f056fad10077e2c60a49caa451a122804599a9688fed743a194ad564ad5a87a6e4d880eca90d2bc4b003c1cbe47854945c012c393ff6a1670207dc33b1ea857e6948efcda0c911edf26ab358383829c5e57f70c8e930e8320e231c13fcda7862c2a419fa868230982178c99af6c89d5f212f6bc827de847e2f2d0ea96cd230c366769f5c8e53af4c44c7923b66f5822411037585184def3b3988213ae698c70dae7393f28ef83ba473f9012ea7ab6858416b97b0d1a3b6f5af163821bb1a3af590fcad7e743fd6933e709949d5825bf1ffb442b68d94fe3e61aa2ed0de82920ceecce292703bfc08e52d156a69f62a19ca2463dbffc358fe6cfbd4b23530793b3338b6f498fb19393aacfaa2693be198ebbc5a44471f238e196c9c47e71db519e2c666607f3217447689c731c36e67399f5be53dac43a4e43397794184793c39dca00db67b23b28124831eb56141f3301eaaf6ebeeb5afe1a353db3ab3c23eaed61799042804c93c38ca275c49caaf328bc2088c7f7c4616888277a99893fa17912a05ffd1d7cc423bd07c50ef62304be11ce7da041b80ab27ab73a76db153763a18fe62a7e03142dd92709fda548954e292d52020ae1cb6b4ecaafe68bc1f5abfebce9e13b8435122a43008cefcde8e0240e495d924eeac58f477fc29376e04fc487c3cd7a33f1e051d3f2cdbcf757284d788c06798ea8b2027f4496d3f0e2daca76ea88e986bcea02cc04295acd810a017414c950cada69fd8a78e81dd2d5e18c68e97ea7208a4e6e994148fbe7098508b65f810e843d13c9afa4fcfd68c04da63e060987542f92214da67b81c1d0759ccf78f01e47d98203ac8c7b4b3a2d03653bb91a25a81261aa084b8b41f4e140e56a1f678a965a600c2bf629829e46de5179c0a416818decaa3e69dfa0e0717721d9389c93121d1d4cfd1c0d83ba1dd8e42567b0feb1e5102c762ced8e0214782c8cebfd4ce6ea96855af87371f96493e31622babefae2fcb8a89e2f8a9f06dc0a6c2d32e11495c85548737be6f430b72f173ed49b228057041037bb7cb7561f3b65f18316f1fd0efed1cd4dc619ce91f4a4ebc1c415a3a01775487ba08f3927d5efd81055abfc2e8bb3af3869fe9e75595ff0768337194e9181631649aa575fadf82770569f91e9784a35a6cd4a616bc2f01bf2a6fe91b87c397e1b716ca5601295991c882b98da440446c06e460246556f5cba478c3b5d363f8d9eb5e5bf771b83719b73b932ae855373f92761e022507b9efd021cfb0cfa0c1f1127befe8ef97cdb55d901c498506fa73606548c927097a33100ed0415503baf8c0b7ad0311deeff8f6a94828620780e8e08c40ba8178bf8379b8afaa2c723921a268134b2216ec708b88dc1a17ee414336b8a99e723c34151cbd209a917e65f88c96b030b22e10d58a52436cc249185ebadb169b35af04e68adf0989849c9fa3163fdda99ae9d7dd3ca80669ada997ff9868ce7e12098e12e313afe7115d3c397dfb2145e2dae754c2e43beccbf4418e726ed6eae17e881fea28486df9614433723067604c701dd23041f4b082b9549bd0a4803e039185824e4d44c75b571ab52f9c1fad657d599f9a81d2555bce344761ee14feca1ce039e86683bdf664fb419928dbab6bea4b60c1d04e9c57ed28379911d86628a6bdeb5a227d316b311c6d40cc6cdd820a1a1501431fc7f154e1ad47e411a893e0bfe98176d224085965f389256f392c8bd91fc7afe07f9c6bcbbaf85c574706960ee0a6b27b2f4c14288b21ee15304910f6e56ce40f34a3ec39f1ab28899def2403ac91214cb99cd682ffdbdd42b599e1fdfb45216bc46441dcac1fbd755a782fe89ddfab671ab782660c3537fc044362002e92e7a118b502dea29c5940ecb557d97ffd5dc9dd3803436310af17cad9f8e7d6957216fc32c1b3dc4716b13fbf46d1c6e5f467a74be385e184d9e83d1aec25aed9332b76197e4cdeeb2d7d72a5c8fc07fa72521258a5ced23bad622110399f09a1bf8c05030ecfae957da2bf946cb2955f6488abeba7f16fa242cb3851fc2c3129cb4a261df3b083309486d6d31883defaa827be5edc479a4fbb983cd963d0502e104ef09576aa7b87527bc8ae2f631c78fde974ad10c7015e3b2059a630ddfe24a0ed606927d48d495ba000b23ea032007c36e87228cb3de10feaa047e22547bf272fb17b60aa82f0231342883df6daeb0a054c9484e4f96c126349f9dddfd6cdcd55dea2f70e2e647fa71a16df808237f2660929c2e3d1599acede825523359ed8bb05e4a2e9218ce19db95d63c1e289900c33ae7e7a24951dd7e1232a6c99d0ce8b63651ff3330bcc25e0c139ce6d0c4d60bef295110c366591b478240fc7fa8a8d5cc5997bbe79e6e0b540587816894a965c3b2e3cd1b4772919be2744b54f73eda72164409bc2ebf715f513eacbb74be4092a5c0c72283cdb55ac008cfffab4e0e42afe72681bc84712f5800ba86b3994ee888e59f44106f4bb1d4d5cb41733a3a8836195543cae94b194280fe6a97a0dd5775d658d100a80830b6c3c4935f5eb24c80bd897b6f16faaf6778e3eb06335decdf415d65a921b4094dc6f39d77da051027c7b49b62021d0dc67b30e2ddd03fb5b5c6f1ebc988528ffa5016d436bfae2080f10ccbfb3d02a0d09a7e7d1c0b2ca839c23d0b2631ed04fca82fae4907e48cde8e7ef823de74a12018f1b6c0299245b183698f7f06efbb2ff5b38b89d173519c4c38d1ba6809379ea5b5376a15949454dd2fb9ee214ac1f805a1b4d6dfba8c4218b9996a53dec08e4fe0d02d6f303aa210cace3b0395c1dd214f0fc0a57887d4f1e7d1d7e1d10244c425c79bf03fd53f8d769cb98e4b0c8594133e910166e285a32df191237c3588acddf6217711797184950b4f9888429905870da18b0a94559b6448693a1c007d064af78937d8dd0ae5c10cd4b9597f4320210bdc292c0ee5696cfdf7468d1e88fda5fa115520435a6bb8b62a20013fce3dec7e6e7f3ff2fcd4175c176ec229009d8e849eb6557fad31ecf9fabf62bfc65ff70cc738a7c5a22296fd0fb59db5d7a670b8bd7e2da8ab5f640e30d8bb36327389690e433d802dab11da94fdaf3ab52fc125ab37c9dc0035362e4b37a4ffe39ec8725fab310935d70b99ec5bfe7d2c622dd7e6a707052aaa65ae2b07c1ab5c3da31077904ea2558f34f2e1319a7ff3eacf45b49103c69bf604b1e5f0366ffc78e56f3066118654a7ca9c73b9adbb7a938738d927146f79b2e795f134bf7aa78663d78f98785775b433a026a275954af0b831b0305dc323931d62e9d54c060324f0e5154665a344169f6b9f3094646b5991e0a02e1d47d345bf5042ab937e0a23bb862636356256b54d4b6cec15fa70993c29eb3303239bb888c8e8e6940acf4814f4492e1f725aa580c26a0a503f452d9df47cdc1eec2944160285bd1335f5f4833ce3aa826f01cc989f62f4f837416a2b4440a76d324dfd6d5d8eb258b045fde508ea8fa5f156cb9caa7c71d6ebd6d671975dcc12e25c5740df3246be19a8575cc9cf591563e514845a79f7e91f59350c374ffcd880e98389da0d89d613017b66e304e9a4e81914fc5454ade4a298cf25b884cbda0c8fc498fdeaea634244fed75f73431f6c7b4ec3a822172c1589dd16e0a8b0e5c32de9e7bdfeade7f3e103e4dbe40aa0458dee313102faca83ed0f2742c35a2882218a3c42f3c8aa04a5393bf936fccb80a6d6de93393fb95033e7a99570ece15729adffdb48c5ebe5a2e48abe0c278707de5b71d62139ec341c3b9a47b3737eb723c956231f3921af7576bec389ff0d44c7310d2f8568ff6589d7c8574e41478ea1f0b834cc2a07c41eb9ae1212f1b43967a0a7db9eab3abc8ee16bcfcedf3a9bbc91708f3588fc4734b95ebf7b5cc44fa46430d88b9f59434e577cccdd66d56d45b94b0c7e74db5e29a8d0df0cf6ac04e765ba731d13445da71b001ae20b7bea1db579a8c244c04323d0d9fd733830c3006d05dbeaaabc76eb28589f79c23c2b3b356532390323aec89904f79fdcd0c1858c64463e311519fab16ba5c0bc9f792cfcecfce53473e28a42b98ca4b2a8db60a6c62946be6b04040c4a851c87a984412a4e457e98fa6a09ae03fa422baca98dc145db056950ed99082ee1c8d2239acfa84a25b7378f0cb5d1c597308ca3933a2c425d8dbc927dc323902233529b26351b335031b08d6f4af2c8775c170a6f428cfe387c18edd5c052149486a20201989e3381d9d577a16c0c0b168f0be68540560e423f155fc8792ba5b6c80723c52eec013f83dd944c6ee49c0512c7edceee45305b1ee95758580410c5bbce9ca646060df4c4f4c820b1d217231927ff108e0b018158680ba1ae08456f6c7cb0eb0bc7f638b7ac89612994819c8a4fd596881181ae5b62a81493fae8077bb333ce97aaf0cdf2016d276438d5cd951c4856b916a82a4aa3f5035645e20e86d31ea079074344d0f208db16362ffed9af527036c4645df98badac001528ab9cc24083011509d87e1a79d66deb5bcb5b87a7a9a46fc2e081b07b2b66196cb7df3797a44f90d44578ed3167a62d0cde12c4a08fb543f255137c86f6631e98b10c95e6528b1029d5d976d8fcc8de9dc2070b9dd53adb03c596da4485bbfd14386735b6264eb07f516c415d768a796b6a3c513e3de83012716bccb1b17e50233cb25bf3a80e849d1c4b7448f1871e4653bac2a04fd6e8196cb5b165631bd33a45b658e285cdc6b2ce82fb8f7ed929384244fdb2c82f3e4c86e786387608650f82353c2c56155f8233899e5d36dc2649f3b157a43c07b1d0bf1833bc9f816287362a1fd91c0bab0e05269b7bc896e7adacf29d6de77e8d2b9b76f9c3f2f870b783f27715b34cb3a6c4b512af4e42d7b026312321f273def7dea716295f0880e19a98382376a00c2ab5f1a74cc5ecbb02465ee0b02f0b480298ad9227d967160262bf1c3e5ad00c4aadc9d14509396919920359410ea84275a112ce3a2ff49c05ea7eaa8d035ae576c612e021c13a78f9c26cf673df2bd05c342cbca5232ccfdd13734b6d2087ee80b73d47d869a0dea750f45e17ba7d46a6a017c2cd2b200fe6755a730b28c644020c01251a4e1a4639899763b7a33b41fd8208e71fe52f1fe24188f2a218fd8a0111f626eb0dbf69a1560e912450231b14f254960b6ae3f3641629b45a11e6292b5a53228af63058e0bf6a4e016ac2612a1814a02e4e0f2754dab656e1727ad50e44d884b65b15e4a3e1114ee60be725a5e82745096fa126cc77e2eefd9d443469a63ad44905143cb55e9b60fd5081bf4a4afec3fb24622eb1833852d4066dadbf8d9b95bad27882f944aa68c9a0fecbaa8dd6cfa12e3bc39a3e558f0b374012f30def27d5482c16a03bcb91dad0df8480f471da7af5e9f80f5f8c8a53dad3b1f805edaf70c35bdfe18fbfba818b65bb619630abaaadcfc75349509f96dc9a3555e8cf296fde62167500cdf327a3b191cc556b5363eddae6066425f7d4ddf4acb72c7cc4423073ad0e66fcd18c676cb7cb44fc9c663429f6f4025ae878aa971659d96e44c01d9d9af530382932ef6881f70dd2e09d6197c7fe9431a1dec2d9be36c85edfa4bc267373298515fcebd8df20891611972dabe509dbb6062a123344f9ad9af6d7ed55a7531f9d98423f2d1cba0ef45d9f3ec1a84353dd6ab2bc161efb5c272760ee85479c73960d8e3f374b63e8d308c603c9b7f2b91ee6d89ce9b099228548451ef0efa2fb9274d05ef8349de7cf1ea5b9605a849c1100d17a2ff4cb34ea43bf1b09fc4ab8ea694c17ce9aed884776543f43ad7bc09b3eb8b3261f781a10c77658ed93171ecdd7b7662535793f13611b530c24add8b28d3ae6c436b08efb3a9441d325c6e3c3b06f5e6767210a22ab3e69299e9021e2d1d00812c621248ac5ecbf01a7f3bdd8a6abd8f6d3423288f5623661128c5dd9a5188efc75fe6a40ab5767d16475be76c1b8d1df32a6a77d4f6be1968150daec6199afb2e5995b728b27b273bf7a433454cc83527d19fda24beadf37367886965fafbbc9ce59cc72bf04342c9053bc04c384e7d356185e121b8b81ffd905606a453e05ca72ceeb653f01728a670f737a942d74d9656d2d536247afed54c1dc10f95692b0567dc25b65d533503d5fe8c6c7feef8c3a775684d5dc5f275bc4286fdde24b444d5e051081cebd8d0854de339ea3cf1d6e964539001c918f15f9ea530389fe70c0090a136bdb7945e8d93dd9509664f0c780b4c8a17130ed3c17ee04e9ed7b054edc4294c3047953b39d5d8bf3928983791f07491969e226aece53c47502aeae246fe4300c30651c1f81d573f0e5aad375119d0cf15ab3bd6dd8ccf94584dfe54ef30d8745cab9b795948a1b1bc83ea68cf72d405813ef7edcfdc3f077a8178adcd5b3bd7041dc9c974b824137427a06a657089636b1f8c65a8778d8620d1ea8201ab2b035126f70c08146d3f64c38674f83a8b415fb398f90e60745d284a11687c71670c895199b515f68f169c65ec135f228c1ca093a82e288410eb7b542ccd453da7a2100b97c4a6742887bb6d82d9f747a38fb627a4fd6ad9e183f090034f5e3816c3050dbfc8ddaf464847c3d47310319aa74787c6fc750dd6e6f9aad948a783bc0b91b6f933e05d574e97dcc549fc9f59389fbba1ab2fb3bbba4fac1c4288874069fb2a5ba7b94da5379f342b37fa2b831a5df24015440151de9e443371c585d123269fc624f5fb2a2b7afbfdacc9c4e5bc014841daf0595542f4a65b0d6d953977bbfdf9cdca6f360b2b9e199bca8fa30960a2e9921534ab071d63a6a157338693ca7ac91a4ff150cd064397e2191691f0038ed29d631285d342f111cf68b5ef9dc1945e8e9999d3f0c89e3576cb0d80776c177752ba2b41db1578a905d2a4c2752a3ea05c1af927ea46597f4005814050da85afbb50ee864262ece2952170df2d9d47f542efb0e562914c6c81d4eda9519e2deb23f8c8357621971c610d3c2eae1c3991b45c9643f3ca307e26fa4cabad19e782905558eb562ecc6e22684d67bfc969b842b96a24eec05f6bddee4b6a45b1d972d1e463f885a6f54402afa8351e471dd7291e3dfdd80418000debd205672527ae439e62fb0dd64b14970f15c7f7e5cb4e2d48653a6b7865d45ff5381012407442fd96ee2b9419176143452b7d9feff94cd3c1adf4b86810fd0286581e39b24e91562d5a3ff1db9ec78331322dde0deb9de73fce0f30165e0046a80a97d755f4f7e8da8f3f2f608face6fbd575a4ae37dd3be58ee3a1dfc18bfee14209d41719160cf91922b76be04dfc1c5092dc6afa128ba86e65802895b1b3dfbe4bffdf925cdde687da983f0246c5beb27e26a4cdd3b7a46463e9b7ffe27c42e32cd1b3861d9b83991fe950a94331b3ee83579e109de342ab4f29720937f0956f9002c448944c21946cd76c89fe01ab5466b8019658b94eb3b7a7e6b7c3e62b86485ef58b7169737a8f2c4cab8e7252d00c2573ba74f442d194dcd06c7167c6fd2602e22fab4add25090c50be0c542d4fae26a0249ae11fc5448c692b562b5851ab54ae29e3dd2e54dc290dfc237e2f5e3a46f53e744615579d893ed2e02f865f0f4b1f486afd3a724aa0112ccfaf20bb289d7f1e6f7dc7fa47e5acdf5766ac3b50b27dc76411cd435dcc3a2c7ea609021461e448e5e471312079f53a5e39f3bff36dfafa9c26b029a69dd73f90aad2980fafdce7df11db11898fb9ed243bc14e13691636b2baf7d6d22065626e22c23fd83d63194a3e57e5466de0910be6b9cf3d5b4f85818259ef1d9be2b7a0ce8bea3f8315c9601f816688c8884d770b5fbf50a53c3638d20d5f851caee03aa6fe54fc207a37805fbbfeae144eb2cf1632db09757794fea849ddf579457f5870ce27d8b5f8c18412e3ca1dc64cc758fd32e4d2d988e7ebd053d0dfaa53ac553c6861ba11cab988e7c5ee6c42dc0001019c836c20432a29103aa869f6efc308877ca284de74c907cb77bdb605f845981781a63c4de7690011c18bd19752dff45ee48b44ec259e9c37729aa8671f779e86c63357e759b929d5c7f0cb7e5b2a7a0c78f007f68ea0208923d3fd7970c88ceb09e99462987e4aaf61240ace542776904150a3d5318fe4b760289e6d41dd2821e3a7ecca66527061c97d9a93305fd40b3dfe8f45c9769f5cd57353105c7cedb526f2f1e6e30e0e3e033a7725a70062c74b50ea11dbd1aed603391e9729b81e7ed6c91c1219d1d698ce5e650b622c7da2b66ad9975175df3dc8f819541ab5940e4a00cba811b42fc87db2472eca4d77b4f312e24142071b68613eb8f429eff13825cba3033b6933d87bb2178476217d924a16bd823cbc950968e5654d0a9bff43746350e03d3181483d8537b26778e2916ed802de2d3b58b326fa8b7c19ac8e043c749aa16ea9d109aad2f4058f4d05ce74031775e964e1cdccf81d8aa2adc1ba000a7a03070ebe0afe53a5f72ac05ba4854e49b7a82804c1b07e888941a51501c9242470c8ffb0820317258bb62977f10ec1e64ca2c5244a26616528642edab6970fe2927fe823fd08de27e4688285071b85ff87d39888245ad1731ee800cc9e7d9e81cbf132f12151ff094ac1d1326519912d1f3774ad20b9adbbb443fb5e44103e1d522e45f7164bf535e72a2d8d10476c047397610da363fe53bd751cc23d5b6655bd52e733c2ee843658ba757b2aeddb300bdb1bbb1ce3e241b8dea8deddd2bb9330e5afd2ce88ab22f5c2a40b919f664d5e6dd79c17388b5217cf3cb0c57960cff9923d14b40e48bf6da934acd2728918e4f43985afadbd56e6ba79de2d6062e450382e6e56506cf5e21cca105e0c688f229a9b6d8f0870147ee1d298a86fa62e9ef06f3d48d3ffd7fe8bbd2d1d08fa55a802822b90b8f41ff7c5b74fdf96102773f07be72c13527cb1667be3d8530da34940ff860346b9c47a33f7e988baa0698045b3818389771ab32616d00bee61260288932bb9eadcc59da5705778658900c30b3676583bc45432bd3577b7c319db4675f9635fd6b1206527031135d6bd289ee4e2d8e17b7839ccc3f0600c42263225956db434da0935349d3b2e6ac6168a24be273923853cea1264bc83520564433f22061992378a688ec962186a980a8e98e919e532c7cc304167a74f72cd8e7239f9ae13e86dce4a9b6cc7561a49d9f7e286ce53e5f98300e9a4674c09249fd5e3da1d0f38821973b1810f9df442a4c1da44225fe4f28c75fb19e92bc1514eda72ef2416b4364e639d0515fed06a0d78e4a07b679a786ad7dde6b58f5098fbc8a4d5cfae400410da6c0ae505fdd3e029f0233d01dada3039f4728ce1eac617907c5d51974e3329ceb15ccec2ae815c075b874ad2271d920b296e437aca2ff0e946c23825b8fe68f111d90424ad54d134a2161ea9930f02439c2e7102993dbab4d18cd9b13a79e05152503bc1773d51ff8eec6f51354995752c3825e0e9af8542eb449cc540873f7c002e7a6e9a9df32a8268bcb5fd4bd7eeccd6b82f7a1d24328e85c7e03829fb577af1be34f3c030d7c789815e8e34006a7fd1f7dcf97b040692fce10e520655313b2e58442d37d15db1afc095880b67b32d4042eec92b0d938015445e8fa67d65fd95e83af3710dd0179af96d8c86e7171292d96c7af27e61294a4a25ae90bfd10da0eb44fa443a067502c1a3b2f8826e1944b92e62c8dcf9bdd47fb3d0bd5f9406e7b738d0ac5e2cbc917f0d0e946c0b2588e29b1de9a87197851c564479dda376bd6cd2f801be42a6ffe08ee94e70b796d46dd4096cda1ae13c99c80154bf83d8b0237de5fd1138734eb63256798368eb4c776defb995f7f00c9ab2852bedbbcd976170fe8e33ef3c7784128748c02b5ba9664120ea1fe7a60c95e08d936ad1b96601d9ad8badaac5fe3ac0b664bfb94c7f1f7687932aeb3d9eebd64bfef544b8b72c2fa3d6cf203fe5ff4f70500965b20b497e85408a2cf1fa1287aadbc9c17fc10cd5046a302f726959fe1ebdb6add8a4676d3f713fadadd81089c8c33feb9314e9aa4b796c3410d99bdd16898a5290d475edc679bf122d6a467c25f1ec735b6fc02a811f4d1abb8a1e85989fcf8455b1e49908035a6b1229fb58f82baac972f0c9b8964aa5952cb516eb24c318ada3631761031591a734a78c225d1fcb15e21126dfc8cb436f7dcf3f1722ba4e9d104fac0b46650b652c2e4d50f08ee396c470eb1eca5e27b1337f8ab32ef32d4f3dede1422e641293c98cf65e73a796a9926a1bef3fcc76c60d661bea8298798a886e4f7589cac0f69ba77772ee6f43cf1f99eefdaf0b70da23f4be339b09982970a97e944f7ddf311ae2ac000c7cea04577a90bf56f62277742e17889a99508a9540e473e55676fbe39355b3367775b9914c30beca6f3282ac89743c170cfd761ceb0e29de86bc3be2284932b9e7df57aab846693ac0cb36611967a0a71803ca28ae346538e1c78e018a9ee9a093db4a7caf1127e2c62a7a8e905a52b2767e40b074519a24443b4b0c84c270233082c2470aecc02f2c1b0b317859557c8d2d8dfc50440852d3744e78f325c9c23ef7f05149f8f3ba44eac4b27272cf1494cbf7636fbeb138ec7400b7f9a07e4f400076e9e0c9bab205a3bd5d76d2002d61dc7d9a69112bed9e79078dae9d1595c7fefef85be46e9363ba554e9dc95c8081cf753aa5f347eeff2d5fe50144532e1ca1670480a4350653495df4b59b3971d7430baa1f3527cac3974b5e0ee9c5263d009ad8cf1e2b52fea15142a62b17e8d5c8295999e50081c2438aa6f5625a54632e1a1ff68298659762e7ace593bb9063f604583362374455fe77fff5f5744ce31e238de1630456ba5964c539358ff8099377ba9fba40ed01bc3ff5961da22c4274b40c8a4c51be06bf4bb10057efb1268db71efd919c4a9408a94166a768529a4e134c3dda6ba63a35d54a28e2dca567d0c37a12dc15f2f91a708c222ddee1897a2851d701d5ef39bca153ddae84f53742b2fecf905a36fcb4aaf2ba2c78459eac9dc35ad3313fc6ca8aa69585b33242431be074dc366355c664d6c1582815f9e6da359c89429911aa7b0d00b8b951c50a2998515ba927fcd6de676c1cb0b6cf9c43a12b572edc41c465d5c38a124ffed8e9a9bc3a4ef29d6a9102b791dce0e14e693abcf176f17a84681e0eadb1ea709131a98fb175f086a0daa159ec83c53a67a9ce2eb21f5434a71bed227fb3ac121b396e707774d72a3ed3e7fae1d6094ead4ee8df24e3362efd8aba578990cef7a0dd666ca62541291718141244d2a81606d09206b366ee48ef2c83bb701d81131be8846fbd86b125005bd89abebe154e8bd7af7e56bffda4e246d2753e1a9f16b0b00e3a3cab13bd3594b4e347719248f3782df36560c68f8942b3c8711110e09a926bf643bb9eb0da5cbd140543489e920670341860b07d6ca8abffb47063f13c2b9906d7a58698972833d09421d7f3e9e3ba3cfe74af72bcc5e066da36bbe4ef7cde616e79dea5b35eab00e57f7f3b235cee3f0e50a16d7fee3eccc8a90a9c8ae8352f73669be6c5d4e9d54f0c36221b3e917a1386cb4a1c9468018c6afc9b9b2356a2a49e11127471a3a7e152bec045c07ff1947656cda1d8f7a94fdfe36537c7507f1b1d81c3771bbc653d7d2267485a76e9f8a25fed8c6d3f56761925212f03961a5c5f285b10f3ce419e7d02ddbebd6f689756191d33202daf4fe03fb26f685c6fcd5caf27fabc39226b20ac61bb92da641e0239b4219d487aff0bee251b10d5d8c55f8ff697da4e74f9af40126f79d3c8b4ba04444e0fbea37dbd08e4e9675ef8017eb522d56d725950a0a2977648a31318a136fecfad21e029212de546913085d6a2f209ace0fb7a36bdaf7aaa926eab45e99024a8dfd626d3650d799a98651e67b08e1a5e471568e02f4c8168967f86db458bf456ae23c609e6bc2e37f5eeb4c7222b0ce71cdfa45d158cdc2de7ee0ded4ecf08b53622a0f4f56c6b2755c89c8a5964cd2f49e406cba3bc5ea607d86633d8ecaebdf59f9f6f909b6905e7691649d885282f7f6fd0d5b05d370d7853527b774963e0ac180e4f91dfa01f91b09b15dae82f471ded3d11c23faaf32a4789472ab9a3023810c1557ece91e598da17f830d9cc7743e3448ebf19e15ceb90c569bdb9e9674b98202c967d1d88a57ddff74bf50e4b6c60028c19e379f15e0df1204cdd2255604494669e1280200edb9e8319b94aaa48375170333581accf0d18fb0bd22435df5a6f7e18ad1a736ba482220954b96b99e7c5c1c22ce9761f249ee28f39aa09f7b512342cd3b70366c0b3780905166144e1f8668b420b40fb76f8a9c59a28a2063a90ba29814b80f1875cb6f1c6aa24f4c762b754544b671a354e2e56f1eeb232fdf411cbd6c247ce5e1c7f84a7b41219f500865e84332d6a0be3c94e9822f18308968f1c906e9bc6519ce1b03e908916c7f1543ac933319e6f3f5794dfe2f409de3629e29649084d6f39363d965894fecd59e47d79ea9e7b4087201caf5ace7ab01315b869e4e3d0673d7cbbb0a0625a6f09514ba9025e1ee82bd3a844f6303d4210b05edb85707721b445d705ee41a2fa831dd6c510b5c38c678cf6ecb89600b33fac2374d27920d918195d9671109fe5fc5b63583f6ae82dcb595f37eddf61483ad9b096f7c27dbe05bae06575aaae24a9fbd2387aacdd263b023dd17c75c5380bceea86e7cd00036206976da30dda7bba042d80b559362255954364d6e3ab94ab5dfc1327f8be7541aaf63b5c7cfba7fdd4ab693d0fbfec2b5fbf70f344ff9e99595d6d24793b29f30d0fb7f5ab99f88fcb750257cc31b28a3a9088c92c47d9135964213ce9f37cee084493cbc89b7e6aef1dbd9718c208ebcd9e5ea283b72af6d3fa4f968d9b84a713e9903feb8a5650141f8f373de7117a04686cbc590399591f5443f0a9ded763ea4f8a7840f9552fe840c3a48d5f4fa989599634f17bebb513bb5e2b7fc0fad5087dba9c11d64facdb4c8b5acadc771de1881d6a811cca994694593a504fa26bba62696bf13f13e23a45a90a3fbcaed6706a05cd464815ce433251d2055c5e65ed1b648b9021b6d42e918e93ed60cbad526a9e8426df326ee81816b6fc4883d481544ffeeb4dc41fe4ec072a014de96997535b361fcfb7a5bea804fbff0e77616efc3b8350d0be337b3f49c72485c6045aed126c8d142b6c697d76ba92386df985a2c8b6b61ece54358a62c18eb7170d05038748f5b9f519fbe919aa24a80a692b1dd3656ed7b5f26f3ee91a3183ac7ed542095682bbe302d772fb85c60ee0455fa2f04f948420f4e6986a011e665d05fc9836f23a3dfad02be7bcaef00898644836a6bb9bdf49b106d20d177963f958c8122f094135e82cbdf1c46d44cc0ce607656f640934cf089f6164c5d538795adec64200c5e2100d1520a83384e090784134127f307d84df1aace87ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
