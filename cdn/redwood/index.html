<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a10c07086205233b9c17d74ddccec860d272e43a2792f113dac933284640d3c92a4129f4930cfdab1e6d6a692d2f63a9835954ba6a97b80cef0a9a983a1d942dd33cc76fa79173e9163132660f721886cc7df515ae36814e1b1cefe6d5bf45bf002b06a33bfb759668916b60f7802e20ed6d4d4da5d76e531478d71bf41f2f0bf665ee4cc1593c655b1f6f456808c6394cfe57a2a324b6ce76438c755c9617ad56f5f931624f848d9ded02010c7da0fc554caf14ea58dee896867b0381bb17714bfcdd78c7b2764a996a1ad4488408daaae9cd1dbafa4228e0e209c02592a6abe28612c79cc62d0a6919e4616e917364830294fa9a12a9c273cc9d64192b1e6d3b24defd45a76cdf55311f726da68dcbddf60cdb8024addcc4e1e40010f2858ce3eb8238b3d8e430f4818ad1c2946efbd7c8dbc681de64e445e0ee6c3115e80208d7c95900aa69f506409664cfac485d55fdc3923b9860919adbfadec8cc171801ae7b1f26d269740f0b8651eb08e1f3c5a1d4afdd818ac53a11b95fcc27cc7b52b97d71d026a734210519f3a742a17d2a41f81090e75930aca3373fa4ff54993c31564bc4b26315053c4e2c3b50b992be7f1b9c118c0a3b4d27a5b84a8081fae27d107d37e4092900127c4a83c87d70e5dda86886982ec3420c7524f1a4ad11689a381b1ce82a88e353a98ea729382b0c6c21b1dd927a74a17550a63e7b287b31a896914ddd77cd4b2272d7ef8671a6ada55e6bfdb32c8719658f8e876598d000e3b6c5ad36066b4b1c48287f445c3c7410457762d77fd6609d16c2edf2d4b6086562f7f41222b18ef7a0391ba743f022f58bfa707902542c66e1ccafc987b8d57e63b322af239ad194e38d40aec24d4d7c41ac15e69801cf46066d800b87d163e0836075e5963a4eb807b0e5c51429e34eafdf3430c011447c7312cb8b4c988ba985f61ea21a8dab692590ce310fccf337a7e7c4e87ef7ac4418a5163cd2d7a62989156cec907a1235a66988deed3c6c5edde66d90a8381ec99442493dd879c0dfdaaf0a3147e0782ea02879962a4917b46e5e59d110a455dd0ffbd7c58798f037360c7f2f1e0839bf9a441bfb37910af92b90fcd75b75c47a8371d43187f6a7e8bf5b6f434375e47c261389b19e314843257169243315b2facedc49e16cab7b3b6903f61cdb0c39d7eb3c0f81f845d259809b5c2b22f4cf07a2344c02d498022dc485fb943152825d83aaed2e4c111433de01dcb05c501e3fda00a3f900c49bf9fcd9b72a990804393885d4a4842ba0f1e7a79f3f902ad7b5028588be5a400de027b2ef9f2050cfdde6064828e38812a671338d9a7670c80a2fcd75e3e0e63613ba5bece61ac56407c7ea7b2e96bbb2a52b22f16979305f1f7a66a6f7e59067ee1eaef4953a28dae2e29b5d8f7ba925de0d28d116f77bd9e2ea11c4c9d668f70c2b31d2f4e03ba0a73966a701ea01e8f4f6633508f112884d9870a1ec3feaa23ec6a7d3fa394f54f32e1e359fe616b65b7f46c5cb8391579ec2d7e272326e68a054c5f79759f02005641e2b67f10d154d238cb5f2f412b01ddec952915a91e4b5670848fa86b1b337a0a63960c587e7408985248c65ccd813df132fbd58785a6cdb5b54eae1e2019ad5b9bd976b041d71501c43d1ec5d6a214e97748cbdb52dbab26ddf0f7cc7f3057dfc8c29f232d5181b0f36cce2d68389205b6dbe7d6fa5199c6353d039f43c30ac64563ca1902c858b46578f504e0b54d096ec26845a01f161b886855fe7a052193c376a911e8a2ad96d2532863fcf9e3c96f0d1771e8a8eb4b0fac236016a5addeb47d77a3f7c906cb3b5bc396fb8014b87792956486b5cf830902b77ae558dcc7bab57d6d6a15b9f6965a62092d0cb38ef63301984eac4ffb729d375109b22b8ef0c6eda270b749dd2b94a721791187b0cee20729eca6e368f109cd57cd2bc7463a3e1283cc79b15d99d75c72a85d321f282b8e3a695c82f545f076384cadce3eabc8176c81d1b6d728b00618ac2f4a96f11f4d9b800804ea4fc5b971bd047ad753fba77751d7cb9170c70a1b890b13754bd51100e13e640ac76becc1138d22e9f1ddb44675a7dda89d13b13c0bcd5749a43f7cca213e3babffb1cdc50db16a3ff06d9fa492faf9c1aa4852606d8effd1face0e1ed67956395ddc96032870ffba8de7ac88d178fdc61a9e45f5e73c2cc2e31ca2bc9f5d332b324813e7eb42e1b6c090a1c5adbf8bc6442f157d8ad81cad405b09a01719912727760e72f51b597a423f6078730ca43577616190cef1602bb915606ea89f84ab9bc84f03099e344740421228427181c5843da0b7a9ac149629740a31d4ee624b32dbba8086b2165cd348394059bd2216412957611b83dbbb81b7215f177470618f83ee2864a10a0986d94afdb4670f61e7ee2066abfc5d4ba563526adcdaa5a58f0471c263551668438662e1e67531952e78900a658ea137b2fb7d44940f678a1a7c9b389e7964561822757f3c4549f6beab398e346de9a6ab542e4a3e14927e696137ddccd3df8b1fa5cbed19e6a60c6ba581c17e805531708a5b8d62cae24fb915947313a08d876c9879c03532064ea629e05d6321dd70d0c063956738c8fd7ec22d9e2a09eadf20f48984f6ef3fe8a55151bf83be052bc4740365fd5121534031f0c28218df615153ca9f9818c1263cfc497c18c30a178cb22d48355027f57712162a3875c3140ef01fa77fc4d86ce6a479b910d01d1765e263f2f210f9e9813a294bcd014c4278dd6e8f8e2784b579d2e53dcb66dd7c2cab797b3a0f8779abfe8fd4b2dd8b1c3784abc2f4c90a5f8a057d8a08a05c6889407f1fcf3872a04573d8209a9ae2e0b74638d10af167788d517bd72b9a892836f3647432626760bf4abe336e80bbcd909f88d25a369502e1dfcbafd1ce229c59e8657ef0043ca6e776c99f62f1178fe18aa054514a94d9173726d459526613059869854e7b2132b5fed24b1bb0832069391b5fc4ad4ded6f9332c72876faf2f01cea69389bf94671ad98684aaf09bf3029005c6e58b0851b9835e8f82be01f59de76d48b1035603c809d728d3db2bcc913e450e5049995d44e45944abc7511e9259ac839890fb8ec02c2c5fff46da17297c647713dcbb28796f256c7cdf869a1dc959bfe12382ce156d837a447dd70b86ab5a6a869906bb9f97dd0a63bd2c021d962715328af242c4f3575cb5ff2eb8919b045fcb8a43251d652dad3c1171f3723363442431781b20fc3fc3c071e803e01b673738e4281855e347808d040cdee77a52fac5d7acc24e9da77c9d501970b78b61063be6f30bed22896890e871b191222f95ec7ee2ded1822d38021654554b24ecf33134ca168a9896f7626e1342185aa3f78271637eec1994c310f8e47b0517e314c38a7ea5e30c7e1a8b51f5c7316e89207e224cb690ed2589a60503bee24578453929ae3425a0289d6a5cf8ff0900a6a96fff6b6c46dd16f8249b73502c2c8e60893e32e336e3bff5bb6fad0d88f326c5402a7d3ff9754069c1b922fc4586a3367895d027cd26fce9009ca44cc5bf5a8c5ad4f90bafb6192eaf25959c2940649fb05140d48cf0191b021f39e6b2e153356cf79563d75b238fdbdca7c428d607ae6afe491482c19a4ed33f5c7e68539da7fcb04c4c8c00d6dc560d341078325eb1eae41fe156081195726495d5ad0098ed6353acfe62f49248eef1a54c1167f7fb6777e75075f3cbcda804d6707844ef04e65f5ba960fde0e18084d59cb6ed9ff2a257bb751c9e870dfc34606c839510d70cae2b0aab1d041b722618cd9fb75ea2d1e0db26ee420348853ca99958bf4787cb0aa189efbab8cc830d2d86cd3166d25a70c7b387b84e7289eec7ce64cb1e9b7ed7965d4fcc5b42dd2dd9db1c8ac0f3102709d820999a8607c96ccc3503652eb057a84f8cc9dd3e072c3966dfcf19b848005d7cdc533956eba76fa89d93a3e7d5758e292b17cb028aeecfc20da313a0ab7f2bd16775b390d023b139ac1067e07e8a6624623dd41209b6d1112dfd4f0bc3e6b08da78ea6df115c5666088927b7e9651a1d5aeb2038b2d2a1af932d63604019a280364775278d94e449fae444595998b0aadf89f64b381f4214602f7e92314ec2616f03a5a47dfb33629502508e99a4d68b97ab85a6d42829e7beefa49f48eb48ac14934babf29cc698fb4a0f2b1b210f1619130f4b0bed398cc90e781f22aab3eb1799d00606922a6447ea651aca44fc0f99d678b2a1cfec783eae4a80a07b7b7699b2a6dc06e16fcb868413e261e5068ccda7e6355994e25d0f69203f1707677f99733581275130962b9eb74693707c8219085bd9893ed7b151ed35bcc8b8aacc5b4327e5cd9679aba25322b6733271e21cf48a29018f78df110892b2cf0e42de33029a3654fe0e8bd4e273ae2505d2646c8a29fa72311d18d7b9521c7d0ecd8e5e659ef1adb387eb91542b4e4d1e8401e82a89587283a0ad0cc1b72383a34c9a6503dcbfbcfca75fdbabb9f4d83cc72ba175358e764d827c731f72898ef13809994c78efd367ce084aa424ae89b969dfd46a3768271e30d797bcc83bf165ff2926ac1786ff7c8c85757b23463331432a9c60ad3663adf8dede0770bd36b3ca692bd507b6b6eef01b1d1267663b9f0a13e438a28e07d60316752e9c9c41c618226e64c8163f32dd8d8bd48655df15534b0f4b3b336e72a5e32b876679d908a99d06e8cd7b5796d6fc335c370dcd5a1dfcaa4a92972c52d121bc47bfff2b9a82ab20c98deb54c0fa38a96948bd62d72c8c290ffa31dc6c943774fe1056e41b67f96ec8a845ed5f996af4a33bf9f2b52880ddbec9679efd941d31dffbc2022566d068ad0e89884a449d6495390248122575b9cd9b10d377c82f3b21ccde17c113cb9e3037bb998b18543149b9586ea8e70f6163d36affcffb8a5bec6badb4c77b77be3a30eab55c9a504dfd71c92e254527fca07308de1ab02949740d63e546c7a74327ca32447a743077838032c26743c3886a15ce8452c319013337e9bb5c0118dd401b59d4a27d12ad878b1932048fa59357be0f045ed992c2c38d48bba51089c9c136035f84a205981a2754fd047a6db562700257cacafcf74755941b5f73e831b02b1ce27cd0234db9d5fe19befbba083ad53b12d00c25ae823db2d3be0605567688c1d6d9a8997ed6253a6de3acd3fe08032625a2033e78fde484fa188d94e1f2b36bc1a35d0ab69c299183af9e8f651fee591bd0161bd0c136171b2ffe1f7b90f76a2753c0eea4d5159b55ba3fe06e1d8323b4bb08dca4c9e2bb57756ef117c9ec4f11c17e7daaf0ab6000994b13a55d29fb6f26ace45fa35168dc55bcda1cc781aeb0770e5465bcc2a5c78d9ccd35364c799d3db1a24878d3656fad078db99c20fa7675ea83d78c59fd2e3450a3dde263e87d13368d8b1eb8e034af2f22afdc897a9f89b26a3c001083b619e7eee920d0c4282dcdba7de53909690d78d77f7ac968c270bf85db953437eee89a93c2093c42e755c80ae9e2023457c3f802f7e213aa830b6bc7f6f69c837d20985ba4bfc1695ee0b17d6a76e4af80e0e3d0e2a759222651eb7513608d5abb0b52fbec47c26d042cbd6ee96742b0a6a21253e62b71a2460f477919ee34930c08d7bad487a406de8fb3772a363b20ad8d984a7b4350f48a57541dfde9bab31ba27efc9ef6aa648480c201e4b20fd55cf55e355ac877b8870063124b3efd31d9d59618e851b74704c98e9a47ab835da15466bc504467c243d9d8387241fe8d93491adef888e631761a5cf705d5a222e23bb37b277f4a8f2882fcdf3c054215a7611f00f786a5b7b54c7f19c0a4a79ce0c13e72ada0e84f527b8dcc3a3bc89b769292d3b358c5e2aebc26d01b1e8659782a02d14f6f2d3e8f33e965852a40c803034279144ece68c4027aaaf52546a45b7e17730e0c5e9b30246eec78ca3430aaffb1578792c99b9b4d0c9e522eb9ecbb522f8619e33b629460f53368db891c444cfbabb3c8028ec553d499acb719dafc084b21d95d316f1e65e93efbee5eeb18fbb36440f212663bf97fe4050a2f949cc0afee16f5eeadfca7a123de55b88214fa5461389930e431dcf496f36b890512c889c633f06b5b0b7b17eff3c4def0d8470232bc8a66b74e9ce277af6bcceb983d431d604185c5e4182eb2cf4ddb049f2066208a7bd987cbd3a3853a6493415846072d38403077fbb78619bbabfdd2143485428e5ea2f86457893215c0e4a68009cc9bfa7f039235dab9a8c89c3ad10d2856f5aff0df1a4f72f9ba80018d607f9b6ed70eb354d5504bfa73be86b3090fd6705acdf28ca9f56bd497d3db574e9aa2a16113642b7c9d18607d92b505c28a3373d6d75e6f3f75a8a73d4749c4a79bcad2a14617a6129569db5b3caf72d983dc19d9a6077dedaba0c300d8c03cc085ba4b7919b47d487aa767a93a3540731386ccca63c82d7615104e08bb35148829f9d68338ae42fd9d87a4545475e7fdd71f4e54f27dbb5697faafd4e27a9678c6adf1a0fe46f498ee6cd73fd210c3c309e8049604fbf457d84a11c93be44eaccd258c9122b8c0ebcd3e6047237b88edfdaa027ff211b10ed1c1f6e2ebfe97071a7508ec17fd7c022f01e0651a2830e21b6bb5a04b64ac8ce85d6f6423ad0ad2ece51a486267a17e00fc617bdfdfed67705cafdb007a2478e3b89a35c85d191133803c22aba85ea9e1a8a024158f63a27590d5151bc2bd54fdbb449588e2e62a259d82e97ae60d14cfb82b03bd25444d9ec74dd5c346d512560c9be3a0e6de6fe77f6909cb0a2093e936ce9003b4750509c2be52ad9e8cebf0f9e7f4dab51701185f66335f7a48b7ce6fa01d7e9a6be2e258bfb39e195114401df915d1317b32206edf32cf44ae5238cca5a78668b3b409d4378009ba5333ffa79c946f15ed7e7ad432449b67da81b4a9cc7a6dea714bb2a242e57f18a7e2336a09e67567aded5d63cd3de886f9571d13afac60b722a82947ae3b52afb7294a6f158f4358e787bee0006deb1fa600dba032518cca233ac4527b2a49b928cc885cc4de788fb4f5fb14dea2e07fffa6307ba61422ab76cebd96bd3c0f3eafb132d7b94feecfb0478349caaeaa89f2483562be71d39945c5f6113399bbd00ba18667ac6fbee312c7b8625b24486b39f95d82777eb93a4a7193e3947f4f31e58371c95fecf706a8e1e0736ea7daeab6a839df6e93071513f1a40586d9500ebddb30bb2249ee0a85d462ace071b0f2e527d96c4680c3bc43094453ba8e920d8343729efc4a096472ea902c8a7004444bb5875f2bb11168c038d3cc16839ace58a4c18557701c274355f5ffef5221be7cd6a9f7ea2a35afc4137960afc3f99b55e945d490d85c2b4bf53c91f0c4a837f010736af325f44bf1e774128d7f9ad9fd123ddfc071135c2ed2e9bc60677e190ef8edfb0a8781e5500f5d038c119a11277a6196beaf29ec855c0cd08a1f4d65474ec59c89773e83ab7cd59c516d9a34c66f06fda4a868ebaf7c4a9fae63c22208989adbdf19f6a63d1cc7c7c01c95501f75f16183b08408858fe3210d02c9a2c5daa9e78ac8865d404093abcaffd79fb5a9b955047d6b164be0c10f8364257f0b8d9005245970b125b6519cef5f1787388379c6c527684fabd057b4dc3ce186c5f96fd5d2a73b86ab5fb8e15f6deb609a5db2dea5156e10e9b7dabedbd13cc0adcea484ec6ab6b33de1c080859696b255f0fb860fc4713c239c212b5f79c3a6ba0cba57afac770af9ba612fd9babba6cdd81754da11487c67087e19c1423550a4b75399f30c53b15fcc75c90e3d1ccab73818a0a311c42ef6cd00228deb83c0cf5d363029c957b5b59889908d5ec1b3d2995f739d934d1e9f724d44f54d0cf149c9f7139fc473f7f4dc98bb5cf0f0982ab3946c3b1be075028f5aa1563458042351f6b4ee454c49aaff88955ca70964eb9a6bc3e973b6bd259ff9e4e5dc1cd2b021386fc114f9cdfb177f2bb0dea83e5644968a605276d867cba543a035dfccb1719a1cfc35bcd109b1235fef3af1e8a61f6b42d8a8f100b114c76faa29060bf39bd20903065562c8c200326f43d3e31e2b7d39a3a434214d5777cffbf8e49fc14d14a6b522dcbdffa8ed07cae4789ed9db3348aac4769b7403a26dd6014e5ac322c85592b672ba87b514cdd74c3e9c77aaa1729da387b5e5d2733fdf03a4698e9edaaa832a0971e96284b1fb2a6db096e018e08d59fbc3367c89707214bee40355c2df809200316690c632a243154c3474c65476bce2cf18ff12a644ce44f81c0e6774dfd10aa2ae70cf03d234f67d7957dd51bc8ab1964c787fee6653cf6e7016a0db8a7fdc65a92bec54ab8ebaa246cc9894da46c29f683f6bdc3ef865e75481d6ff1575a53c6de777c75f68398e197a0afc3b7ee4073b6b1cb295bb07e407ddd60f88bc32d9cbfb8a2ae3fa2874d65e8bd3ce096949efe1c249e7c748278de3bf80fe70dacb8baaf34ef8052f790f95e125d5e3847fd03b8e19da9de9dce8c81b14337a67e5fedee1e73021a8b9f51d371ebeef2202f0b52ec4407b37ba5a9949f88652469fe0a9e88f39f1833932ae3b60229280520418352688bba37496ab811679c09a1a5d809b4a351219aaedfa22ac79bda0b6fa4c52023abafbc5e2bf3bdf0ef5a64744c78190b8479b730a2856029ab339fc17d065ab6367286a201c4c0c98a467ba6c795976db9a12424b118b742221e1977ec68352f180759ecc6f1aa82caf55ac331b5067aae294d99153f947d1e59031ac9f1986fb11fc56ca1f4d64c6596c86fce61324d046db533d0a8363bb39fb6ab0a2cf0f021042640db91078e2254733f71730656497b3200f76d3924fdaaba509d7799d217e0f722d376ac0d3e3dda510294b4d75c50a8a1e0b16da75ed5f7a466e42dcef4d75c3c1473c4c9222721f9df53d6846ae5c89a4c30b20a5c537db91d90e89ae223214f8858354db2fc0cf6f1fd9932b96221afe8288e53420f83483ffb21b8ad04ce3fff4e9919907174b43410a37f139cc250feb99dd8ebad823946d75289bb2bf86c57ddd50338ed33098eadd3241926c782ddca127ccc7d685e6facea6be142429bde4e0ad83257cdd074bb23e456efa8167e0b2bf2bcb3b36bae8e9fb946ebc8dfe053b199ffbeb6e979620bf1afc84e6450bb45a73524db4cccb93220bcc273d49ad05f85c6b56f8ac5917631667cf4d3521aea9e0839bae2fe27421b9716d89de1616fe7423805a90d66b76eb2d92465f0f34e7bc8c100d1c50705ff8fc91bf9becc402cc3c17956de6e300c0689315aaf92ff286b2df9d922cf009fb82069ddc53569066e6b1c25308f44e6947ee8ac6fc98ebcecd5342f6e1ecf532c2096526541f77159fe26c6d4f1ed745c245470c8e2d04aa286d105c12d14566fcd576281b281ed41f941119ac2eb577160baed257404f1b2e5c06c3fa08a7de49a22bb683c4a5c01f25f91ac6cfb9850e2783605c2ead5991d7e7ddc308855a152dec0017daaee4e96386afe12757d7114be9a4f29efb3c046df0e19b41e39bafdb46486de5048e26fd758cf70984400102848bfcb8a64f3499a80d51fd66def20e0d1f26b2eaa68305ea3684abddd108975072688ff2666f3f32493dd235f8f82d0cbde9756e7358e26348f31e063cae1ca993ef8715fe5f5f9049cb30f76a8eb11ecc9115ca03309e6186e7da64019f2d69b91c5defff462cacf02cdc4629f01ea12fe047babf7f935796646975c5edbe7c2dfc4ce9befdfc56f90307958d98bd76a26bea2fd55d415c45dbc9dfbad88d6de432e459bf2195a2753bb52d851f912e83c77192a3f164a87f25f60012188153944bd1194781722c937847817af20e2d4a03e9ebdcbdae81320aef4a32a76c39939a600e5a1c0bf8c24e9a92868e63e4b274057540796525a9ad48abd2284d4a56d43b1064944abe3dfe57245762aa99ebb1c037b3711879e24c0521b652acaf137217d02bedb0c4f7e224b219f188bb545ae2b038a4b01e6fb9b57fdddf147be6a11e3ae5d0b4e72cf45f8c96fa8f8ce1284653b6f7e19911da3b861d855e014ab42c442cfa8d4ebd522df85a85dbf7ca66e8515ee91d3412f597920d4979d74e3ab5849e31e6e0c95013f91ddea477c278c75d81db2d716740a3c42f1e39efdbdfad92fc8332c7ddfb6808fcb69ef4913d193e42f52a66b9b3e31299111dc85a92fe90d3b7c631827a7a9f06beb507a6d8b1d1dc4e3be9b3eae3f14e4c001185e3d4139cfb16eec369c80d4d1c537f6eb20113dd82ac635b8e23b5fabe93c2f052e4f9e3bb466975a6528a1c19fba0dba1a0dab575218fbf4e4c2fe60ab4be7a1a9eb9ba092f5d824b7ecac931fb9b44f78fd36e666d0cfc19d93288408076f8ade405b83466310f57c44ac8004c7d497b2749a033b866d82854bf909c360d5eff5bc50e20506e629944edf256017e583057267826c48f518ee9651ddca02d973c5772d642657834785a3bf4c530e3e5360404a779e8ce3bfa7e9676eff57a094c32b7d0b68db8bffee3450c94186a2212c6df97a72566ccdf11df30e06e61b39870a5324589f3f1c857b4037e81ce9bdcb9e58f976df20d60437fdeb45773579eb5ce997ea60f72df546d1534a240dcb48ff41a89cc6f699cbc3629b9329c8e8d1b82439ed496440b20df242f98b913da631c937bbdfba862ad9cc567565bb2bcd294bf6c3fecd29acd01faa2bdc9557587720fea0d4b2f7186b6271f01b5f326e0edf213bb47f3289295f3fb070e3760fa1c86727f512aea3b6d2a60350c56ad684265bd07e89f3d184e4c1eb10398d2ccc179efea33128415c608ceae9fa11e1c48412d6d53ad30050a5b7f5f3026632f423fb9b003c8347fbac1368090265cd48b8ff6960aa1ce50497c13c9517321fb6ccde59bfe9064c8fea0a6b10026a38df60382aa0f3e41b31ce05d9d756a26acd0c492bddba082b6d75774c03970b751d0ec8a015ccf042ea8e13301c7463ed9e6288b35bb566adf002dbe9ef4e877911212cfac7be4f2f13b19e3d927ae7328a9f556933ee1c144d1a78e00f059ef79cdb73e73a19b5411e2bdf645b28233976cb5f5725f253eb853d7c15d958af370661424aaa139c80c07479a0ce509d9c99ae6a6a8de9ef4386cc34691c7eb2ac04b7cfb9814f6550c01355723717b7d6cb18e803b7598b9f7e1e3cce93e0d549b325fb73d525a69654a6522a9c76c46fd5682b197b332f7a303dcafcd9f986e9b435d39da1722823ee221ae127a6471fed0cac1d1121c0ea9b5318986be0e22738b75db2a6f955350b32a9244c4824a56a43eed99498ff67da9a40228c51b3b6be2c23bf4a84d8f324d18e08a7778d7c8bf11dd2adf48b95f3ca5c974e955e3f6ec582c4f3c2bcdf92d2aca4580ac586d5dd229041a44d3b7a4dd389091e60e6e995c7d72266e8ec4cd7c35514467b3b452575b4d2cc36a84074a824b7f460649da6578d3a8b84a73c3b921336812489119c6cf089451782825bbe138ecff2ebce1b3b7d83d79d30fc46735bde6a9d61ad3dfa326742fbc8f7e52ce2181cbfef120b9ada2ed59d7a14568f691fc6acc21ceb140c2f24569e8c5ac8043680c01129bfc292d4992019515cac5e3240ddfa434386bd965a2e22504236c4384b550ed893fd0df2839150a94174a307451764c2e201a7934b07c7761c3e47808975da6a879aae178095ab7e0ebb04062aa4aa84e39de257e31e7785cdbeb88a7dbf1a8ef30915185557bd41e27969bf70010d4fc74aaa578f08b75c10f5f3c523df2682d12d875fcf603e0c0ade418c84c5b10231165239ca322617af42ea309d79770d379eb44909ba4080edae111244bcf29baeae0dd58a65b52b5ddc37960e8e86494c20952ccdc8568321cd5c0214d2f93268fe02ca378be542dd6e71afd18a9cc2dd50b83161d7fae9496d790ffd4847721137a0f38047f79fe986cfae755fa0defa39174ed80f8e437499d0511f1deda2baf496f5c7cde31546aa02a574265fa56107773b911211a7099cb5630a43d770a55a84ea5cdf059422bdd1cf5e93825cede4e84e3e605a35f982b5a68b1188d19580834d899af290e1f26d2afd1ff621430f9656f4d38e1fa2667de905c5df0c2a25094d9d4d585cb87e3b3445d344baad3aabffb2b67505bee6c91c27efa6546f778ebff36a8064bf2442e81650d3f7d9e2e285e21a4247b55b4d1ab38203c20e982e99859021eccf682d1d6f2af067145ea702fd0f685ece9ac950681ddd89d0e312fe8259c234968daa8b560f6e7466ebebd5efa434dec1d4ad0b0b94d3f2cf85328aad6609948c158b32b3513700327664f58c1edb6b2f669ec956f6d3a421f1abf4e4929de2a2ac379fd0da111db2e209ebd5183d0d5aa48e0d4d383fdb7b86fd5c493b8f8fc12f7e1b72ce0617387833208f87a5cb9ae31f04f1746da4c9bb1e0694388533ea4cb0bca45b9bac904eaceff1e855140304b666cb5f6780fd72c81954eb353527491bc2553a2ac954d14914e44576fbc5ca5272d0be42f4375fd812c14014bd81b192dab55fb4744cc2cb7156b923851129d17f3b76a0588d6b6b81268487d9eab6a03d433cff9837832de3e8b9c4174e99520c3c77430a13a70462777fcf812ea8581ed2c12ad4dcda017cd7f5a45028a8d11f77b53c3fd72bf35fffc795c0b9594076ad5c71224278a667efb544db6cd90e9c4ced56ca35d6eb6e993f1dbf9ed8ae905328bdda7a00340148e6b527e7d99c79c24361378df72d97158626d1b9f3b50d24318f4bd318ffabd529bf7d771dd48fbed0154a0e0a7270695a079f568dcc5c3c0e3f217e11ed381b8a9cb0b032ac95c9fd41346cd9b020410dc7f3dd4c75c013d2a117aaad6ecaddbf0b01016f6d9cb47cebf6bbf8465208510ebb3bbcae5b3d5488b15f8b49d1af60f6ec11cba462af4b4ebeb9d7cbcd147ec6b4dcf7276461fcbc9ec2e6f2cab14d468b85daf9ae1b615be5fe680d00d006af17b20ac5f5427d3ab1037aff5d572942042d74a02783f7bbcfe7420f1daa13bb779838e415117af22b5ca26d6a9926fc28b95ffe7f4de6e62f74e2a6b182a669d5321cc9be7dfd9390e4cdb73ea90e14f3481b2f4e1e31d23ee7175ee2e60a798e49b3953ef21d0d3b9119b44b7999ad9be7d31d63d032dec2bf40b2a4a01f1ac6298a4d63df7f7585ebf5d118bdfbd6b548bf73d008124d656c1333bbfd88c34d6821bf6e0e64f6cceb391d6840d0077fc92d974cde5267ef936921767965de8dd80afee95ede4da85e24d2f2bfa3847ed4941068c9d3049ea9d61a0b0e8e06b6b7521f462a1dc54baea7b1b21500a007e518f156e1d268ce1851c1ceb728fea1425b623381f47b514797541f062633f3c04ffc565b8885a7df16527f85c3821386240530b57fbdc8c8b73e42560219cf3b4ddc6909d36cc0d1289414be6dafb5a3a87f19835c5c2af8c21f0b8d26a2e925befe68e67f3a85bab87da4fba1d377c3973bdcfd019a00efa86af5eec15802b4ebcfdc8801129a78c56172e8b190ae8025a107b156008f7f50e267397c541d608f1be5bf6090b8bb52d3d5b26560d8a4411e7463e9b5eca8c362497eaa594752742801b6790489b79f094bca64a41cf8873988b02e13a64991badacbdc13b96dc2379362ac3669ad6f2605fce9cc84919061b394299ee80a9dc4e5da963dfe2d54d9e6a3fa846b276808578549ccd412e9cbe89ee9bdc3d03f86f4875cdf1cfa6d9b9b6d4c43b113c9a2931d6f1348dab2274407e3454bd092f95c1c822c713e906d3ea639036ed79d71506f4c24cca2f81f0b35d1fac1f17bff3531f700bd76cf1251a20b24936319f99bc95fd0f64923d0dea6978f5f71a88078bf5c6e00a0873627ff26b0e3255d4cb7978c27793173c1b026e500a9b1484ea042c100b930985c217a9c55233bfc50074ba742dc2a96c5ae0157ddd138c8257a7dcdee98516c15d551e473e51218ff73a034d3814fb52a12dcabfbcb3f13f042c38496fbb34212629aab6b126d8c43c3bf98f248ae29c289966e988d7240c64a852eaf0c846fcf47c7a9b9a32c36b0bfb3ec9b33b0ce3c6fb1ba078ae3bf1a32496da7d338eafc528f8e2d1065cc3ce1e3d59ac38b958965837bd84f722a83b44f031533aa065b51c0fbbc3d764590250e441b319d52d96f4a6e36f8855d8bc185a9a551a849d13ab8838c75635896d279a338fbeac691a6582268f444cba2f7a18fdc5f8ae3154ec3c9bb52e74c708c569f9c8e59c0f340a5d76eb5443f3cb9718bb51cc370c297c4fdbb151d6d83043b66bb9536b87eea8e067adf6fef44262fedca792ef2a1cf81e7a088627e67d71c0895ab1b875f4db1097e5c6fd36efc7fd6bef1c5ccb56c9d8c99003630870f0672ff975e900f11ae97f673820fc7a85a8d62b453d065a7585a24d35752c10270bf9a1d53e54a6b08da65f62128d31b722b3f66e4520ea412b4fd3fab8013efd3dd79168cdb3a3055a88e9e0672dbae516803d716f51d3489f2637304edf3c65756a48e777111dd2306a173029cada46ad6ac6ad22f6322d71f6f53290b2fd5e0c8a2f20a3b20faa396c49f6713b9b623673b0f5ee42c43746e493652ece4a29e7a5f4fcbbfd4c7c7caa36bc089276063f725298cc43c19a79f00043a00622485e1bf0c47787858b0f14dcf6e41e1caa2649ef7b2c81666ca77e0021e6bb7f7182d20642868f9a96561b53c4dbff563e1cd72e225fb64063513a55808d6c217caa227094815b822027771820919c0343bec5c1cda40589cf1136c5fddcf5bb0785d53a0c40847094af58188fba7bd4601a8d18df16015de094a0e206538e12ed809eeaf954ac9967490bc03aec92d3cdc56dd57662082b09af5747f799bea8c3d0c3a57c7f5c0b7a001c72afb34e10b241cff45cd157015f9430028b564ade564ad0a1c26a25e66d5081ffa00ecd070225f1da7fbc00feaf0448809573fd72450c17ed66b5fc96cd9d9e6881049107dd0efb22dd1eaf8c5be67be51893ac7b7e67e421f46ffe249d68647fd577c425dc2ef9fa3959375d214ac87e712c88ec67efbe4717a3935f7030e0c84869e20652e11910adb7f725472794bc615ee7508920b0ef147ade0dc147ac6ef721e213f8f0919845bb62609f8876102aa4009f9a3607fc10228ab0232e5fd226a5d8b2a0ec940035fdbb2b56cb68464500447cacb3c2e02c1665baf7f8fd9adfc831e00b92b9ad0f650d1c4d6d7468f1cfa8feb8de0e28498b917e363077e74e130a6acdeecd5498e23d81175b57bc70214a8834e87b9101b5ae5bd2216d4331d3b71db219ea82c6ff31522459e1f103720dee8ffb6d52f785fa7eacd8021788f3eaf3dad7ad698843b4bfa7b081232eb02e6116e0446d5a93ad7998a5db816abd8d9dd3fbb66627fdd39b5092b63d9e016ac36b4e53ec24267acecee211a3ac95e0366af3710d989b21b4b60f412d2c640b14bd77d4413914fcfe13c8b86b297d4165ae71a3416f80e4677499ef38a51c8abe40a37d4180c2972b79405de54a05740d27309f51817deaf744da19be3f01f9436f26368cc09563f6ee9d6a3a55fab8ff1d49cd166232a11b29b5add9e52cd6a417c867fb7fe12bc8e7a4bded2acb3b9ad588c7ba17f3f631c45214e7d6513f5f9ef6614fd0f9b9dd41dd67cbd8a91edf627078bf37679ef5b07f959e4ad7d9148d36af131e00766ff9e35a364fc1f554a1cd0acc21e08e6536ab3c28b2174541dc3b0c14e2fa56e63496d4ec73e025fd5d3d40077b034db8215bff7b4654e109a4c408c3b7b47c4ae8d6b090a67d537a18b8d7f843becde9f78d937e8f5fdfd32f1c5d9673c009dd0911303aef293d7eea067924a8f445fd93336db9f68bbadd7d8ea10111364a6fd2d25b80ed1aa04af0a59fd3c4ae211f4de74bf13e0d754ee6d490c4fa12a2bf8d7de84e377222f3a14704b5fd20e9f3ae4c2522c75b6b759135bede3378512a45726c6fec9a7703d2c005e986690d0b73ca8d908834569ccc42e5187008b67b07b442e253fe33b93b1eaddd0a1c4c617fad16dce4e65eea6022fb57de4628676382d31ab3795755d20e9ee6a9b1ec3d3c85ef472ccaa4e25836cc09ecdcbcbc9e8507ef26e791f12c87e0842248b2b8d20c8da92ccaee13fb5ed7990fa77f3cd6f001bfb0cacaff5a859eb6e1b754713d2ddcb236219298c4cec7078a5076667e523f71160248150b355ad5424d2911a777e6d40d1a4ecfae44485428cdb87f8e5449801603c5a765b28e6e932235d526347364b5d3c96774ff015718331b14e3ea25424a9bea2fedd7a11ca48387918499b3d5f9ebb25dd92b41c27eb5804d047958757f24bd3b3a8735e3086ac3270edf2a44906627a520aded8c7c07eb426040acb89da9c8fbe4afe8a64c2fac042e2c8d1326d100e444bcbc22b61702e793acb83763bed0892a478f75f4f9192837b71d24883d8a95c7213494202b8b71536466800b084b6a9ed1de492b50e2e071f40bd4fc987f0e06c26af17491aea04fe5bea9b283f5d4902acd091841079736c7606141862279a8a6eb5bda115534bf04f35c8dc621e136234d30e48298cefb056b23f49783d0712a4c6fd74de60c5b6d708d45abd68ba390b68661ec2eeb769447670d8d4e0063505833746a66ee94448dea44ce11d34d30af122718c37b5ec62bc148706468de8bf41c35f9ba54f20a8b139fdccfad6b67e019a868e47f8d7774a6abdc015a404a5560a8b77420337511077505fa6de0f5e12012db3d4a7f8fa630f162fbcc9529499c220ff961bf1f43c33c0ed652b0bb5303892a9f00829b9b8fb6cde348e0913a468b604c40f8d20caf6eec3548b014f7f297c38c4a23ee681b0274f537b24759d3f8407db0244b1ddb5bfd62986a26953c65025e22c88e29c223b6cc8c0ef3a30e71bd3bf18c76a54148e1ffc170cf62332d188f1484fdf903e25289aaa0cbf4f14f8e87b4b445352bd40540cbf00bd03a4d271be8556e29d7b181159cb4a5a920323611ed23e7e837dca360b26bf3eb1bc9a757b86285053b9cc0475004a50f536b068c65c24cd7a46d09290ae96909e7e4a24929051b82e0a58bd651d878f56133bb3e4807370051d5723a2d1e4a15a6a3fabbac13b76dde2516e967b096859bfd4ca08b7412d615c95b664f3983736ff8326368ac6efaecd7a61c55875b723d16a82b34bbdb94f5b6cc9dd7fee2144046c09fbcac7f7b36c826d6742edcf72798fd9cc93dacc3f4ff9bd2aa2f5825617d114f6a9f5b372764037e5d79e5806aa5d17cdd5f21b786f7007f8120c50524a6eb9b1acbd794cdafc0788252d3eace07bdec1ebaa780c517d451e15d457e4f845edd0cfb10136a380dd02ae4684192187e56526b6a26bb3b112b63a7a24d71ce4bb896fba202f807ba38374ad6cc51c447345c4d1209f4ed5888220d3f962606725d5c1f2544bf1c3b7e081033b2bb5bf04dbca5ff79788175edcb2944af92554bb9cff33b8e977d2f2c57ba0990816113b5d44742f0fb4e9b4b9f5127e46aa3d6e944c30553fc1000013e77afb46c168d43488f0876565b1cbfc01e62d3d7886a5434784f6ad9bc674d2ad9428f50945fb249e77cb93418aa8426a24ffefd82c319ca55d3a47ae8f0eae9ec381e7c364600f11786eaf03db40ed7598f01294a465876030c58aec4337f2f8d5adcff1ddd52c4d69bf9492553614e016cccaea30ee5746fbae47b74b6d2c4fc24bee4cd6dc6b4343c3b0b0bec51f0d4373ebff487258c2e7bc5d548eb6e9ba16b41fbf2f88a9f67137016ff203f7acdff06b14be24702fa945264cc47a5db38c9bf7e40606d3021d4a0ea983140170434439e71b6adf6504879507dc7b399d7d5ed06c106f7d04fe0eade04869b32048f1f88b14e762d93ed62bcd7cc90573263df4a1273783816c15c451e404aed571ba939a90b541901b5b841ec3eb4c326a92c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
