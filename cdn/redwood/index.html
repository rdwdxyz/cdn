<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22ea7dbaaa22b827a1f70dcfc9f3ee73301ed19e8aefe8a4b5179938329d603d5958724cdd6b6a33db416ca3df0d8dd85cd876908b00f1fab593a250be582fd8e37979995812caff63f2132fc45fae3111f7de1785d12a809786968d51eb5a83d16e9fa86e7b3dde8122517c0cf287a0cfaffd11a3c7fb98487fd903e8609a9c51d120948e13e497a6b639e7010fd0e859a41cc55cba63053cde3e61022363c47c6bdad7ac07b9b8869663d57640604ef7418ec177c03f2df1a303be9b7243dda3f89dda70bea71d94e89bbb0258fc425af45126e4fb86f5ca16c7ee65eb42740be5c7466846e4893d8eb2ed6649dbfe95c30d16b42ad7fbada16b2be41705636a72e5d268188113eb622a76bafdedce0c9c0dd29638442af4dc54795b11f699d808894a8b7fda9139c07d6c500e3d25e5f77b9106f2014c4df80e6c4e59850bf40dce0b1b74782606924ad7846f4a2f69a99496d6f81dc576836aeabbcfd3a7db7cc983f728e5960e04bb124f5a8afb89e7d30139dea54ad725c123fb30fcb9eaf362404b7d15c15a27e9e10afe7e76338d8d0ca86ce445173206312e959688fb6c2e929dca04730f50c69489a2ba12e465aad6edf324f4dfa5d7bc0c8d898399dd15d2a643cf5e05ed86a21a12f57706030bf51ddce7a6ac3262d640d0b3837ebcdc597de4439aacd6bb8d4cf80f23a731376c7402b7679a3939852b5bc9e658791e61e3052ccd0f4f5a389c732d5138fd2e897ecdf356648a7326a5bdadd7807160a2839ed0294b66284a60a0bae7f90d9e54d0289f1b2feb5424a51b5b1513b5be0baeb386264a9ff77b48e7c0e5d6182f58350e5428db4d0aafc3052ac12b58a24ac1b36b150665fe3db14652efe246de8682bce904c69e3205434644db5fbd0c0dbf89edfd268ea1e672644dbb0dcdaf6cc5f15309b3035b444162f09168f75986ba863fd9254469a636cdc4703d0c77e203ad74b7dc3b14b769880ad5a550b47e76584af3ad5a74e3f75ef7c1e541cd7c486640cb517cf9a106824cb7c8773a3eb76303256fa7784051acd6a9e9ce72f925daf17204a4ed86c7e91ee2675c0f6bcd0ca828bc3abdf7a4efd6ce98b46d3a9554e0ff0a0465242d69d1a0b5ccb5e0b4efa96892fd4a3ddca507c3467326acea9a0a0ce46f808451d95aa569c2bcfcb0bfe8045eaf646c67e5a51df6323d56ca9505485ff7fd733817c7188bfa3a874914ead04c6a5f20b7b1c0e93b38503107dc19008479f2794ac1de2b7f4bd3b20b41f3703ea4b7ddc3f432190a6c11a141655fa60d355f530077122a2b67d7e9714ba72d77633d53a08a562520d9dd2bafef04aa9f7b0b003e5731d8498f7f42fa6980a91d96a066ef34b00273aad102f56ceffdad7ff4e311c7810b9c8a39e81c70ebc4541f0c3678d8e36c45c3bca14c47773f703306e0af3ef0b4fe819464717704597cd67d7b8cb70f2986c650406196861f125f7fc1e0406e2c568c38504aa60932ccd1f66fcef0c66dfaf8a29bacb7a3626527e590c382d3d88280b707ab1056e0a97ecf59ddaa89aef0b6a886f3fbb2066d7082b18395d2707c62b636fac14f61628a658b6fbdae87c7a63cdac593e9df0e028dd0fdfad0ba87bc1d4534554782510dad72b2b6f347cb61e31e2cd81af08f8151c8dafa681b20cbd25889a5b83d9b0fa0af060b8f474d8b3e2261323359db55409e1cf69df877518273fb0b53dad6ef56303363938fc47fb310f4e46df6c4402631866e02b84c9d1762f54871db0e6bb59812bb92e2391accc5294743c12e970aed44fb97c168627642d901b63af3a011cf5d0eeb68f46c6437260ac8973350855639d7e304281ba005a2b6dea26f25fe4a01228e92d341cc2be5288b2ef80c121f168c18802bb8ff17cd9808f3fca8b4d01f24fd4d4c6e802c7a1a6dfb8d958bf5f666007bb3317616e39506ff1705f04722afa5f3d9a30cf9540009515845259bb5b6bfd101cc83bae93edc27f95078076ee1cece2da3698a11e28126bfa82abae2452e210fdfcfdfd7b11044454ff80cbae2a32ec8faaff721f441a3ccfb4ed21a2db3ab1fb15b638b654f2b4738ab5ab08023cea7347aced5cd41fe95150d170e7ba98d7c3184884afa190685e406643ce3b95ffb457d328b8effb3872ef4ce61c7c725b9c44bd6807e8d525acc94f4156a316d59a44a3b8f433fced19972b728107d422cfdd53df23710e847ca94836b6db478388ffece265833f3a21ed2c36c42e4130b8d96edc7b712a34598754e0b6fc86bd65de7046f0b9f69042bb35d5c02453b69ea43858b759267bc22769f6e449a789e4f82608594d7615a731c0803396894f8b0cefc83143cf0ce27b277160f02488b93b8df150b090464e6dc18b53e77b90afe283095830d2cf772937470eda9eb3e67ced913262e4b59b57605243167b50062730cf8ac45580ccaf80d33929701f55d9e225f02af6195a289017efe0aee5129f634c27c8d31cdffe7997cf1c426bf2c883b5c73d6458ead28a48e6283929afce27c60d0add65857101cdb82ce01677b58e7c3dd7e3e91281621ab95f0a3df39363632720df5a5beaca8b870495a0b2b8f1b1906f0d84ef6d4ca758468455773e146e0a76f68500b3487dcf4a053eff93c2e635ae7237852fdf23992c19d05f40dcf93ca2bc2f7455d197253bf3ebe4d3b86bdb7edb505e716af4e72d5b384b7d3f9c3818ed0e8f0d1a8aaa4750459867485fa0a1b4920c5909e5c771d03bf18f03801fee0773cf54784bd9f48188905d032f61427718cb566736d9265dba04fd7463ba127a5769aeb352de63616dc0bf3147f35c0d392ae97f814f96b4eebd2afdbf5d005460586b56d458848d4670093a080f8d950e04f4787bd020892abf9605fb547b6e821d047f458aa0ac717f2a38768100d5a6c321c6a037be95f58eb010da6f2686ce4c95ca18ddf400730494e13f519d81b28e00a1fe09cc16ce32aa936a577306ffb62ebd6ceab5626a910fe3663914c24b3c3d43eab50c1334ff5be1f5c83930f88aff1c78d763fef2092348abb7d7a93e4f21daccdd305d616f5a3b55d4daa7ee5e577b2c443cdc6e02eec5a7989f8f5d9814af311a56decb65b51f2392862c31694ecba93f1039e2e090ae9bed203c3770fee0bff1246425d0e1a0515fa6e0e9cf8dddfd39cde9ae96addd4ac7fc7b95f75a5425d9ce86100d2a38ebc0ed430753a0b788623aa51e943a895bbae4a158f8caa35111d992f42be799a00a73b164002aa11340cea9cd0bf262fc19a71f1890bcaeed94b3b7198bb1a3cad98531b03205e3f473e188e276061789a5f4a4d248593af1f6f6f1041d9948d6674a56cf840d53f6162e06e3197a7e44a1a038cd93999b5613cb80a67df87a9314352d54d3f229bd39df1f2ace4bcc55684338b54f1b7bd7e5b8c0610bdf4d220595f94e9340c287a8a60b441638c43d0d4c97dcd949a3a9f150d87a2cb441fe49adf3c562bf8b4f04c018fce4ecb545c6f9c9ed75d11da045721fcaa0d834b3633e0032b1e713ddadbe21b690186845174acdb7618059b65243771e49ebaf05bae811a0af410799f9fcd4d7c522132c4ca5847a3a9374defd099b2c6a00f2259893f877f36355850eb1facf15dffe8b79a8ba0d0b8432ffb07f450b5b3eabb4199c4e0f91dd5c50be12d6033c3170ffeb03c50e9a008a4dcfe86bd4682b7e27d5e7779eef1845d1b023814030d71452ac85665a4e430ab276ed39cb8b3942933be7c6e32d50a7292c85275c34c609706b7b3efcf828cb2b398d442418e85cd51733a4b7c71a96c0169db75299303ed16ef686b9de4be9ab9a003b785a141f7fae20d8f18bb808be86f40cf153f047a6606d6ea404de2c77f3de3fe5fba141ba8863a68da69e3e4bb7a430c0874220ae61b4d55d253bdcc748624b09cfd94da93c992d2b19f34fd33e7a959d4e7fad1fb12ef01d3ad39ce40e8cf56899db468b002034c2376a3f59c8d39972c3e53a300b5b8b0a3b1f79d4ba1ccb98fe556ac855ebd049a3fbb7ad979417539238e6447216de52c1f1bc1f25ea162cc8a056b083700b4fb449114777cad2445acf16178eb30e36cb8910046f257f84455ca7e35baa3c4b87494e14d971f3dba43a2792bb3d6bc90ce76a69649f1f8f243e4279c0854c908cfaba9319fd74e30cb9ea69075eaf8b4ba72be679e571b173b38aa5c1ee7989061184623957f7d15f6b0989ac818d878bf366715389fabf9c0e027ebd789f75c42cf343e0eaf687e0c750558b6dc3422ba5bca6855fa254cf195198536b3fdeec1e461d858fa8f32f4708782007a08225d74cf622c4dcfda7936597df06bae0b7f57a3a7b4bec4c55e7d914febf1ebc7a97e3cfc19d11f7f9ac41463711a4e6c0367409f036cc28d0d06fdd2e8a8708764e5762ff36fdb7aafcf570ff9a9c90494c0b94eddd2d4dec99449456ec54aeb686b02b6605addcc6942152bd5d8ad9f287035843a8d9c00c31e04a0d3df8575edb1e310d993f4b26ae6e7a105b649bf600560889a4f3a403027b7a08df856c31c8acfbd6181589987ddc1add1c1dfe393ffe3d7d4bf9456370e02e18d839bdf0fbafe093c3adc13d2de144e63afacfa4dced5742a96ac3422ffd4b6e64afc12cc7ebeeba8d6d1fd680fd8b0e22dec490c8a6b41a404beb65486627c41f03dfeceeaaf617952fc5df415b22468baac48a15edd97c860c52b879543e32f56301b40dd0c2150f16acc08f2c29a6e104215dd24d01d6b25890289aef7f95907cb355d630a833f02d3097416ad6e9238349cd4065160772d34bc3345d0988d070d577ad1aae04df4e77b267d3f1170c57345aa6c95863a93d61d76ffb37c628220aa0c4044aa413486e576f8f70c65e885e7e1ef0aff25f649b1bd795973baef7c2a6ffd6c8936d2d1a35d443866ef23b8d5a31ca0b65d57cc6236ee6924ef5a917124b615bb128782c3bb111b19059bc3fdb68a8cfab45e54c9925286b6be886de4fe0890188562855464018982595c05a083b7225bbbf8fb853f85da6a36ebc0ae26aaf77c1c3d1abce2d56695212468244d23f661a7cee4f7d2c4a607a2ab9846e63ff353970216d59b64d7f225f9de8af6447cce6eecd38bfa08546b54c0b623f47dc971deefaac605153dedaf2a315eb72e9e2ff2f1edb0b9488028ff026a98a1848efd539a20cb0ede3d29f6155eb4265389ef135341bb6085d05dc0bfb0cff8ef52e0340f2853f9a69d0ccc4cfb7d099217c1ea48c05eb29ec9ec3635db9a91da515460f693eebac6f472611415d9acaabf49ea855ec16becd0ba78fb04c0e90c30f34aa4c6ccd628a431e612cf58c077a991335497740f9eb5c8f7d99befae73f4cfd8803abc9be34b268f57e4ecbd747baa7fea3488dea5990a8e5aaacfa3f1aa27002f4188c3348c8c7ee286a44926ef6b25cedd342ef67746ce699865ced06c1aad1319ef2221376dd2fcf08432fbd9b8f011e7875057a69e212ef3d955362f4234f420895947353cce31c977cc932d25a4e8cd139712c8479aae7723808ebbd18634d8abac3936a95ad970b7d3a4c73924fe9a577acc391416e13649335dc24d13f10247eca28a40dcb5c6ca33dda78dcc51affeac5d1486ba38a5678a6d47b272489decc722d7c21b94e382da096214e3f6ea124257a9ac3e99e6edab9fcc24c6a0da3d57220fabd1d1478056317a879e50e1213295ff403e8ad4a9e0c35f64672247631b1a9ee703c6421a39c63528f1bcb1d3e0e21f144a793f26b62527b23e532278941cec26c7a11b24af24229de4814f2af2da097ea9ea27203f5e57f50f2fade015c2eef6c827596ac293e30cac9b8ca733216e9cb764f120139a623f403866e48120ba330f47f05bd9071877d66fc899084ba5290e9491ae452147f0c3de9bcf95795ced6634641bfd03ba9a771bc2293a6e9a7cf9ef6d27a813b4104ae9c81e81657302c3e6c91b6750e464dc62d2cff540b6b2b3026a663d81b4068c6645797b256d18edda7205c8d06fe6f7558e88f70f156e3b2a7abed926cb522a571de61c3e1c166653124de4af8055836b304a6baaeb8f8dcdc63a3f49e7672d062264c346d3a3d3071e15eef4150cfd16eb39abcdef4377d7a7b174304a6e8ee87d80c1aeab55161f667142259d8393bc1ba778ee93d1b1fbfbf56ae8614fd47253a19d93894869c413d917a3754943e41525422dc2fd53b1c928ab7cde6f35d9bfc8766191923e37fe1e4ba38e5d13e6d90eaa30df9fcbaa5708819dca3a2462d0833eb4ca68421ebc9a7972ef9fb6acb38397f8ea737afad2bad6dd7f9a810734ac3984e2492ea85718e9e78461fb3ed674f3cb9fe4ea25b1c4101964610715144f123c8869b09c9a78d3c8601e047aa80e911fa9edcefb42119be5aaf3000afa3f693b6a63c336d701e78eb50ab174c33a96d05a98bab700a825f89c1b8cd868bf644cef9709dc7e84859415eda153b1ce6ca2b0ba40422e1d74c452040b1dd98ac82930f96c10eff715e99db05d93d9b6ddf08953808332d85a42720abf59c2387264cc08c00d50f92534332e4d922f5616b98741910a8b6b66862058d2191af867e8276778655b6f99535869b0b440de8af410fd3a59db6ef465c600a8fcdebd754840f636d6da64e08c17e73db5bed5540a118ecbb66bc477a07c2255a38828663629aef2746a1c023e815f59e986b729947f3cba51bdf7d5c42c9badc543b309e8b596ae759d00e6ea86aa684088ec9880437d367ced9bb5ffb0cf1c8f6f2e6490201c61c1272ed022c51a5da27ef2a7b517106a67a15952b5dbfd70ecd601d52cec1e81ca11966d8101998d5f812b415f4f7a98ee2fab2702e1adda1047f986c5b0faa4fb4c9812401bca55b5ac83169ed3ff1e694e6a6f9469d75880363fe00773136b38ca7fad33953a25eb46240b34866734dac44265276b83e3efd37d7dfefe91440445c7c5342562ee7aefc2a03e33a236afab2eb1cacddab4d7e76c38e7b2ff1c6ee54fd3f035099a74ce5e9d476a7a831ff3e95be451fcc70598f136462b61d29d8b5d4a101f11bbe3863f33f9e25e00e29cdfe5fcc315a94caff1d824983d74f094c73cbc1e901b86f47b7435cbe791a14f5112b466549c49dc8f16e8d8ef9bab9d479c1c5596c7a7a648f90175bd19d1859dc70d42e2a50c9c2768ba5f6e6c76523658e6192900b48d7e0a36d00ad33e4b5c04222df75cab6eb828788a23e8647a5f18d603c711aa4ed0982ed9fb02ba63ca62105ee0cb5839d00e3dec3b5799e8a106c727f5ce5281987c96d2d95cdb6eaa759342183f1e8ed569a31ca279bab2196a9dbb65e7a6712086f8484bf3a192146afadd2e2b7a463cf201f35b11853e6b863f9e88a41c45f90ecf1ff040a0e107a8b18520777ec215cd4277841a900559bd338ed999dde6314d5108166ac96a8b384e3380326eabb63c93bb35105692c035c235d1bf26eb91728ed9037843b8620b9603d5e6a0b6bcc69bc8d681a0c06bae2fac44c129197d65b8f36a6add034db8efa4ec69f1430115ff6a8f9c1dcafb217930ec4affe08efe9d5340cecf8765126a66e7fd12114a77366e8a6bdf01aa90764d764c291e7286c0ae5a7914edc0e79119afc6f00325817814f2d1106e9dae973c6b0d953bbcf1dcf7c400aa3a63d7f18967e676398a74cfda34c5332b86f5d28f47ea0458c6a19cc60b01f107fa5d2e031d3e79ccac20e345356c0a268e91cee2c914ae46371a6aadd8460030248a556c0f36c70d22a07bc87cc5bb89c3c1355e4d8e6f6f6d13836de8f44bf5f4b50ce93e3a1b424c83f1c8a9a13fdd2f129e77a78b99a8db515b0e9c5ed1f4419f0a7abfa3a9a197bf353b641e3388d99890195352716841fd6f66ac08f725678141f2329554299a0151a07687463ccb78c2be2643699c68f6e595753ac8d6bfbfc03bdd986f82f9fa5a6a6195ff98eb262634f373c63e6a1237fc21c55a43d5465207598316302e735893171ac818c4ca04ce7c7cf1aea492bd7213044d17ce66a0fcbb3e0d3c1176165cc896b573c9d753e92d7984abd57ac7402d44bafc95fc4aca79b10e775f6930b22ae8799c5e284a260b0ae66caaab7287285558ccfa47c767729d212cb84a456e716e6885a8c318625881a381a519ce1e8bb443dd6e212a242a4c04b0104a7e25e985f61514e78c6ed6eba74034c76001d709bedab450c0ca075133abb339ca8477904e6a03d0103e639b790b8c306906c721dc6a46ff5fcdbbd1d96c9388a19c9467f2d714c676112cce29a0fbc777b55f6e9918741701c13942d4a8cf39ba7b0e023accf0d00eb034248a9a84212cd11aa414be158fc782b80c5d5f8c48c9caaa6829b269e3cde3d51b59aed7aafea26e4739cadb1cbf3909309021e9018ce95dbbccf18be39e31ba4ff7f2bd6a10f05b2f4276b2632a409272c2094d691d35e6dc4027f60ccc1607dfea1bd71716b8089ecce188956f248f593676de5726bf238c395d61a9c6f62a1afed80234b8110ee54674ae990c806e2ee25f659890ae2dbf5043a22863260f75890485e3799e4cdf0c7904b50e331705aa01637447d9d03808c7d9c415ae2e1f791991d7c27f2a3710f2aaad8d185bb54b8c035f566034003f158348c4d6af13d7265ee0b6a02e79554a59a60607f676fb32711a8569a13a8325ca2ae4fc9e656e349c6f6ceabc1a9168d422fc5fdb85758a55067021db9dd0ece58455d6fb6d1c5c59f9b6889a15e5c680943af134532da408fee15024ce47e7e0ad13252b7799b95da6040440f31a291791890fd6281be1b077b06184c8617a442a1e8569a5263d5bc5c3d60c1ac88ebaf8da1dc5a63192e9a486b9592fc7706731ccf8de6015e83fa882e434d33c35dc284efea85c4aa7879fc29e1fa72c23d6b02a3bad644c9de9e31f882a389089bd275b3311e9c675b37f7728572a87384b071113cb3b162cb4443d9d5895138e863438c9947cb585da52ce5f8cfeec5bd04faf71c5b9084fc85594c6699595aea33faa1e15b689c340db516c3d695fcb49f6e95e66a126c996791e07d5c41e740522ffc23d17d77ac823d8257297c5e89a54c0ed32554b0a81f29645ba80bf44d940d328e074278c3a0e0a65eb1807603f5ccfa36635ac72d87e2c4982e76b1ce3f154c7028ca70b9852ceea47ba38ebf3c48a8b35f07be649e096d3214b2fd450101498775aea4064159601bf32486e4bf7bb5430dba460fd6e82861bd15dce99416ee36f99398e5524c83d7b827dd1cd961f8f7de1c069d77d24c6067d15a29a3e9e162a906f502e50833397a12de7b259c3df4a8d11de33d429d928cad510eb5f1b83531256b4fd6dbe898023c6eb3586b936c540790627d98c807f7f921f56fb6402d87c52149e6fabd2a3fd2636effdc79464bd248c38370acb35a46fec3bd1a8bc2090d4fe38727a66ab3a53c3e6936597c566f7af6a95cc8661fcb3cdc34d7cd918ff704ce885c5a33355f8c6eb9de28befbca11af214f3cb0cd11fb467f47edb3e23792005fab79e305e6c1f5ab67913e5bf72dd2931c429858ce51b68ededd9338f3154da1a8c652b62446afa408903e803667a1f19bc381610bf379d3a716eb75e12b78f701afe98031af9c1b67681e25b4fa1b05ca5da84c76fbdec10ead92a2b940acc06938763d046f1d93753f7a945fc051d2baee1e1ea8b3c9df10c27536659fe47a2929aff111d4473d8cf2674664401d98895bcc2efc91f86fb116087fc6ccff8521b2f365cc5ef408dada9b5b5d93c621fe6d595e3dbcfaffd2b72b3e63e8c9651f587174d25c02b9ed7455ee89ca0312c796e0c6b3e8f2feacef5f1930546999bcb1c92b1ad1d6cac7918a5f57e95168140d5facd43264eb293fe2c8615c72f671f5b0ac9deb6bb32db07d61f762c0e32f41c5f17701a41905c8057783473a85f4e7c69fe8da590ac29652e480ac7a98a8d91ffa877080ad85f065393338050fe0ace388bbd45f91c5400b204c55f65f13d449d7e072967aac4068ee8d2a6f26bb01e4f0026defe777c17180bbed1cdacba5c613b565a5fa953987357ed87b4110f365a6628adf4b8eea690cf603f367994e59cbb7cf08a1aae9ac60270a5de4684ee04beec8e07a4a573d53448c1025e204a823031c26a2e9ad29bf9fe9284534139e605691beb7355d69da64d96d963ef32a967ef51af935df234a5e6f16ed22258e7f096ac3763870c3358ef31104ef566311679f4596d55bcc511151a44b9b8b3e06635f8734c9f725e00408b710c9195a1dce9d8b8e2f4b80358804397959aa007da4c20e8d9e2ef40724764f0aad56a400380711cef017f66e9464a3282bdf2071c06d5af15bdb0bbbb46202104dcd1fd0b43ef206680ae7c6df15bc309d07fa15544896d60bf5968b1dda18f98e9bc85cc8bc059208d548e7f985b30dc4b086ee7b06a3184c118c7fe4457f254e84487f8fd53801554307904e1c0ac6139678d5ec44af3dc4c8842eeed4a16e91b628f6be178ea60897b41e9a0d18f119717685104aae6d333571680e443700bb64ed0daa6b874c4711dad3351689f8f1834badb707151e5c4d91f06dd07a491655f442bf01ded652f525b92bb5437f909e49c878c5242a582c6fbc96be65abfa327cf2df975cab65c8a8f4eea02f993c651097bf0111cd57630857b2de88c89e0536080db347827a2ebd9212e9b30a15cbbf4d2e52904b0ccbc57f798eeb5079e3d5a5c952100fa931b668f58bf3366810b4f1cb1140af8bf599388dc8557bc03a85e85e54f6b6e14239702e6b7ec0f3f86cf2f6a40192dd9f4dd113fc3c122d8590645ea15968aa7e971b7b3a1b254b02c1cbb2f8ca05236b0768df75cf8a4f9f74548b3be18a2bd5f658c829bea30e68ac177574728b20b495832105399344d3f78fd433514145274865e24a917191fae3fed287f3697a886221a40dcc1aa0fd1d1e7b321a5409e3555032a2e77ba64819c3a870cbec03280203694308ce6d31c35fac2b94d23afce432f1682a368b87270d535002983207ad5321f3a0954b88a15c17fd121f30b844ba94b9fe4552e31b5e2a89036ecb81b9e83861fc3ab2835fb3601532617c84b632b5f22fdbfcfcc06192adde5251bdf51460f5ef70aa415e8c52754138f2a4f45543602ef654756fe7a8d7659f011e69eca2202b1dbb72e8913e1823dda1d6827dc1307501cb659d223c0ed89be20bda59bc85aef9875f1af263838760b8ecf1f420d7dc0c119a8e4920faaf7a765f31415974f9fb1d69b8498fe8f7d1fd67836bb46d38dc709f76ae9b03ea513df25755b7d1b530b42742fb4ac0837e29e00c8b73567d799ce1f960f0cc7ad28c933699ce3532e143430efcba0feb7fa8c8fbdf7628b3cfb8c82023e5f18fd39603fdfca38a783405c1ff14cc74f50fea2e21cd80e5fbebf076fba6697823b6ecb3236af52dfb9e2723942f35f796306639458ee112e48e2a65bce3d2efe7bdfa44ba78dd1d3c119fec17a2ac800ed4a8165291fa3f9095d792a0e6c3ba9e42d7f9d3055b1840d1b22e5eb628b9e5a313bc7e80aebadf053d50513b97454b83fe6df4e23b93ad8f751d9573104922a2a319e7af8588912023e80fd4b33405054d8494b2002ea9f9290cf148cf7d9f6e1c4bc69ad4bc73b9cd123ea977f351ac93ac4af4a56aebeb9f53ae7e4c4a0b15006627801c7c6c9e1d17d7047d45f7e7f65908931b96038ff29302fc5b9fa62f03d229086616a2e94fad6ce71471ad993bc47bb2cf5c4f78d3b77b35bb9f4f2945ce5253ea2118152bb56c17897661ea0bcc91d3b6ab054ffdc4eb3da85618d559ef393d39dc9ab7272028a25de78d80b88b7ebc37039940651fe5fa9712c811f8f87c7dc06cdf8bb27547cf99524361f754ae097e9e4a1a06fa90bacba4081bb883bd8c4e906e2aef00b0e6ef649955450374af3ca079af26d32f97a5b19bfda72d31b933cc06f0dc8574ecdd57c7fa2b4aece5f0715162661d8cb1717332a41e3b75982b3146268862c804e81229314c4b848344456dae6c9a813f6e4ba85cd6cb96ea885e83cdea23420c6d60d63d827d83db4ca6c7dfb0d1448bc7a7619afcdd38beeb8a4cae486cc15c4020aa374435c6cf8c1366230d82cd920bf210ffd714b86a98be458f903d9d64b71e8d7a34ba4dfad54439464e87afa042fa57fd00620cf233007a0ee3ad3f555f70e6dcf3fb5984a799515b75089e844c8a011e417968fab8f2106d5d8f7e71070c0b09c0dd095ede2eace544050d1f503e94e9c2d6430b9eaea2df4625811ccf9a7686f79df76d0c665485524f8b9050cdb133f6acfb9d74cf49e013c5210f89f5d4ecf9a6c67ac72ff0ca82219593442a2db53fc2420bd635de749c24222457b0a7f487e3cebda971d72542ecd64107397ecdf2a638010602de98b0210399947a206547d9fabd5651a471f369b481ee80bb2d8800ffba417f9d5b5d27ca2513ed23fde483e8a9c48e1bc9e14fac102ea1407fba203266404cda5d914a72e85b3455913939d07b8e0313e86673cbb4e13d444583bcfffdb41a6f743ea485f3b4bf78e6a594a15b116dcb49a9b37ae51f2e5e20c42a931011a9ece946500c57188f45481cd2559e7295c3973db3b462df66b1ab2dd23f3717ab0f3d7d4af702c29874f1fbebab62c5b1eda7bc70514e26c0def3476ac99ca96f8a1dfe94aed20d6dbb4309e6cc845b18163f816072f649805f35bcbd7879d5d9e1f4272ec8487a72f62ae4182f6767cf94df42f9a4e9a63e976aebc5e8ea7cf06e1772f0261a7e12de18049077dafef6db676da3b666513bf313ce6df5eab12a3f591f8ba20f62d1433184ef1f838e99cd0a47ea7bd6ecd4eb0c0a983df5f7c6cfcefd12308f67f11e9552ea8020ec753ff884743c0ea962f0f436ec228c26debb41c73192b5f4994d9c233835953f0d45c9b2b5a7857ea81dc084bc8bddc972f370ff8852849188554fb669205e49866991eaf4c8c2f38480a378f61580f952360019a57c0c57864779e50dee452245131582644557a38e63938e56d86f545db32f7639c3b4c45169f71a88c54716e06c5bcd980974f42c361d8d5df59af19ba98e14ec37ade50252126abd485f414b626dc5442042d0d5ff9b433f73cb94332a1b5f2c4f5db1b54e68ae0a83f1b00d3d1b793e4349fe04c87172c6628d7666def142543a6ce6026268e73cc55e7c017cd06719b71356ad6b4706a6e64cd4489a757216d80f079552872ada060b87071e9f64afc4bb7152b6cc4cf6d14db43714e1e46404306f54386c409592c302a9979677583d6e86b70ceb8d1f40c50730e6babf10295b0711a322ec61f0a597e5a2e47d3b6e20fff6c786b474b16441496ced864a9258efb3eff8a9dcae779c05032bcbe69cc824e475ad77937b9d2eb2e027d894e4a4ea8d4f0f9ad51310238e951136d6b6ffd48da3f7cc7ff46d8545d58391841f6e71c258a4a1f88b6a01ac5206d9ed08896ea40621f46894020752c43750fb932d9f49c2902d61d9ee6d87059677a3b524887e51c06571aa1f33def3dd48ecc0cbe7a1fc27ba7f9b1ffb861c9b1ffa74ec2b05ea2923d14e2cb805698efafb8c1e612ddc30675fb1ccf3c3fec675d48de32e7eec5d3c4f59dd921cfda355b6aa4cf4710e01b08fff3694eecf216b5f9f57aad0925fff05ce51a76c163f95e0a620d7f84c3215ec70ee7ec6caeacdb12d7ca6ef79ac4d53ec167ba34411684a9061160aa2c556379575913ef5686a7ae742a9d109b1eef4d7520cd78b587f3f9e686a93e92f16928e76936776201e4cbf08b8beff2e03f586c036c3c7cbb420752fea5bec1cdada095980755b112132b49f59a7905ec3fe5314ece6dd2fe4884ce0b6983e3c9f2a3990f4be171795c4891e7395dc6b9dccf7582dc13e4cf6028989971d93f4e9c92d766db091c832e52dafcf68549113760924ca5ca293bafcb1129cc14e869ef30a665838e4f54823ad289bd6bd46a742a977b66e779811ee1468ef87ac646bda2def446bdac45767a53cecb02cf5032be00bc694593d98c2d9f5c410ab588fd36b28005c4360e04aec198631a7a017923346c4f3c854208419268f9af7e61459cf13293d677316eae38008fdcf17ae7482a002ea3c27580d193d043ea0fa5351cf867118fe959edef7fc7916acc42899a9622cb77e05a17df05e3d31a669ec5082533a0cdfad29c786bc2231b0be740faba965909b69b9635dd9daa12e6c2db2b3c6d8aa9b02291b18f482907824df63880d38ffcc8adad424d17f74d683a20c2c1c3ccab5db7a8a478380447451cb5abfbac17877ea23af4540c048bde707d289bc1335f92d8f04e63ea66cdc65a27a06265d9205a9cbe42fe5bc87acb7b25e1877f9032924f25defc5147ae20baf8c089d982bc0fbaba6e28807d9735736c0f824c7d008d1175c5b852aec2d6df757e866481eab416e1e7346d18194ef18807297276675427cb59eaf090eb09a27e4653d735f1deef37db7ae0e1a2dadd7a844b26bc925f27f354f2eeab44ebb114d201e45f76154094ca75c064c48df48f2589fe99fabff88e8c1cbcd2e2ed82b1c2169548093bb60e0d1084e7d45c04eac3704534723b9f8303ac7ce98b9dc30d4799da5480cae2c3b45b63d8fd011b183fc58018882245f70c91a1a90684f9a0fbcecacffdb2757a9084d304148d28062d49dc78b141df12f7c4ab42b340fdaf120ee04edc423115fdd8ab9b30a0dbee7c9b7644279356ce35a12244804134301fa5da621327ed36e38ae80be263a263dd8dcb8f558af74aef579849646e662a17d7f1594c61e617ecf02cc87985c75acb156f14bc26f3bacc327932d168e82842ad23d27fd5520980922fd935da1b241f0943d7b90d54d1520c0a6a59a2261ddf441b6c55da30cd7c2b33ddab427e6891b2003b6a466bc043deb022f98304eff24dd761926d0e87da91917de15c4a8f4c703e9e3b744db8cd9deada9ed6a7c4f68957d74743d4d05b898e2eb7fea4eb568d6df1ac756675cc90bd04b871199ee715f6e926ea490ef8b728a906f0dc17019eb5689fdb960646fdb907e0d2fe9ea984f10cddfee831f98ee3f322c4db29c88f478fb7b2e8f9792114983a0301c1a183fd2afa237942b294f4d7b8ecff48fd109fbc006ab3cbe462a4b999c4dba7068e67f3ecff5cdd0b0512fed9ae9525945d34fbb67b068a8b1a501c611771f792430870c2f2aa2fad83965a542c0a50b8453dcf5c7cf388b8e1c1511b58df6348deb126c383272264fd642fd705a5904c3cc975ccd0f5b97e79948c02c66539b7ca1abe67d008155186fcc7e7bd6b9a8d4f7408352a0aa50691cec26ba0228cad95b33778544109a24fde4d261cc2db0a792afcc4d10a91859f17e9f41538e688a20b77d355d1ec16773fbaa68651629aa9d2281bdd7d65930af11c5d5814d26d93649d8a2496394eea099c819a1bd98102fe95dfd1da11e8c8a845cb2430061b75ef245c6ac425d74ff645fcdfab0012377cb6a2c18356ddfdc038b26ee544e27d3810fa24d1081007a6cf051798c8e67e445ba4f778b206715ea562b4d8854fcc1f9ddff7577a3a9ffa3776c94242ad2d3c2dfb92ffaabc374a9e353f38bc0e3dd0270b4db2b6fcd5efeac660d3cb0b73f54af2a1b77fcda292d271f3df05d7c2e3525f983a25ce875374e734ed1ee8e6f42831b37014a90739a3c7fef968dafbe8b09955d0ae83522266afe59dd7c35cf71d66115832576b59824ed5f93b4094bcbeae9c55f818e26be43f931d237ee4655e2fdce446ed01696d451f38a8cd7167a711bd683f868c59c1fc2c2b115b933d009fd98fc330595dd968b627132abbf3410ce4640d675b95fe33519f14258b1258d3e2d05fb3c35193403867e7efdb6fdb6f33c94fdab2b72b5704d7f6b69df2f56c5675813f625e492773e5dd79d085cd9c2113c64d915c8c38e6a2eec4108144e09b2c4dad9b41553dc2c38999756a7d6067634172f3c523e11bcdf84ff5c8b1f555d71dd1e47b5cdf83e081caf20e7f24b954d77d8f1e5a6e6b510e490ae354ac377e09b761db8a425062df759414f15d32ae4e612277d020297d8d36738dd7a60710a284865da6e34104dde8b2df09c0f9181e05ad356e128bbc8b967aa021cca4c22ffdb1c4055ec18b55f2ece416304569afda8cc46192ea783353377bd47104523eae7655cf2310eac4ab25588abd383339e9f69e4b825151b2d09315fd6c3a968e12c503c9f06f15cb2e9e727f4b677b3f9f88552ba8c7115e543335e958d09d44ac7bab3e4d3951da73fb1a5b7c273aeb9948e6d1a83c92572843f5983947fe36c23e7d3213f504389110f830922c105b79b5e3e3d641e7e55f431d6ecd5b0908892f62d9c85d5f3bd124c9c41580eab5861880f3da46d530f8d166c22e53cad2c284506211425fc01553fb8e67d1db1cf5ebbeada8a6ed8866769128a35d6d7f9f2be7a05c750676bb999a533b4ba02082dd55224cf4b0a40ae3701ff909861a10b95fa64cbcbdc0c521b726da26430127180ef84731aec6e0b87f681aa0682818dfe524a0d1607e5fd9f7feada226c9d7c89fbd113a8b757479066b5e69fc4f24374fa7c31ae37cfb68ae8b314eb1636773cdfca46fd6a307bd2891f17daa8feabd5b21c05f6bf4354b58fee99437840ec765f8b9e62f114da22e82eab7d1bfa0685d6c8072a311429e8136ac160f03030f75cd7210ae2a8eeb0f95ccb30893af11e36c0d8d58630584d05383cddbbc892bad7d02ca281218f2f21d93c5cd6bd64b46ede2401db0513e155e4e1226218fbe05bb9bed7572b233dea94169b893923b58e02b7496f3b2918494f66ddc9c20b49a5bafa5411cbaf09e13a0601abba211c8d1909b83e8c7b27f3171b9fbe7b793c5393fd32e6c361edffa539f95d3a6609feaa288f2586a0f66016c8617f5281d518821c328e3c18ebafd9458447ee6f404d0b274fbd1e686607addcfd76639090a6b60be43d1f54e63bf4374e8171c9aa588f864dc1291edd25ef0e404759df164b01cf0c3aa1a68b9eb02af5f8ebe7f234da439b5f532f45982e0dc2d8ee7fa4c0b0d3a21134ac7f6d6867052a6fc1aad24e80bc99e2f64194065722a192a885159c3945292e3d6cafd75a5e0d9863818759c4f5ca3951dbe91a5d1bbd198a3a5c50614bcbf83a9cf922ffedb45ee86faf53810b3f787d85bc373a807f824183ce81a58b494a9b694b57bbfede84223954bbab13a8729c347c20025f023febf070293c6f3c283d75dad2d91981d6b9b84c3426efcda1a5247ef4a2ec1573e2ba92f76417bfb378d73074d39f5414a559c764a3c94c46501a810a23b64df7690921c4ba8f7eef2cf247aa83b551e8e093972bf51e206f254c5163f0f48b0214ea9950cb8b510e740b8ca19066efd5dd17f53ebf3189de3242e4cd9e70fde2664e3bb7d8ad01a65d5652cd189a02e916964d164dca314933c66127be7404eb30a414d0472ec4bb33c5fe0a1dca06cb088cf2759b9a5a0a169e74331b8785b478d5dcd97a5e9211ee483b014749eba959396feb4bcecf10f7f2d65cc44196a443122838e65a6f037b5d1e2f6d8eb5ab77347e460260daffda7c2a96598ab7bda226e73348c7ece670892685a5ff406a61924dfa430ad13c218100245ff7b5eca1d84630c75c0c080cd5880419ffaafdc7438ce774597c89121e7b38d38f18b2bac84ed72d3c04acff4c6ca6da91db31a8ca58bf1a2f51316cb52f1be55624045d739ed035441ea3e5f942ed742c80107a701b192320591aec13eb74a3bd93d40186e0fc01f193771f00736440af6e023c3111e32c17807ac5e735cebdb6aa98c79aa3e764ab91c687c66c7c12dcd7eb36630ccda46d6d5edeba9c79c18b5cfbd245f2fbc5fe74f9e08300fb5c62ea521ac77b3a036b8820e127d2d289e7faeb1d571ae143b443874d2b8bf6b28d5935262896e575e17aaf86c329a66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
