<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71f14e3e7e23dfab4c86752ab2ad8b2235defaea3f1a8764b0da76ab800c3e0406ac98f1e36717150b1f4191fc775c24556734e4e58e385ce843d075a88a3cdec9c5f4510be3831995da75aaae9c305f5d44a4fadc61a91adf25e8e2db875f9e1ac72dd4ecc0f72d018521bf6e591f6c07b3ed7c4d2f7a227535210c5e93fb7da5a1b61bc7c3a4f6b47c7dd51bd1e1444db2aecad32e18fe5c6ae07abb526551f8f533f078d3d1a8be43cf4224d293b7f006e7b4e4bc5f7ddf9b7b78702b39c801c577bddec9637815e4ffc742880eb178156f5ec3b04e08bf5f8e6efa89cab5cd52e1bb64d01e579f89b3fd8be82346f0f8e632f6c303fd5263810a38419d0862070c08a932a5bb38df6d42756a82493107ce9e1ef45ee5cf0760b19e3e435424ccb770d2ab2b3f09e970a5eb42ab9b630c8f88a7007042c8492aeada885a961fcb87c279063f46b51081fd7c3b77179c602a5bacde9fd3cd457905db02874b03a1a0f82287885dc36dee5f8a06a81ff0c3538f94dac089e1403e14c7334d4418da6a7ba2a0371cc0bcdcd854a9c077f120e5fe7ae067f8bcc75739f08fd41521b9ec40f9453166e7efa11434b691e48eefe92bd8b49f8f348245435476988798d38be6611626cf3dd14e6e4e71b5a705712525c7be0d07c45759b742da4da15ff99b1531b390b089377ef19403a61806fc047446d5f8c96328cf6ef741ea02b84abf33dd9d10bc567e06f62b7824929842485fd13bcb118d735536190c9cb7651edead2ee5cbc3f2631abaab00e3ce3eb6c2a8061114a6b3ca4a2bbf7e3868d0cdfa2606a483f6fbec7cfda166b1f302a8e0588805326345eeaa911d1f88d20f6c9019a48e0ec4bbb98b2dca80a863329edaec2ffbe3ff57a0461c22a406f532c24412a7d3623a231c38dd1bf2cf19e48933ce6d5e56ceefe9dd1a01e310702c367e43e334fc7a2c223336838f6ed0c2fea3de60ed1178b08993ac7d7abe62d295df5aaf2d85d93dbcee4ecc8a269e14c9f634ed36d9720377c69571b14e248a557c1eabebf4a0c7a7a4df1a4adb8ead2bb2800a70db1728e230932012630fc0ccd7c0459a61fe8310a4a3e58d73f955d74b282f7506ca48371ca37f3b70db614c4f81dec50fdad8a191dfdef22dde682dd67cfa1ef343fe4098061a222f1aa6bed5a76821f6110fd3f3a498dcf44185e7cb671335baea21e2c28b06d87fc8ebcaecdf073f5a25da5bf9152feadc0ad389d569ffec06222b2d420cc29a772cb39beb1c7d35d1260a1f47c95a6ff6a46952edd064336fb967a0ad260f00ff25eaca02786235cfceaa5e558e5f899c8a66cadbf6c79502e4a643fec4f07982d6d5cbf305848419c5d561a407cf085eb600bff74ca1dd6ec760e5de59289b12232778c9abfa08ddeeca04d3405379fa88926f8647c643a3a9901421415e8c6a852de375c4aa9a133c7624d2cdccec8bd3c722c2ee05d08926bd9bb835b8cb0024445865a973a72fd2d349714b7469c74f6401d5dacf45020eb70c772f88ca3a659c431b80fa01d2281b8548e5817418b4bb1d9b211795fc6ab02422d4d4c387fd9e9666a909fd514924930e4e55892f9da0633eb4aee235be81b62b0d32fe1c7a779289d1e9ffb271461c7e40b0fa0d0c8ea0d229eaa0445fb9f1f9e466f8d815d5c4a637c89b8e211617ec311609c422243f5f833b3cff4ea696c88a66970856144259d8d9a27943dd41f686f959df652bce84ad8cbec8806be07815cb938aaeba2e214a25596116ac09546375ff0eeb6acb847367dc46ab8ff52e89ad862a21b677e64c2af34a9a01e20a578d2af561a8019bd52334b1c738b8179040579bf09c483e294356c3c813b934770f20c00e5be8ee634502d94a7d1242785d5aff5d9285e2a5ae4cb994efb0062ee3b0266f901618f0355afdf576bcef919a90468dc24a6e1e5b482339260afd0b13f03d3118817b63464b341ec6fc146d7acc15ba157ae75acc70adb86000de48f00a96723d2d02db8f5be2f4f49839b519b325c7631378a8b256149d62f580ecf77fe4dd9136325f7fb35625805f477ed7ba0f5ce8bbf191209cf72726ac9d33ec890bca150e9f25d4fc134472cf99ada622b854045b9a90abe399bc33c018f011e60b49b74b0f33937f1885e7be64bcb35c456b3df0627c9d5d8774cdc17389b6baf71479213e03060753bfaa14f23ee10041e675d461a65ad3bc7262b4d0124c558b26e813a5e6744b0470711b07300831f39200a0baddc3b67bd28df83f1184134e171c2bdfeffd722d83dcd78db8955625edac683ea32f7af324541241849d50b85d2a35448120981181b66b5259d16dfa1254757f780ee06adb5e7b8dba589f5b002652f7efb46ef92ff42a0b001c4b064ad16c1e37a6c2db4ee2106e34b0a09549aff8fc37b2405f24d7e828b5ba536723717c57a0d6ddbab5f695ecce091e87ff8501b5d8334889ea16a41fddbde1de118cff68df9d0b9e0387c760c821b1424027f434d0a0b2e7aa309d7ea1dd511f892de75e4e8a8ebbaa57bb0ab37f067c09270b59cf0c74a3c084b80f2dee5f25f3d5e25190368b5cf9cf908cffa17869da4cb6e04767526c3dce989bdab8d1fe61b0f12eaefd7c53557569fc5ac9b111389c2e6b9305af1eb95edac051419f55e480012e0cc739d62167c6f50c44870f412f6cd76a05cabe29a1fb15807d5fb54039d57ca0f965a230104ed21f9b3e636adc81e3dadab43dee1900bddbe31af2e2ade4e9a0e6d487aa197bbeef245a5be99bd2d77d0010990edfa8d721fa0e7b19c4cee5b87e1e88e92fdd66a77270f042c6efc570b84136bc326a62e8c9fa9e5b20aeb8075e21b5f3e0464c98dd9f6632a3880272ef6fe5abb7c56d44d755b6f7b6f80314b15b8ef2d5c60b16706ee54a70c4ee4d6d1650cc36b7f339d1c5d6c390fabc7e2c92bc13652bdb044569cabcfde4ad0d6989e0752a1707348d6c3b74528a2d204c6fc01bac3ec98fba3d97f44d3fb9ab8ac10dbbbe747e96dadedeefca0087185bdbfeafd9c0fc448dffa97f529b111ac5cec793a33f96229ed37120af8dc83578c9550ec9fce37ae952061326a9aa0212a2e56b5765ec7b605cf17c8a41a740619eace0dc833e627608d33f1969abcc1a52d3543af3f8ad3200d1c06e90685cf156d515f75f808d00b54ec8471defe65f9c99ae798e4cf4de8438fbef3b824e68c9149bad05d309ac993bb8bad2ac6e973b7e24ac4ff7b229d61fb36fae35e76774846f10a35e72d553aa80fb7cd0a627e53ef79cd1bb135ab098b55683149cb890809dbf69c03e251550f726ec8aa7c0113d00256f1b292bdda69fe5b6675a5c0511de0e4162e6b2fb6d60257bf9fb9a992fce9d5ef9dd64050f9b2a2ce83207ab44ff97b96ce0c6a2e85f71e16ca959454e93079581027f502e0d4c65471a71ca6ec9c84b4c2d117075c5e7c66c7209481cd4b78104c40c7803d4b43dae1fab15a514143d91fcdca9061287bcc4316e4eec1b4f17ea8ad2a6b8fde4f23065028d8e15bfe70717297a5930fd3df0fc87a5619870fda9a3d38a5383a6df03ebd15a5a10f871600dda1fc9a4d4d91855eed7e19b5d5d59f412ac3f7721350263833732d4f2a8b1f95fee1abc4d1875d5f157a9c3d87540ca2c35098661c681e7e584bd3746a566a7e28b52da7eb337d7ff1fb4e205382570f3bfd343a8fd4d08345ccab5f3340e87eb2b323793a18aeb035ea4112e70b833e018f993e6a530469a656b33309d026369db61a70eeb88778b6835d15707c139c28216fe936cee1e7024c860bfebe6b71de318ca12b350168f743d201aafc5cb17a1d62dc193af888e3275f84073cf9a06de853c36ec7bb53007641e63b709c83da3b6f7e284f3b3cabbd24d7e0465d10ea1986795465e3ae5e4252a00479ac9cecb82751e18b96f5a0bb1c66e211db30683341a04c430c63ed1a4d848ea06d4a2328939f60aa792ffa39be2f166df4c2f67404898dd45dbadacb3f6e6679b86a6a78d36b29b2fcdd9888017ce5973d910a84aadb569796797d3a8fbb6d2557dde800805dfe4f80e9e72e5293b6cd7f26ef68e4e1a93992697e662c2afe6ba2dbba003fd807acca72f9e1b1aa09bdfe1e141988ddf65310d465dd125b8aab7cd43b4b0e5290692787bd3d57d93102d80ceb6921aa8af4a185c8cce0209496858ccf5154f9f2ff7a1913db232e1a5e5de17f8954c00c43ba4ffe7956b00837f56339f4e493d8935d09948b64046815dfad5ece59c16957438396107b6d7392564690731d78fb7d0b9f5084a98c074c86ed27d8868ae42624e549fc93e417e6e0146428e570b3728e73032c6434133b80b4bcfe37f763679707b901d15973a8d6bb7157b0db9d7279236d8d5fb2d9dc2eacc92c63704fb328b02b76f085e12e88c41c988232d01f08a3db93dfcfa8e40eeb9e799b133554feccefaa1455823b0ea185950c2eba5b87bba906217b0055edabc648517449dc8d69dfb42a608efd614ce751f4455c9790e1ca6aa3f82580f6c6627bb82738399c53f163c672f183d70bb9f448abc60ef865bfd76cb8d594426fd0ba991b1a76087568e72a3dacc517ce6f6f0d3b08812915743fb0e11791fd4a1134ad6b9f2fca315c23d3e57ccaf053a8eab371f8d34ea2931dd28f4788194505986058fff0b66a1ed4a9b1cff6e5a8c613915dc1519b499c907dfe3a43f2cf82f144aaacc6c65d9e5541a46f460dae22374948cbf9d20a5b64fb7db5a274f9ef89c01b5f3e7c7afd5bc76e73731d8209c8823e7c4dde12541abb40c0cf1696e3690aab3b0126eb9587640b5c1a2c5c7f347cc2080f3d90a7aa7bfefc728db08674a6b2d11ab189d7687fb8f4fa37e97d53e4aa287d9b6ef4474226a95661aca623ec5d255c8f7b7e471c23dc388ec3e0a900e45602fd6504e1fef192fb2b5d89a04d91c80f7250a70cd47436aeedc409a1a9b5696c3a25d55a06cd2827596e0aabc74bd1f2735b55f063084d34a5ecce253de995c050773fe758f481746967ca64f88b77d16297b4e359804085f79b292c4bac733b638eb948afb3a17792b23c605a0f40195805c174604699683bf0cdbec12cbf3b5a63c65a8132deafbd546487b6eede47aa9c300ef8f4f552634300583dd35073bdfd341c45afdc5fb5f513eff543cb8ec6e30216c53d1b0f2a65913b8a9ad1be2889dcdf8e83081fcfa4e54e7b7c0cda002d6fc1cb87d0ac5f8abbd7758473554ea5d7991c3ede7a4d756e8a0e327fb2157d8a5ebf3f8a060b09ecb11778e3513e720c6310ef9417fc0d8beb5972a5683708d6ec3af9dbf657da58eec185dc8f344df85267c0d9800aaccfb1b30808c0a30c45de845e49b96cffa362aadafa66abbcdb59813cc1b2f6ac8fea4d70603e73f335d9380cccbe791d7dbfd6fa24aa5dd122ba740a84190b05bf9f7c5bcb4e5f6aede6efac1efbb944a5acf7e02750b578871e51e605cba41ffe6df71cc10841a5f453ac3d3d69cbd31a3ae8213d27e90def55edbcac425636e1132f937d20ebac87601c81703e397fd0e3dffa8aa23684415d910730b6e8928ff749b571f4bc92861b329213016c2aea42daf7d3759ff67eb1993d5665729772c5319210e1ff545e7ef5981d23436f1cc23e3a0643074ebd983c0f57b60f9b0fdac18063b5eead26432a726be7bc9c63a8baacadc2f19476b9f674818363ceed9b867ecf7d394972f27a30e50356ce64ba649750e0ec376d468af8c6075f8bdcccf91c33c8f67e1047ef8a945349d9b590b98898a7119b05df11fcb164ec94199f0b1cbde781a7a9c5d445dd32f19c6dd04709326ae04bd6e6c3392632414a28ae629448f9254b8f1ff6bc687f50aa63780396d462079f27a9c11115da0de76b36ad875b81275c65e9e4a379e7d1b315f5d905e9c6642854d8aa7aaba4f9442d5a84ab2bc0f13400b081a495d9f74338801e0c382af033d0fe338a8644827978a7344208609a4ad3b4fae7a71584a2aac7083996bd58e56e343cda0cb34a2bb80438694afe3d13ca5facf70fced759b1d9a0b4a2c29366af925910f45b6c5729de70630aace789b6b04f160ee415b1c9870fc7b3641424f4fe5cf835b3ee1b3bdba4ae68ca060b71b2ffc498a6226df42aeff01a9e3831a3f88a93e62a5fe759feed80a05d3c4271a793ec033f3fd672f42ea90b4a13127fb7111888bd5686c8a3e40a71315f6e2a8240fb0760bc8181b4a211098b0bc6d37f6de9d332152f1546e6884675f96671be92b433f96b335c719ea74b452ceaf1ed86a484c363ac63c19ee947985ff5c569bbb4d2d1dc812116fa3f4c6a58faf512a2256ba7cacd444e864c55a330fc3800f21596abeb39bd63b8bb7660aab60de01ad7d9b7547d3382fdb84fc8c007ccc077c0a14eb9b2704bf986b8808a8e1879cd6c5d0ce4079e73832ed8754a22c684ff5c5035a5b2943a9d4c52308254957076b53fa54505c3c7b3dd59a9ef0d588b2198981a6b5f5b33f165a17dac1e8a1b19db30482822724f9a0ce02dab5bcd9cfb29512e41cf071b62bbeb60a8ec979062f85b955adfe291699c7a8ac2a6a8912fa701d95c3b165aa492dadcc0a30fd26ca2995bd4a80631cea2f168340804586c8ed0222a5531837ce56edcff0bc2e94d4f7ace3cf4cdae0a1d5a853089895f52351c2894b92566bfb7b68b15ed16a0be056dd0cf7f1c8453fd061f7699c7a5932bf577676bb783248ea5ff9c6986397030d36629b4e360885d3459eec003acfb913e95457905932a7c634b0c55c894f0fe99ee6cb9cbfd4de6f38adc871dc954c633c4b147d4f2829dd07dd2165f53face8d7a4ef1a3e56e06cc54e8a9345b586f24c3de7d4aae1c3be173199d2a1aee0bade2212be881647beb2f32346b03852e648f564cce9fc5a1bad5f106c913e7a874ec44b3f61141ac292bc5cbef4c28d1b2233313d303991b5a499ee0f588752b23e858632f91c189b596b060407449b18de142e30eff68d26c3ab9f0ceafc2a5f5c6dd04d4fa3eb02027baeb36355afb9926701e56e711b3d4a47d7f309c7ebca5abb2f10d9696e097044073640f9f4317623596d127893cbfe7203c5c16172820d30f6d014271fa1a77e3d4e5fe5d68fc2d5052ab55222f476eee43e30b8dab20421d0dde76cc48a32bcb47e5dd0c84fd1d0dad7ad56d4beb70ed4b16a42872de2e3d33c739318bb2e1831e1bc3eefac2e91cd180fea59379dd22fa9873d4e6c262dbd1d1444232b96fe0cbb8e14a534a4cdbb1652b19279f48ece5adc98204ff02c598c8e3775fb2df22272e6e2ea33c9534377a560aad3b20e5cb51536efe14e35997c41fab9d914f18069a942b40f2dc44362301fc65aa87e4ea2f671256a99e26a42742db4c1b15656a52ebaf123c0010c59c6ee7c17613ad9ebed426a451e8e3ef31f18fbfc3a299da9753d9032c9c1f2874a4073a15e6b947e870314a16e021f5d4cda770b7be6b4d7aadf30746a873e2108ffcc97e74ffd9b3a3dbfab2f8e57e78946bac68edc1c1e2763698933d09a4a2b424b96d99f171e3b1e3ca08d526e0edd79fa80acf9469dbe8b28c88688268ca741691bea3f02dd00086d16439115ef28cd1ff44974eea74667a7018912a866234ae0f81c2dffe1d9380191546918a5cf5bdee0ee1c8ffa26b55de2c7eb5cf4d5efd673ab4c6f5625dd279e65df905623e94a3691c27b4362ac0991aa76c494e20c93eb1f3465d3648647251aa984a8d6e00feb36898c9ddd9af22054f5d29dcc1ada8d7bca489873ec2e89d3cf29f186d625348c6c28247603ba96962487ffe2cc9b412c86bbb6d56c172d2e83cc8bdc95e41c82ea6763c41fc51c3fe829b70aae4c82cdca7ede02ba397bc8f08f6244c81ca0dedc2f4fa923953f18bc2cc7906dee636f6e739632aad6ef75d031a40aac82d1b64cbc450b2ca949a351139b392d4eca4a7517302d44e4defa4abee0a462914f78c4aeb064e934b9aefb402746d279804c8738715d6407d4450c184def8747b3426b94c5dd5aabe6c15670463aa18c9a1803cd6e32d31783cc9cf13490e9c2209da63f7b1f574c1e2d40a21d28c9532d748ffd30301ee6ab7f3d8e37b327f301a9cd8a480d31a10542f977affd7d80475482c726e439b308e2d379d94eeace759efe4abf657167f5e851ff7b59cd23841f64292156512c99cb709cff6180b4d87b993269b108c7acdd0c7915cb6b49f751f96cf7c3a52e7ae56d8415857ebd625787f00cf674a50db1b9f7c2f08e4745070c57e68dc49be62b8822483d04a5726250e2fd8a451ef8366f2d92383fbe4091eb00cbcc716a97346d706651fc1430f2c564dd45fe09f65d5232a7f94e4d54a5692ed7c4b609aca35668e9b0abbc6cf7aa290e4f9acde979903699ee419e2857b9cb9d7eeab3afd58afc943adfa662f1eed0800810286ebf90c09caf63dc7d60e3d9befb79c5047a39e2a57aaf3e83a365df5cad060b664b8053761ae88a45f245f50c18c4270ebc0892a1cbdd68148bb9a49f709ebe3985000b3d3457d8bd4becf1d5152db41093a9eef4e150732c237a0e9e5d97a11f3e360e7724bf72ccbc10c17024cfafbc1f9d44b125e6db38caa4745128e02d33813b48c9daf4cc91d60582a01c00e4a0b874b5931f0cfd13f9c9b264c1179e54fc6f9288d9b87d33afe3159b8ed68fca897dfac94b9b94b3c921d700ce2be0d24655a3e2484bd78bd5c2ff9850727543cefb3d3c3bf1d499751c9fc3c6927c685b07bcb82a5d608642406726acb34216cb30283efd059e39626447d29352856a2aed50699d71fc8f3163bbb6d14030a5b0991927d13d850b65a6a39978b9c9329773f56bef3885495c410cdfa1b5c6d17db8b32c0e8c7d25ab3a74bc535b7d4fd83155754d94798d97b97eb4f0c28c6395bfadaec8e7e5966aaf4d6bc7f337e37bdd9be96272cf9eb1c12d74c5adba968ac2c983a7fdc5830f1f1617f3d40c6e8233828e18754b5448b863bf6fbace1e2d3e494d4b2fa8e47f9a42fe59483a4f57914c92d5c4c446871e67cc8baf31e51ca8bf0fd077638dffa12660d184e0bc46cda7c85bbfd18b5dbcfb201b574586b24043737323301e7de30a5228c33058e1c1fec16cb7a081af8140f4ea2e62e1ecfe4f1ead02b5c44b6d9258bf0f12f7a3db6e3890c02a3e0a94c919562ab7340a61019cb6d56cbb6f84f7114b8b68dc5abd4ef720ab2a8aac7d927e8707e1fa7ec450c0fdaf4b75b86104e467bcaf952d9a6e676b7244aac2f2d7221a668fdbe3f347db074eccab9a4855810b03e580a801de58404214531ba6282c20561f0412ed5b045bc5f53319047d720ea1766ecaa3dd301c1dfc18fbb7bd7b99a3710bbed3865bb34d7cfdea220eb890e7b987287e4d40625c48b80e5782ee34bae6f2ea04bac347616c4a75d5986f29ccce959c349b1122f3ffc7b8045e21d44dbf2609141b5af72d2d105e8adcdd1c5c9383ab7760b93970a7cd6797b61cb472f04caa9f9e448ca31298ad01ba78da9064224f3dab11fca8e956f5a0c65385f1e7d0781ed9c4acebbf1c8472608178c1533678968ac8c41d5aaa1a260d1b34febc625eb5acb939c11a9d1821407df67850c27e028da02ee323682cf4bdfad6ac2dc8415ff633372d545e4c14974effab224136df30657c3734dab00b5c3203f53357481f6515bb027a27de0a9115daaf894ac2973330f36d671ad0b01b0b5dc587272a9b20910e5b65071f0e64b8c4f0f337497283e4d480956a9d6c6a68c856ad98f0540318e004620a939f2d929100526d97e1b22edbf624515d3c250ba24b0a6af17602c293625188de413bc9877353d816abec5b76eb10799a0fd2de26ae0579cefc07686959ba8a4950ac04173204c1a9101dda1f622d096b94fc78b198590d73f4d52ecbc779659056f79557c1d06f99b23db49147a3cb9e327c6ba2248c348548cd5eee10083aaeb95d7c6adc78768b76409260b522f53a9a40b938bc05992904a9e22fc31893351a955f83ada857262a25e355cca9e8342d315b39194a3d3a23c569f6a840cc81d60a7c31adf65ff82146df1c119c99dfa427a20947146bf5c4edd853359b8b65050de69ae3404f709d8e1de73031dc624af49bbc3119639546fa933be4cbef82c796fc082faf48508c01dcca395affb1d01ba85e7dc0b1939135601872134647900011fd39856854cc92c3e05a445c22766cd12edf59acc364ffbbe6638ee75b1b17da8145abba3ee92426ea5a470bea2c583ad28df3399d88aad1d8b34fd5f4dd13fc41df362e1495ac9e886559a7c7e7acef833129a7b50e6e62db59e29b8e505fc53cd070146162818b088b8c1deb92465995609805e8b01354b1e74be04c815cb86d3fa6b20a923870a2b863e1ee38c1351878039518ece31fdc2f5d56d198f02d30a3e47cfdfce8e368112d36a2d0910d3db5df9558351229c409e862d959837875633eafbbf14e1bc8fc7e1ec91c1e2c0cc3276e1aeafe3bb84051e77c6e9a3f000a9b366824a6f2740862cd14bf9e8377b84c4f68db6360517925931d1208e80c5758896fb548840b0a4e9ed42d3b341969b9274ee6cae10a610fa1f6c8116e8a35ad32cd6dc614e3d8c248f151a953cddc569c21eff45922eee2a05d70ade8516ed1072f06693a63f41db48f0edf7c575378fe1c70d0122a74d8f5f7fb562cc56b11b47e8c814d6e56d62897529d1d47c15d1357532bf22ec08cdd0c683c40df1006f4ade8aeea8a7a8a643d5ad357bc4016438b67c690f6e8cd462f3ba48f8e3eccaee2221fea76e4dc34be110a1ad59009aaedf839bb1898e31c939fa4c4b02df18a3d47139591831394938cfe66381a593aff5d45fbfd4852c6f711a1fda7fe97e4db0f78c1322ab683721a2e37c5a3664931d2f2b2a2473595684b9e6e350e07187be158475ba92682a3a758c1a485a899d639c9bea9c6327bf80111cc578f7b07ff7b52264a9a39869f50f105a4109eef4acfbdae3bcd91268ef0b86ad08b923fd847cc92cb45ae7e4e7d5babb70a9da7460c4eb86fbedff156514266fbb4a5ad848fed9c3a74c4402a34618f1e05bdce834dc0f9ea4d47bd3a02a527704376fd2c6c10ae4e559e5a1cd8efe8b46dec0904164c56f65a4d14c54972e590b8a3dfd2ad7f7ee56e46eafb0f7bd3da4363efe2dd1958531c2fb4b05b27440e26aa771e18fca6ebb4640f86035b905af1dd0e2ce365e122473db52d47ad7ce47e6376ebb6aecdcfd1cfcea829f1efd02b8d80f172c37c111fbdd1b0f0c3176063726e342624da3ce2e3a48a0a6d77f8575727634df58f33d9550a15eb2a5b8e7c816b4b494cd531a04f53397eada3d394c6aa227f5ba1f9511921556d7de665f97d846aedc64f32023ca3ba271bc2e02ab412a6663c1b8b71fa53191c56ac217d11a8b00a6b5a9d0491d37441ebe5139c2920443c632aec7ecd79c87d4e0f6f8ea0684e4286eab04cd24f06840cece1250b44bf37d85511ab16e6e4548c3e81b0bc5f9d22e1c4bc86de4d3f598f5865591998c98b673a9e819eb6ee22fb8446e97cdb35adb359b111ea5a3505ed474ae999db769e3b969036ddecb1c57420b1bc765ad420a3085f102500c23281c3ec5ec5d70f3f3bbff7690d80771c971839e0c82830d45f597c3ebe6c517b16689e09549ae4f19d143eb7c5c37b66342bbafb6299a19117cd0b12479094bc42774f736fb4a4f8676db0e24e27ab451b37d1aa2667a10498f0fdc67c8b414318082fe6dcaad28383d6cedaad58eafe245643ced6f973094d2fe88f7af8082f0ce98fbb02c8967681fa08bc8e2ced013f42ebfd5b01c9424a2a1c6870c6d5a40033705bab4deebe01ccdd601a6b57197b32053d4682654304e1eeacb9459608d46a085dbd296cdc312b5e295fa650694a53d8af6009ce9200268eec1260a63ac5a4ccedef464201f28a3c74a376ad022289bc2df31519ef151f534323f2fce1244e7954fa775145557a0c6d2141dd1d435e923fe007ca35aa97d97cf1b4dd46428eaf428f073ab19ca71645fd2c1d28f492ba205635e59b206489963359573eb1f65c94ed0a42b39e946ee279d4f0fb9aebe0e58f31742b017e9e456bd99075b56287039fb302a87bc5d9b9252628f3a0f9d2770d12f6cc005eb65b5e8b847e6dfa7fd207fecfa31bccd59c277065fbbe988c6ec774460aa3e699575a193f55fb8731ec556138afccc08fc03903d0bbc5da583ef8734ddd4c6b66b223a76960feb3ef189ed2cc4d158e03211d3018cf57e267fad9c480d9a614c08ae67477528135ab5680fcce99b9f5ea8366a403ba133b5d509d06002662d72e5644916b5feb2caf29a042332bbf74c392c72b1a259fec3249f62602ab4741a8fc1dd0d0d5fed08b0f5d636347f3cceca08172fede2d5bade0d193748c04219e5d07358ec454dc9c947cad1bde8a3eb5e9888bf95f232dde9d46e3725745a1960ff220e2abfdb812ac662601e3d0f7197b01186da642bf13bc485cf96376d9f409da298c961992079fd4981c357f915cf9ff03625aba0929accbc9e7d26abb598eec9dc4a823d8459a682fef2f4eb9d36287b0d804d1c3e5b4efddc01d4def74778893c7eb0334a12a5abc8422794afd7e001cbf137e3352302e635ed6cd4072a78eafe35a880c417a25ae90ea6bf87bf82ddb33a9aecf6ee835f842735c581836568cf313bafbe251766cdb55353f349e54e2201cb4d39d91589419684d840f357f4bc60ea8f872444b6a5f56a12ca8859060f7be7b45f8463b085f81a1578a2ae85a0a90386e8ec1d428a5084526d2391438522721be356d4486a19bedd454c008934bdcdc26b3fce6b670faace7a69de9f7fcaa57b2b06c4b00b55c9a39978e3fbefc8f41d74e56a264cc147eb1b2b28c4736b5224145ff469dc13f1bd24220abe27730792359180f18f165fe64ea93623961cba8182ef7d0694c8fb67b906a3dca3ca8e5e1ea9de2dd56be4f03435b434cdb787b36d8b99385a85cd8f46d7979f60e4f4089218a7f643a91ddfe9c994e2c4afbd671206386ea1a9031f202b827bcfcf75ddd5871d5b52b996672ccc9b2421d5c0ccf99887346ba241d5916a08b997f0c5f82a4c82564a5cb0071c0633c5789e414942783cdb2be056673aea2f6ab0fc2192253038cb1c2b8a3fb8e4ae599c94d62eb9b1179610be1079aecc4d6936403607d820465c2c5f6dd4dee73faead960f5099b74e873cf9dd5d4093ed571a9d6634b61f7c04a5648a865c3a58debf8ae5e90c90dc07f90e09e73658cfd7f9ce9a19563948976822195b963fc6f1c410b58d67893915234dc95828b77a0ca4496b9ccd5a50d60014229f92e3f0c936dae21ec63875f1f9278a48acdf10ebd7a93bcfd47f6f33f6e4d9fef3e670bf25b8148b5f8cd7c7463174eca51eb2970f1a8e6f42dbc2db25e2e36ff777cbe4c544552d9fb12ef0bc5fbbed572715a0581b6453b14a931bc04365255c4dddc671742b14369022df1ff643b4b395293a37b8a7fcd8dfe3d72ae73111c4e81955019e9fb59d7f012cdf5bd30da3cb6107f10a721da97fc29d372514ef36ae9532932ce67057f3747c45849b7a45d511d8aa10da36ce4c45f1d7c7e9ab9cdfbc411bb0e36ac9c37a4bdc54b4cd8c40b488622c9e48a1e95fbf0a16db81375a57168b769b069508e1241ab32bd1ab1eab08cb4738176fb1436a5da6e9df95dd31827f9c9184889a9c1a5f2583dcc20723cb79497091bf806326ee0a4d39e12dd20662f3ae5690b54bddbbde423742861e88452014fa97f9bf739cb71edfe25976156d63b2b064cedf9090265afe780c63f1b015203adcf46ea383178f522d57f81fd44bde74defca4eae162581d4a7770474afd96ef4c30edc5f4daf7e88e885368f1e11755a84bd277d8c766447240e022ef6ed63ceda548a9b74903b5d5ea303577c09486fe0fb2034f6d8fef54e214c870a154ed55e048714cda6dab7ad76a5f2f8cb53ecc46ffac57448aa89b74f5dd8c54896c31cd5a701dd46bff633ec6c0988683646027f412fc4a14c614a5fd9172b2e94c3e4a633cf763826a9f01ab4b81c83a17d219019ad543e27981eaa110dbcfb8d67666f186554b31931bf6ea06942c720b3b48fa2f97167148da825568bb32693a59f307bdfeb91b3a1ee7460793a14829e3ab37f1f721e1b983992cf2c8896d9717ce4b5652389cb3d699162063a9733920a55e7b3e1dc5fbf4bcb2aeff2511b475dfad424b8412bc3bf803f9b8055624ce1cf142a1961370f4c3c1567c33b7d80a860fa5a4ed739cb0151dbc4203f1f75ac34ab3aee2cf981c589e6fade5ac571c572acf254202ccb60f9ec4d52f27eb1467af6d019e7a64a3b9072e9cd2cbd9ae5c19aaf65aeec7b38684659e0b460c9602a05a3a58e19b8b368c0aef9f8d322fc58e4e1eff02e3150511005202fa1c46a93d3c2db5b21946bd220309a107ef0c049a02f018ba8a83a39a41b73bdfb01f178b1f3ef5579fc7bf979b5d4242644d09c54063468dad74fa074ac8a980fc89346f9d95d9ec4b08b6ac8b83cf16cc1d237a3e06237bad5ac90c7fae75c278a9ebc20fd7b3bc42c4160cf8307221ae3196cc1bbc4dcaeb62e0d9f5fb085ef43ec7837f67740ea965046cbb1d8f87d7c4932ff702df96a23b4bcdd6703b236428f273354bdc18a66c8d06093882cf04d00aa80357255e585686d7471eb70568b21e9e104c7c08e18728fd3f5685a480f32260587573e23236731347d9b8efbe7ec311bb91246568b12fa24fa043e1d84cbd72288a1402bc80acb5ee59a394d78e71b8d3af180998fc240e21cb0a4e713f835665f47078745d96380f8edf6aea48bcc417af8b10a73b98d5dd35d52789f8a6226dd222235b0205556a1cdcb74845ce16fe8f0fc89f23195f5bd6486153e8f21802088f704e49bf7235cbb0f3190716251ded7c893bce431af974cd8b3d75596c7ed3d38c3a53273954e59209d969c3dc1ea34fb1132f59478877d93e6b3a305323576c13d9958dcfe895e230f0567b06ec47f4dc074054bf654217eb513895722605083594e0d7f2a80bc4086226544df472c87c87fe16d3e199008a27ed91bff2e840bddcff6b3655fc3a1427e71be897210571533f476419c1aaf23b56dffab1590307725ed8b1940ef968cdc74d1c160e49a014564139658dcba37ef7d6c2b532299888aa8c9014dd667aa5359eab9e4bf1330be66e7557ab8b7ff90aa1be767a9c32bf6fbbcf10cd4823778b922d7f045553d4b3fe47a9f854143a53e71dd4611d447bf8c5a65e978e7d1b625ffe0f40f32941cac1c7904d428bfa66f0339051e922a40f93bb3722d8e5faf36ce7579c3ee26bec217697af9d972026ec6f7c1c13fb06e41c765d08db6cdbabad0ede494715d29efa9654415d15c189f7d35cac19f7702fa72671d67b28b908ee147bed05e3568bb340251bcb20ea85fa11ed5974b58eea68f8c9c93fcf5ba247264acbdd60935953614982be616c3b64b20a66b99e941fa33532c7a4962859480168088131a732de0dbeb37f9286b2a4ab29c34d6518762fbf867ad78669129c8919b5ed11b24e4d56a5a2f95fda28c647dbb2aadf351df8e0899cf86ad1b2174ba3e0c5ef6411f942dcfcff14b4252c289c2686963a5e558f9475b8e676d46080adcf91b00bc3e85b31d25e34703fca165ff0c59baf9c9b08a94fc3422606ad9bb18d9d20b5ff25f037b264419c58a24d27863dab728532b797806e08996c08c6d6e47f450ca9fe1f627ffc3e3c7e27539a027a613b2ec272fc733128531bc28007d8f65f1813f25482746d7bda2f7f3ae490c2c4a138f7c289e8f0299a3829aacd343274de2d7c58268e2d46d7f9165e32f39f49d0605c346c3aaad91d22a270f49635e7f6adcd339fb874b30987257db401c54c1639f6e6032d826aaa72621879223e3880b73be3843433d2f66fa7d975df1a5e56b4b0ae614c4bce219a2f5d625adf77c3d9de1b90f269ef394b98aa742834dd0015848e6ddf3c0e46fb59d3009e4fe0e5c8ec7cfb5069e04d3c3bc9ec3867c8df16ea0abe248b192a2d6dbd5d14c93c967b94ffc65533bfcf031863fa466b91674e95d44273d472fd1231852f8e4c8ec6e9c1c1a809beea903bf5159c5a4977556f4e1478c7f94ddddd5be0d6a7a1005da48bd24a5b632257578b55e912d68657880fae1ad71661453151d89f1b4806231bede5a486bc1c77935c3920c2762948c86e1aa6801d6d7da147d8b92b839f98c942345077012f66ff609ebe256b6192db34106fa13a814ebce2bb5ba74e06516d994ae1465b7ac0525eab6cff4fe1755a8077a69eb2f4c73e0e39198762a0c5ed214e2616d8feec9905ff5eef539cd729fe161055e34e02e726e00cf0570da0474672d341e8f371c4ec548226681c0f329bbfeff8dcaab6104005e7e28b39a33bb16aa1c2ac84af01185a7f669397b5f7b53d29cc55b8630aaa2c54174082a46173a792849a846e82239ebc2515636e5781df8085cf5b9e014103bbdf0879d4656577dac2acd3015b594d3b523a460b18b47201dc51137936f1cd530d9896f2450791980b23c6219a78cc5e47e3a6533fd27ff446724771f2b6696d90e36871b9915c3de2d3c4603e11b5af5510a13e608b4be4e95ad5d136b7de495d15e7a4701e534d38236935ef5aef0d01c1756df81606b6ea573416360ea7169f05965673cfd6ab554866b834483c5edd8b968625aabb1c83522097ebfe04257202bf0bdc34487e7cbb8cd12f040db6e808e23e1f71abdd7fd32447d55f032279608a9ec3c59a01ae1e4960354822944c652744530220defc0f3bbcba4b9e74d3f5a658a003e81c9f59fd0a15ad685eeabb86f53634d240bb76c61cd6d1e64c8125838258f94635574fc110fea7795f2d0b47749fd34b4be1302acc62538257502807f39e7e86d4d93225d6f3c507674a3ba712d60352a554289a62d5763ba759cdbc244a6d05a10b04879199390ccb886b205a39ab8c480d946940960a283a691ab5df47d3217133466df8ccd40feb25540a74a16f0407d01c7e4e0d787ac8f2e7261127202204663b969577129b009172a5a0bf069bf2f275b872d0b08e9aa48ffe99dfca04df31101ef1429b5c5baa2b194e5313e489a90e61a6d0dc1dc047ebada2095c3eef366993dad15ebb7d2a1524dbbe100e80857eb91d1f7fdcdcec0edf54f9ce8f724021b449b51c76d11b70195b57a8fe03aeec5397d4903bef13ef24e158bf5cd6fdd602629ec82a39cd953d58aa15e8609541978c494c28332923765cae243410556ee0e229b5210cc24320c9f1ab3ba2fd283f971383c6c7e68f48bb03d96d7976c4729011af566805463b6086f5c5572b192def8cf1601f04ff40cf4a85b8b9abda4d96f022cc69c21186b9e96db456406bd0c70147c7da92cf4628ed98bf34ecfb0ef040d486c0dbd8518094b8762a14deee877febb71457c24c4dab3628f1d4df3381d9c21ac7138ee991cabfc854ea18e8bdaea61ff9d2b3b2d59146781da11fe158419641307b97d71544316299e69e07d66e9d18e1542c04b81fd6128480ebc41c4c687e55ba0d63f57f195823b2294037de760bddba2f947f10df52e95deb4b2c6f365a9d3314b506031e768760e5c2406553527d06a68455357225ce46d57e46f07a39ad485e839a7d5ed5d24a28541d97b79f24f317d480f11b46c520d3fc975fa47c668ea29a19dbd90471ca330801ec62eeda836f9ed624ad436bcb5e8fd440019177509960dc7f9ede54c5aac49c946fab2e9e4a5d78833aea0c284824589c6697d64b264d24b975ce0e25134dc7ddfa75bdf5431175777a3397c115f1584bcb96d803a245ef09cae53fe9230cb2c0d17d6328d136156fed3fbe6dfb090f252d06ac14d9876081c7e3945b4f4846821513dc8076dd1f4799276f8572811e22e08f477691d97d0252f433f8fc21e4e84ffc8e50497927bce5e44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
