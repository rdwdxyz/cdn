<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b5deb497d83f2bc21186cc964987b270e2a62b337554c0bde30b3dc5521a65d6f3ee23aba675e0facc9e00fb1f0322cd648269bfad53c7b740d636f8fdcb714ed46b7bd828e5e4d03c7e139365827d418794078464846ce28d651409f86c831688bc21a8de39f99756f1c688feb39761bc4353f34757f4c0d2711503681578c3a15e76c0e00054e6efc880662e487ed7c0f132de4f670e2767cc07ffb0e50c90502b348c7b2825db660113c8cd8f83cbf6aae8b8e36dd8cb0c4a6ec024d54709bfa58cddb7a0e529bd3364d85c8615422bc0666ef0535145e861c56c53b5910aaaaa592b92705d1641a3eee9446502d273c0b3814442b8a5a7014cf3f2f967a23475b003d337036a0976df261319697ca45661fc4bce0cb2d0df731824a452e734b789fc7986a468e5213eb44dcf1cab3d2b8952816c736aa2affa1c58301823a8648e321861c97eb4edfd8b56581e79b35b1f35e53924018d4dce9afdc948a530c8cb5a1683a7592bd1649abc65cb4f5002d97aedf3ca5711ce1a86f23a82fc721b54557d5d4f9f01ba3228c15c6d3fcfa341e87820d5ab05874f60610f2d3a7fc1392938005758ccc0313a1728636ac0c6f4c24dc5b2cc2bbabeee64a3e4e79404090afc92f35b4d58de820e33570b766a61ad31bd1065a2848a9150be0cbc336ea6cc801f686918f2d1d3789f109eca4113afc3e544eddc31f4c73c73f1d7d406aca81b0e265776f48d86db83eadb9d603aa8592ab7c1a975b41bd56507f718d72841d35bd7af9a509599f49faa993561445fe0db6ad9118793783431ebb315565f4a24ff0fb8dbbb6d67d6a4ef6f3d290648b1aa5db8bf429ebc6ce8b725cbb34222dc61f7b37294e991bb21c6c9ed152587ff7bb494a43f455613f8694f65e388fd67da69fab1db42ccdccaaa995a184f3dadf1c7eab4c9d826c32f8b7e577bce455a4bb57f13790dc7e45bbc3ad6135660ba919693ac2117982873412a8b8b8edbde6de07fa134b6ce7e1d976cd36592db8471efa2aeb9f1f83fa862f6c20c773206ff2b5b25e2f6ecddb630e9ffbb3194593dd08c5a301653a03ec8cd0a2eda8a42bf43b310bfda354238a3a9dfe863c425dc9e081d197515bfb78dc6a0def597abf13b6aa236492da9b2f575d27de52e9cb27a4e449d1e5ec97e02da386d801f9453a1137253e5ecbf8c288652a20093e8774d5873c3d8e3939e7545b51ed999421ebd088881ea69d1a0ffed1fddbb92b834c3d2296d4cf14efc5162fceae21e80c5ce5a36b053949e6c2d62b4ad7529589ecc46397e07907658f297cfe9dd69b6306b291a53f3034d314e13c563377139ffe1daa6d043a295258b68ee752d63ce0889f84c155c921b6b0de19e367dfdbd3d0d9043f8c75b1817876f2540a6e7239cb85cfd3f6383c00f4f4e8184814c98006d180da0335a2e5ffc9ce5ae5577faa5c15057b5b75cc9b28273063877612e23abd53390398432633b378b1fd89bd03154464af9b39edebbc71886dd03bf525351abef9b16ee44201cb0037e2f0ce386b1688bea3ebccae583153f1f745a7bb93746b926316c772fcd310ba23544352895eed33a5b296a4cfcc6638c01637109d164b2cd2c2ce4a9a9f19f7a20dea19c9bb9095d8ffa8ab16ee0a8e805cbe883e4af7a6f6849ad022d04c96b234d2620d8cbcc43349058229786354002dd289fc495f59b6eb2e416dd52a304e5c30a0e87090cae265198baebc37591ecba5662e871d9308f4ab29f3dc66d609b0809a9baef1b2d9cae8563b0a0116686be0f893d9237333cba49d28b0f7bb4ba5ab86ee40387ef0962b6a34d93cb1509f29e9786e8ab05d69eaba461dafcd39fd54cedfd50f31f2adc3ef2479c78834e0d157d991a87d6a1aea1a4383352334e2312a9a63e82b37ceeac3f61130f833035af5b19a31b7d29a21ad8cd8b22df35085834a2b00d7e3661062e69a73bd43f17d47d5d33eddce5906a0f61a657edbe81dd58e70dd9ae4320956d00a0d3cfd226c85f3b4f4b285ffd507e72eb401b11a15c7c76cef26cef8d8f96b05d210a40d72d5d3e14a10f6f1756a37c69c04de3394743be9729c10c504e8a4797ca5d47dfe64419c467e2e4b32af89c3e88525ec1bbd88ba0e00003b262e8535abcd9fb7ec6274e9cf3d6f1db0971275c5d2cd9f3b6d2e3aee2018da21e7bc4c0953fe52d6a4a83d19fb112a61bb01bf11da00400ff1defe8ab2f50ea8cf254bb7bbd72d093b50827979f6a1924121e55f4098f9a35cf1e219e51c12c192cd8cc4996b6442b434c6ad20cdee1be716931cf4e9324d64eb4a290c43c668ab27f7b13492770d81551536bbd27a886e8825868365651b86fb13e72a0a6c588455a08602f37b017536148df158c8a31a13bd93ab30e66b26583c763580cad0e97d44f035cb7fc2c11d35d1bdd45d9c2c6dd081fb778da3692c26cb08afec993814922b09867e1728330dee5dbfc502ace5a984828cdf0ea39745a5b726cfdb74e586710a85b196bb7855e29d95673d16a02949149cf60413f0c0116c5d8c51e32c8bc370672f31e86a1d8ace91762a2f21452566664394abf35549581c40134379e46d972d3c62a02b0e55afcf57384c9c6a81ca5204105be3442c0a922a839735b75567811e4304a8f413c1816f13fc992d5b18d85d8b695cae584174ab4a295e42a58686578c2a99f2181d0c1ce051ca8791288d18fda01d0f8c9edb217dc6cc357b15b59ec300ff9d055e170491972b1ba3f1c394327f7c82e0f3386fffd14f41658c1a9198cce4cdf21e6efddcf597d7fd1993681dde961e69fa5476b7b1ae481a4506674a039e763a40f6700090b7533ee6246eb3eea73e02078c74c52e67fdb7cc97f80d12b332b34b7283d63f1387358c55f62183e00da70bb73ae9a1ba7027179a9b2e5d4f184eb258cb7cde56d5d8fced82a6996aa9cab2dbc0f67ddba3e2e6e6c34b5d1d3afda1f8a0d5134bb66f8ab204de01a9ed0dc4a6864b8663325b3f9fa99f85ff91b63bcba8c13366a7ffa894c91aa588c79ea4748c3ab5c2152fbb8c720be9a984960a36078520d391e548b7d5131f50aaf75c73e6a00fb4be57793d4cc4c505554f35733629af5d9edf214362722a7d979a9001021d43ac5c199c5e32c338f4ee29defde915d89b1c0d75d84d76938a95e21f11f1ffb4d212a8e73dcf5bfc319290f245c85b3b67c3da3a8fde12d85ea1a42bcbef42c8345c160e8e88a6f2ad452f262eb075f226bfb1e29316aa629d3c755bf4a9e5eb1bd38ddfbc94cf514fb3d77feea2e909fca4cd270e1c656771ab6f4412e776e049d9d37cae8ba7e7f0816452dd05eca9a66a59897dc75fc366199f087bc407e1efa3d7d9291ccb9462c6fb14c584e5db872dee4538b2133cfef7b50980e1867c29124bf0e7e29d4913412938ed73991dd39b44257e9e655afd6ad680f883d910a2081399f2b0ae590fe026c4034fc826917d946ac45e6967282ba5e98f75ea8aea84f1849135eee5b45ab009921a0ad20ff2db3efe01af96f902065051c57b97fa36ed607fbf57705399be6e04838e53f445eca6880096d0f23fc5193371467d42e5451a35fe40728213b1409cd7561b20bd85f6481a08538607b3e71d2c76297c801815bdbcca6809a4ec592ab0f07df5f741413bda93fa5f9c187b25d7b2395c83618eda5073113f57f1501ad930c6a57902874ac322820bb32f17f6195e6f2ada7f486df4b3b1abefbe63657f35280ad25613b2b89b7250e9aa4f564218226f85d02e8a73fd345f8ab5ef8d3d48bad3771db839c55111feb4276b27a7c3df5236c78f85641075e3a0458133c719550b8cb83a01fc630d7a84d43d9081a86c9f66a8f8ddd5eb42591417d6d75b32d4e1b3696b1786463f46b84e582c73b2f72cd853975e8beb4c1466a630f9c56dd35f17834af3598cbfc4373da9b6878432eac1401fdee525c905de5876cdef72a67af6a977092c073e38dd704cac61a0cd9eaabada504fa9da9592d775a866d1cb70f9a183b0fcc6a316775922d0a8f72f83b51edc330214d77961291c217232bba9609ba73ab31c9c9af3225c4fe353a388a7ea0570879fe1b6ebf33f7e5d10748fb58c09c84f51502a2d3abecbda669bddf367190add863530576f95d40f3048192e44d17697d33980e297bf381a96031c0d3a19278b0a0593cfc0300723a1082b39bf66004a44b489ab4752473b509df185c967b4e53863a5b464524b5b254052c1c2eed4c392687ec105de86c49fae2092a7d816821aefb17b4748adbfefe9cc70e793e2c2f2aa972cd6c241f2496814aeb4bafa65d732fd2c98e9d946e3a368bbe6f69910427280ef9431707cbf313efdf12c6e9e31e4ec69c535c3d8a87abf46b004829039d42e4f587ea0ed2257964c189a753dc80a356ae14ddff7904862d2d179319d32b37d61785e913c34a9544c0a99d12ff57a8615b35fe017d93880c07ea54b5e893173f8d5678dc15dc45f328fcbb6dcb652033923ef6ec25a97d58564ff7ce91bf98fd657d7f728e50a0dbcfb870c97a5915e33439833806f27f9f38ce36777f3cd782b98fc0ab68f4e9929c67a7a7fabd15b735a271bb8de5eede15c9674c9ecb00f6d57c41644565a6af368c6f36deb7c4909be5425c7dd05f54c41abedbf533bf6117fe4f675736643f250cd2bc2bce125feadbb2d8c351c9066668176f1b9c168e92962d03cec59d4b519b408bf281d37a6f2624fb392df8a28d0f5d35b6f765adb605c84fcf80fc051bfb99cd040c55e116a69da8591b8e0fd29b73d40b1bbb1ecde4f23cf4a1aeef94f46ad0daebc76606e7dde690f07c59491184e8a356719d54e5ce041698958d0b78890cf2a64adf3a90ea923ef51bbd72f2e6181b9755527ae7b16b85c7224cadcceff77d0f7f173f5bf35743454ce4d7af16d1614822acb90d4a60698834e9c7d3dcaec6826f775a383666c71fb9587802671dfd10ef4dfbe8aed4743d2c976b73edceb84b2672dd9bd41cb97917784798d50bcd886bcfc33ebc0d1d2db5135dab0b48e2ccbf190484ee572c8d6fee763bc3b767d476b44f850f60ce2827d7e47eb27e4c92f1c3ab30fecc42174e6deefc810025f2d15f082963cbfc8db4c9e9ef5da46e75ce7113750613ab9cdfaafc0e21bdfd1a510b59ba4fee8f3dd53ec189e946a1a424bb318ea64af9fc03c91ea41d9cef406e10d032c1ac33c86c782e38a6b1be380f49d4a23ad321837cd0132dfc564530a93aa356c6b662dd39ca94fdc7dcba7450226ca0bac4947d61dc13563b31c80b9d91717e293266e80b530429176b47ef47435d1021de31a64adb8bf5e75d8de781b61f0047e38a1bed3309345e2c94b097983a3a93c5338e784e682b2beeec026130df2e3d4ffe0df178b7bcc52dbf277f2e187cef8cb85c053fe0870cc964421d3771626622c1410bbd1ece6a6757c0145bce0bb337e589fc71e37615c78ab0ae55bbeea4e10a02af0a6d1677536e60bbfcaf67571b850babed7dc80b0b40c38c57783aae9ccc0f06ddbb18dde1f0a09d1e819b3a9c62254441681a2a073af34a6f257f0149ced4e43337afd879e93e68f4967cd23df585fd4da8f801ba746b03f329d5eb1f0d8d419178c3cf99ef29a7ca26305d78c5994d4c22d50d58828c5de08dcb213f732b89a9e8c557f0f4d150dda3182fafbe7df81459f41411fabcdaa1fc70eafc0062186355c6777e005ebf53eb16cf2b31aae39a2289dce557d894f02c490a219b3d0a065906cf65303112ddd41252d0fe3f205923c8aa4bc316990632194341f92f977f7c1f8f3c7fd0f8eccf1f8c256dcbad44208fd883ad06b1198494856c50cc3eee5eb51769b90ec43eeeaf23f7fd6678ee654cfeeaa33f4c7eccdbce6380e3855f9e60189b664c925f49bebe3da08f737b6d3f0896bf5749aca7a0baec256a042fa9a36a078619034eb1293126e4c48b948b9881a8b1a83dc44e6bae798602c5e4ad58d30f2878f5a8f76c2c32e6f8026e2b4082c703e8d1a35ae54296ebc1c57019455282324187a570450146f73d41a9402b786844ec521b7861a9401f8a4f2564b8f778a8778c15e018e098504e4a2fb72a1f059f4e765c6f2a8683a89b4dee801467ce4b8dce8c591afa409256672c1572969f25cdf904a0b462cb5ddad4111c2573284500ee0dd98099c420a4ed9453526029f36a4152114d56093570a2438e7a4d77b6d9f4cf815c89bfba802e0ae7b615f6996184b14d1b5f35d36c9e561bf5b70aaa9712db473e20eb6e0483f045499bd2054cda27a4e8fe63ee46dc8b571050dcd18bd265dfd8890b43590d114654871850bca5114e6bed00d6384f556166419a57852c374efc6afb6fc9b1d561972a4e5b207a630213aa171f4419157d03692f5e45d56bd773590d09595d1b62e1b5e689f1b4c90ef6933f4f418157a5f4199a1ccbe62aa084aeff517593cbeb98c21b804e9ce08962b8dec15bfa89f2fbb8c3fc72a3c08862ec58a3e583e89c2255e016b8bcd24dbfa0d4658e6780d02c1eb7e989c333bfa38dbbc38071900d2798c9e3fc0cc87bb961ff989a4a1bb1e0092763b19b8550ce30d3206501cf0f8c086fc6939801c9b2d28631192695438c5b70a23ad993b19223e74c84c93442ef5ed553c95c7ddf7f453f09faa14ae475547e44e60848b3f00d93f238a6d258178648a7352abfdec70dac375d0a1337c64c5a90b69c02bfb33fb28e4fd49a38b44d9ca38fc3f4ed0e44f43e0025820bcac6b591dddccce3d608556877d2920f2e27b4620ac44d1f5b048df47dba2dd54e268e5dc2bd26db8c3770d3daf47fe649c7fb02f8ba76c51cde5135581478cff4821db04792c0caa6611e2908960670441595c272e8a7e8f54c44e9d44393548f0943534f68d49734615ce235f934f1f1417044dfe745f49f08f09d874bf890b47ecf2711d3b02334eb6fc967b70ef8c114fb755df06a070b45eca24320e2365871ba1893d1d32d8309a9731bb4238623a040d9ad94fee23943863660086a8e6e00f21e39d007c52b55047a71d600551794035e53bf4efcc9f449f27b28b125e2ecb4c794e24cbb13c45ef034c502b203b1dc5f43661382aeef37cc5e7f07273ded501e6856a914b05f838c1752340498e250f741a88f7b7da9ca746ac632f8d7eb2e93f1ddc464f3e7cc52066af273bfa87ad024ccab68d5f50ba7772efcbeaff284bcb97b100a144c471451622669b592172739acf4e5259434fde60d8839fabd2c8c84e470cfc3df183d84bb15ec1d3d9b72433eac8e27b8bffe8b8e872db28067b9e26f85bcbadcfd01638185ff3fe87e8d347044bce50ca9051b72dbb15a1ff033a8069210c7b5d9f8c1791b42043420283f71f2639cfa3186b6916bc3f70b8b61354593f8d974fb205cbcc2e86b4a2796b9454522ab8d3e4ab369cef046d35eb67b46e6092991691d5ba8e2de95a11fdcae42a16f5052ab38803c1a57401a489cfaacf5f3f23dbaeb046bcdcb02a0e9318d186e6142d1fe4e4252284203ba55fe0c0e31fb6565625e925bceaa94082843e3cf1f01bad707fa5b5f8f4bd354bb99ef335ae1e4c5f2fad0320de8e887ef4d35940bd5014a9a5bc1327a5c0c64ecba686d1981096b296bf8d92af6e3797d32c8342039bf5c422bc1db86627713f689be9d1c9b878b5d9468cfb5d5cb2e92c017a46d0c62576a164f6f4a0a5999fd6b4be9b196e3812998c868d2099923464ef2f3c71fd9f9d1c5c4fb8ffdefc8ddc52329cc6207326438907986294e720b51aba04b67eef58d0736f9dbff83c8865f98f6bb7a6a3c8a11cf15502f9d5dc3f2b75b1ffc1cb8a18ba95d8306df6fc609d3b0b6b39d870a011a65477ae0bc0a8dba5dc07d704d46125d53bc87ab48e1d79d7817645ccaf711459b20700c8ff596029b41ba4806b5a2f2686414f4fdb05a199675929aa2e8e1c201e5790c529164f1a43710fa77c8a9faf3a840643d877d28890875e571f779c25b11ed91873dd9271aa15a81a3617adee2d692ad585a606810dc47d0ee9ee0e020f6c86462eb2c1dda8da6c88f0a024a88903c12a7f4c2b1a4c93aa72469cdce8fe736182a3ee81793e68f65d1f74ba86655f89813133f1a682e80c81a67cf1e5d53f8625f168bcd0c83615444f06a34d9c58d4ac85e20598490bf3540e596f4d773048ff9d9beca492ce173a3d4975d747b74e61b3c9b60bd025d6d78037f74bd24e851cac2d4005fa3034f3c9a64b603cf83be7fa2e158df44ad066c21c75a39ec3571e027bea79273bd0721cd12520a4afd1235192b5ec7570efb00069cbd7b0771c145f6eef4ba6970bdda6cf0e9ac803c9be23e243fa8bc1c88ffe2c0b429587f1bf4637efffd7a29e8a13f91832e30880191e624368f9cec4b06a2e2a4cae486751d00df656f877a6223bb669e35ec07a8ae95d52ff219a0858f696445b72fd4596eaa3125fd9d5ac1d410fdc4f362109fcb257d409d855cd3b76a2664b94aeb7b64e302b18f34364446885c21602547453578c15b8e6d1ce87bb5c7e9c885f4a1418433c840204c0f1e7d4c662c71e86a54502c6df2d175505af44d72a2019144bbd8c3ca270c97d7988b327130ca809cb63130d2d2e10a08d231fdba83d4a15c2a8ccf76f794e05f763025a82efad08f17ce72976b2614857834fd7cb10dc895fac323efff38288caa0942d9f20e553ecbe25fc0c6831d201bcecf979a2658d39447f9bf98d802a7ba4d69902d7f691bfad48b003d61eed9ba39e2f8fcef40ef11ddd7bb20c8d14b185b80486cab6183ea41b0be314de41467a9be1874f915efcc22493d56c0d19bb1d942aa241d907077ee957b6af2541a849d4cfc3e01f4ec953486655eeccf3c755805b913c82e55ae267b60b42d007e416666e412bddc25678194ebeb8579850e43a0b8ec5427ce65d7c6b91b1b6fe632164b128f6508e767e4fe4dd74fd9dfc759f477c1f5826e36b2f8aea932f2ded10df88a34b28977ab074b692a65670884da161138c7c03b298d3c556e2caa18937b119cd8c986ce12e58a06a21c0c78fbf0544bb8c8028552692a7481d368702eb8e60bb570c334a225607accfc810ae93bcf4346527e7002aeed558de6f09835e44ac5b87ef5cb74bebba9c6911302798700f30f2fac4bf74dd6fae4f148632891481ffbb4278e7f2ef5f4929a4806493af5a9835dd9c4cbf94723b810fe806af8cf5264c8060d7ac73d23e5c04b4e227e64aaf4f3f67d68e1f78c0a088b372d71ddf4ede983cfb0e196590c65a9fcec5802a905b4b4689eaded20abca5737bdcaf5abbde80ef994f6af99ed69bab62f3a166bcf2155082b355cf84070ba746a1693da62bdfd18173adf71c3e516cea1a6448d18710c51ba74a20da7b1d1bd4d83a89cc6a169c64da4785905957139506200dd7730fbeed2d784d4d92c5cebde960883d6c23b2cd0e9f87285fd0c547f7a46ad937747cfa2126a0a0d3cb2ada81497b6d4303c0b73946f86083f35349b53c6bbd026504913b136de37cdc0ecf48807bbc21cf6153a500195e0a4601cc5aabb154404bea8693a22467af37031ddb22029660b57aeb31241f172f34151990f66252195d24f12c4d0eac0d3aa249ac3cf15418f47a690b72dc2da72685439f07a5f61a3b3824b26fa6f46fec1e72cc5fdf151b9feb0c803d78139b26334dab68b281f0ce257f7721e9de7049f38da3f28e8e169afb0803ce1252c45757cd3b6d26ced4e0b635c50b351128072022628accbea08c978a244aa81367f1d7349eba251427c76686ede292bdb8533f1f6dd441f4050143ea50479713b18ce76db7299f970e53a657fa5181fe5827401ba9ec9db64f04b25e0f50ae603ab838748a525875cbda36331172a66dc72cee8b2e5c3d3e321e1915133d755e86bcfea9aff0121cd95f2d956803b8517ca7007c16ad55fcebe89b59d8ee0bb2105f6d8db4ee8277bd6f00579cb22f94873ed2a65ac26aa3b4c4618cbb05520afafc4061dad0529a102e82c905a556bc657133149936de1c438b23b05ca755d5250aeb9042323e103672f4408d91241561764bedfd20a50338dcd0ec38e9348fab20f4487f3a145961fe2d67b4309fc50b12393299762ddb5e8e85a4e13a8a144e30c04384d15b2ac652367a38c3b4fd595108fe7a3437ca87ea374cf4fb90b273854338488c4f203aac0441ccf4266b73af7c9a099e11a0dacc608fe22e5807bd1a6580b2651e9818d1bce92e6f8a3f812c065f7b05bbbf550ee00622afc29c29de45eb67e1992025f12e51c68d4b2fdfbd9fe5b7771cce2d2fd235ffbd875361bdc9e2b0fc74bed9bfed6c71c5556b1776bbf488fa256795c9e4ed3a1b2f1df5781e0dac3488b881355d704905ae29e7f678fa691aba4a9f7d97dd9fee57689328b2e9159370d63e240b9b859928b56c7189d7068c06662cd82f2419110a9043b3673e45b48dad9146e9e1d31323097a5d80791303c0f82aad5a777bd4e36300444efc4c86d9428cffb73290788035e4f240dd0ffe78114a52c127f52f52c858e573473ac56ae08193c3e4b33e069af6040e171c6766be6432b4d1a05faad2e4d4b087e1b4ae3440b8de2ec7940deff7cb580c040b49b4a5251a049f47e876248ed7e3c71e6c8f8182c4acbc5f018151ac4c00d4753e4fa44a8132df7697fea5c9a01f3a43f9f1b009835f933fdab4854dd4cc94df34d400082f867b2ed57d97a27a16f60db547a6657eee3192c89384b58c72cf908182a3142fe9208c3ef9c5b7ff2a14df3f21c437070d0ef923baaec08a4d37489e11a171da7b748961ecdd7c26bb5f697c6e7f531622c4329066e9512c427cbc7f4cdcbc2d1c8e1e14dc03d234e812a46c748f11d8ce0418cfbb70ed0055828d0f92849ee5133b8b1eee34dfa30481fce75410355e36342877d3fd6b4a588823f9d3cff0e5015dba5694a630ea28b973b1a907142b6ca5722021bb8855befae4e29af1740079a80988b5c39dcc002f0de096b17af568d61ace1c832fd0448130f569c2fb4ea34c677db1edf1ff3f349820b9e2feccf96df701df10f3a85ff98050f6eab97cbade28a0e5ffe40c49cd3d244bc21e26bce9501940477d8ba10e1445f1c5e502cfa5369b916706c24765c7ee5296935c7943c0fb288109adfdde871afef24e317836dd194ad2115edf5d9a39c60ce9d2fa105f4d9a1a5eb7896953169e32428a732b47e999588ea92d5515414ac6c4e6bfc10fa3b01e4c4414e01c04e60bb4dd6e23b6e07c60700edbd2c08bb77b29195dc882bdec2abffa4cf0865789d84852a153473de7e99f634744493cc878f590aaa1c4420785deb23626ff8b2da3df38249f9d4d32d441763b582dc1acddadf81a5ee791100607489b4f835e5f16b53bf0eedc0bee075807c635298ae0c95865a46c37b7b799b40e2133e9ebf8bc9283d0e9b28211646b00b9209d7cf76af6a47a275406b8d4427bd17a02529e3f3ec5e634cc9e87c2349f4900e7f85a97a30ad8149b66e2c53e496af3212aa44934e04568924009041cd25c66de50fd8a8a3c0445b5f54cf72a4ef31524e0aa0e890d73f3d30f5d45d12e29879e23f942090c7aaf9929a1b22405a40b7ebe53d243e72b881b973451c9990168094a7f097429c1b9f0e8351842ad7b92ba3e5cde0d69fc925639543b978edc818d7ad74fe8e2e669df408ef1c33251c50b7f08e2debc228cdc29f0d42836bff91a5c5b0489c80ccbf8605e5ea743b0fad598d1a0ae65ae339fa050fb60b8493216418fefc9e5d93c5e6d86c514df3b245a8ceb21a105b14e222a51c3d81b5d611284969387ddf7bfb03d504e3b641641e2b1b50d796078ee2c781715751849c9014677b2578757604011ef4de1cd07ec33a199a7a3f4e1ec65aa228db40d4a850bb3f86e2fe413f84e78418348ece36339141481b51434b82d8a050bca57472e9aaa2f7e82a4980fe53156860def7db86c9f73c0eeff89729b666c9ff243d11e890e06c0c6f653531e1815e94a837f8c501bfeae9c7de28ef988bce5eb89ab8a5a99d8ddbefe1b0d0a2ba11d881d0cc748e7d4ed817b35e5d50de13c614e339491c9de37d482592cea4c6d7fd82e67efd5353e975f0dd3cc0c7ea22927269091fb13427a27203be80d8a541413d3070ad51ea72e7a4e0b5e28f91696b1f5e4fb45f75c0c85a7da4e6295e6c9253cd0991c77f5e27486414356f6bf222369a79f5f2d98aeacff1d5363b41a65837b468afd8eb843dd81b48170b07b19f51276048b06702ba7f8e9bbf54557a28bfb697e01823538d5e64be1194ef505aefd0f35dc932d70b3cba49d471e307857f999f7039ffce7a8f1affe86f7c8a7030c4ceee7426ddb27d4cf814fded6b724c82e238ca8e5ed146a0a67e8001b5276b17efe70edbafd13c3ba839ff70d51ba675302530063dafced65c4a29746cc4df3809de7954c533f272fa9dca12a75a165a7508c35af8b49e1483aed55647f3c9c4ac194c4dd418199807dd046ddb27f0b520ff56fd96ea08c6f11905acabdaed063c95d38fc9c9cc3f51124ba6d6b979503a697f485eed59e4953e8c34700b921fb361950488c6ddd37f3f43cc927c643cf321d7988e4e38db9bb62cf9ac5f99b6bb7d5fec16996856f835f91e616cb479f63e62d1e6dfb7e5b937bf1d2c0042cd45e2b1e4d3d96e865e5f9259beabcf2b48dc38e2b83003034ca88521749ec1416d30208ce23bb1e92c6d1a53e094feaf1d3d15a080e649c85ee6e8398babb105bd58e4313a5134597add80be911d0b55b8238d926b5238fc3139d50e390d72672db15a1ac222d635ddc8812f6fbd4f40dc74b28e004df3882b7c341ce9e6f8790ba2b44fcd54fd43f1f219ddb2a25ca9d76eb1a49612f26fc84527eee68c0fe73d1ba15980d7629cf1c2f2b8ae5aa23a2832f5436b11ca6b2ced58d99256d7e91d4cb0abc9b84791593cbc0c0f9aff7d36669665d013b53512cb1717bce9a1ed832cf067d8339c304ab8158ecadd460980ac29112609a760e375fb85d40d04dfa5174bd30924a2b1cdac44130987e125867c89dc0f0211b1690cc5ee33df94f48c8ac39ff196d90499c8a03f10d7d636b3e097ea1b669358e2ddbc1afee89964cf4b2ff685f1f8024c5ca3bc0cc63168d5aa8be9adb7350a12a1750ff7d8d2fc2f018b10982367d8817bd10c796550edf962eb924d9962ee85ea68a52357764e70e942e299f04167ce5e5f98579330692d848c9053f9d828f4f54a883d8f857621fe8af2f5c66112550b5bab1e093bc3ce7612bf3a500578824f854feabadebf970ddde06f1753598a5e5f54c193f36e026f7372d50473b6651bfda4bb153d42e12fcba4abff3e10d489ba753b0084608bb92142e54c3d0ab1a8c2720268b68d1044889542baf76e7192652be60991cf73929037d107888a1bcb171e40859ee04ccd15bce66046c3e92ceb4dc5fa08e97966a0feb1ec70995a49119bfabc47dfd4457ff1d6397dcaa9ab8f8e1f7e74b9b8a8749b70c433f4c54e68014d823ea240de898dc99e55ca8e55f39f603688e63497a6e9a1f49fb3cb077baa5f5897ac2872d79270a0dc9bbfb4e666e77330a99280ae85f9ce43fbe345d96bec7eedb26e3cda25cd10a261f06dbf6eb8a4d4f9747600855d19e527b8461d933879a9d55bf92f40a3715a867f6c535f903d67ae265c318ed23d63932e0524675811d2d1e06dc8a497675746d21f4f4299126fe1b8c9a770aa0b5b7b9258a9a4fbcfb8c64cc1713b0038f5301b744543ba0575297699a618aabe3cc76d2eafacf1220a47036c4fd8075ebfb95b95d1c2c8e17811aa17fb87eff797b0ddd7196e38473e4dd431a7fe63563dfa0246bd696f4d737e8c723affac0b262a4b2e275e17ee96d8906861b14074b07d7c39ed6ca39a6020ca4b1a8c03348f85ceeee9ccf921af60eb47cfbc7e99df8a097e335d5257adaeacb37dcdd42787024966b1e7581ba92fe4210812401d83030fdda9c8df949b617f861b3ed9394672ce8dbadde3453ebbce476eea25f4a4ed8f9a1bf309cd07ff756e337f52febab102f4b2990f9dd3e41c04d0be9f2906628c29ebb6cabd9b21f813eb0ddf517732fd0469d42b82a953987aa7031aab0eeff4c28ae4c8b8b8e491fa22d20dff11dc8a9258ec8db89fb0fb515cf0ea736c5cba3b3e8f5f823c4eb52f52515a2d0b4a477dda6366845dbd4972e175e8b466c8b12888100ec53d6bbe5e961c4a373285fbf33d2e4e02b081bbac5d2b69c97db171f341ec94d64ce514b275c6398bd95de3efe33e0dceab8802572c61811ecc9ce95aff334e23ea04d46507d1db5df29fdc83712da91f31093890e69e63c2b18e6863846754a2dc557e23aa9295273d2b6f4b80bc593b1571c7f37263623e9b0069217f29e094dd7d52e2d875f1531a8db7711797c5cc764d94ae6ba9c6e111cf6ad8dd08d0d239ddbf2bb4eead16263c694cd73f6b8c501bcc026d934a63c1e4100e917d7b636f182ac709d45cb7ade601774e14045e639b310ba88b18e16b46684ef7d9246ae11dfe4b2b450f4b0bc93f146288ab0e0d679b7f17c7f773abc7b2d4168326a4545b7ed18c9001d0845bec616f0cf8dcd5d4cb30b06605c4d49ab63f722bafda04aba2c74b69ae7b3485994513412e2dfe2e6fa80ed24014fa28ee975ec30541933327de1a610a016e0ff74f2c886669ce627ab04f81d80f67119e5b3e69973a89bbcc3203265ca022d0b156f064d18c9cbbbeafd6f398b1dc839acd732e3deac29fb4e10f7516345b733f6a133e9fd395d0fc5878d233ed4299c10cfcb1996924c594d5c2e6b1d7c446083ad3b2bdebe78054828f7e79fd179579d1f3cf0495ec1300bb3f34582ad46f28f94414e36917f8a4502320b5583f5f62b7ca3846d4a749d02faec8ca5ee200e9561873b8b3c1cfe98545f2fec88f5239248beafbda503fd8482c2a09b8e1998c096551b2e20be060fcdd8fd9a540378f8679a2297f321290a0b5690393f2faa5b73973992e1ab5a802d2294cd94b72209194863d894a3297585a1abe2ce786e92ca0d5bc8ce355ca186253380c6630dcc52a248d36cee370079e2fd3d471cbc1428ce82e283c23b88fda387c0b6e178a64ada92fa78a024044f2ce33f9f8e5fc7bbd4cd66511fb61e3a95999553a7b9849c61622d3d6a36f0767c949c251a41bf9f6c327dbdecb0fa29a56642838d86951e9dc65f69b1b299ad63744c36cb78cfc35d553ac77629390b57e9d2b3656cca54a97546e2d3ab55d69d7affb47ffcd1e74745a700a93721a21e0bfe5432d24f866896c1e36824a55de7f6fa0356424d77ce6c22f2b6fd86dbb26f407a320f3ed228ced562fb3ee3ca8646de6fadb7274d421f0fb98f4083beb9cd98df84c1771be2edcaa50f22f085ae6f809b8b6a55dc3df2ad7d679216feec92c1398e965dea6efd4a907f4cf0f1d6c0a2d6a9c53bf28a170035b27ca86a91a3177fe019687f5c848c123ffdd600d1586371ad8739208bc439dcc6e728d664c3b3bc0a8b30e2ea9f3693b0374283a9ddbfdb1d4b1196344deecd2d04416ca9aa33aa56e0a1e7c42905777865f862064ee63830d2bfce3fd636e08d201cdce6479686c6995286757eedb7261a7c9354199bc2b50c81e88f03c3202261251933b5c3215321ed4dcbc6c06edde8eabb0a850895b79b9c52c76a97cfd1cf0a818b364a4cc16bc2bee6cd14515b2b7d38dae816547fe685b3abb4e62fe75bda0818d48b75dfb4f1c53bcb457890c90a003ba05b289640aca0f6a93310b078d807842b053f7249ebee60b685ef152a41c93b2be1ea93bed8c016bb9b4c3092267413669e986cbeae903eb068b6431186f181944686a92aa812aac64247539e145d961fd9af29ad56ab87b2045495c478658c810e1aa893898a117266c6664b4d9aa54d41de01e672b48ed74a01821fb16d81bc55b9053bf7036ec08cf191e3887acfef89146d8d5448979ada728b21161104ecfc695314632c89378a8e7dbf161e712bc38cb158cc2eaee431434bb7f02766f680983b7ab99872e9bba7065ed5fd68a17f7b38549bf0754bf493a053bb83aaa2b887445d3f2e585c7b3a86384cbb5de828c656549852d74314aea27b073c47da2c270db94d878bcae96759402482fb9d7aa36bdb43bf55eecc71b6ba940673fe2e0fb8a093544cf12bfbcec948a8f535aa31c0e77940ec6034fe94074965c76b89ed72b806b2dcf8e918a38ba22a041b747f7f051927eccd1139c336471acf763e926a976a4affb60675376b8df6d899db8e105dfd4749bb03de478f5f04fa58648c2e72603486a2329ee2cdfbbe9f4f0506cdaba79b510d3e671464ab1d7ab4ee1aa46108ba424e1dcdea8435e912aff97696ce220b479656e5888c3ad84411a3f61087c092ef82da26ffe3f5e59bc35cbd49f2c31dd16e10709143a4fee9c36a4aee2f083b7575697abe660966c6f756d72c8e5a54d3cc0e8e4f6edde2b8dd3596c24d4f4c94933b353ed8b249e3076d71dd9a9a41b37fbd2746a7655ef2baddbbdd1420796a5fadb5b065abe94a3a6d2abbb4ae1c210d0dd1d67b70c0cc6897973ec6c55eb5de9ef5f783239457e439592700976e49ce229ac0fd068d7d417dcc7badf49e56dab31055ad450d36153bde3066d3ee4b40d02cb9b324054e70c6678ee1435ec1dc4e382a313bb75a40da4f603887cd0d29d475decab4331b9ba6eb2977f9f5cd2c50af1781edfd4605dbd2a4f81a7f82985c100b4fe3642fa7d0d528f84d3a88037dac82e5f1498d0228157156934da428ed1e748a0fa22243402ae2015ec0cc4dd76131df78b41bb58b313991a61c05fbd7a0c709b7da73081a52dd76b04c2654a80d31e6eec02eba427bd3e659b2d76eaba5b062df2f2c06aa407e31e6042b76edefee3010849ee19ee6a59112db15d0cb8d0132697ba9066478b1b634a7404a6b4a34cc03cbee72ec541c1da33b35e83194ac804a8bcb9f24136f39e339eb353a842784ed1a323b738967e76331896afb09cbaae37db5e063a0c214967ac6e2abcffbb205dd306a073fe82663ad9c5319a4a9263745ab959bc9c0bb9ab73709de3df6f7844da7b137786554f4408101d52916d4e9fb08782b585d6102ea48fa2b36e14dced81b54b42884e8fd1cf11543417232f6f633267f48049ee16aa6449c5fc108f6f0cf12e5dfdaa0a531433c0a939a37a4e924819a0bbf084cf103778940ad40674636a7d968ff1888ea3c1057e0ce65e8ecf8d1bed5c917fda5b506ab6bc58fe203d7d5bdbee4e69cbc1acf30747e51e6b186e4507358b5b940bbb622ba9cf38377ccaae40fe00588b8b78080cc06fcb48ff3971c2470c609377f415d5491e431c9436fa6503e43433a2325fe669b171405bc07e0fe2cbda80f777530afae5594be55246f9ac3eb82a9ed688931752e718e9950ccd3ef341b3666d6b7c5c4525bda4a0260eae39995170822191d6af6683b8b6b368d171da99eb4c4fad6fd4b5a8274535b859860e81d332fc42abbe11c4b733ce21c5bce1090f2509ff92d24418a7cad3aa665705b9b461ebbd786786909ef88e6c8896e31b0cb97062961e12616bdca921dd56636f4e2d7a994173f15a511fcb032442d1cd847f3e3b9ac408a7380e858278269ba46a2c6efeddf1bdbb32a3f9c36dbcfe4bf3cef6010d4dd73663e4452b4bb5b8ed81fa91c2deec6885ed9283186f9ef4f55c47e0c10c7e74fbcd1d9d2bfd1b7218b2e37c75998a57d70c3023b069811633a0be8b7df9cf11c104cc04742971fdab874438711723ab1f7afe3ec5a935cb17c01d418bb0d75f3da1e9f9f6fa4f736a54cbba8b281b82a2f26a63f0ffa181d2b915fca6fe14c0bccc66e7581e2ab1423ffe0de82a05c0adf387ea06aff6841884389652e35563bfeba792621f25c1a4d5124d44bec22058abc4d2512936bcb028f6fa5ed4a76e3a6f0a2ecb63608fca7295927451177b0881bf06ee5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
