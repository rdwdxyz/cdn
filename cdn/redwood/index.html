<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45a850a66d2fe570534a9a92ae9cd938fa6a447d39bd2fb2d2c91134f428c8798acec87a360be0c90670dfa96f829ffb0000ecd77d1bb24835808ddbbdfe5bbec260dc2aca3a5b237e7f0cb0749ee04667267b1a991b9cdb357d7c96767a8521c311407874b55b5d9a3b37c85c8741facf551c3048e74adf5ca53e4a377d84711222aa4b41168efce58df09a6ad8a35e21c3d47b8fd659f3159bb4af13658a8747e34d317df22548c3d3d674371397c52a8739619cb67cdf61c57f0fce34960612aa6258b96f4bb33f01a4a61435f502458fd9f86fd350ec25c1cfc2849acc3f7ad287701fb8cc8eadef4d7d38a52eff93b0ad6eceedc35ff03655aacd695f376e59d363e74a99dd2e0bcf37561db9e48e00adee7d281d8d50c18f8ca1853037bcceb6354411ef201c0779da991e80c132a674e7b7fb62b6b15464ae09dedf9b039141a22cbc517ed66fb45a456e3de8b528bed6771f4c01ab886d0c4eb0e5e9951ccb4221d89c18db74f67fb5865d69a57c2fc535fed4817f8337eeb3af3683b358c906b25d7b433f89d49d7278e0966abf6618bf027b1079794d450c9237796864fa8116ad9fa2c65bd609709b7a0505d372430d4d10c88baec873befb7560d87907a7a3a6bd0123f63d5eb66e4ffdc839a4c803fd46f6848ff24e99fc5aee7c0c909348ac47c352f9194b328baa46d581324f16240202c5d3b2ed54bd1e9e680566288f093df112400b4a760ad1f6668da66fba3cc8ebef85181a2117b9aaa25a2ce953a4ea83a655c9e1881fbff71db642161035e0a38188dd2e50cb8dc83d107f3866c00b9a32351b8fec4a4866de474dd840e532c5c525d835b3016da8336e69fff2ea29c9e048ddd27a43b3f5f8cac83de8e63dc9a069cccfdc90696dd8b665250cb2996e7b9296b20410e7e29ec0a11463da2708df10b23bfa2deb5f8c8d750db67027e5748e61a530c48462902d93a6255e3779edc5693d901820cc19857b73adf37b239c58d12db9e3d101ccf7437b4d828af2274bfa29b8fce2ffce6dbd0035f1915f528177b4001b641fd85ad991fab17210feb0ac5196c279bf1f08cd567864663fa7484d3ef61f2f44d1fbb7cf8e233083a12ca19a1af96b85ab56344d4829e2ba151009534a22d5f3d75ffab3e5970fe5ede35c8bb2ee7bbb0dd0103acec4c991447889f657cb82886b448b9f07ecf0476a2e0f3e3d46110d0e3a30f2ab386578184bb4d9b7ed01f75e387451f0e1575566cfbb2c0ee2d4487af59435236b4b3001df5e3cfd70b32cef3f3caa485de6330cef782d710f15b24a9698050087f4ba258271d9b3aceaf33efef1b1fc3626552190d8ef3514e183fed500a92dabc00c120e54eb637428738ea2c475bbc2ce2158756925f9b88a55de32d939fec81eb83a15b014e8733a0043ec6792b69eafd5cc2aca601bd3c64be6711173fe7d70fcc79679cb1cf427dc6f71ea52880220a00da176584652f84e04f786e2059ac558a0984411b0cff00dcdde45ef7b8d19c67b73ddd1d7e46f0dc5717cd49efb4d2b38b5ef44c3c58aebd845aec5ac16571a1c7c123c75420f9da3170255e595dbd63448fac0bdf08ae95208960ace634081463e288c33329baa738553f9bb64558bb0e055eefb7498daeaffab9b74981becf4107759833a907e58cf88be99562086ce7ade1324a45709726fc35bdb15628ac0290782b9088ea2454ecdcc09387aa480a971a837a28b77264ff286c1de6bf9c85774dbd1b00726ba8ec4ab7acae19fc0327541393dbd77b2a4d5e426b6813a2a70fbb39a49d55570f898e90a99431e3cb550897e392c249b5d2033942cc9c519ea125960a8dcae3c1e32251ae07ac22e156e27ef34e5fa09df46ead8da8ba4e71f7065ad7865dfb1aa768a52bf183e92041514e299e29fac6d25b03b1e1119f4826be9608a41fb3c44d356463ab234a2730607b4a876e14b3b72eb0cb8bacdba3bc2dbf1a38a692162ad4435b4bb93c9b2fe354db800a2009824312f5298170ac01102d39eb04eeb325c644761f1aaf246f595cac9fb6884aef3932bf697b98834dcf5cc59590ba9a4c9d0b50b7daffef1913e85db73aba87c1b75f0c7df75603dfb51834b378846e8f62280774fdb8e1b1f0ca9a9087aa9e668a95158babe8697288aad83e4102725d64320a37c531dcdd66b51f468086ddd9ce67ec0e43a9d2e0442dacdd0fd14c29bbfb20d94781b89f717d3536fe401350f73a025ce0cc264e782234ab45c5bc19336aa88aed460d5a37aa1af9bcf767b1f5661458f51b95e750dee2f75327f193f407ac8e603d7d546987189eb2e48f84dfb425a3fa590a5507b3e812d00c8bd6863b02a7830ecfd1d3e3b5ce53751ac63709d2b8cad021bae559c2dc95d530fd31f54d20a79131770279ff3f106f7ad969ef88440ddf147a436f791bd788782e2edc77a18ce4dcfc885754ec135d1886688a1c42bf42195f20b2ddd9ab731c0edd5cb07c02d746f92ca8681341098939f29f1c24e6dcfd286b1b4f6417dd23c55877a1979dfec02b9045ad3a563d5bcf1ecd9e1a8fcc670c311b18cd4bdc13b464006e097dcdc309dfd632216e59a4f19d80444b926bcdae757fa322b16134f7c4245ac15c4a8e9bf2f419697d75395b59ea2c8dddabe78632798f76abe098d3dd732d0ddd44b07a382812f2cf9c2e988cac665943579eeb8e565f0537bdd6ab1e363a3c575dfbbcdcb942642736ebe47c1f66643b7ec7b88cf583c7dd5934ab86894d6966d3b7d7bccd703441e7ffae52a4e3f6772478086297d8aeb4a276aa65547207f5ac7ce272c1c045a262ecf99e04c6f1960b04486307ac9b6e1c8f331f5c875bc56fa8b448a8dbadcbedebac87f477242138c278e2143c6d7491593f854a31714e0f62a5875c8dcfc3c739ecf4147038464dcd886d495e0ed0838a4aa6a878f5b95c9b62394658e86d3b36e62da3224c01aa032b43f58fc25ebb846453407d477c5280a8133ca6132b2ebc8b589879cf30ef1b9a8789960ca24a15ff74e9bcdd6fa2b4be5fcb1d83f3c235c566c8836a0b98016233ade0dfd5bb6e596755738b508af5f3878cb56cfcda4b44b2cbc52b23299f7ca8c7dd00dd2ba66ddc2554a52e8b310258bb10d70156c7881aecc0e7384ba90a8698019023f97bc2e179520647596888f8b03f2a6633854a5641c193479af6e687eaac05e52aef7ffa8d780a2615ab79b92d99d5bbcbc08c779656ea4aeb823c0d088e46e69d5375ebd87e042a0a808b6151064231f37e23911c3fbd136959fe300e4b62d51688e05113e6e95755c1c613e0c2e0100c9c78a0b3aa61022d61b4b0e033ada92122ad37de346b8c1c35d1d0d174170d9555ec2c8551142a3a2f828f86ab4934a6773f6ee4f823f8f53b41e671c5382028dfbd8bb9069412dcf69892917638bc290812be3760562db259d05643f46ba2ea44cdd93ac110df917286bb797ee199e45d774d60e179be5b4842d42b8091d01780c5103c0590efc6f8575e54f2d7c7558b3084c18972f4e4b6f5bf9121b7c21b24af1ae133d52eb070e8b79e7b77874af309307f3fef47cb9f985bbd3a96b15df577aee70236638e6ee33b3037291455032cfc81070ec83186aa414d034f7b437da0de000a4ffc2edf0723038991d4cf014aad19edd94d0e8cc890d79313967dd18af815b5dabe2d3e796564be1abaf1a0ec664a95798d7794a5079ca751777ee562efc4b3bd5e2ba2ce5f64e63630a3d82fa2b924d87d2889998b4604e003531ba637df9d05bbcae761ef76529bc3736b4942aedfa331b457fbdcaeb0ad1a7d20ad6dfc0fac9d20ba405a122ccc0d2d4ce63ab15528bcc1dda8d3b16cd33a0ff38fed18085dade62103ae21643be53c431e4527b9d8633e084da7cf97e8abd44e997b22f6abd2025ebf653b41989f08bf3515cd6c81cd42455ea4aaa16cc801a52a74b3a2a766a6b0b61f5de7c708a4227bde60dead888160eedf2960edf4c5cabcd2a77b8b9a266ebd459b7314c2fd4f8ad15559cd3ce0e2f5576db0aa768760ddf62f20637762faff3fe70b8ca07a4fe650d97e5fa89bd5519189e3141ccd98392182f4ec103161cf7246052993eeeebf8b2a1adac2560d6b0c6ac6b389ce4dc368a1fdda0c75eae6fd4877f61f6ba88381b2fdf1d2e64e49f957cdaa8059eec70bae78e56b7baac55d3a7be8360c1efdd2772f6d0082407ccccd86132be93e266cda4528fed14b9661cdd9baa7e92162f9eb5d3ddb5ec1cab895462a4767d913615529658e454f2d497d034531152ad1ce4d3d114955bc870dc29efc1886842753f22d8e058d576e9b55bf0113cfb303d6ca630e00c57d768b3eeeb9fe8061f5721488a4af3edc64ee3ec9ce66391c68b9ba900374e33fadf5f3bb3747febf4e3ae9dca6bbecd2c0847b742ca6d4b6c35460e486873ce5fbc42061aadc6c245b30fa4ad531efb49a43a15e815cc4b8e10e8100e659735000dc07acec5a558817b09adf850d67b5f610482aab1542dcf57d03520c8892ba09f523a9a31d32320a12e9f7855f3743ff6ed9cf316c84c59edaa8c7d8d7b2b8dd642febddaa2d806544f08f9d6fa55e8b76448d128e5298a9880236721641d822dc73a555beef01b2429ffb3b064725119e3aa29a30cb3a0f542c7b9aee47d9d66df95e6214db57e050f4042d5233ddfe3703bab870da1f53a6a82829df0e106be006108b5921c66b832b106eec5eeb656041115fc65e8bfd06f39fd27da3299c6fd4a43baff871d0608ce36ba8b50ae48797b5385539150696f808a500e03cffe15e74f8c0a01a06949633ae0bb170abeba76a1a5d4bb22f27e03091733823054874220fbac9c904127a526c822cbd992de308588c5f2ebf9e9ef179b4a461066f35b36f7373c0baa979a2718eb5a260ddf961682eec3bbf535e0635710a5de2ca45fe22fd7ccd138927fdf9b92ac85dbfce6aa7746d213d285251a361a87f2779554a41ab4f3c4107047fcf2cd863f62484f3b39760f80899d1083d481be7abd508da3c8481a2da3d65abf77f5c3e6cd575cc10f77380c22f07f2001a1c15684010b69900b2bbfe6c354b774c63f46212404ed68cf09b8e4e8ba16c8d7a5be97d707c38db5b73b2cd16a4c6643589afe6377a0a8af9fea92a0df4399e69d38b201d27c7010c1534e4c0df8b142dea895ebd9fde69b21d6f0b620edd0ebfe701d54f96aaed209e35086423eba5b15d422d0c899742c2bec5d059dae10937008ef8766ee3e7dd463eaed65f94b40f566e42606d0a502197439b2579bc98e7c39f08982ac2c9bb1f01a771402566ab8b3663d1ecc321d58b20aa567022b676ac2957a853bfdb333c224bb7f72d8ccb5f9b5fe60b58c65f18eca29c2095cfafe2a8175d8c7fba281aa03c3c9e2170f65dc0567b1d9e421ae13ab5ffb59dfb6434adb1a927a21074d395402a28258d016d5ef588d0350a2c29ef63aef474ec31bcbb7ff4bb65a06f164a7827246151db86dfeb47eb512affb2b7c2b90c5e70ba725e3f47a6e032e049ac596039eeda6afc9c1179cd35f7cfcd568287b1b9ebbc2469a52da097c061a1817b685d06a22bfef326dbf3e860b2dbfc5bbf1ed9a9ae00a584cb6111657980f81ed53e0053dd243c9f9b1468a2fa9a3c4241e6b774e034564557f1c1738182157eabb021298d4a1a8cdbcfd9f8cf06d303bfc96b42ca1e0fa30848923ff9a6d3d714920a51cda3b1f541ec50b5467dd28dde2f9548344417df97a7512ee1e1ab1f3794452f8df45b1b1063c81dd7ede1deb449758e9b59da97a73605cf4a56855683e2fda558057b7ea18f258e0d51f191721fc1dd0024cd7c985ef80d2250b2108468465aabd217fc9e42299e14d7412ed3be089b94c8b5c94237f995341aaa32d5f1cba1aaf4fa5d34f039b78cbe5b5031b8ab1e73109806eaf29bff9c149910322f550cb81b845a9f8a51cd13e3b96a50f71c7c4d5b8cfbb68b8e504aa6bb170b2036048929b3f7877c64a9b87684d73e3b8d44c6479cccb89d53dd5058cb0c976cb2c334e4e8aafbdb1b48a028a01dad2fe48583ebfe0696ea4c28a85c3244b2c5181e3caca2198203ba897d736c4fc007806f9b692e30f3786287033b98562c6401e3be256bb358cdcf4e62a6bf8f0f6e325e1e3f509e50135e1a6b4364a2e85c23f71f6ec97c44783a1172e743c1130e9a5ec02ff2e404c30a7a57c2bcd38bb0939fe1e61b57b2dec5ab8ebf66fda1d1bc3ff6202e094730b555c0a88f2f61ff9ce26aa5f4ee0ea7b296425ebbb62629f52cfe1aa83d15c12dd34e62c6ee711c72d5821eabab497ccf690352f472344ac2af114ef051143f432909541ba183b066fc5ab81fb4bed9835fd431f5b713950056709d90c33c83d064fe93b3be884467bcbec1106a08e5aa462d3f568d9be68cb7adcb8cd775e54300928f85f9c24f9a61e1c2fcd33bfc57a1017b3150a0e82c0060505ff38edfba50ea460e3782b6dd69f0afa1cc24f7bb7679b3d13f5550a94f1ab5a29e1b7f64d695760c1890da5ab77c6c64b573f3dd3ad1bfbc5a8a9bee4356c159167f4ea17e19f917d9a79ce00645477db7ba89154febbafa64436c00aa1111b35929fda4a0f18a485ad14f6dbe87eac875e07314a635029b8e771ca22b675944e9cd9a6c3586493b5fe9f457845bb63d7439cf722f383e11daf6c711a5cb53a4924e16e76d695f8fa781c1196bd0dc5d9171e56a57795292d2d3f15495b32f547879c1c2d4c50a5d45cbc9558d78b4c766d9aba8d5673c9b00d557fa5d9e837cfb10647a869a32be8cb0a963c365cc39ece9776df5a5afb7e371ac7b157198c2edeac4e296fc99aacd8756c36697d86862ee9ede9370e829ce25ef0700fdefdb8afa3ac9ffd92797636c3c8743aa82468b6f1464712faaba583938439d2f0adb1689872376f8d76acea66228eac8eb518a9d7fc2495674b9dd840d515af48e018bea750ea190fb4445e73015755393888cfc7a28d01f09346b44af9569b952fe5cdcb728b3adcdea56d486141043e270e08587548556005b60da98ac7bea4b5f1bc8eb858327d3f5bb52144de038284a397d67050ec78c58c58869232e593cf52ea415312883b6e953a473260ef8f5dfe8bc623314dc161eb6f40dafea632f5305be3eaa2908db0706d6f8103b584dbe940009c27feea37d63e6ddf2a86be82793dcdaf4126086791dfb3567530d9fd35584e59b91b100e75edc6614546eb42ed6770dc504d37e5dbe44c8b27f8efbb484f7b26f7f96c9548a50d985220dc990e47629a49ddcfc8f116d17ecdea276ef167e2fd8d1c5eb3895e92f1717406bfca06449a0685640a751e3702d9637f73b0a6928dda0d61d408780e6027f9758d8974b287769e3e7264abe51401d9c669fd18fc22c6d036aefc7ee3dc0b05b680465574647a731739fffc0acd2e63e802df72db96fd352108e02b4ba9f38f49600d0df27b5908db386cc019c6827db9f04f2593864c49ce9ac15ae352f591aed0745c7ba5728c0d0508ac355a3f5f2d627517643747054f693c73c9a6c870f26f05dfc584b713e39a81705e2dc464e39447d9d66cfb76f00bcd808585cc35a9bda33a9da01304760bf1ecece2447e69c5675f84590b47f638cd3f2ee66bbde8a38d7c45a050e4d7ee7aa6d51db53a7cb1c0684e8e34dedd43001482df7fd13362c112262f4d58ebeadd1723e290ef765ceed96ca17820cbead5a7b45c1c76b8614ce84bf2e0e9935b2d96587988c3d84f0de4a2a3ffe86da892ac3d8622beee8c39c0f149c75b7f67f2351c6ff0a04ec37175f70daa89195fd0ebfce5361118737919b3df54a60f1d3f57981f8230aa5259738e4bdaa036368d5e5b70fbc1ad8379d4bf865098073db9739859e912312340cb518a13a1049f04d316ecc8fb8de8b584ac6b10ab6dfb674f8fc5b84683b9cf3c078d69e084c3f1e0bd72e0e1a6c838dd74de5b1e2ef7b4958ba8cc8edcd14d2ea0394abbc079fa3a4da13ae8bcb48e065b4e007ce96d9a0b2bd0d2b4bc4e02b737b3955cb7462996aae8975bedb487b7d433c6a6ac614ad71991b24d2fbf8bcfe8e477e906d2388503eb21bdb70057723877674336ad82e91695c1b5d82d965e71487e385d76b35028bee6f9b28b84479aa5f55264f792b5d6dd6f1509683ac79cbdb38bb62666064a7470491677775d9a8ddd36f8321ad1a9b7a0910055d996294606115c408fb8e564589c6ca3cc54b134a8087e623c6228509e909a96ffa3c6abee62054a6d54b44bf62e4988a6cdd1342963f8edb6f1186e7c5970ed09ab7397786e18043e804ea73c9a13e3e940d3e2ccdc40d54f691eb2e85d866768783471fa53b53f6853e2faa7a042737866b95a3b78f02902f056ce2df68d16ba79688314bae8db0bd134c93cc4009b5d85ba0ad7a29c7b76bc4d7fa5db81442fb1ae751f218e399539574fb8ebb11b6e8ad760f0f08dfeddd4e4753d4463b6593b79d6cc2d3bc5439a4435ecf27744d05f261e3d3d704bba967457cff4f723a920ee152bffa6e086fe48a1eaa6e1aa11aec312b07393b5eff9c27591c9e60b528116d2885faf5f3a66881f0f286a34b9cab9874edc51c4351248d908a50dba5780d8a9f1f837fccbe9d90ccfd8519dafbb8e73f4b59e3b47a7ffa5097d4a24e923884765c12b45cfec805fbefa61faf471325c67ffada33e909c6fa9e30be774243d675a520311ece773882fee637966453acd3be885844e66d253c953c7a9bba03cc5a3b8d4fe9e1f7ce10d2ac8fc739a4ff939d65c720f15186ea313341a5df673709289cda95fdf5bd5b26eda8e5f99e0c105f46db52ca4b5a0690062e0872e9ad5200d021123b8df643433fa53d485849aff130fb0baf881777aa4470c6ffd2971835c43863cf233205bc7b3213c13f0a59c0b3836a1cf023b9dcb674dbf85dcf77c00de3076c0091bdd4c91f119fc136a46577abd323771fc3478e3f4cfef7ee5aa8761b53fa0fede0b04a377e16811178b9a8dd3e9fe2ac8a53771b6232db3a93cf7c18360d58fe347737e79725e87d5985bcafd5ea7b786d2f6ddffe7db1d63d8b69f2405e1dbe328e526a0859438d9cb07a48231064385a3262844c3666bbe537ff52f7ac1c13e12988492c01f145bb96c41c7898b31ab5ba7ac622deab75abfe15cb8191c8c4218649f6dc2de8c26783aa205cbbfc9e8b31c533ed78cd136b491faa8516c6ff1b9ae4d8c23d67c5c696b81d7c18946ba0c97c69c3807491cc90c24f42b1e5ecc437ff9629be692971db0459beaac004fab64e1a7ea075705b303dc37e0b3f33876237ba43b6631ae089c4cd784b1e10f5a103a4547a9c9d97d290cc7fa0ab6c6c1c5c1b2048708292734911186e37c172bc1068ba2dbaf385a1d8db5ef37aad0907eb118a303e1dc5a0657e174c3b5dcd4df635ef3c01ddf7a7457207efaf7c3c40babd6c22b492f460b4d49507360829a228292ef253cada0b321a786c6847c866db73cc187774b10d8b8c50214737720ff1677a18eef18736c7ab7d29b1e41655bb4054dcb168f3a2c8f571eafff6220441590e55f875c84c7cdb276acb3b4fc426be0efc61cd407981fa38d75adebe5b57a5690f65c268b65e7c04c2ecada3e4dc4a5e2c27bcb65fb27f919c4ba566f0b6f3a9154e8e0fd7e536f1f5635d590d7f5b00526272252baf93970b3af3b17ee13ec6137a2f9634d712e68201dda83a485ac194132e67a5dd5b0706258787080e822f98d757d273a5be88b25726e4f95df885960e96e848f96207a60f38c474a7b2eabc6a129e3439c1b00237238b1a1f0a27a5935af42d9b16fd793710544315733b3f68b3b3f0984101da590bfb34ea9408d11af478596eaf47959811ed9fbac20f64fba294019df64a9872a233157bed683cc84bcd859b8bb5dd5db6350712d0704f9e31b98f5e2bb5685a2b8abbfb33cc00a5c5810e4368084c09951ec30aac3092b564ba2caddbe9c1b7a997a393ca692667b427150c2bad82da586e2319ec413052bdc1e910ac0b335a562b5ecc0f69806737ea106e8994606339c2901bbf27be8f7aaa29fbdb9e094868e2fde3c21ab2473decda318cccc45302f4c87d1d1c8965f90ca8b23c64586e3304767e411c11506d1e8c990b4c1ac049773fc6bf71d675efe81f791e5f192866f6921abb7666c34946e603b3941b18cb688d3ca1892987def1c277f883e399c4311acc3131a9652e947d2444aa0c7899ef36fd631e093fa35bdbec4382a5cb655a53a388772a196a5240730fc8d179c237d9b240d2cade112081e1e4ade9f0fff2bb72901667103cc12f5cacd1b919d2a300083c4faf67c9d5b71b096b09909584e6d68367ea4dec49d6468614f6abbda4155bd17c9a20ecfcb73949e659ac4e6934b3b3e68623870e087ac4172e9547d43c608fcbd89ef10cda5c5bbce21b795cb79f063ecd640ad9f11f323b8e754988fa184a2d515e8732170c85f8c1ce8598e5bedbe8b20f77f112c5cdd8c05ee0464312bc8253f123c7e5d2f5fecf35e91fd506138fe95cc1033747b8a43934e651b5ec48f84bb5617188d3d276abb763441e898772b4beb3a5ccdf0ae3554b3d0a1870134d2fbc4670fd3f3806fb0a97876d2c7f0db2624e7782a79088cd5799dd12d29014ec5100669d74ce5074f41738b16d9654d0ca113611fc7e70742d1a5a611d444cf6a974da26eac45e8ed7f5a728c22f28aeeb2ab9d37e7e8e92ad649b2edb64bee2aac5470c74317b384a11d0eb043797d6637b157ab4b28c5b12d7732de1ddd92553afd4ed0b97fd9efd6fa9f76f904971227fbb932f0feebdd171dc974b45c750f3220c6a42d910a35e2e59b78187e3d9030dcc2a47aec0b519086ed1ef4afd317f29900a132df02379448c6b4b090ec0ec7a2ccb4a70f2e116ed7fc2a0dd2acfec844d3e9ba25442704aa9247e2bb68cb43d6d088b9c5ff3321c10bb5be07504d9a62f5ec6cef5af2b8c3932b6265ab6eaf953fead23e54effc25c58d5df3dfb97edc2c292a9dc92a819df7017d8c012ad062b3627e1b0c06bc1034f65552af3915606d99fa49f8588420bbb46a395bf2e9f2df929902001aa9547eb95f211266fc3c18c6a3b2c966d3038c3dff8e20e78f82f991c500595dcfb1a5a3f21e4264a78ca43cb1dcf047af008cd6b12c5e392d4ac677f447ceb2b0e11cfb69419c1aa4395a6bfc9fbce24a7bb2065645b175fbfb03416ac174c39d70eebc769794dcd60acb6a946379b4e26e25c3d1ddc83e82d85d78344ca7e3b0e56f9d1b6bf8953697c137d30ab9ea21146d11479a2f4efab26c7015ed0c5df35ee5ad5526f1f05716e0cb3d35727110baae9053616869091a603316b47bfb5fdbd5c83c04768662be4d03f2174c6769d600ca260bf0a61da5f6bbdd18692512456c3aca68c1cc9927051c6e1fae6821a65475aba151b92f4d5b345f60f47f39d0b3a48c28bfce7be82df3089cb6efd2c9f98348d84027b967ea25b60204a21037522bf94f83bf426feb170bad68e444481dc70f8d3d05c7775dd790ddb50c9990ffb1561e976eb412641d742b3c8fe0c3692a6064766734fb576b9e44f91f1625627c11f32270c3f5cafc1045b522587c1d6c28b1b4e07c8d7739ed73ec3391a522e38fcea6828656bfa6b4775c5c57536af90468b64d3052efdaeefbb15dfac08a456a66aacff7d1d768f68c3a8f61eb69512c58f4f1f4d7bfc2b451d8b3b6b788c383f2e22ae945c2d96b6e5d6816a19e0ad853ba57ac8c196fa8dbcb16f1057902fa465450a33ac6e94dac1c4d6995eb2c9bb887d125de664d813f4ecd0ce8d632b133b2aa4b2ecaa20f42e02b7f2f1370eb29df0e25098bd1c34d6a5c5d26b57ee153f9e809cc423f76efd7685b8cf3036cf84e9ec2f09ce7e6386ff5ebbf421a96db0dd9da6aeb5f95540f515c539eac54b4a765840f4e614d5603cde025feaeb5693534ffbf39b1985f9b857c97466440f2bba6323bd11da7d6653e49a7afb3b7b103f1834418030f39428350ea8a169c90fc06c7310043dcdaa27265312fbf3ac7b869e13114ba1aa77457f0ea74a552f3ddada2b7647435515d4f864165f5101c2f5d451f18972915689e2373202467f81aeac98836e94333a890f51e71126653d4781bdeecdc76d61ed113e41ee3652e49b489b2bc2bb77d189bc06e0f484b9ea6bb07e327ec66ecb8b9d59e599b50f6bdddc5ebf1ce9b7d560432db16e6f502b477e8ac0d7ef930170a50cbdfd877bfbb55f09c6a0c20cfc61849fb0361f869aba5453f41c2c1b1954f86eb0207b65911f713a1684a602590afde09244fe7b03eb2a1b29a161bacb685fe6b9e4dc908dc0508abe55fff23a2670b0740587307aae15d311d5b1a89e49cfe966fe557b89e0a88aab4acc18910fc02ced1e6a44886d7b9e9a917fe59061c9672d617faddf18ba95930dc7c8b6498c8945ed8e35edbad991b87b9796117cb90799d6b595c2df8df4db5b0b7f9243836c1f2d9e6fee0dfd8af54d32332f386925d5cf3940b85ab15f9befe5fe639a463e11d06d9cfbd812945436c9cb62cdb41eb9e6cc70d097be49b7604f22b956aa3283b69dc515aaf6b23a91a41beb901cfeec7e42c29c8edd6551542c2c1ed229e8783d3f9ad7da6772ba01d2de4bd94c0e086da93a7723d856e4b350bc078c3c484c784db1159d76dbdbdd35d5c0d5974824d23c26ba8568714ea3ecfc85c237a72e88010f6016e6e8b82061915d3ca3c1581b5072ba24846b4ea6d6809c2e7a47db01dc7d521f37ef1f29b5abf8fe38c61516ca0f2409b70c249d91268402893849906de48009a28c80f26ac7f191ad4f3cbba27b14607bce3abba9295ecdfc1a71f5354cb74de4b214a9ce801b2a1fd29c33b146fe723d222ed7ff6dd75b9b654ad3cb71d892e21695637a2e9f88591785e0b8abd04cacf79fe45a35be39c54130c8c6d39ac9d7f643bdc4c77a063b716acd4deaf1e9b0765fc0ed542df819118f9b24530081e03fa46b5107367256588e51e5049c8bc78195a8c9991bde69bd826b00a39102f0db2277259f760348a342b94c86511a6361c166cd398839b7aba6615cdbb5afb590bd6a5b45c38c21787ee92e721875c57cc6d604c9d615a2d587a4f06c92e5731161095cda3aa606e9002c22cf77af88d358d3a40972ee9237ac5329497dff387d727a0e3ba6dc9f157d73d1ab29ff547081d14e55f83c76ae239ca162fb33c26d57132746680d4beae7e4b90cb49b38bc6419dd14eacb0efc34f854eba311bfce1ab89aff7c28797a482dc5efc97f88e18ae2980cd7b632c93185776189085db4bcc866776f589e8f94f4b5d155e5aad6d7052a2708ba2eaf6d10ee0bc48af34ca46dab47132cdb1d4d7c04189c9b297469a66ac4a012c013abdd409b5d4a9a6daba25e5a9a0c199e223d5d49d88ef912c923c7451de1f892f408dda40f8e596d4f60f8f40db70008c70fb7a2cecde3a9e02baa0a01e696107e1cb3ce88695a7ce2f33a966a09b061c8aa34d0786d8b87d5f5448fa54052d450f07cfd879cab1e676befd754fc3eaf96cc3b1f973f1d7676fc164c38314c6baebfc98b130c8c4317f71291762eb912a57699621be6aad51a911545f1423a1ce795d910dd7926165f3755a9a59f3befcb28f2cb308f48fa90a8dea3fa5aa62b52a65ff2e320a2dc8f4f9a8cd7d94056f221817659a66a4f2d6219dffef211c37c1cb23946c0810490f4abb372c9f5cdaf40e54b985821253c0af3bae15c413889f0f36728003a4f563af9aaf56b599793c939d67f93c605dd6cfda7ecb1d8eaca1ab9d7b89e123b5601ded0ab75b712b439faddca303a8ef76c574b6cc6afe9baef238e16ccbd4879a1cc1cf5f2ccc3dee7373b739f950efacb19d168d9e4f42ddf8c176deb0bd2a56ac57193677032e3fe695f063a635933828a65a35aeaf8902e290b2da1d68ae2740ecd4506b435bcf49a29ff805771af9ae4c41c7f7292c9f379f3e5d08c59078f2f27e8d63d0318b5abaa1f50ed80ab2c1e252d540f9c131d812bf235dbba284feda4f87fe3e825bbb46d50c9b6757e5dd58fb98d83b9cab147527f988475d5bdd3779f0590a79c12d74d72f3abe953b1fb81374b9375003536597c26a0b5e25ef4d17241f3cf37a5976aec75349e90b386a9392dc1a48d85681d49df3aab74d6ed296f1d47a93804a3c0f3c80cda2a1cb95172a73a363107eaa880fe85465b832d1042b6285cc943ecfd59bdbca9d1f47fdcd91c1fc4052777e301aa6dea824e7cf5af161a54f5e0918d2eea6b12666b9dd655b597779c810443fe204257f1686c45b72567d4447208ec81a9fef54eee35f348d46d7da4d313ffd77ebbdd665873b70ffad209e26d4aa0cdba50d368df97c9aec3f4f751e13c1b75246abba225a34f23d78cc55f7903ff6475668151c147a0b8128692088c8eced4001a9095c9263439afef4b8bc92276082d2e3ae4f6fcf5506bae4013c0c75031ee977bf6f003a0e63b662f3350a832279f9ce35ce74a876c08b25abaa3b664211ef3fdbc0507656b37d1da3f4d41ff09aa227986942d7f2104fb08cc3f35613f820f8003ccbd8f9f2a1cdfb09cb42dedf739bbdebae7dbb92f5daea047dd52fe8e1b85d6a1fa9e1010baf78c128d91523ed86f8d06f150d2504a5dd0ad62b76e83fdd1954f9f5f2b78c3e6d1fabca861f9af8fac31dec03f953327553fb9a109de202d4e7617426090a9423d8e6ae17fec8bc42a739ef8e44587d58d2f140e49f421a5d52080f408d5335258b441ad6d016e17b7e99c95de1def8fee6d678d89e1a454137b0339135e4dd255bb197256c1e35937bc2dffc397e6889596128dd9cbbf635b1a825b013e992641c37a34b3b37ed7787ea16d7b8c3e7b9b2dcb39ffc48c24389898cb0b59b3da509517352a0c00b149826395d738eca68cea65f587f29546ae68c7ead4f84c8158f12c6a0d23f4acbfdeb597a23687b1bdaa7a9f2db874ffa1f5e341dc21dfca8e33de3ef3c10507549e0d000da1f16d3c491e32d8d34fd133a7ede184850aed25aaeec4e127d142ee058058807a6e4d62d9d31854e0645c516dc426286299108f92a5b6963bf86df24c483bca187cc76d246740584bdaaba8335408a4492201c28b1ee082bffd3266680c49b46f74149e03bfd4c00b6dac545d4451985dcf696aa2ed4b4af651b20fdc9fb64ee2dc53ce62a2a77118844410f9d76072cae7fbc11d5a7a81f54ae182852690187a1db5fe221ebfdc279ac5eb29655cca88b1491369493e9cb3cb78c0a698da517135a69a4461f518643a6da926e83afbb828d15e09ac8dfaf1fb286d5d61631e822cad91fb1e4ffea133210c5b5a03b5b873b3df0084e98e80a51c7c7ef7d5c04cdca5328fa3fb6d3ddc7568c033450ae2acfa87ea8ebca935b7b10c4062941a2e05a324a8e53414b0bcc874ad585846662d586867664f8220d92753c08238a1d7349462f4f511a797c0fe0c1deda22d018da695dcedc567032eefeac1f47d04303dd1317df3a233004f8fd662e27d1e91ec00dbb9c59f66ce92b9d7847bd0752492fc7b7e108b523f56beefe6a5f44296098bb317ce247c0efde598549b5a3d4af0553021be7ed23774a85af167958ada4597590ec92769fa97d83d0d9f090532ae8604ba23bf6ef327a15c74bb7d06fb8dfe785a9a545a41ecb4f6e114dc1e82c9274be4de4168191ad7ee1296b1ce2e0fe8f7f169748e5d9a34639b12687bb5fa045090ebd71add3948598aab02e872db69c6e3082e393959fd54edc43b295c7fd3e83c400026f85d5ec7e364a8198eba54eda3bbf283255b3abbc1751992cf2ead2d49a6ffb6ddab7ca2883e623281b26381feb2274e8e7bc8c676617dfc04aaf2f374424f283f0bc571f97f1fe7cee3785b2dbadff94e2a6a8dfdee77cb2d921c82e0a494ea2d3d08bcf6839339a235a1ad05810c4e1fccbe15b06fafa3fcadf2ebd6f021e30c4e61b3d4bf4de404dd34a8d4fea33ed4a99bef7d5172dd6d0e49b367db7759aa67741a729301fcafeb1987c1c9b92fbf9c34dc2e6ca548e933f40db54bf1911d813a8bcd7ee5c15a3f7269b40244d33c64c18c95d8b613fcc174c0faafbe84d45f0e82ecb97faa1af7dfaa3e949a156771618b608308c70c3bc012c41dbc233aad9716e5b89f6469a6feebb6147ceeecc672d988038b10764787c3e14db0fb6ca68dcb6bd762a9d100b3bb4c93d59ee4a53ea59f1924f4b37c55c41cb641b97397669bd7b860ff6645e840cf437a608bc8a06a02b6da25ea1901cce67b51dfd00a434e23eecd802cf9bd48e5fa61b2fad940fb3c9ba9fc4c324755c2604080bfe17608ac01860371af52e6f9947d42311f282931c6a8f9247dce13fa68a2871254117513dc148438539de70433954ecbfdfacffb7c97a47c5eab088fb25eb339a95ec205d5a5d1a42678521172b69b0ac0180c3c9b450daf712797a5f30ceac20f13e9e73f7e80748265cfac92bd08d319103a27bcfc88b1939baca3ac07b28a978fc629bdfee32e47109be4b13dc0b2b34b9772317e37badfc10c800dbccd11376ef5eac560275d3d27cac8de8387da23f5c5314662da491773681d5239de7227ed0a5dca1acd7f51c30ce0dc7e13a11fbdb339983ca7a3ef14f254b2bed1b693c2b09808dc7f662f7fd61ca72d46d5fe9438c2143922654dacbe78e3fba439027f68985f7bb2e209ce10390e7f6352a8514e4c9d4585527b229d9afadde3f75ece6590df56c6f1118939acea304477197be31a725ad1b33eee948db453c4298481773473da131f1a0a3acbc79146dcf77062ff5f5de4acdd49adc9d012720f9969d1b6954b85d65a3fc804c4219852bef9edbdfe1e5924501359db951ffe22a4ca33a03631b70864be9fbf31491c785932cc136f7422f1bba1d088c17b2b93370acdf4facc4fffa7b2b68939f86eabad6c1b366258797ce0e30f2a591d19236fb572f599affc922e664b64a1b21012a5951e09b1c10899f9e8dadccdf797497c41152f471f9065d2f710ae6af764d4dc95cf96dcfc9596b105471d457b91ab1954f63d65ae05b9d77005ca690b1e9314cba931fef58a1b7993be2c45539c390714d1314925444b95c506787729269d2d027e12ac86ab2f7df4dac80dc2e01c5fe3c756f67b5432b8d15d85a6ec6ec949e5284ee40a9df312681df1c11e17993c4704d1f8b7ed4193f17077b7807e8ef4dde3b434479c8ee75e06e3e1e748cfe29a0c43a6d6d58bb36636cf79cea8a492f9606c6c7163e4b3f2b8f9dc7e57cd6434ac43e4a88d45400f56c1b86c038e9c968e4d0a04955560fd5edca04b32a2d42aa347e79ce41ba86aba3c703c37bccb3f033dbe98f3c18b467dc280740c9e29b9b690d2efc2f6c37b679efa9be4565e12b1221d83183cb68a54682bf07e3b37641dfb2bdacaab22ad4fd5aef12a637a0c50163c008f777d363657d9850c4d2dbd3274a2e1837a7ee82507e876b6688fa5553cd58c7cfa832bfee97549e12db5147881266354d36c2e982fdf51d1547e405f9fad287c79684d13e5d6c57329230c27b8f3088ca1dccdec00646d8b5c1c36c3016dc13ca8b268d230acefd8043d4a5720adafdf8276fabd3890a866aa727e2a721c741206a83fc64b153b6ee4dbeaee5e1a908c3f0ea9e5fdbbb227592551e92ae3e5ffab6bc2bb836dab37be3c44ae00472e5a0ccf523c3081cfd56183d99f93511a6eeba64c211e4413e97d0b27294685b404cfda006b0de7cc52ffcb6b01a0b5d7b67075d3cde25aba22c896f6fcfc64ffffaef21ab523b1a8794b1604584210e38f5f8b0a2a310b4e695b8c96ecbda41436eb95e2d62c808bf88cab8b01d0ad907b53cddd533390ddc67b6a8a960c677898c3148cf9da33059739e31ed059d03f67facaf959dc65b9b73074297680bf12afff21ed5df793db1727f1d3c6adeadf8fcba55e0e4bf91fcdd9f4c1a3a3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
