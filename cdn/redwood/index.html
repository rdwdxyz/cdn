<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7306311550da77ba7d1021a25b3acde5bd1adae32196d166afebdd3a40ff89a8345a4c51a90e1267593133677084931eceea9ab9b67c6f70e6e7685bd1860d0ed3b4796a2796e158594ad683076f583df458fde89131e0532577f2a039c1855656a87bedd468e05d3c5334a3444426ef5767534e7404513baaff23e473efc59777e585f7c15fc8e7868b0bb7a91606affd472380c78c21c8d42a3944e71fe1062e9f8a16101dd70036ac6939e5a12e84dd7a41fc6b781fddf0673fd8f5269a7cff2713e7a0c2ac0c3f2644584815d481b18f66bfbe2760548bf62b83a2cf203121878a10ab5386b2c1cfb5273c64c85a3f47ff81c7ae273895d8f74de60ee5c303bec10814a4b7848cad3199d0761914580ba4f3fb0bf1648b2b12d47b329dfd7839d06fdd682af97ed4b7e4f12bbfa1d4228eeffe74a0e36b97edefd1895e4c41ffec54a5d24d27525a084412454e21419029c0ef71b5da149bc5ac5bb56d687672e4db91b9fd7cfa15c791944fad7c00fcbb62031de250dfd782d2496a190ccbf77cadd53b947fa491a08e9abfda773f8c9aba5557f6ac36be7ad814eb3bf9ab9a72c1abb3c1f5e6c5d9ce15f0162e05a5ab8ea8c761a4b648aa34f31c436ac8dfca1675d06820bfca787166f961a41df255b26e630a74b73e2249ba693b1b634bf9e4ed93cb4a986e1958f8f0938b00c3d5531b099bc3f8f0ccbad59b76d0e92989219a45e07f43366f38bf9d68d8174fba2c0ab226aaf0cecaf640d53e19be89f7031403a4e5ad5df1fa4f7811753add9f3f4262d2ade41f499767e8c8c77c7fc12a0e55ec39571ad50f158ffeef52f089375a94bbf47c0cf0743f71374ff27f759c3e20796fe5f1552a464da91a726ceb9dd2a52273ce3898e2963444848496300d273ec07eaa6c58a6ea4632543a0bfe5958699eb2194d656201d93b055f3456c94d36331ebaec876340e1b9573ec34555a5c2371137f62fcaeb57e3d5ddcca8471472d4b16bdaf1df46c86b08eaeb081babf494341da6f494cb93f4f01afe8ecb383ee9e8a62d89025b92b23aa77bc064d34509908cf65b43ff7be52e1c71e15bfeff6cb63785ad9ccf5330c12ca6eccb4addd98f26934c3077aaa85e5c69ff8aa311e91fc145f583bc13b0859be57390d1c68f1a3f6e6a354ca8c74f03c3b7b10a0d3f1b59c0969bb9cf052d8295c803eb8fa62b7998e197a687d7a60a70e23e8127cfa4f743c2c1535a7a8c96de3f6e016957bd9abc64c0b1e33c0a01cc63da2fd27fd124c936f54918ee1a8abb145bf2ac2bcf4bc43f5e2148b157bf2918b55065380079d3e2494f0aabe25d9f01f2abc80eff0eb40f0c6980d4683114587065a96675a713ab3e490e51c11746fc321a36f4d3f511503d2c91679bfd16b9d3e4a9a497209d263709bcd451ad97a0b6711901cab1662e453f5d90b1a091700480c47a0492f7d76167cf5a33f17f35eddfb1052b79426ba501a1c28ba27f34eb9e2b3fa48864db574e1b1c8cd9299928e6c6d2e9837182ce6ff4d7668bf39e7c5ac1544cd7409a009feaa48ab9e0d1203c1914ad3216ad781276f1013e69943dba5b707cc988ba11643da84da3aced8d10b9246f38237271086bdf6a3cd5251e2bb18af3aab8530059b58ec29495d667da6c51a691086a5b5c9c85883e3bad9c4654cef1b19d8cbba1b71445fd246d3ed8e41306e15d2ae859cac6330ce74aea7c41934ef8abed110821fcaf4da2cc4be06492e197bb75d86bd169c5b42a0016fdeb5dd6f89bb4442811852207b17da7a69487cce75763bcaa72b74d7e16adf1644c97d1128676305716daa900bd0f872260a987ac687016f1212e363c9fc5f99bed1ac35098abd826cbcc8487281927a9939a4f61aca6c1213130a51831b5c24153ee41c9068c1441907e043a9c4edff7eece4ff5a69eaf61e7d84b279665b3e2b7bf44036c1de22b5e7e4025d9880fb4cdb731e493423da426477c2b37f8bf21882e2f297cca330656815095744b02bb564c72a8c2b633a8b4960f970939d9c22ab3f5fee9c10fa42c5067d6ce08a2c436b8004048dc4a3eecc218d94868cf16eddb7677910d529c24440267a0f2b3ccf59e8b02cd061bd21f2f5549090c3505fdd330439e753e03193294e51e250396862f96094da927ec60a64f195cf35e2d633cec0daed0960d4dbbc15a9690ab82bbad877df74c9073441d44a8449aa03376231767d33e32e4d85ac81c48830e3f96383c0d4215638a5a979ff5bff3433af5b327a1e378da81e20ee793830ffbf9fcc1231eefd7be6ef906c6cf3bd99aeab339112e5925b2c63d70a4f53c97d3378f717214ff5fc659d86c1f99a818a860362bd16da439619005874f008fa0c70b9567749fee1d16addb6664c4a1cb0fd7a0f1f389f988979b30919fedbfd1d0632de4410ffbbf0521835d8770182ed7ba81a12db801b7634e2990ee0ea54d31ecf0f92f1ed808aabc34887f9bd7820a94817b5f8c0d0596a18a7bc012b60286113a90f11bafe585cacf552e05065b2cb481aaddcd799bf403eb6b146b9b3e723cf169a8efd6a75320918ac3fa31f8b8926bdb355c524c3b7d2c12817dd62f7fa0cd4c5f34855c36225b65274314cb9066c25452c2434ad12494cadd5db8e9c42ceff17726e8ee3b65c899e7791d2c3ea99a3559543612346b938ea782f6803eb2a9250eaebc9511f6884283a5a79854249e1f87c8c51445be006b8b22afb4aa7b8d86637af3aa2d31425a615ed96e730bacbdbd1ebf1f6ee4b20e6f71bc59f352df790096887b30cc3d053e122ba41e47a55bce486bf208388a0fdf83dada8fe40a8086382672773c156f32b67c98218638efaf7e946a94b3868babcf5c208d4ef79fc06df27b1d1a86d81e2886da414c66e80942003d40929b4db2697fc3359456b2fc7d28691a5c39889d35dff44f64243351322386d7161d4968b587fd1d239231ad32757c6f7d353475e03066435a69a0bf7a9f9c6964bf151c80b6ab0743175c91beec936ecb32faa275cbfaf3985b90510f3261597cd66e5c17a3211a86edc6517c0df9bde3ec595b54bba110c647135c271a082165688131e8a0afbafb821bdf833df9162e59767446c5070667976116a67c1ae4407692c209965e6bdfcd312e95f999066d4ceb9bf6f9fa72ca7cea4edd7af1988aa3053bdba4b53bfe69d6d1d91aad8d139995cf53636c4213be3042c6ec012a8f8fe7dab55da8f4e8abde8823939b1c7aa4442a060d399072f3441df619e1941062b374a25967a87dc7321ef6adfe36493b6fcaa33c8307f7afee0a919c11e26b301abe8aae00f1bc83901f1362261e5468fe18ec89258dc2685a46e9f03fefcbfa90ba4175dd2b3483c068c59813b45511db6a153c3bfde762cd38d4bfca40edc153398b36f72400ae915595d0a27fb05ed909be8fcd9c7d5cfdff9616a2fdf9a20124231cf9726f075c0bc4a9a8c078097e023b966666d4b59bdd1bc61bd87b83ce8c7e1995d7d9185ad82b31112a3f3ffc475c810e4f99de8082b965e81954ae4cb5acdd5baaa8a36e1fd61e67b67f0dbf4c605f958ab93d8f13d14b805ce20725ec9352e41a939f491856491370c310a75339cae635e35fb22b450e06d9f10951d460d92e632ed2bccd7366788f9c8189004588fc147f9a090014f8b90168babfdb5f11697f755d6c9fb3ee66d0d8d3a8af434533d6a556144d2eea3aeb9b835628b88a9dff571b2f3aeed9930a03680b01dcbcd673e6328d111f0bf951bfb8d51e357da9f90c4283838813b0cb1af21ca2b699e3288f9a1807ab4c5ef6f331184f931d030d0efba86b50aa420a03243cded7cb83e1cd702aaaf93bbbeba60f1081131bccbfd36eed248be56d4d2adc025e32b5af598f39b1bd736c352bdbd062daa8f741b01243ba06f1616d14bfa2fa405823f6c917e1dc07c6a87828697774deab27e4492da2c0e49d29a133465c0c67c4c9e6250fcd3906f3c45b899ec1d9f1456a858505ecf9c4f39acf74e2364bfafda04c97960dd87f759c036717235899745f8a190da00cea6e4a37691f0124ef9484bb52dc02852693f4e42fbc9cfa2de1078ecd0e98c10ca28912f05d3ffe14164163336344141c71376e0fa4c3109f0d0b11e113a370a0a77836c9f11b45cfbd4a09d96f7d8c952be2ab9323f485a0636f7dc381aca7715e3249f8f9d49d4f44b5c92828e02678218f7f98790eafc20e5a84875ffbbf25d21788972870cafdb34f0f5905d6f7994728a603d149388dc7134932e7bc98d3e9555f93289c8a2f239f966a901040a71f2fa7ba4b5f44505fdca9b3136d7373f066580658066991fd5f7fc2d2c149846cf0b8e4ca976f2b34fa231a8a4bb9de157acc6cc7fd2da4bf574ea24aec9ff8e4916498c1527e9b487550f192b61b6e0c765d5ae15fdd12b73e61cdc377f116e7b241f1730dddcf0e10c2468cb7f6a8e83a9ee0a89169e935f4e7ee779f90fc1c59beed7457d6e29e73ba3ff8f82b809c79ec791535be98d5f2d377e1253ea549281a5ce7bbc0a39b0c0eadb1457e3fb015c169578cebd7680187e480d84d94966593d086241ca563a7fee3bbf75b0bc5c4120139227de1a31fa6cca3b68a4e6c92e0b0ca63f36b42f901c8f18b6b86706f8f0ddf14ee4e60d752a9c1ac54cab4c6d897fc862b5572bfea90c9099cb7109c08518249e0900013a0281495db1e5b1092a025cfe76cd0c232f8ad16715e58c57e4cb0668db490004df3fe304cb64ae4a6bae6061ab22610886590397e12e76b598fcd9f4b1f551c7cd20c73e7bd36d83891b2e3f40566b103d6ecff11c2264f6605d5f9b445e77ba15e1441c31bc1f19417dc4040cec4e89b924d181e027bd5a5f7cd744eed275b3af13f15b5f14ecbae25a3604de0a69bcaf0949f2e63d46cefd7be5d9dfdee3fd7c6d302678e9fd48303b17ccaad2e3fbd03b08b9f118be1759bab69a4d762506a72b4480d3c4f4bca970e549968a29b41e87881570c51bd7f9e3627df1926f713d1ab0c0b9f6a1500bf8b38eb9111134d928a814749d27181eb1869a6b3e1b13a19d1cec5b8b707581ca0f35dab3a29a51e849d0a2a32b2bb4157708b81eb9a0f128ddde8dd58fd0977a0264f279ac5ae99717461249ef0fb6593210d367db1590d93343df6fc2913accfa4ab5ffb271db41bc246507bca13358381478c340b9fa9ee61062b46308f7170abdf7d0340bc9eb6d2a100e1c44e5b4caf2305673b7ae56ba3d86d4f2a591a6eeb4a89adb9a179ebe2ce88c405bfa1beab7114f8ffecaf7e7c1ee907f11c3df20dddd374188a12d724b627a9a818d976462153020564006700c33e5fa01874e183b2f58922b7233f02ba44f3f0c90ff289bc677cfabd24a8e3b70471b25880f1ebf099cd367b76847549820e3ec58a64a0f59b907ea4ed8cb1373ba7fe924e2b077c1b0820ac0f4b888214962ed894cc6b8de7de9f76c8f2d739414f79c855e0621f76823741a871cc70d785256ca762ca506bef690ef9ce8b294255b0ff64d82292614e825d66001b31d69609affe936cf1109b6d214651ceb52ee1e5261c276da227c3662a6fd02aaa6b5764998d3d86e0c35f95db014d55a11eaecf95c841a58f660a2e99e16f20ac9d52138dbe9b575f4ddc33580b131332a94b9ec819269789432ffa7e4ce8ff2693fa767b180ec87852b7917dca112254a78d53162d126edc8890ee1946c851088959e99e7eb68c2cea1c43aafd26b4014aceca88140862adc125f90e2b234344ef2f625281a2116fca17cb920727db5cfd6d9d9dfff823a55ca0a20255a045c22c227ea7685f0686ea13a504f93bcd5b300abb4e36732ff254d4a0067c6ba8e7bb5882551e22279f769eca598a96ab89c582f89ea3457eba4fda1a75a3e33ebb12fc3c5e6122e468e3070e485a856ad3537a4bb61818e50cce2dfb2171e393c6d9c4ed81fc3151ad8314dc787ab9ccc9026a653b615f1193b09fde17fb28f1de0bf1e806f7d54507a7b1103a3e84f7c3366900dfc3f053872efb6fc10fbcfbdf2a0b753f666f06477b91ad13a7cc28bd16d53dea261b853d14fa4539ef94c8eb8a00159c16d918c47c7daefeddfc1bde674696ffc0631aa9f4b4d79fd96ce0f89cd80a0dd399f5db711fefc111dd3f8611d812082ba5806f261bce245aeaf46f898ba43beeef35259834cfb582571e55b6a55162393b61d3bef0fc071befe9efb1cbdfb4b931e32e6f1cfb225e374c43c3315c1781f72fdbadee95cdccaa98f89fcc5ab5dc2d00830e8cccf5add84f664e7b2b5807287fd36c595e18ac0e549c7ea21c2c0669510a19d424432c068eef3fd0c3919c169917930abd95a5289db3bd260f4ec6729b9baf35870b1b958b6370e3fd87ab915cf2a71b57d9d99ea3f83a21bafd0eff329cafeae54876ff9fa9d0de264cce37e91036562cc44de3ec7d226a278d411b5086910f31e329467e498590e553457f5cfb8988e7794f0241bbcb11c3561e5be0d7b0f7b334e16cb249867c174de47db4be879cad856dd98d56cd45aa402888b5075a1fa376a0b5ac6e0a94c93e7bc6dae62e5ef533d97dd656c0cf9721286ee0c46b23a7c36c9e77ae12a254bbddb3307dbd69c922260f9b98b057d35f7659efbcd1fe64fbfa9e111f5679472fa424c8e3e26fb67f9f72a796986c2eefd14388056cc38e48ec1b3e717c8d730655786d51bf0baf464c70de4785cb1b3f0da1b5af89951ee34a248e1944826488d94cbe9c7af47c6a92ca4c5fabb384884a5256424206c87aa58ca202b068049c9c005054846c5af87d8088357d259643583a70785e689a12655f7a91670cba4c81863565e83174feb8ffcf389f70cb077dd41742eb58be289bada2a20870aa3dbb61f4bb4f1e394afdf8f7652156848f9b3182bf5dff4cfe9aeb0f6fcba66cb67e89046114cce55b3eb99cb544ad1a2615b0a4c2a24248567ecd4e1f94395a895f838f23f1e8577096ae2b2fed3d0ad1faa2fc945c67908aa8cf8891d3a94d37607da97a7e03fa7b8a192ddca26805580a8a10529d5ff67e7636cd061dc8638309c3393b7b830f0ce59a3e758e93550f4a9dd971c92950ba96ded69c6c93237fa149a32af25ee4afe63899f592449063f83ecedf705cce71b779c387f03e74751c7f0e89946dfa42e388b5216ccc382b4c9144a0c7fb8451cdc8e745ee1c7d011341c2bfa3cf612012768bdde5e549fea5907030f3b89514670199311f5e83bed9d9645399bf16d719ecd26ce7e32d0a88fed2ddf71010a2dc66767d0657483a0d0fc46708a626b2d79a715e08a9df8847795d29ed06bd7d69ef337b2b71983f514f69ed51e0b673a8bf67b737d639ddf7b0350529d84dad9d646e56805af1e4d528331cd58e277aca8e2ae5be853ac44b6ecf543f3bed1ccef161cea1867161d84e29119b300a1acc10beefc27b722915d47544ce79c0e136ebcfbf9d43b9e2d9e28e9eeef734d051ea76d3348914b33e195ab4019e66ea1d73aecdbf76edb6b380266374af14c585add14fea027406abc81df6579b6939914d50eeabce781cfeb3d770742902ffbec5bb0992238e993ad72ef055afdb956b2873d151b956327ae7f032e0a56868d46fdd36d2f8f11f7611849ef03651d049945212bb4a17f538bb7d02f90b0e4df403a0da15cc60a544babc2e61773635cd242028b75d6309acd4e881362fcb03a62b1256c0c7e9675725951e5e094e042faf6f4f82f6330e63eafda6024a00fbe45e98365701dd08593655a42e2dc24f668ef9ef81ac5b66c7ce0fbcc9d4cb8ea11e5bcea95f1a76f82bd12efda86114f261f69b0a337f1b57748ca8d277ec2c156bca15510efae910679af831379e2808908a03fa760a111c3b63ec699845c2acc7e254ef0cfda42e24ec66b218b2f4efcd4c6e94b18b571d07e5a90ba67840356227d0e3603c7a05d87432c51fc39af03afecd90c6cc0a1afc0d2767a84e8381b356c41687f781a514304bd4fc46572b0e4cb25635cb88f9272185e6f838b27eba7432774ddeda520fe8569a4f8724cf17b5e36cecb530d38062d2c1dcbd944274971e6fc5696d0d95515af099450a607db4afc91eaab111ef6331b008b518f4b9e46347fbb09ed87cbd5a2d3c3e60602720eb2c80783d988ce1dfcb5dd929a986ac9bd014da6f5a0dc7ea24f71d42d2d86c115c1b8da766f90c8164a67920720fc338160fb2d9675aa102b4b43c3934ac6b3ac0034250dce9db2ed8994a2838686739bba5b6d992ae867465660832d6ef45406ec9c2f1609131b6bb508f4b4dbf7220eb59efaddbc1bccc026c88fe356b638c391ae427c63eb2fe161e4383450f475bd40755fd4b87a20eab7dba9270c0210ff25312ecc9fdc1eb484dafaae3d75689d1e93b6a119277c20ce5833e7068b632af55a0aadadcdaa5580ba4a0c12aac184c37831c1be9338e8259170d7509d6148c91286c2bf18ac6063cbac4c4e2221231db756a90ca0f7e5d4629c8554e4fa8dfe521e3d4bb8c8f7f2538c61b51685b5c36df8d567235b66d248c20e2b00c923bb14e11448c2e8898a49b2df2d08837456c7c352c61b1695a0030c2785fefa46195cc607a9b500ecb0982ba60bc0793435f17249e9154dfcb589b1a53c51a72d2e2ca3312b5646a8320a685c4bd4c65115b1ef59636da15fcfc2f01082c5091284deeb893b7c2eb39457d2a2a455c0ec81f9f7bbd12aded06e4e94f77c595b286dfa49355ea692f4c60f544ed745186f05c1336ef3946b25c0945c048cb4c5358d84e8032bbeb2b97852186a4ece0fa5b72a3a4dc695f169dae754616de79d576f53f7b79c5589b62be29056a15506efcbb3e3fc7b62202b93d684404349d92303ffc2a3986aca8871d0f57e695a1cbd083edc3cebd5e9b9052f742360aa51623bbdcd445b2ea0508516c2600b5a566c999f1fe86d05842a2e5335efad1ebc4bc9954c40c95a575976920ab1f4c92f5f616066217362eaa98a3d0719dbafd9284a4bad1e61ca59ad2011c80f28071889bc6b7044eea5ac79b557abafe8dd82896d77d963edeaab62c48789ab484cf7d09d49dd6c4e430807d88f4346bd8f6c6bb35df23e49e98ab87f7760fe6365dd316ce6b812da22097d9051674aad404e4c47dfb3c03d274aca1e7905dd8581d4bc980ec06a9107698d5198e542df716bc48903d26e5497c6ec1daa2755964595db0403a798d6212b7cf7378482a86b2986444127ddbf88448377638a510cd7d0c8126170c0c54e112e3df5f40b964a909b42c5837849c75295de8d1f951e2fc5742c6a45c29a854f71c510f52b114525225a404a04037e3dc182b129783c96ded3cfe5c4858db635e95ea82cca1079ac10cfd96539c325dcf861a2cd70ed0f9d4285ca9960f95305890bfb9c955fbfb5de12345db3c1f453c2f64b9af630caf6fea0983aab270a571e8c4eea4eea7efbb7c0695faff34595bdaf0972d66983c33e6d58a446ddd9b52130cdd890069139bce9811c99bf12c3046a399b31922bb4d40db72426c8b2eab85b40dc5cd97c4c7cb7d0497578ab72f4578705cea247b66dc771e537f8d9373cf9e69e0b81fd84b6b22d3d5d22bb68f8e70ef4cbc59fcd874b11d4aab9a2445d1a4ff04d0fb57d68c735145cf1083ad9e2c0ab31a5844f047c3e72ea5f3a96819b33e9ba3fe2d89fc00862aecaf6fcd19243b50faa74544d87a7b7e02599351f6d15a42138e84042615624c1b861db375b88ace7264c1d752ca175c09916362c19f6cd71e33c4a782c530126a75e42b73ecfdc6c6b75c2c01f5f9bca58fba53f131842819bb9a35c424c4e4f76786249eebe24b8b247740baa97dcc49c3bc08208b3f37b31604118c89d065f8cbc7b4c7413521bd7b4fd79d89a3957bbfc0f5fec3ef3e4313d863648ddbd3553b7f605b691edd8efd57deb6a39d1626fa9daaf29f91f569781e40495497f8c717a2bb5efc0a18100e886ed9d2a1990cbca3e7df61f5dc4768a05ff3e7d375e81000485d9658c98943b2d7fd481af1d466f3d2b39d708ecbbec9f87b5639238b4ca9d960a61be33d8c37ac1e1679cee4afdb777fcbe5756e5b9950a4b537adbafebab75aeb95dac5b1fcbe8185519c439533fb117ef3593e33d430b61229bd4c60cd672fd284c9adf0ce9fb237992e29c3c3dbdad20fa46f5cd50e33d6e06d45e6d4ce156801b81bebfcc1cf6ff6da61e5c55352d3f828d54c1774357a8ea3a1a58741657e090e37550ca4a614d90991968b3d3c7af49a6655ad96f3df73236fd04a51e58383ba193c34aa3383e6e776a18554911283811006963410d5f36111150a0fb7f471f75219f96c7aa9337da985f90f087ff193019ce0e30b832b95be9d923799bece638d07f595e29fbe5286c5b7ed02d29c9991e6d7615411f5d160b5d44fa388faae3509e52978bd6076e3f18606f78ecbe368febf8d847b79fa76deadd5c6392458fc1b1acf1cd4af39860d235670d05bb3ea71be3f5c53f2981ee87de2cb189cba0f90ac1b3bc0f5d4c7ad6fe3025931242e0597b55411948b2cc71a384118a95d01493782ab325f9e2618fd9e9b683b722df25d5689e5347b66a87f49b346889abd9b4e7d1805b0337a3d9de2a3e62cc018196d2972420c6299fc29ea1b61cadddd3e884bc2008b2b300d0d2707ab34ca55c7292ff62b6ed304e0f4b665abe9a92e00ee603b3b8fda284338bdfc01a863e8992323f64b4427d4e67465f1bd5ecbf69c86edec47e3121fd207abdf83316301eba26a53d4b7f652cb823269eb644c639aed35baa6859a486bc6276edcbbb06fd02a6a4150d126d282a70a67945892bbae201ef95660686e6b89dd230f5f8b3aeab1dd402dddf9d052006fa3350f928ca051375a0c286098430e945dcf4b8e4c7dae551eaec227eeff7b880329f56985df8bae19fd8e831f4375e1227de20e8293b8c13a8572f91f64efa872a5ac24e80aae4753754fea1c8cb00d9a659536b20f65882df23d01db71f19e8567c3c20dc9ac6aaa0386533dfea48ecd80cbb5f8a3a13990852cc34637c64aee117cef1c963883026144adb8d3d4387b5581ed868d58c7c9c4533312c0a8eb18a8249a65f8bae1caee6e55ac077e196ad6290de814873f80af6bf431a45014042f54e4e27407e6740c193f51d7c76a2a485603fdc550c864a06d8fbf0e07fabb5ca319b29cf3463b6b8adcaf47a3b5d30f082435ec1adaa510f681bdec1490b8a2cdd9d3b608c8476c9f3cc595738b8780b56ed0232f60ef71f441e4156d99a6da5ea54758fce5bd2462a90f984b1547c312b0c63c31234ce0d928e92aff529106efd12f4f2ba68a9f52d3e27aa7ed897eb559756ba789b64a74fe68a7229336828d4c25f3606373cbfba0ab9d737f62d09226a04fd064d69642a2b6ac9babc592bd90e5f6b5c2668148e661cf0388a7549c9163947184905a50b8d8167dd5eb61dcf15937363b42e5bc36a2cb62de968bf6b6cb58fceadca9b5c9f013173d5f3c5a69f21334a6e1fd5816a6230ddc2601571c26ee6e6dd0d87d9b2b374eb614d27ef90fdabebdffee40cc968a1e76963af415c7c0b4e0f4cb52494069856e42797a2266b925674107caeeee81acd11b7035a23c6e0d7368dfb0228023c240253861633adfe185ba708a347efb5099cfb574f8c327e0d530d16e20c0449e3820c57f859a5c9fac30b1d5c6a0b88a2a7e3c97b66bf782d6a9c68ead89eba1bdcca19a4dc073e80646ff3ab048cbaf33fa41dc3745e2da9180c0ca79a5531612b5b3d52dadefbfc9f3278ca40e593abdf4f1ffd811d12f9eb03b5b4668f1488c0a8f88ff5c0a2b0fb7e9590716ca14e70ef69faf44789a130cce2ea27568b15c74e779477fbd479d05581fc52c8d1c4261676ef36351247f66b7a7568b1ee63bf0b3531140251c67ea48dafc241cab86ebfa3498d83059d3d32fbc052ef5f8732977a9b1e723b4343c86e62bcf3600104609563e4d6ec2d279ad1aeed4bd09106b59feef7e2e75a22f7ce9f8693411977ee4cd22fd4be5eb0188d31505d854ca92728b4be4979f414fbc2e86c851ed4e41e706346ae1a03dac65306c9b957967de06de0b431203dbcd525fd2f08aece0c69e4d25ca21492fa472a74481889edd225c40e14b19d17b5a396536043ce3cfbca7ee60b3048ce58943095a8a4ea5484a2fb7e5164f9e6f895ea508913c74b94bee2cde62b53cd1fd76a337f8b4c52fe68f7e946b2c039238122a8626e0eedf58876a560d81e04314697d2fbd2c094749c656bb34a113e673e7b303b21e7f3efbb0902f832e685e0abf94d0cfcec7ed5f7980249319836078a6477e6ef34b4ab08dd09a16ae11cac391b929ff414f1718f1f3ef50b47bf86b84740f20cf7a0f514fd1bd40b5743962d1ff39ee552bd732442131c6ed5a0be29f570d6610add918acbdf50ee4f002624781bb6b81c172e9efcd2c8d7474d8f877bf2ed0fc2fa1fe1912b35282d910170ffa98be15bf525cbad4f48ba311977b402613257ef5fb1b8335ed976da94dfc5dc0196f02ff341bc53fd35adac4b97f1ff5153f52879a82383238d102aca1f6e982359dc363c18e28ae3c311da7eba51767e6486519e23ab4bb3e24556d441c112ce2cec8d7f47046393c615ba385f5fa6511c13c7903db50c46df0f231cb6deb473b49d5f847e921af5cab41879905c7f07d3df643fb800f327a2a2bb87e06684919b455e25b4b57dd680c010276503d3933890ac970057d5858c38321e321c2116e6ebd787a5efcbf6b2493a37e157f7a17c81aaeb3709e3dc41790d3dfe2b45a0518f24b83839461f12ab25b52f5200b5b5a32107b9bf9c0ac28878a6922eb09253844c5e6e019cf0beb212c022677259feeacb93df69e0be242afce9b907b1de1e1a2e960e3bbf82f9a082fc0520cacf8cafc08129b15eb7e5132572bb036f525fc58a67bcc6c9247a1b5bc69a76a14e3c6dbc31ec58e64d7d074ff5e075a47fd23e385b61cefd9e8d5c03df7d44af08d1240ed7191e6d973a61f410934ef62e097d193ca45cb54be32cbd4eba0d1c639dcf1cc01a294036e547eb03507b5d5f5c8b56d368ccc5a97965bc7283f9088ae5776da313dbaf411a88ec65c835604dd95324c4e934126e24e91ed4a2863f7298bdfd0f25c15a6f8ad95c8153b36e779db245243419f3b5c907113456f616abac68ed38c5542ed9db336582f226aa5772bd97696eb5becd45ea03ab5f2ea57ae19f84cdf3963638d1d7a57c9a7cb805a11c8715b626075726a17efd46d430bdd6f0bb3f6d60d8ccda15dd2632b03d381266cfdbe7401c542e5d6bf4d279d67a77ca408c726b92077f03ffbaca55fc926b3cbe88371d6dee2870f9ca8b9923f3f042ce4bdfc0eb8bb3d34751e86ed9706f408ebf8935ae04324925ad3d4f4202e99ddac6abbd4ddfb291f85cd38677008315f88fc9d3c011c95b08b38a13fcf0100308b4cf94427d135120e81183b120915f117bb40a404d0f5eb18cb0c04564bd610d2b03f1d760b823e96bc2a21a7b815bd2c2c7411fe9317ef28128d681b7ab2df8dff8909aef74aa6ee53344e4435f879eda7e7a1ad320d869f9abd145fc37ba026e852d7e7316881646b6507c571480211814757f5e9012c534d02049f7274c0b267c0f6ee51554460ccec7388d501e4f44acf91663275f36c99635b251a30356a1b0ab28aef0eebf1b556e484bdd6a7260777a3aefe2d9f70fb2841803b85b7ac27f13aff0af824cf44f89e486250c2eae99f5599105cb6ca1f73e9b8f10d3eb12d3792bbbaa9c9a4f37d33405ba5efbd57a2010c966b5dd69e779cf6b85daac75e1606da6da13bc969dbcf5b66f9374f5fec380e99ab88af2fe62e97f8dd994181de4288c069dcddf269b246fce00482021b2ad4dc194cb69f672711fee26e1732999bef449867572f688037348dc17de6e4d4c86ce4baf21e0b0e9ffb59b6a37d681441f4f2f0b5cfeb3b17636965e778cc882a4bae4cc6a7dbd2e897caab0e9a677e1d86bfc7b21dd277d2d81393dd98ce66cdcecbf1351eb7810c3739900fb983fa5cf9fcd7e903a1c5cad935e6e98efa300fc513226ff71c58f0ac63adc1410d2e9d4e552b9d6ed16a366adb000f24c2c4cba76f58cd2933c53447544b2471c71b660b5ea67603df4841f512aad7e7c1654744d82e49c2a8819a69387027d7c7cb49e722ea168de5a67fbb267bfc72b47899dbce4d080dc0b10ab6e6780d7835e42e85631e10c3be186331b6c5829660443005261ca3b9d3fefdee35eb8859d07fb4063e3469a5d2bf70d328c4112b7d5ab9d474c36cb02fe41676474df9322e07b8142576765a4a17e3a877e620b2ddbd228b60d4beeb45f23d2999b4088d663ad85bb56e7dc5cca57aeed60d086b099f5f94c935c1b32ee4a7aa28fec8d2ec8e79eb22893a421def57246429e0022fb664846e585dea7fbfb23fb81d6fa24f2ce9cfcfd8e07835545efdc35fbec8515db99c8ce50641df2cb69b95be00943d3d0df17abe28c0d482ffcc4fb2c32314bd0a73ad138eb31e108be91fe71d36acee3403ad8abcd6980e2210efcd969237dee7adcf53af663adfea1f6cb2d336fa5a390caee9a3ac6d125ca09cf223be9fc1f8a05b9875a560796d32d1d6362537031bfb63439a7193d6bc148cc0d16a0b4be30d5221e497e1370f02c9d6a912050549f6f97307977f234094dacf5946f0432e04f0af549a135502a294b6d7c2112b929764f152b3e50503f26068a5c783720aa40706b985d4bd68cb30ebde57a24e779c667d4dbad2eb3d466205ecb0ffeda39deb86640dc9d361b39673aff72587a091c9f03ac57b379fc2779f31b91627d3e3621175e49c5132d7a99b875b3a98e10e9bea0c7c674f1f573df2886dcfaf7862485ad96c3a574d262b8f2432354951ecb6505ca21a29add6193218cf8eeab5cb717e838bb820752f3ffd45a5983ccbf093fcbabdcb01cff223f8da1fe667165890770bbe0a4b0cade130b514a56f79bcba38ea29d860a08e312fe64d66187fa226633a9d906a2a8956b8167dcf06e2f6a5f763fe888152258024a2e094cac27ce7b578dd2b4632a1628c13ec8996441ecbf4eb8097d9aef06050dd88573e77de27722efb863681d330c9f53979b6c7df8ae3c041ede38d15c14653bfb70aa13a680725e8db36df34d2ba453a71dab759e5e8e4e90bfb1f3b6f801bf7511f31ca08977f961fb4c50915e460a4f23c0e7bff3ef02ed80aa9f251696566513db018b236c3e95ce419b2e84928cd8b68c521ce741ec3672dc71895ee49f758ae96f8bd31a70598a6bd66cd05c048e4326275b8057522471dde208da4ce864c361dced2a88e0921cf4bf54fdd131aa025fdd84495da94c2e251720f6c19d4dcd5852fe062422110aa5d66f0c818d5b1d65db658fc193f830985dc61624434f95a932627b70badc9a52fa8cf70719aeb23c519757aa7aeae11c95f23161172eb2183284cd20aa4b279fa6d465886513c85ced63fe09add6b0e2172c170c1469814d1f7b1b8d145d0552932fdd2ad96d2d996b680777ab516298174124c40c3bb7487fde694685b6266abd2c271458d6b963770c7191f41ff4ad74e9d4dfd39885df31eb3e0c5f57ed085d74cbc244ec0f6b5676f1dd1608757b5472001331fb64a7677d57237ffdb88dd9b2c619825bc66fd363a12bdb5c430b3277787a2704c304fd6c06052ea5d0d7395ee1389fc45e3abc5667105b06887ea721a2b744c9813e5e954844693748f05c0a5b929d58705b81b23ac133d2ae4f27f2e55181f27b7b4b680ae95d5ca4664b252cd1f166d44b0285a9f31c6795cd3fd1d6accbf1a7aa38ead049c8fc5e305ad08cb4906b02045fd198720fbaa6bbd52a16f7e2aa7b288156c9196f459cd4a11152d29efa869bbfca3c73044cc2a122094d40a7e71920be99bb41f4cf7c58210acb2f227ae8184ef88b5f57fe185e1397d96c70f7d46da839cc3ac14f503573a082401820531f0d438cc27565f962055f414b63884490be87de50ada7bd366696564ce36ea3d2af3fab34f3ec30e5f72e31ac6a2687035e50a18144f4df41cfc0f1564d7bcf34c754718217705d1199834c773418d0cc53822345857eea58fe0a26f566e3c6498ce7f301f51a2dece276d34aa0e89c32e32dee629617e9f4c7a6989bc8c9562548f27d42493bef827060ee536f5bcb3acca780160494b9f46d586f90dce6028c60f231cd7007fbb9a84848121061a011abcbe2bff2964383bf7cc235ace5d68496fd5a02fc48b93c8b088c390ca316a92451c3929d9ce74943ad3903e0eb1af47f6db99460c976d120970d5c9757b63e02ecaf76a4c47ab91da4cb403664f151354a0f99e9718c63213f60e708f1079627b2dd5bc5afe97bb988ba3e29c3377f2e7d13caa708a657364e00e7f3de4e1daddc3a4611a75537a61a6fc53838f9a9be8a0aeef5010d534b5c079d0546a833dacaf00768705c467a46d744c4b59a00d3f324b2f06c3ca4a3ea21b1077a8706e79dc7b79652f06e740e4e3d0dcf9b65485b538f0db9767542cddebebc73d97f5a1350d649c6da1737006ebd73892b0dae4b72f2982994f6573b245088d381cd369f7b032d56ffb8b45a3b2bc1ea807eed5dbbb512eccaae6be4118f8f99307ef8d94f1e97532008c29d17d0b7892b34a5d575b9c6e95b1bf3a3951d40ab3e2567773e682410f29f0089f129ac2ee784b452e931f8d475588a190b31cffc102f659f61fab340a7d04f54b0b92f38b5cf955708b66a1d98ed47cd3f1aa2eef25c84a9305e67768bd8cc75bd158da9a2334a1cebe01b2b6ad49ca35d256fef9a32a464fefae98f9320de73af9812b9c17dd7deb9e4d250807f5c54edb7263828e435b186cc473249a426f5d9ce70545b036fdfbb4ba7fd874c291da45a143946035f25c943c544dfd543ba2c22618623316e423bf49b0180e24f8afcbd12e6eaf78caed2740741c5a90fcf29b5f5dd79d97af59128f3b8b13d82fc947c41f40f347c9f3423eae8932f86dc7d854e3c743f7fecb7e9a0aff8ec18ef4ea5cbb19d0fcc2735b72f9236f7152fa38d1c9e08cf6ea3175c65208a18e809d76ab5450ad6599218b81a606c5bfbe3a239799bc65aec097fb397e8e84f1bc5e2dbfd6665334cd8a36a1c04d0a6894d1f58d05e84745726089f8f3ddf2be41836368d378ef56ec7391a45ef6bc044e3394b6146a65841576255b7ce9a4462003f48c44d528448a65ea6db823c07e82b262aa62ce97e1eadb2de6c9c706695cc707b8a131b2f8c7667cdf967defdadb15c135395c6651ba68d040677754ebe15f7bd624dce80b2031ac4fddaea2c77920247de7e84ddbcf03dbb000d368e5b5fae7e4c2ba50803da9342f7f6564c30b160b81f15cc86d5647872e0bf95e4aa5a8403cd63575c3026295d5ff52afc9ad3b3981483ca1e32954ab506ac797bc34c685414d550d55b72cbeb0da3b73f60bc15363393e2ec18d2f863228e1bf0e08c9a6b1d9af825cbc52e52bf07519c496b8321c56f17c44d940bece78f793807eda6a890690ff89877b11775ebf021530cb8b1a48a2455f88bb3571de836c0ab0f468c00083410684e432fb74ee884107138350f0d40c627f7a45992a83de3f555451d10c908e17d2fc28dc35ead2dedefa0c630e9bcdd4d14920735a66e053b085a767bd6afab7427f4de42f7ec926ac1a807eff559c480dd0fcf8affb8f76678a8e46f37ddff3b7c2af7869b6afdd13a03dff0fcb14cfc71d2a87089c4266d7f1be413ebfd385fdf6310785226fa74e9141203e937941121e28c89ae4dbe5995ccd11e46525aa40e350362f01e871a4768f349a63d218871cd94a01a0fb741460c931074f748ca49732e673d6b403b0800a6865161c83112b37b56bb73a6e00569f47366b844961c0d5cec96bb05de2f819d3b335be7c013410a2d4933b848ee66c250b20a07c0b07baaa44f611ef42d2bf4f2dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
