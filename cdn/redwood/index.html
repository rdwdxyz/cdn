<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd972c9c4fd65b924b45169165d92daa612ef4ec719e26fec1f285e82a4f6dde862301333c912d3d5ec7d901c58739aac3b72bc74b8f2a1362acedc1a6bad838d6bdbc239f26cf9c79bbe526dd11b143ccbde433cf8658b014b64a59993ee01c3364af209eaaa1cd5b9f919bc0c565ba6ed2ca55e9f713844cbf445e60884eb5aca1be701c0f343fa2b12da49dbcef692e2929842324d4ad2d92dcab967e01180660dab66c5cfb2333526b0b5b2df715482e77737bc9e8156634172ad35afa805c6524f06338c3fb6efb7192ed5181b6b7b499c3f40b7cb8721ce39a34759b22cc0442fc3c9740023a22412bce7d9e25b5550adcd64a510aedd46bbecadb093a2bc33e67c9dd7baf6f6ab21af0d98f5c9387d22c5f31501ffc498c304036d47b069f37daa43336e9c119d0a6da04ca517fbff0c4891cf9c87c65ad3e061316bfbea491a1db121a6cb800d7087f1f9f9e2ec60ed1cf9f636fdd6d0697f291fa7fd928f5e6b2968cbd5dda0613ca674ae847b9fd958772f73669d000b946fee6d50841d97120069e273f30516c3eb220f54402f6f4ec5cad0d73d2443a8f672a09b46c996ff7dde36254562a2ab9b61daa8cd9e90c5ffdb3d3bbb6eeed1ce41cd8828d67b8cebfa9ca0a62a1acc33c1a8254cfc6ed7df2ed32b930c9d4ec3ba10a42bdab88ecac3ddd5e1e2dbb7fa6de00dbeb2cbba36e67a9d0700e1fbcbf0593c57464099c35062b009f9cb1211f441791c189236558b6fb6aba957a6d2f6f7bb65dd205a8f3e570d633994c008014f268477c7a006d17cc654676055d8f638b9761306f8e69d182088ca7912b108185322c88d1735604579a072359dcca8ff9d0fc2d1a1fef821d041777943a4998888c3c3d6fb858c1dd064be9a7e560dae7ef77202d046bf355a849171b4988b727c37d64f05548b1cf657864321f945235b7b1d031c23236dbf39d82a68c3e6543671a6d0b1365518a092457ac5414b4a84435641ba14b97e6031827eacc439d03737e043a772831aaa5a111e02afe01e68fd1c46f63e25035c05983e0c533a25d745f2294ac22bc07519a6a67faa2e7be9812a6e947f278ded226c85feb579e0d8fcd38dd469c8b1a97f57f6ed09f5ced7bea0db46b2241c269d82fda7a72f64ec44fa538c22cadae7ae374d2eb9ddf317e04e184b02648c46d856c482d74bf1e5855b72bb1626caf2351cbcc919e355d7464ebf6fd2544aff0cea03eccd66fe757d9ac2c7e674c387aafa70a3f7655775f89f30d6907d069f89d50e6c257dff1ee1092a8f2db40240ac8cacb82c32836f2b580905b9c86ff7e7c7653152e3df8010e77d2fec64d0a4349bc3f84551b9d771762101574d688ad667878c1d563f6b33d94c29cacacdf3dde1b784df965de4606efe0d49bf12f5e631d3d27b28f16fc3446ddc4269226b5bdb83c99b1c34812b7bc2a6ee2189fc14d8c02725ef5e0ececfc3476470c0dccff55bf1c23a5cce4fc05ee0e400c5efb762f3d5e09ccd6d2913bff2676643869a67b3ea78911fafe39cc78fe17f98ebbd35431d230feb01050cac392aedc724d8ae6f77e6a8f8469b3dd0595d051d1385caf5315149d2b4ed0d5d002adec99f3b0bba94067cfeac94834985ff6ea71d5f912b15b3c5bfb94a3f721a381f9ec73e9438d7b5e0cab6487aec19c98c5cc1cefaab93f90797ccb8cb10bfc032366d4b237d1406aa8de1c73652ddb395f5daadfb6aea5f81d547b0b647db1be8ea9a0e9545d079c4d3b9f0c9c525b0ef0a6b79c6a4f1265fe1d5c5ea4c2b10bb81b5fc7ffac542ec6160eea733f4589485e9680bcc0e3682bfaa5ae4c9b44fab91d1a2c3d4ac5277e3652dd8518593cacb59329ff051169e59285947f9c6952cb9391807ab58c649a20f6c4854467702f8bfb531684f946911c9b630522dafd2d65598c2747adc5adc1e543e9a1066cd9afe6875a64a3167871d28bb89e6e6e411274c38d29bc8b51eb2eea57e1ab9c1b2965db659db4a9e565a7141a076fa9bb00fe1d293f6559ba3b542be8257a8521b5b1d3fcdbdf6f255c6ebf1e50aa58a391834c0ae4663d40742cc779d6097178b89d8ffee38d1fecc00e63978c393c27d2a457d94989cba18564f2ab62be3baa4bf2e9916c22fca089dc15effa39f2ccd2e7f0ade071581dd1a692a0501088be32c4a48ef332efb536b74391621e0c9c7ad1c904472f6529dbb2d92b47bbbde7f76ac2d2dd7f3d25df59909ca357c6f39782c2714bdd67c2e58d4f5329490f00e06666f5a27458a7d870055453c1969f55589d7e3d591e9b5f8c264e57e1317b318280318b849dcdf2bab12611f927f645b9fc2423d853b8f016256568e4b7d6aaf49598cf217454f708b7b821dd7acf4e6b99b20014aae7791611833fbd8fe91fd3926bf75a6366a329c51d6706cb33a8a9febccb1ebbfd44b4a142f2df12c3ca5d29348097b1ddc9ab2854c819060eb3e254543e9068690ba58c3e722d2e5a5196155e6e86ddce9679e21f6e271a71fdc75d51af61901e776824ddf12b34f88c37b846dee1c7a3b168bf925ff52ae1836e7281b2f3743e766b1c0569af52266bfcd1715a5b3f9fb1db874f512cbea078fe39159f821da4c3785c152db3fd0b595705438ddb63bd446dfec79f2cb9bdf4efb115dbe29f220ed463f7afe6565b55d48b849342d795c058757c080120537697f15112d434cd1d781a7123f53bceb28e4c9ca50503a25477951d6eb09730a676871f1731a6e4c89d56de338d63580bc7417fd226b38e4a0a1b10c3b444cc69c364237b2b708cdd2faf3549c38b0c2f633a8e75c376ba8fd64adf08a96015df9ca0331afc1f3ddd8ee47b5ab45e3887fc30c021c4feacc0dc364ed9141ece6742826fb994cff9ea641eaf213e53e6136c0b7a6a4e4873ddaf4e539d9f3a540b154e6d9eb3f195d41f300acb6df7462c98e491e65126881a2ebae62327654c24665bffd6642d8316af6097a9cbb6425185ed396fc7de8b84a6a07ab78b91000b6fa191089424a272b7e57851a785ae3fc50d6a968950e11f7c2d62e91edf9aa5d0fcca94d632628c61b6d44d22127fd23e711834ceb53014247db4e7184ad1cfd4532e056c767d6cff163632017f326df85ca6af2d330b34d574f08ac6d7a2922566bd33031c30b6f879ec36012bfe20bd314fcee515183f838b5bb1ac73e752de233b33acae0c9734ae062c701bc832ddfc83b27c13bb72c6e94af9401177eed834f99648d8b9ee803c850003778e780e49267762527519149d77b9fd29c942b48b0bb6978db0865ad8e0e4a0517c3acdda9fad7bf13d4047c1e0916e06bf2e8a44058e305d4dda36f3d7a1b811de498b17fc6e78ecc839a78558b5c74c9b3515349ca5d43c4a8d123ad67754f90e5b9a95fb08a01585a29864c3acf2a9732f0537e2d8d69c2e715c063f3f0b81525163e8d81ae9ddf5550a06fea3a12bffe1e2c1c2e2dbb7054713381070ac01302547fafd920c6937c9ea3cba5dab4a21ee57348022b90faa2eccbb6078dcad9fe4c1a7c714799bfbdf4a04fe11b6a2940e147cc9cb4e0cb40f35f5f8db8b93e40f82f054bd59b171036555d5993cea05537114653872a1c5d6e71de2044182677a534e80aa1af01796fe35519feba8650eb945e0feaa466116e6301c80bc0bd5b99d0c9af0c6978e9d06fc81f4b2a1c54cf83ba29cd909985d45c0bc3578e3c22dd4e53d84190e8aefe1becd5dda80803d2c34bc54235b03110e794dc81731871de520c922147c80af8b4c6c61afea383659e92ee158c4424e83c3434dc8c7b06ac29b08879208b918512c4a0670931e395f3fe35d0c9ff2a664cabc940883c3718b8996e5674e33d7c4284f3702a378b70cc43543db4900921adb875d182af7530a13e45772549da82d36fa864856210cebd64a96799e87b351ba64cec9e73729784e362a8a2a08d8c3ba93d837681bb628c852098b27d49271b74b9f5e582fa8b62d7a28fa65fd4ec84c3749f74da5e104d8e976fc4b279a5607464ef6005edd60ad44875d54266b560754c5efe8fc97066cb0dc4ad823373008e31cab57c7f70e344855765ba5fee0dccf997fbcb93870f4de5f40c9a7dd3dbe5d3be966330f0b90ce157d3dcc0b26ba405415450958def26606921527d9c6177a3f37c26a1d2275106282659d708a596e1af3746fc0a6b7082cb27bf76da15ecd3e76753e07803f31817b29593299f7e05a6209cd888cd621a8763ce1f87301a557787d551d7319179db86a8c5d53375937249ae4733f567b582dfdb86fffbf15aa513530b8215cb9fb84c32db56333c4180191135bc991a51a15b67f9ababa8311e24d448298f1e472b09637df3fc487edbd57a9b6790f4c4e41790e507d1c0984fe8cd29d1942a7a662a3b79c53fdebfa1da7f92ec9d95cae5d6515f20e9b90239b669fcbc277b52484146d5012c32fedb76a6090558e8dfbf2c068f8ec175ba60b1a523e84e9349ed3a926868a12dec4efb24610b9c4aeed604836e9decf7f22bb1989a1db553bcab83ed3483cb88acf059da387346b28eba4f2f65a5bcf86ea3579dcbccc8a9fe51402aa32c329a0f4423e8fd6e4c597846d2a0bea933ab51d22a82cf1e6fe0437a65741d16633c83b97dc61b10d69ae113ecb2570923e412453469ade14b1a0d92d4a4724dc97a6f4750e28b06d1e2ca32075bb87a1951cbcce06da3e0dd426c719edc86203b436186d3f4782f4dca89ffeef2efabb78597f6cdefc97f9bd215f221f749bbe0ba6276d8ee02710ee81257984511ac722f43c72bb5af819fb4552bf4061dd30b2177fb755e5ca16d15f82fd24792aedf7a906e07d779d4d83c35e180e184197f7eb974a25e0d50237b87f4dda96e233e55113bf7e68d86fa40da7c822ef8bef3342e87759fde579d35a07e11120f08ef7480ae0438b1b3535f0f34620f38309fd4c996f80b636efad82ef292ad0b71426c79c9a8630458a9661d59a117cfbd571fd7955401d0fbf5ca358e90de3885c40ca27b28d22e8a82b587808c901f208cd9d4107496b4773f629ae724dbe96189ea584a3572e412a9e6a395181a45cc8e10dbd9647479aa0eaf0191d28181c1d3decb7305799be3ae44325a0172acf1a90ebca1a1b35e7036859a474de4b865d49870b1e3993e6313ef0e26ea9510a7b25ed39c8e83f2998bef0a5580b65acaf9707bf79f4e2f147b5c08a5263c725a4c6e0793cb852c16d446faa91e60239177c560888eafb731125eab32cd553e1719ec934d1e0e9ecf40cf6daf8860b8cc1d52dcd5698787da93278aabe24e74e5c0a897ac5e697c66e36114694b51d2282cf69b31f76173007ca6222ac0eb7b17ee6ae89503be37ec55ed3701c9f8177907ac2ae4a1821d699a648b5c261c763ebce440370e570d98e8812ed5291ff5680de77850ad7a6cf6afc9c6469e835c9f3d71fb73f80f810e3504c979c8f383159e9477ecc4c28df9cc423c58ecfe697b50a823f2de5f78467bd98d1a96fe5fb508d4d073a7daaa107a986acb22bfbe053f0e606fb5d000322fa21b74c032f32b1d6d6ea6d45ab108587f87d3c8df2e142723cb435b7b8ac31104698a9905555587a5f1d6f2713a9b7590533be46dfa880e91c8f649829a46c4c6ae59e045d6d7c82c6a0ebcbd67f469536460cdab44e95cb5fea72c451a9e5d588433434ad1aff3a7acfeeeec4bcaf62e3a9c04ccdc97e0ae515f4a3a39bb072ae944afebcdb7d56d4982e8820e081aee1d77e431b9e9ad207b5a0d867d28d2c0766e72636613eb08faae763c04ec1cebf31b834dbf549c1662587a828b17d534cd76fc8842f38fef11f34282402e092839444406810cde837cab2a3358c54eeaab3cda3c333e3c1a47ec2dca65d0f020942f9bcc48b438fa69a4ad7f1045f6036e7146b1ac5d6e33d42c79caea81e824379547b812ce6ace32e5a43d49f80ef83e67c0f9c6819a0951acfd1fa224ca170a0b67a63f8e839c613bfae38a350818636b078eaeeceb875f65678c29245f530b7bb18c5a94d57aa2a279b60b0f3c8727b6b96754daf967600064e2fbb89c7d996c83830916b416d340f3b2153b346d6d38a9603491112b6b227e7c8b6aa3f9c290aca1789a27fcb900b757d2a09eeab4256cb69beda8136cb3c8be573f18f5f6b95b9a6e1fbef001713d80053554a2f08b9fa06b6d18c021ff990125e6186b66504d811165bb44acd49d688944a6c4e3c755b3933d4c600c8d76966fd0b48004e336c00cf1c636e8747e474486a40269d7e641d2212a6dc974199a737e69cac12019bcad477b7d6c3846e310ada714c33c7f0d1a115808cb1e2b692ab6e7096123ae2f96b679b91bceacea7b9b2247056960013993b3a58f46da65e2ccfc6c3ed093a746ea764c0c703da9e22b7e9bf9d39ef9dae945b3b0d09696b0f17ef115f99a776c281c991a40de05451930fdac94e213a4f038f23fb9faf3c21d379b87a1f84d04c2d0ec469195198d5c767ad88943d438fc93b12b8353dd09701866dad0f59adca4ed5303fb5133fa2e11b2e3623c375a58bcf65e1f2d8cc662d5324b5e50de551027c9496b1b1b2d5fc9a2b4e2da7f10a61c0d16efa05d435572ce37ba99f28c4f206c931c0bd9ee4b3018b441484b27c8c1ae1bebc7d1df88a0c722acab62c88cf2557f6b2308a564411b30bdcfbbbe4d55c01a9cb2f3dcd9c385906ba3b64d4d7358425ebed8daee334c5fc8c4d31dacc952854241ec62696ca61cf624b81ef3336f1e9c4ac45f35e9bcc451af6940c3b0be006bf6c11e3b25c68dc7c844ac67fc681bf787045c586c079d55655cbb5846c6b287edb5986a46b388cd2470cba9baeed51ce2ad62161ba4ed68bd5a92692491c4dc1ede26a49036a9c5eb45e76d2ae66ade799bb397c114fb2ba05668a3b1be1ffb999c686cbc7d99e2f32930a08cb6cc333b2419e86ac871febe065a3165683915d27a208a520570fe08246757fbe62a2d02525de333c127b57378b5b16f0aabf648ed61ebf3b17435d82034fd138de52d3ee10c25b843775c5e0e114524ef3b4489f57d804e4f4d8059a1202c8857e16db4a05c5b735918d99d9e21e9bf1709349b8c7dc8df95aa33c713eabce8cd5ccfe1291ac321ecb5bdcbb1a15f30b89b79da814b1796e000ec6775ef16bf25797409506d356db707e4f5951dc8d5adc1f0c2e43a0228c348c11c6b0e212791ad04366d13dde089c24f9a76ce8b751799b4c2bcde419b360123d0671ee7a3bf24186fe44294e7fcfc3fd2e0507f573e4f5d6b85a5ed411217161ef32499945eacc4a7b365b499bff140c7d4bc578be037912d5f33fb8c190477822a3889a8a716cbd0c2dceb39717a6690decd10d01198dffe527cfe431eb925faef36428cb40df5f0602fd030eaff17ec18172332af332ffbbc922b7b293386452560b5ae8e6dc0d4b31b7d473a90d39e2764f9474d270c3096b4a63b2bd780b3cb0502218106d8d46bc16f3b9fca78d65238e572882a34bfa6003616b4643bf915ae26c75ec45b2551389b687f3e32726dd54f81fa872b81dc251407351df8f40a2cb11c05ce5b9745f1268faf046a5cf84967d5cc95926631095eec21f301fca0782907d8916ae6d4a9ef1c85d5d7ab82cdbd7d8381e06a5c759f5186c62d88d1dba1e80ffa22c8b1709fd50215462d48d8d5b30a46b2d71d2ad8390ad7a1cef19882e25fba3cb41a1d02a1f6c354c9a547566991b66c29d2f12dd4f15236cf729ab7c5a61db1e237291fa038603bf8b0738aa83998235bdb948f6fdeea858fe1525f3c354439506b540abc2591872be69989985d1a92a235684f3940228103d45f3f54bcd52a37835aaacec32b6ac77d822c3cf95f81921c70497ab53f844babc918bec6e5f261be84c95a0b7a6943939afdfd39ac82f0a82b78804731ddb937d16c5396c43c6b7790a1e0aff6f687e0e7d04af1e28e11d84843ff158670d0968e2d416b1848ab200b9953fef44d13ad000bb9e24a355a55a4902000e191099c39d5191b0d5ec12eddd6d1d8b650aef74e25f671e6cf5f5affbfa6b84ecc630d2d3eb253e0560216e45b9afa6208fededeaa7d551265d4cc064a81b0cf6b584af52f671835b86b082ae76237873a6d96cd406d845a40407685c420779c00d719f22f16cdbc4883e20e85a2dc5d56b94c0fb3c637f2d4bbf94c936ca18bf562e6f02161df10727b10cc4226bd125275f4c2b55304822a874404de89139166bb5905d9de340829f111f3a97ffed94d5535af88f6799abca9c1524fa15b1796c1108e38ac0bc12af6e8f6cf8c4ca5658bfcce2c13bbe59ed7457efd4daca2a6736ae2a5cfa114c2a0e3221a767a514ceded3ab4d758902a98568a61c2e1cff2dddb9c0eb96e1c3a36aebea28f707cb130faa133e67da14c09b6cadcc264b8ecf29a2e167db97242b0135b2e086680c3ecf256c6983e630aa1b55f75d7eff8c0d88278aae1485089b00b28c504737d4d1bce6516dd701ceb2fac67d47cc268cba014f50146a9f21f2b90442ba5e24eb3b1ec61b620fa0dc80366fbbd01b0292f21b044b1fcf9a79ba6982fadbda59aef5d9392e83d040a6b482ec7e00824f7a6ce2c730951d10732d5fc365216ddf254f8e0dfa937ad8ccbd4ffabd1e31eb5b81cf904725540bc822c5f77d3d7fa6a9c4bdab3fe16e76a7a3a7f4a79524979574b61c4de229bf13395db57302aa82d614cb77ad2094c72a670623c6b957901ce038ec4c55f73c01696a085e45942d2fe2596ece87ab3031f60c05767ed02e4de5df765fff63550bae4196728ab2b28a49ddc4bdeebbd030e105f14a9b4dee1a8bc2fc31a5373ffa499686078b592abe7ade97ce468a5469a360f506f2c2f951d4da9c8542dd9ed5fc632fb8ba8504dda2d3494b99a384ecd50fec3c0d44f417e6aa2ccd4c19fa8db60ed859ad904d6db03fb2a4ddcbc9ad5449df513ef66c7c62de32d01df80399548a1810afc08c392f2d4a6c8b27179d58746823341c70c7236f1ac374236500304ff8138032c1e111ded8fd15ce09e1164e4dfe533deec32f657c3f588048ced499e2d8a4637f6c1fba9b4bb655b9f757b5809aba85a9fa24e033803c2c2a7dcfd5c42a0221eefba58a350ece53c7e0b1113f4a18f89aeadf0d3bcc65672cc230da0f6e6cf72976be39f514864594bc9eaff8cbf7353141eb7c6105b41a0043e2a24e0dc4f78fdd93a4c9bd245dd222db823b770013900efb8d99569051506396b3fee26e2fd309003702417528413dcd8e1e23f309967f8d66ae6061acdc3de7d43b20cc46b45972e248737465368680670f3660413e980452e2b57e70d9089e0104729b94adfaa34bbfa0af8171e92867962c7d261f57e55f005b7d3afa9e0c9792fa0b19dd60b861f05e2ffdba557b9637e24c1fe42941d8d29ed4dca2fc8ab471437f71b6c8e22e824f07e177fa11d4a099161b197bb675a97ec32f84b0202350ed09f395fa3072e04f165bfb94717d94f83ea301a903b80c616d6bb200cb568a50a212083a27ecbc45fe0d643fc0ddb19219091c6a862a60089704f10a1f0a635e80c01a7b053a9bc4849c6590672347cd269b57753cd448d2e894b662a2064757dd0ac34deef763e1298d5bdadd8838af2c079c253cf27cc9dd9181b0a3bc41a5fc77e560ab05c3035bf5eb25a2dfac8cc90dc9e0ac937ab5855672d21539c8b1efbd27def9dc2678269f9380e1b2dc9322a78eb26e836de5facae19ccc56e122cf4f51256f57cd48e4c51a686b5458982aa06f545674b77b8aa5617468c0814a12031640cb7a780103b4f3854420e2b8e925d2bd4f8cf848164847ce150597e17e1f8e0f09f3547f706494b3cb380ab0082c627e1f89c414b134de19adc069a7e66a320c8a91e78c139e32e3937274a9b267b2b516e1d29095f36808d9beb104cf033e801edf5460b9b7d04632f7e6d19ec08fdaf1407a7f349ba70a362f6b0fa421c35adbfa9ab4214e221fa1ffc90da39f44353f7c1a789fc6dd99d2fa0067dfeb7b6d82bd83ade1bc59c4129da66d44f42a94264d595f440b52eed22b9ddce50fff0f349ed6eec3a06d248ce2a9efe20ea2d9af5931be1806cd77ec3a631f6e154ad351dbc031ef29a4b95f3e492c0c5a20c93af5b0dfd6385056239e72d2c30767356c894c8904b22c5054a0f97212860a832a8089c3a1ac402bdf7789bd0951b103892bee9b0fbc711623d49501230aaa5887fcae71d09ac06592d989a0e755f6fa1da6ad9d736816bf45f8622536c0451cfaa22a7646bde6d8aef10bb918c0c75e8539480807f9813f55d991fe1edfdd9b8b58fb1c7b27636e4bc667ad99187cd13622303eb2ff387d95cf88a6b87fd9474a955004eb137f29dbd6de1016ac5357031d97ad8b7758633f9172d55aacae84b508f996e6999a9c52861df7a3ecb8812d9a33d3596f5adb2dffc1b5e90f6f2066bef82bba88b82608e185cc47f76dc2af6d1768aeec2b7c00156ca9bee15945c0a03026baa08c136b8ceb6b93734da235bd32d580ff1b9288d474661069886e1c7d050b3e7320a471747f6a1693eb16e0edcba3dd303ed56c19397a9a7b0af312973803da356465f92691299b86a1e56de957a6ad6abcbf4764eb69243a9bcc0c80a092463c9b54f3dd5c3ac554f52e3eea58ef42d962993e97aaf2503b221a7e35d310c8c2471cb30a8f30acbd2f86568a8971104b9581dfa842a9ab59b104261114d25da9f3227d0792578e5ac22e23b774488c4b625270f9e1bc2b678b1c00904d04f29ef9fb9a23eac70138d4ca4b8e04e924fd4a8955bc0e147d1d6bd6dfdfb45f1ff1e0dec0918ddb4c1993fc82674beb53038acf7cc50ea9c761b26cb3cb6c8f6746284b32fd1d2655d46c50e6de7ddc44c13e69cf803980bfc549ce7cb1229a658dc778be6fb379aad218345a50a1dd1f9735dabc9e1a22fa3a0d617ad468693478e89948372b50d353bde02599bec3495a68c9eb998c1a40c1717ee9c23ff9f237b1801c48c26e01389c3d292585a2f7c85e4ae3c7dc6cf4080e5735527c2a8f21519984eb89603e2924327d4b35497c5f770b4f7af97566d87b4004e3bfee72884de1f82518daef5118b09eaf659f3a21d69d33a3c6f73f85fca47e9cafc9ffd336a75b42b98e267c0bd47f6dab8cefbe5d2b8e8ca585c91695855ef7e800acc920991ab56b17a8607539aac550699a240c97b2ceaa06677cc306746885d4ce110e6909666e8c1cf39e4691cb85faf28b35d89b8b2e7528bb191195f12850a3dae583d521f5f11e64963ab780a829e4ee61b979f701ea8ca39fc4ea714dac155e6f4a47fa8a243bd6e4fe49c32c32642d449c7b4b9da9024e28f437e72b5dbbc3299b7cf25f894d6997c814d17360c0a19768e5ef206417e1736c914c532c9eee664c496354ed556075bf747a07bedd24a8dfc772c5cd2a48f7ed4bb619576d87f0f9168b0c7b3cf94db16480c1029814d92734938fb96dc74b388950e7f6799c11e3173d145b9be521c94412071030cb160bdd41d7ef7cd4b30f61f24e87a723fdafebe171f1372292dbf5146b867a87137fd4f8651af334fcca9b9d81c08a992a5840d6f7b03201d77cca569e3bf0b3ef7b34b87e568b6bcdd09a03dfa7c4d5f9ab2a7800a82457aac576384c32684afe714eff17347c33df15a7d0cc3bd472b3f0c958edd60930a6f9365617b5919d9b18796042fcc21dafab43504e01b47d11b9a8ea68ff6d00043acc071d009e645db3e723dc2d7ec2f172e4e1036ef27402b339f5219b6af71dd80979a8b3d33bd13096ceb727631e467832b437245a4d6694c544777afe6ca9e58fe32f341b23de21f9c76cb868856dc734b8e571f791b6da5d5bf6aaabf9ab76be953b1edb40132e5c697ffd312c38217b87f56245f212c683cafb6e58423a3aad945ca8d2f732d21116a9be55058f1049e33a54cd64b4c22953844e3e0f42c2b1a0ab1d14623519d4abc90384ad12157eef3d67a88335680b4a1e92d8be69ae953bac06e72be6ff02050b9ccefadc71eca31e2a7e6a272f27ad23abe2004f7e37ea0d50ea79c721a5e5371e249c6dbe830bc476048af715cdb4f763ae56ef0aeffc0979c57308ddfbfda3632c4c13bebb5ad99fd1e419c58020fc9f5d7d380985fb94176d75dab79dfc42edcc1d73d52dc270e566b6d7e92fd54a01a6dec7edd5f70ec25534ebb182d4033ce9dc1a9dc58d61697876f74982d9a6eda430a55ec10bdec3b3488f4c36b008babb0615dbdfc34b2449366f02966052d02114ea7e28b4e0ec810def1ac89127ec72b62d76f99c740ef2784dfe112dc1434216be3beaca532330f20f0ef374410bce921559517b74b405852b1b2f9d890bb842a76ede0a781484427c06e9d1d6d7afdc46274ae10f87316a8ec933fadf064d23e456d5fabfc382e84576996068d606af08db8225ffd16429569bb37ca621f633860cd7e865038eec4731bf9e9a88f5eca023d86d1b08e0d65f3f6e5cd98e412cec00552e81bff6f3e5d2895d0e070fd7cb9b5a3c85cf7eb284838c852b1e08b512e6945b7e58ee601a0ff35ca41ce8567651e564afbbcc0dbc326b1bc1bd0ac512c3b139fab376e9dbc9dfc5fcf9a7f93c3ecee8782b4d736c3bda4697aa7cc33b91082e0ee70d1043182dbf16323c5de88dc08cf9d398bf16498deed2494cc0eaf9d833b0feca5dd147a391c07ba9ded177cdb2a31e00c3d34949ae2aeefe41f679aa69e06c3750a6d5b8c89231fc6e1f8a13878be74aa322a4c3bbca0c63522492c733766cc7d0db359b511e269218a8473cda5dc83a43d930c4b5f3a40b77577279cf1cb8ea95e8c3804b6fc0459b9b144a727ded4ef59b73174145f00d82cdda557d709fb3915d563d0ec382c49b611c2f222aaa11dc1d86f481e3d28e2fa0408a5129a6f83750563727b635f54bf50de9ed4cb800bc5475d324dd8660bbb413939336f4bdac49774e4365af0fba51ae9f4997d24fe55e309771defba53d863edb87edba139ec02b3eb0876d1dacf3cdc53ca0286363c48d274eba895b1c84f72497aa5321d25e9df93b03e17fea3b6380b03fe7880382a5bec54026fcabee87452681996521593b3cbcec38371d48823e020e97c307a089bdb8e1ccc18b832dd9f358ff9ebb4acec8dffe15c578c375cef3ad3c66a8517c89d0dfd8a7f5906355c7e9a360409a7c07b122bbae81441c0ee1ccb6e086fd45e558e6c736418f164f63538bdd107ebdfe7dbe2a8606916c72c5ec22b00768321aefc614afef6edda0a9580d9ef98e9134f02df8ce6cf5204bc2b6672f9f3222829d89fe9063e4920d28e920c88a235b78270ea5809e59d1207971ee249a554cb47f916a3964793a0b5a346ed7addcc6e92ec8481f39f3dd2386e442fbd6dadbd2f8af7115df359a28941e93577f1a0298b2f4206fedc7dca27bb10ab0db841f1433e424cc6348a00d0db5559007ea223a66bc846f8fb9a5938fbb02805bb3ed4d176631ee7401b288b6fb7e9ba5f6fad7e90668e49f6f3c3fcf4af63b1daef761fdc1b83c5fce181eaa9f7782df18edfcb8303a169fca75cc70d01aa182ecae8c0579ab19d9b88381c71f2c194fd2c1c51ae4315f0a81fdb94e906c766ec87dc23d9ab7b438c922f1640018544c2ecbd573426ffffd11c73fff15da70e5acab27ddcdb02eec72b4f723f959bcd60324e35227f09e1dda7d1b641811a18925d307ba07be0ac4e4e81b9d7effae9f04095cdb74406a9b0fff8cdb3d3b4bece272194d2262b61fbd3ff727c3cfcaaa43c1521e223be49d2a75710130ac5efab49ecfd8c86bfa62c20e021f945db2a13d7da7690d246dfa2df908e2978b605e52d19da06529f89975f7cbabd3f51929298dbc08238c8dcd54a19179634db7005f1507408f15993b42921a9a6e738764aa914ec3a8b91fb76e0c14b77bbd950dd673e5c28bd3ed2fa73edbba3135129a3291b2f29b7d5b3f242b10b811ba3606d7e70084398966f1dd8f7044d0991edd7996de87cec6939f263f72230e533bafb7f66a90e305e35a19f65c14652b50737382e86f8afaf22ae23957422b0168eacd02e910c586ea003b63ab2f50bba27eb7f9726b3d89324637669d77b41ee12564d33b495e4fa836a47da7c516e69f346971e476eb7b4000655e1bb0563932661ebc1c903b0311fb48fb5db59ba8f3fe5637391be2abf568061abc64a5c657a0297385c63a1525a63343c97b7f4b1db9cecf3827e8d077fe026e303c18519fe9f8af862bff7d2b928d3022ca0531fd5de8b82d5f61853c884a3e1af7a0131abbee627a724bdef22a3b5671591ee14edee6be1c42646ce620d85284c2021c19391652a521a54c6cce506713101afca519d8a507589fddae7b53b81342030782808681e17745aae0c8358418319db2c0adc61dad77ceff041d4dd739feec976d20dbfa69a454ba12cc720473d8baa9a43c9dc0198a4d6b1a9a8ddc48b5a723ffec8bc93106e8a6f7783ed9e2aac26d6cf0cc9d4a8ad718ec9c4b531a0f7c88f8f8845794f58e97cd8612d3403514392d8e087984e500d9a3f5be7a5a96f55f13c87b3bbfa4882b9b2c94b595954b8add118d8f2dc61b9d15d80c2d522e3d4c7debf9e5163ea52299c264a063d352df7e7fb4c4c7686b2603453b7a05fbbcaa206db6b2307301dd20ca91466e7e1848befceceef8760f28c795f26bf8c8c68b1e0a03f0604cfc7019ce8aa4514c0e01cfb75ecf6bea5f71f1fb98d4e6ba40161e497c01f572c889fbe55d85376da73541b58c10e486016c45aeb8b79dcefd0e9bea4b675ba8054065d0c6d8b6d55c633792f3dd001994442aacc091008de98af6fd2ee9d4eb389ef7444da0331b65349e5ee00ce6a954b33dc6b0998976183f4ee300973b4ad050fb7ca1c3784da0ea1dc999fcbd4b447d43e300d3e27395e2bdd504238ce83c15a539219bc9227a67fbae03a9cc2d52028dd616aaaa1309a143b59b0cce935ff48421774db5faddf90a1eeca8f1c4d5d8dee8a8b57306f0f8388c288954654b0f6ef8506023d3126e2e9786cbf1f55d85251d18e667ea515ee7fa211c8e0e50edce9896d7ccc4836e64f84aa47f13d3d9b58852b5a2ee0a6d260dd8487acdb21d6d420f93d43d81af675915b670d31a6ffdb7c72f8830d6720779ef26341a88d397453574d6a3399f1bddaade2358bd461532b11de6e627a7104826261479d01b6f233751748191e63af1f663a0bbc22b2c8eeed9da5968ded2ac30ae54d17202ba1366e6894cf86e6c25daf3297f14b5c695e2227c530aedd39e49baba608b69233e0f2072b761f2f9cd6652fd33c5b30d5671ad37d31f6ef60c5a2ae1ccb61245df6b99035aa2b4592180495906725f5a4a6040fd7b977f0b5de820dc0e005ddbc516af9904b6a6ec97f1fe07e1a8c67f0c2fefba6dba0526998a95930a66043ceceb59e282650fdf8bf4b2449f394fac25e41886e2001c1c0a054e78bf951aed94f3eee2a979794eeac8d85a5c0fdabe9e0b050374a93f844ce99b829d54a1de0c2abbb46a769138f2c2a9a9918af49a6f8817053af0fb289081cf8ce8fa1fd9bff0d68bc3c1a8cb22a80d508f7753a6eb657ebf92a0a69a6762c0f355d8d83bbec0e766ac7823b7e96ed6cd0fac2d51f366bd720f3a1dfc5f926365e23066a0dad30bfb534a56c506245a16ce61f7fd5d31e97688efb74cf0ace2cfa41a7f884b47dc2f34971be082cfae99bc57873fdec55dce70715e4a39735966226b47670c5d5a7e5daadc60e3520dd828f2f9c829437d0286da8fe4b0ac8068e3fcebb44015411deea3a978e78c31ebb50ef19f77dd3620e257cea230d1a8e49535c095ed9a025caeabb86023ceeb6478c353505b9f3379c90a4935aa6f5391a975a3f81b108484f6f65fa17850813d67223ebac0980a87c59aaf8fdbefb354e69f01f56f2c9d4f0eec2aa7efce7c290919ee67a8ceb4181020475567ef400962da1edceac616e9cf18c166754f433c902d9e2c0f9a7a0b92d8842cf57eac9474d4a029dc98ee30bb1d64c7626659051a12577a08156e3dc42e83c808e5ab9387ae933702462d97d13ea9b8cfec151b2275e4505a478c5d673d54449b6719cf82b09e5802fff71ab38c26a29ac15dc4bdb9351dcaca3f538a6bba9c0d676a24f3d4e5c06d93bea8dcbc2de51a9943f9dffeb971857c02ed288906b41cbb02bbaeb28caaffd2e20bb3b66d1f3dcf2473793a2cddc14f64d5e627ef7b9b2ed038405a76718ed8574d96b455ba937631b4ebc339cf9706fdd22baaf44cb8f9c8a1da386d2042787866e13c78d47ab24a5792154e3050d3010e9cd79e4056fb118e54df790f2d52e654ca8554748025129feec7e4413e457e1c9e2d50163ed3f23ee995499448ba471b77225ecedc4a00987efb616a8c4302b84fea7db886eb479ffc0b6c330bc30411f329cc0f74ee9b04c7b452711e50e7086361e948264dc362eb5b8ce08f4c42ff2bb4b3d167b08c0e0f9d27c70da0eb9289aeba51d957d441a56071c0341dd849de11e81f9107917d60bad9256b1ff06d758dbfc4051874f86fc4c932711304be517de6e9e6c95ebbc31c6781a90a38b33952fe5b26c1e475858652d8c6235eb3256191c248d203b8491625a91e0f02305f4db4721220b6a875cc2e2b8101296357582f3801b5b76d5f789c7115930c3f1effb51833b0847f206584ebd81d5cd115fd5c675839734b2dcf2bd65b6065ed698156fb4a1057e79ab8499b908b3d06052cbf3bf71a9499741b807e317e007dbdf9214dfecb56566954e084d9f447e2e5e943b542987d6a9f2bac2a7f9ad74c76d69957433d9b8c9735f917786ed861770caa31e8f8b42055459eee5a3d26133aa1d7cb0bd9e11988b5578c6cdcceb7c0988971bf410b7be851a59ecf64769a1835e82d6b4373e684a17663b6c6c461aa381bd39b498495cd358523bf3f69de5e5835c4ab4f19f4ef1b3e5ff4192b864f83bb7bb2332f79807d1efbe8514da316f673e99ccdd0617cfe5b28021bd81ae32c88b66b1cbc9a725780e0263cc8db392c25175275c7fd49d3c691eeee69a7793c4c55c847308f4de2222c389f4d74cb2a6781e3ff793fa02f689bf9ea9214b643aac737633d9d27a43086d0b98a74af46abe2db80b35dbf5519f878b943e4d06593a4908f075302c70e2683d8ca4d48f25b104246fb0915d5a7f7139930078973d4e07ba7af23c7bbed09f56d3588f30e6508ed510e9ba78b5ff74e3d1e41c3f672b5dac00fa48afcce85853e77edf497c86a1759cc58f732532b509d577fe827b4f21fab73f8631f200ef59b9933d12e678e459e8cffb7915e31f10130e76f7b51613b9b162b4bcf71d2463ef40ffd1a56a6173be7f4a2071d20e59ee800679449c52d1e931c6531ef8764693b6d6bb5fef797800117d2acb3ba079090541e7a2a243d076fe28a273fda775d361c46a2fb5606efa2ae510464d4e43fd1c43ac4b0d877bbb6224097c9a28e545f0201b9c8157488cf787c14364614ab563d855dae19a1cb05bb5ab87719c814046ef59a8b663e9d04416777c8b9126f72032b24a7e1648a1ab630c5eba5c790610f357e13e3f47c3e28ab9268a53ea10cff8feb3d09cdc175bbd53e9051350f8220d48099e4d704b32bdbee4d29203cd33938460cb421583ed021aa6038c1417c0d0ab25500c907923e55609e437303e247e2d32960bcdf821a7f25e025b4a7dda83d0f0f053b3913972413dec0dc7c7fb70e28cf20e451c12b4e5e85e3c47a19b0d14c2b99ab6f3b959d78d54da24c9dc914084f922f86d0dc324fcfbb5da3109abb008cdf0b30f978957c8343260d69b4d136105098d9a05de436d8cc5f31e7a6dc2df1f778da4d14a4d7b3c52c2c63b640a3b7718defa0f3f762c3e59619f0c691bb10533da8c01eb6733c14545489862a9537be893322646a445b0f9677989246ba7defce7a83b42fe705c3f6729cb99d7957","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
