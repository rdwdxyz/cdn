<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ad4507b1c6c81e8a3da37acaeeaa1aa0096fb701bb49b43cc34ee7421a86974d64d96fe9189d61cb42776016003b72eee6925ce77f128a4df078750ede5061a38af486dac92854e3515f33811fb7163f40d529ce801fee8f98e6142fed15991b829661433ab1153f260e70ff0f8d0e3d455c5535c01f45638e31730e741556bb60dd979a7b1341713948663f0bc68777f4eb78dfaee66cdc8033a4ec4bdc76688f3cf4f839cdd309087a9349f764da94c49009010f00104e351dafb79de3f6375f22f2ffe16a4390f7960500115efde0dd0b7f5710e18965da190c636fbf52e5e1e430af2eedffad37a913fe48e40eb363f30fc244c1b2cb26197e9173c15909f9bd316fe23185d07fb1cff3141265dc4670be3fdb21aa6f39a3b0dfd12d59ac42647193b03c0479385fd95ad46ce97be1ae3f0a2b789fb803f361ccd156259f1a6d27de09c02975e3bbcbfb99f2a3ad264b713e5df0d6d161de015f45c8224d8bdb254122f3169c8be6e4411251bc1ac308884011b745a20ac9d01eaf1b166b6fcb9ef99e02fc3be4460ba7d62804b648370b6145c2b447472d913b01f44eb0b5823686de2ad0a4e40772cd0df5c24fb95665b877e161f7ee445dd52ffb84459954f14781e42ba102a13c964bf62e8caf7fd7617eab3c0b34461ceccac707bc1f92c48736bf0a1cb082c03471e10e56d9b002af8a948c2a004674b4dc2ed5a5a1ac6e4d4ae82cc793c376177820658d5875e3f827e84720add86a445cc7749936a80f1adb69153ef92bac4195225d2ed018222ccb173be1f0f522aad33c6882bc61ee5710dd8e572950c84982ef51d4bc2b57a708f4e0c8f9e2b22b0ed56b7b8324530da4880ebe891462cc5448faccb05f8d38dba57587a28de0193b2b5101fc50a9b31c14b2bf1eae7786ac28f32c0ff508bb74a79a473aacde536a96e3d2dff2945ce71751e83f4b212b607a9682cb9615e51ac3a8a57487176f8193d5d502ccd0f7b09d6768a2958951ae8827bf7e96534f26e2ab8cf0aee8e38d910500417f22ca2e43c87036b0348d2963a3e20b7d52cd1b3829907567c6a0ae25149ecd89ca68d4d570ca7c5ea202df7e8ca21e5776a1937f901145383218b94a77514c98b90c9c7bfaf0a51996a7cd2b20d0635a5d72685047aec32e12c24ef4c6f4c618dca3c58346c2eb18bd1a08a88899cc6555b467d69474ab114d6dd409209d2df5e1fef1b98e9e54876b60b15ada425d8979337b17407de79a705465a85bc589ca284bb794903c9a7ad04527e5194dbfb642937f89230cedbaa42f2e60f152b3cabb6ad5018c5cf1f3c805d4913ef164ddbd364b333299aff2604ea13097aa1d71036d8e4091b9d40117cd939aa28d8b2a8b2718e57f496b447dc95459e8d203c29e0c46fa4d2cf329e912e94859ef29b3490cfadbd9cd9c18579033bbccf26a82e57705bfb29bd9017225841585783b2986a64cf7e2218e0f32a5fb7c43d61511164c7dc4c24fbd01b8cf403469d2b8f501a68843dc08bfbcda8d3c1c43db6dc94ed8d8dda53108fe3166f8ac7e7ee9028f0f4685bfcf748e65c6739be340d53e8799bcbc307a8f0d91abc96c49ef18adf57d3f497a5c8672d3e0259b211bbc7a8c1817ce9ec93bf1911e1ce28373bbcf2ebc7ea57d37c361345bda724ab69afc6a770deadae4715fd3aface8257017adb85e53c1e5f191fa9f7a0f0331c7535df089752d04578dc7a4a0236239ad11c2be24b3a95e22ea28eea0401a850ef0237f27c2b26330447dc7cc3c04e50f3de5dbce26f93558afad5e6e18e824d7b3590e4d8498a4e7da4d16269c52cd38084820ab7eae0dd1204660020ce25168db2f0492796fb2c7742435d748c4065e57c8f9a6fff51f03422b43bd90433159ee07a960ed1e0f2a4d2353ad5b9b43d855b466a3ff98803df19f0c5e6f7fbd906447f3f29ba29897d16ff9c40ec1aa144d18694f266a41197572679ef344a4c0a9538e16665528500570165eba1b9c0e308ff7a0bc0ba55d49d9ceddb2e8e0c821c952781be32d2883cc06597384c3c7f87757c82c448b89d6346f80c4faf60bddd756f152cc74690178d61f04a69027c1e2b5a8c28e3f7f3c42199807bc4d9adfae28e38b183fe4dc8bdb5756fc81fd6d89e1ef07a923e7b60db2b34714bf4701d82d1e824b76d4e422be5cf0a5ea4f0848d31a084d6365f19f03ed42797f627c366f653efcae0d88a3a4562d61dbb595a8d84e8b0ab13864471b98d4831b6dadf208ec5944e75c71b575cbe7236f03084ad51401656ca646eaa2861be5dd71e5a35209fac8f0495156e8461b6e6216282d6538f7d1073949c480c8c7fbc161da17e694dcf7e4084cba04a2d9502b0e37760b749e4f05f96cf6fe1bcdcaee2d87df650bc8bbd87dc3a945981c3945b402c5bc3d5b437c95790968c812d1da599d4763ce0146e7eca4d583432c37c725bac76bff41854bce1cbfccaa02c27a19b2b3837edfe7aee7654b9bfbda16a6f3ff86b8cf3ad4f4ef26a7a46cb7a15f28bc5e4cc9cfc56f10aed7b47f45e30b5aec79474e60646f915d474acbee9decca021f1d46538dc40126b3f938b413c95e34f368d5bb95a78d2be3a49dc7256f367736719fe6a8d369e76f20e18b6eb5806ea80c1f442575319f2121870f9192c2f97532b461f3d8e2d274acbeb10ab922790a64719e5b07a05615b8e1482029aed5f82d5c8de77a1f6a138571ef2caf4279d9d0cb64049c811470cbd661f40846b92a77e1a5563e3b17923fd4e40f9131e016c1e3004cb1b7f710a44f77749c22d4b0dcf00d98e674258420d3bc8342132309549c62f30b677783d3aa19ef4d586561433a1a28027bbeabe045a2f63707a8e1a3a1ee9bf2acbec9cd9289e8dc98e7a382efd1e1e0fe8ed946be0b76414b17721d963db437e650ac920d7293ba7248c1393ecb44c27d9c14899e727a5fb248693fdd8ae02da5470eb5872332b727fb2bdcafa827a775c624c4f8fbee9166ad1fdb9d152a1197cde1053287332166d76dc135ef53ccd499819c9f7f02f5642376fc5dc87c7a92a85bb7c144bf8c9225be0861bcb397fc5493d2549cc7278bbbd97ae05bc76d75dd839f53d6a501a0c2e40a2a8f0a1c15dd776a8b3b920f04b6b9630bcc7da64851778835b863be2e140b4335e312a42314be4dfd814b36b4ef0d668f7430ebf0d0506d931c115dc044ec33106efc3b043349ed7da32d9efead9974f46d4a59e251645ba705f854a3275b25c521643041f5cd5e123028bd1799844846d668eb50095f6d1232a4dc1b0edcc3460798844db60532a92d885ce6cb8274e6b9f346ec686ef450c3b40b2623e99288540d9c2bb235aa608674d6af1d377880e16eccff7d6ab7280489bcc5654b119251847f4132aa98bee77b98ed889c254c74cd556fd31d11746d08ca3361ea267144cf37fd679b1e56d7b265bbc610318e4e080941a1e210b2b86f7a987874c815ac14aa5704215d9421b3ee22a3eb959572283cb2035bc53b48e299af0198570f9cee8d8865d943ddbd56b95882bc1c4a9cd0f1c1c57e959f5268cad8a4c8dd576bfd197458acd0d20529e72813a108db5756b5a986e19862969eebfa70f69a10acdf607d4967996c28b03e7683e2c14721c099225ce423ac006eeb571671079beb56852ce275bd5db4280d6174d6e794fe3e1c44dbd35a908b5002bddee8a84e061b9cd27f53b891e5763831e87d3f50b06f36be02c7eefa7c3b698c16dbc45542a0dc10b9406c3554eb32170c9a1a5232ae37435cf379748c1a374ab56b04bda1612bafcd0feed94ed0ef61f852f6b0076601b9d320a874d37c6a68623750112e2cd35b0152f4a678bb8af0379dd55bbf1afe2dcad656143fca2ea43753b19721d67359edab75887938e4de508f2b34663b99f6e4c0ec75598ec4d4e57edd755b5b7eb10beaf9af6e562f4d08ef04a58be8c201de93a3417f2cc929e050feb7997c3464846b29993f0948a4693cb31bc8b885f9d396524f910a23695ed1a025b6f8ecfc80af3a348ae94fd1d7445b088dd35ef80f49a0cebd9fae32d7182cc5cd147cf0df96bf5a2b710c868282e89f4eba0a25d6d0289f5c68a53a5e8a6b145be1ccb2ff7a8d51de8c68bdb7f272ea5b62b12822b8e9c96bebc92464295b1ca815e984cf296e208aa4085d39f638d99e309906bca7e3b47eb79ffa4348079638b9ad7585b21aa39e8b3f2e6d70a6f0cad16bd9546fafeaf9a2a9794955738e627358edb357029ea670c9e9c595d85e61a97f7f82f1ff0d4ddcc14a2d2d2b327e1e604f5c79b8b4139ccc99a956d560eb595ac0f4a7f6fe9fc55ddb277924c097121d1be31644d689a9b626f51091d85e3f6afacbab20e1c56cf7bd0a9e1a9e340576664f3efde6ad618f2141325aced20f29e78e58883acfaaa2a80a3746cf204fdae6e901decc462f268a328a25069c49eba072a4eec601f882c60426541395177d1843bee2efc248129559aecfd0aa5e7091611a0f6d531b75dbeb7c69d8eddaca7dd1d68ecea8eb62f78b8b5eb4f9b1809b85434a4ecbff5098766c55b83ec3bf13d72e7ad9a58475dc2391ebccb57a03863c56018756a58eaa545c038f21d8b609780e6cc3877ff0d255ae8cca91ec0d18e95ae1cf29c8a2337c792bbf7f896663279ab249c045071903cf6ca254aee8fc7ced42eabffa71d9ab109445e7a1294bb1134e69b755e9c84458a5f628ba3a49dc90d06998337a2c9fa1f4e9255802195f136a2d57413b397869814da870a31d34328056dc7f0369f20610292a157cf32ae420b4cf9b13de6cb6e568f4da9ea6fae11601b1baf734298016fe2d88b836ca25f559194836e51f5403d917e8421feb31667948d3eb5ed05af6527e66525362d750b950e7a73ab107cd9eb7fc458849ab60d0a6e05d99c76306f1270e3846900c8ef70646e70579f96d8ef49133df4f87732b199ce5d570008eedf48665b791c615eed16d6d9d1300d6a839fec8c36a4478d28a3963e7eda8ce66deb7ab3ec00e72e479ff008be2e102dc397ae8213e1d769bc5175ef93d65784979538d0163e5d6b8441cf3375779915a76e4e05b5ececff407d00c3e97f94ca78928d1cd029ce08c50767ef528040f0c23a1ec4b28b468e8cf4b7feb62827760bfbe105154679ea5ac86e4acad8a0fc5bf57c014f9e79f723b8220c88b0ffa824881a4ee6c12c812f38dc505137ba0ce544a8607b01362131f5fec591c829fcb179a3389543d029dc9b54cd54f9be5a5680f0b6d219527d50cda60e7db6f6fae2de6a144efefd9e45651a712c8a8977fad31ff35324f6d483a2b38c21487493ff79e8a9af32d44e3b22a365bceffe104d4b26a0469da39d5e119f8d43234ca95da36cb44841a3eb4ea23c73b8533f13509b7cfa6bb341b25836b1310f3a51e66cf583de3605453076a792fcface36981abcc720b369d51094523bedebfd70ec34914443ea932487ba30210dacb16f9a3f1f14f2e9033f09c119033fca43066e96454a4b7ac637b9b76e4998affbfd41d4953ae7cdce023625aa81822abd34f604819dfe786134fffd960e8482cf5dd38125b33001d5f515b98d13cc1b20b43727cf4e8e6c3222b7dc8c0af05f4239ba87dc5711904dd9fb941fc040594cbe9836de63e2be7ce2deea9fffd7107bdbe51d51b52208fa0423ba2778b720b9c7603254489097929a5a356a0ab134779f3580509cc45747a9b902c0483eac19b1e46250f7857d0e62138e85e6eac6467d99fa01dca44fbfdd8aa403dbe39f2dd02e803670f2c767248132dafb577b42d372b5ac7528852e74fb045c7d55f9896362f774e2a4a6f246ff6041966eb8c64579cebe9a807ab85c5d6dbca1770f094ab63b10f9c5ac223eacc6330bdf312634e45cca0f6179157014a9dc75e9ba91cc1b053f586ebb1aedabb324f7d2daadfeff55167c4f99a5c0501929ca35a028014392696388423a5c6e5ee9210f39f8ee00628f5d1996ac1fc8d238193158603a6c00611b85baac6bf22a9c19ce275c5341a1be673ee82cd85b60511a5100a64c0977cb490c55966d424e15fc891ce71f9a8ba3ddd933eb0f889bfc8a73430c72a5f093871465a93ec053e3d98201dac5b8f01432fe3482479e6950d8b444dbfd8b68656b217cbb5fac6115bcee398ce10a465cbf0698d2b06bb5198201bc436426e2b8263f00ea2a930f439ace73cfe75b200ca40d9a3f430a1570d49863f1bb4c5b348d12563f034ac1c67aef83d6b78ef7a83ab84993fa7cbe0c0bae1485edf971eeb7dcc4475130e52b8b6aa8ada0901391a603221ed46b4546a7a3599532aa5e28a05b7600b96f0e69132b332168646f3de0112109ca0c9e9648e986092f0df473bf2e51ae1a49c13c78e78dcf60a733ba932159e22a9851c355902b1b66afa4cce9af2128e9c0477995a7c6fda1447b62b5f5ee07538f365040bd6b0b5778a7d57392d500bf53d4fd524fb6528a6604ee8fbe549a645a8765db837e99483768e825eeed27580686f771f3edd1ea4e3bac628e9ac169a888573996a989e6347b4a3d8fb93ae2b0c0331b474b81aeed7212563d60f4046f9a4f261be953d9990986e7feea18b9e3c3b898c0a4002b0caa7edd0e951ea7f9b8371153d37db9edf94cf734a8a238492d6f7e9c6da1dd71f0684f03e1ef079ef7e1aec475d6744d7829518a710955eeb1e321ec0425e33a7bcce03d96672a5ef4d3b2aac6aa5a1f947426c1f09c5d54878ec2b7fa2a9aa614325118fabe007cbe5db41c8d4b6340aff8444890d39a5e07b34159d60e4a3ae52a276ad2dd8d1033200b763c892bbc114d2bef17443735ae1fdab64e420666a7df26ff068eb5f2ca0e0ae8400f7cac01ea14871613dde5ccb883171c2728c908f1b8a2034aa5f6d84544632d29737912902b1e8e779935ea928ce3a489f4de205a38274a201a5de69445e3f2537e681a65f7458d55dc1fb8c899b5a6cd6ffa96ceb256b58c191b42b2259a0000a1edbabca5e5be18df77cdf2b3b2f8f608057a92f51dd1aa1614448bd7e3c6bd69e31285fe59b1de787bbc7de32a17841ffed25d44c5c92a8164c847402f2719a7ea55e77c532ab5d5264d1e557303bf75361c6bdc5f5933cc89040429256a8f9fe79cb52243fbb66a9e42b4dbdf7aaeb5a379e14f387b28fc2a5e8e9d41b8343c8adbad2415ea254b4a7e6a3dbd6ff1ae428fc899874fec47d05354fefcc3872da3d169260b5c6e97ac26f6546d67d82ce88702748d238c0bd84a405c8e720cd619609fb8ad8d370cdb9f75261b9e0712c6fb7734ad582952a0f407e02971df1659e070e94ea5e03e1571fca2633e630bc9e77ee30f1371b6357da21d1879575a8b51390584107dd3ee949580b55b06919544d06b475aee0e86a8c8a5fca350d5faaa37e92fe59fd5e965b6f55adbf3ffb49d330711ae7ad8b982781892cac6aa4353198e75199da52aa76d09889c1e62724900bd9aaa224e9cfe25b22bf355ce0c8ef57d720c05fc2c35b58b2bc8a7cc3cdce4ffb6756911331c4e70825bd0e1e7b1d5d1cfc97b15fd125bf00feee4ae17e3947f0e18efcc9596fd777493b16097df50ffb471eb0b6590138434de5fa648e8b50150ebeaa1cb7c32f79d301dd0eea36de8bde37d9160c463ee80f1b3e3cb1a82859f1c6ad302b6e0f3b24ce5fcca5e2a5da555239ce2d78f5ad9e7cc56beeae21acdb6ffd042066ce42478505590058a771a95338df407deffe8aac198be7c4d2c1738a3d988a22c07ed673e27a3c65436f278bfa476d289de91b7dca9018678a72935a5307dc0e2112bc52dc759331e5e925425d1082fc7ec7d1cf11bfe78eb3bc8bbbd56d867101b7ef81bedcaca2de6c49c34193e3026e80cfd14ad3b71e9b6e19fed64ddf94d62b1a47959fe7582bdbb67fe95d094b63b7bdf1db1a4f129ec39ec23d31b6bcb146abd355e428f7d7c2c723bfcfa2cbc3508e73e3f4bf04d1e968ec78de77ddb28a5d3a246e76e3b1d5e8f9f882ce710c5b4f8ec813d61a2cb73b37495925fc45a1c6438b24972b1dd1658ec6732710804e7d4cbf429d7225327fc672c02cce805f9cfe2cb6aa60d057d1e0849d7153acb13a2d9bb38dae3ef6fdaed4181022113f21a74d58fde3327409d58fd27ef4875297fc440996488f3f2326daeb272b0a8cf611b2e3d42e2f600d89f6221f6db7f975d2a8951bb21de40bd4a896d4ed1ec9343f23b0cac1b411b3857bef3ee9eba01659d7217350dc6be78c3d7122ee3ff61e49df1b96420c65f7624812d83222e23371eec8adb62d33800f802c69c8531454db16efa33485b37b44b7bd11f24c9e6f6e65a060c36b218a5c52b934995b53144b860bd90f55b4b58ddc9bce8f96642e1a7b1d8a0ffd19176e3bf338719d875ca941175b2a8cb03bd94878359c365da874f51a9adf1de25920464552c242797ee5c3c01537468830ab4d2ee2f5b4c9937f029b6d92df07fdfd9ca13075fb154001664597ac9738af3cf9f154197efc3c23f08bf73362bb609de3a47d462603c97691135d0a441efd57c7874cc5ec82a67f8fd3ccfaf3d9f92d59c7d5a3ca7ac9b9b257f3414e7d5db9f62f6beacfac512c84f8105179b9a18f25a7876ff9964feb12dc3fb3b12ecd19a7eca1be3b7919a4d1d59437b97fb1c6b7bc8d9a1f0b3dfc5f919c2973f808b59d3dd0989106b9648a2fe6ed31acb639acfad6425ba1070e8e3f7d28955aac748bcc0cf3e6e0e19265ae5b19d2f762c0ab1c37549fe780f05a0ed6da43e1a43a55cb5d16e2192d6b95c050a8caa2117349ea6dd6cc35761c7c83c865478bd201b754deaa95289d3767f8d35a6400e67d9d928180fba4783b67d6f418687ee5ceef16c06ee8467ab61228d1e6b55a05d1bf6212dd45c0e8925fca8a1a9e52d5dbddf484167948a5554ba487d5e99f9fdd81713fd47c41c88a8669686e28eb6d909e2eb361e2a7c66880171d22a4dd128e8e7781609560f7cbdbd969419d3e11eb9f1d26543594f639168f1b3db67af3be1614854ed5e44be9a49bc4342856805b2ab8b84bcc355c739f33fb3cdbaf19d578d4eccf6ddf07fe9ec3c55550c6e78ad0bff94c370f91f66334e2118f9b747894fb8a4eee4608cb36d6a47c0214cf01cce3156e8033bfb1d383cc627e58f0bbb79845d9da020464c9a58ad65b58ee0acd327e533e9eceaa7a09c1b8cfeba4ce5bb299f573828a2ecad8d1048d25d0bab805679469f27234856aa492dbf1354c4ce58affa03b49fe134ef9afc1bb5b8a7a7664a36524d476f37069ebc195180504897a0c8a67829e59148c1e02c18fb08201b4112340848f9c8c706a3be3f214fbdf8a02a114572839729399560008b5b707392b8732a8036de83bf8f73b37f7dc27f475d60bbba5ca20d234e2f69340faf4b55418e1d82caa156d39a874fec3fad68222ba1cfc337b3459f199736db347c772626567e9f7d9d1d6106743f54aa938a4844b618f1ecc8b1618d7a0bfae68a1551b869ab7715a528f0b5172765da466557b7d7227f5e4aa4ceed0a608c6eecffd1c434732e2f656938e34853a8adfdaa1306e10196212ed92fada9163c5ba04ad6ed946ceef49ecb9a7ee189538dccfab4d95fff5931ccac1b812e683389131fc6ba4303562f00a095621b0c70dba98ec317831aa63ec3ad0896afd5f1266def3410218d15392832b3afe1a993dfbe36ac9d8e17a81c3605487179c86e27c4148162021a5e347824a6cdb035f697a1dbe2c381802e1ec339353176d9b4b9d0a67968953364c9d161290178f11f73d05f05c12207cd5a63bf2fa23963e015ba133e7bbe6fa974d5001b0b83b3f20e4d7d3abb0e885623f303996acfffa373a6c26699a1635b642f98266c0b962c420a198af24fbe962e4f0bf68ca9140d4e6a8e8592c206f75480e02421e0e1f6c024c14fa2c3062842c6e79654edbf6bbc19f2e80bd71c4810b761c5cbe5dccf384116b93238d969aff0f4dbe4f1f2cfa97851726620f32ed4b02bf0eb6d3ee4cd5a936370e1f25de202cce26d0b013edd527795c4c77363b3472f11eb29d9bfa24670b02c83b73728309de5a8e5c2e1337e9a39cfb2e5b41e4c8d87439b11cc4e2012dd00b3cc795a2832f1fc2a18d413181741b9afa1e91bb0e6169f7d64d73d78c14ffe6e92ded383c1181a38acf5eddd03742ed9383a2340e22c70c0ecde7d1c8bae73dff5cc187364397ffe6949d254fdfa06b9ef686775acd7c4f4db13c9e75a3b1c9666615acbb3f561e31874f0b49036ff4568e2dc76447f667513a6d1b90fc3d427bed28e0db3b37ed25fa4dbc2dc8e15b29c7b9f5cb6aa04c39bc2e059e8bb9454a8e4b547284305d0c1fb2b462fdc3b6d3c69ed9876f0c45e171cb78007ca78def84ab12d232c46372325e69a1554e63ae0d2546350046afe05a2e9ee94f1d204af566a8f07c9f57e6e5e31f8530e35f342615a2fb94bce5e78c3d24059839252c39e23f07d2083e8fd0b2e9d8c7b34f8f8d4399a763a1a89f6dc44d643009d96682a500c102207223d5b7d3828665cbbff005a20a38bdae161dcf4a5391e21000a0fbf330efc7bb4822226d60ff2e11453dd39f90a1ad187d2ee0870d0a2137850e3a555510b636283bc5deabc81b452f8d2df66ddb921d4c1bd9fb0966606e5660a26687cfc3e67be6e016acdd7f253149d2990e5aa1197b4f6af22fa59d2ea6b35cadfb5edd6b69ba68f8e9a1b65a6b3e79a45dd8af38e54b5050be2869d93f1c9ba76d87b424b76e19cb347d48f6a2c4e62f4a5631e6da63b26ec412fe70f91df73cde248ef4c82a1080ea1b725e161d00fdc7e7f99261b3ff495a96cf1604f9bb3d87927f915cf6bd8138c686e612376fc8dbb52343b5292b2193fa7f6bc1a13e050e5a0b69bfcb3b36e77eb1873cd77b13c7306577e07a37715dcb5e1b1720b32f15149406ee489de5b9c89d22d15f4271289e9c05df69899f98e14331bb7629933a996b5d4c60b0a4ea9a9d6f498ed192812ec76a4c74a6738a2b23cec31af137067672c9b75e16c73ce9758eee7080d45ac1bd489f8b215059bfae691b33565a1845a4c5b33ed54f51e5b7d2efd759eed84cb2f827317c638da0693a33f3f07aee37252710399bb82051f4bcf26861b6a29c0f8116df93f4723f4fa3cf84cdf50677fe4f647087f0359921462cc28e53b7650970b97f219d71ea3de93a077582962557b3aac3bf7b5c6517d10424ff6bdbc9f888576db597f53cf64952bb54773c404cf0086f53170b2079041d088880fe7e3f617a3ed2bd8439607ec8e52dc78e6807f553242debfc273b9365d504b4eddc2a64a11241447e76b9e3b9c0a5be1395500a48c4dd069eb2e3d92d44ff23901702f05513a61b4d4bf7b56fbcfc52e48659721042217653b08d8f41d982be9d4c59d4d7ddc381555588e08589fa7e3479362a5b8ab93cdad9058748ffbcb4d81a99ad6301f0b4c64ddac8176fd1b278d5a2b512bac46c988b76343aacdef2e8eb49e7e5abafc837f543d2439229f67ef6a9f69f21d687ae9995d95c3a14e416b96e8530120257de85604dbbc9d9bdfcddffa76183ef30bc5b26049dbde41562c375a56258de570b9f322afd1d1288b51e0ff3bf40b74c8e2ee1e9e6ad2e794a90107ad6ef7b78e2bec29368d6259ba46679519f74749c67adae5fa3ee542c236112fba83e7f99ac22531287df8e9309907729fa6471b403aef5d633050675df744850c4541520e72d3bc7ffe618f08987fce99698f8f5b97b7f501279d85a56d9b943fb52be7bd41ef7b333957566e147993650671e868f41586ad06daa4425fdd463b835294804be7899338c104258506f9e1f3843112fb9eff1b376da38e8cd0db388215a8c55fdfebd0b8f801b457126deb45991b41160da81c147d6ded0d3d4ae070e581e0910072fbc8896917c56674fb0cbee44cc438c2db770b2fe50b0716f78d91e77bfcc221e426890cffe53ff072f121ec39dd0bde640da7fd1647b33ae6b8209ae4d850ead3c45c5967e482e448d33edd0181759ba0837079f3bedad2df61f1d4a0e1b6507a9124d00e74bc631d35408cc54807810273972f6545bf5062f10bc2aea56567700dca73018c7be5911f764c3c6208ebd479c1f8718302e57086a8978f43e5c79f548f11844fc98f975c63e6a9b0041c22dc88ca27bd41736c68b73966903ac2009dbaabb80cc25e4c21d4f6fdffcdd48e3b746a109236c2d4356683e986125e228a530c058b208514bcfd0c9fe7448c7dd5f52e340d4817f15c9d44396bfeb228fce715f963e9f2b0fd16dd3eae3aa54cfffaddd74eb20379c46a84bbc28fa6a62f6610fb862a28e924556542439784a4ccba557b25f07fb2e79a3ff137d45d9253872d1c0d9366a919500c991b348fd22c1984937874e0c4c74e6fca379dbe50e59f8462b4712b624b6a4cd76a7598c6302424126e9ddec6b85700f38054e46ebb0bb6475e159a010742c8908f321cfc98550de166b92fb643ea7b31361df517cc1a674e2a11e34ceb8da79620d58bb73afa28fceb66695092c5ee5d6e02e672eeab8e0c7a779883bd011974ec54071b1888b7cb7395365fb70aa1629de23ba2f1a1ed6f1cd6ebf2ee669dd89c7041af99503f21cf630a32094ca34fd7797f97fc1a1ceef1ba1d923b9a05991c6675e3dbe1e3dfe94703ac876f88ced4b5bd7a0e80052c6027dca454c1f431a478679d8583946b14c2c5eb50d91171455883b2abd9121de8b3f66b5a1a26f950cc5ee912b2a10bf55b3cf501d10e5689e7b193f0afc8e300f80585600eb43a57dfc34adf6f7d2a1d187e2a96244dc815fd1eb4e54d3da693c8b33ae9005ce1bf64d063e078c8a7a12633eab0b91d4e18763e26ede21c7ff54626dd5f3f5b259eb0a8befce7e0f11ddfc551da7d319318febf470f13771fa3cd3dde91092d164992397ec9726874864540a40c5b04ca3094f592657ee08078d0c1055742cd2f47a52359af63036dd6ab6ff46a80a4b420d428e880feda90d6b7921998a93519f0e02cf907859304be108af627665c84492b62e2b44d4e50259c0063f386d05e253f4d9311c22b00a3cc6affa92efee5237903663a21bf7bb207d27c31bce57e6d81e57e2374bf76255a1988e15b4c7089d12ab4bf47ff519cd0af03f2b0d591ebc9a9f5c769255fb42ac1ec6620f7961f0c3b624e0bfaf04c9eb29b2c56055f044d0ffddb20effa06257cfee9cc2a7aef11e00c5435175dd7658c580816577c69308c1629f2b98890b8b1f2d07b8846898900ffe0dc19c1f898e460439798964f8cbbc0548211be2489b2c2fa4aa09354c384fcaa0829f408d7913674302480490e6be41837d65f2b9fb33253f64d55afd6e50659f3f9a7694131febbe28d6f047016ffb50847c50bc31bec40d0d95b96a305c788d0345a40ebd3bf1278e39c036b9c5db78523bf07ad7673d3356ac930b776ebbe60b20be6fa9f4f1dc22e60654137899cace23fd706d662246b910f72780b91ba29ed07b423235abc918f37f700004736e1153a4fae00e90732ccfcfcc030d4747cddbd9d6dde917f7762659568eb8619c17dd2e5695233ca229d2021cd7eba362aad179795c185bed95be3c10f6d3614dc862fa9a26b6fa9a69224d191ea27fb4463c551102c34e6a00b7a456afe88967c3a3fdbbdbe9504f0b18e1ea25445b0afff8d736bfd2d6a1162bc6e48e088906863a523890d536b4a4b5e8f3f9728f3c12601c4ddd0918da3aac361ea0c80b91f08755e942131f332a1c6694ed701c413f3daea8363d2d82441069fd26029a6cbe2c8e03b3a38e665be42ea4aa1c60f385e870695ee0dd3b3bdca791a4877083ae9598925374f29378a3bb05dbd676ac4bf5d725c717984ab92fc12c63e765e8d17997e68ad9e9ef74c0ddd8bfff79e826db5df49d8ed1037a19c6f1aaf1ec7710da7713b7f09acef814401335a2fcd532699020b45a225bd3007c7b9cff2b456543af10239fe6b8fec2882b54c1b21b42e501ebd6014760afd9b5f05d5f9f9b75a0018fe05babf536ccf6511e0a2ffbc06cd1266f76c266c6f74db125444c6ed698c1049e4a8a005d7ccd6663ef6cfcf5d74cbb382207d93c3b6cd13c3989800542358a8b00075cb745c8372371efa01c19b58087db290a0f45afc52a34eb34a55fe4abbbb5e80cd4314a8817394364a3d131c2ac14811ef55f1388bad40abb59b25d3bebe20d268bcc0fbb523626a5075b3ec4bc90e6ce1a6c10aea47da50dcf5b83b196ecb889040b662c3c56aad3d2cf65453cfd7dbdd3730fa2ad76b93ba27e13a25b990cc28fb67cbd1472bbb32cb61e26d3198e57dc0703235ceb2617498822836661940fd062ab0683236b581e6b789313cf60e6d0c31ecc988d2c3f3b8181eb13f846a0278f7160e624c2aa7ac1919df8012fa8bd6790f33e929f9ed574bb03a056632d09a88e1008a5e9aaedce39d5b20505cc213ea879c89765b9725c7d99f9dead38782acf9a80f7da868de5808e42a38ec17a29b148d716690b6b3de1631da402e6a1b7b4253ae53c890646b11842a0018693b977e812f33829d31addb65c5cf466cc090601ff04dfe5c42509363f49ebd495f9565b2ff7c4cffe88e2fbabbea25d85b91279d394306f5bf4f25e4fad1dcf382220a3fc4db0412642a3be621580791a48efcc0d1f5310c097cf95353c6ea019f347eb04ea280c757af0c83d4a97fac2065941d720d7aaeba805a89ccec2f8a6578097166db64cc0e86b1bc4071e24bc16115d6b68aa8457fcbfb3aa7a16d5dd23112bf66ad9b49f146e87efa4e60391c9a4a600d6dab877043836d4fb552d22d64e5cad4013e4b1803d70fc6311e6e5b05bcc6b22ce1dd540f3ec950d47aeede66733ac8cdd34166b7478d08c83ffccf1c6323da885cab63ec0a30c6663e654bfe44af9f6fd0a68fc417b1835e4a365127b13f0d1a3e7c91ad9f490488189df5eeef861da33c045b93054c9d51c82cf6cb6099b633a686c43cbcee66539748edabca6cc32e250c0be813e8e77709e7e1e66fd63cc3bbce7c39a2a469825b2a21fe2cba5928cf50f0de0fbbdf1e0a540e0d30649372ecc9775496a977fc99f78feb6c7c890ddfd730ff5088a19f370ec51a2e6a4d9b081d383952350663f331a01f12c99c8cfbbe15d5e8579188bde51784ef32da8d02635e2f3496f9e5326022eececffaea0afba8c5aa0229305dbb80a4f718dec3b9cd84243d2f4cf1a59b1a6f9d20c9f3ffc101cf76bb47887089d5960bb6a2bb9eee88b01d0b7f7cd81df7298082383471210d74b08759e0dd9a90c3a9c121f98d42375527982c8cf69ba8e8d45b7e6085342af4b32afab33e943fb21ed2713f54463141b1218d1ae6fcffa949ae7bc32c6793f455b2ade4ad4781d77d14196bc6e6063f66312a7b321e28a7f531bf23856cc3fa319de5d46fe4b74ab8928a0c0f8554dda43eea3317a918dd2f63297ab7316cb9120df324ef5247aaed085e04568232484e41b132aa2b7242291f6b98041863fde9effec8e95d5ff4ab5a324c67f95f0c3cd9885a32b66f3efc29c949a342ee31eebbcd0662320e4ec41a6b99faf1ce4543d44bafeeb7622fdcef4cb4b3698c1021a889f15041566358ad3deffc5d722a1689dee0102a99162e0ed7c5c01c4b5770a7066fe08c7bd88ea4ca2a11331702c22251cbeef54c69449b674b3c3658ce92feedef3c057c722c27fe4479559c840f259b681d9abfe040b1c2a29b61c12040c55bd0a1151beb3c923fd6b160d62d82fb33156c3755253050973577f1c38b40021fa8d434030f609ca68b4752d991cbd7c211599140d4bbf3635fd73653f77aa653d08aa32d26adb5f7eabdddabad4e72bd13fbce76fa28faabf133dd7c6c86af7f2285ed0656473d04a3bb8b92056e7c0bb5fe7f35bade3295aa11267e54a5a7b10ed37a07c60623f9645fe92b19772e4401d97421ad75e398287b4ec346524629bdd386b3c88238d0c073288baed235381563d62ef90e1d3113719a497aa80aa57ca91e76a69f5763d50d840f1ab9d6f4a5fb02ab5e84c01f664d789afcee7c868e9ac6ed7e8633a6dfeae58bdbcfcf922d2435de4d3de52602e2f51e3777bc401392de772d36b26954cbbc490dae019374db2331e0133be355ae07bd2a370e08b24b2fdae36f02cce43c0ea40e1b46d1940bdec9cab6799773f7c67f4fd966c7e2a5f5add1db621e81989690a484d4d48a754dffc39c8e4c743f803cd4364836c9375084ab2d7d67dadcb75d0dc2717f8696fb63a03687b4ba26ef3a62fe67e0207aec2c9c0d4c96059ec8893f93b85e81f292a8f2423327326d3c987842aa665c503d0ae62b5d4116c893048173d188517dbfaab0a9bc26f58d9285f20def3d94cb2f10dabab5be18405c8263e06b4fb9a69455619fcef7831b358111bc73a1c1bcc37bb5b39e67c4ea131f0911d710cc7ddfe5d59df96716a7f2e1e8dd758a092a99521aa48dddce3b8042940b54367d5f3c6575719f26cddb46bbb49bf6e55f7e5fbd3fde573c8f6eb51add21187e116a65995e155faea4dcc107a9b756d3d14d0731bde633d1d4a92e5b8e870d6392d54b68cff61e4bcb4a72fbccc1fe4bb8dca43a1ae0f37d1a9c1e6e296e0ceabcde3d110356330d0be38b08df408ee56c74d5684b5d2c9299b57d910e80c0b2c6eb1bc7185da56dc285c24bc49e5c2989d59935c6fb67527878fc102b7c7ce3deceaf3d55dc04367cf65fd18a8ddea0c7f83ee668cfe91acb30448ecb850d529e0bc675149c6f5adcb13ea4fe560c87427aad28bc9ceaa40549b40dc254dc1168e48c51a45a374266f024d0ed69ee30c39613f4481e296cb64ca7ff475f75c489bca61550e1f67fc2fe6daa0c5113e9e9387b6451ce87ce65bf0d9695fc7e407546c8a373e1c2121e711ebbbc37bd066b5a5528c47668a95745cd176ea1c5f88cb0e063ad64bbd572b43a1395953ef75b2eae16e34730a972d7f6351ecfecd0a4190e3f444189ea7f26993ec115c79b653a18d5e97389d6561187eaca2a97cfb62db2c8ab3f19da6f31eb12eb0bc9aa175a5664a0f6d2aa63dbe6588567c15122cf0a21706623d389d5e784924e6ca34fbf80d973adc68ca18352f8a763bf05762c8231266b26130dcd374040710bd190c7e57558e2e6a7a7aa200d89d9f3dc7fa68031f1d0b7213d5c499a4861d1782cf12d85036986152ebe194d2cc46c76c562db0c65c04d09c414c254113f3fb829e5ab41beff9375ae5ae1a3bc041d5e7c5b08785173a30e8e8e854e65ebe0d50f046e9e6e36689156b6e8fd1ddf347c2deb8253ab25377fe64e60ca64fe818e600baf9c1b4574eaab00d3bc512933716111fa26fd68c5691a0e0ec441c7ba14f602a1e6b5b06a090403e8ef499400691a3616e20cd4bda92bbfb47b8a5e318f046b0dfa283f6372a3f9ce3c4d71554bb62889d595556d12926cca66d9f4c48a97a5c44e257a7b782d08fcc470df4f06d09ac0b1d724edbce38d6cf26d4b784ee7adfde8d2cc9946c2228b93e32124fc19be5c7b2ce292658127188ddc9502d73d758b78eeef2e95be6b9dd9277f8a8c63959f51c04c90eb19c01cc1eaa58912f997479c06bc353d723827686bf6e921e7555892883b8bdd70092d1d456a246cf13a582c8e648b31dd89f15022e8fa2cc2b24a56409d63172313162fe3349ae17b9391ccccca26bdd6034853d9296c603cc5d58d5f454d41836cfd0d254cbb1aea9e310af0d2725b15feed1df5ccef4588d8b8cf2123ca7e59610560ca21eda68f75922714c3813efd3e86bccec7d20f8a5c4f8805e59b8824e2c963a340aa3841861c201b72fa99f883fcecce78bf5028d6c606fa0da9870817ca123720e98f730c1720337bc8dc248f0099410ff7cd9d94ff54e046dbeb8b70df033a7fa69d6605762c3cb8a10c8c8dc210913b0d24974318eff3bdbbdc8aac0af51e8f99a09fd743fd162fea3baf86","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
