<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f932c9a335fea2b474751066fd50706c244b9ca268225ba2f2cae7191c3b41bc8c4da5abe06609f0aec650cae271e9268318a76e377b767c5d6dc4a2db23604631381568acfc0184397fd755b2d09c985aed313f6e6d166c961c1409434f783b5f1707af022986de009a2b3c7b0051c3f5b5790dce9f32a49b0a7aac29b709e03acd4cacd87c7d9d7889b8317bada29d8357977dd1ca2c161f55da2fb1aa5de9c50c32feb09cc2f555f9c0f4feb8b46de076a832a91dc962719b93c112fd0ef1e4a33f725fb066a1cab7adad5e82503e12676ea3886268e542a7573f9f42f717ff525170073403f8e548968d89ce46e522cbc1649d5b00da57f8b667dc755493da41f48d3f7b48bdcf3f3139df28c433c6c15b3d6d92b268d2a44b794327fdf4dfe54dde3a409bb668c585e943baa27573a715e4264dbd46aac92fa51651465fc9ef713d6f9b4bf991bf83c0902daf60a7e05427172c80b19e858cff20a7e9a3cfd5f5fff28cd5cce9b2c642020320a9052b259af20af01777cebcedd8f536014d0983a99c6e7b25d9d76cc7efbe4929f58b23d9e4685f409976ea3751a4e05f8aca27b32f1f2b5d91ba8aef6d968c86c0f5b17f4651f949f3e6944416c5855d628a448e6bcbab05f92b4deb761bf22bc4801df7ec378860a6797aa5d0f92a67e3852aecc89d35d9582cc6c3b469c93e5f2ab2c318a778eb492ab55e48ed55836209ba1760c836bdea03f17a52a440530899217dc5584b1a6499896780d90a76590aa6f880adb8c8b21d55de01fb3f148ff08e08a449a3fd885d59b59e44d0245a603a8dbdd4bf3f1b4b59433a34b743edc3afcb9067703ec012ae1a2605083c7eb506ce8ba98981364cef9d3f5bc65b459f5c2d84953b2f017d7da68c48669c858873d76eb3b5a0f258f30977969147dac46db5c4f0f190b6b8ba80e413e553afffcf7600c2d4bc90d5a75d3a7107ebf15ee16f8245f15c7813aa5c494940e2e9417f255e61b9af3d1a04f52a676d9f7f918c46511be2a687c1a1fda5ffe6e6ad81c73d1dbf06ca5db7d3360249a4cc434e596f18289e111c20282343abdb39e01690ab2e00c0b1ac1c24b181f0a367be6e5a13b0a69e104290d9748724501154cbcfbad43a576b95e775b6eb30eff0cef4d4e6434f75f25d91079b4cf6b0fed5b097659d3b8bb397caa0c52529d0d91f773d2f8dee7cdf6a6aab624d7b63befc5001c821e0e818f049e23391fa3dd00fba24828063ed4b508880c77a29b6093ea43267ed5aa52b65f2a51444d3b3f756d709030fca3b73e7d345ac42e4ad05bf49fd44ab56a86d5288ac01a025d4966adbdb5ed17d1cf6a53c9e0b73c5725ee4f45edf83b2cc4ad82e722c367ea1e27287b4dcd10ed284277ff4d36d899cbeb6f008732f9ee1fc7c89c6ae10ff43dfbef4a545ed72bdfdfd23dd38768e45204207c91f6d047c947a917f51f1dbb4a130c43c632077d4f64c979e82e46f4c9a07a25ee327903eab731f0b1ac6179482c0bcc9936bbc7769e4fc1b6b93829b30e0a1062b3f5ac2361ef1814449c1f05ff1d62e4f6b3a2823a0a1017cf927896bce62d4b77b88e622c17428f7ff8d0df57b124ce6c706b9545aa450d95fd703c622bb8a9f9f473c88d43f236ce723cdd52cd2760d00ee5b6ad99a2859ee61dd3e98bd0e64407f7dc4439fce7368e39cdc7183464efc21c6c50add471ef5e249becad7278ad52001a9328052cd4fafbd21be82230cbb4b7d5895c6e6351050060d29a372d56b29eb491f1edb57a77a50436e0e6b1da01e536ae1fe373d6565d97ff990483b85089b22f1c6de07c8b646a84d8ea5926a5966ebee074079c3f2d2c28f406c7f23fab6bc48f1f55a33cf195125c5aef6c6616f2fbd0eb78648404757f89909a9e9a9fa49fa5826f2f6a29fc8d844745d07ec15f23dba41bd573442605064e3a7055face37f80a626b8b725147ce995f5ac12316daf95f94464fb8be728720c3dad3ca9068daafd8c8c32d5622788858578be947b50f0fe8e74f3537573b74b4d255b2b8b48a193cd2efa4a90a1ab8ec20c8acd182ad103f1f8a935f436635192ae698c27426ea036393c75791ba1cb91c8839913c921717fe19f24977b2814c2e1790cbbbaebbf524cf779f683ec3e5cdfbc0045e80e9e8d0298a70fb9b055272067deb969603964edef162a112f29ace5294e4d253f8ef6dbf1d98fbd1bba58bcd4a5d6ebe26a3bf35b9c780324ef3a0ddab510f810bee3f60f2982b3dfa6c3063070064df69f721d0e4c26f509bd0e37504fd916c758adea8bc583b248cd20ddc87096c3eb4dd3fef54eb01d990d0e03faf84355f2c295deef81e51923857ff000fbae1db71200787c472217db5d261db5f9941111dceb33c56f1b13fd75ba8c007ceb091c837d8ad7ffc3107e4d0f97c500deacf8cc3b48fba98ddcaef1bd07ee35ab08a2533b9e02929aecd5270305eb70a251c112ebefd0f4b1e80c8e1f03ba486f84302ecf3e0e763c1672b34be32a4c21eacc1d37b97c778cdc84124983424bfa637329654694d92a04b9d98e6765873237f4d1948a900c8b90c09e0760979502bccdf0cf9250571488edcacdc2cbc92ce35c67400000c5fb6dd51536103d3222518dc17d2b7cab688205514e4a44949092daa74259a92f619b1cf1621c4603deeac32a9a559a40aaaafdd80c1e6838f7b2fe6d0713a561681836ee2a126c081541b3a7b4aa1b570dfbd4a637c30a2b87868f8be147a88b57b9106db6cc913ad6d2bb0b3268b40955ca55bc50c97a4c86a42dd1408b2750b2d70654cbf06b082bef1a99a1ab7b4f711c2a8ad8205b7d717746e95eea0ab0b72286ae567d4e04451cd1cd200d4a467bb0e518aa671302cba45043b06a6840923eef506acacab7a114d882fead1ae16b079d107f6df77cc0994223cc51fe9a96d026667d2fe669a2ac227ee75d9f4e8e4443821246adecb9973bade1fc67b278f428e524a7404a1be3a430d87478562d9b01bac9d6325f7271f9ddcaf2ee37a641bbe60b10394999f2fdb5cd40f320adf5a748cd395d18171f850dfda6c80d65f4d41ad37751f4cc7f6d57f67a00cb3402c65dba4c8505cbc4b396e0e81685143d20cd10b0c4c64bb351c1d43980a02f7ad376d9570c1b8db3d5ebd521ac1f03f4686e931bfc5279c9399aaa768d7b5916a71aa66872244c59c5d98ac1346e773466db1c6d3dc9702dc2f47608bd93e3296db10f23f7d26598caee10f30c9c43964b6fd8d4add539dfa3730d131f01b99778a22fc740ac35d276108dc27bff5670d8d896c26ac1dc221a2beb10c7dc79a9fe798e323af3e8deb0175924283892e96faa64b48ef7fbbce6398bf6469a917535c47302be8958c2f74af8280f9750785da14f2ed38096a6651e5739a4ef67e5a60ce527a93b463a6924c3fbee9b490a94379a2bfbd3c7fa12c278ae6d085186440eca844c52731b9494ff463f16a595f049f968dffdd3b2bf5010d4d64a89f20c5b212a9f748003a630f9e10b19c91361421d1ff6744626115de71811030ae4a31dc9b76d04552f789e35b6bd2f6ba48de68268577ea7d1fbb2c65136b8b946d3ca04edd70c2a0e0e8a6a3b04cd87b7edf76ebe41258d6946f0003c134427d86a2710bf04d1195fcc1a4059effcae9e0944b5317dd3a528a3d4cf4f3221c15a51b3a785d8006dee917a3020523630f9a11093b3865c913bce0a7340911c141cded207b01669d835b1e505ed28dda77dec35bf8d9ceeb40f043ea8f0517c067c0439ad33646f2675cb82e6a8039efcbf9599e9ae17c8f42c74607d8ab2274864a62bf66da1465000ee3c654b228f605a02dbaee4326a234c7605bbeab8a15e4500b671410f2901b1c2fcb2b1e94ee991a71bb522fe424cfea4edfd0145d795efb365de19cf45ff7dbf60b87a36857803d4ce67374fe536dd221e0c8a5fb1345e37e4236415d56b2f28c659059534a04b763ff9401759f4798d569ecfe0ca88c9fb2557e6b9bcce432827d6798df4735168ef41736dd7e2b4e2573a0a562afa8439ded185918dc324367319aac9bbc31995c6b2758179e35c98e9119f8b2cfaf7bcaf46802bd2deced4941eff3aa323af9669438f3ce3699022f64905fb03a598c049e7a2377d3202af601fdc7d769dbdf36a353c9c740a264cb36da3bcbb6c5e5a0992e8df4fc826045c5fe835e53662e5a5c42b9c39dee9adc973892cd972fdbf4d4dab59b08e008d4bb8a1d64156e4da5e7f6e5cef44582dbb208fa87a1a6483ada37776b7c147b3719ec7d5c10202f8527b9012ac22b2ff6190412c344b51d4de3984152113a26f8826bd1c16140fcab415f666f39d30191c8cd6095b6f325a2cc0502246e2dcab76381f4f49cce7aa266574c2cd7e9d3615867080153c49faf30fec4519c11bac68f2f80571b4860fda7b231bfb071e45871f2fd064c574328648c3661d8c8a598ff7bb88b2bf255bdf3d397e52cf4ea69b2c9047e21a6c645ef3c574da9be9f1e4b490673ed1cdbd71521b514d2faa6500bfc2c0016a99c0708df7025603cdfa74a721450bdb0a8683d61e668b59ac7eeb757c3374e9c15ac2848321999d4269e23dbb2595ae087d56a161e2a631dfbcf50a29d4a79f77a781fe49b5cec32a0a4cf82606e29c7eedad8a9f7bbb77a5b7288655e62c1d6237ac19da1649785c89ebbfed75983ba28ac43d06134a58ad0967fc42434ae36f4153d517642b90b50f5d05c3aabc8e14eb53893e61ef2bbc9f470cb67a2beabe9d57bc8fd18673ac54fd47838f3063170b12230f26eef280e5d988f673ee1a7d3d5c60543592859a04ea8aec988a428e8f8eef449476618079db313f225428856d9f8f4eb401b00a51ec6b417e9b193847f71c7afb035985acba6f3f5556ba43adfddf09f3a564022638644fbb39e50becf605817487a71555c386e5360a331852cd0ab1d63c8f818b0fcde067138d3db39f2df6ac9359124c7424ac835a87035995c99b91cf8d6b001a42cbaa0c1899fb7ede3acae2fbabc06cfa29a32fc28064a9d1b736d889fe4d7ab449cec90d86bc414515f363532af59c413e3531d48efdcad9e0f700ad7774a3a5fe50631a12c455730338832fe54260cb2eafaf1ae48001be5155128a684d423f853d4496e979cef94f55e7583e9a247db75514b262c2b00f4e8f4637f6b492c8b54a47c3f7b0efe85b6934094a496696f64fda236e6d3853f56a27770cd4077a0a9f015ea4126b2ea716c79d0b2c760449e052703cba6c2687c68fa340b755a1abda6fcea702771c750b6fc04a4133368be98d7c2736470efc127dfaf4af92e38298513d00ed02fcd2af25d40d5de4a04ea7b6a8423754b15532e48c1a4f4aa6b2de9d6be63f25c1f14ff117c06abefdbd0b4781b47539237886e556a6bd75b9ff7a4438dd6d68093b19189fd9a4958db52fe478a9c730cf4d62aafe674c0ad7d763ea99b601ad397dfcaf174482b0d8419813057eeca01fb8b9f4f694f4cc0f338cef35c8317c44983e0e3e5ff620875d8b1d844adfda6e5246889a64fcf9a3e4db8d553120decf30ba107d85b33a040ea62b58599e93169b2f90b1c5fac22e0c2954286b55fe7edb167be4155e2da16c14c0a7de2cd832600346cccc18deb281bb044817d1e4b480ed6ad393d33fc3894a3e32336b9f8bc4d484760e8d0faea1e8b761c2c6b0f600506f26104647418269309adfac906d967dab7d90522b249b4c87a24501991e3a01464a9495687af151d16a05c2f312778b6828e40e68ae4039bec3ce38c64a2fb92c25af1c6620f3a705a6b9c138597b440925e37688756351842217d6c312ba5938586b13d7fbda8cdb82959b7d8931cd5aaa44633c58a88732d2a498694f369daefcaede1f64fcdb3026590a94c355ba2ddb783729b43976e37e80094924da8e104a4aeebc48dfa61a6abb8e9d47ebb2328eeb1fabd38fa455fd97d6ecf2703d4f379d626d82587795327a4915e22125683ff6c9a4321eead8c519b2bb738e112d7cfc62cf652f4ac334d1722b581fe5b5adfa506cd0290b31d8f46b92f52873a4410a2c6ed15dc64a9e43da3fdacab12e4af07b3c52a9e24dbb6650d46ec7851eb6c0bfa6092095546ff8e917e4f696c17aa53d87451c364b6de91a071a723404efbcba9bad6999363362b4ac2a7fcdf5658ab7bccd1dc1a7c1d345e5ef44ab31fd29b99e0caf906ae64845e323d6989f63cbfb7e7d174268c9178f0a3e75dc122c68145c91f964991b924e80d8716c26e26cd4ffc583741f733e465a9821342d253c4f44f2bad2aed61beee76e750e99acd2329985cce28f85eb211a4ceaa9d88aab5ccebdb948792a06ef2cc65def0cd4ba94acd8771388465b68926da2a7ae94f2bb4f6b81e8a5f56f3763ec62035b49dae779160a3898ecf9d2c966843b947dae84082020b1085c82b6000a037b302c44c510cc4a12fb3d61b74ae07af9ef184ee6a86b43a078e3cc9ee15486b84ef3b473eee94c9c3d46583a804db96b0ff594c194b00619b00ac3c8e29db547be5c21ad15005357cb4df30aade06a1d201c281f7cefce093bd4efd894f8d3647ee2d5516c4360b67a96839dead763c9adc6ef0fc657d3e3374a94ac82d72408afa8adc75931fed0d0855671ec851d137cf5d0b7724a00696c825079e207a78a02913eb7f0279c797e7b00898b6cd887f373019a66d6111c3899e2b382cb2a6d05319b5e25ee7b886938e041900c1dee4e651055799769ba7d90bc8b153c17d4ffab6db23db7bf55fd0bb884eb3d632e7a36a6fb95fb7dadcc4d6f2e18b0ee96c113dec71346969b63d5a499950ca23b7dde194a02f188ef278d6201d06754eb8f7ea1bdb0c0de828a24852a969c831a9c306241ef00d931d37f3ad5838b3e63dc4d384a1745afa10e7b9ef6151a81a714127eea19a82626b7b6cd534449178b6e0ecd92ab7ecdcc0b759c9737043876afb63bfe38986ba1131cc205fc1612cdf761944b268d3f1d25ab14aefa056ce4029a0679fba22a4a1ec62de5db378d739b5a403fe18bcc6c5f4b117aac2b668b2ec9e84e1e52f391def159465c1a03abb2411c59bf029a55d0e91eaf9e30c2d3b4a96ea85a937184d49498aa30fa61585d566e51f48cbae5ff15ed16d7517a2dfc04b777618599c96d22fcc625be302a68b7c2039e9ff8ddda451c4c35389aaeaf568279fe140d46730481ff03829dec41d8fdad1bab59512b326fad1ad8fa75044c2abf715cb153634920893c9c57578a735d7a2c845828280ab1d6daeabd1f7c2c684c7350ee769ca14025e240f06bc9e1b5bedb84a472b2a35c6b00a5bb3c26f2bb816bee6a9f1e40dea05a647c6e6e8ba208df2d6b5e838af8863a9ad972dc0ec60be80fdffc87defa6e49750c3531923586226ea681af6cfe060c1662a1ccec6dfad3251dade05fbce6fc77f5c72149e90f5a2a2f80ba414bbcd64b1a5cd54ce47d7bf8a2d7841578caa31cb86bba860c9f4aef1587e6fb2e81e0ffea9bb93ef75a43ef372d4e9e906ece74ddadb7ab3f9a0e87dcfab3613336c644df8d49f2806b82589de1097ab4e2807faf5e03a2dc7915352e4a28108512bf4ff834c077ee05bcae60cd34774571e3a43502e76d1294e2c25a02fea3322cada7720e05e6fb5638db1067d9bd80b598b34175697b27cc24886ee66856f8c1c7cc7c5d4f0d7e09f2c7535e9e3b638b4794801f8910dd078ffdfc9065fe5114605e0970b991ffd0fce61a451105e41e9b3165c7fdd19d00d3aeefa127a7be651d7ae2cc03f3aa78dab69011b4b3edd2cbee31d7dc735ae22bad235c4196d90a35560af85637e7441d5851c05339a1c10e3e2a42033500d504682b5daea79ccea2c901f649b6248f618b062385822e1a162c15f3c7e1619c339124cb2582f1a9c44a6a9f3518c1c434149c0258a57c7abf0a6d9e0d24daa8f548abcd745f77de28630714ddc6b533792e6f352a91239d8b66456b94328ef1154c907757aa99d087811d7ed0c29a6fb4c4471247958d4680ad16c29a7c7a4818eec3f67fa82f01cf461097f412667e01581c2ecee869ecdade159304ac88f94ed28b3b0990bdc081ae5d754db0474ed58b598835e9204a7130cbe897f6f7fa2957a8d41d64eb0af1e1db03d73c2f2ba70823a56213903f0adad9bc98b9496132056b7cccc4f4016f3e7e33354731c4b8a39eaa12b361a9b9e47fbfc2e52ebfcd765ca810ecc3d83c42b8fd240850d7cf9a8867445fc1d9013a4d8090b8eee804a726ce1b8f80eab81cdd1f0c0a949c0429f481784fec9c3559d26cb1a2d5809e1025c8cb30761d4bfaee25dc0873aef5cb0fc04071184bda6ecd27938c2aca7855380f8c8d326c890405d5db4b72e76864df8450617b2ea7e4eac6d533837f4125f54b7d7e80c0b5456df4e7817fcf0f0a50b2340d121cde253a764e02dd5c556ea2fb0e979e994e2914b52c8f112df669e31fbc9db6d944f8e5ab8af280248432b3a33e9a4cefe3ee83679d1097f2f442ce804c7edb85de004802f092db8c199db8452dbbfd11cbb3c12d46c25daf462f7bf0d6095ddd259bdf7296a06417ccbe363fc4f873bd199a0827f4d2694f8c208da43e5fb54e1c13ff94698305755fbe5c16380f26df7a159d8ce9deef62e7f4dc89d2e6a10734787d57e076109cef5e6e2b9134978b70e3ce035186b3002de960946c6fe75fc2ca59aa0e7a8cb73ffb9b68213695998cd00f8cfa8a31994affdca7971ebc7433d6a1f2e21ce0821741dc000ad97b538da54b78be894ff90a9f3df61cc76bfd4d9fbbd94f46e42ce17d5c3e3da82894679f1b488fc4f0f073d9a7f5635941d905c8c5bb948e0a627462bc3e7018b0d3dd598f26676aef1907f780bd1b65e24c072c0e4663dba4ed4eb4ecc2647d43df97bc889fb4d9d722613ea4d12284157e12e8f5e06cc43eccc80a3fc541e23ea9799a8bcc630931489a7c95ffbc271d7ade8880efb2e3f332f500ec4a8d2544915f26a3d16de961926c72d83481758c4a2a83d5432effe175c183d7c5690c9ed3916e9597559a52f009c2b7885fb64328a23c2c751e9befc813588edd3e56975afcc7c7016ef1cb75615985f03b1745f5f49707c2e2a023d7e73fc1f1ff06f2dce872162fbb98629ed7321463dd0659034403cb5de56465d8a5f53dabd5f8c2ef7ec3eb4310541c485199220cffa4dc0234e6b0aa596474dee0c7a9a1f8543fbb0cfcb4b332c3d01b6064c56f57028e36fb40f58155ac7dda4be5b56842375d9e409555317d8cd30866858eea8e24e1496e82271a6df160b2d0244a679806fdc46f15234bd28e04cc492e5c814996d3a5f2bf72d67fa7320c2abc56ae76f32a9bb67c30d905eab92e1d328c5e5f940bfb084e463d6785fa5dc25d67701c1eec042cdb345bd933528ac5147e241837498784e9878a24807800b7181260c84d238532efb138329192e9f865c739845072a0d929dcaa338d3345fe761a1d7e7b74b2c68aee0b1d23f9cd494d074ad82435ac1206333ddd6cfb3696b57579facb5900c5eb0d288bf736e3105e00bc26df06d67cf3e4355914d4719a6aa26005e5cd3c28791a177e477b5d54619f314fa90d70bae458c5d8a56553a5d67443ced710c9d49effd1b33c4b990524747d5bdf50c9baf15920708fdbbaf9b774728b0945161154dae38a6da0ef1b0349c06d27558db05c86b44dd86b72f73f795ae13b6490f2c51a61ec3217dc82b0416619fd5553e039dd5be0605594e90ee2b9efc618a8d2f78b46ba3143f6de7541c9831d2066c077d8482393f423cdb4f002bbcaef2e3747f6f0e847422dd615e6f9fa911501eee7de56c89563807b782f6a03c1b24e8fe393425a4385b7b06b3d6e82733f94e55536ed270866739a9cc96488f6c3c68ecf271bd4d8952a02492604c8fad59bc99bc594a7e325f97b773a444d343545b21cbae0cab893abe36d72e5a2d3779fb25c2686b7617ad02257a0355c9e8934add27a7a4ddfe9b553321499bc9ca2e688a30a83312f66cfbd21e2736381c7c3e641a33306fa487cb22b0c5463fea19d1f60e02472582223aff3eec6c833675dec9c90bc1ea23f4f5b32a277aaf3f6f3fcde64cbd0cbd473fa77729a562f0323b07a16c21e669e7e395893145f6f2024e946a4b168b651e4d935ceff2f3ecd0f4c7e28c33aa54f609b6d832e5927cd8775e9c622b6611df4d603fcf7e935bfd1d01b4d7609de1021c4308ac9ba1d62beeb80b1b6526900b16a0ed522fad58b2e50ff11bd6558fa9e1a31eba817632fc36a1fe623b8dbbb690021d770aec286bfd9ea543718186db21fca355526c95d60ef39f2870ed271de844b797aa247ca0cd2079aea88353410235d0d3c82c3ef9366ff49b9b89418f4a0e85031ec0a2352699f66a710332c315d0b8b543d26d1d891b8c449d0c68e6dfaaba70a3c873e9bfb8742a352be334d2c2e58f502cf2c3460fb5e5e6f51ee56271c641d8c887350dd2d2b4008723ddb231979b0a2a07a72efe79ff1df91715314590bd612e99206525b08897a4db95dc0c3732907e902df686dc071b98c934938ba502b366c8be9e7cd983b812e9adcce13c4f936c8ee67c85b88c7fbf966c5dccaa7849ba8c6e875c348aad064fb61c457e489d02fa2a1464c5d9565d5c1c14b479ce3cca6c79089253a959e854b6276680105eb8a300c5ee1eed64fc3a2deec080a5bbbc42c2ee24005f84c45437dba4b673d871bb90df0225c1f02142303ba6848ff3b88bdb487f95ebe823a69e9817e570cee55449179484ae1ff008dab4e02c1e81fe389fa06ce85162ac76ad6fce4e1ef1015cac47ca01875478a8d293c78cb7177dbd321f1cc9f941b54f850590bdae49795b66d058151b049663058d1a6464a5db5198b4e39df1a714659c21a9e726e664198037a9883bdf786c769012834982ce683dcef559d0d8d47127a4ec9ffea019303805764e7302f79dac152c956d666f26f7e8bbc89e11339f12d4e4aabedb3f3d9f0f1d38f1b4ddf8ee451cf607340fdffa6facaee5ceae6e9c11b4bccfc418998aa5c8edfb9807b53e847d323786f64871c1313d835645d919871829afd94108e060f66ae8cdd9daa06b49918f96979f90a8d3f484fdd5fab1ab1f68ee87973a24ce42ada2fde4e829311eeeb85db8a9f2d32f0b932d2e948935b05e690ed14c998c08a4aca47c27ae46268269b2bed13027eea24f935587c9fa6b5c706ac97a962174b45a403f3b4e5b0e3e390c85d06842467056ea24195a92068a2e5441b0c66f38861c9f59a62bcdba6a880ba1c1a2636ad05690e7ec9ed0cda37fae0ab441e0cd09de9c2983df633655ebaa73c394733f05d3aa32bbdd42e22f37ad60edd69b16f43091e2df956b8c587110eaadb5227a84f293ec1750945744f6f08f18e6b6d7afe5a55a0cf9d1ebba51ae6ead6a2dd6dd10ffceea132f01c7800829828eb9414459f4a25fad6bf4d42abd9d30c6f265aaa377b5ff5998adcc8f8e826f9047ebbe2b5792dc12b3e457d9584ef5b2b50a23c006ab07ac9127008bc2169d2eb9217629e24b8ce09e5413556dbcafe6b695f353df8cfb7d8074dbb29eb4d5d5b24d092107888c92d60244fb4cf0d1952f590458622ae93bd4a32cafa3294a0ee6f8d99c9e543bb053be06c83e8ac98de1dbf31d2715ecd33231356704f4738355792aaef51328ca7f40b1afa7b96373a91dee222d1e741d394dc8e5408ece7469d01f73e56fd5af55c9c556934ce1c6938133cdfe6b0d7bcc00fcbc73430cb395e5f5ada8976ee5096598028cd1a2b145410c7d9e6817d3819b1490879044586811216618dfce59fdfc97b66e6ba2b30a66aea3012539d58c304dd03609efd7dc75feb116df7f428cf3e9ae30359aec09c670df8e23363885c3ad13bac2a4b4ea493ec22b24ddb544df7ba07eaabc9ac5c5fec7fa13f8ef67f451bea5d4b63c9dd5058bffb3f3288f265bfa4eab1d40347b6e1260a25df54e2a76e5bf69c5cb89d07a3928aae680f440f6e759542d32ad5a5ded1e86721b2da5172b001455709602cb25cbc9fbf9fbd833c2eb2a71489715ac7e855e5ffff5f4192fd5b8af835a5a8ace59613ddc8bd901b7d5a6e4c613186cd11d1e1b9ed4626adad7d774cde683fe679d51ad7f681e9ef128a74382b8aadc5e5834b91763b9069607b7ff542b7f51d8a7013080de6cdc2e152d9f814ed12c02d7c4330c270b99e74c18799ea2897834dfb1ad36b53475aa7fb8ca36d17c9137cdab8cc49dc08588782559c86e3319ddc703e5e3e33c6b97ad5279e92c65fae10c23a6498f33d450ef2c1285e0224399cd75dd14e3a9de64306b0ddaa8577c3314f6fc2788d4d2e53387bf84dba93600291358228b5dca3727861d71f3fa1d833104e8114352e90cdfda3d698423accc1a0051e41e227e3e0732e9fc4f667e5b11400be07b776b3abc59eba3e2d223cf70e275ce9e89486e752e50c9a69ed5369e8df6710e9edd3477d7d1b6377204292357fc99360e34c3a510faff720ea9ebc9f695b91fa37ed847fc435107d8826c49607686471d7060ad68675c7e8b743da50b9840094e5e1292618d9d3098a248c4e854b5e4369353b3feca08a06d38cad1c59e5bb8b5300c0fcda5fa647c9a1696abc0db561f2893da7767c20880c061ba3a7bb7f8d23079a62e04ffeef80e622f2ac5837863e63ee6ae4333b245d384ba1189c0f73a3a535aaf6f40d4a6e08301ff11696d0fd75510e5085d51963b57ad16cf33dfa2dd6d13db2fa8683834ff0f0d28c1a630899abc52a534a36db12fd70ede16c016008e6f3f7e788666723e1512aaed2b03030d9fd895bbd5a5b98d764c4ec07d4661d464d55cc88d51041bcf063af0c081ff5797563460e439fc068a3cfce657c06841d6355a225c615a4a4f18482b96bcae652cf380ee592fc0484837966fbd7a1fc903485ab5acc71bf1857026510c8fb4582c8871581900b0b6b8e9c795335c4b8f7a0a8eeb19901a1e61269816b1f58a91fc57a1abfd8bed75c8e411ab0068de3eb2352ba036771deafb94d09c8a9ad4e05ae7eb98f6f9b101eda2e0d72c0b0e621d657f5fbf76a7d72a9939d30050cb88ab03937463e6abbd4050cc18be0761cc9bf3e6eb4175a7a64e28e671db066441a6f87b7eb42986e499bccba969516d06bc805d49249e47a4614c73ed5e01c8c14bbb23c2b97ab39337e635617fc4f1d00cb1483c5c9241a1cb323e45c9f1862c9118afdc98f27593366f8370fe63ffc5a1851e7effc1290d195f47e73e52507f1920712007d1d8fe2b9b0054346e9b7004b4010f6bdc5840a20906048d637f137b6474183e4c9c870ba8a8f46eefaa40b98d5ad4ca208bac7dd9c6b1e84b401199ecd07606db85c1e9137b33016d9db9cf112a651f358783f7b64454641411741652bf3a5a6fa202df28e507506b92e1bf97c76aab4eae56d6bacf296a3ec17d4e0eb098f18e85431b8ffe877931aa9b806cb87cfb191fd0caa4aadba4793b98eff459ce3b7fa66f4ca05a0f8d770a16851a219832c14ec5d5e621c373280bc2f8255f353e6ab7941b10d6e197d34e8301eaa4e85df5598014935feaf2592e3b1afbd379611ca4c75fe9f4a36c4f6830577a42b1b6dff4d0e9ebd6cc7c900f6190df2f4fe3d1146b2954bd2e10166ee72e16d6e6e3529a533114f69af4786380d20bfb5a3c60e510323137906b332f0b08ccbd0ef46d5509e13b68dad0580f66273b473253f8e7f5bbb5de4eda323273c879da843e9f5c18bc5bf2da20cf5dd2adcd54f8ea11d8e6f069c70b2eb6086ecb948b0e2fa9b7910b98d631bdf3a5934a2361eca1f4b0933df00177dd89ed17e88baa2d9d9b1802c7d175e28e1f1c58d1a96f75510bec316c28d704f8a4efe500143b72a3669df38d93f8d24e04f3188950a54e159668491084cd34107a512b3953f42df155a4734cf9991d8e4a51b070d0f2d9dd847dfb3625425a7712c0eff7f2daa9b7c02d617508bb0bae3fa54116de0bee4373722fb6d990c9b3c9154c016fed31e51303b003cf076aaed5be237e737a80b938ab9c78ac688c5de31e86d28a041d3b3d05ddb5898301870a451c1a7731c000cf8f6218ccb5869925064ebbabb020a721ec51911d2c3fbd83eb02cdf593b05ab855eb016ed063dde39136b42c530dbc6e317f1a989aa04503acf13296b23172a37f0575c61d267571e9fdb7d1e13972996906cfc166681bb915fd5faf8b288deb7435c7f846f924d3c380140739266015c1a3dc400e008af175c4fefd4a24e17889dabe364b91b615180f20e25d83f6bb1ae1e600f63f774594885063f5d9d4b022dfe8e5c4db08d3ca023ba6a3f96dbeb0b68bba74ba9acac0d3b9ac47b78118ab7ee09002eb5b624b3c1dc51f11c54af8f082b7f1570b3e76db53f47b36de78a218d830d6a57fec39ae08f3da7ba0de1949ff9a1e4aa8b840ba69081d06dd147f5e4b4ce9002d45514318bfa3d6884fde5a6c048265b3fbd5bff7925bba364bd9973c81d070a3e8eece3cfd964a1a1351b1f660d933406a42e6d2e0f5fea1b6d38c03c07595e5b91889aa87a25f8a5a6a9b4a2660f2469dcf13aece8c8713b64f941c0a91b2e62373442c2f5e6c9b6a842bfd904d00faa00cf9d8ba24483964d46d7420f3fa3937f739ef9eb5aced997bde7c18b1addab791ebe57483d12b976a79704d2f4277e9e2717e8893fdd15d44beda13b41139c62220f1bfaa194533064fdfeca6265a3c649b7d1aaee2dad8941bb5075b68dff060b878b6150e8be9c2b68eb740b31c79f023ae1d09c0e33a94b599227a7cdc3eb0261b893e85b8543406c2c51a0d7745439bdf96d0f5e053d6082b410b1572d22a948b77b3ecb1184c85bfaf6afefa4efa123845cad1be523fc6b6107b409618ee6a666575e5266fe00d3d701efc928ad74387de637d2ceb40c1f2e34b1867591765acc2742b221c6154dda53f3bbe6465af76ea2573f7369ad88b8fa4655fbdd9cc8f99a2e2b31883988c075752fabbc3ce3e8c31b970f9b2dc7cc72853360da350321a48e5ff87745dd12b126ccd77f465f5d2b03d5d3d2820f632d6ed63e49af26594a58197b10cc92d64694fc65119d787507e0f17841e9efe850a6a27df164e13330debd54b58ecf50317b7c3f3a7706cf1c141aef2f39cd81c7e68c694568ad6bc4c6cd32180db5a64fac1d843f485c1141977dd6f3b8aaf505c5749afdbcf4ecb92e57cbc0341bc7f67bbb60ff4b1a2f53225962310f0fc3359e0bd30d577e06e0b66e00c90e8872b91726d617dc37f7051343d6e1c904d92a88b2cade61b772230b5a7b83445a6a618f8653d446f1120d34f24d44270e21a6fbcae7d7c26c2eb19634e34fd27ffa7e0c828db792e5bdd8b845e48cc4cf5d471edbda7d4c4d736e9934e3cc14803d4d8ab2e2324e00920a92b85ea1bd1160c74721f09067e5d65115dac73086e7d639cc9068287af80e9e63b311495905bf5150ed66a228cd68734901f33375d9187f13af88d8caf95642769fc1ef4205f4931dff50024fae6b1bb41c7b87a8a0cb80e47e2ff2e6e6547f39edcf23f58277f87651061e66ecde7d83e1eb0cffc4c7a9b43d133d7654d3fa07bc4d9dbac800eb77bd1dc0c1b4b93cc064536e3879d5b061bba148a7596b0578bf6e6163a5dfd2218949f2080635a26c943169df777ced6b43f341fd47017a12d06feed19947180ef562fc95ecffb5c840b8435f8674d64a494efee764e9aa81cf53b10d984fe59ff8ec9b86033d7d096f0b1d31321c268ba784aa9904a390a0e20d9fc95a965c7bc33ad2ededf29001cae59d3d1696e8af2f333a79ce36afcc940fdfab53eafd9cf8c9d4861cb1b16919003685e7868ecd222ae3f9e92bf9293bfbcba158a698e404523d3f5080a2b5768b36692db8112189e1693a35cd4880df9b228c461b5696a0326f3765a51dc7e838d106d11c024e8da1ae287d6bfa580c94354660301ae663763895da5e6cedac0f54bf8cd1552bc01ec46d2b612b3180b87879250ef21a139b94b2f11543dd4c73210d8a03902bcd4682108c88fb0937446dca6a255c239dd0233d641acaf50c0e0ef003f1d09c2f99f9832c69310ee795cdd1654d1037307fa882be82ef5556e80afbeeb87f96f2620ae788afb560ef735f07196f7deb96834deda4e5fd2a6720412e94e333b5298c2e0b7f6791e2cba759fead6542e204ce387bfe9047351b755627d00561ca07b6e76d3a6b9e7e1f839c1d6107feee838c476e57d8beba0bf151b815d6c2f37bf52d66097a36ebdc6c33552856f8b15603cc091d14e54ae05919329ebb751f22788b83184f2627b7e766ae022fb34ebbb7483a901dfa7e59a93011aab80d43da2205d08b446eac9d729e58a28c69ed2f194d8d149d0d86ccec54042568e53d2b275f4ee313141fbdeda53b9007c77d92473a9a14d0f489221d9673f88a569d2e93e8199b15c0f97c1f56ea26cda1a788025d8081da45ad01880da18746f142df893c3a6a0aa41570b3649e578c4817e0d4fea18cfc4ec8126df1401f9c71f91cadf13d84ada26977b5c800422c453654da3a8bb2cd046ebebee057526494c84b5cdc6c5db8a3e1f51eea3cbeb34dec4a6e57195cbec2baeded340ab97f2e970746f2a999378faa35feb1a04319d99d77a937df92cc277f34b6b1df8523799909524511482e85fc693c075eac692ea0e5cd37b4b30bb7f6cdb52dfd7574b8f19169dbe556399f7823071ab8a49dd47057bfb845c049186c189e1ee7df38522fb72174b678cbe37179e8d5fc1f6c08e520c7e23f0a356128987c3c9b8a98aa32149197936d76edae48685c9dce296db39779885a250f67311bf2c0e55293ba19931498193869eb7346435561e77d4570bded6b842cf6a9a90cf21f1b264dab752f24d7259cbf1e38a917ebe985cc205e62939bd35e215bc9f95d22e0bf2f6614b2723e704788ac3c2222654b1f68b224812a58998acb96851b76418b8e84f2bd87cd66e5c441ec4e631c3d69164589b8be7ef7b3474cb4a2b14ac5f0a8b75a4220615b72ff863d7026e71af5848b0584355a789178305c7a8e28bceb243c249c555531b5d03cb16f6eaf64612c0fb4deef670f1e8b31fbe78907dcbc9b14f819b6bd25ce3312145b29512aaf208b3d1dbdda2bb1245aaa2841d6e18382d626566d93796b6d88367fb7d2883b2ef767f663bc5a8c3fa796dc4abd05e1f0bf5690aa8a933ef7c7a5d135dbee198d36b2628c299f2a558f2e960e6542b10eacdcf559ebafd00537750f9da46bbba0aadd33a86c7b75d83678414cf311d72ec414f6ffc83564677326fba5ed3f9c66f22cfb5b72c713a1421aed4bec042a331db2f9258d6d4509b1b7aba5a7e6ddc7f2fa3511e2eec56be8a120960817aebc79bf79e253259de4255c7145d14989bb8fd5fdeff9a7fb9afa3f60223845ca069a0b11c3d540059e564207ec5c4c4078ff21886db944bd3992da9b334f81f2c5dc583445d078b7dc1abccc0b880e6e975e8415a66a42074b0ff8b3f2d80e92fb50d5af7f2f552eb92c49f8e3a3f9bab6074f6c113f9af352a888bba1aa2e644b9b5b3f3acabbe73a70709b2645c1ec7ca980a5c4c4e6239a2a48176a3bb299c56de95ad038b45af2b8df40d07e8fd7fbd3616d83db63103a0d2be34aa810e043d262dc30ba83b809cdc3984d297f3add770e0d7d1c7f9635b3244f227a82e56efa5fc3e92f8f2adcec18762380952a83a1e9194c867b3de31db6fadbdcf82c4d1b57b03ef1de7b9e61b8d227dfdc18179d94fb654e696a76fd4cacd38fd429f2e5f3df06cda0f6ca83231785b22d6919fd2590284de2700c29a79ea31922097e14ba541321e5b782c56d14b883eede4a4a1d642fa26767e79864698f4faa94a9097a823ff5c6561a870fa3259a163cc007851d2f6f6c17d5df1999f41340ac11abc9f32cb651418a7d5c42a8e4c675566a87ce3fa81629226c71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
