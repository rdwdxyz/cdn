<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c858981edc9de0f48ecf37c1f31b9e56a4990ecf9fa704c56c63b178b97bb528b54240fb7e945cb5b504b1bd7db85dd676ee64de3cff55c2e800f8b05058618a224896ca4f416976f4dbd4d5da567cc1fb57f89c09d2b8734a83ed6164e93e33c9c194fd3514fc90694cfd7dd84db36bbe49cb6a91328d3c8327d353a88e8ac92c9a4f895679833c677ea8eb241ec7b2bdb33610160c3f6715ce0830b9faee7ce24836e4acb8ccc4208a9c46a50a682b71f2de0b14a511fe6ba67452bd123acd46f7cfcb078f1d3460572f5cce08724306b6e5a7a6d847fb8338948c9747de6197b0d11d286f36e3fdff07f2c54e8c678e38c5622e84268568192fb5f2d8a6c2044b656010a7d59cb81bacd91e0fbbb428f14b1a7853a54050c7704ba5295bdb6817bae1de6e28d4123d21475df0ab473834885bd7080cc9afbacd2c37fe8747c039e0f3876786bbfbe6bf7e5af924dd08f8fba69a9cb7a58ec23f863122320a2a5e213596d4a6d5f12d12985cfd81551b87bdd22b94cd5f968abbdc2f7436bd9c91904a56b5edaef88f375a6d9aa93daf3dc4b6020a7c9bacc7dd935078406ac7528bdaafddf6183867fab621b1757e56f1906b84c2c64c3c74b319bf19c63a01db83c6e308056446eeedd2a17163fa9c42484ea2e3a34a9b8ac84abf4e2e044f4e43dec27a17b353beac6e0fcffdc875c6073fa345e490496a362f5970850b0ef4f1ed4c36c3a857658b49a845f5de25667866cb43a1245a1df12fb7fccf7c91d7edd87d355e027514a7a95985c5cdbc0ecc0ffc64c8a667713a03d2434561aaa79967e00b92a62f3f1a1e29b7b2b0917b85e26aa8250af4b80cbb4d0af4d509ea1fefbed90373b01c83697cbfe0ede7c07295112e0edb08c1ec9b0dc0d9e4cf86576ab275125b030890601e3e51806824526c23f503594e2f07089510a55ac6ba44707ba60cd82107c55411018744adc4e5d8629729ee3d5c4d1ccb935273d9fba113a57da5a866367fb14aaf8119327a8ec7e745842e0791f5235ea0ead5a772e9ae6e222cbae3aa789049b2226e7946cfbb90dd9cd2b8a31894ef17727f9b85f098e7783dc4f93d300683c8775ee499dcbec6d38778c23cd5ca72b8878a883f92e6b29af8d52a76692504f9982b548801210bcd9dfd087a1edd15bfdeb4d25b7c189e4dda2981f411024d8d50271aad53bc4f738acd73e753375a003074bf01c3de0fc5c1688a00f5e1f3ad0281d996319da5558413a7a1b1abefd2accc41354bcfed36322e5f6c232048e41757c08ebd993a4b9d6ec5b0f1c9a42057a372e79b49a10e30631f5f080519c29ac321f7dca7abe6d11b700f7bd0200d218be8dff3b78b0a265fe32f8390673f96d96f30db005bf31267adaab6cc38532cff059dc0ae88eea109254f16e5a63ed13a4e52696096942e5a1459866485231743295530914e85f7d702a0f0474e70fabdc5762e20c6653e993a10562d5aedbaa93469b36882f72bf71995cf0820b2e4166f57727fd4d6f9fe8fdb793008903ba207211e72ae1b602c6e545c27458c4385f432441c60dd93531d065512e6ae6d022e1e0c621ff43077196b4ac881c774ecf49a3068c85ed17e370d265cef5be8d7885306949ca52325870e3d438822cc0a993352a9fd002bd777d012beed71c6992d4ecb9212cc671fa55ae2ee36771b393f606c721735cb622524893d54d44847f54a7c24c4d1dafdeef5b935a5b1d44d3d8d19bfbccaef7b11d6a3cb075492922af644846bc669b20b044e1edd6c610fd9b7bc7be5676bf92d5f6551a9aea9accd445194661ab4425d2c4d3103f266b58a428851a564938a3a0c2fcc8979f01d15cc306385fb5db4bcc35bd27daadc1b8529bbf63d52b5a8c53443e1cca9aa06ccd5f424e6298a6da496990bf680e10e85dbc2ece96cfcda309f01b8541959e79b36025a05002c798190b390adbb6ea63c21b50f8b6ea99b0d0e8a92ea2046b60fc24f665e38a8796fdb960b3e2bde724761f296c88fa11d8481a953e3440c7489662e6f42f04e73d94f962a0be44b54c3bae2fba28136bf133e3b5ef6093ddceb8f17204e840a06d46bb9126216499f6e663406f1d3bdf0723b01ea9cbadd7d5745a558e02d8d8183e3d920f59a108cbde3f10210f18e07353544b25529c9e344261955b17ca97f710d4a6265e098799b94934727334a7b0f5546cf9d4cb1bebaaa12cdea6ec046f30e8e8bbcef464fdd4cdbe7c85c2c721967a395cd697af309cb3b3bb4ef9c11a1daeb0496e6d52101e4b36c0f9044eeb2a45fffca1f6606c0afc7e1e0c33a341285cb92edcf0a50d1f400b8e85ffc9b8dd4a3f6a35437ded2f77b7a7b0778823d908365249c07cee38c3f88f097d896177a84858f54f12b80ab6b3390c1bd9226375126ff869778a2c4234b1b70681246a2d5926cfaacca37c8c66f8f3c4b0d09633e974d351b57470cb87f2dd341152e821cc9d345fe18a2113420f4f69674b59a9324ec8bd8a93a0080c61524e5c36350b3187b00332a7ea32f283469d37f91e6d0642edddfd77dedaad892e1b83973c85f053d384c99631f24c73f197ef2cd2c3652182465e1499a7485e2372aec6bb2c3c13efd01b6091ca01fa960d9c73bc15ba29a2c7e9f1c6547cca16887be1d0297cf75019af3dca9f2f3af5ce8caf4d3d3166568e01c941ad04ab1c73b829ef3fc266ea26a0739e7f07cd57b40b54324e5e842b29dd3750883e2a9f98e85cfa7c55749a95add1a6ebfc0c23c723c0b654470a970dd4aed443df1f34ce412f5efb3c248fee7a9f66e3eab8be289e5686683fbcdb2f0660d771e530f1e84aef8e0fb2d1850f2657b394b8eaecaa472880373f38d12638f883be5929199f8145f9906d9d9c334e4d8db798067361c20cd200353358489517ad2cd0825f5a19a439b3f55f374b1d2c2640fc292dff7c6e75ea99c75434768d414f494cc89ea81d90b0afd295b5099b2dce17d725bfb67b3d1cb74490ba9cf0b4f381eec14d94e4339c8fafee13f1c2bb8544ec15c34178d2766514ed79724457158d20ab35f0174b7ec12d4feb42afde7476a518bf545902287c86640643f810fd67ddcbc9f2e1a7478092503d46727498c201da38b8ec42a9501e11ca16a0b94afdea23c87bc2d870f308592b1d802abe7e0c09a55e56cc5f50eeba024da14d40b3fa5cc4be0bb57d3124d7390520513d894aa5002e89f0e1399c8130675cdb2d8633668855f20ffaef70727ef7e5e94b0e6b6bddb880737997dfc7b6e545e9c4bf73486b913c78bb3bcc7a80d17668b5b9339ac2363ea9145d1268454558873481c91fe16f90d6eb8071948a295e47c510e5b987e55c9a23d5c8e46426021a5e5d467763056ead9c88083427a2a77f53c5f3156ae6b4feaac939596653fea192dc6214dc61cc38492e73df94d73797ac7205df63a1c773d1fe4eaf72d6aef4baded232dfcf8eb689fdd7cffe9b1bf296738ac83d9289cb787e844bf80418971e11e021c6c02ffd64728b823bb965a5ef6615cbc9b8b3e10ad34ec162162af00ac7cac0e4564ac76aea0f8d55b7aec81b6a8e840093383ee1052512a2bba7797cd18978b81b0085a33f7d56eefe0d7684cc19e88e26962b18a5e2e5d14951712611293f9c64129b9e567c2b80f7729f73ce10fa0d5c17599b5650e72bdd193b78dfb994d73df9dfea243b522aaba5635436079ef03dad3093580a94c30a5983e2da99f1533bcb817304e484c508c325f316f3471dbef9e4080f9721e1a218ac9e6287c12bb16e6f99dc1d1b6d0acc0718f977fe3627a08312263d19e5e50926b9d6608f2ecd02ee71b3f2bd1e5a51cb3d401fba933cb2f2121424317702b71210af5417d63095a4cffeddc20432676ca85491284fbaba3980ffbbe8ae091d6e0355072c540a4a9240773368ab0f0fc19f219b59fdd4ae321f3838105e9a66edef5bd9f5e9947b2b79cb2ad656b904dd8723ab9d879c6ed266017f66912aaa50aec0a7157fe13c66887050fdbea0e43d454b66248de1f130435092e85daec2205802189f4a7b25f30ebb16b208a74195838738112f39a6a0d2c898b344de0782e38f5c055d2758ad023aa8057eafb9e433f33c0532b005a736068d3d6d506a37bde8700317ae2a8ad82e9c57362863a2b9bda9e162ba8013700ec5b1583a59ff04cf864c8bca1734c4457eddd0a9e2c5dca9dce5f1838469ce3c35d4e7786c3f02858dc8efe6ae642d536eab213c27667920ece7c3f9b4df9e5a2d361c17efc165aaa9a2bd82f9ade821749cb55c13640f2b2f0eecaea1c40bbbdedd7a0645ac22100b48fbb1c8a0f2c0b6bfc92f2eb48cfc0b4b93a34e741b02eb0293d53356acb252bacf4ddb8a878046f242872fa5295ddaa75c04d0c14460b5c461545b9a2eeee320c7a0256e4e560527db9b430468c1ecd562f40850f12b8a7ced624264a3d1d10ad62d4e4a661bfb3a34629310d359e7f34ff97e348c842520edd41388272dcd9dc66cfb2e4b46dd1405e0587ac54c711b7f0b4ee6fd35ad798e790c74924da34cf59ab1ab59129d62360b2cb762397a49a91551d1cfa4e01125be8ac3dde93d6763ee894c87ac0c47ce900340ce18aea05e9392458589fe26cfa15ff502922972392f6b271ad8a155b094edd52a4fda6be3566443f1f071767f89d419c7b943c20162aa359ca057b8c9b39b4a6e424c70d228d5be2fecda50e4fe986fa02ad9e295d10171272d9a37598124af7d4efac8702d36307447beeb8f50052a34b54e200664f907b044083b4e6d4244a37d066b4a9dd57647708af640195412e2c5b39b668a21cdd71eef0e5c78491882625df9e8b2b5b86e25959a578b5ce1b33beeb4725fc8f6e3fa63338d5d4f74847a11544f0dc5545e14d3ea7a708c99b793ee23d2101ec6919d6390abf677515c9ac9ed151178436c302f2a4996c7d4093d2f27e39aeca04358885689ba19de04020433eb5f8763db11f437745a12c2342acd8815e5d0cadd7f0681267bdc8845e2441f2baf82933d4c90d33b22adfe67e875d24181683c9a8cc93184d4b2f8605f9cc18ecccba397490aec7b34c595a3c8b6c9ef0ea80a7a3c9184132d96402be3154a3277a43d7a6badaac86eb0fa0f110c1beae283604cc8574c82428972d17bd3c33be577f1197a57d10ec8a380c4723b4ef91c656cad8ae936d0266947489fe9154302af96b13feb345da0d0eb489b4590134a3752d71bff538844235afb9c8562b9384e19ea9ddd629699136fadbfbd69f544adb2e14ef31058a428655d75c3189c1fe520df60941014098ecfcd7855facf8d3fed112ae0fff1e18f05ec556ba07ab25bf087cb3488d5b28eb8b2c2800be9e4a6c25ce716ddfe54abe29543d443e08f07fc602f0d5f726bbe31d1f6878f619994cf3b83e213eceb8ee11c04d67b9adf1ffcc329bcf40c1ce35e5e46143a549978ce05d61bd1a7e5a16476fa8549d8ad4487db6c3cdfd4b9495aa291b689bd96dd5f72fdeb232ad6d257ec878ac26900231a17b67c0ce91a0a00c50cdd379b9881ceb39ca5bca08d0c592330daa79dc5c0741ee2d1dcf28590d6574c5edc36a6d4c53233d199682345ad57f793d242755703acc1cc0a867939e53b2ee3428da705fbdf4705ea27759fb0c782d3c969c559aa8e601a9ba74d63cf714fe955d1453e4b237feac282e6399f42b1fcc69867545ffca73561718c00e0d55a34fdb3d3b92a79e8259c98dac96bae4c3a432a41db27e07a6a627b74e56df9ac8b60b57858f2d02cd17214e3241b645eb4565a1fc42c322876a7bf1986031cf998937e57a2be4efc4c2f25a228a9e947692760e28a07ea70a331e12fff2c2ed1221bd7752959aec0faa28b9ce731f369482fe04332e9036b294aa45bc7d55af0a6ce21d7454d649d3378b74e09d3640065d45f9fd738be56c8200274967dd5f94e73e0c059d48893250473b70b6be9bd6d77fee37e58067830d5d6a218a96dab97c4b3bc80025d8f9ecac7e0eb12529243c23a80b8dba7ee0ee9d65603e105120436c6906e0c6251116f0bfc428ef4ebb5a0aaed52a7b4225baf56cbb032bb7f5fe3bd53342e1c06f5e3ce057f08790b636cb28c264aa2c55ae0781e2696ae8747593f8f596ebe7f2f08ca5b7f82c6a2e4393c0429ff66519fc05c96ae621e06d1e434e28dcc64c432aa1e9cac5a1c8ec604a2798439b7b4aa99b8d6e7c67d4e5aee803e1a162690109bc0e050b2b345a708feb8ad6bc007550f6ff92cd7758d243eedd68fbd21be7da0b2b6fb0c4049c6ca2199a0ce7b0592da2e7316bd47bce6acdaaccc4df68961b88947449e5bed2f51ba40744c07c0caf5016b8f60a1379beea4031f5dcb3431f41bf0686d634fae5d0da4b8fd955c80f4c5b805fe8c4d332396699209594634c299638d3a78a85db30502265ddd4f7948d88fb87fde1a98fe044f2abf62b21290ef18400a666c20f76f72540ca4c8554b87f36ff07fca32a3ecb96d076774448a74bad799ec4ff8802f22b27a9448bf9533c1a46106c0a83ebb191dc3c0df71f350681cafa2b6e40feaa7a9761ddb55b3948a382fff76c43403ee7c5c4c56c21666d57c193bb4c0faf8162f2454849a3b4079e028fdd7c5bdeb24fe1ca84ed9dada84fb5538ee6f9f9fe4f9e32d7c94c10aff348d8dae809c95476d369876b59080c04e8545e63a0f27773a215176c41b81df640a1733e87c5923f05c2772f060f6be29c35a3d613bbcf8e430dfc6b8d597c5e2336accb6d4d2cccf4cb50b04fa826619491027000d6fe6469246009c15181d1399bfb3ec55b32a52d4d1aded45c713ced7d20cbe7c6fdd914e728dd4937928712e643d9f65666af6ede8759d65e6a2ca59b93bfbf2329fe7d83ff7777debc21e71f56bf28c2b648b7a01e1c1ec2c945e51706362c16042ee541cd2cc92effb381ccf6406ddb30e1b800aec7fedd5a275922142ce3c1d0fe6e6243711597fc6e7458007949b41fc7f2b3889b341174b3471fbcee56b8ab2fc9a1ca6fb299383fa8c89f1b7f6c2ad8cc44b55d5a33f433ceaff455fd79d6dd6b32fe9f7c37f101f167ac030bb63eb5ca34050cdb9a340e63e2c36b0db3d036bf34525296b68adf6c7c305a2bd69eb4c98fc2bbe73e88b8f03e470e83d2e960e213d07deffb853e8c3fc9496ffd6921e7374d3b0f677b66b73f3c42e9fed653f05c39b9430f023bbc73f3bdeeeafaef140d6527d45137371ef9633d949c5a74dffd8fccdf0f43186573421949b5bbee525b87738246c2753ab5425977264b3aee9d0d0332a263f135ab01572d526a784b072e05320a6e77662dc62d3e55023c00cf8ec22f2fd741ccae92ca21e3c62cd82d5aeb00476dcd526cedbfa87d6aebc34b83f1c4bd17fd9e8b39587dc2a5c7473748caf032abd88aa7d68029a7c16dd64f48708c6ad65f7a1bbafa7e4d2019e3566484e4edc5f2083b13756c45749ebee7f79f86afc318f9b6ddda1a53e5ae2f518511f6416309960d2c10c5106fba7db46c9ae08eb1af086316a0d040d6742bdf2c6bec8191da1be4179dce4aabb600071e1f2ab671a6b8df5bc86997f218c111fdb4952dd52073c9af6dfe560ecc2668501566d9b64791c84841b40df75f4e69e400e0935387f326410cb908feb4fdcc6d6d5e56dac50df7a43deff131afa119260aff6ae82a8c1d8ef3b1cf517cdb01ab4edcf687c7c1a402346596562825525cf5a05a728d1080f8081a186ae4c2f8f3ea3b8d918ff172d61e8bee1a2eee2de59ae4028d286b7d1068c937cb9c46f79ee1657a3e2966792a5ac2e246ebae0925f6955f4d4758fc56d8928b1b6268e812bce0949f7acf130f130a90620cdc18675d7d575bb5c7eac43eb1720fbf14c70ce248d698f01018f9e83b359bd68c3c347236a31855e59fbf12cf308911ffe958c2d1e869cfc01f1c16e9bcfa779d6bc7477201306d3689816be5c4d7b0dd8f3252f0800f1c1fff2bfe4bccc25086daaec21d6a3247d2fadf1a0f96c0746f261cc7fb1494594654192ca1f78cd1b555e28d7eebd2f11e2c5fdda7ec2c0ec965f9cf3b6f21dd9ce51a4514cc02bb5bca7b6413de01622e42f434aac6a61fe06df9f7c35a77fbe08d7295ac9d8742a060bfb6b69b2a39bc996366845d79bb446b002b68fa91947094a2acdb932bf19d83097ba1d9a1cbfd0e095c486705c9be25c8a8787f07cadbfc200e708fef46f6dcbbe9dc7e135f96a7260ab07e87e437960b53a01810e9ed92103432bd8d346a3bf382fb2dc800f9e1fc90ea21d347d45f5daa40d3e91e7e0428554227b0d8689c723d3d5c80aba075297995bb72e30c17fcaafd72cce3905066137883f7fb8cdd551c5950d0b7959efd3758eac08efcf7f63e366641708796c4a6e812b961b52774b7c6f7b71b4308b6fb4a4410ae21f928d7aafd391c8f550bedf20ff3b73f23980dadf46d521508d71e6de2822ca15e881f3e93ad4fcd43fc825e65ef80b708c46368e92448bcb9491f76e5dafe4cc8e8a9532c0a0add8bbe1e00b1751a150ef3961f5eaac14d16920354d691ceef2e4df68071a67cfe16f1f407244a2cfb6b22696dcf0b2d8835383a97ef989de44c79c217811e50b3c164162fa446b35f739ecd66caa819ec782e7f213ad28a1a104b30bf8c229168b07df1829f32baadde04167a21fc80b6e43232c9908f193c9384e0734ea5313fd5acd5ea4b9d4bafe671d3e0d2209dd04219554b0e606ba0d3c257fdfa94597ff742bff3e0a8c83a3aa64755a1a79579e95b764688a34e5c186665cd054d2a6557737c8f479d62e5be59e87fd7c5ef2e247b662670e42c99eb4bda8cd112b5bf7809eb81ae7fbc8f76878d5b3234ef3054e4f841e97373c58031ce9da97be559d1d6c88a97ecfe34895038440bb6464407cad5ec9d26eee6cbf8f5230bd7ed1feb12ca41c6ebb8e0a027345e36a941da3966da3e79f39966b62410d0329c2a87753efe667f77ef17c0e43207d4f5bd3c47124c43c5480509344e3503ea84b06aca2b0b90569f9bfad3dfee20d6295754da7fe39bcdbd382644a0043c4ec20ec756fc418337fac6ced8c24431a601d7ae7eb99601cbf59a16542f73986dff8a9d1d19fb916d295520c547d1744eddc21ec2671bd47df6fd1c82da0b20709363602a776bd5a2d9563bbcf8322ca47eff68506bdbdf0d5f3caa4a8df07637458ca243fb9f60524323bdd611165072932817b3355a598e8e92d02c20ef0543f507e49e65f1744403e217f59fe6e95bbefddc1d601fc4cdd77778de7455a1e77728c60c75efd1a4f92a15ec1367a9cc0b1fdac07c2819175584e05e05ecd6fe051c35994c87fd233809d307cc1ece2640929a672badeb023f37854d3155846558f6099f87efc990060c7c8900f11915995b82d33b613aa1286a4effd1147b7979b975578eb4d221eadef26da34449e449eea4b5623e9b40740625aa4aab19922d88d3d5e92f2e7b2776d8b9bb59a425fc67c22a6d92dcd418f8845b8af0f4ccf857030c84b36c31f68c4dcb34996d6f5fc282081d8daf6d64f07e7e731aa37e4f5b71dd4924a270108676a57f5403c0f09d2988f918986e7ddf84e3c864c86385678748245bb2497abd617464688e403c5fd8d16b3c31b4b66ac961a1bb73f03f7b41f32d0cb9c4353aa4a554d2f38e0297533f84d4591f5fc268a7cd7bb285861f4c214d50705f961c2a25c2b196244720e76fc02878a56be835b7474679f18a3ce78a6ac1650073263e6ef0043ebb855fe8d79b932b42179764eccf5f1e0bacd15e471739548de789bc76addfe6a6251d9850993c84fb3aa09c3f265f2aa6b79fdf8b31b4d6feabba388d2a1b74b706a5717b97b7f72b125f3180f8aaed4e8e1aa86e6f75134d9c0eb24e92fe0661f0d74d134c7929b312e43d20ce18a5a2f47af3303ce8d329dd4877b515fb3659ea7b6cbc58e5b033bb5fb6276f5fbadc5a06d6079496a6ad37dd5ad9967f8005baa247d635105411307d3a667103469aa773b34957be2ae6e56b781178dc7006cfe9733cfe6749bbb50b935996df88f320b2e1a761d9eb4cd254a405228b3e104f466414d10d5c3353603d2bc9a1a93a3190b626de940d12e827a0de748e83853e59e231b583ab7448f25fc7595b2a2e2546db33ca8b306ff15a4de39d238def00b133ab56e6254078a5a2a9a7d286ecf8cca751a17ffb5c47a81eb9dc165986a387ec336ec32f935e7bce19a82060b436a04b73413664124b6ea1fc5a7d2d2323a4cab568a25aec7a46e8dccdd34b787b16cf8e0846f4cd7018260670e87c8f136b0aa2c927b8c65f13831420c8d017c80001cd297c463d87ad17d1947dab1c39f25a804d9185ca43cb69ebd37ce40dc1feeadfbe485f04b40f87de463cfb293a04a783ebeccea3267b17b22aa7a7526b55efbb44aab1965ee9ca996af3485cfa18db9e1545da4bac50bae4068918e5f26d994bb0966d4ad91a5efe19496f04d967fb1ba53aa0de3a7ab45f7912793710b2aa8b8bd257beaac39c574960d0a25ca49ee05e3ca55e380684c14bbd6982d29fc3dff5990c020c3872000115230cb79054bde9be2b2ed36c66bd2eff6767c36df816c1f8b2682c451069d043e892f156662e237a2f03e147436b8dd3306c151a69d73cc1baa7f83048a5f2b4c9255895a670908defb1467392645fe67601bee95a04f36b09c5d49eca9c45fc7151e821ed9407fdc6bf017d48f8e5e4947ac96d18ec4be53f9fbe765f1e1f17566854607a559abc0e4ebeea409b305e89c2cfb9431ce7f2cb42d11903dac104581175957ed057dade74f10d604821ad9827e8b254274c59957bc6a350548440586b16927191f883210c7a4086e8df445c7ecd62c782f597470046ef7036f0791d5ad8305fafde0569721d9a099adea03afe191a1af25e97ff1f7f2621fff2a6e9a7fff41bf72b8eabc4824f958a091def0ce5cf40ae7f5cdd72617c2c809f4bfe7e46e98a36bdbfe5ce40b047285bdeee826aa785863dd9e35df85c0ea29cbeebf719e4e4122569bae4f81a1818e79ea4c74f43908dd6139428d8406cfffd0873feae3f07e87bfb51d210acab99639a5228970d4860d0321634ac45ef5f09ad6a576dd565243f6eef2b272e1e0d7d44a4de86ce2743a490e99339c257bc00ea2638f8473c881e7a4ae338132ab17fee348e60c1e467503820edbdba0a54e48e72088b27a0fd460e848a9bca5304ff89e27ba36f801ae4fe5ad57c0f291519c7e0af4bdb2f8dda262b8046dd99d61c3655adccf67eb17289748e86314960246809aa94d8e20e29f6fa556ec7eb287322431f045a2c677f2b3b71dfd41428b8789d9fd132715beb103fe4b8a60108e8bc952ae22deae8d044287e681e7df12feb6ccad1b0b3ca855f00235c9cd5c8d3a142cd67b2d242895023ab3c7f58dcb9c056c73a2ce2eb823184b752f25d014f665e0fa827d372b464ffd52b14b70bd5a48a3474a870bfd52bced32842c7a00b02d382d07dc2b34c73273a2698ce58d34c397f433cd4100ed9096c13097229d8c43ede14e4b7432aa5d4d0490fb0ef115be35267c8982b9b41478c1f8dc7f98203ef7d55735f1ef433b9da783e3974a83ff82a4afc5db6a9937156a6f6aa61f79032be346f965ebce9ff047153981a191f1214a14d879d0445ca5d50f4d1b263fac669e2565e0208a16b4ff4e2f35bc2baa3d7c9026c1da3e0418a89cd38f54ab8e938bcbc48848e2fbaab865670d955168f1fe4900aaee173fcc10aa71c24dfa661ed0001db3165e5025396a8c4226d909b8eefd9f0f4b055378840fc05b9bc8013931ab6a8df9ad3c7310238434211b9a4c8ff6331997058c8fa797b2bda88dde461fd385e0df5995049a578f39c7838c074e400cd681e0181226498e2fe737dfc21a0f8576f9f97319dd1a72d7a0bd4c302ba66edb0c0671f8afccdae02fce63c7111fb4e95ce7d2ed7253459e43100be6add9164212393a954fe10ac2acb99edcf1d38f9d8da1bec64a163e9c21cbf219b3ab6e63f7a4a5b38692ae7e7516ba7c2f3b7b9cc2d379dacd8078c15d4e51afa9c2ba2689cb46524246bc3ac25df641930e525e2dc275b01109a15b9626556645674ee7f279154d9fbafcf61d0362c8151c9ca97c219f73a3c350c1c8d861f4571ffc20b42fb79a909433494586113e49d44f23ada1fe5f4c18a6130d2c9a3b7ec72a6e0b261ce9a8bdb7e606820e325c04e3198312fd53be3bc51243d55033c3fd520b6a1993347ddf2fcd6b56abeca38fdb4373db7f8643650cecdaa5b89510492023cfe70f9bb0ef4a73015e5a318d86002f35cca4d5a13e989d9693934c2f008edbee3dc72403ee7bf277a387e99aeb9de08df0f55a94dff5e2c4d1a68957273c7626cc522e1a830c28cd74e89273f30a7a170f57adefaafe58559b5afb8fa7cf4d30ac36d2f784d818fd20a5f20b5d7579ccb325053291863d5acf9297d89bd4d11b8a40f397cc3917ee1a5b2e091c760d1c5521cb12908bec655973896fc4df119c4292a57125fba80008de11704a73d292ce5023831d8ff6fc9ebdf7ed6fc44ce723b4ea34aa60e94cefa1cb3335d4065efdcd835603f7371902065849fabafbc57665c5a29cdf20e8c79055006d5bdb8af6f03f748124b817cfc89194cde080305a131e10c42187d0dca80acbbdf81472a902f2b81021c25c26332d9133e85d04bb8d84d07012e905cfe907ef4bc373ce5f3a8dc44c387eca44280bbc37cb25dbea67066818909c3b3464e55b609ba28b976f54e3a65763e8e81b4f100c57dc61d878575a3ec54c081f9b5640e71729c2356fa308029dcf461e8148ea875baf43e1c227c69fd7ffd3144e5f397c13a962b34941661a737799d24ef1baf22c1fa2cc772630049cc463ab619fbc728ba93017f56185e55843215c344d155daa001f7d0c6b28af23c59b9f4b57f97fa7d95a4c90424ca15a05e1c318331fb4274cb5c11cd7158babb9f98723475a6c4a5f07b1aa1714617c010f17fc35760516ff72d7d18bfdf14ad747b979e357c433caba9db69f7fca9de9cfeeaa31acc3df802e4b2285053eacd4ad41d51ffb3957ad59fd4bdd1420966273e123f5e48d1db78ea51cc1ddc25e956558126317944ae495dc8f4b823bd991a0b3258b26ee02585f2db8579efbd8721b6a881ecd784bd62ed893e647143276de958d7004532712702a29687bd16cf5726dba80ad68075a249ccc6c1ba8ebcb50d7b43b1b53be0490f36dfa11edaf72e2c2e06d57c67394e7f72e84a970b3e8751c67504597f7264439664f5ff40db0613a30e55670c40fbb912d072046567f171106a27add368dabba4d28b8393a65c1690e3cd1a02e18ccbb1903b7e7d38befeef0470d15d8464a60a5e7fbe1b65125a0abd01522a1021e9359f16d1e8726bffadcff07d6190d0eda6b8e45124cb1de5582699a79441c022d2b115e9558ed90fe9273a24e715c23cea8df557f9fdfa030d5a124dd53de8621585f492ca66541023a020e41c770ad2181d0894275aa655497e7299eaeb8226ade8a2b8119c0b092a24a15ba117a225b45e4607f9672426e62d3a1da31362ec01f06101df968da8521da5483c98fe13e4f88e20c9848721eee54afed15c3ebdd111bf8b1f74b14ceea0c35daa0ea8b1fcae0c4da19d4af33344fe49b9895cb52a4b118e5102763045231c64046db7a74da6d59a0cbc672a544cc5f793db68c3a9af99b570e9d7d97c524ef3a0a52c4588fdb853c285d342bc17b0f9196677d67def35e6aad22960ce20d6aab4c85a718a8937ea2a257818d17791e6132485f483f727c27409c03bf63bc7dffb61f4ebbb72b6b675a4d656a041d2545e298aba1c7937dad2a5166acd8a0ca5f71c9fbadb543c71716ea9baaacd380aecf0a82467e7f4cc2e5d33ff59db930043e9833b4426350b8a52d303e8c4baaef8672ac1d7f09b73d81ea3126061462a2c518a01501ebb975fc58221472cd086367683dda4586d122341e763a74d9ac94ca8892344854ca6c1a9bd995c2bb2f086d70353d7c89f4a4cc719c5f104e034b279ba3896e23df1dc5428a55065d56d61c55a7b714d0097bd580660157f74ff35d8a95802ef17cddb1e6b430e77bfda39ea1f10ba257476f665be70785f8fa7f665d645ba5035441005e3c042bea48907ab1f58c76073f8d5db60c38935a22e1f2f191573b84802ea13fd09e8f58e3639dad4743c15107b6bf4c3fdefd62f9540e62cfcb2962f3b22ba10aad821218af074884905c1298c715ab9580a1441b638b4d9330fc7c51468d897fd96472a682841a1a3cacb7fa2d7d2edbc4c691a35d67ccbfe3462c046d9bf6065e2c630968a69479d49f0d58ff97f5a7daf6edf1324aa7de754d9ef12adb7e2c4e0a217a850e36fbca3cb5123b248f83dcc51b1869debba33cc240637b7350b8cb004fbd6d6cefcf8afe0f51bb5d41d555e52a84c6c52f9f1e7564d03061a89981134df97e02a60f6f23be21b2dc1b26c846aeb91c95111ddb325796389c44d37db4f668579951c6e551ec0356dce153ade79e05a970a437aa1938a0bc79e07004e5077f2e771788a6eff5ced6a8afaa526cf1e03a7816f21dc8c739fcb80e59db2888a69e587f73fdde3fa4f9db5c20383fa374ded9cd2318eca6a3f75991778e53f511e241bf897e923be446747726392298e5185d637cb334bcdee6c3f14743ae2c03f787fdc0bb4a63cc7fca9a8975fc4798ffc1be31eddd117f791425b0e3a26f6b932da43d45bb69b59a845436b15c87b8f04cf55d0a64a9b9f7383c27a106e0ecdc3b8f57aba3df735a37ed57b70471b998084bf94727343be649dbd053b9674f8293397ccdad1b5a2cd1febf374c668dd3efe1fdd3b85ece2637aa7eaf14197a1f2ca49237d62419d5c5c72f6d20a15dd7e6147de6bc9d4ea220a84d157521869adf2d2ec038ea7d655b5d1de050e4046ea2b7cf59465f12750129dd84fc8de80fc4bbfeda18aca8dc14118863413b1061c916751b3b7f2727a9e905d99b4c2c18541ccc07c947ccb71db80f7384cdf4a86297fb638ad35bc041a5696ba2639317f597cab865a8e07491b8ad8c0071843aedf0deaefe321c38baa0a7c13f8083f80583fd83ee27c270944bec26a28305feca9be36d08131f404f087f71c0d9afb6385ba7faa1f1a8231443439202512667b725a6f4292df1d16a28af0a35ba98734e64db3108695d7611682409bc759a785b341b689a02dcff7c22e134b6f96ef15afbd28b6b2fc0692ee913b63c3dcfb154aac79a76a30383400f69884820eeeba6f68be0e556471e6a13e735599376d04a4542228ed71d44c10e5c6f2b137e20b81c1da3941cbbef6d67b7960aecb7a6a43d8636fdbf3d84be75a9b6efc3349cead40c01a2bd4131b5add5163181bc9b6ad563ba394d8362ef6cf830906e58893a4ece90efd642a6de9a700d62195ac80e8c95939b5e65ff844d30a3b59f894bb6c6d1cb7c3f872ad9e3725903248018136a3d2791eec484d80ae9bbc3293a1ca8a7d8f9cd325aa7a0a2286c513d69f5f50fb8c305215fb2240d38b52fc111c6c0d68342593de71f520fee78120e7b7f0bfce00e22b64bb96621557f966e74d7880093dc9ef76aeb9eb706fe68a7d54899fd1a0273a97229619f7391f2311e6c59a70978c2e98dfb78c79ca17aeb4dee7c30c9e33de0d0abb522d0cddc78b8b5b8ac509e3c2d2d26e3b2dbdac73f37529a9eb233bbb492239e8f603ff6187d2470e2de49a6ab38eb1b7d0b36fd4357f0ab7bda8f84e6f083f08aec42531996b3615257f451d44376c15897800fb054203272d1317256aa696f5121fa3c44d80e6aa54c09a5bd461aebb97c677027fe10b1ec3eb3d5f09eaf2f5834cce7d78a54a43f41372402b392445f93c782714fa56911cdf1180aa6c46e8e2ffcd0c3595f685be25c13182a378bcb4797ebb74e2a4130a099506da534a1bc7578ae9e25f8650cf2f044c001c78d5a3e81c11ca932d720d3cdd3f7294bbe51152619dc1ebb6f7979c76f70dede13a70f0f4b8b8fa63dc7f7a2c7ba4402dbaff93ec4db8ca45bb8dbbe32b8ff55abedf78175b92741fe0cef4969d0fc5026cd45edd3cbfdd7af7cb9375c07cd78627bef3b8b61292da9793dbba0c2a0f1183bbb95a1f54f83137201373f975981f91e1bf014423d7668da84b573a5fde0fbff3eb7461e23d4321653cf05c9b2cac5b3771cabd843f3c238595a62644d5d435adae7e433c8fd970f777991705fb2c7a36859002669ed381b205e16a029e31874667be0847a951af888c810049a8ea2dd8c88c264f30a1c5f06b0e93c61e8689abbefa0a3e44f718b83feae001862596942e04fcdd7fee9fcdbf2fcc2227ef5d760d940c2122bba2a7255a7bf6c7aa2d10bf9c7a118bbff0a35b6b12ea1ad811715c5675b8376a83c8be4130bf761e1608094dbe6fd7a37a2ede6048c4c2067109879ac84ae5aebadf6b38efa6ac64a58bffb646fea66e66601e0b170816f7c3a3428c1794dc598e3e5f87e6f745d3f17b43aca1baf18841774c84774467ee3618270204c93e20164f3a31103600ccd9744d3a75eabba3422741039996db4d657447c813e3d0a2f15ee66878d4576b43421a024252f91f022172384940dd0e14110ed38b56dfc81af6ec44f1b7c2a533a49907296b443a2fda79ad9a274c1af52c513f272ccdf12c97d87a153f1627a8c8d054b6738213de2c7279c4c58e36e4a078cbfc326c0f3a05870d49a4a25c53c87af5ff52bb892b00c92dedb5f534bc4b29fe46a85852c67860c2f279908f75aa60f13aebe3642536c0125f341c051fae27fbb149359e403b8460f2befff10576757415f692dcc363ab604bc9cc1b3dbf17cdd6e0e52681c20257c131a38a762aa2dd7a411a0d70349142f871203e099b029f626746e3728283c4347659a356ade066af6df93bae359dddbff3c9d890f34b930a3826de5868ab684039cf917a2b8bd53656816ba8fc851a435ba2becac821743c33d19a8a9e4e9359424d7656f2304f4eb430871ca447624fa41647752bfe5ad8d775330710980c90ac72b22aab38afa89b1765887e8be78c9d562b1413fa4e8054504d7198edf139eef1e61c655e24a59732d5136d58fd8289ba221784b4e041b0a662aafa8c56de91aa4c617080c8ec5255aa0cc98e3633a5ee8f24e30d4f0338412c0e6a95efce35c387d35406a9de640d8fa61d7576ab62e0791f62c8fd85679f83735505f870b8de8606fe8cead34ae784a922ff66ce9beb465ff96a1fa738276dce17dfed27ece6e6b6e2548a09d0b7c8d013c3662abb47a5e86711e6afd5f556342ffae19fcb942600478860f9556fc4f24b6f50050c34b229a0949b25e40fbfd049c370ee0c762a0283723ec145e05eccc6ef27ea6a5b781ae6f21d44bae40044e8ff8d26fe0aadf9c8ff3b38530ae5dacc4c411c44e86ce22fca630ba845405515199f5c0b4061d24346248cf16706a0362d8dc1af970c361e5b4f3c052cf52939b9d0f2c1be7112ed18e02b9bad6f43c999a3330efb797480234307ac7460038a75478b989f39837852f8da44533619be179092c3bc07d2916042f05b28126883dedeae0eee3bd388581254700fae061a81698d56de245d58a248601a132cc4f25917b713bd188d8d99c067c5d94bd11ab913a77a87773d01112cf1349a2bb33016fe44c328fa08935234410f8d99e683ff01844690b6762ca2bd05de4e072880189f6edf80dc2373a0cc41e8ff8a6d10072a3943c13342b217d58d54cc0fa62a54fb223622ee719dbdbbcf32236a8c055d18aef3fad80f54961d667919d2b25185c6dcbdc20be46a5cbd2ea74b62e4e25250b102a8ce79baa0797b3359d485eb08368cdfbd54326998ba0569dcd77d3a02c1bee035ec06e13bca0bc29a8df9979a83798126fc2df907dd8ef2051609d8d15567e0fc18b5a68e038c67f8b8dc30e54f393e650e4b56fcbf9345ef83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
