<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa7b91766dd158653f835b846b93456259fe55e286897ae0d84bb33538f356ef8ef3ea19017a62127392337987ed4fdb5fa6f0f5a4b0981e28d2c7c1f8815a6b134d361008c438f08b84d4e10cb6de0c3ad4f3c4afad61cab166aa4b588190bd8e5b1e0a08bea40e18bc17f53b841ae3f725bed84063ea0d2edcc63107a397e51b9a06936814feeef9fd583ff241dd5b570457dcc039ac7f8e476c720e99857c3743526788d1a726f09adf65a8cbde97334f1f89e096acd2de0644464f1a566eb0854615e741a5a5e14352a6c4e09e69b4eb1ca7a9c19bb2cc2f8ea5051ab9fd777d381eb094dd69670ab44fbcdcefef78855eb783b93b68594d80c60874d49c6d799ada8bcbfa314b1cda693aec483626f60d2689b4101122f56f398ef2561228d61a7536fe912ad6587ec058767b4e6fb11059859196594daf8dfacb1d3ce0ff69c7c0c7e400ef3b1d5385a98cf62248dd316b6229aae31f2e1200aaad624e6b91bb8887f0f596dfaa2104f35c21b8870c5f7c690d7db8131fe618bad4028c130d999f5d81120aa814fdc2f420d601a0a5f4e44c65a13319c5c5904b1be46e31b6a8a901c2472537ca98ea2acff596bbc5b9b6bcc940de2b7476e89fce2caaa9260919a40bb9ffb328f391cf36ccd7cde08e61f8fb40cd0e46c241613f81f34a19faf646e355b021116d77b5ce327f120949b7760468a896fd61fa325b2b7ab27b23585cfd465cb596f778363ef6366eef6647e5333f2aa116d005f3845b40d1ae1b3e7c3b5ab14f5070ad3eea92729cddd6c0335b9a2a8a8722d3c7103eb5d1ab23b844642ef3b516fc6d7b8a77ae3dfa5c8bc63d4815160d8ad7d2f9bbaec18ed4b6541282ecf8c2a35f1c97eee90cf0875d4c6b9fb192a04df57594812e5601d605fcdee008e88e7e57a570eb9d56845a813c9e845ea6945e9c17f09ed828b62ede9da07268ce14c49c62186c4510792a54ae4b716e379692495490aadba646db3c4fa2def1ed7a5c9a1e3e4cda435dc58f74c9bce18f804da80540d73b49f1caab13cf2a1c096957fa0421ff3aa40b3ccf656c3a8dc005db5d25dce3af0603455020fbec8adfae1da6d5bb9b34404a019cc245fd2b0171a7a3d1e098214b23053b25849534900ce8bf827220b5972af51e098987df3263ef55be39618b08aee82a555b0370eb04035bb38ca29165c1b97b253e926e67d716f2bf21c502fd85c3cdff190374fdf2e18a4078e22826feae624fcb5cb6f80c4a4fe5a2a617a63972b0b8583f5a1815a53c35f84d6c0a13c69dd5f19724312b5230e035375702b80186c53e174b61bf1f5fa519d84dba309e5f43a9800aaa8d3ca17da63b1faab8facc053ea35e277aef4df0fc614d380fd21fde00986cb09c4fc23da547704d5acad0a82077ddda0eb561ecafc310ff5729aefe2151875a3411560beabcfae93b55d647dd2fc66853cce6cdb49abc824eef60494fa18180f11e686c9a01ce2c12c46e1e7e1726e0d6a879c9513a0804c28663e3a5350bb7edb65d4a14e8e2216fd8d6c71241cd3c7cfa1768794fb66e9fb514ca5d282cf5b514bc588509a596885dd341bf61ed00670948b1f6874d5c1fea2d0357a55790f58429d83e1a603366c503e86005efbe4624fc5e9fbfed80c14fede70947ea1b3b7b2a223342cf2b638f4607e37f1e319210e8cb08f637fff405a3119d9d6cb051aab607fadddc787f07d3daf0dc5f18bd1f09a7fcf7c0f6f05916ef7a0dabac9dfe3cfe9a341b3be7c72852889d71566ff50cd5c10bbc805a125543b667932d3c9b94e8fce4ecfc89c6de272cf6d87fe7d2e4197be6147b43511c154484f6f17fdc6a7fa22cc432e846966c8ba9be8392d752d78ec2faf5700b5a52560f60f151a0e8998b90b3654907623d6addb8fbd55b25180a9447993f632f466e606737e5a97552f160b905f0ad998ffb55e4e609c2124ec0e16be12991d1775cc7888dd4fc3750af8ba21b35b2127c5ea5cc2dbdf9224aa531dbc86d123f2bd625c6adc90417df61b19e886baf0dbb3c51267923a2923f9034393ce88309a1e46c59524f7f5d145193717ed31d1de421168a4a870455dfe851d1d171f369c75e6555c279869937354d156041b802f95dcc1b3ba0ba5697b945fc39754e613ff9ed6a92c2875fb31347695e12948cc62be47d6bade1e2db7ec41f16a41da0b633c6a282bb604b90338f807773d61d78e52cba6d9e959aef4968f6f1f239f01f27fb15301a4de0e04d2ac0b2409ed203f44fda68a795c89e3ced1997fbc0b656850494084d80fde5e11bafd0c2f00619f232612088656c80956fe665ae8c2a19b0003d24a2cbb977285a9ec95fc5b20778909a7976c0ea2aa9f2ea0a3b3906ab76cc53cad238923013c815489a7b081760183da301dd2811330a46c2659ebdae600b65aff5463831313aab1c1894dd76883e418c1f7b68973d33c46c087c38a37c8e478ec3eb261f63567b4b53da35ee6ed9ee517437f27137149b4ba6d3d243163286a1ce2af39f315f33dbe291e1bd0452ce3dd3302d9ef03aa59b7dad9be534f6d21ac296033653f9179c817165e02eeb988cfe4a644dc162a4926d1fa09123ec1b9a1254e5c8c8d4cbf04bd78ed5c7cfc031723f33b16960df5f6fa38ef5cdf81ae0831a491e5f93d1809d161c46ef71a7f39d8b7fcab6c1f5abafb0c942f60bd49d7b84ff5fd73ea758b8755439a16160056fc6620a70403388527f7171ce1d69c838b4e0acac014fd60e6b9e564289fe7a3306ae4c8c9fa732bf6a78e6e8558523c3caf016ad0b1a08db57e719fc47f51e743f7a615ef956334c6f91cec23d2762158c2b1c63252b767a5dce66f888d698b27e878af27691c51cb23ed949a8fed3ed65b9be10421e4e6b97354bf90c5f28c693a3c38cbe180f50f280545b92dd26d5f9e741785f9247ac0c0e8fbe208f21b90f498e19fe64701852f519536e68958b87c82c15ba4724a9826e24b9d75532c27e7eecbd873182a5bad87b0cc95718796e7b3f45a98c75b8353fba12d006956ffd4aab7a5632d3bf15e087c40c01adc102172ea1eeee5d6805d388d76273ce02c4c82c3681eda86b6b86e4e5c217e027fcd0e786900f7e821c49d104f46740f0e17c492b645f4cfa24882a450c753c80143993c448369efe96454c1ca3673142e60764b8b659515bd11015c96eefdb708c6590710bc1598bc14c686ef2b4b0af4a63b890719b921025bc3648027bf15f2646a5b182a21fde024ebce5dd436297e2718e56a079940631dfcd3743387b70218ddc1ad5820587c9403c90fd2068017ec27e04aedab57f305ddb9d763c954634c1966c762c39ac00c890242ec8119fa248c9974964a92e8904b1c9e53b837552a08a6d337ee6d52ad01faafe67a38396be43b11116cd07e6770342516caafdacbb9aefc29aab1f992553179231efb3fefee7ded06f1afcf17aceb86c3889874ecf4458765c42e007dee58100638c3f6a89c8677067cdaa1dc4e54b2948816b9bbb4b263163414c49d74e5d29c4f184d114efb9ec1b94fde642e4f2ece9a6bc459a84f3ba24a77e993cfe6b49b6ac2ca4a4f88fdf2bd1bb263496930280b7d95929536b3c0cebb964c0dffbad2d037292f2aa03bb7979f87f1c1da3ce8bdce63635185c2c99169dd0b7470291de13717f50d22ec4505174010d9900e302d36d007d79134332fc47acd823e405691d31c99e17211df7f8042465c4aa61db5fbd5385d565b0b3c11e602beb43e9629827c078f8e1980ce38e8494c35639bdbce342f3594c18539d74cd554980fba697b38a457a13467fab2df24eec519253fbb570cf4ac2350611ed0ccf48dc3260ed091b3c95af5c49ce2fc1633ea857d19620e4b345bd5330b8b5ddce53de4ce16141124f3479dc0cf3fc397fc6adc2cc3a228b79c9f91f37c55dd9daa9078714c085f3a976085aeb580a632172dac3af1c0571696344df0d880503532cb018ee5259e0e9899223e0e608ca156a792e1b2b3387dfea028152cb6c39ba99e74944d8a584d9b6cf4228bded51f73a40c887a916ce2fda08738cfbe00da593cb5402ed8b83680b5d9e768541589068be07ea6cffe3d54fc26533181702eda25909e4ca933acf6969cd00a788ac3b4181531ad0c46c4803f052c56712dab904e4f683bc8633039c3afe0b9d6d45f4cb370341419facab23c79fff00d2611cfac1fba71bb3d48d08aaa553374feb32c2b8708cc4c334fa82b07a2e9dc69a8a58289049059dc5e083ebb5230a54b384f58b92c928c5c6225a7a90dd1a1970126651725a8a235c0fb29d3170162f20e62f169fd9f45c5dfadf813cab147e038583948442f8f9c9bd08c884d7bfe8db35f4cb5bdbcc4df5e4453175040cb8623e10405e2a60bc04177725f0525f4fc33af3958dc5a5a3f73856068117000aae0cac8057dbc456e76e1da9f0b06984105cc89f2f8d87cdae1b9601dd28ef787267795f076fcb61bfb563a1e51b3f6c7b5f5086c00e0157efc47e21957f5fe3e88c7c9c3c427dc60a641f617d62a407a5e3a6f57551b4e6ce460c057db3b7c4cbd49a950e1c6b7ab2d9e74c1056fa08a55be7227d35fd18e1121c36739a9dcb3bf02bba21e8ebb9330846b6f0b7dd5154eaf6cf5460c5361cea012a4246333629fb2aa96a4b7b28570a63ac6659ca53d410001f15bf501f387af7fbf5dc9ba8c72e74367c032a794683d223a2298c185362e0ce478c6b652b53f2c7915564ddb273a63a3931024c23d255b7adb061dc5650f7758a7070df0ea0f9ee07a508ff4ef7ba722f6448b28851e688eec12a4b2945d0e7231dd47ffe6ca081510b966f0627a5e318cd6df67d43db77dba438bd7b11bfc2cad90e52e975a4900067e5ef8b29d9aa21d142cefa9792c371962e61475d5abbed2fee2e77dd31bdac79b4798c50e11a5c2e297eb954f8c54634a2ba3ea3f899015cbcac29c3c823686502d99bb40aa1278c4ec3337216c356908977bec78d6e0fa265cc36eecfe3112ec5ba34bd13bf378813537b1ef338854e5ffdac294aa1179d22d6f3a07f4ebc62a384b3ad772bd7cb4278e6029715f5a271b9195453f5d8bbb5e62ab0b31e8917588039b710e432084e77b3cee42e50f06611f43d52b565f8d9eab062ac82976979321c619631fed5e8f6aa7f64699d0f91280021dcd805e12189da5e39edb59455a233b1d916c9edc05efd80729214722ca2ee44d988e819269bbef3340ccb7752fd2af1c03ae2500fbe2ebf3d64d379546b42ee667ef64501406f4eee8d26244de234a5a2dd8e3deacbd977e32d7327d201dd1784aaa94dc5d38d12f70850de8ad56e5a1a19465a6109554aca72f72ffa94f63b6601194543ca5a0683b141c57408d84a181e8f7b163529c4b68dbfdcd5e8a29c2539e018265579e9b7aef4edae1ef5816799589b0aef32be43c8b20650fd6e92c8df87979eccd81133bde4b7c7f6dbb82292488b749409e7be4fa45ec09843729fd8b10c7d9a5ec2fe9e7f40a3f2a27ad5250088d30749af1afa62d040bac3e94aae410659291516bc3ba484594d1d31d9c2ca6bdd6d452dbc533581675ea70bdbc0169b9ed9ac842a93ab656d1c5b344c6f032ee890059fb5fc00981f0f8ddec3cc4d7f6e871f15e7be450fe5d86e869b162110719162789cbfdefb2be30281d4a7ed09672c401da2f0cdd6201a9942eb7c54d8618a02e2a8b78407c467620889d300885f3a035341bbd9bfdc7997cbf54418aaf586503984600c0af24685defc0851589ce543665600cf1d164bb40bfdf2af2688aa770f23029880e27836485a5947382f8c50951595d0b0bd4fabd61849cf2a4b92f6c547abfa03da04105492370043532103da81eb3e6bd25c9b596a3ebcd3bf9ebeaf9bb97bc52bc8a4248a00fb2f7fd749febdc1f37bbe7a7f143d293f0507c037a1f47eaf88e4df74fcbf44f3fae6b04c5a854bf283ae30fd6d050c97ca6d6964cf153486fb4ca7f4217aff74ca3394855b7cda067008b73395b380b130e84efaf8a11b2b66b293d480fad5ff0e6b2bbc528f3f797560282862cd2b0ded97b9127a4427a050d84afdd1484eebee8cfe1e5f185084c10972161a8c83e720de0c51eafc8fa220a624014c74845d0c93eb2f4af6e0f35ed9219aef384a314b5c3d9296ed50d72c4479369c580f42a08897e834375dd66d21f70d5434a89b91ad684f6da20ebd422ea363f4913d7b55e3007a60977dcd540b57b5ef2ebb500bcdf570962284ac5a47676d5efb49763802d70def994bbd2a521bfa1f06e5707ea3b594ddd4830f2ee3af02fc3690d80fed76a700c213e8b403698bb3008005598c3ca932f4ba63205b67c41944e8031842d43966ffffaae32482bc8a14b8650a82947ba87766c1be906d64201409ab29404c90d1ef32786e33c596eae972a1029825a50f0d35749fd878277a8be349f6be2c7a9b41b39fbf2ee3ca93bbb6d5515ce7c6f183f15d3df4d2f2f067540e62af0d74696c848bfb07f63b887541ce48681f937a5fc260dddd39f7cc2796c9d8fe2e49032380816c5b10e65fc8d26a2a42063edddae07d047964a627d2f79ce7fd1405b3ade3ddd7a044bdc7d228b01e2be266b27ed63dfdab3f4236c4032f5581d63dc9304ab94b531fbb851aa9f56b72ede8073b7e27bdb886fa81aa547bf8413a3f69ed26ae512b6f52e41aeec5666356aa77982d200d773d4dac6219e243792690975b10896b0df815904d03513a5438f683eecfee323abf2ead11155bccc981d33864f4b1020b6605ba569f1298710e5363ce6bbc1c3b3138e846b082a7b5fce557c1cb2ef02cb38d3d3f5e4ba9e3439c16d50ea48208cce9d896ad9baf64c610e55b6eb14c909049fb90e63f3aeeda4f225d8435124ed0865d1451259d9bb5979a6f7774dd3f12efac36982bd4f8ea57d6b4202929f6483f5132892bd309f971c1271d896d2e2c096bcb34381ed7c0fc6023cf3e8b9e5d0a18b4326d87a419ca906d4b4131dc4e847ad68ef1d6c7ee74f3e7943c8017fdcfa7c1b75bfd4784c67607949178d56b36580b4a297b6c507d0e15546d90f1418358ca6c917bcd74054ff4cd295ed31038c3fa44c64988ce8c1f8bc6626656f3d2fb80b28ca31ca03cd3c8e260377efe943924ed67395794333411e6f932f14e06b1afd718018e5c23925ca434c3218f53017534a024f7622f552fad798be8e0f4cf4d868605ee4171e132e19aad21bd5600558df269e0cc575741e18143081860daa9f5de4e46ac10c37310ab8861c320598d2496efdf998c61a7250ad6b88a12278848e81aab2660e84be82b3c63b0d44c68ee203fda4045c3ce6e8494ccf9ee5780b2f87797b43fa681e016d0dc3899a4796a96ecc5249fb07ff613c7feb973494480088f1aed5d25a268b03424a1e5182d16649e06e69265852bbf13a2984025af0c45214305e52b7ae844e570deef7b621837a9cae1501995204c23aec478cae33d8a1f480c981b76f73edf8171ba4a37807e0072150aed40284ba7f5b2d5f1835bff0fcabd048443c8c83dfc90dcb4b7ee7d13e179fcbb785eedc4a5b5592f9172b65ce05b39924b437977ce9596e362fc62264b47d7d1799a962272b6804b3135af6cc070db8fa031174ac23b1fbb6fc0d8310dede770526311a247b3d48b1e2db6b44fc52b76413b31d50b0417df4f99202a30062d07c0d55522d64b606cbf047aa1dd8f23c899dad30391f85b6002dbe8d2921485700b7a1fabdea5424c8f50560c00345ac72c27c6247188e6bf4857bbffd05e53c0839c0de90a4dffcc879cc771a463d225dcfcfbf0c2a097c1d7b13ae0874d3a3be2ef6be3299f1f1053c27ed72145c18d9ff325e321193bf0e8b74e59b436883407afd0ce12381290d73f5c69cd8fe06ef61491682de716940183c2a0daf6eb2031f0816f7190737aa1f887d955ec6caffe36721b18a3897d031e54a1ac5e1924c1c10a489ee631c52bf63ca91e3cc85bbc214341a10d7a0bdf1d5762c70fb218d0797f5ed7bfda5b7f17785d5ce4b7c8c90767141dc1a4ebcffe3a1d8445a31e5fec757a97820c19bd73e04fa119775e95d3b17465a241aa76bcf013c7444e06562f913762e704c423fe2fba07620f29d18d2d56989c4db6b9b6990e320d6725a0afdbe463f64c99b85a345dd231c2e19ef04eb4f4637f075664e8fe5580245d7b0ce237301732413fdf09dca5aee59cba0f3c05650a205a6ff7fc18fd260a6a8b677a79422eb7a03a37b70b3e7730a618bc6db0845a7b835c53fb0c9baf16238f16f35e5f2dd0d79693dd386f81196828334eca6eb05df8d438a44e03770e1e99e69943c63752e09a3d49c745616caefd1e2c799752bd91ae0ddf1b17171dd79f800779ff86f4a0c287ceece2fc770b19ef6976b0f63655bf49d8f9b24027b21001bae4c166c3a9692c932b9d9f906d2675621e78cf7a9c95ae6006bab6d804063506c765bcdbd939199a7f26eaec74b81e5f3b9dec5f360af3b8f920451ce1461e8dceda5308f2fb98bfeb175e344802f12a1711a731342722259bc5399f5efa2444e23d0ae3edfb8c3502daa3bd28cb3039ba4e9c17b135555c4a7bfd5290a374f6d4d5d2fea4d35cf27052087f6360e4a9526f487b21df9eb38763d46441bdf73f416cf140800ca99dd5b721b2150f054cf1d06e4f0c76beb45fba0b71d6b22f3a278435a6e5177633b6695e658cbf094108cc8ed4030d2b165256e04e2b1b67c4c1ac18e6ce56d8e84ba8e154d89df4766fba3958ce6b80c558fd10f1c7ed30caee131e97ac1b46d69c2393c647b1d5a8b2b48d9785462348d8f19c31a0b96b3cc56b809cc666e7f255c43d4fff9cb0f25ae8755772882ef8c833d54b5fda2a8a842b6932d48e8dffc86a44ea74dea6decd838bb31ce8d4ca75627bb22e84a4075433b096a0b102f4edb86e21ed53fff7c28fd7f06f00bf3ede172e0a0ff9eb89ba1a10a6d357b9e438b7c8414245c4ae009e8e86f1c45f9d7354b4bdf31ea3e56637b5ee65d50f1d0bd8aaf30fce55a0c22a2a96648e890bda082236526c83684e324f2ec08d0f4802ef375530edb99f7eee62ce09cf0a259680ec60d0812607d95930da0bbc9fbabb94898e03d5a21925fff35e9b1a3c94313c7da0bbacea4a6eab83982601408e93d40daeb40dc26fdbcfe7de8f077aaa90a78bc02f6f65240ade360b126164a1e583d6021dca19dab95fc6b55f281adfbe39b4c7da53aa101c6d387d008f0bbab22c283f234a936b33a4348d84e8b687eda6c0936ef15acc2b2e0cb3d1e8188353dd01d19c561cfe7015baa9204899de9d4e0e39267f0d7ad5fc1c07bc23b3c51c128276bad8e6858363072b32262fce7cf89aa7c5e784eab3f48a3564c6253adfea4eccf262b7d4be311df03d1279d3b714f58aa9b7df7d16672d850566b975bbf520907f17dacaffb89ab7468b6b648586ae4a8a33181ef32f8109fbd7758532dcfb71cd9582e61c08edd2a16ef2f3e3345d95f073ff2c28388d7d22fcc8aa84eeed858400c53d804cfe4c0012fec5f3b96ef3c89493c762c28ef38051374befdbb97fe0997f8a68f4e70a8bd740dec4145376a3c514aea233eb948899efd0d08c1328cd856066db8b2ab8da8e946850194ba5dd49fc15ca0d1bf2d686b9fc9571688d8060d42f2be78ebe510ee5712bde90782113ef4d23dc0b43581b8af94e7aed85df79b2b3b704de6d7e9729dff5ca928c6c177f7722b9dd7d1c4dbe1eec188e550f2536b01302f5c64667e28d7c82b5149300025b43bccb62e97e534e3a8b621f5aa01a71ca60ae1d8179b50bb536051e89ec47fb1de68732ffc7b1fcd0233a27d59990f6a62e549ea6140616d446975fa2f511483d02e9c4a6a1e38d6ce301a4c9dff8760e3c616eafe19a26dc0c3cf7e1f7a6461a3080c60768311a7de9733067b82910e169413379e260333b390de04c274c849b96262bafe88d93a2c7cc688d23d5e954957c5eb085371d1c356d980ae2d3395e07064960b4b3838c006ec2decf158df5085c1c7c06e744b316f977619de5483e13e755e9187c6de9e5560766ef5fc2b0dc60c0113cf52e7f62e3a2dbf0a0fa0df1dd1e50d46c6e7f2be0ff1cb67014310238eb204b32a6076553d72d4181bbf8973d24e9712dacc598a4d9b2f26dc109bb775a2b30bb598901a0ab5a688482753ac5eaf73a250690a6b61a67f268dab5f5dad78e43cfbce90904e800a25a179c8db07e7dbcc0da29d887e09b26a64767128a87cc3efe6ad3b9519fa5de818ab9941cb5535ec0c10e33c81863174a2da490b94cefc13c106b433ff4f99552cc9950761a5171930e8faa4ec12894dde7551d1ef1dc6e806adeff7f90af49667ef2c432f63f74583749019b3cae9cf4a41bc7ef92f2c2deff6bfd33396de3ee5e9fe5c6d42f656f83760ffcdfb21919c6180a841ee99432acf9219a452d02f5b3bc52330b9cd9df0b6414a4e1829e3e13c060248be1a2e7f75455ef2046d23cfe107e74a234943599104e55f4450014c62a9c2d46db6bd83bda0d603a373fb342da30292d62e560c385af94ee4a966f98563688134aa0e9e160b5a742830701e39405bcae9e4e3423a0988557379dfae058e58bea3f86afc66a60108467213868067fefa5c6a13c1c75c21d40fa99186b9e5a938e1ed576e7ede0e4f67776cefd28bac180f2880827c7e2e954f66e0f45e6e242ecbe44cd357d79a9b1340cc7c83de0e11e15530d4d05dcb37eef25aa6ce0a5ec5124a737da068b019a945e8b72304b4c29284c70355ef075bac0f55223659b0b0dce9949a028b3733ca7c4a77908cae5fb4f2240a6537e98b2c3c2e93b1cc8c5e760141c342703f2c92101467450fc5296ecb55de2df6a246c17f633b4024ebaab9b52ba23a077cb96227b3f8b8f72eee2eeee27fcf9ca5899fc1eeaf54a9ca8fa0be7c414b9e381bd306b54bd66da5a7a86ba245629e5c9f91a6ac28a8681da541490766aeff3025027aa48c4a513a91b05475bd0319b9d46a60639c23c2e1f51b8a13e396388e4229a9d48a44e20e42e3b0364e236cf888f5a970e42aac11faa2c7b281e1c29e2fa30654a36918314cff1120ef5946c00c3a7426364fa3b657986ebcc3aa8f698f5bce733442efa6a7f9c71efbb86d4595499fb975fcd58650b3b9a1ff71be0426fbd0e5faa0611c040696f0da304c0349bbb8b3b01ec53814a98b1bbb82f7359a517a19b74b9e81ad5407479f4c37af0af39009bc81c1130382ddba2f6849eda9ce0c40b5596138f2cd966ce5bbf0480b0e3d3dd0d3a5efd659ab25166a555b1d6c5632ff9cc957a908daaa37ff29dc6a8f2c4812526a5419e36a2f34ebec43fa9a73d6090261debd0a20507cbe802ed93213dd3dc744147aba36109d245d232d45a8b4430a7fbe4b4442d69b512586b26c1f35f67f532437a4fb4c007f83caabd5e09567a46a7a62373c6b138e36de981f4f662cc277c85c5996448cf9ede5f734794dc33035383eb2c270658332bcefdc598e13fff968572c4b6af8f81621dd687ef14b56bbc2fa26c495f47753ebdf21569040290504e5d6f956725155799f3aea485193230d38588d587e349753ed680fa375912bc6b0e2066d2273f3a8fb938f6b12e2d109778e77bea4f2aecfb349fa29a034579e9366fa28ba34a73d0537220e1a4b9bf9227f7bd8cc37810f2f50147991e6e5c83c3c3c884342ca615fc8197d89abcc35d0df11d63ff280d69bf58fa99a798eed2f3f00f12e9c5b9f1f92d3eeff57f134c3cccd58b1268c3b31d021f97d35d07c95a6a01e25ce1bf7d4914f96c28b10cf9b9a1ebf4b97f095ab08b941e665321d366a021f40613630c02fda5af7b767dcb0836ffbdfb00063f79a551f192efbc059bedd127c2462d1cd8ebad2453815c097157bffb3f029697516e80dde65021be4d8955635ad79bb734b50e95ac6190fb13576b236c7ee5c6a6cc7885b8a7d3e44fe84f5312363c64da80f49d864036d0b52ee318d82d19bcc340b45f30f5005c9efb78ee4201d26c73ba0963fc6a914329866b5009185e036a5bd016bef23af9605cda54d10b2dd8dc3f995c2348192a81652968e128234797308d020450e3b85f76f3a63a2aaeb4851c5fb0561bf6305a381d14f8cacd7bd0e5e12e07b3792475728b9332c7e4b7c983c054dcf1061580291a2183e0dcee664987cbf55857a9e4a67cb0403c5ba448d2b88fa66c99e47c5eeab78da15341dab551347a61b6d598aaa2d8344ac32d2d6159621687c9ffec6462f399d3f3fa7b616a9f10ecbb29ab28e85e0cd3a639f0f19d29db85b3c752718c399385b54a4fcf48c092bafc78f7dae9a5f8ea312cf7e52d8918f032e5599ba65d6e9d7a0baa72b3340c8d9d7d8224c6d18eff4536337be788ffc1c8ff37b14ea06e5264c1ba1376eee3c1b4ad262de79eede64b6abdaed9d4a607412a2b6811f084ae0aa4e285924156632adf7c77248f6d3422128e3a6eb32a06d361891c943662882e8fd03bf9b6e75d5829eda9b3e9dcd2599319db960ec8ea6cee29e6af72dd5d7b4ce47094a7f38ac1a118ef66dcb9369153311a82e4bb530bbbcaf422dd95d0ca89eedb4820484eb539dc38a825e7122de84e085c55f2ca150df95acf74639c36214e8ee84933c23b0fc6b478a2dfeeed948c6767e8951c03ff3cdec77a71a3acd115ee78cb1abb149e5f018cad6a51ebdae2dc351a22351293b662a83cce65212dafcf66cdd3a77b7463911d9a7a72e9b870ee164314270068bdeb9f12bc55819085bc526df40764c4d1cb921f90de313d9165a6381d4772dffc3a9753d4fe5c6a7b552e20d47547f28cbf1efaceaf1089a4f6af5fd79437d5ebbcba54151200c58504b19783441eba984795b0df8455a28c3c20c45ddddfaddbfccb03935f72a42d14ed275289932758011c72721a95a6ef54e3cc2e1d9e96a80f8d02ba3de64b532cc9729f3bc1974425f1d4fba22e6681941d7d197d9d99e7b2090275919f867314a4e4981d705ceee9e17773a29065ac98024ef977ea029111e16016af22128e506e2a795b6d3af45e3358e12ab9920a7e9bc30aecc2a41d430f641e874bfc178e2d018e9ed9410494e51777a2e589e9fb89f1d648d412bbbbe2fa6ef52818f030bc8e472eede559a0d6aeab09b16310ad9f2ab9f90e859839f457b70aa2fb4f50ad62ab93267cfc8d9899e2eb1a93ed17541fd3d849aab846dceae015dc9a824d6ff9248b204c21b5e1f750a9131bcc838471b10385139d8f957dfbf2c082d4ec7acafc56baee1bcd9746a8244dbb082e02191a2d53fd16089212f44f14ea853665c30c051c8a34fcba1e4d64c90f82dc2fce2704122f70a602e442dde3dec3303e79cec209a386ea7f25edeefd0ad85c6df696a48bf04b80bc28f91769b0fdab0862851669708a0d598fef58a5bb986abd364852714c41cd5b5269c3840ad2c47ff47b9cb92e1d31ba08447baf352f69a2f0a57791f9a77e377167b9b6eb65d2acabb7ffb3ac392690fe7c1a85d2e7397ca9f9ed6b0e430724f4be8717f23d1a5998b8054a48e537add26a3232bfdb94b74e4bffd527d8521c971c9bd39e6f25a97a6c632a464a62152c2d8dd9bfd3e29b60f00eaeab92f4aa4aad7b0b5823be1e2ed56c077e76c06635a8419393379df783721b1b5bbc5c456a88647fc6c3b4f80740c6022abc46246d2df33ebd6056ac2315c94580a3c93706cce4a3ab0f5b6f0dfba542ae472896e41bce95bd53ebe775051315eabc46aa812b5d3c16d89094408861b4b62df111a2cc1c079a3847ae6de84102dd4e9fdf37aeb824f8d3099e0e3b38545ed798625402fcfe2c88aa2338a4afdf970904d4045149fee2e8c950af1a28db81b0e256c24becdd743aa983931086bf09713da4007b24059e7b8a58179c936bc7cb28224782056209aa61c657350dbd18892340c67c510b9ca0d1df3e0bc7fa146eff800a3bf386798f3fe66b91df75e5bc03e302dbc7f8504c192aac4fff26af5dc75ec6c313ade7d73386fbc9caab8ea7e2fb6eff87c0dd126ae59313ccd03300efde73b62ee14ab58d4b74cefe0993b759af52d62ddd29a1cd39b7f04f61fa1dda439c278db78e7dd433bc9d9076c40038a350e217b7667428c10fa87bb0de16c2f8100eb75b205daf378889d941b91810241008b2c9ee9a64f73a269a7ffa358081be7b4bb8b8e4eae6991464dc28807a4ca1a6dfb05a0662296418931c43ecbbc288aaf48ca621e1fec696fad1b76b79191923d5b30a10910781c0ae002060ac9b2cb1ea99fc24d60e4a17af8daf3390d12f705e1fbb801473d8286365b7023a3ed744083dd327031640c2b55f934698b17f0497987c2302551d0e40ffd97f4b1bc69dea5225bda719d1b798692c8e28782a6d336434214c219209b31f1e5c3fd9fba1024362b5de4a584d65f4abd5e5cb59eca138db80cc6b2d357d4b7d7eb88a6922741c6c17b1f8ca6eecf483e37e74acec832beb6d3a203b83f6ec95a4fd6548c93ed80e8de52ad0b6b53950e2c39b15410bcca503a3a131d47bffc71be6c888a9b5d42b2dbf0fb297a891464da2aa8cbd14d4478f082437e70374d411140977c1230b36993d19d4d41bf921a39c877d62d26f869d419319e08115a73210bdec143afc2628f4beaab57505c625a1c0a4c4f1e4aa7f04dd257b63d87c7f4f8a6934ced0b44a39bf261d7a0d3b5b9292690ee3bdd5e0c0dc098c50022baca61d5c956b28056defdb9577e40fc7688f24ddabccdbd159e1cee859f32d3640d5c595d0f1ed05287a8a57ae40b924c0fa33e3703dac099a010e353454866ba8744df391fac3bc14f81c8e94f3fb55ab6fa38aff004b447c4332f91292202691f1ae2f4bfb26fa2a62fbb2a27cc81ce53182a821d052a4cef5a1fef5fdc374bb4920712a48ae991a18723513e319da664e8cb851bb3c124688443d45d1e23cac9176d9b57963bae0e19adfa5e1a26ee7cd91ec1f60281c405fdf7cc8d5bc7aaaf8f418fa429ff5337950952602f48a2529b561b5d54b910a7b3038892bda03f3e2a9454210882d6ba09b2bc83c549d834025bc6e0a10d578d05f09ddbf01e2a4c98943bf622f52ba8587d567218427e4f5d9eb6a1b05254a66b0db52f1927b42a87577c2cbc98881acd4a56ddfd072303d0c875ddc4bcdea6f1de855478a4953e145838ef404b07ce1c4e412eeeeafbc564cb378e48eab2148bbea6deae8738f0c5a0205e8512942098e11438e352d2e10fcb9a4d2f651c11f5978219429e2b3df98e967c3e7e1194fd9373f6bd2d991d12ffa2c7a011aab5cb937e8b1031cd8ff085cd87239a8b7e41f4667e2fdbb42d0baea7bb605a057066413a548c72606004f5c66413ca3a1ccb7639a9389e00fce6f85d9f4dbd43554234173a59993b2d9a938f3f23a8f8aadb2b3037d87b1e6d1235b441b64faba3f54509b8d1070e88cffe02e4f0ff8f26cbc149a471ed67b96bf92fe9b43b4478e78c20c546e551ca69abddb7ebf02656766b9892dd3fb218eea8d2c45d473bc1fddc43de73bdbb30130bbe3f705e2d2a3a71ce803f0a3c9798b604a61eca9c17a9dc0391376b42662292abdd6b7877b47db4922ed7a11790afdc92a567371bb2ee7eab1a28b9c78e87925ea65049af4d251d00d6ba2a6e4cbf7832bc298b591ea24b39a6efeefd5901a49ce56b6a087c9a82d3ca1e08193327ca19d5b844fb481c1de1462357793785be31fc5c53439305e66bd88879fc7c92ecb9d38c8f5651306c7584b02c2c8dd0cd8177471065ac79cd400a4e9d544ab7ad18183987f3ba20474c102b976cf4926c2118f3154bebc16bd1c7c2c0595bced8654950bb403bde7f7aa2d4d7a62806aa96dd8a4f7ea17815fc3f7a4606dccf4f7463b27373c7e745523f601fdcbe93f5a70235c4d6c7fd9a1f063e9944ef7bcdc6301d2d5a062601e2733e6cd446e236426be5cf2686b4fd912e83930a329c987e6252c9a50dd0c107ba3caea697ff2f1b1a8b01e200e6ece381c54c4975eb75a78e2783da35a07f61f0b87a0a2f6fb208a4347a43a1f536955af45e0eda2685779420104b3b3db0198afcb61e68a70c3be1111883c0d356398b0ff1854ec3e27ea4327606502d821e4bb8a900a2d64d465b035f991e0c7b6f149dc807b446a1d4ed01ee8067584a8292bdb4cec723a45aa345825cb10d1794f5404a8c6514ee472e453aff65f6a2432982827d8fd82c1ebdfe1055616803646d0fb9317b5280f7f6174f957224710249c38ce6d576219a24d5cf9518e50068396a959621e3087530711a823d6b0caf499841aa000de6d5219406f49ee973071bafefa880e6130016cb70342bc42883af8b5a99ed363499c4d106ef210cabeb8bc0e8d0f80a7e8f0fa9e8f091062b4fe48176470a9254652b65eb024a3a6e5e6dd010c94b2292bf05df587d458bc2858109a7015eaeabb22461e95889e69bbb537489158e722a55a4763c3a386a913e52cc4a10beb445bf906ec40fbe47a2cacef6d16b8dbbe67a91415c00fc043d76cb0d22723c5e75960010191cd1a26ad243763a664e29594f2e3d8ae8ef7aa31e86343fac222ec76ddf091925a43bd3b7c1b7e6100b5753955d2298e8ab5193661e03a4a6e39cad6138718754388eff63dad4bdbed440a5f483ebc714303b847b0373741b77bab804d4c2c558e1489f192697a87696407f3e57f9f66b3de808645f35489afb6302b3ed054962cbf253837bb1e53ba38c8b2544e21c94d095d7f7855f907b60f77e7d52f638616235d7e627e115f2c0868cfbd9a418d1fa7cc7efb5fdf7993620c614d048db84ea47061b43e9ad4567ab31d7c5d0d94e7e3f8e69e338bd7559833af4474abf276dfb6ce0ad3749f6f7fa166e27b217f4dda5d8b029546a3fa359099cbc3728f9ed8672a05159a852d4706a1a75e153867bc6426627f947634a1cdcb09d5726ad30b540db7c84ba5cbc8497e62e191ffb3898cf633669feaa1ed58da2ea3795a9d42ff2bd6a24d512ede453e8814c65bccbe937c73fd7e4ec19cba6f3a05358c696a9125365380c16fe18b02b3944d84100d068e50bf82de74b2ff99564e970dae527d370f296a5db66f93912a692f31f1848458f09309e88f8de24f89ce7f638de70d93d271ab5d448e5019b1cc343d804918a377e8a252fd1a3cf3b01c7cb586a157ad53211a9b393da0f2e37c79df685574257ca26b9de32168a0777a8a38bc6d50bcc07c24cdb0c612d39974cb184a79bcd4cb26d115532de3d2c67d3321adf55e36a1b0ab5eee50b0c49b36004e6330917577f065cc26317100170c9e24727f28f4d16dadd8f711e78d3663271575bb4300ab92edacaa67ebe571182f6f5a11d6f08e5d25ef70e19393bd55f9b97eefb06eb9b16a5450a5541b336c86ea616701c9fe7d2ee415f23132b96de67e4272080ec68717b862ad08a0e0cba49896d3aa020565a921b69c62f978741afccb5ac4774313e5d022e209ef0090844891b5c315c68cdea9df166ae66b44bd3dbf5dd05a5c0cab56296a037555b5c209cfd36dcc53049bce4c260925febb8f71e1068093b38be5d96480fd4e377487e29831f35bdea249dda5fef94ef90a68330af92120711be7403960f3dd814ce1895bc61db6257bc6457d4be9ecbc6fa5284c0d836fe68c27bc85b30956703d3c488ac0d7c5e917d08ab1d6a67c90305e169e4cbf6ad3835256d44a0e1e1b6f10a71ca6bc886dd6c5613db4099f91aa47ca921840212632df1ff9198da8e50875e31001c0bd09787b5b86dac3e9dc9988a3d3fa5902903d181a5035785a97f7fd557790b13090e01e63f16f32190e68c801b5662ca96724d5b5dbb11bf8bab21074bfd4938f32892c79f3e0d4adb0386148cd406ca04f85a86eb424ca91cd8650cc51f7f6927c8bee2fdcf52005bedf336430925d1cabbd882043d03c3c5fac89fc075fadc1c118e1c1f06e68b03baed6c895617592de2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
