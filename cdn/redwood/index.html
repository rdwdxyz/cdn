<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cafbd6357153ff7ebfc6c9049eb85378e1954443578cef0d6f71d49f3e004e79f091120c81e2176de5809033c4db16bea60e5fabfd24d981ffc669720739197f823d85822d58c0a99c5e8c68c342febe36c1fbab1db6c5a9946abf19fe3a7862fc4b31524a72a8c19c6a978afbdea68fb0b82978d6a100028757a3007388b8db7afdbf4c75c5a2e6722fcaf09195330e32be9cc984ebed1e8e0cf4881e644419b793f060f7372b15bfee17285646123532d204149f114b161084ae95abd500eef1d84984235d598821337370a123399f943f1a66e7829dced6dd697f7bc76cdb4c5f677449ef3d2806ef1aa2ef4b69b4ef9e95ebb9c7d8acad46faa92a0392d89ec55cb42372bc2f2c77bebc64a73869df19836d1c4974d1375d15f0b5b177a031cab05dde95a9ccb89ec4eb50a41519cbfb4a0fb0d0e24981eb4e3b37480900b63e55a0b8e286d8944cb8e1b376f2858b0ce8e0502b8949eee814ca36a9ff67825cc872c5ff4ef98579deda8baf18e38334336500770f613fcf4ebdeb037c3bc8eeda22b242e8e37dd8116a783ac933d614094a4259c0754c3faba7998ce770a006059cfed2dd7d456463471d7bd75f9471dbedc543416d3e28bc0751cd735a30c1ad8f42f2e0f25d7cff0fa6146a172ff61b68d4424e86e07c1fe887ad9871cc8f12e900d99ed8fa2966b46ea375dd65a6c412396092e584f05751091dd89f0aa49e291e0037dd4df5a41a1f82460e6324146730f46acd3a1cc4b3e6b9242a90d69055d05d67677f5a5a3cf7a417f36d07882c3bcd5dfcd0fafd40e3bb10543447d9b66fe6fa721ddaa5514672ef300bca3de1de38305dc82e401b1924f99dc97b38ba25716727088fe8f21336311944343473481c181f592647bf57c1daa74aa21f29e79d953e5c89b3b652d63df0316206e371cc54115acc81e4c83430538cee888b8947e4549987528b502cac3b9d73aa882e91fb86697a09f0790a834c28aea75d5b82767129fe90516ecd55af2e190695f069414c4b44dd027a89527c68f2c2002bdb9d7940979c93298ab091c8fee1198b588dbe0d4d4f9faef2c0ba1e0aa2f91abc6d286c8157f26c15c14e53511e64411b872752b11b01b8172ca8b39da9e5c8592a4ab2c45b82f160c8c1128c04016c3b276b8b333f394d974abb0f29bbcd928c7919b27983fd25f8cd72338d07e64f6f68606ddf495628c612716c14f8639030d3b8823689fc20802cfce6c2cf06c160675aee296017107a8f6057476f234d5386242c39a04eca8f334413d2c2b5b76c18b4b911697dd12a8339caba699cfe6632cd10364ae1b51e8f825fea10f1effa677e040a9bcea3d80488eec75da9521ea2956e7b403f1f78e8be3cfe43d0394fcd11e78db28d19adcecb920e6d6a5d7d2b0fd86d7d51a55a5321014cb4bf6a2b4877e37a4a3c3ff619f3285f9656e808f731974eab27d2b1860b823775b1a09d350f7bb550aff2508a80805d9cdda1ad04689c0c2076ed7b3ea0c4e59c182aef755ea380aa532ff9f74c4cb84ddaf459a91320026a2102b46ea3cec9a3a46492fb7dbc57451a5cc9618a0f54d20fcc342b2c6ef887f4e80235f71ded7dc924f34b61120cad6ca553e69f882d8d6de044ae42f09ae660f36c275158a65ac378ff2ecf52c08aa97b88f9aa81aa8dc32992b2dd2cec3bb5520994d5c4f678ed6e849d68a7d6402489b9a5c53f600d8c58fd8d0e1a1e5387622b95691c194fd9fbfa7092d7b43678fb016d5c514931d6818a071beca9e022a5d9cea71fc58f4c2ce986e5c9e8156d6292a3a90634549166a8521001f5bf04e2f7b895f82716442158a4beda6710b8bc5c71c80e4d918eb0614e2fabdfb9d0f98645ce51a4e6eef55a0d1c3de440f6364003f9ae0d1a996fc216e9303eed7cee422db0fbe4ccc71fa8bac9d038d551c161f8c564173d36a79b9461a6ee33fe5fb0a88b29cd146e30613485cd39702bce79d28a0feb4503e7c42dacb20552542907d62b1739c40ad1de535faa8db72c27178c3e96667f530e9284c3c22be25bfff5d1838a28de69d3ddc896bf91fe709ed60662757325734df15d4e4d7329b489210a612435380d1aeaa26344937452ea2790edc7290dfd6df8ee57e54eb206ee7342c6cc5624af41eb97f45db80975c2f86e8363ffb6b669337f31b844075375e4a5a076e28568924f2f545d5b9bdff5f0e7220b747ed670d43a10ea4164fb68e2de4adebd2ff52773a39e97b4419acb77b44b4863a874e6cd42a50087fa6c7fa026e75a35e0398f0988f63ae0db93479a38291811986a1f8874b1d7f414c142c37fc77e45a1c4d88c270eaa3698a956faab1312089d1561f5eff34a9b4615d791e4a59fc1cf78a40026d7e7cb08673ecd4108b768ed2a39a4e61b5cb32c153414092ff0127f8d41879f8a7f8da3747c26c1b50a44dbe08fc1646bf8027576bcab6515999984915a499cac64d4605f8699dc2654119f1a91a0e5f258520f1487a85dfdb3a560d95e2cbcf0b0950b2d9b824439760ce19816b61a6c4771881b45500ff1905ec447d431c40c9994a1404e0669df2aef93c80d4e0d7117082a0616819138c7152b22bd558bad9da1c41064cab24078050fec388b65bb4eb739cddb09be963d2e766352d3e0e576bda93fbe809a3d41bfca4e756f914d2e832adb8aeb7f49aeb471fa292bd8abe92dc6f048cb341616d6dd7ab3429e2cb9489a670967af7ad86bc093bcc7ea7fb4c9c72e362e2f1cf69f9af7a959a326e2ecf1660c57c30f3bfd20dce3b2c976026ba02efa98846f5b0263be8af735f926b44bbe1e1af71c6a36155903a3c6921ac02f88b4078f678d8b1ca2b54ea824633b2e520dd575fb391d1ad6a77a73267c2a3c520dd734922b6a51fe44da98655f42b5cce54897ad0901d85e22e2e96626840b7ee186a9b3bb4f62f6a31d0d2100e32e71261e6734d9d76334249f0707c018c87bc5f86cdf99db51df70ccb7c8e80ce155e12808dd39ca212bb4786416f30e4c94518c68d7e9d36356312db2f4e150b9ba004e113e8e694587d7bb8a7e5dae0ac68779bde40785086ebfb652d313a3fde345aff8b0d928d17f572b57a9fde5309f1eba6df5bee86ca9830589d9b78138b2d94d6622a5cf0d0a1051ffee1061934a15847ca921a4088565e91fe5d7f8b46340cf82eb25df77bd65c26ac3352d762a94ca50e4e147061fdaadbd8b0f1b76b6515a3821dda08b04fad3099db63ff2f95468f03b6fa43a628892228371da3ae595d0d464a6c6cc1ef2b464f077f12d4c18a019cdfb30c78080a2f3ad6acb331196d2e7929e78838996ce803bc1ed3106d43c21d8d74df8fbdd611665d6592d3924779ee9ca153b6505dbec0021920872d648f9a1076dc2c450bf37ea2a051329ebc9c14ab89592835b62b89cd5da46ec90dc01a79b4957c3f642f0ccaa5418d63deb5b6ab69721c0c222a2bb94806a3383e1aad9f1089a9bc9d3f9aa69ba999c5ea9c4ced3548fb80502791342ea74e6be0ada84fa681d6f431aa0e8b3d38a2acf3a318c2e3ab7109e388cbfaa00992cfe1f357362c508db8c59d7fcaaf5123196296c00910eb0785ca8bc3e0585124788d2230fe511902ed23eedf757be113bbe700010a5a0c27898b81139d67171620bce5f48dcf66e3eafe2cfc25ac799ecf1379ee6066ec851930ae7145f4bf6ff3117b6a260f0c21f3bfe30f36f04fdb669957ca5ad17f0c4e12c30e958b73e1304a485dcb426edd6336ad1770288b2da4afccd7aa5afcd3d120bd7760d80f1b1df5d9cad7b60de4793fefa4f9fcd4c87fb368782c5925b8de955a66fc033be6a17a638f4408a17655418d569a5eb2768f7fb76f05fff9dfeedf164660fe7c381a907b9b40a64e4eaa292b5b994ebb15c074ad4f511092b4c8f0b379c4d607c9c976bb55480db545ad6c43e18fc8e902f22df3cc5fd9d7a71a6b82b7caaabf4d234d51624f58ee980acf6f67afe4396a84321528cc18b1d64be5162df8eb42b0f294bcf21c832e53de31534cfd02a29706b62ba773c7d5f22ab4580bc5b728a22ee4ea5087fb22f0ab4d3fd7ca4bcdb90e005eb3d0be4248cb5c7fe61692c6229b74519346407ffc9d34db3b06ab2d6dd7df4b33027b2fbeb92f2471bfab6a3196e27f241a25133463501df664b0bca703316b8333b06cf5ff9f2286382b503b1fa9e0b6f4d732275bdf7d0d74ef91193a9164ca9102dfc8aff6b6c52117778eadcaad799181ca693ad25c9c957c6e9457de521f697e2c53f9b0136409fc21df77c46ee7f56715481076c3d2d73710cafa4ba3975dd09e583e9d92d774afd8242f5ac3e85aecdf224a40c5e812413892d67f333ae3cadc93fe4eceb749b96d1808808d34f79dc1fdd6e2c16d33fabc88e7d5dab796cccbb1cffc6e2ea3db6c733e25787108fc04a247f020a71e89d866b78a8c2cb69662831fe0fe1dc5307acabdf4165f11927d512276d162a7671f045d33b73b73aacae8bd680033731bc5672e825bdc221898c40202642347bef9ea094df89e1ad8cb62180c38206fb739d0d0cd392b619c23c2e37318cdd23c22c97b50989bf470a1a2a56978f5b7eef3182f2e75129db058da9200dc27b12238d427906278a51c399008b7ee8400c7b9be5f92aad0e7e07eae298f47d45c102f01bb63305d9db0087b59ce54803fbee5aa6dead3b2a3ca5f2f194503a73a5ccedc936f42868d47f51ebe1d0d5a577d680029533bcb729e7ccb62ba46a958204a5eb4a709b9c35649c376c36171e39719854dfa0014401058ee931dacab14e89a3a24e3e78d6542bc914695948e809fa3c82de43dd5088b31566a2d26a1f970a0431752df704faba387e274fdf4af85be69a5d2a653cc958c67f2ba2a86b8e1a1c8d2d53119db719732b5ea69c5edf65f8875f49048930729e6a1fa54111042a480b9f21ebc9113705b17acd08941d337e64879dd7c82119d99b871d1f8103c50a603647eff4b70afbfa3ef0686807b745e50e55fc65291e19c1f598fa0184eb4f19c46af956f7d4dab2d5592a3961f26803f28c31f998a205cb450ed056949876b8abde25e28f4bcd2f1d19d9d82e75604c85a4e7d0452f0986ee38eb2afe29014ee7a62e3bf4891ad0d8fe8898db6376f345740a6eee73f5eee6370f0b6a09b414631110301f1caa5c0c3905c5f3f79d4bc91e56bf9e38359e8c37b79a965ebc74a733cfcefa8fc0ecf172267598b933a1f10ef61d42e9ee0938d37ee8f203336c17dd74d3ed2f68c2d62ff7776169a0a525ce6b567a74a3eb65e21b3b99c9243bfd9e90b5f1b5ea1db53e9434e32f94a1b73475afdfbeda91e7727dd3f137a87a3b76c56ac81597bbb8154158e403b2186081bdcfbf5940bc883555af331409f3bda05c541cf1dc6941e9a7944d3c70e5f1ce79c8bd7c6f4aab6a4a4ead4efdec98401d5171ffb6a35768665dc168aeb46498720f4e22d98be06fdca802428f9bd54876007a5fde5a718d1c5b626813bb76737cedf0fc8e8048414a53ad276edcc6a7aef3d568e2bb4bfce6c995a56f3ac6bc1a476a982ee7124e47cf9087debbc05bd53e7500f4bb2e765bbc1168a20515538668e551230d69ce8d3a5fe42d55158e55983d81e4f4156643133fea4b0e64d39136f54770654743998cf70be8a5c5373eafbd377dc35752245d90b7c6b0d17d41554bfa48a691fb54e3a75df4dcad9ea9992412bbd786f525843d23202e19052819c541507cb31320d92745012914e50a9677780487b380677a0e69f427f9a80677293812934e3477dc2b4f6e0190f581f0e8d62ecfa87970738671cb33e616a298f803213bcb90f11d4d15fc205a0f331b489e8ef47f923e9ae21152b12463555a8e238a863f81f9378a92cd9e3243a8693ee462503de158bbe5c1d877b0593ddac600d230dfcc948cad9fb32875575aa43f3eb0acddc43afaf5842d45f46b39f7f28af3cb164236735dcb8db7f7c94a136ffd89f65c2514e7fb700c7d5b0fb27f518f4c5e8dcd5275777669787f5d198e8a60e42e3b0651b4b6dceb24f68c5bd1bebabb9cf95b36d5bffd4755a1989186747f85095df23ca1b1a9b162994bace7231a61f0d5c6816dbb69ed2888b062b535a7cc3176aebe6a1dfb3ed48b63c9aa745b10b24ed5c4afe5a0966cd4e54259aad5d12861483454e3d382aac81e94e930d79d9d336891007bfd11ffd767b17bdf24e1366a12e8f6161d3945de6a4a6b251815bad1ab1870a8cea212c505fc5556c9338d71922798808d7688ab3b0432e9c4213b89b1deae011a31670d25eac5e8808b0d7e1f283cff4ccdf050d316b8bc867e2908a0a98bf67ed2518733d22b641dbec2a4ebc3f5fb64f318a9dcc8763a91d9f085773e6f6773b752bbfa2bec7d6ca3a5c8d018e836999cbde6a75adf830f797a5a050c298a92c0c01e2ece94d3adb59bf594f3c46c3ca5a95548e89fef1329c2394e6018ffdf1363595a1a0fc966324004fabcfd4a6e8bdaa8b9a4fa6e84e76a8d3eac30a4f7e904e112bdca3be7427a86390c5feba8dc65720a6369cca5cdce6cf92822c8634085c8f6927431d862fafed29818dbc01f4326d2e2ecbc7a859ffed1acf36e2623481257011c7fc651a7047c9e66ca9d2cac985372b0a1d32aeae24dd77c7e9c00f6234e53645624f640aae2f9f0088c15173d4e4e3985bf9ac195f5d75e00889daa05bf315f79bce77f4cb64b75c3cbd554e52b43515482d5734be37fb60db7f181288e20644ad170e7b4f5f832bd811654c4e0d93431c39e34fbdef5271b21f953213e5a37a1799d3146c407bd760a467a96d62f87441745c2932151f9757b18775f135b70eb67bca66efa888bff89e4ee475ca7a9a88bc352ea9497ccbd0fa3b3a1ec3cb26a571bb42f3052287d0b4769d1f433227c1f5b099ceec79d8c102e1a9b59dcef24ae235c16cf963d52a8c2ec7b72dfa0bcb10dc1baabf41a14ee2f1ad143b4f1ab3c3edea712e4b5d2147a30f59dd5eee0a5e8779d50b321fb843d57284779ab5eea374904ea017c242d90006529d8e2a9971e0f161edf1484ca91e30b918ee9375143aff07517b6bafdd23e891b3a225af00ee796acd3e2639a2d5a9de807f990094a0075b064453a4e9bc63ba4df53f53369bcfd32da2b039c44c395c9397eb10ceae034ecff82c99bb62e163611adc1f0c6332a31ffcd46fd6a620ec71b4ec2e01bb8d45e22f0d64b8c7a566f779577c892d7afc7d7d63e5214cb3a7bf5f2d12c6dee20d0df48260c1f5b3d964cad8211ad226e0ae0c5f757b305c79a16279cdb523768f3d85eb11c015ba243f94bac65b36d0fcce7fee833da13c3fd17111ecb4e2f64452a7cff2a641af69e07b96c84adf6a27d194a71abb4f1fe6b9be459c8dea52f615ab416750c89c9bb483a0fe5b3383e23dd258ed53cedaf8627e22436b92ce82a188e3459cbeaa2c1d6b2d513efa00194fa099e99d9eb0faa63a4ff738e549c48c2dfe40b1147a474cfb68986aca61adfd5dfc6d5468fd75f9e5e2f6194544ecc95c8e73d64bc26f0167bf01be7b7afad91f0634233a6af737ebd4a5a9fd5c9dff207af7fc35d95693096e632a57db739851aa1aab57dab06dc9392a5db55732c42b5afaab817dae8dfb0a2971e26eed63bc20dfd226e757cfaaa2fc924f809d328f2e9a2188435a8f3639fce44dfe298999a3023acee7f52c7418ca4a31ce043b8a7977afb11739f710f8a11bf0d3b926e47a11bd4edb1d9a51452575acd027eec5a5bf9e4c671f40091475a503d9cdd7a11cadcd40575c85691226ad3235352cc7c340890bbd28ba5e077feb4034e4bf2a8e1da74ba3b59f6019753f1cb345fcde9a523a3450c6abfa682afc6dde456b1c26277a6427884f37f42ce5401ac8025508df8255041746596a661cb77a1cae1b78468ab8ae06bb80385f21d342f8968070da105e0125fb2bf0c9ab0489ced24823a843b6d73e14508aa9f8551d28aa7ce76c44035c10896cb0c2d96680edc40a91c29b707cde46dae93e48da3eaeacb3f3bfff4dc9405bfc9124d88858fee69a0495b628ab3331d848c5091892c203a8cd0f99f21ca3cabf10a7ed56164c8c3bdc6e53adf94841a7cba4ab4dd44fab52f6cf10ce5a554cb98176528c03222f7920c14f3bbdad6b4ce63d0f22d9c023cea84965566ce7e4212759a5d2978faf0e15b008304ba1d4bf38afcfefe00a975f44876219b055ae3e043a9f4cf5de219ed563617ab389dfbe5b17f3dc0fb9769f9892e18b49a42982a5404357a12bf8cea1ac7ec44b64addbef450800aebb60418a77748c10dac1ac1f90c07e61c946b9c8462bc0c3f6f6b1da1288ad78fbe70d5c516daa4675767dca6b903032ba9d21ef937750e629f6d8e77c7d9c2a7582e8e7b871a4d03cdcccc543d19f90e35c77d35c7d6679bfa269c70520a68f61af36306dcc70aaa08f4856f3dd121e6bfbbf1e2887b29d1c3dc2816cd124c021897e7cc3e775cf1f2c86e24c00814f52b13b0cc2e61092127e2a4afa769d2dacaf5fc969edab7bab8d44947b4c3edffc8ab8ec2fedda64e11d68aeca4ff11c68e4f9809302b151d0fafb44a417f888456b4abec2ede5ef4d3b3175ed896f88d34f822329b00f1b9f2ddaf1387c0b2bf566036d1f0356366a00e491a2ad55d0d174409769a49eb5d8426fd2ce39ee12171c5d5d0e80fbb828f03da05512b21e3c429d94beb83e76bc1d72b90f509450b62dec06a031a37f984b3038c0b447ba3b4240c4eb2ffc9b8bceaea529ee812178a44758b0c82081125ebc9b61676a7b0e678bf0be0d64ea273e0e3d4b8e17ad6c372319fd537c5101957d4fec0f2dfa452ffe301969960d75a67d634412e1591a2fcfe48c045d522aafc9cdeb8af0d39c09e9ace3fcd3fe2d0d544669940a01de2dadbcb31731faa9dc2d794df1f3114610b52a264f8bb2e6d526ed418f5bc73c950feeb3032ed9a970e86c76d49c0f92b9f17a8d50e57bf0085d5602414f769cf836e13d6105918290c7ecd5ffd6f979e0069968ce64829017ba66490918db10bb3c23dfaf5f42d0d901f2fb377f45a5ce2b8d800563fb0cdd0631609a6bfac2155985aa2c67973fa132955dbb1176ba4c73e874f2f0a7ea8775ed5f64b0fa51728fbce53698e69a08695dc7ebeff187f181e48c6168ed0b5f11fdd454acb15574a7aa63297db517ffced4f3f0acd07c56fbdb9ce6e93d2cf335851e9f60eaaa829e92c68962e7ec4a1f111755d84cb6f402d1e1f37276b6aaabd344e3ad24d82759bc8f5c64ea7445d24cb9fc888280e06ac683b403ecfdd75bdedd0ec35acb022f65476d9d76ed9efbb07970cadb70cbc1d909958fff168aa2ebec703be423bce96f67a0940b80b10763e151a84a7d11e01dbb12a4c54411859d7478d3bd863eb54c6fa68bf9171064ddfa5bef98096fa1274aa454c592253035663ed4cfb9d7954a8150f5b28b79823abea34626ac179fe4e74107fd3cb16711082fe64a991ac9fdaac1461d661ec03e01a0d8e1efb67178f081035479dd659368179ee5a5973ed355f27e4294703bcc727815ea0fe77bbde6dcab2909f8b4b6619c84dca7dabebe337cf87656d3ba8435199d5c670a024cb9ebddfba62251a2efb49089a3cdb7703aad65a22e078bb554edf6cceaf86b1f9bb830e4ae5db5360a78e680de320b9fb61e74a8f6f9b24b8bd5f7d8a31ea293204e7045e3a3c02cee1a7f8513a46bf876b8c5d9c7ae2cfad7777038b354a8516f37687b8981cbfab635c733ac84dc9aa088e31d03b5c2549afd78dd865e7d7c4379ab8aa28251c4014f0dfc60a55ea7743f2843489da1a2974ad83021f6d0b5890e610dc110e2be9f11022dbede0a742d9c1e095bdb5e80b2b25d51e07bcef1c9bc9cd2c4a9201b7e0a8ecece27fc05bd44c342842ad5aff8f039cfcd8b678de34fd8163196a785c155791077484b74980df64c7fbc7fee69867780b41f007cd9eadabbb3d405426c4c97a262d2cf91e2e8e4854898fc955ec755366bcc2c2a7e99d2e87432c588a9fc9e1b275eca53bbd7f023f9ad926da9d6f8c49df853df8592ac4d47f0a439ca1772eba62ff7416c25e42c2d928c31f39ce555c9524fbb5888211688ff929cf8f5f1c78967db231d6dc40f78d21f9a8272493dd0869cecb5e5d236c8cdc126e7af0b7995a7d7965003c074db9bbf815f1d96ae1ee083535f1d183f8b74918abed6b24af8677cb4260eab51a163cb7baf59ac3b67097a77aa1d920192b1570283eeab70546b28dbfa5241c25748c1fb666340a3c51211d178bfe0bf0a8652d525d4d0b738269c81e4c3507ae8233ba354f316f56fff4775e40780566ff9eec219c8fa8daa16067d78d511f5c0c2ff3c7c801b0e19073d31497d187ed701a2a55e6fde466e210e39a3d7fce3c808657294d932db7916553c826b04584a22eace2230a59979e9cc0818147e2265cb6e211c37728e4995b04c6d23ba8f0fe91d7b5a68e5c85b532d7a611ff84a61323cf391cde5dc3517a133d4aa5f518d177e2c27d48779aeaf07cd75a58d41a13a9c0d97ccffab9a813d52ce2a199db7678201aa87b68d1c77a1280fd3ac1e008ca9757858be0e607fefaf00ce7581ef22da8031b96c95273569854ee773a7c30afe8789f6b22e7eddb840e516d9368e8404f38638e0ade007f15fea25811fd0012aeafd74934a5e82c590e9e3c774a88515a30bac19bbc990a09124d38789188b46509f83ffaa71f24c1a616c1d0ea066ef7eec90f852d485718e0f5a81c4cb0450d1a088a89bbe1201460fe07e49b5bc74e9f48a0e259392c44fbaa0d622ae6e53089b649d9e69ef06147d00c9d2a284474d3fb7102ce3e982f9a356c9e67e29a3c9f5feb8dd91de0aa32468107985d391a9b3b032dc38f48f4656e8cb466dd45a24489c3589ed5ab7e8045d7024e38da6591fc5c2de2885209026c42409759aabcc35b6210b4fa8513bc5e0c351f51492fe820a340ef996ae7b73213e7d6c4bfc184202d2a11e0bc88b19f4b97ab218785fb3c8187c4a2d58bc01d8ad8de2943c28523618924e05e2c78814fc4bda2152c110eeb3389b5233a61f9cb140f756c5b01e712f0e7275f2fd780f8efd82a4d7dd8c854014301797df68862b90e0b74b350103e0f7279ce2311daff09466a5c7dc057a6bcda551e1bb592e3d01243cd5f915f72e6ca9a9ee3684d748655d28a8c6984bdaa22650e7fef455d7cd9c47bc351f696d38b10a1f547c8f83ecad1dbd2b8544f98ebb4a254c9a8471a153e1e35035f8c0ce6116fd6422379ea858cfac6626245a52c74add48030b6a980868e4c64e31477099e80c774ccf3ac86263f81d9e398854888667f3a00384aa6ebdda2c4b0e5919e2015b7e3015fe8880881ea6130e465c312b44ba1e45889d51ede341fc1cbb9cd013b9ca8752a8f7a5caca6f53918e410c3f4f36644f3f7e6c5b0196e2c893ac077dcec2962c53c2dc21e5166301d60f3a2d197f34bc633d88350f26532932e0c6bd8a12d5b2b427efa026d018e9302bd4b97af4ae5b08886c3b0af36668765618a87adc8ec4b195300fbccb0473d6d5124d2757d32883c936c5d9cd1002e15de441bd982aa6c4575bd7d2bf178570b178abd1fdcf1805e5e95a7ddb622a9db527aa78e9ec70da6e9600cb101e6b1ecf1017fe600e3b2b374c9af9d08f9ffba0966d3b098d7c99fbbcde7a16d55fde6aac8a0869da9b12e6aa507c600df7e37454cf09538830752ddee8b7a98b909c474ea545a080eb78d154eb009f9d02ee97040f8ee79e70be9bcd55d2d9ddc4f4c1cc95f58adee8e5e37b43034b5129b499b05cfed25ba6c5e2f4eb6d802aa4c1519d6c529be735ed6aef654ff17001e33357948eae5504b506c34ffbb6cafa92a0f6be87c3dbab18c78419cf7ee5e29e577f1cf284f1f856cd822dd29f65e1fe629638d72a40882a56dd0c12d9f1b6edefb2f9ab0522fead216f2dbcca3a1701a9edb6dd836ba97f8326fda595dfbb1a8d432c7c35a40c8e50076429473836120a70942b3ab8a27b3264192b66150fe0618780922193321fc3cd0a6c6d961b685933af7539a5b05b51a284ed90262902025d27490736d5c606e75391cf18c7315f46c131a45fb51593e437891c2bae8a819e50024559c148de500e891da5d04b2071b65aa9c837b901b99eecc62a94205319b4c4faf334a099010df4a187494987c002849b8ad8dd0d9d84863be89c1a0d43911e8b031ff6ce0ac48a79e9acdd987a7f64a808eb3ddb68cddb7d1038efba64d6553f6ea533c5c1db7c08b14bdff62a3a4d04babb7adc0627b15f7e687a4e0efad9a87f60a431c05ea6a22354a021a8505572e007a74a69c7590bb4de1b54c4e28fdfa1d1ea68797682c2968f45a4cdd0596650d5f69697d3ac8509af5d8a952e6a5330d0d67010fe4212cf66dd17f994f1d61d7b080b7506962303b2a2ba914875751099c0bbe2ec419a290728830cc6ddb8b1e2b12a4fc94866ef6a00945c8cb7da6cbec76c8778955f9621f731c0c14cd969167cec375a5ad3e281e4a1efcdc7bc5e514198b6aaebdf0b87d696b5d51db80e55bd3c2ee7e224b62c0eff0f0c579c898eb68421ab5bdb5684019c9b60626c873ca1fb020728c96468d528701f883e325fe20cf943096fd6f83c2e259c4a0f9f4e341904cfc380686d53dc72acf2d0e3d2f9f1fcd84a6334817dc12fb6379f31bda47739645a244d459002efa14df4f38261233e381052cc4434d64f2443bd9ec3e7df1d1c0f23f47d4e6cc503d65e1fca02ae174b6f70200f79b1d66d637a0fe122560dac13078d7bb5f4841cd5fdd1aff3e1bc63b658faf0e063356824778995e4065e9b2c1f5f39457739e1ca2906f897722cce95bb429172e80f97e396012a1ad746b082fa7b3639973f4a5d4f9ab0153133cc2f5684c2f9eb83913d62286ffd969c7623e418057c6608d4ea4b6c2e038e66c8909327ed56baad40490a1b66f8d1945afb91fb8a962f585cc4da1476443f2401173a6e78247ef2a556b58575c07bda5216a32a4736bb5ab42b7991db9e7989e036422ebc1db7808386ad005524407c25053c76cf8e4bd08153bb196f279578ae55838fcf09046a123195fa777d1bd3f5bb5f7f234784059464ee098ba7d852fc1955627da7d2d27b33828da807ab2fbbe792be91b82c977796b98a3972de612883c46e6df7da0ad4f21cb6ea9debe9762ff195a15b00e3c7cc204b4897c362415ecdf831e19bfbbe3022026b1bd78b31f41a9d0aa078ee20864b84eec8e3ef9915a12df1b5900d7cedbf312c7ede2342de4045975982334080ae292b81b3bf86699e48a1639ebfca902c61769f8b012f389b861299e42101c4b40cae0f63a5bac5b0d2e7ddf2f9e4f57cc4bffbbf7c2e524df4c83acd3dae4b129da4c14e2461c659acf11a7a5c69e29f3372d4a7b6b90277713a525a9ec4a853ab484fe71924f387b33edf49a32caf857e605d73823690ebf945b53781a1b32227c754066719308f99625cdde51100ddbc046e364eeb3acb62f8d064a27f11bca09b8f5220f9b6b7218d62f6069f915822638b41863dcf45b262f9f93b7945a2780feb2d66aa2b223894464047c9ea928f2e40fe41743ca89c995431f296c75145a2ee5c4fe3494686abcc7fc8b8f75521226c11b3d041e6ddefc1e596f257d49a09f9799f3bed2122f73b2558717979a0d8db9f086276f134fde9b1025a8ed26a4af521d3f3e8918f378d544dd13be880216264d3b4e2e76d6e064facd43a704fd4c8e2dcbf5ebd55fdd643a8241a0c519bbae40afc6d16000f226eb798b7858a1eb96211088a01479b2eebd2e74bead43acf593bf6e47ab60a89d021324b1f1406978010dc2aef17d661e805f142b5a90ee2d6278932d038cde4b153b47b9f1628c73a36847d96570dc4c63ad8ba6bf7bd16058b2d7ca466d50d428f48b5c60ae2fa0decb4b120a94624d460efb3af98c5d6496ad9ef0eb6fdf1874cb5156e2b0038cf94f38b6ee13a2096ca5fba01049c1205b76d7b93447305399adee9f21f3ee0575e66d0abe9aea785a4a01126051719ac0900d187ccaeab3b2fb899612e2a092fa14307c92b5ca92daec0bcf4fb04fb848d12e6a7ef409956088f88564bd3e57e5b6afaaaa490ce859bdf94c29c199d800c4f475114912a0d10c6c75d3ec04634729338da87ffe64964242f43855925ec58c6e770a7d413565a9f086927e44fd867ac85d32b9a47f191f912c6e3b0db3b86da091dd1bbf58b9c50a897a10c4816f175e329e97e5f266a174f81f65dc06b83abe20118e3793b28a941d1e1ef182941fab74a35b9cd4e7b7e5a572396007023ae2955f88920e728c2f2e4c4aab6cad0b8871586c390dd447dce3a18b32398c210650d6537918ac68936fdcb0181b169270bad3138df30ac194f1b19e60a6289036babc2ae41af42589a2105e76d8ae4cb1a0cc989a842067d82eff828cd422cd0b97617e285d45e4e1a11e1717a5c182cc887ff3856d07b4c6ab7577024e838d29855ca19ae575b8b95ace166d5c1cc7e21124626cf407eed396fc895cd72d05cd7185848e1f0a1e176aadddc977d04c6a4bb93c2f5f4c687f7eb4cbeee113d39dee31c224cfe921dabf3b4edc60b119471fb0b93980502f0cfc6fe0b1a3a52f4bf14836b25e0473fd13ead75b136de375a9d45beae65459666928885befed42fbdeee256ad641b636eaf1fcfd8886c161c04bcb34b9a5a4c5dcdc92937b668146ba145b7d09680d7c0dc4766d4d6cfc64fdbbae3d1757d2f0edc071ea59fe5e6c2ac7f597ea0a12b2c06e330a6b2b12eec50f435b4eac8824f3ec277028157249e610d3b1e0ef55952cd36d65484b3ed21c13309a99dc5693a27379e194fe132d8c6cab30c5c0be6a175385f55461a0f20019e206645fe704fa78e816c8176345320640b5a43cdbafbd7e65b067959e7de193d3d42eb90b0f883d35a35298887fe2edd0dbbb10731b4db7ffc7bd18aa26b54715e971134544976ad7e1002b38d1ff12e06d1ee3160e1dab3d5fba12e33a38ff506bd94fac7d008a34ebf6ca23dd09fd35f51fe7d2dacfebcef7a0b9f41a4eea12476e4f948cb7eb8ec197885d000a571f8eec7d8f1073d3832d1da2be4fa7865e0afbc0222eefba760c1e3c9f34320c0748e58d89f3e61c80f61f8bf3d1bb1dd97c41fca59768e85073ccb93546eaac961302a0003aa7265df128dcb2e9c474cc6bfaa39cd2766879849b9cb3538052e5adb5845573b4576ae4c85fa7f331514ddeddae03c26b20be53394d1aa5f8a8df246bd097109deb35beee7b1494dea4fc2bdf9ee6abe6e9fd07199c1fa9d20b5856ba3d4ba786962a10a3a3ae93470fea8d35ebb6e1c1573b7edc6188c860f02353d210982b847a1c2a29cf69b95767d75a72acc321d02b0f680d8faf6121701e9c4cf589818a419db2900529589e83cafba575119fe73cff7a29b0bb1fce5111985beaf9e2f3d3352e042a584a2b955587dbe3b9eaba03898dab56ac336d1866910139030c9740abbbcf24c6c5fd701726c09022ef565e6506734bb1a48466136ff1ca6c506dea339d9e3daa3852bb216822da4890870cab129899c12e74a0883437dd1c16814c019309c19cc66efb0eeeb5ce46499c1d8a52c254988eff971b1c484508dd020c5c6013cbeef8fa8cce4a803f04e6c674dfe8086f604682b21497bd3ee9399b6f16a4822b777db46f056e63d905ad80569c79942ebb87a428eece4c2f94b428f765c825da60ffe67a0c28038a9dc1329dfb23440d9e3d674c7e355aa02daa63908abdf1ceb94893f1876df568b64ae41eb936407e19c2cf66a85eb0538096c830167dcab991c278848f1e3b6106375e7382470654d57cf621d8d084bfb764b07ee45e77e3ad2be4a74f535607facb5f3a08a9c3627d7b394ef560b2c0c74c796c359b21f28b6adf0ce417363768be7b26d8d62ae019a165e9bb86d58ba2aeba835e1c7ccddf99d63f0ee6f45990d2008ce83a2992e648475251d91aab080d9e29331d54fe7a8b6e30dbdf11eb90eabc8f343acb7782bc9f6bc89ab3971e2679f4d47a84315efbd8386740f1d89f2abf9b5cd8b3c7f8855df4287c63f6e8b7d9de0342ebd72d890cdb18364fcb70d04eaf026e9cbdc8661b6e028588f2229ff313374f36474230f5a494669281421c384611151061c4a841852c122773e3b4c01a96c17c6681e6fdc90f6043436305cab92d80bdd2bb8bf3cd880456dc1e2cc157c856865843942338e950fcbd254618622ee7c02301115962a2463ef39c883c8832bc2602936f6244823b6ead132914053ef3132a5e4e6c1d5fdb2d594035ebeef98f61114186fa678db901f9b33c1ed579ddb85f2018b782fbbe957f7e695b3bb60915c12676f317708582825dc5dba111a8fe0b5e12aae7c4ab04140938697a09f8b95fa21fa93d5b36cc9c4da7949c8d250c0316030636ec4c4b481e6ce5adc33d3de223046363bbbbfcc33da0a39dfda13e530ad3a6dea322f247e8a2fab06907cd388f557c2f7cf33a03940557b4fe22c309060faaafb07db2466b460814ecfe93f80468af4d1855e398fd5e264c8ccbe23336702d91c9ac21220ffc3916a2fcd9d7dc8894c8972fc196066067cc3a97cb760eca026cfd29ca7db72e031451f26b3cefee998c67f33092a427ca266bc735633ca42679bdd83de793ff312d276da61d8872926c1ad93ede2a07a7b00a70d2193c326920df0ca362fd364dbbbb8d698a218c6ff452abe7c867f4be3e5d178121eea6624640ad04987444492faac811bd299da757b4cc8abee803f097a27427488349863a5b574d802590d07735769401c60d4d37cdb038a96c7c131545f810239c5f22436c8e7565ecd5fcb2a8e56b7d236f4b322f1e9a3254c3cd8157cd680a679812d1c557c7a414935e95518ee17f64d60b274ef2d44fd3e325cf0941a6ece46731f4eb45b718e86735889352e1abc9ec34ddad73e8f6ab376853316f435bca764f9ad47213c58b2cfeb88e2e89447e6ca45e61211a85511334aca7361fad8beebd01fe705c5c25ec0faaad26a0028dc6613d57ea75474a60edb0b76457fc570c571ddac901ab0e6d216ca756803b087b81eedd4585cb461742d90e968d97bc38b6943733d9ab9408eb24cc8defd29d624450147c3fed309664187a131913ea22f191f5fc59b437313acfbd62689e826e772b978d289de34e357210682b60d5680c803eef82b9e6fc02675162c8ac23a7ebd4da8ee8121ae2f1b5996fa84b1f6784e412099b8d8676980d84dc28602a1cf7026b0cfa3b4687cf04678e567b6eae5660e16c1d1c275f04a7c821a04f6cc08ac5dd4686591ecb7e983921ffbb0703124da4056183a5d98d7a9ebb871f38782ff9734392e96af1f9287aac5249ba9f7b48b4b637be59ba5685c0b841c9aee3fa18d1a5f98bdb67a0d46292232d1d6311f88b27e9ebdf712ed050b4445c8c1986940b6f003fd902fe202b086b326e72c2907a9928203984373bcff60c9ab616544ae9e0d21a1ac6b9bd76a8862e2427fd706316ea23351485314981f122ca103bc785574fc3f3568c26a273c05b0b3fdbb435a4260053f0478699306c9dc54739e81d925cb5c5b7c98aae9c7627bfa60f7733cfad789de3dbc420c369714019aaacbf10c1092ff4a6e9af71bdba79e615846765324d330304c79001d2fea3451092ebefced5a23b2d9661df0f6f19a7799d4b0d34ff83b28025083e539a3a5238b27bdb07a3d8be591da8fe95328753d804485631adab986365a205e8fb69ddd15f31a488660799d3a37595b37f5a8f889a3b8457e765861fb6b27fd3e9396f261aae78f2140d916959b2e91067259848cc2c747689142c714537f1c2aef0bea1b31ff5c6f9996804ca49b4ed06b0f036ccac9053a5f19b7b10d3464b2afca4bb9b1002e096cb37558f234ab8d667de473cec364bf93241f4b6749a1102b35648","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
