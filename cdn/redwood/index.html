<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d4422462f375b0ca8088429a2b1bd01b8c31198673790dafa0fa672d62c4eb08dc24c5b838d3072db92b3656daaf0d60d9a53183ebffc41794b24923fea2dd3d05566e18975e1cd37b3fa93bb07b78e29d023fce388d37945cf69cf5349a75cf271a8ea78a0b2532886cae832c34f69edbc22c0b9f723eb3d1b040161f21c5805c83278bcd8dd88ccebc3c171c993f7a9578954ed8492f68b1f6b908b3482a8ef07f89582fc630433f4fbb070c41d8105cad37f42572157c1681ab938a925e74cfb52a239a2d115330bc40c102bd8c3ce57550f20f1768d82be6959481f2b2c321888a129dd0cbabe8a73da578aeca788f83a4b0f8491c4f3ed5cc405de72c6e73568901298188e51a32d83399908ec0b12a3704231b4e3e422b3c7bf4d85a80c0d0d82784c53f059913fee0ad01e2f0d6b628c4af323d78953aa3a4e5295e846d7137548af69aaa5c0f304930faa6cb80191c07ee37c88e6eb12cfc79bd75ed9684a46ea3fd5fa5cdd6ffc604ce4261867465d7d3ed8fa8a0ef740bac18d522c0c62d4764d1d14ef78207b4180e46ae7efb8746f9e9fae727a2063e001d5e1b91f19b0f498df514b564165a3ed2ebcaf45dd4725196a4095e0243194ba3b685c19d098356a0eb21f11ae6f5907a239c065e700e397616a5e4cb2077feb28610d3e1022273a22e4e1481f90cde083262f7bf3c8a8ad38250759b01e2d1a9e47c555fa0ae8749e3ff5c5abb8f03008fe8ca6b489e8bed623eb0d6a48f329f53c9b53edab0af12bfa218b558a344a4834ef9fdc756b87707f3cc5ea3dce74440aa4832a13638b371dac20029ce1294d133ce16725414975fe9fa0b3b2f36a719ec329f0d4887bbf2aa64a58ea139b4ae30efbaf678eada765f2e590ca076eb0f96a11b2d94c6c1ac2546e6e948d4f25b2f207311b29286a17ddac4e1281f0735d43dd45a33c0b19d35360aa45e2d1992928b238d61a1fd9250f4b65d1f153ba23c0a76988c751c711a52febca79dfaa99c6e86f7284f67289ec95c55650bfd4e9be1e49e52226e1ef802a4e6125cdd415260f6d41c8d12232ed28351cbce86dd7fd76707c71a29c3065a3d1823c71ebbb521a098777221182ffc21d04abc831713cf0ba805780e87a7b653adbdf1942b3795f37e5a745e96245d83405ec3fa713002304c1570bd77116a1495b78427354617c8f2219ec86bc73f3c1ef41f4fd4a795ae09faddc71622635addda49e0e01266d8b87a2928aab5f235d904c6f7d7ac647c5b2f651b56e99ef112ca21800140541675b1532674f7b8a3e500a2d45b824885403fd25d72a4d03d1c36613d1441658178d69f6e2acae23511f69946f51d775e5d05cbeeeb2267c7000fc77b0d56a5b02e4f5bc5a44f4c1c16405da47f6d9866c6bd9b9d6d341e601e026c4b45863d3fbf31cc6b80bd41414b33f0b98bbee27304a952209d571bc6d6e9c72264eb6fc4b6f672148fe332a58a311f87833f2bd8c11da9cdd0c85b1f9e7ec07e46175dabd6f8576b4a750e002edd0bac4da2a00c51e01df53054bf47c90e4e01eefcd0843537d8b728bc279d06c4c1d09d7db553798061e03535d6f17972d1725b6795ae7747e9243ace3e42887b8188c83d7d0957bf3d2f808b94ede23ff77d601545ef78a4349f404edadd9a29f5cf7e6ccb58698f5ca93dbef8ae97dc30c87d6e7c1ce1e86a819099071ae9434411d27f69917578c8a1942199f45539c33d23468ab9262dd45ec22ef736ae3cc4f7dae31ed0930112a75ed9798bb9639ffb5a0124b94cb5b1e2ebc6bdb9d6d5df771b027b868ac3a9d710795f46bcb78c8496025f9c83c8839740ee8990b632adb07f71c41272462ac6d5347c46eb10c1a440deed5f16887ee2f03ea250e82d86733569801bee0d3e2f672debefc7150c7c12d010f9abefce02499d011ba1d8574cb910d5143c4fe3948c33e8b2c41a7810bae869164913eeebc8c7bcb917f76c0d7e459b470df9de73394b972f55b74171ab7419189920993a00f17e060588d0d8acd60836547778fb02db8d5352a3a29a62cd2d65afa67bf7467f84caccea686b25e3222d953bcceed37b83cf932e5951f3628c49cb4fffcb480a1cc396edbea47070cdf096c4243b777686a836d8fe2438b5a7b99a97241d57e89a8afb2e254672057d77bfe8d53c93a171d24f0e48d0e17dca8a2f927fb5b44b8f72f5e50650412f2eaf94f10b63211a47b4eadeb9a8e5481b6057c80c6d379486f57e825a7d3bcdf74f0304abbcbdf742cb585fc3fc461849e642b2804a53a90698db4a5d65a1b0b9d6e3ad8c4a4979477cc47c1c724a565275f36ae7b8f3e0744dd28cfda354de784e03fe7eebebd45438628f1d3e74edba2c18ef3079eba422db9b1fb25274b4a40b92147c1607c454fb71abd9b64e83eac3bcaa602ec85331f374424a8ac500498082361bfa84b89ef48806ad73facb3061f34aa4841f853deb9be0931ba5e06bf22b3e4c4b7a83d87d53af52b757d3637deeb604fab0ec3fca5eca707ee0e8f29edb57e565da0e1065f35bdeaeb9b20a5a41e4e5ddd246419f952611524b0c5606801d0901d5b2b7c1b3e831c1321f122f34402b43d02e0a99ccdf47fcfdb870291e48877b011a51703df07aef94e8a3e135fb01312106eb10754695a9543bd125732d74b4206af68fd69d823b88609d3116fa1721f79c6b9e43212eba7fd23c75dcf8c73d1424ee402dcc360ccf19e6d915094d218d22554909cb153d585905848c12113f58cb2f60325819edd87ba0b6073c59f81ecfe9b15fa786decd38b59dfa8b86757b471f6983f9fc6120540026ab47093ccae33f774afeac394abda61018f77c618437ddde9777ac1f14ad7df555a3be637c3b34166e00dbd1c5b67a50a18f59e51d18eee5f318c0ce2fecb4db3a2da3cf7ad129b816b1bbea41d764e025cbc66dedd18a67929d1fe555b2aee4b84c65521043ad98f056f80fe5c94d7419fdf7f717ce6b065938661a579cbfbf6b894d5982fd64b5cb7547244490b65fbc4302279a15a21aefa6dbc49a3daa7c83cea88bd9f0b0cfa408b1dae6988826751deabe6d0b027cb57264fcb4c67e9ce29106cc32c42edeae61cef2787d20acbe442f4a93f9f1ec867f6c64c68a1f4eed314dd12beb869d7af13676e63e2f6d7de2a9ad9bdde095766e00bdf68c0e380b126cc0fe88b3de021f20b6723f0ca735f7a59eda38c100e1744e40eda5dc7eeed27a4bede02b86fa85c3c376b9c44bb54762907c6126317bf58b0522792ae1bb41e80880bd33b97392d85dda4c27f398e298ffaaea0490f74d91cffcb3acca984eb7b0f55bcf3b6ab816d9f50c58f87b8d4e5d3c452e4fc425898a9ca8320672e070185900985fe7835dd3a6db744046ee7b5369e7e1b7e074bc94e81c9df5397c0ce67826349034de3a70f4a24b10fe211d47a80a2e257a6442440f545fe7a512d1cfd0bdee41b4550eed486b41e384c0e58ead916a402d139330968274aa0debd9b30a3fdb3b1b23d11880387d07c4ed1c956bb55a20247ca3e4112cb2a97b4aaeb641d68e814865b9d6aeac6fa4ce3858063139739564a36c89b9de646455f28e17b529be40d52d019d415341dc2a80a33b45f0903318726bf2524f676cec8b63d7645cc54030e8c67bf58228aec8ad42a853fa8b573b67c97009ec5f395bb13680e501f3b54362ebe9e388e9e0af9f4f6643812f69389a64ff762d372954a4b8df3f6abfb48354ca28d83ee1803499a145d6c07e5df32b76b84e69bd039364a7199edd55457dd229ce7454cdc9b914f7395b0295929cf0a7604fcac6437f8524c91c9a114c2ab23075fe29f47553a5eb87e41e8788c5c5a962fd3c4234d0e5553f07f5f6dead6fe49622333f23d306d0d6143c2db5afffdee1f8c7bccb16badb718a5329d7e7bbf30d113d02ad0d4dbce1cf31b58088a6a0dca5c7123cadf0c65e7cf96ad752fa8c8eaf556709adf7e2f41658f5461755b2dd16170d2d74ddfd06cc0cf370f812ab99343b9059ce4828baef48f986024fb13fcc96d1d84de1b73d0a8c29353e53593493557474bd557528d004f447c6914b32b0f7b00f7f020f6f30b344a3c223b3dcaa746aeca247749e15f18a89edc992cff5e1701d881f4fcae423d02dd333d0ab801df2bd41c7fc43c980427f091a443fc6855ae62bf499ce6bf31610910490677cbd4fb5b55cdc7a93c01d5facf735e1b390c26a5c448415bd64ad64da72d9a0cfad3cdb6fdd75cf1efc6408572b0ac26443b4729a2f492e4d22f03eed0de761b0ee894a227632d1b0ee9b7f26fb538ba422a507651698fa22cdd6b62a3ab599bd47bbcafc74707ad8cabd7feb4fe0d2b03a9961ff6ec1ba453b2c67f82fea8fc5ede3463f603e428fac9b206f530cdc8747c64b5bf751bee3c1ee9c95ddaa070571345480303e4de31f136a9db3d39627d8c8c4c7b74b1f9a6ea08de044e29b41164aea423f858994dfe50611b8c64ccbabd15fb5f4a0c2532801008829d7bfa15d237b1dc22ae45dc6877c42799a149da385cc027295dbf0ff4e072d6f0d42eb066c48ec478eea5d2a3a60b38a8cc728d0402f49c5f4ad7ec07b2a80c2b1deb53e8b553abd140ae4a54e777f28d0d748403bc229fd526e80f572c0bc0d54e0600e92c83a44e17e0162df3547f73c433c89d8e9d30efa48bef748cf6a8ffd938202f5f3cf3c90162d812de4df5a779b51f8cf260843acb743b1624e4020ea4f99aaf5fbe011efe98d504a6d782d96629f3107215d4edb16bd4e5213b3af465733661329ab6e78f6d3bbeeb01ff2cb69e145d596011c240a9bac20ed79a735265d06a6036213fa2e1f602d6d17c61fa1ddffdae23b1e96b127b9ed6906d506bf20919df89d342089356117373d1d768d86d54dcf19315d0c96975376dfbbde32ca6e0c239aed60d44c9b2d78eca94d29602b1ce446b194652f0e492dc05a082b699af1ccc58c4a779ac53b598e60763ac76801da3f05cc4b8fac490e0ad965f37ca90df36ab6e3a72818ceff5c40fd55c67b0dac2c5a4d19284c81392ce5af26e5709a58d91ffe6c6e3594a09604b7e40936c2e68e624a598b421ecd9276bd42dae95b75583e0424628e794deaafa03f40ce308b53fc419b7bcc521069a19c201aa2f191d67698e0af7e2f57578c6177ef9778a953bf0ce67dfabc35742a05eee0d662ef4de2c0cbd15afd8e4bc1bbf5e66a2317d5306038b812252169a3743348906249d2718f2b558f3c834ea42ebbaa962d677dd6a86a460ad65968446cef0e22c23301bf22a4db2330170c3cb8e2164f25e7c9080373a6b0e32dcd36cc0fced9f2f4a3d84e62cc5b40498dc01756e725389a34376bc3cfad90dbc40c7ba9ecbcf6800527f245bdc725e8ca85e19a718131ab689c37f994ed009a4f4c97f67f31da4ce64ee076a039de8590e01c3476363cd885909d15bbd7332eabb575e5971c9a0a2940f5d841d76c0d0e6fd5cc7b7ce1f302882d4c0e4207bf6051de1b8918e5b2a7c15b6956003de115beb06b7df53b03144a50bcdca9497723d889238e3b1f7116ac4dd2dd22a511c2f3473132f3c9573b271e6cf7cffb22f7516a4d1bb54853052d6b8fa2d36daf8acc9d0f8d0f78b50fdb56de07ae5457e8a1b4afacd284080d78878cc766c25770858ad2e554289229b1ab7d6ed3fd6eeadc5dde4aa1dfe27cfb455b7a639964371dd45b8e4992f14aeebe7a554106f9e114c2f4915a61379a999ccc1d52d27502751d5eb608b1abef3ecb7c747fd150e434963044ca653123460603dbf20813122cb365f5f3d76b607d694bc93c08b29924a6397b805c335b39b85858c37183313b6d3e480b55813f27bb3e11525983b519b457a94ddb50c040970f15a66cdd0430ba76dad18731028d9c4ab1c1a292b3fac7688ac894774d4b80dbb183d19a353602c7f84803863d27b9cb58eede2ad2d9b4abcfbaf6ca958f530694cd1b0d2b400cf2e25c53b5177d82af70eb9b88bc38b28a5c0e9db8cea6840953e3362e2823a8b823be2b1a84380abc9591f2776559195d8dab596d475d9dc36ef8ed69a4edbb864605ff5c61396c93d32d157edbd75a0bfa137b2ec5d5916995f720e61d69dd217e0590f17b589586b4a930232d14cb75cb0d0762b0593f0218343cb32a48e9ae12b95f1a133a7a8b2090769f4c7d4e10f20d2e578d4c41dc7614cd24a2a38e4ac2165f0d641a92a06e140f3510319dc84c1818cc3b207b09d9b6380002495c2b6136bada4c7ba16545d50367d38eedd60287ec784c7e08dff182ae5c548d0674df478173d7ec777c2e7f0b76aaa42f23cab489b9a52fbcad382f7bd4471b50bc4039f239eb65fe14008a000af4e404e22bd68924e99b96277d60b00b10f90636a5d9d17d3f60d281ab330b29957353c604962a44ee2154cdcd07e5f85e5133dfcf3d988ae50345aed649a5e9deb913e81aa5b99c0752b7cfd2890155f2ae1fde7fd189e28745225ac672924edec64628e9c1e8b4b34d654886af67fb024d00d7c8efe9778409aced48c9bdf81eecad553d0938c91ee3ec0499d0e15a907dc7d149cb68764a4cc9b9f2b5d1656637522a123bcc5f1169e78e51ad44f20c21f364de01403a203da8f1e688b880a8e7a1c3c1fce8582ad9a8de9d4207c5a34f69fb319753ea4cd83739aa61544d30c6745eaebf6b6817f7e52ded5f4c477e6fbcc39330196e758972a8dc7e2b5d178cff2e312335a8679299843c50d4d9803189bc869f2424f6186deddfcd83cc6cd3b5933970bb0bbaeb1df348d1522ff895540131169d12b9b74f3299350d85ff7aec7890e4229c1dd3c1771cd0279e5305bc4ae8828593b4cca38ecf597d0b09bee79a2d5a9b9354246e47441f3ff8823915ba49b9d864ceb8ffc7cdc8736ad62fd3300d9e7c5abc195efaf4d4514fb11b3b00f8793b3b89fe8aaa10de1cfb48687809c2174cc6224e8cd6812d8b6da9c0765e2a728a42b80b026c9b8e9b82c6565151739811390df910d084d1cc863ebc63d8bacdecc34dd8318034ecd651d8e2c742f3bba2b39c4bf943a63cd53e79498d48e5cd0d2fa2808e0fd25f4c566b85adaf0caa612557d3710d1f56e06213337bcd74fb85043f5c0d9cc492b264324b44113cbf5b22749b80ef28981361a199775abecf38961f03068ec1a0a1a676c3b022ac1c1f3051a3cedc721de1fcd8334a869aec209c130d9dcaecfc29db6bc39f20447259bef12e2b52bae7511fb145328eb5f5340adb1af6695cf3bd971af7c7c576175f2a3fe222e2831bb9194aa888692a8ce5d38144f81f5b87478f7e34ba7a59ba729616409a24fafd72a98699541f19b4e1315f9a4b2d1427d06889e3bab31ce5ae25c1345694f74f6afb7a6a951f9e1599ac43761435065a2d1aa4d81c5338b0988daa14e79924e13534bd49a7cf721dfaae545739ecce77921b846d24798b82e9f084644db65f102fe41195f00067f52d770a4e2834b773448c356321e61e99056166dec5a7603aa3ecb3927a1a0741dbd4b47e5ac49b06b92b622ac8770de19ecf8fcd68c5a003dabe6d9bf7c9fc446fe1727dfeec19fe34451d73f7939ab4a5dbc18fec9df27a18d957e1ae98e6a510e93599c7f7d00bc4ef4cbb6e80a4cd063c95aed260757f225d9f52cbd22a6e782ed1bcd1ac6e0c6cd08fa45ff87feeb7cbfb6422e01ff822deae83d5a0cd5ad68d81786cd0f6538e2d95d03483e55796d8d0bc4acad8de5877b3ffb819d390a23ebae85390b488e6519446e01a2c5d2c5e2359f8c6113be1e38a9484992c8fca7ab5abaa9274abd83afeeb4dba01985645fbde4ce49009e98163d26a49de82e8afa67b09588b5ba89d5362d4a57b82328943dc3543a5d0b6ced8f255018d0ec1509c9327828beb7cac23a12fc82a8e67d425d62341d32f08b9236166943d9607bc676db242b28d3d8208dc3a8b946398fbdfca3b8c35c854599f8f9b500e2a2a940b6b78cc0fa65289b658d509af67ef2df893db6f6aebccbbdb80c832df3fb6abdcd484bc1b0b20899c7a04d921768d4504b81f40e838dea48bf7559d5dbbe019c5745d5531bb924f2e0c67e734274a846fdea68ad8d03ebf98178a9bf32eacbbc649cc7b8c999e0ce6655f82d80bbfbd5b18356fcc7808870050d375c986a30648f91044781d0063568cd1213a218e9971c41f4d8c34271ee8155be277142b27aa0c39166912bb6d6a74e703bc2fbcc835b17e558026b197cd06def8340d0240afe53bdd2aa65245d1f1f105396f0cc5f510d585e37612457ff411456409abf4e839a3d2b620e4c462f1a3dc0108f813e9e8316f95f7a42c04a55b8e875d087f7c77777ccf56c46c3b69a3100830586c90213447a1930bcf6d4118820c22feb9bf251eee6bbacabc8bbfb0c9e36530de2c26b02a74882ab7b493430fa3d0fbd466a1a64a5e3c01f5a768171c7c3329547c69e83674b2580b16cbc2fd8458c224385ae51101b712bae2430755364e90408046f79dabe5579d6e74ad4d9a6eb36e40c3a5b43abc6cb6e899a02ba0fc3918edf676024859a147acb81fa8c42592275f7d0c9914458be5469e7f93508c6c5da57476360ee2e48e60ad9ad2ef6a15264b57d60aaa5da18dddb2c5f70d81fb94a966ee3dffa198969289770ae3db4fa068301e43f6df97ccef46b2bdae1718834c49b08b4fb77d422f48720be8c717353e671e625475cf7f15f8499c9338ed317501cc257c576a8aff95c0c58348800b78e54319ed0b55e7760a00204f54f493bfc64116d284527c23ee55cc4530bb131581a2425c3e05ef5c021f3ef5141a8fcfbdfd4e8589cbc680ae0645cbee7303f174a58a1a4e7521555a183861e04b44d6e78bdeb5e502c744260c4d40332f0731f1fd86b0a1aaaf91e0b7a4a3c7d437dccde98e10f1eb90c88afc3e893d838140e11dd23b09dc9d4fe5a725dbe65dcef5c4af13159fbafb53fd3be6b42d0b5e7978124cba695a18a55d663fb270704e17bdd5dc7b1e8dd5c0320ec8c64d715c75299fcc0146c318fc05320543602642440156b096b327b504985f91d078aed49640e3542d96dd1ef149e6c4c00dbc2007c0df58bb3c91d6732e6b3f6388ea7e79042770e3439305bcb3120e30d0a14aa0493b71ad3ce2f170a1924fbf6d5c62c05805835dcb85b438baf2bf1a351f6b35ec0dcf41a144fc18fa0510bedca77c1631c2d0664af84f17733c2b5e4dd67d0474ec50c597f8b8b785e815c7d52606b5c9318a2886f56face2b37caf0f776577321f8f48709cc28354988bf3a0519b2457632df177afa0c94331f51b36f498b07e51450c7aa7e75b01594f105ae873c6b26e5423a0e428ae08dc7fcfc3916e37b51c95b3a6ba23ae027648ece4548e11e5d6be20396ebe3e466b4df05d220a802ea5566a6e74abf2eea91bd882fbbfb214a46e67a77243270ef88fdff220d071d71ec9de611a15f97615e712f883ef681b441fdd439a6e61159d9bb7d2d9fd5324a5ccff8b2b1572790e5ce4edd1ac2de3e51f8af94f0f5b442ebdf36384baa1b0476e554175924bcc021b7cfb38670fd8cae20d3289e2aa17b7d70cd579706906db5dbd0d1c82cec19d3f65bfd8b12e6d1eb7b3b1b2923141f90010cb8a5bbf5cf97a2839e9269a968c12c89e7af6046035d52596c17995fec7a73779b612e47ef9a69c55d3dd2086cad173cc12f498ba7fd8093163a5d6a01007a6bb4727d3c2b6d1ab45c04787964ffe5182d1ce814c331b50b602cde1a115133fc855c442b583f360648e0093a06d26095f97acc09ab9462f3ef0cc456ddd0997befaf4246776d589e636724b8e3e7974e68c721d981f1c4f0ab9ade18657be10b658fcc90af9bacd19646173364ace887df4564e0edfb179013e47a84d4eab2bbe58012cb495fa26b4839828a444e1d77c90b06e2a195bdf510afecb461a1fe87d9c23adfb27babe4583ad5f0382c5da4fd10b79307ae7c1c6d17cb1097699f7a16cbb5a2ca86bbcb657a67917219bcb7d8226b49a72256ced236749edc63d7e31c446899df1672da3c749ec7cc9c52aab002b47546d631407b65288df0a619ff7020fa81738918fc02a814e2b9614f95118da91a038af8e3018a8e39c610ee57ea0e593a0024135d968f756428247f1285aae7e4f6437a7a85704d9ee80c7c718c543134d75d259e8469b5a54d5a7b201404d80bd3b23b251e4b978bffcdf6ac2ecec8e9017bfbcd1eb1228c3bcea2d43e541377830cb4d7ae32eba947a11673fcf1bc313688b9b28bcbb67d4bfadf21d39a5b2f6801e3da0f52f282c6237b9c633d3c03f4395fe7bc77f50da0050f4246bbd5fbe09eda75394eb4049823d3a98006c9aef6e1f701bfc4ebad9b2ea2bc2322262cad65cc32cd7c31d0dad66425a7076c2d265c1e9fa8a827cc8bbdd6c0f9bbef955dffde186fd10b057b1ad65cf279d6da2384382b5d14c94d4aa6e55bec0f813e4aba62aa7ff8efb9d56273cf535bb5ce16aec4feb18624cbb80a66d1e9816fe26ef3878d6fc445d2c8e88b8abc3f0e28cba2efd40794db1a9bd7c75a82b6427a7f23735d694abbc5ef9e933270b0c09140ad9a3940d31344256144db335a990d6396ca756fe1d5759e078cec94d10360ec7454ef2079d8d86d6677352eeac05bfbaf96c49f604345814ae99777195015c535c70f980a503d479b8d0c10a2baf73f044b95236cfaf959a86f5f8157837780adf7f6204f0ffd008d88770068a8f02c5d1a743cbfa894db4989b64a8bbd0b12089598c376dea70954b58b6c203f0373f333d627219f063691ec30b84e872619eca27c9396bbb9e75820560418e531a0e2e9a9db566b1e3c8a829f4aaf0d039edb7d866a03a646f765dc6a40de1af985375e018ec2e817eb7d0bf6d65c22b93964d1b1871a5909c0708a2e484d5f59c0bf01b6e3a5a5f70bb5d904d7aa1274af8ff8a557b9d5154f26409e495e5a911f4df46a55772489a2aefa4a343ef40f4abb3eea2ebbce9ee4fac8ee1440aeb67c4169f2db6cb720cea408bcc13c79d360e2a27ef0ec69136be336b8b225f075e27f3c7ac6646d3ab7eef21a61dbaeb0c66b21fec5adda6e9285a3aab916b4616ecb74d366eddd69936f930d63b1d8c267ab091dddeb23b7f798817a914f2cd8825f585d7c51850d1dbc7c9e0e7f014bedd1bb57e74d18672424babc0148c8af27f4948559a57fde373ac3a0c63be27f6c8412bf3fd95854dfe5b92b07ead232afda06e934212cda4362913c658d4fcffc10e257f4b9aa3879eb049a81e06e4ee6bfe457132d51474dbb496626916d46ec8e1c0fac405063f9d50f7bf279e5d0d485742152e2f82571826d97d46fe1ff9810e2140e913846b1efb321905ff1691e02f0e0d3271ae5063ab2cf899e847e8f7a1b33b890fb25dfc60daa1e554deadf49c310ee011317c59aada065a7cf0ac37f138dbf998daeb4e9d53a8310796407a15e401a7a1f3bb609d35099b4555071473136132d9652da7320d1072bdfb471bba5b5aeeef6a83f18ed23ad588d4b518427a751788b33c70ee0719df0d0f7266c044b9303473c11a7b2de751bf9646ad2ec1908c8d6dacd247d19c7c65cd0559bcb54dc1607a6f490e04d36a801e4454621ddea403ce23bf75844021082037eea17226851f4b9d983692ddf3b5f02cf9e6e5691a23a6fe61b602ee975e65b3f225a762f49990a831321e59d82b7d25735098955e637314200262d695e1778e206d5503f72f8d00e4d753adfe4c8bb8b86b5fdfa490952e2a0f57121d8c84e34e92cc67d0dfa8cb0f3af67c20ecee8543dab0d9e160ba6c9a42e67a7e5884ab4cbd720d9020e79aac410a9567e52785579061051c71ca972d9154d1baa018d216ebb2102d4286e159b8c9302c7a80417045e8db1313bd54d46868780200248f2e656df030d0333fb7a3d8a937375e1eeaf0a2603b41b60c63aface2ccdc1938f768c391797ae289dc3f76766175f9eec7399be0b41d67f1401ae467273f77a96dab4c49fa095b8d1e26e327d526589a5bbee23132b9672bbf66c682b192e67b6e94b219dabf5330c355662d2e15f523f998de3fc3ea5a4db60f44eb32321023e0e0b272acb8ffcabcbd306529aac13fdaeb1280c8d9ebe9ff3deb1f287d7398ab0a8db54b69a93832bacfb4cb0d766e51bc67cf453efbbadadbba294d59ff87ee02e0250e3c78266f369fc7c656702a3cf68d4760d3c32bf923736db01536cea5d5ba0ed6ad44854e6e219991c82c72b640840064b5dc4603849bdf6f287a8db060f750c6a114ca20049a80aaf222b497347f148c0263852017d3884a490f5bab46b50291f7649ef136b00c49ca640b40bc33a5239c4b405b20b616c8faa163e6e11b3883bec1fa1e93044f59432021b1f87f03eb49158abb42b25fa96163939042152243d8249fe7229ed8afc2e2ba11777d82db8b0cd3695dccd97c9624f4225b4104202acee2d8a6e68440a28c435fdd8116e9c15274abbc4d8bd80fa09ec1307f6130a4397f3f1ea957466b480cee252de6aacfae8fd8fe28f2f0d89c17c647f3be750ddfb715a283dc98d9ddbabe11e3ccb1fa593f4b2c6f60afb3fb5b14840b3491fd4e39896966a5808c17546cf3264832681f92092f5674abdc48080bc7c3fdf1bffedc9a3b15899b5f2580308186d147b6605a091373672ba46dbe8e42371238ac17257f6d9e881e4cbf681780c1ad22e1f68e23441d6a09f96d2da6240981962691052df87d8cad12dfa7154dad63f6d34cb543bac619266d08b0af065bf97701118ae509423f663315d716532d66bfc2b45a40702de3280525e13bf438320ee613e6d9e7776c999e16fa8aa4f675df4f0429d81ccf0006f3eb71e7e1c1de4fc2d2424e401f78f1aca0f217fb62146725c3067977e93ea53a6476e2ed0f689dc0488f1b6f1ba03b5e102ef37a423ad4c4702aab1c96e3f8976be3b4707a9605a0d73ba617dff62ad775ffe2f9a3b2a3a5e98288ab64eb65a9cd14e4d30a11ffd27edffd088975a2230658dce8d24626acfc6387433a867a11a955823bfdb8d34afa68cb8e6b9b8b67b2a1f119bae65a1edafec4b65fc61c754fc85f1a7d84e6ae3ff2f88e22e2bc2bb58f7633b4a92d28a59e65850a263332bfc90aa0ec06dc1d4c227edd56eb54f29f4beb0437c371bc008c4c6e57271ded06b6eb673ecda6ddcd582f1b5f989f948e948c7205b295d246cdf57fee91f25359470f4a1193d9aca83ad56b980999c286a122543eded71287ebe6c05b1688621aecb0ceb454776a772f09a5b0e08f3eaef1074f9583a0e3c35d904e2b8e4f4bd8b94fe09f930fcdcd2088918fd90d52cc899a561c6726b0c5052443cbc536ce637f67621e675030376a48c2efe944d9b2be35d55675112dd7c600f8287d56489ef8c0b7fc2d0a341454b7fe1537a637e157625f063e62d952cdfc3418e52d0568a6f404a139a53dbb9ef0cae7a82dd01413d8354a1689e2313bb71b0a85b913adf24db6b7821ea58dc5552fb2030ca04e5fbc12c64a0195827ed2c541a4a654fff32437597f5b9f40641faea9a2d34a26fd3234de131230cb1bfa2beb616e99049344b2d325908cf774c1f11d684b42ca0fc0c34a89e602ae38fc819b27097948e57974a43cae64fa056eadad8aacb5fc953e4670e79fcbf1a5daafbe1b1278f1df52cb1a12871112677e37d4873f20b72213bc0e26f5e621434834d93cf3b809145924b5ec50ffac14bcaf0c6ffea053b7083dba63898a7c74be3a3f3e9ac19b9837149649392d3ef3115aaf91b4aa79012edbd422db7e1e9f4f6671f1a9aafdaa09c14b21f93f79e02fb22475f51d2ee35541e1be43e2dd0c9fc6f0fd9b398721916671eca19fe975ffbe2f28de04cdcac0977b59dd5011382e4e19aa2c9464a761a06cd0b3df025a960fb9f684ec57f1372162a23f98e8197bce0eb3311c29b18e227f94591b22afd48f79f81aba453625b7ebf956529cf0ca44454630a8a5f118d8fc873063ebf115b296a21223c0f52ad8ce4a35fbdfeb3a535835ce0c655de14d8b46733f2d32ce27d38535aa138e134e9a1dc24ba0d8a8359a7cd96548e70c42538ada9f71150e8835c9493b1572006b1aa09b47215c1c07707c22fd3245c5c19bb7ad14d6fa8a5e722ff5b59224ae6bbce814db6f03dcc14ec26e28e941d54877e0f722f4e9888e5294d9ced671616a046568095fc5ed5f897d608334f2bed8f9ef7e8f5dc8adfab145b69ea7609dc4c888b8cea3ec45ffd18617227c2077b3b5bba5431bdd480d5a31d4b9246b95e2b482858b26738fd42a5ca1d62f5aa4499efeed14cc040f9974d91eb2fd796b0bb5c404c57d4885e59f1f1acd213c6ce99e9dda152d996dacaf4790e9c7903f60ffa6893458b73272fddd4c15a66870eda0a03f212d2b47f8c5180b74774b5c18a27007a26792d26098e9fcf12047feca6afa776f7ec736792669e47837340e2c0bc0c74532831e7e57f1b31b9574564ea8827ff23b03679102ecd3c573b9c23b31775b0a9ac0f8a96ba1ac6b71be9937417f65b5e73019cfab8454413973b4bf5c75271b9a9b67ce6a47551d7b89010cfb262ccad90141db80e6e0b49d8982bdf7e3d16d22e4a65593256e191dba43d1775289247463f1e65f2e49df10bd279e5a6789f2699cce40b911b1b10a30747b24140a9977520b41a7c51f71e094de5739336c0cc35533b28119e3e32b42ca5d840837abcaa730e674193da9afbf04c0fd93d90cfb96c135bdbedcc0e73c76b0a2dbc9a1b56ab663fac1340a308aba18c4f1bcec8a604a3e388680f2b3f2a4b344b9170cc52655d13bf5ba69689ab235416d6852b6f44ad32220bd6d8e83ee3b2d02b0dda78c8e5fce0ee2918f211e818e5b2c4fab9d318227faac63f86a8db6a4e181d361fa5b87f93234cb77c592f70536036023c23474b5d4aaf0f5bbc50b7e0600d6ea70ee2e48f7cc39fbfa9c0dc526314bb39168edd44f6d72b36d78376184ba1b8d9d46fe99394443fa6cfd592f25a75b5dd9f0c0a03583d5ad28850851273841dee0fcd587b541d8d861bbdc99ddbb94ba499cefddb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
