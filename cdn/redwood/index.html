<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a9ea1e80dce9df9ba86c219fbab8e2575e40775ca13273259c6a6f1cbc1b3f8aee6a34a24a3d7a64800acab64c62a70bdcafe603f5b2781c1d535b80b50cb49d91633343ebf4f12c637abd63d0fcd3572ddd43835b1f26f13c10fc93a568357b10a5a31c26536c31cde157e59f7800a276bb02cd006ea7812dcf7769a9181a6dda39672107cd23d48e99680f15997204788f057442d8e030293ed96708db0c64c7e476393018c3bbd2b4a152bd96cad272571f86b959a604fe14d46de3f27c28408f990bfa9f9f8b579927073a34926d06ce25a19cb18d954a00b5f9c0b5642cb7b3fa35b2aba8fd89f676a0f607e0368f9e500db6ad4ec096d801f8403b0fb05e7303565c82fd89c0db1a8f951c86f45999cadb66e2bc6f458de7b4c8d84c32d6029f3fa0fe35f2497c9105caa44642532135a0a4041af5a459eec5fb007041ca6f55000f9ff4982d53115d3fa260860ac15ca2b07ebbf5fd2a2b8cc43a163d24a3849544c543cf4e4eed178821b93241624259b13ba66446ea03ebb81b5df237e0956313ba10ebd746c0703622ea9f55ea401e319ae50333be864301454d46d09cb9a5e7e7b019753ef259fc8990fb74d9732b18e64db070fd89ae14dc09069b7a33dec1ea2ac584cfac8f8234d3c0e950ab1329d44499cc68ff80a31d4d353b85469ad0e0ebaa44e11e5715ef43f9b5618ab056199be07a01a17d4c591eaa5f820df6f2dada6d7e4c1b1744e7c7babb7ed4a66e13d397fccaa8ee5ced227c6281f12c28bc6e10b00b88531decfab867f3eb30ff54985cbb107f80db2a05027df94cdb5720205e39d7d603c0b2030e5cb0e945275bfd40a9304e154cc1f6180f640cee64d62cfa33b87777ab8ea23262a3e16ff873d18c57e7f54dda99b52d873474ce6ca840c47403d7844820ca9d0cd93d5e33870d582830ff2418f4616553e55051bde0bc1924250f192fcbec0716a01cc60166196dbee94ae10f1ed2dbc4c68fe01abaa05b9c71f6c68f6347e7554472c8184e3c7d10f403683b80b9fd573a5c661fa14a7811c18bc9bdcb496611a9be4223ae380dddeebcc264a5234cddb7568b85ebb1d9c568944dae172af4f581bec82a7d3b44d63f9af3a5b626cdb75ca9ce4b766bf98b570657e76a2d68bcdbaf8c4cc3295786ac58462e392735c609bb1f6f26fbd7b6303dc101f9e329d4673f40ca9d4a0e358f48120ebbf67a218c91f9fb69acee2d94c5c8c7b3e67e8d8e95110561b8f8d19f3c3326240bb6be01bfee1f1effd0e94a33eb7a4f552714f479e790e0926d8adc34a3d0003452b765b28765fd41e4e2bf603f676204f3164f02acdd70e3640681e8741ca9832c813e04009e88172ed4403b5ac84acf5b10d817034b9da71e2a74c1aeed8e403d79486e10b907b83e40a23279f3e0e55a2b9f541ab7d6100852730288bb5671f0d6989382f8991dc7353ec9965159bcf7f044ec47258d5222882854f75e7f7dad4115764deb32afbbcb7256d02949b30566011686731308e26d40e1acf1d1f7d65ca324f5ea4e7297355103e22fc5addf646fb756b2a2580385d5b2e104b6958d0b8f7a96047f50703ada1e7705c692bbb7bdc0c36111ca82d83924d137e3f3039dccd03e37672b11e6834644769408fe8ea8fd1c22af1b98169624c72b960e0c0738ef28e3f566a696850c7a73f85d5ef19b95a4ba8ef379f5e9e578022a56dc9a3dcb554bb356d81458da9862c45125a709cfa581a46bbc7a9a48d386b4e59927011d6ea60ea58ebc2e9dd04483a7a900ae6775564e75f66888df2d230721f90190aca70a6861363448d4ecf45577fb0a6078c9f5452cfbe69865fa59c0f39c8b76d8847cb3c6f257478d4695d3f63435938f3c7be864ff53d61258cf4366c121e34cda9d94c36feb1b680818fdd628de82ece44aa5d541927875b706d6b513eacc3b898c1516e5aca36f6fffbf5f1d2bfb8efd68b106a774b4c46d5a78791f1d0cd5f4cc6e3e29124e674ecd9d5a87604d6c9980e61ae77fb08838ce68418e8252e02809ffcd607118ecfa429f7885bb7a0c70a79ebee6573c9eb2e5775ab3f7221657a0d763f9090796f04aa6f123b8aaa5dd2dd0a79b3c8aaffbf0b0aaee33e053349ed2607a3b70708185670303d65858a3e141a062d27719c6c32377641a28c1256339baabd7e236a25f4e96b5ab3789b98771d801b093a28abbff54e176779e45ae0226e0479e65be11c0c7ce60646901a6dcc33958a8a7e073f2da013230734a1b7b896553ab5e561c67dd2754748cec385ea89f22bd1ec5b1d6be5428f49cc862902863d9c372cbb51df0e9d4b1a64db9f0f8f13de34e1d658d926083300b27f9d9cb3aac9e3305c5be3b9529a01b921a4280e2057e2349b11def4ef388bad212713670669991c7b7b7d477e6f2183dceac6d973dae7e47e69f53a01505bc051e9f806feb97e5852fe310d03d0c203e4655eb9397b8c98051a976fd45199036501916700f610acc7a343b1485cf7d5c48fdfcb0f13c20a12ab867ad5b2722d4d4593c065f84efe8b0c84f3dbb00f0041b1ff8497500c863c5330333bc8a034dd110f844c958da6c6478d1f2748caf66b56ef2496c31cf64be51cb629297a0fdccd87d642eaad8e95eea6b63bfb9e9a0cfc1743a5e86c84e26bec34fdeaad17ba2e31c7b92e38850d554120f9a2d1d3bbc334fd250a5fdb8df40e5ba45da6a1d4bc8133916cd0d25ddff1e75be56c05ac3ab485786f2ec1c3eb434002341c09d52126d9ac633040cfbccc5014f22c46bd507c80f5f01681e16e4d43b50945a30a7b758f6a7b597cd77a5ec86f7e270c68e2cd721f59fec58216a9fd1a03286222d612ebfaaf418064faaeb78a0342e7aafb8145d3105124cee3bd58c30133220cee783b4efdc5f924715499459814ebcba3f8083979b8d1f8631644380e17d40133c907a7ee15c4b4ea121b1c213dd5f42caf464df2a11ae1909fc4e1a8a14565bc4a0113f9b2d1efeb572e2e4056fe9271e68b8b0e3ec8ccf34f5ae8ba1a4b3902524ba778b5a84f8f62e8fca43550067467edcdb68c6aec1a3acacb631579f925f4addefe14dfe6d12eb113b9e5ab46dee3ce0ea934620f09bea55e766d2db7b76796d7efa04cfc170fb292a5eaa4f04bfccdc7656de73573d3fa6fc3207af1f750b4ccaf71fe5524af9d1a89c87d3d84f94a2d64b5bd5ea34ec919841402a662360dcf487ff318b1766f77bab4ba5bae9971b67d0dbc36aeeb67b002e9b1b6ee2d0c4d15aac4865ccb5cb987038d27a36b346f2bda7dcf04dcb855524e47d1c558d3603fe1276b708ddd38a62ef9d57339b2dc89a6974946b7f3f06c676294980671f9b6f1485420659313ca2e72f5ef8ab5e0435bda6541ca13646d1941c22edb9266babc09e801cb38bbd7c97e76ecbe2880c513632e29374022e0c75fcbe966da504f8302cfdc14ee6e7debeb00e195929d354d649389b5aa22c442d1fe78c35fa06e50bb91e34c6fdb64d011f221f4fd08b9de3e84994ac63e9eb406961734f4bc3613bed4a2425de69e0a9dcdbe8d95d43b7d844b3a82fbc97e54b868c7c86af6d0fd791a844ec5475273534af2423aff31f43d4af0d0ec2e1ba6ef59917fe854cb7d89916d190a70528c2ef39c640a2d18bbb1d91cc000a68264bd6792bf7800b07991f47520015d483ba939b1e86e04c1d2fa3b1899c60320b5da37484f6a14f3e260f08ea42baba7c23af29f17acb13fa19923aee8c7f124f6698fae6e3ca72e5913316f9f0d54a50be2a0e7a7308d7d12a6cb481e2e07f69e305d7fcc987b3f616e58c2f3282e7a521034fdc80bdf915d136f8dc8b9f4109328047faa0acd2e34ec4644f3ee558dad3f55c02b293d89cf6766f2596960785a955f09af405f222a03995cf6c3aa7b420c830b99d833e982aabe1243578b67964487ebfead31fb79eec60b778fd7ae41e75590fc10d4903f479be1e2b2182af3b835b651dd72dfdfb4fa26163024338c7949942d667d4fe002728d9e73043d2937739ff1b436d235085e1644026049e1dc83dba0bff1177180ca6b310f1ad6a3fcd631c76261364d53f14cced7c991387ea3151ea3f75bd4657eda8908fcd1900aa7ba779a0bbe62f4359ff46beb7e3310502bf8abadb170fdfc31dde053b47208794d36cbe58db1743ffade15b6161498cbeac18799fce57a44841bea0374f717638b7e62dc3cd0c728c10d2026142c884442da0827b52f4f089997b41c59edcd96d8ef8a0a0cae821f04b8fac4cb05054b5c086fba8cfd75c31a0f20c1d00123b7230251e4e3970e7ed0108482cd50cca0a9c8df79f19eb5b2af0611db228d9cef6327095199cfcbbde6f54c404e74b61b8f69c723b063e9fc3fe29f744a3157fdfdf73e917c2733c416b6662c5720d137b542b14427c2713a5a562b81a0d1650137a6e6a942116d9a6001710c3c8c49cbd20b0d5ccd3be75db7df77e1bf60c56c50b30c1f6f58a6ee85c68bf53b0a1e4530e0dcd5052bc240a64978d9bfe187c0b0e9fc9efb4fd267248e13f8f9c6b161cbe83a25bc8a46573172d0ad6b0a289fbbad7c914f9c6a9b3c9a88b284e7aa26ab6abb722bc6c9602bd8c8fc2b16bb91e826582f187c0d1cc1cf1dc2cc40cd262411caf7b46609df51a254720b7dc04a510c55e75a024324962ba19001284b3b3000c137a6ce8fd4be84c813f34ed5cb7cf90357a76c3c2c61d8e348127545fee73eaa7731865bc04f0db701108c72d1bad005b993cd0a4ace337e5df66076b0d6a912420f2f28b3a7eb620190ce28942f7ab3093a2a52fc77af239a49f5795a3917c4ee61eb0d24f2406f9349829432c7fe0519436511143a26455f86fc7f445467bf6598fb8b50ff2430fc4e0f18866d665aabc16aa72ddf0a51ebd9ef280fa77d641c66241b9df4f0ebdec0ab8f6318b85c4bc4c6b8d2f0538abd2b720e9bfa99342d8b2e35d8781ee8b366b736fb6e25476df6ab857d0cdae5c96ae3eda2c993b69c6e3c3400e1bf3c7228ec6fbe614608c8de4c433623d10f084bd3b23d7c77249af120e002a7fdc43a9c517ab0850d5a1669c08b52b5dea3b33c51197db017892f2441b62848329166e61aa8ffa9f3f2f817b50dea31781015fc9a5f486638d5e94dfdc388e4616d560ea3237645312d5bc47438b200cf3dfc4f517cd24fa5ee0df06bcb519db7f57f5c767c5758c20dbd0d6c227ed88210247e5e6e281dbe1535dcd067fbbf58ae318c7baea7e01b6d8db1c693e0fa9cba2ffc08d637bb27316b37b0d133f306ebfc989432dedcf693c913a69b2e1f7c74935cf30ec663321231be228916f57b0255a09e0d3fee5ec5a016538d80a66a3c8de3eba1e911eb46b2e3ac4af9360c09ca5dc85a925963d0f4f5c9aa07cf26f0d82b48f13f247b48f8ef6c8250a3395ca57d63cf3203a535de95f625b92a2e38c43dcd6402f3de51a6d0ee64112e416abb12f105203b6cce9c89cecf3789831c7b49f5d1e3ec3d5d95c2f81fa6564ace2ee2b9f7da18d95280a943b98e336600739826d23f7fed32c8609aec90f8eb90581894302b02a6e47c2b361d1f3e96b370a128a62c7ecee2a3b13f7f07e7c38d06afda3a1373b8a170406a83c3d2166f2248fe0915a51234c473a09fabbe5751c582df1df247c6203c2cceb2ca047ba230457ca1c30da526c39858bebc18b255353b9eddf0787aac8819af0613dc7cef534a2f704cf7b932d61c16f32fcf0ead882a69d582950e10b2b9cc91a8f3c90e4f769b1e3afeed84b858ac0a7914142d4fed8a0aae34c3a7767d10f4c7cac089b19fa2d052fe6034547fdca66a7e0e3054e407319672b38f086c0de7986b2232c7885769595213eb589c04c86eef6d08e380758898e1d3bba217db650cb28a58489731da3b0551e0ec09358186168e35cf6303af69d7a6ece31b01af823776237c2539b8ee76936a425109938b0bb61e8c25546191a479ecb36c25683a695510358cd280e1c848c3d60f63276e9beff3901def83cc6c0710fdff8572a8749841105691914aef1ecb77035c6d41ca329f22720fd3ea284fc2ba99185f32b58fb233a7a9a0615a46b99f75755df0fbb34ae4cfaf7ebb33cf7947f3e4006e0939bac3c7aa2f811203cbd76e0c95c632391f6369f4f2d00e9d9f858a4fe725686ca04c5f41f73bdbeefdffe76d389cd7398a73d2eea15572d4d7fe681d9304da4322bcfb8f2b0865eadff12831995e68b3a98fb7dea616c86afc3e35e49112f082703ece8b1d0763f683f22bf209bf6b54aa0c567efa18595a6c9aae0fcbae7d551cc337b328f31247bd1a689f5b653a1f2b65ee25347d22c2d1c67c4b47f88629977dfd27b399bc2a6304c935d13d67ba204a8a129c44de79940c3ccb82c285a4a4512814db3baeb6342d9a28af398a142f73dfc32405678d6db0a61d7da225e9b4f8be0ec8ce2e10307850f86506582557138cae71b0e8801c6afbe26c4f231eff63574f446b5def641e7dc5920b1a5c198d6eacaf1114dcfb9b80dc7ca83e1b21fd441f12f18c338523a0bb7b07bd6886450c78b43d9276e89c5fdb44e2389715ef3e2f1e5e20f9fcf6a925fa63fbd1edfab544b7f0ef8e6fb568b68fe2edf23b607cb5a813076d54158095ca9d302c5e1559f61fee6510fcc4cd6d1928dfec0ba7361f805a77093fcd38ff6b8e655607cfdaea5fde0f0021847da04ee7ad8c6f64007f8c8afe42cd2159bb1f7072e95fbe619b4ce0d018b1332842de2f5b73e2b24f52cd8a46eaa9987e6af765edbae22bf356e44560faf3a82e9445e41dcce1213f752e04683ca32b53c1e2563d50c8f37cea8240c178692fe7ea190a795acfb5b711442eba058027cf5498e82c996b7184ad3a6839c006cc8e628f99b2f499fa3f59ed820fbe9aee0063e9bf1422139a24791f63e17030b756db81b17feaebe9359415e993f316d16d6ee6ced6af39ad2a48b2c1454658e5d8c90603635d2cd93a4e6b60fdb48a6765e9ebc73842f2a22735a8c1a2ea420928b9ffa60a1d59dfbc3573373620abdf3bdce26060e9d99f21cd176f92cb3b9aed8a5f36aa4dc63fe671c9bfca58d1eb9fd711544be3f7d37bc291d0afa33b077316e1629ef7f55ccad4ff30a525c17bf5adf5957fb36ec4cd8ac6c36dc34924f72c4233c9ece6cf4645058705036ec2727550e7e70598aee4464c2d32916244e7364548a9e1b2cd7f6fd48795180f7d282b50bc1ec177e16b8c003d0a6c63811918ab479c7fd2bdb8d139d6954633c1c03061c956cbeea0170622860f2e88bb11a9156656f04b559ab3604c4eb796fca1a168ff6e254c270a8e2daef555d5ab0b4388c2e3f3f223edad2915fc8e1245d507667f21d513f81e5ae344eb9e3de1c6e65125ca4669dabbe1528aea6cd8058fe47f5ef79ecdcb9077a1e5d1058fe9080118134ab7a45fc4d7d48fb5fd9cc10cefd9ab9592e5abad1eb8a9a6e29ea6839e7cca5a1c2caeb34e7544a1387e99205acb1e8e72dd592ed9f77b23c064406106ae0f1441a47b07561635c9c9f26edacbf0e6aa77d0455ccf99c51ee46a6244139c4b9894f33ba932bbbf3ddb6476121d756de79e6f0e84a9ac308c7bc7ba18da320571faab29a1ef52baf9d24e0e4645736e5d3a2623d035396a8fed29ec650b761a5bf08609bf8b971d388ae8ecf9f60d1da33fa6f3cde31ea440e7e309c672ccf6a162c0e8bb27993ab928d34c7ccae27b76e46a0d7ef2ff40bedc0209b87370c62ec8f24dd42c5c224ee9306f31e1eb44574aa2fe50c5abdf9c9eff5938f34075d5b567b46af41768873466c8d839f6e50720d494985ee2b300f694a4ef1cf9d10e7d19911ffacfd989c4c77eb4ed2a9837933eaaf9b12e3409eac95e913b53c2f64103cb56a760e639e35fd4af1e68d3f8e5db3eef47ce95819dfa2ba30462823189657af2da7ad64556321efef327f4cba6a7810ce4f9d01aff50cb80f0e2ad259ef7759c03ebd65f3d2f76f0fe8ed47bf4e543c61851203e849ef30e5109af60741c652cc72d6547abf5d5c4b4accc2cb9c90f85f648287ab71990bc37dd2a470876af9e4deb28c4ef87e1cf448f1616e3cfaa88a0f236b7515abc2f8b26043ae994a9f38e61e5b3d8801ef4ed0b211b1fd5d3a136403b9a15b366f39151f6ebc030f1a92b1bee24bb03d669c61e1545bfd716d2e86feabb4df235ea4d878298df4d4254e9121bf5a46d20157393b94c527d1fc0ab1b677de71bf5f4f686a1fcfd0497c515e70ad8938e9742badb8ea9f696185923982de5e86eab9eff67d24d5bff1ce62e312559c03a6700a4a253023821136bd6009e63a55d0e1febc844cd0a61f629d756624e55c4e19886ccd79d0fda812ddbddd078b5081bb37b080c814a46e9a3e918f96b30bc333b08980a7eeb9164f420d21024b2677424037fbaca9302984fd09ff8ccfde4485c00d7385cdd9ec69e2afe046d98e4c90616803b973dd82c940bb2462c37a45633d785ba7898a1b7bd08a2623036bd8cc6ceec45e59357110f9cb16106aeb5dd3236b12f80c65cca5c83160a46bf4a94e651144d7bae135c9c8568cf006c664cd2bae4d5e00729d0d35bc80963d2ca957546b44072a1bddb646509b35fc24f9c8dd3b58d364d403eac13bd933cdbff97c112c93845fcb58c9272a3db240051699adb4ec2dd77f98f8d80887fd71f8094972e1bbe381c982af622dcb118b018a4851fcaa9080e73e5e7b64de4e963a4e1630e4d4a10ca265b439e1ca523bbb26af6c42209f7c5776486c39d9c57dbb6c2964f4f99eede99a0150d9bec92c9ea12116fe0b8b9b9288a8dc1f004eac6898b9b102203a7fbdf2086c7dbaab4a36f0fe7b443d0a33aa92f4b4dc590f1bdbbcc26c73993a0646679c6192f0a473c7391c99274e38e4afb3a49008071810ed872a67b6f1c6073f70253de3617da986d384372f104805804b2f6cee76667628baa352c6eba18cf259aa8e6ce2f63b382c7f7885892bf012215fee460cb78c580890c721c10cdcc204b7eab2a4f772fafc3d4731c83a7c59a5e6f408ecf2652a90fee860280f343ce5ab1629c6c42e1131a9808c295966a5bda870530af16a67880ae0f24df62c79593694912c4436423545fe06d089fcd47b305ce07fcbf177d38c1e4041b9004fabfec5d4f7e39fb6ad549fc30291d29d35cb641a49a2ef3e3c4df36188b09a370d2539c006fec39f56bd969eab27f7761c1c95aa3a09a75332ce69fb7f35dd501ea1e900a6b3a16111432a28481f7c8924aeff48d55c55360b962c387f10bd34169fad3f382aeb235375d277eefae00ca2b6592204b10d8fa97030b84657a8b1e6951f5476c8e68fedddd4acb97067b98fc3fffb1de1bc95c0dc2c5d5a8774226a18bfe264adecd71a7e50f0af92d1ba190e7a0b93935a7d7bea6b4de522e98f0ab089c2217e60f1e3ccd0dc3a3c4ae387c01a0de91d1694cca3d191458d881784c816da8070f9306a390e605f3b338772e6636e06eb4f31de1a899d05a6326e5a469047ed148a6fdf02da950b9fb165a6e10ad01351816c036c00fd5f75ad56fa3337fc777564704f4195ed0eb2fb5fe79d16e0dee73d3a99458739a2a978da26f0f0034e26c5aa6d190b6d2acf3e3277277bf82d334d551f37eef5b98a14f1a77a7454ea0649baf42ac575f9d66d9bb4e239a253bae558317e1c9b5faee0b2c547de69fd0b609bfe1f3dd5560028a61586de0598e838da798a30244fc3f4f0bfe476cf44aab41304902903de7fa328c988542c7adcf266686e6f6ff921d8996cbc5dc549db65dac3a829326a54705e5a88fb9138615c3d739947f4310524bcf49c2b37571c4afebd6bf51ea51535e121062f150c0427c4f331961ed9e0918a72525106d6a9fc85ace9c174e612366ea76e0892ab5e0bb86ae701d9246cc3485011ce2efd30f16460d8fd7fb52b55a900268eb9bdcd51f2599a33ebc67b2ea8032f957f853cbf10325861e905d7c8b370a08ddfed4140bd282bbebef5d7cbe545224e4cdc21128c96e514260352157b24ae338f781d7a469b2081cd3acd48f9682b6808c3653182f25b521f3d656501d271b5bc2adbe2c1b928768a95a17c85d2c94df93eb04fec20da2fb4d48ec756a584053899caa5167bfd1355a30e72409a8fa0df76ab86ddad33e4ccd33ef25eabe5fd9b8640bd6a06e8ec34dd7fc0058c7ef02746091fc6b688eebf54b953c105a600ac24161040cf48aa85ea80f35ed1e287980d76f0ca5a90f7ee3140569088ec451e1aca8644519900a9a9644d1e915f4ad3f29e1b0aa75d673c68f5b727bee4207c5cc2448aacf799e47edd71bad8d00aea9ac28b067e764fe16ed93308a8959951f2dd53925f992c9b6a737c6ce4479e33f594bc7dac124fb3a6adf6e4612e57765e1e0b204c5c804d845c2efe27f5fbadfcdd4819de8b4b7dc1a2fd9709f69130f3ebf16ef2f7785921b806f7a6317493e62747aed15c394bfbc408d30dc007fc1d8d289b546f959e20b5fa5c08fd50bc921a036d90eb103e0812e112711d69de0424d6a548301e53b48e2d313cdfa81a40f07a6433325fe165f97b710223d247858f150a0774c36d3f7ed7165abea4f7d0ff9c1e261006ea7923be25374c646ef456d91847afaf20c7ccf265141183e8cedc28688dd1b7d66d03a55547d34c538eecb35754141238eb6fa6fde0f2af570b30726e85c2fd795ea8338633a5659b9c9696a7ef9389a1a6da591253817d6c78e22f920da93961c104bbab300c050c290c9e5080a7139910a5a608ec8994175b9a6600d6a49df6d5c7ade2586818ea40ee9670d292f560479407053308714850d9c0df7a82c023d056623a5e5de96c833f11b2a93534e16336db24c092856bb9be77e01cbfd7929264434f223b9480363435b78545cd324b13c0d10e26747a87bcbcdd0bac55c345b07ea59c460b19df635222fbdf868b4a76b02ec0ebd75080885f888669dc53adb98307a1a1fec582655201f969b15d4f54ecd564ef22a32b48fde3bdf1d00ba4c91358f0a3392d69083ef6652ab0d2119b30b6aad1c5b3b69bae0fd8d97ef648f7696c9b45e91a8dafd09d1e138b9aca8ea058e54faa136ea039e27ae097c25769db352fc837ed53d6e072e669709f2448e3326ab5b7ae874bee6889568c175e82f558bd865eb45f7908a42df835b2371e3d9cc1b576d27dfd94cd5576da8619aa91d3b5d76b05b973c905336fc95a7637bed5b882425ed5d8f1beebc3a241ddf2db661eace5f130627a5353b93195a26d953c3abb041ec2e16f99ae1a4a04fffcaf8f89d2bd30f4828ecbafbdf994e1629ca538683b1ecf002c745e7e0a5fbe3fd441dfaa0fbe58319ffba0dedc069fa7fcf9219df844afcc351fe2b96a670a5e80b1175f031b95edcb9ec19309bd351f94b1a6348d51ee5b358614ffb3a8d3cec0ca9e969d3b33f351624d3f0b24b939d9224f380b0fec3b04e5a6781c8f4c3d62a4544e98ebdf2936694e7da0345babd46c2ae195cd7ed2cc4fc836b7bb7beeeb198a5b9e1554df56e6eed154b14106d873cf8c2c495fdc5549fbf37417e4a96c13c2a41690dfb2091e38e6667101ee216d3143751e8558d3cb2f989bbdf09f927300d058aef1cdd6fc1dcf273f86fbc36c6ffdb8ae82ee8cc85951f73880e0ffbc6285478ec19d4dd13fd78141ed9c53d90d869f8e16bf1dced7e85c4a17859546579edb36c08cdb5c3628107556d2c6558dd638993dacf0eb9b603c0bd029d1323a9793e57f19357b371efdc5cc9676c4d29b637e4a151cc1b856fd51a13e84f748a3f42aa7c89387ed26942ce0af899334ffd96b41d29ff77cf486f7415801b8580775dcda214dd5de19054336a87769ab81295db168c7317551ddcdbb3ae2ce54ae10c9940202316427aceb0c9cce087a578c3e69e9b9a73758e00d8df7a86cab931d5a5a5e95e4404fc373424f3a06a7de3ee911e19641795ce63ab070d831ed1d6d296236da32ccd06575ae46ad9bc2734df4db688bf9ffc7a4b23f9d4a07de8bbe1d3a7a29511bc888580f75e9c433ed0148e4b8e2a6473c7f18d2369c1cef0bf31738cb9d34ac664ea6eb9b975fec7e015a3f3ee936fc3f833b025d4340a5d0f1b68dfbb37d30868fda19820adadeb1a5fa6f84c218bd8d14b145de65cb7975f87e80c2ec2c6f5232812b85c9e25d1be83954a4727476da17083a7c8d58d8e235449058660b2e6be6dc61a4e908039a317ddb8206165788adc7919096e58c312d600de3233768a95d6fe2635651b84d91040b4ba115e37a1794c197159bffd11f3ebf2a2d5be03dbbbd5c3982190fbdc38465b5a40be3ca0610d4eaabf6e1b247dd5536bec39202a9c1e6831b67954350e1244530f324ff11ff3f020dc7aed50b7b047f7db32ca9fbbd15e7eb54732a0ef46ddb62b600d365766d04d72fb128eb03ebff34ad177cd99e975bb9de713c3e1fcc859409165637d917940975e9a10e1a57d89e78f2cf86b72bae854bdba1ceac1f6e77d2877c28a0096df144400ccb554cea1fbfbdf418850e258afbe42bdda3adb63af69b48da379bcae34590feb807b02fbe31d3ed7aec06ce4c2281205312281bb1474cb16debc2cfd71d8219af463909d9ff6cc1d91c11e67f320f7a022ed7216689141f9e7c818fbc12fa8fbf1b58af542e7a95eaee333c63f08f249eb0d69296f62b8cb386ebec9755ffd8801bb45e6e1567a2b39dafd4e3b0614edf63a5ea63d951e85923028f811ccdc97d2184696f590aaa5c228768597084a668252c0a69be7563be4699d2e41c33666cc4771e2ea6dcb6caaa0f0d2fd40947cb7949a3a80654083a13ab5493cce2da8b7856efcd3270885770ba7cba5260709d64975c10e72bb177250269dc4f85b4bac674899e036f086419d66870cd93abfad6448f166dd3f4bdee378f3ec0d6f0b011710b845c72a7af373d92faa64da33574a1050a5336abbb20ed3c57816d628cb9e210fcedfa24cdf179f604820215cdc3faaa4d4c4fb2db2999f7a638f8742e3f7c385b2681588a614bf02a57dd83c0f30e143412a4f75415e15f1fbb7a148cf97e46d16f794200fbf3c2a73ed12b787a892e9661b8ec9bbf57fabbf54537c41fb414ea7526d515908b9ae57bad2762f98c771ff6066a2b9fac0e928bff55ce5288edfbdaaff7ed44dcc4e98ed1389ebd4010637d2f568f1ffb11aa8692a16f273c1550e606bbd44cd58052086ea7eb2613567dc95dbbb86e768d6230e0f947f160a2cb25b0e447e7b444545a5843cdc41afdda8c99bcd1cf0e318a98a666cc77b9f5bd42158a934807c4f19733fddad421322ff969f58660403220abffc039d53f03e57efd60a7863dd4a69fe792a12ccb79205a2b5cb6015a2bca20c1a4bfdc7528aa8b7717c316791404931cc1ea584ffb672203ba74ed99c04dadcb58cd95424048d613478b0ebae553ff1a971ab189a0c83f138e3362e512787ab9d91cd1db5a800803caee3c332942dca695c53f48001390e637ef3e872eb51f5b241ed59c9643b83486ea3d0f0eba0a889da51948d090d0a035e2c5aea4c2cc99ccc4814b6abfb98ebc3aad9a0a29821d184260c35d577d119ed52ed1c39b966902fab518194233a4f395faeb8f8ade9e64036b8050f5ce98996397f4ae227310e472a39485f78914fe694e47fb5d4b8ea6dbb27372ae370a8bbc10a4f9b3f18f509636acc5904c537c2d2122faed9722b3a95b0b3d409171e265a9419ba30e65bc2d8fdccd3c185a728891ee6a6c5681f907405c885e60a47d809c2203185d067b575c8b5627ffb3fd3295f31e16f7c6d6df5f90c59e9a2a46697449676a26d258ec5f25f4395730dbef64c6512d555b688ba742b85c26e35bac6086b18133f55774cad7322cc3c085042af32e83b29dc5aee8d556ac8a6c21ac844a0d2f08f01885c2b9d5a398eb77160501ca1d8ab821f707f2ce2e9bde8797339c53ed540c83f723aab26a0d84d14a32826fa216aab8476e8a3796284b87b7e6917cf4f9b0b5e9bef17c54bc7c481e931734585c78415be918d99ed398fab2d5dc2df47726c850dd417165e2188592422e625559dbb6482c8ba1b802d73f85eacbe58722d68fea8599c7590a6f24bd94c231b387024e92b8833720eb2e1b4804c1442cabfdfa236f3199418b8f816111cae2afa66ca035f94eba50b227a2cac81aa21dc313fcb7185793436089cb583915d6f5ebd38bb5b844cd5c819ff47b500af84cfc97e89a6550744160a0a81b2326d380bfe54f1f94b833fc0138e605ea1e258622f7b3219c354a154763d19ce168c150190383666b3b15a057aeea36eb9dfdcfc6cf547eb0fdddc6dbd42be4e1fffb717fbcb8072c0f77cdecfbb8d4f4c589ed97c17086cd982363c86f1a810ef0dd2c66c70e6bb3f5d9dd53b3af1af5b48b1cdd7f48291fe8b2b9ef8873f8372f14dd6f8b3d6d1b7b622b3f869f9935506ca5d1abcf188a441ba853be895c1f7af39563d8a8cac55aabfbdc90e43152ff4dd0667e4f5d51fb2390416cccd4604ab5ecb984535ed7a618da7317bc2e8f11c6c6ca03e68ec262bd035fe8a7dd211ace389a3389e9d595adba7647394dbaf4fb065818304bcc1758ffd7ab7fc9aa630a0fda11a05aa347f0ddf28d8198bb6b6d39cee1967174fb3a74826221f9c3b1509ec0fbc1efcb25ce9cb7417e16312de2cf6c89f893ae8292db8e14cd6187f6894067d4ff62be39600248cd6b39a7d294fbd3e2484d27ba38fc33bafe1c30f990c406c3883bf361cc4f63948b5319d04c4edfe6c72e4d2839493914ef7ec0db44f427225aa6313255c8ff1c44c1962414cb30554de8886a4da6febbfa02b3d543d907ae0287ac446e83a504a7b274c9ee55a74e416d8bf4fbc39f4bb398299bc162d5d55067ef276c817fae48a884634939c78627b4fcd44c8e78f4fafa3623bd0c1f433d3817adde9870d737969be55cef18e1fe40ddb741dfc0e4435d5ca00717967488d660c9024a50f80470347a76a5d76356a70cdeb5c2f394c4f85282511122df80d574f6596b6f2e99c923d1c7a39d89b59a1bd18d42da18ef0b8710ea618d7dc59981716646cdaaa23c4a337edf595073035b6c6f3af583f220b57c449dc54fbb06af0507e283a7a13e3f806d6a95d547dfe1d5c9db2a76df097bc339d14ed54fdeb4fd4e0cd0b471bb35447c1fc21fa869bf64ff050a4f5d72fe7b4d0b3508fd490a90e050ebdad3ec40bb1eea215099143787484ce7593e251416e6c7e65ecbed86efacdd9c13625445c07d4e0e4deed31496fdf88870ae3a12546ab16e543a2d427440f6458a20033a5f9cfec744495ee1d19ee618ee8660f1ad316806ffa5843dd7f198c41a1fbcee22e20363e0bce3c884571c7b97a5fee9123a4fa403b1588400ea8d7e7f7b6d289d27a0e7ee9e6fa4bcaea6e280c491fe93a921f454e400996e2304ed8c569643d0a323ca2a6551b4567482b0e14bf39951290b5829026f78fb02aed68d2054b64b9cdd122b78163a97307663671a57d90b8ad032964621c0aa8c46c1c8e9ef1193bd573b80068e3db0aa3da077fb200cbb95bacc910acc0b814e925c61b6a472eaad09b49b9f185fe4afdcc18ffafb4479d45f72890539309b6421f670c552449793e89b5a7cb3ac5100ad72d70f2a1b31b2caeb2937520d46a227370abcdf2aed87550169637689551344c0b7266ed8bad9c59545cb05e610c1a09df3b829dab803e83b3466b04cd845cd55c3cd4d00d8116507ac24083019272f8597ee99fc867fd0a3681b9960489d9d97c368e7d63096bc2f7d96e84cdba64d527d02b2b704a90f4501a8e4c2e04f58fcb08edd828c1d3934d326fee3912641343a44d02ca2fd7385748334fc8b98f2fbab279780b5eb2df4e0d8eb0f86e994d6cf1360c782a395f9b9b26f2a4495aa06f284308dd6d8d3408534ac3bafc734874c7d7f7101a21fe76408d47073752c04853af5117076e5c084bb9f62c1f6c259dd9eaef20a6b492d4d71ce3efc91616bddf7b2e6018703a417a797bad7867f0618b64b45f8667c0f41b9de676b20890951c061fae467b8ded78bba2b671c4f26f56e874c348dc08e5df5ff1ff132b5208f33a46dfaa7d64bbfecd71fe9bfdb7c895701b6d334a5b30bbcfc2308ac8a1e86196f7f46690bb0c74b6bb2fa385b0538c16e5b1c1760fa5e73541b4add40bf85e510a3d28e026ac0de8631acb88eeeced6d3cd6e3f0da018650f5b37eb36afbe047d525447238909ee8ee11cd336f89b2c2264721a7581d71bc02ed9ff55205a4be91bdc2a93907c038b930614da299670ff15a09bfb9444bdd55436ce401eec6d7081d65d244d37ca73143cf8a86e912dfa2f4372567d9a1ef7ecadd2c8cbebedcca670701a3a863ce62c48134e5861713aa509d96c71930e7475567e814ff8c2a52439997aa01c4b0155513d52d5289a0c490f8d371a687e8be74bd3cc495cdf8a4686b4169c6a7122f6947c638793df00f63db854fd2962e405f9b0cc061679919837265f6d7f3ea19e1eb04f41649c203b543d5c0e17796f56ee81a8fce78b7d06398424bfd0cff164a037ae911fb1e5403561b89a868b2b5e55fc1cc50d37fd938355affc5aaec55d7afd833ad001adcd279c9358d42496087788e469765a5f41e57c0550b681f21d255404bc4a30a8861f0e1986315677bdd6fa706418279d03dd4fc1e7e87c79f03f8fd4c254c150c679b0c25afa06d85418efae1df9de746743898822f8ef3b94e0118a2fdfd6c70256920e0f4ff409840c116e0dea308056677f0ad68e1acf3821f4eac1019a9bf50082f1cf3e3f6aa61bb38a1bc37f8a4454e3423525e2b98e4dcada3abca1893af6261e2392f21b28d0ced31ba48652b967358d89431084c1779062abc424c36b71d1cbbf000df6ef36ce984672496a3b115e9bf3d6b7eab84618f355870244b0ba939417917a9e5285952ee0611b59da0408afad22e53177a066bc242e8e42e5e44a19a6a9474b2afd212bcc775a3cd8cf4db3bb21b984f314bf6df1d664bfc7dd9b1189d9d51853a0c7723777bb17c31a8e5e343093a0a3d78ba457cabffa9abbcadb677adb352314247d4eeed2fd7c99842d2635200da43ff4de35fa48acf1988554bb4086979984134d442a8d7e2e37fa87808585fbe5ebea24c7cedaccf6698cd7ff376ef8a103f4971d0f3e2af1c5f27b694b0e6b91490ffa5cdc77eaaea134db6cb935ccf64906a7e1f134afc42ba119caac17c22dcbd12938d3b79aaed831c81c9fcd453087eff843c4ff8f33746f0c354bd917d544535e78f10a3b409deacf62eb53b3eca7c13e403f5a6b4e0329093b0d878d096029298ba232eafb86744946020599e2fec440fa2c982e36481c6849aaec18635ef6cb71bdeb56ae4f5345679a3f2d03c740cf131b972971eff8690eabd9a38be41708cd131f63b0ebfebfeea956eea34f0a901decd8ed2c2766092a35c454834ec1879f4f8d37c31c30dad1ef64ca638b11f3d9229d2a6ce61cafd650543a729ac939d1117775e1acbb1f6dd0cb7c38c46a1c2712c09aa32beb55d43af4b5aaca4def6075579a6eedf99aa86aa34a7f73666cea843823bf08de577f28d5e10a029b24adb545268ed57cb8a763b7717210de26216cca9a79f612188e1de424aa8eabd7ebd405f1512723ad3455f3c51140cefb967a7288e7669559aceaffdcc9a99b39ff5259ef5af17e37af78d6014bc3c260fa984022cf86feeaef6cd3af60f5ef87f4686d27658eafe740a009096f4d226e5be63596a7867b869f400d562a7939ff38fc4b93c8d72d2f41fd8775c2556a3020b196819e510a13893575a78cee1aba23895c28dd5455c38aa6f9d29066f096788e79ac550c41049ad279ce68fa01c3e7f0d51f5cf5122df35700a20c97b6e21ec01b1b35933fb892e486cd39dd1bad1a15dfd336af68dafacf049f9aa4b73f98a4019cb8f27ccb9db5ec5783e98fbc746c36967d5ff5602cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
