<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38d6cf5a43dcde1c6e8300b09240ded2e650feb8484a71bcc026aa7887d6e64634679a267c8814dad97d156822db5ec8925c961521babc1bd94a451ae5132d3d7fc2c88c580ece4b2ffa2c19171132a4df5a0f4c1f6b4d00ac48583f89690ce689c788fe8832bc98438c16ba0e70d08990ea5a43b5fbcb42bbdeadabb0a4b0a1169234ac7f81000a40b0874980c4c9898a92008f0fff0b1cee5ab6bfa5726cbfc76d9305367e1e0171facef21e94384ccd2c32b145dcc3135a2d4dd365786e42d851e7b630ccb068438f2652b34c1c9455b3c3ec0f26976bfd4bc67d992f2cd146835d9d336a88a414a08964d48102fedc555681c46886496fb32f775bba8ece0583db2c8f17ef299b6dfbbb8df6749608f5829d6f0d9aa32226e22150097a7917e115555df838f32cc472368e2cce9c5f68ba87b1977e307a82a713f59b6016a3a539c95502a49d903b7d96a4432c699b487dd3981c866fd8dd48df06e2589694e71d42a264c666a5be421ba94c981fd9ef9c57e7d37cf0daa04545da167ba1eb748bc899a6288feb8476fbfdd9400aecb4a6ed0d0c1c65ca0de256f57905640ac98365da6c36a969215524ecb9ba6bc6ba0e9ab97d636c02f40c219442bc72fed93b47b6ea682cda4061685bb5355eb42a02773e66c99c726a8f1232c03d8332a2418b792c3786c0b7949e17b2d5aa2d107c2c2f7c2d859845276510337b4397528e10afd2f7672707a9412735436040622968e95a950c7abd8f80e3af0a7a4fcddf2b51c1bd5cb06cf3327440e38ddd3b684084c51a2b2c2df88c8c50b79553828aa544c045bde2bf9ea75a56a24c0c571da146845026fdd6586a6c0f61aeaea7f595da74a78f2640e5e9171067dfa1059ac7c4937017add2515643d4cb50adbb21e8cc2c4670fb2c481ab313df4b68b43694ce6774d497ba25134b4e0e348f2ecbc9d1829e5a73740b004d51ff0e57f2ab37b0e38f10cf081cf31d86b76d4eebc1f7eebeb9c32386bbe692bd2a9ef2c42e9cff14db5e05d0ea38d41b288d302a7fb76efe77e2e7e971f0b285bb199da2f967e989d00befa8fd375a25a4ffcf8ca0319d5b78a10f37724190a89c943763877f77b0785c996fbe8ba0670cb572618fbab3867e244a6ed4a6aba331ff716251d8c5e4bc61561d61e8b4d45e2f83a9ce64acbd7ecc38f93c94ebb61a44c801a51ae29c56168c29309a27043af1538a8ebbd07e70675106f0273f635fdc1283e7d8950b35543fa3791e356cd456b5079d89414237dfcf8ec288167f960943db337257d81c3acabe2a816cf173bb032fc6f7204305ff68d34a87ab8576e988e21e23c54123fde4fe869043ad97e1618c680195e5178287fe9c730a1cec77b3501e5bae68754a54fb0d24fce1ba0936d759a03bf7d554c2cb7e4ba916fc1acf8828de122d30ed6cb808e440a742f13dc8dfa440d1cb1109e6546447444c4f6641898b4d65f252d891d715e909d2b79e1a15c04a971a652ae8e6113b5f039db6323298b3a393572708da89160bd5c9ff2f7addfd86d0c513d1cbc226c62a8f095f76a219c2bdc9c53a9b114f293f4b13522d1fec89029643937dfe55400bdfa837b47770a07ff90a805b0940b59f08e969026af054090104a36aece653742664e9db6ecf1a7dc49a55df5105fa39116721a1d68214d36ce54e5e6293e12b66b01270d8283feac5343e2a6b9ea990bd3b537ae71bef59c4bea1b8ba6bb2380ef1e01f9b6dec46b80b070f733890972342906d311099bb160e24155f7331bb2f8fac009834010da2ea4c91c72ecfae0f1006d438272a7f34f8da14fc193dd4045fb6793114ae33453c8521876995f569fe7a9e53c397f005a8597e62187334723b870cd56760477f37079130098d3252c83edfc89c1cf2991004a6fe9a9efb8b457d91f9b8d9abe7e0625f44ea383532eb338767e20ebdf75a486aa7acd9f4953e871472477c079425d8851130bd509b0eef0194c02f15f69cfd3221090240fd20ea3a13171036b4a062f05e1de2c489abf8d06482a51aade5793a0571aaf6bba8fe84e87197b5733963bd629b3df2432501764b41332f9b682b1b2d60ecfbe516135cbd927cfd78dd0f75d815407466b25664409d7de266f6b783b5c590064ef55bab387776e46fa441e2e557349c10c1c890b0354c842b321f9ebf924b5f7d260d97c1ff7f1d77cf45dd7b471d94adb050a828e083a697dddd26c68c2593787ddaf018ba4c7c2306c84410142acafb22e704698629cc7f0fb4f56ff13348b8d4d0f8db8c57f09ee2da51cc20b319330338ba9e45ee1476b0c9ad742f20960a84a692a809d5a3d047b9e008aa871ef976d349b4b643e59cabfa610f6b74238ad6140d978e5b944cfd966fde587637a8d9f73403a116b259400620371750ca38304e4326e2ba171f5e9f5d08fd61dba77d3431a92d2d40f9a626c7ef09da3c5a4265638a5e2cd62c70b434a3f614d9c4ae5469ed1d173e679d11ef4e56eb31c84b756f007cfacc5d35dc1a615e490d142b25835dda1feed73f611700127d573f08b973ca3f33b6540af186286396fba68f71284832f7d1303facec0eb6bc80b456462cafb28e0ac79495d4b77fb5bcec8c78bd9d0158db058ef61eed2443bdd46333f3200105c4cb139504045049cb468c25d4d4baea4fd3ba61ad97397f6bab16d03f6cdbeda3e8dee23a58f0219bfdd10d76cc7f82fcc9f7ad091fa85c6554ffbdbaa9859c6121e9f53a2defbf30a962eb73a707711877a31f7a178ab7deab396f75c3eb86ef235d977d0f396a8105d13bb5477cbeb41349d1b3b6f854bbed7169ccf2be4898e18be23293b89cf914d21bb4da1b60b4dc7b82e6bbb9475445bf60267304a54995561352c79226f736244ce62c9e783cc3f3ea2bab8090f1a3ae40f997d6ebc8f34310deefd48b022647b63f3cd1f5683cc5b037e9bd8e27f7a61516a4b8e766328fcc0157e0ad3e1fee15d12a0793b06bfa861325836d924fcfd463766155a6d88dcca75a0ab1518229806a7e0b439dbc14f250c1af3d8b0607d5da117d55cd27312bcbbd25e789606b2ef8840b5c29765c1a926e6914b71b997def0f0e75b5be19bc4029159cb198e80ac98dd8abda7618e23bb8d08b37a0801da9f0f7b640a8128798554f8a02718f2833f86b8e14b81166857d9dfad9397498fc89d3da9ce336d06c0ac46d79aa1c8e326ca84839db39068a92b4c725f00cee45004bb309033235e5716c25fdbd6d84392446625b6a54ff66d479fddadc169ce3824f0c67de97be7676b76a55abbd30113083a3264bd6af8af05d002a4b7f347b1af9db691f3c0e553d28add12ed2ee458512df56180df315d16fef6b61e1b047c9b54307ea2488b8a71690753907fac1239b6f4125dc930a5024447929ab7c937e35aa6e86ca11022c99ec3600e9198ea566c4b1e66499f109480660dfe68852dcca9dd027a9d4fecce2bee4f50fbc027700d7f6029c309d76227928d8befd0d9236e5ffb0aed58f4d50aaf58c8c2f8707457ec3dbf74b2b8992bd0f1855e9d5a1b4cb533ec533294c4cb375b56254043126a9f16c7c897cc7e17676ae0c29166c122604d23fd745e6a4c36c8d98774d98640d45b8c3be3db5724af4c52b866f27ee55a6c4793d85903d4e208f66d557aa382924459d6935577d113a0070600bb95629713061007eeb31f923c822970acda93509e4e007131afe88c9083b6a51955d306a043859da9aa6fc1207de19c5251c6686050d200bacc60075967e336ca437974839937c9acef44990060086bc61248715a3d8a6de60d06be3dc01197fc615f5ad3116f737bb1793305dc7d54ab93a68dd467ebdb9a148d98a16e2ffc785a2bf93b5f2724716bfcf5d52829ed4cfc31dcd6876cfb2b339e30c60b2b038b8a617bec3c2a885a23fb3bb98f57987355a689a709805a539cb7f8d6327af389b6e5f081624b6e93355d30a1cd24ce63cec097527ad48e7900b093e8dd90655beb9ce6ba2dc066dd6855e2f75d9c96d19a59c2dd3bada6c4622a9086d336763528a9a7e7d9507be668a782ab578ce8ed83357d4fe263a093c82c1ec97d14463c4abc1c6c14bda5b055c47a49ce7f4d8717997bcf2d3cabf4f14c4c9a664c1cd15a034dbb27dfdf662322e88750f4d07ef95778a484d48c23faa1c376982880acb52507928b825894fb1d23060f32308f2cac29fed132fe17389c79cea645181cf55a0dff0c906b8d86d881070737fe0a98616a5f9cc4f2eadf3420851fe69fc6ed40c7d2916af957d03f0ee096c25d5d5da2603bbf23290ec966138f0baaa12b0c91c937797e174ceeff81f8a83af74adeb127466ad9c75eab70ad3e60a1903ef49a62c785f43cdebcb186e22508953ca8a88c12654efdf3b4c7798057ca05b22118c366ee738e2b791ff06bf175fe047ce0a88ac4b3eb8f382188530eee6c2ba7fea15366f721c549894775ecc67e8feb4b20bdca4d8ba5573d49868e40f36ffa881a6bea40dc99b5c99ce528989ee314ebad9b9405335bd909f48f9ebbb94204597e084454dd7f2c3b771b1aa887264d17cff64390cc79a0d34bad84d191869d6096440992cbd7271e32ba31d1a3715fa2d760896e47370c37f8bae21b248e762094cdbf5a9d072ffde8042e10bfc0b10e6f8383afe1eea7ec004522c53287544a7829e5552c1b0bf01bac1c9553505dd106232230af0e15e46d1da4f02354060316a2011d5a45cee55dae302a7a0d3f7185ea284eb9f15b17a5d45910e1629173f4ef5e93623fc065d6833df00b0b3bec0c5d598060e2884ea26f297467eeb7dd19a23f2769236a5df3c7d3fc6eada57b34ad6d0024af0e6b1a7dde4c10ff29253aa86ce407bfed89e39ce682a5bc9a7f9e2634fea1e8653ee7989c1a1ffae66f8e73b879212d2a1790cac06284e87488242329e2eda99d04b1eed05bae4fbb8e3c21bfbda09e4c1fd98a36e671a1f032dafd87b934d65310687723a9e4e9f5369b0c71a9783c4ab3dfad61979ed8da9a49357cb2088017911ce78f3d26d8c2085173c476ee70b31747d9725037ebcda0bf115c6cefd1258f2048deb6213b79c8b7517a30e71ed12d9e2816d3717275ae4c367f63239cd1d0865a302f8d204ddf6bce0c2b10c095c19648d5496358693ce95324784af4f8c9e09fb053fdb7b4abe34d44814dc52b9588f2a2b481a8583566520cd345b9773ae24ca45a450e8536cfb6ead6cc300b7e893ffef8cfa0923a2472cea0033f206cc2b3ea10bb248f9e287b77a9b4a84c5a53ecc7fe65c053e9db5c513d324e458fdea36996603ba28c4ad3aead18bd2d0944e90a059ca794d16f2911732e05c02254b1e0a18a021687e0a737fbde48d46b098e55dfa950fd55c81f8439fc217a16c292abb3b10376bf7cd69224cf33252125ca9c60028755f5ca2e10625de9992f1c646925721ff225f3ac68ef25f13dcc6005e56740a5b5138c7494f3d2aa8293cddc8af4484723f85b5912e35079eb2539619348e0f1474e05c0d6e7f19e3f0cce96c31a2755e14ebd90190379924c256341216e23cc14c773f74bc05c02b779b3dc2b7557f1570408e06f4330252ea8de61006782bfe6a1aaabd7496c73b18f98afabc8f446c69a2e113fd8b040ad7c556c7c6357d0fbe62dde7400e1a7dc04c403394a4c37ebee44db08c354beb9c4d6b00b236314c63b0aee9a61a56faa7fd5c643ab75d0b90208f61c8227a4fa484b0025697e0a5adea3f9b5003d4a7142b8898701db7c7eff11821fb5ef7177dd9cf8315f972e206c3951b810d8800117c5c9b10f8909810014fe9683721210fedbdc0020e38a4d2d894395b4e018d423f39a0aa4563dec9c2c8920c16667b4debed19d0f179d642d5c1f165fc4f12210a1d09a561971efc1cf50e92f05f5708b67b5617753a6e1daaa8bc068b5d04dbf4f39b885c2928e15e39eecb80fcd8d9e4bc3af9f2b6dfe0b31f0748c049f6dadce6bb931ab458289d3124adff7f8ec4ff7f0472f9e190729f32f227053091e519858f2d89e6e64d648cbeecd43e6874a3c0d25998b069514b7276c57bfba2b9bdf142421d11d1f0b57303ccd738f49c8ae171e19551c029e58f5dee7690c2933a6724b7c7b64a3fa7114c6f996c01f1040129ce405d515dcb846d92aee3f8e311814b386d69c77ecfe3de547e92414bd8152f616df5b30e2c6d70ec86c6092cd40a459e6c5b226f1c8f6169c483ec9fa5cbe7b106b8f000bb370fa39d094a1ac6d2800e9beed2bc59a90de787fe42c76b682a4cf54ea7f2eaf8bd368a8416b136a2b8ed638430e8b68dc50f0e9c6c9eec7d910edf357670b9d417131f46d75c4194d190f3c433c9e5db8475577bf41081106eb7407bd7e7954120e31a545cbf99e29838b5a40705ba4784e0f083d2cbc91698f1ed2bc43748ae3a6b9740b510cd72b3b93a19ccb12964f9df8e947c8cd00308a95be2d518e1aa537fecb349362188973ac63f3c53b3a06b93e76dfa2323ba0d5c5c0f80be08304b8c08c6160f6c7ceaf50179c7a6f95db2cb239c6529ed77811dd8d2d4713c006ced2c39907062005f28b4ed3f2eba6ca068552192f69c3635e280e64b2df3816f6e3f5748dcbb96d1e582e2a24c8e6cb4a30662cab09dee451ecee115c62e0cefec0cf37e708bad3e37ed88bfeb014ce3d49e196bd1227a5d45b19d8548fd7c3cbbe9fe0a000fb41cd211a31df654ae5379c369624879bea265182cd5eca82db556e887ec5da1035dcd020ae919f95d59a86962473409f7ae997238f6965f9d921de3e2d5c173b42c5829fac1024723fb073699fb1c4fc36d56d911cc8f16edf2e80b6862f7a62a16cead5e9740ccc2bc35ea3b7c83b80283720ee032995fd378419b013e536752b4c701f524e4901815ba3216be086169b15bdf7d3c6e90a3a37f58ae2f3cc82e1b59b82d450fd9def44c85c27b5f9454d62690495806a7073adb008b7ccecf5e30413c536da30e0b632b457fb0d295c4e25e8ab3ad479b78db5a370f54a0d3dea323fed1b4fd2465d94d5c668cbda40f83f0e324667df4442b4dd48c720664a8da7c9c7db83fd09da3001bb245f93bb19e8d14a97a27ee2b4b44d966e4d88bcce919b1cd628652061c8bc843460484168e7a027c655e804abf88f9b3dac49bd8669dc51eeaac3d9fd2aa4cd3370ae8997a94697754397bbf83fce128bd3729536150e2efd426de2f819fe252d2c46d55a45255816fd9ee5480c1cb0deeda6b0312fb3711ae4b300f2164e768206a76fa526e700e3d598fdca19fcc2ffc780f9fac59a5fa60cba4f3cb2ad3820ba5d3558d7d0e36e478d1c9a436d824c1c46bd06897a7b090f80121860b140724d5f15407f4c39e5fb8cc59daad070ead05bb9173b7be35d4e18628e09123b91685bffd2ca9f017d99fed69d0277b20edce85c81198645290795046387843bb7a983ec6176ad781ba2c05760a2fc8be348ca839b8dd8ae0b73dde58fd9fa12cf7df8a1413bc2ad892d3b0842e973527279e9838aba1f30f1da514d773dfbdeeb222ae7d25dcfc125954dc32c5295f4109697d9249f39cfa9b6879972448a3e8fde2768dd824f1f37cbf3c605ec4cff73bcd478b6eb0b3806652567e827064046fb47884c53f87ccdac730577b6281a0381cabca25c093030bb3f7505dba90a8b40ea5ce77d724366d6ddda261c88a00db526c5c49c23aac8170385ddba808888001fb1dd1d93d8822656de23fcf545bceb26b6a2271fd86d86705b0d8835622aacdab168e40648b711dc2021f5a707a57a310bef96bc5782209ad1b3ed9f07104a24313db7f768ff6436f951c6386fcabb9edde9ad4054b319de98ae3b41701e4b6fe711f4d7380e9fe051e196af2e1ef2614efadb650d1e98af391302e10cd8559c6d5d5594b15ba2ba812210fc5fca011ef34032c02e5b685bdd7893dd62a4b81407e2cb9dbdbca3fe104f9a01c3a10aad20f55584c402433291a107bb37232358812ab147b10d2c07fc1c679dd8de6975fd5db8e2530d7f1ad1ddf3875dbc143484fb2d280d41ed6f58bde0610b7ef2086d21654279cbff323bc971e71df044c387b07c314f9f14847f0f7e5649bc69c5765d006399d82fcd74c74cbe0435274a533fdfd87310e7371713e137a4bc1375060f9f41cd95b3439a603ae152243ed9f569c24321a18ba07a69f166d547e90b1d130ded28cd534d0471f8c36dfb115cc080c8d05457fad26e16eb827503fb27e2623f569d579b70871f1ac757bfba3818ec51812224c610745165874300c9297d5df77c4ee37b9289a7a9df1cee4ccbc5e88ee7c7d839d7378514d773e097e7801ceecb9259b0c631516f8d03476fea857a22478e6f91ad7a6b43e3d55338aeec202fcd04237193145ac923f9e42cffe1b01dce9d7e8fdd7f50cd76cbaf5cd7169df9cfd0ac2a762aa9935d1b3e0d86ba57d0290b0d17c629dcf64a38e4e2c75298f0e719bf6ad55807a8961da892e0bc0ee71d978213352c39ee5b45f24b1d6ce9ccc694b7923cae24259d5f7342f15dbddc5fa9ee7a6a3acba18ed392de2d8e6ff675a476b6da5c2f8acd7474fa52751334ee6805ff44150ee38e66583e25672cf36a926d1ba348d73736ef6e98766694cd6419d442435aa6b39269c96dfa4dc3079d761342a7efba1c4249706990c10317e6a2bbc364d634f36281c425f9173ca3a2b5344867dc92d4d8c3f2c40ad41b96adf52b9e0b38f050119627ece3afea2c13a30ed0152fc5f7c8af431ddcbcc199766013aa3d5486265a7068a471c11c84cb27c6b79accf644f519ece8c2763e501712f105d258cdd2f6e8581c5db76e3518024ab6fb6406530a3558d4b1966edf7d9334d6f062d68b4b15861f7807120a0a2de40573e271a25f82904b3d76e0541c6812b8a77493411ce098d4be24ec8a6e8a9c4dbb27a906d5ca2ede993b346046cdd831c778cd3ff3d26481702571ad86da62d7b144d0c4f57c7bb95e3e9b5234498bcbcd286e1b38a7c1995ab7ed750eacc026fdde33767a7d6fdbda6b8dcf0d5f2d598780a8df26ecb43ec428a94ae88e66ca1daeb9028e76e4f14eb5f2a09d74ef4acd70c8a0219a76d223ad624736a2bd86caaa6b128d945c9ec1b2e535ee683b5cf30e540a48eb39958dd00d0fad4e8beaa11ccddb408b2686ff35d7c44196b86d5d87f6a1e0112f301704c0ba4c4738079fd803a0b434539e8804712fd8133e4f775a6589a6c7b4aabd253e69bb9561df0d41a2f4cb0433afdb57051535874681f63209e4960c945a7742151ab97017d4f3da7cae2cc92135818c404318b1c2eb8079f8df92e4309e8084197ddf03f39bf063814f45ff44b53ead2c59156e84e9c296d2de0e5b4cfb0cc01b1af60d453c0d320a2b3abbef8dccc85af6ad0e7c12cfc79108a27f9226ae74a0f0e0d14b7e086dfcd691ffdd6c48a120d04949f5b5c4560c1a2b5fa5cc68a3a78ec415702ec4239ca5c547c680b10edbfe1430f319934062f80f8c469697d989493c4ef45b476056b83addd0f20b7818f77d39acc7f6aef7df4a8113e7a44c34e9d08576ab40f15e73761ed6edf343ad617ce995f1604978e88be2a7cfb41d6ce6c1ccfc23c7c1b3be08ca58d234445dbf5a7bb98d3133f3cc02bfe935c64e2deaeb2b075625d558418e5667972c3c2fa7ef2b9f50b06b80aa0baa8bce9cfab0870a47c5863fec900b27add1afa241bc14312a70ded58eea46f513446d1390348cf895fa3a5a6ea831daf2890547d4ca7ffb6494f361e803c7bb6997e1b4e9e8d82681b742f556b84ff96551338d98929ddc78e00847a818a5e0fd7322c3812d24a661a34938524a21cfe3d88f77daca835cf984b95e9880b945432cda78f699a22ab7edacb0b9945e941b0c64f99a4c9dbaecc23aaeb56a3355b35e60cc0684c790d7e17731fe1d96605cfe646e8c72ff5a3b00e179d3dc2642132d1b29493a91f71b02bf8df5642c5b62960b5ee8b58e156ec04fb477129de2fd7259b911cb9221d33a2b4d8cb48793eed8c9068c00bd9a113e64734c2dac11018710afd65b2258f2f97d464b201d186bac24ef0ef5f7aeba8cd9dc371b85f034abd4220d6ce91cc8f2ddb23cca20b03ef9ae58a268159bbcd1b7786aaf4684a9b04595acbf59bf8f5ac16ca683084c74ea9fed585530d314138d502e3e3cfd0a51e918701507fe71084f0e071a39464ea324da10e8a34fde1dec3c89b04d475f5030e3464a887b82df861af87a7eb9988cafb2bc096bd89ed0ea1889df7d295099715891802c44626b67fa3dd955c8f0f06350bd5899a1001ff60e602088983501e274186356608daa1cc64815351f5089a05988931239f209efd52155ca6b0a56c874dcfde753665ced187f2cd60c19d1af8314c78005ba41bd882264b1c93657e0b01868e321017296e89ecd1c37503958d904d9bd40e0ba16be890220acb5259ad44d9a67f11e6f471d1497cb5c30ad637b42bcee7a7fc9ab4365acdf4fabea930c468f1755343e5809160e42b580d9f3cc2c554b9ea37bf8499ad2cd1f3492be3829baec37d212f9e8360292741348d5944499ed738bfcf7d87af33a5bdcfd4be5b8cb7ddf985199c57cea2d7305a94e98c51b68946e00adeeedfc0d83e49dcb3260b6e7c3d6a36b20409a68c65e05d7696b8f36608649706e0dc48d102f68a5b07f9518388f494ac74b17709272d31d5accb4561114761d0ab09d771cd66150bda2f3beebc53d0d8057480369436a754ac97f2165030f341fa85ee3061af0ee8b5198406dd67ec5e27460d11210cfb4b0170c97132959972d28fc1d38087b7f054cd2a918670047f11b2a1dcab59aa3169aaa75db088660285585d02a83cb524047fc0fc5bde4173056e78672ff26d6a3f1fa7bba4e555c0eaf4dec86dccbfce5e0b7cd23c065efa2d0047cd6a16eba324f3a61b99d2e610b87768a92ea4d6cd9ab8a88630e7a7a7d8cd20501cafa8bafcefeb3f9c64f39080092984354ba55a7c9ba0e99c8afd786141c35f8492d853d7c1425e8366b52edb3cdba0ccdfac5afe164f7fa1b697d109d47486b68ae22c44addb349b51c1a5373ec975baeee631402d799481daf2721df39f805dc37fcec074562e74f8e1399d3b235bb46e1f20f00afef77e55caa53769b0ec1828c116d6c51196a0986c0eb3b0b38636c2b34018d31ed5bf35ce8f3140a22ab6cde3a8ab04fe2996ab39c0f6c00d26b66b85dee1bd4b54a6a428b272cca0777650ae255762b1434037606c15e446fecf9c56151368d7bab6e1f2cc32d1138026840ab6d9b1186ced87d1175614fbbad365600eb402baa407f6b8d861b91ff71a430a950669c501d6cd6f2372b888ebf7a47548c17aa891ab50d90a05d66104e66be703967b62163e47c5553290f684522da5a6973a6795f323ea76f332c8404179ae7dfe024b27006f6b3b7392ebb2040302d5b1d2b06c3a65c21ac59d620ff2002413fbab98d94081b9e65c4de60d8f398af76f5565ba3c8722860c444032a79b1a92527d1ce7c57a897c19f50eb803b97c62e9e23b5aac5e5e52d097dd894e2ded01fcf5b3c94b5f1f92ab1fb48bdd21410876e3b6a0cb90b454c7059dee87f3498e46c7e20c59bfb2a2a424b13e0a10000646958b0f6d9a87110418a158dca4d5f6ed06db2cb07861e9169019628489db6f7df232844b9b67d3956ebe01376d53aad9a1e175af0dd8680ee7599f3cce644e8a29f162dc786925f456d9d14e76c249489627278c9caeb00171201c578de87348fc899c80336399ce74e952cf99a0f4072cfb1db00292b14edcb32fa087039207e40950d97cfc711075bf2c0f5947edbfb3febbcf16e11d15f11112ef8f70c3dd334638ba308291be1a6d60817e58b075ce7f866103695868301f4e9bf484e577f7cb22b5f6a3a95bbb28865038b72dca665159cf7d90338d2537e82dd04deea09c753e9263bc2f3295f70b8c877685841b8f70ad9996dbb9e5c5de99176d295dbb167c823a94473f4f61637239e2b5b9457d495b925a12d6d1808cc58bebbabb3a69eb050745a38bb2bbe60f2f4973bf917e07e783a6c3814e235e6eae30343f992a44047aafd3f48e4504116f53334d254a8f86550cf0c64f01842b44f9ce2912d9a6400fb6e7df3b7e5741c873cd8ed341c96b245bb0efd7dfd1e0b8d52c7212c66d31eebe7b546638d53d427bb5f0ca79cee3bccefd04226c93ee40b3d9bda03afbb8fb39c91de0220a6398ee617512129e3fd0066dca898dd741f27766cbb876b817f173ef7f4b28c2ce4546ee4bc91fb590bcc9698d0466c111cc40b7b50b0c862a724f6c13d1391de6e28e133f830c6c873aa904a1f74fde383ea410165066cd0bc04ed17867063470d7eb097d95cf43715062d7bad698346b1865551bb5937fde547ceb49b35493b342ffee60cd26ab075b9f8b3d7258958344d5fb5bc0d238ab624d8b1803486b7ebd9f358d9b7587596c4abfa9a2f7af77107756f29567a80d4de1baaefd0036ac910bd8e3c3aff23aa0ce21eb0e7946b2d6e6ab1f09a523b42a46be55af07cb2098a47854eff08324f7bfe57e2147584b138f5d24455e53bbd47c56e7dfe36b6c40620879c28245852cce5a3f300f2f89213b7846c9a1c40f6f515050b4a297237b5077296b54a01928b2ff60d7f3315957db658ce3fbd204f1fcecae20a0e4753cde6441ed926db7d9a0c8d7e02c8c1fbc772db066ee3629e4aa1b0817fdc4843f65864cabfc334fc6879fac973e374538e98b7947870426b3e12a9c293f5072a5cb86f25c4371ef9988fe127e0c8c24ee0447f0722c61c62a6df9b7c6acdf11dc263620c2a7eeb2932a34a71085c6f3ddc9be3db28ee16ed1742a073f1e517d53542c02c4bd149828697a3bfcec234ea7c420fb5f5e1b8148ba062be73afab0d0a83c84f0441c315fea85ba4c78cbfe6060714b9375feb36202d48f2ca8839e5426b64089e1358689f4078a7e88d71768f0b3e8d7a78de1785c6607834545ea42e0ffacc7850a1211e2e9ad53fb5bfbc9eeabcc6c170484b59a8ba65e85c68b6fe2896ef4235957b6e81263f59f15d5e38c3ec5bea435a1e07fd646e2a5d36b3c1b7c7c52e435921e0ba377536142c247969c863bd298ce49b067c44cb2d808fc2df17daa043ba330a9e90f6fe34a4f0ef54c98793f75b5862140678a5868accb206c0b20fd404873e1de12a1491b775eb4e6b8b6e8e224312630fa71166d9ac48329c0b7de8bc97620f28244fbfd093dd9f3c491be3110e2e7f81acc020ef4ce24394a0cc158c9ae80f5e8e75200502d81ea648a13bf0bdeb2bdb26499d8bc877c89d484081a1cbe37885a5f313b22207d92908056a26e00c9309e0474fc9ac8b1ac99c9a73e16e628d5ed7d4454eb971826115134b3d9745f3164e35033a3262452ec94f4a1dbe203acb68a8dcfa3c0a16ca5d72e48eee11d505aa2c4c9284c89b70955e3079418b4d47e7951cec643daa12bcdb5fab491cf69191a2df815999d2ac0d5ff4143a19676e620f1948bad5c8e49f6f74d429fd8c5b888b0f1f65eed029e9ea2996fa7361f86af422298bb23f801ab2704717413a96ab8351ee84d39694d6df0502a28f15b988b7a43be1e02b8656cf0a4a8f7a22a43a9e4906ad4ada55ccd6f3ccb0e52f6c8000fc6446e9bb2734625a9b515b9c80cd56d81ab4f2953a8edcaef6a7b15b12e737dbca345f5b441a65e4cb07894960d8e5cafc3b5fe222334a2835eabb82c19156f9e71a132fb2e62ddf28da16773ffe431287b35bd11a916df54d00d12e52df5c67d7462e845157e9dbe5d4aa23ca6d61dc75c3cea2ac6d5ac94b2919527040e0b415939a85ebfb8b14c9ebfd395099860a5209626f6415c8410c04e745a05ee817786cc087b0a0c2879cba7b9b6ca9a9ba503785d93a7df0f73b2710c75434261504a746b91d11a881d8b7ee4555dc52a711193683f738138876c86e9aa78773b57bb37b3c1c8907c5ae618422ec5b3a89f13c839e18f345221eff983cac7869b2a17532e296f2eb4d446b4ce72e4baae056b38280bb6ac56245dccef4fec5a0b7bd00fa6792b3eab5a9b8f63f5a2a3550a8555696eb5d088661807b1a7ad3a8f5987f0d9c4a74292d8361aeef863f1d0ff5a4f3372d867a875605bfc33758a451457e6b4e2ca5ee2c4dc02d16a5a45a3a9ab5fc66ab30eb8da908524f1df44ffbe267ebb18f15d0eb36b204f1c1c7eac0971cd7eed2c9d729b9d74162d2d8ecb1a2e2a58bc7255045eb247a23727b1992f9db2d89c90eb3e67b1f2ea616e43d068c75cfdf0153967202754075cf12016584ad2fa25b502c73646f47d685181fde5995d15aa20a0dd74ef7d0a17ef7b2906cbdd6e24ac13f2f0d7ab3d574bee81899bfd9081bfc4f35e59cd41ee18751816deedbe0200877a3265afedbf3a09e8774d52616bd2464622bc31850f88aad616720b2218681bc7d921340ede0081209fabac2177f5113a9eefe07014134a82cf755e6e5b541475a80349665b9dd5fadb716e6366025c38667c84ba1345da838590b4bfbd0829444a25714308239dd467920c1d22d242b56ffc469198844692e73cef77176182eb864dc6ec592ee9e1f9c10cebb5675afca9bd83fef287a0764c0ae3632f7db3f89dcde7d935648a7b8eaffe4afbc3fc3708d4118cde8201268daa87f845ba0ca9019aec27219959925bc19d79d9908b2b95f3563ec28e731e9503ce8156ac236540f606edfa472e5f2c392654a4883daa505dca35831d92e1ca77a53d3f34e7f7469d17d70e440adf365d8452976d1710081428b835ba94c7a39902e4bac5501a7ffc7c61a9ddb2416cd8fc874a5836e372c114ab4a6bd99d914e0c33b5e1a91c36de6ca966b78fdacf7881f2f7575259deb10f04eedc6f819eb7be2eee3e7fe635ab7a23bb20912c6faa444bac0748690ac26d524b3176834df4203a3f57e7bbb0d1aa326d3604f57efb0da2cebc76bb96983b77b0e90ece92bfd35a8d60eddb47e05e8217f4e4e2aacef7c12b1da1a0ba5c9a477f57ef6e19ff20a292836ec9b47475a15986acf21831df0414664701463f71a57dda717052fd78234839117293658f720d364c4b8dcdb163375b7daa3f61f09b51ce74a6eeb085ddb8f1ef55d9dbc659a745e25de63ea60a3479eb83462bb48632273de2c2dd8c44fe648d3ed3a7262392c8f05161fa4328eb561c302abd6886390950bf819393c2c39b24350f48725550eadbc8686fd93b3a497666b6e316f43f325ba7db800eee6730b616dd8b70adaa917cae2486d482d65f904a5c0c070ccb69590bb169400a022e5b60189f56cd215b9f5652ac223044abf0fe36191f059abe643d32de3b723db2fe05a3c74217e9366cfc6694f778a58bbb5ba5aab3e199989c1ff2271e30d6c10e8306299cab8491f49e8af516ca27f0a66361d4d81ca5953ed9d59fe913dbfb07a10d31df7ee8bcd5fccde6369eb55b4e76a85985b2b1ff1f3366bee11e0a018e0b79a9d5565c2b3d8ddb03d415d4fe57b6da475395655e6eae71c872595f8f6bc9936fbfd360d2e339ffe8b543b78203fee07bdc3966f4128ff09b3c2ff3e117e9569ff1aa8569a7a1b5b344093b77ed3bb3f1a936d6b626fcb940078b0b02e89485078728a626c41f78983c24b4c15817d901c5fbdd32625064d0d8bb4f7a894b00bdd96f8a8c07e99261f1ab1530d114a14450b741b16ed83409887a4c616ae72f295583ffa17d2049a76c9971a4dc697871488bf2e62fbf5e070a7ca336b14ea72594828ac353ed6f3870616db45295b1df7ba6025837772cf0712616939533fec678c65940fa6c7a1dbbcd2b2e8c7035fc4c4d52d76e2c741c15ddd72354b1f07736f93ec760506d2c1cccd9ac5ed6816d76b1b20f18599661c260b66eefcb01cbc61589b98bc12a8f10c714d7608a23c5f67fd9bcd6cf77e0b75eae17104fb1554e2d2a77834ad23252fc99fdfe603961e95a3b970f8911336bb5e8a5e19f86bbc5726c23a3f9ccd5b9006f305a948acac81967c962d92116ea8f4c60b27c01db665043b33196adf8ec951832d3959476b26946dbe813e445b0167d787e7fb3c2dc1c4cad8c7e0a74ee98f3fab330597665dbe63a3b04546d1b7f1d7bfa9a54fa5489a453cb6751999885d0bf511f343ff3f55de4840bebe48c9893532a2882e6ec453df02be7a7ebce56aee87677a321ac1266b34908e51c788d907451bc602be765f1e018ed1d9840d53d8b8a0a5dde65c35ed85538beeca09a687ee24ea5016a9df546202a9706672323a126083e104a025a98224100b4d0be91db37d59b3e9a34c3121dc9f480334d27df9630f8a4f8b8abdf9b44643b0eafba90dbc20eb79a25e2b43311d5099b2a5b5e0ad71c0cd3b594f05bac4552c5af5726a17a4f0dd19fa3cea12651cd6d73f6c9549e44cb45f68f5d768784df28eb025dd40162a73e0c69a92874fac18b320ff5d5fa9977be592c613e463fb8c0e62fe12e6e2f41ab8c930419abb13f3ca2e1da42b6a82024bb7572fe569a7e921d6034b4f304e62c499486376698b63728186b757e61148b7daef984cca2c737baa692b5094726b967355b69002f1dbdf7a34c03dc9a25bcd14d8c960810bf64ccacdb7f92ea055e26ae3f085c6ead3b32bb2d3c9b5411e4f319305a774969d8990647c186efbbe50c3d5a45828aaa0ee940089ce4169d4fee9913f4292c240dbf5462ef24bad44a9383d48fcad19da49bbff86e5b901fdd905fc1523ea9f94c294aeb40231bf920d612dc24bac55bee681faed2a0f04bb10a1240e850f2821931d4fcb02d207a6449e5d725dd7793907c02fdcde0757984ec1c436e059f43250c9a9211e0702aab55f5f1a03acc2d3052e0377286c93d1eb2547601dd4509818e2a5528379e8889163b670c41e4614b94be709d2685a916e95963145f00576da19c472961e99478781cd3ae9a88c543ca731667047614291a119d3264647c2d6a1805433f2aef987b35b5abc069ea5830237e1d84bdc33cec5c50cecb698c0c835476359af82ddf981f6b7108582e9ae087153b91c678f1b78b1e746642eb000337fbf1730e1c27a6d70ec7d9a5c739b9b7c7ffa584e62b417fd76f14ed411aa21a75e51478cbc04e8ab2639a5364cc77b1915dd8982d121a3d85a759157d62317b4d92c0e6683476d7f15249838750bf48db20384c7b13b4a41280e4f4eb37de6e03c6a15d0da5ddb00017e8db93a94de948913b6757afb07f72e49199bb9b20f2dc7cc5554dacbf769fd784c2766be6e51f22102306457e14e45b7e558579575330c542cb59e069c93367f2aa6d4372dabc3f2c745aa7f8754f1151e7b244d46ca9701d7bdcce232f37dd81a28029558192f0871e90c4df1a087c38236b51ef8eb7a3e4dc36ac88559907db831f3a970dde15cfbc18e03b605f77380a6a06cb5c545d4efa5639cdbb43246609cab3289a0639468ff182dac16b1fc64c75950defae19c0c28c739cdcd87e3e7004b477a10b005004fa99599634c502dcede0b661901b7120cb03549740cca3caeec9ac65891922aaa93719c0b379f2049ac163be57b081363e683b972e37b4a644f0634df7e8c9a6c9ca99f77781e5f8c4bce6b422d5522ddab40a3197a9addd8ce55a0e0786a383b3eee4a61b605fb77b32b202bba6ba8b65dcc9148f1738adb10525ad0027a5aa067c61cef357ce62606349664c38ac9c459d6d279cda765a5a9725a6de472cfbb36e8fa45bc5be219a56d5aee21dd6f33a5a45b04b35753bad2e93f5c7ee1d7d3f0468d2f51d662f6aa5ae371df57db8f93d821c79faa92aa54bfacc2817d4fd1991e3e38ed4d2cba861645c0d4a6730cda519456906cbf88d73ae6d588aeb7f3ad5cbe5858873dee11249c9cd56031fda4c484a925d7d181b547f5a93276d46c35100b5a0735b00dd567f4a6555c0c9f08b87566554f756c54ba6ba0e937f2d77b8b173534165ccf0913183c63952","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
