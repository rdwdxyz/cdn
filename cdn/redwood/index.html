<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a967cd5454713cdaa472f92fb2611e48b3be8a46d4f6f2df6ac38ad36d75a4aa81776001ef50d8d594c0553ea73ef6d018d39a1335938bd6aeece446439f5a6f72139bb28566c8b8895f1a482eb41b83ba0a1fb632490bf51607e50d69413563d9802933512c965de954577e39943f32c03ad544fd4215f174fc53fe620980693e08a40566f27c0b2c7b01c0172fdf830c6aa7cf42d5c6c44da3384824ea9a2ef906b4bc288795b38b58c9c55cf386bdc9c46e8bc9a076a052340f37b5820a4b11b91c2ee2d4d84cb0e08a90648c093348facaa45b742ef7ea2334409eba94290b8f711e561e8ff97f0c833e9773357d01ac3f5d97005e5309aeec6b58d240c4d18968edbdb8aff7c8c66fe416ef6159205e6cceb4ecfc23a41c33bc5e43ae81ad3f4f87274d4b80d47217b72e5a6d7092cfe68044be921b3548df29212783cbf703ffd17e5900492ab236cd325e68b7a83f45ea0af96ec1b9da83cc5bdf02771acc37c0e226b898201f629a177ec134d4aa7fbb5d4a86908a4fafe73aac6d6cc86a38f46211441ddfae8e584f283ed83f2ba2fc6470aae6db1a2420c093a937d16c763f2e752d15ec56ace9abe5353b2b17ec9e6ea394c940da3eb8818362bf354b8d42a6f8c391159e300a66bcd895aceafc3cef6e40dc666159e78c646df5d3d963b1de9debf9fdcf4e0f4b61d452a0eeadc4421eeaf4049e73c61b411ce15e049c2adb434218e381a668bff1991762554ac9af1e735a1097fbac525cbd1a24fe00ca373d2c01552dbb7e0d80fa18ecc97c17ab01c0e999053bc16405d92530d27580cffa684df81c546418b32df5211727d9c049b70d632329d8befb191f2dc86d2d13a9dc4ad27c07fbad110a08fa1bc1bfa7f40463be4401b577ccff21f0045e7a7601663e0c5c6ca27e95a00be62c8c05d61729e538d75fb51cb208d73af22c3fcb487d9da28e362824e991bee90b75bfbb7ea1f0c58b02776dd6f70eefd96fa9f2fff3e506baf2da0eb63676e36327961b10d8fab8c4d091996eafbbf88413ce1d9c78894690329914e45fecfaca8009b5e7672c5470f023cc87b30246f78e743e7f8bf37b6c1db627b564035f6911ac193510d96ee1c3ced431c5e9af8a14b11c47b8ffb7d8be28be9ae64903ba2bda4e09d3ad22c294db5027433a5d348f3bad31eb1234837dc567cbc45d1ea347e8840017969cc7bb29e9f3e3436f87155ea0cdf23685fc6256a7e47ce73ad7bd3ddbec9391c582a3b23414b52da71a54ca9f62501bad436b795f2f696d895c793fa5476f6335283e1c0acb17e7df9f677726af4cf6f1b06183896d16003b3e3d49ba6a24425d2927d99c6f9333d10be576efcb7906702d282bd1d0b507103658a8acd33955f311d47105c5bd445b6586d249187a74f93b157b2c38030d52e8062a8f7fd5752f00581807047773bdba6203fbb0a272aa65916138dbaa5532302fd98b8ec8c6b0d0d7415b960122885e44d4eebbeac8352ba38a8fc36d828a161f40acd77d386fc29bd8f2da3a81b3b577619afd0020f140f7dbd1438adf0692abf435d706e848def8ba7d069ffcc4ba58a7e92f2eb1fff4890a89349c2f896cf77a2c0fedec3183b20a62c5082babf78f510de925a4e7600950b8c0beff1117c6cac87ff4d6e79ac6613b7fb5f12842740a0be331985ea7d6f53a6b1c1c7e61b842737352be54fbb58339260de9819e1c60c2b8c930eeaa12987cd894d8b910906ed35e6d2e6426ebbc2ef64c8ade4436c573c44798686709087350b76a08a3c565863e1fc53c553c14d31eeff7bd122521b967d514620ef990c65d598ba6c59b2affd178feeb566965c559397129bdf1f66740211856ae08c94dd9dd107ad4fd14ee4f8e96bcdcfc4750b38f7aa9f367805f4bd90773676b2377148a62eb92f2d5769049adac9439e62c7a7df0c8c25771d3c490cf4455032224122f86ecf40a119d5918868be1d25cfd3ee1adfccd6cef5f43bdf5e909aa56c21a724ae2d8ca96862b21ebafba77d5cae842e498f7c91f15baec4c87ddd4050860fa3e8444156e65812c9af7b4d43462c8a0645c96ba6b9ea3b67a9d8ee6a7d515f2d203b98f820a96f2a02fcf9d95a4efe24f808f4847c583cff48e4495cd8d82bdb03847fbf1b4eb6a029f2e5cccd2dcfcd93d1134eba54f6bc222d7f0696c0612722b39f7f67b6e6429d7ba0aa549572f0f3927c3eda7b5484443a32009651e16dffbbb5756d6b9cae29fadbf50312abe63e43601c72b39da109a0384f4c6e5834153c875f2ed5c03748684980c22ac19256d6deeef1cfb87a284a6a2e53ac7fe43d8a7bac2ebb84b3b9868f42900a697dfe91843e606b3745ef98221378b716c314c11161555c7de6508558a55785cbcadc80e34783b2957d3b82c9aa9e5531beee0f448e8415c93dc46b0cd1be906d006fa0934c7ac9690397db147cb360d467346567ef5f55751b44e56e5e480ec4039d62764783c6e21e18320838fbd603d6c2814a1bee8452ba0f1044f8c35d4025b96ae76be5dadf74d17a0dc6bf1d6a17af539f0eab145d727d8805cb05a8eb1c2e160eaf051c401c8eb7532c30911f6761e28ec277deba48165eccaf0faf179c8c1c2af35d0a107cecdc7e31d04c3af0c2c90d2c542b6b788423c35ec12f72d42abed37273604f568c481025f6fa6ca47df8b7c04e4ca6376763742930737374655e6a2f135b1958e49acc7de1eb944bb2a648950ae596a76ca634969e045f97dd8b5bd2d5b65cd4dce1ddef1d867a0e903c68b92336cb5a20ca17bb0cb9c960d4e0f0c7e3d9fca4229b92637bdcac52728218cf6600c4a0b01417557c73d4fc91be36f7ec06fb66244033ce4290a9da3df9e20e7a16b1e6318e2854612c493999c2fc7800b9a731a9c8e27114fb5c8d6e34f29506d077935f4352b598757aab0b8d8884bc6641a56577c58b27a12837f46d5cdd4e28a3986b29d7670135031c3c3af2c307a2e14761ed5984bbb371f21e78e1a34e535a241629d9a483414a38d3628285a53c688be41400e0147200c38d555e7de45ca5ac239c52ef37ee184e6bdf90a134a263972b3afc488094bdcdcbc1ac6327641eb0516d8c3eb2a78d70976e7bf97c6091deabf7ef6fb75670675e38045983c6c92722ed0605c553ff85f2fe9a812047431df76328758b76bad9ca26e59942a12af7741a37419e3f0722a2a2643a881b98b8335e3988a88bf813e47ab289e2a4cdfc4bce414d331ae6a2d404b3a83c8608916cfd91ce4e2548c2252d018f0ca427d51fb74254a8ee42e65452923015c99bd9ebd20ed330434e9ead45c239aea3e2a8a28c6bbe870a9e0e6e41b264f874bd2fd8db4982faffa21773ef38f246e31a4c8b2558a34d4000e49306cfa3430030259a0e1caa27ea0330a300461e87f62cc8e25f436f0f18a40bc835cc5a037f35006fae50e6466a396b72a31ea701c2ee24ca9c15c9cc8352432bdf6939d5cc5a6be3234a12f83ccc8f20017ed4d867de936345fef396721a3c2c7b552d604b55697205934d74c5ee705f9fc0cf603026d4fe75584c26c64cf56a46d555042e019653b21fd9ffe45661a3224cd70a851d411fb8d42e445b099fb841ff656c9fdfda021d8a147e70188d9ca526558e0a520e6990bbecb996250fb6ee416bacb8a93db968f67f8e1363cd40ce4cb45372aa11a1daa154eeea857751dbc00d7c4ea4beff275d76451ccf0b1dd8e63b2875f4a044fb1948cfd1d62109f6e0eba20229dbcda79e5dbf5d9abd399da0055d0b5c4c8a3c0c71a70d2f0c3b476d5d98f842971ac8a1ac4a0dc8d9e80f7201459082ff0271be79476070e6d633bfbbe0a066e9d797452bb13c65378a51f074f140b2ad0ec1dd422cd2ae66e8d46c9457e19f190c1f5ea602c5f85404b592566e48a86e269608e2d23a29f0a12c993f375c93502b437a2cde3eecbdf71bf32f8bd0e1392167c969b3dac9c9b467b0b575b3e445006ca0feba3d68982f91f988423f2cbd4298e810d847dbf1aaa3d9b06d74217a4d118a7c50c5e599855ba0cbd534474171fda5e2a3dd9578578fcccc644c02bd4ea8f748c6fb2d521da73fe8316486f9f56a8e10b9fd9a22211c25e9afcb69b409e850713bf1bc9eeada75f5c52806d0df7396ad917c602f12b365f936c4514df5c9b28af10c88f395630af4e3ef75b275eef640d4d51de2ad2cc2248e5b493660fda28b00a2afa4f1787e5a07b6f213b7692e9826f907f014e00a5a4a3a274ab60e40955865d9afbb8498c27f3981d7a21e8b979e90163ae4e808c921f27f1ed01f096edc2eb888f7ee2ad0a511d43cbd8279e8b71268d1248548833bf25b705b768b41e45db4e8b1afba869689b325fffe0b03101c27a86248ed8f3e601e406c2ba5128e6c43f4071405e25d77ac4aaf5a1936b820b8123d1d6a0631f17c7fe38eb90312e790454bab77a15a82ff2367d9fe0263026984c4af6805fc9f178d8ec1ecb98dd94053d33f00159cbfe2cf717f136c0d36863d8fae1dd08b4954d01d89d4b2c65adbb5a4a1ddba06bf506a8adef397dc788d914529221347675051cb048120d02abe5d587412cf75d5eec81eb9ba37025a45a713b8a346771e604096390e5eb67f16d75163df450c9d9dd1bec668dad74030cceb33e72792c203ffbca3433cf53fcce067809a81832f8a0fd37f033774a0c51ff4cdbb68be0f5b745e15b46146db2804602dec9c697b13cae0e08e438ed9392ef6b5f5cbc63191225301905bd6ec8bf67a29ae28de03a4a501d47376c52e26e4f6617573e7f905fb822652a8c76f6434c3b13ab6935caf2c0d05c32eaa63e0e44885583cbcae19c0575c60536bdf320146cf1c1969f4e94567d8b49869748c0d3cdc47a594d5fb58f7ecc7be5dbf60ff662e29f2e58e01d59af19d5620de6fa1f46de7b99e91450db3b1df4a896bc859fd51e994d8559db1cdff8cd54a48ae46116cb1c7eb265ec28ac1822c34e30134eb187e75894c68d8fc5a901655580c48956499fff88165a641e56e4bbfc6ae4a07ca1a26642e93d1d10181f6dc29921863d911975d1e2156168bdd13d205c8f484bb0c4f93501d137ec7779e559bd41572926c4962ccdb07226976da9fb767ed442347f08d939b01c3868535bd0a6c69eee5d4d2467c9c15d7e774e4f37590be6279ddbe8ef4fe8740ce1d41eb0102c1fda9ca6c6d28d6047cfc375bac6038d497c1ecab8f6016809df7f7bef2c7bbc83a4419b1da2f4ebe4fd897b74018ab62312d87719a00a99ac52341ffe4bad0d1146144bcc73e09d72cc3dabd872ce94600f5b0de84c96462dc0dca5ee88f4af7056ca4c63224834d8b10a0245769b69c96898bafb6a2db639965e2eb2cea37ccb0c0c1c722615108e5558b91e2ecb84064a9d5755213b186acb187233f521daab0507425d47030908136cf8a0e757757f35d5daa5d37bda35ee1be05e59df8f8eb0e95fb37f32db9b16128185be3328ec75830d60f132eef005d3b19de445a14f9d7f65c26fb805e2888ba0eff8f595e968624902f4d1fbdaa1ce0c1e2ac7bb406467844e6ae5f57d59860506d9dec7ea2fb4df85a9ddb820f19c9445b01c02f75d410bb1d2f9a3a20012548bebe509d39e0ca8525e7bb148a642e54ee26d676fdfd464b87a272da056220ab71eb6fcb2a89269dae402439b03c7620eee67d72d05b79045db2735fb6840f15ae42c9ee13718b2ee0a51bf137fcff8bea1dd3854c325f6a94e754862e7b55b284dd1e33b6ec1cb5f88ccf169985b33769e4bd833cd3d3ecdd1009390c65ddb649aa687baa1187cb894a2bbd92fd5f93e99c2beb2944cfdaf431ac049109a6344ec2e784b1d4e881595aaa6912518f5e744b30bbba530f353711651224f13b043d0bddacdd460ef83be799f64d0c089d61f2990ce0a9d0085b7eb0839f1568a9b0e78e6a1a93d739d5dd5e8560e1f12ef8ed3f8c3e4ee9f75ee2f0319012d127eb4751d676989fff574f5d9f16b2c941a03dc6bf332b2aeb1ae0272238a7d09948cf96a4915522b2901f82c780d3bef56f085802b970f8412d22262df7cbd773b5aa729dfd359290f2ea9bb0c97c55f7cd7b043823650101fa8624c85277f6da296ff9fe5b8fcf2ab7c1db9d33eb368722b486a2c943689395d19528b6162be1e3546d1286d99eba6be20c44aa20ffdf57dc8ffcb3f240c7a9c4b3f2e3a8afd7ddc19d797ade381a7ce9c234698a1be193f90bf6d91b9b57d0da07d2065313d12518ac7cd60be4c478be1063300e31384b7afa3a2cc8dda9ab13373d03e7b98820ab7aad278fcd94fd27b2bdf0ae15799cba38e70847a74aa654f4131b5305a516f78271b2467d56698b2a3ca8a1a9679109bb3df305e0a6ec806f02ab2ed74e610cb042ad578419407d40846c84a5c1f190184866ae5246e6eb9e6198bf4b5f4e6b17d246ad0a48de7af2f3a935f36aa223130dd5db624ccd6cdd403cfd91582ad9b858dcccd30cfba278e267a17aa6b4be9948712b05bfbb8fb3b1899d111c64ec4a060a3012f1c042f7a49abe4dcbd85272b1d27294695088969be486f50538add16feee301f1571d56fb8780b3c14eb5e61998f3f21bc1edbb9cf6a22b4ea04137ee65d126902d05b567f85d8a2bc8a55f527c314731e1d9bf4cf217bb67221c4cf16e0c801ce0bd8720084413209821da961a8b02d4f9a40f5fc3bf5408a2b229f1b098125fe067ba56bfd3bf015873ad769d2a093f1a91899976cf055f55658a5727f1c186811d227225d586a9f1c71b2491d4e4f1fdbc47663c58749415bdb43d0d77b1a805daef89befbef12b866370f0a1b882c6eecb6a9b09c85ce9160b4276148a5147f3bb50958a212f469e31ee4ff1c6fb35637ed14b4d3f2139d5ac82a0ce15300f0d6ff98a2a67d3cb0c9c7d054d939f8b8dc5b2ada70fd6c2877782d03af9b9ba03ff00dfe3d24473cc5d216fa084c173820123664d0b01a5cdea78ef532424d2fa1970c65b57632638bee66bcb4f677a1b35c69ea4e83532b910e910d1cce5d2e21f3071d39b889bbfa9362c0a89f1b96afd7b3a7988949281df015ecc750393d314803660e73e701c6ef08757e234c59306df92f76055e1dba972ffe6a085fbf4dcba9d29f5a20e624dc469cb5aa54dbb3d2bd1de961af9d94b30aea1b08f503c69afefe7acd52e35654366f97607320f4438febe4edf5bbc38c2a0bc4e946441fc2ffaf7b8d4a8c399bd46c7333c1bc9cda0a5feb18657b9f508320cd6db1dee0c9a9fd0564c98082754c24dd6c8b19f59c4a6194e70477929557d7b9cadc807c397da969e6f259f2bfc7ed725ff5942e62622ee52087a10c51a99bae3e3449a0199ed4be8f7342105f92e0f0574643841d292a6d67600036063ee7fbe251e7799caa0ca11f977bda84d72de4f5eeafd7b25856b5fb84946829181d2501fb85cb2e298716b3c3c8e6d0aeefd4967a73a818e9127bbfccb8d6f702120ae0b6657d23df8d7ef2f2c09aae9948a8b62b6589248aae4fa717811dd3e7ca9b2d523ca1bcdd6280054be42cfe1ec261246eec77652d7e1bf1941c04b7e0812019a11e006d9e8a4553ef45e21b2494f79e3713debfa0bb23b428be3a699e4b03a3fa215351ab02e5d9162962be53f15e9e71e9507aba04087a0cefd3ac5f5625da1fedd5d92d8d8c5c3a619d65ffc63fc7706b21387c526b000ae08170e7ddf926d5528662ac7c5f3a71f39b52b48f13f4d64db0b3ac74d554de53797fe1898684ca43cfee076c29f5686f36387af32ed2fc6d78526c3f337b3fa15ee29076477ccb7d459476342cbbebcce5d84bfffed9c61289acf471123e0fc8a970a50be6cf2ca8fdf04df93a33fc832bd727064ea75bca3702fd4d588607dfe15eb16fb22563d228272722456e5c0e8031a84b8f9976206960771966a1e70f69d0dca5ca6289cf3f696959d399f6d0069f9e8d92c9d7f413433946faa6131b23a3771a60dd674833391beb485a118a96a1c6433f1ffac288932e3bd15885e169aaccc5f7dbc82bbd3a703d8ad4cc242fcf0da5b2f8e3f71b045f6ad8dd13617e99b17ec656560f65953861a8e60901648458db2a1dbabc3b93a2c6fc827cf0f0f542df8308389d69c4a6fa40d2c60eabd241aff12d17f4829b5c32b797484243e3bc7c06f2a1ccd0b40f77f7219052e52a24726cbd6bd077bfc446fbfd11e94f08c5c4da150fd0dae44c8b63878ec3037f7ad804b7a6da538bb024c33b2e72e9140bc87213e331b4dab58ea1c753f0211b236a5e5d5e9e6f52995bafcd313cc6be075aef18ab75f6361573bcbfc26934e59f85ffbd1acf21b02192c16f653f5989cf4d5f97b5b140c8b579d417fc10c68a5592804bedad8a2200bb725a96c5148b1939783a089fb180a7be6dcface2871abd12a939ed8ea3f1853df9728fcfb0b04deb45d2cc450ff474657e12834e8a5e0491afc77e0a41c9c11ea867e4c63b3cfc15258f1acc8b8fab0dd2b78203d59e5f5fb570b54ce50924c406b25413c6ae2192c163ae4f6b99711e1992b8c7dcf6767352ac11e2af3d1225cb5d929cd6402a51f3ced0a88f46ffc721f4faf265822eab53cbb5108ae59f0d26bc84ebbdebaac4502d41bf600814c47e42350fff33b17580311d054271f7fe2b74612ca400032093913d821157cc68067804e248a95b5dd3f931312775d32623fb512d48ebe8caf5888f4f979e1fc6fc56d94a01d8884b175d01fd08ea9e858b29df46f9b4e6184fd57fbfb677a09fe074b0ad02282b99368c86132d2e5fe0bd7c3e313788196ac774df469aaa817c2ea543decef49d8f09352010b0dddf08e05d99e714f01e4faa5fabad491918bfa44bc5db5fca4e4ffbf7304232f3709443b2fa572aa3feac8674bdfe17b516ba5282c20dbc22558346067fea39f6b4455e2a9f808db8c1cbe3219a3acd9fd9a3983e05470e671978d20ad5ef68f91bd86bb9d7faed0fddbd616328bdfba21c47ab2a4b61c7f50e43ca2a5ebd9efea5a06f3349039707f7e28ef1494c37bcc16da03a7ce8ddf667c15e5bcede47855f3a380125a32eda78b373caba68dd788d0a9918949d91040b6e024f34749f0be426d715d1e5b1a44f77de42e454f6b0c5034c8fe16647b0db2cb8377e46704cfa52aa83344f52708415f44c15658ffabbc310fda70e4c0acbaa6ae2cd110a036a1396de315ef4c1cb7640120e291df112bdf34d6a0723a498854bbe0d09ef1fb5f88cf34442245fafe0c8d8da8470dcae8691c786644f0b7106253b46ebbe8ad391876b7bd81d19c94179d7381b377f115edee098f81d518f6598e8f5a2824df62f3a70797f88805e88acd6511839fd8bfed53a4f2f3a46f599c1b5a387fc035690dca64953b7c5f00f8f62fb89055313e2d8bbe3555f439bda35388541eed708f8c9104c99a788be78724b695161daaf70362801d71152d15ad3e800b4f10fbfa080120b05b8664f907e3fd1fd5d97a0254440b9186645b85265ab279d53a9ab31d5698060005c34e06826726b516896b4e76eae1cb5a7382f08c44962b7c8136203e2a3fabc75ca183247a53ecbff90be8455e523aebb96c391f3712c538db92a620ff2ae65548f17f55c492cda74982b80bc1c3f7eabb9d13037cb35811e9948c9a7c323f189163c00fb4f95dfd7190775f8da002e7cab1236ddfc20a275bc3a6c7a74cf767c5f8b2eae1f0eac2c423b44ba1ea79bcaa6cd70a5ef5540de505ff87217e0fe3eb7a415553c61cb0976f2d0be0e0fdf58ac75ee689a15f4c0c2e50493a48abd4bc7b9fd9a909665dbe848282f42d1ecec7569d604eeef9f50b9476f2cc7c3ab1b74af589ef3fc3eba7d8d506c4c0f09ea4bc514a13f725ac6dccdd7a03bd223cf685952da1a5fe9657f66800c8370afc996d4d3a3b723a5b8f89e5033c7bb79cab83a38a750dd5ed2f3720be826f099e0dcf5e64bf11d53050fd3a600b139a48784696938f860312bada0107cccf5e3b52f1885f49ed691afe2593b67c68814d4c981e0b43dfeb0e94c438c97981d8b832e1b22ae75cbff5a7029d0dd19604302a8644aa7385dbe2ee6744ecbb8aa8583969303d5bf0e28c36a224e38111632d4f65fd3e84aa9676e135956bbd66b7243bf05782e668e16e2c2edd8336db78fd376c444043950fe1d6badd6a3e017220bf62e05dbeedd5c62a81c30a1104538cce2804d0e5f0fe51a1cc47ce2b93ea0c1055245d882e752a59b2ec2ca3496c4007c664633fcda0fa9c714b3c632688d97e21bd1e92b899011fdb69f3e27e6be98a43c80f2af275ada9ade8d33256f8fe70a53ef3ec4b01784bc55dd7260a29a862915867f9ce266b88068a51a8b09a8ad44c9dc9d83acd515fceed411fa03c0cd41ddda74f7e7b4a2a361a5ecfc777102bcec0e89c478f322e09f4b7fad4630d362eb75eeb35ad2cbec5b4f808be1153b74209ad4ae2a321a4835fb56a118ea7205e8f14d283651ef4738bd01390cb1ee4fc290afd52996861f89e596a2829dd7116bb2f29c8a878cce6a969976ba9f58bd61a258fefd9b2f44e06f7bcc48f2df8599925df9b9349064fe011fc227bb24f5172f396efe2d4e77aeb162068b95e39eb4c80712731f96c4a67082585b8f5964a5ce1392c22e9a43145420e2dc9f84d6b3a465a13c11c7d5799d152e740a1bc13eeba73b54b83b4c857a1e8f60455135bc5a7cd7810a687161604fc8e24de70f7984ca630316928a276cdf6ef869fedc95124edcea15cf042ba627201534224fa2d2af77e92e057f1aa478e2a138e99e45d6babde9b849a72bdf252ad3592941ccddd3fb317f0716317906a3b63e9646bfa4e225fdada04bfcc66de2da23d10af32c1dfd9c70e26df692fd203837e724cf8a73d75099dab7879d4acf2746767ad1a94e5c7950750f106a01f2bfa9dcabe92101c4efe1e9457a8c5ed1f32581cd1036382aa1c9ef97fd880e5c08eebbb072fe15b317508dd5242a30cfc375a3a66b04ff3793149e14034cceaa316e38b7e31659fa87df6fcf4b14c155f1a0bdf8441a2b50884e39feade7fb4009494ea37e3bdb90176c708ee5c3e3d6828fc06902b37afdab131f36b83854953c4f4bb44963a66e89037fe69c36a426906b7d0ae87f51d25af3e4e3ed2931132892b94f137a964e8365045f2e0c999a05c7a906b4d62eef9d03f9b2046df5a09aa46f2bb069c932bef7e931efee276d8ad21bb070e30b0e4018ad91d9f04163d14b700b6e16d8088db5ced85c6afb614908cbc94ca252d16364599027d741a53e48a16bcee5975570f53f80d6b168b4fe95a68a708c6093a1fb3f52f845677454927a27a41f98dd58c155a76c1d3641c210946f3764a224432dac25ce20bc40ffffb638c515c23b81044cd10aeb827a59c51382fc5342121ed86851db3aa1b16809125aabc24a0d819c252d786847bb863bcaf182ca106f97a79a7b90fb8e77bd0e3eda9ac1f74766a1f81dcdb57f55a8ac77d198b17c63826b92aa6496487bd90bbf37e5d14e3d41291a40fc12504ff324ce4b526dd0d3d631ebf122018d03dbc32055206515041b89dbeb88b03beee64de9558e4efa16aec43eada410cd08bbc0389edf91858fc72e1dcc406c6cba8fd0c2c3d947e5547252eeb44b71dadf226b77c8f1767f2744869279e8b620f68ebbca819ced65736dfbe89a25190458cf46592e8848f9b73523c900166e4660da9fba0f8713cad0e3519c10f9281739073ec79e1aaea2641db3f668ee3440291107436c19d758e0798d4af80365dd523e4c887c97368dc52691cd6a3604e11d826c3b7cd8acd93c320ac14baa6bdb8a15a62df84eb53686fd3170f19b926e5690890b57442d7450d1c13a05cb95f02b7ccde7c55c003d379c9f0f3b4acbf57ed785a8118e5bb2c2ecef37abfeefad64dd862f57b53494e62f20341125768d70b54ee519e19b3d0db7afe540855bbcd54907aa288fdfc1aa690ad37b275b1ecf8cfe91a584c5847085635d0deb9af662130d1af5562eef2ed4895112ffd9255c8c2b42e08449fe410834fc8b898540562225f4d6da1bd26729b7cc2f0a7de540f1ce6bb66bcab7b694f988b5701b6fc5a86b959d9a654269e756d782a3b94cbc11696689a322658ef1f3c6803fc9e1dc1192887b2bb5f5850319852ee496e94441f62f90522305d874481d3d06b4b340b0795bca202916fb79dcf389d80444c46122d71c226d68e603e3fbac643af22532ccaaccf3fb57fdb8983e50099a1304ea5c464c0dcaf5be2c19ed8aeca1f4d0c28a743251674a11e30059ffdba429f24ef3612f9f8b62a52d0c6e3a2417b7ba02db961529b2e11e53002a6c7569925966fee8e00d9eda4092934a69f73f1b57b124104ead572ae41d54d1163b00c11932e78ab2f8ea11cc44d3f90e3dcce97faa406228c95c4eab371bad5fa31fad51d8176ac7f58c07506405b03bb547cb7924960373132ae57555b6072efe775bf77f1d455dcb52c7f8f3fa45403f341a64f789aef4089fc0c82a6055bf5cec13f371145c106844dfd292a0d397b63532860614af77ea4f4b211e0e3a2f344fa377f1cdb6ae54fe6ca82743effc0626140b6a35099350547da406ac3fdef0023c859db5522f314428228cf74843967cd8bfd21ef165b62bd94010cc51764042bb84602889519cbcf6d50281f4efc23bcef61ae496c2aef9312b6d53ea45975a999438636cc3378ff84ea8df3017b254a8bed29b99bc175a0a3fd2dc2128ace8db8981a77e7848e12d3fbe3c19bac1f63d88bb798d698c862adaa926ba716dad2764105b39bed48294bfa9a0cc9bad26148a403f6d402cdf15795409913fd2d2b4c6a143b940746c3173da2c6cc59ac85029822ed7fe5d8539ab2bb388d3ca26c095c7f30337b6cca17c8e185189f0c4ee298e319a081290c5a2c52385445a21e15d90a569131cffdd6cca243cd7bcc447f040463627c11a725623c8bb44ecff4fc52af8959aa1d16eab94da9b3c149e8e46ca8811be421d19f195dd918e430a5c05e339e0228970454744a4eb8f448d16726498606c1e37639935c7c94b2a78a5b267f3d60e3663a2aedb4ab928b92fce453adae9fb4ca2d9c672c23bf80e3621ddbfba385b3f0008c88cc1441ebe59798c99b14cbaed724fb73ba6d2d44956c44d1e129ff4498f80fe88160a4bc926b884d604668a7b7bc26e2ccf1b29afeb803a77d89581643d9a419b5f918191b21be2e1fb13f27da68583bf1dbfec54bc6c25285f4075e63035007e9fd5b5db652996f67ba7621a5fa26b0d2b0a30aa9d5211ae14bfdcf69ac40089cd50828d32d62f2f5dfb021a11bad90c85ccc0048e56ef995eacec3107069f709f8b5ee3cfaab936c77f560b59d0a894e6f09abef1c1d6323ec11920db05e144cf5cd2b787dd5c82c007858c32c3e0a3435ae05bf9c2d2f9ffa53e9cae594db79baf3cad56e4e90607ec88930e955c37cffc34e464097da85015b2ad459c02eb42f96f993db0db7ea3f69f24b61e3bdab7078e93bfc10a13721e303f07e2e73620cac12295633215d032bf431bb210afe1fa59cbc3c7b9122a0b888b2c0bd67595c5b5c5056f2174adbd6680c4a7d34234af040fabd03c3ed517d314ff5a177b1af755dbf5caf1482ee11c0c2764daa545216f6613969db42a55220451c9830af2b27a2b0cf56d2d9e5a39f5893c3a6a0814769889050a3bcea11b770231073c2755c06e8b77953830f1813925f1855ca7552a51ec37299d2d0d2f095295dfb00b5c27e118f43963276d9791e5c761c4ae08a4b834f256dd825e810453f74aa61bcecfcfeda09bae573596fef488c09a82e2f64fc3cf6f0e09fab354bc318280a1a0a2fb74fc2c43805d7368a62cc6cfcce8c89ac5c56627100051cfeffedeb8b0adc1a33d7cfce41b05aa9d4c6eb1d165c8e663ccde34c20adf9d9c937644e90a137c7ecaf1aa04d23baabb6b60a4ce385671881252719030f595375c4ac6b26c51919de6e7ac3c744a07de29dde267ba92a88793ae81910fd21eec68938ddd80b4bc590b6a7558e494fe57b2b293b690e43dcd08421560f1a9bb7c679c7aad554e5e29682f6319372c22864b29e881d07263be4b9ef1039f11e928c215412328ba034d80256c15491aedd3aa6c7fe847e98891198212a8755aca83beae7191f702353c78c8c37b7ecaf50daae5ceb9476483584e205a82679fffc25477ce989ad7d97cc57b95b03f04f10608d24be2ca39fb8f6f916fea8be03e46d08a50ea0f8e1c65e683f457882e2235cac0cacca51afd0d02b769e958d463423d73785e94590f3e5d68dd6faa0feffec747f20dfe128a111dcbaf45c5cc9c0345eab655bdb78fbd23075d5d72ed1efb1a0ae1093d3f82395ea84668e8a8cedde84055ef406891e2d43b22f29432638550331c8e1b94857a3d8c11e0bba2926552c3cffb24935f9806a08d87823a4d78fbae85fe62482b65b28ed341361bdc54315d5e086aaf8e190449ec63aef1a9416b25574cc6be50bae80aaf289ea00c1ec50caeebe31ab94c96a7dd29574b2d9c76a540ed5dc6d3426c8296c84e930059762eed246e727004a5ca948f11723e8ef1719a569a7d047fb86cbc95414712f49ce75c05e9b5ec01d696dfb7371bb2138c988662ff963ac7a59b2cc3b278ba8a944389139f2a3eb73ef4b2b6ddfabc33fbb46d78644ea1b4a78461d82840ce3dac66a62ad2996750cb72ff8a4861e04d793fc7467b853af67d56287e05dea7ae2245f5b48f09e8dfc734f76edb29e49b71ff8ffec747d856432ff67e0238ba6f1696f2706480253a7483cb904b2e56eaf53e9f7ff9e50b3b2155b007a1cb7228c6bb5bf6a0cb87652f6ef13e5a1e07e6a0e0a3d7f3d80ecb323426e2e2631c254b87e3c3756bfd629f605969d9ef24065a720743ae44426bdf6b7cc701ca2d7717310913eab861514ec6af5bf5b572739f99d6effc0b93cdafbfefedbfc1bad424f62828207ffa65788cc516a3c2d7a5b32ab00f70b45e91d1ae81cbd22c05c9bb82fb775d928180ee8d6077fc741e10536e9d39e06c7c77de3704fd5b58944d7cf641f2473b4c8588cc97cc6950c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
