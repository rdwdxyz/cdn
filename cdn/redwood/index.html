<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a14775a04282a3a27a59b200f14e0dd7049f1feea4d2ee685f7a1e94109c1784362ce55e2d31bfbc2272f607c0a7fbbff457895cbe44a8d940cc606492550935d605556ee81427b6c7ac3474faf8ae0d918b1e4f29212253390c6d6e6cce97d6ad6794e4ba44d175f24abd9ff91d066c41e6b508057f3026258d2a80019c2274f54f556383d76e3f2de3bcddd9f581e20771dfee4ff0160a60e6694024399d24cdca16e7e9e678c24390887c8a8c4d9e5d462846d2f30f38e18708e022da3d319325ebdf9717a00bd7c5a90faebf99c6a4fad0f24e0087995b1e9882681bf7734ef9fd3829f9f67764bb60774686a2ad7daddd1323bdec2dc2cf4c276ec3c5ce6d2319cc26898034ff2e886495a9e22d1a1df1c6f23cca04318b5d2f7058578fd2a5ccca7baeb6a5d30d1622b37d237258401bfe9119b26ae0643e2d3316917d120e318872a01c01914839b65f8e28c7813ac1c3fd0240b61320a28cb2bf1129ae55d369c84ecff8a0dfdb539f0a27acb9ffbf28a476f65335ce0344dc1da14bd43f72a5c5953e6fbd4aabf3e14dd5851dbed443a01be6e12bc493fb975d87eec9d67cb6ae2723b118d75947dbf3926ad76111c9fc18d4c876be4497a2bdf480ae10661921913a6c46ef98326eb34d361247b73bba8a857bda1e52e463ef0e6cf4b20e305db0587f2af1210ecd03fd17e2d269a91f0ff8f9f5ed9cc61f4c096cbab65b450616ac31b1c01cdb2ed08f1f663baf0b3065e9cd4cd590fb082496977ae60225d4ae779f76a56377de0faee70d56803200a9bf595d2cb57eeb325a51d01d4edde863e209bf643966b7bd844a03afd5f6f63433a4aafb272e2109fbbd7e6939107eba13fcb810513a47ef34b116a2e1d9995e7066fea2842bc1d1162103d9d41bba0b3e3d683f1d08853fc854f25f9b4977f7a3af7eb810793245ed4df86397a72608863dc67865f6aa4c824f24857449c01c14581224070a1b68631fb89637bdb5a4695187231fb6870ec158ec4ade0386ffe7c87fe97552b7d25f5c53ba27581d8e94907b43266c93f4c60cefe4480d19e04fe513f7bd45fbf3ab35ad1085366afd65fee4c85fc615adb1a6ad8e5f2788ff9f74cab2b69118bcb550541399b623e8284f105fa27fbe15357d049e1821b4c03fbc80308c7efcca60e5f49b3264afb43a673f561443756e8488078796ef26ca99911a18ee1b0a1aaf4f1904f1a0897fe1e139ad3b34ff99a22cb7d09650a69e5920fbce7a7a188f2170a03219b9c4a8842759edb0e156b268fd324df210eacfe21161cd832f18536da6662daa2ee3117f0ab0458590c7f780fed7f9704e8ceeefa13bba7d88158c84ef08962cc26e733163d81c1c099cac188547387544cbe1f4e649530e27b4e2781e61e64accf4100478db455bbb3ad2372b773b807d3aca50d402d6c405f4f68e3b4b9013911e55bcf626f8f2d8d3e09e2b566b94dab83e9e178ff4a75e7c55c6847bdf4a9e2f79e26792b3dd73413bd5753582aabdb7fe7a6a31c62f28c2d01192a0791227acdeeb9dfff7065a883837e998bf2ca27e2592565ef03d9b5ff3b144b4b8b27e62b52d5aeb2f0a69495e6b073a8b0a159393e003f24217af75379431f3de62ac01eeb26cfa636555d68c57577bd383f569fd03b83e4ecd27715a3b9dba73c2454aed7f1b261a23a153006d61667aee0d9d17ff111a895c08477e0352fef6c409293db3525be728c41474cb440e7875d496abb8841ad9e7a47890881df55726a2b0a38ca26566d92ad7c1d844b419bc084712aad3c7bf498c898d78d36bb7395ee97854e92429fe7c5120724b97d4e752d05331789ef4f7d23ad1d292508c1462ce9d188ab3bf6f31512fd55363f34867926d67a71c281ffe4a11235bcfcc0a05a922dde4f3255e4285c411a05b971b44f2b1df321f406cce31332beda5e243e052d412c65851cd6f53faacb063312c0814ddf1b95cbaede6f17f93519ac3465007215960c5ba1182aa1b3406391f74c32e959ec43c2ab11bcea70472bd098249bd7d01fe7974de8c631605ccb18f2a8957ace789d19d810f5570d481a55a261ea180c4872d3db1541499cdcad923bf255b46310ac88c2399fda6057c905893352ec2e98a66f03f98457e7c5c68710447589d2ee156fe4649cdccf55b5c334cc7b2d5182a0e47efdfd98caa45b30d05240fb4bf73089f942b8fcd9034797f5ee133ef58a3bb53bb169394a49047263dc6430a9eef41447323804a883cc2eac6dafe5dff2f4e849decb7ff0ae19d2d41b53c7488cae510d292c1563e896ff882f8750086486be27deff37e0b81f40fad13558883ecfbaeb0ca2944a03bf5ec275e121044965be52a7f47a41b2ded19c31d7b03426581874d43798a48105fa06b2ed2d6a6865dc58fb5a19d3999342d2fd668b42687e9358e10d3dd4d22030c26f7671f3e0f59593c2da212494cc38cc0b5ed9eb5dc85b48b2911642405af4fd727ecaa9747b64c76ce990c718364b957d77597dcf9a44eb75c5e7e43452e5a7c32700b72621c41ffcb270bd14c5bc29222dff707442ce4c1fea1bf6810b673626713132cd1aac47c5908e01d4331a82f3308c49595cdf3a938e54838a98fce0980f1add04deaf8539649d48bf6700aef5bc786d39c19c243749a6e6530d7ab5d5ab13af4d8c709f85e14a6d0f3e3f7e8fb9c10a5c20b5ea252e524fc656bdaed1f750aaf1d8a2e488994ab447b7795edbde9e5129932d14d0a01ac520c911b8b597c2a23d2dabbc6b1d68d05ffa66c36d020e5926dd9161968a349ab28ba6235cc15b71fb13c516d40f206ea025f0f6e7a8f987acf2840a93bb4df5eb76b3f28e99f199bc454ad20572cc20928fde1318b0b373467c3affc2d38dd6979b2399e6f001360f34d4b51ebd91d69a91afdd51a425730d9f440a806797d27716be31b207972321396537f90dbf209a8d99ce3a42d3883c5ca27eda0c59c6b1f408c14dd7c4a1f94b3c24029fb5efc8eabefc514e073d48483b70acb22b4d5846a3372c2cf8486126db51271d3c02091898c59078dff65cbbd0bd7f99f07e8cc7c12d0e84ea0404c3f4891ef67157be112ec9318c821acbc56dd51b1a6cb87df22c3082343618847c407a508c1173e47b83c8d6aa7fcc1ab99bea7ca654957ae67eb59ef284100b348720829145e4e9a7f3845fb01d09020cc2c969ac82844b8158d51898e47d4ab2a2ed446f58d3c069e58adee23fac5b4c8c8b2133dbe328efb3e56925bd7e34e5b5ce2a28e80363aa38bc2c76ab5a18d98236a23abb5c804a516bee0fe006e4a4ed65abcc8bfed5ecca9ff41d96f2517495639a9e14a9d8302ce633572937c610ea26692563c8c673a14787d20f6758f71cfbc923af9660543a5febeee86498664e93a8d4a4c4721e93ba4f4dcc10cc5540a282b5ef93d328cce42e4ee89877a6cde021ab93f5d188a6db97d7ca5a4e3352c1635895ac8cc7a9a5da554e780c6bc95d580165d80f8c94288dd566d7ee1033b5fdce9c8e4ffd1787e58c0f6576a88983ef9e3601be8baee514ce6595824e37d549293e94c3edc2f30d909c3f6c8f48aef3c695138ef4fda4b3100bb802402af5975de53759fe03948fc29ebdec85957af1807939e42e8375eaed0b78f081217d781f2934bf1171ec6c0bb0b1662127ffd91922094d8cc32c492b8696cbc596dad2e19e4b23eac80712374e7f02a7eff19ca402c7316f3e6428991c4932e042b1879af5415f88550e8eff97905f41475201f1321bd4065fb9d359cc063f9ba1696c48a7f7cb44efad8ed8cd9647dd0b8367e36771497778bcf5c83e4fc088acbd03e69d4ddeb04c4ae52a723cb8f8c47bc4ef8158329b671fdd902611ed6f64c0b6e0fd5cd7036af1ee13518a53ae8a7cf9a48f7697b385dc7a0da18a4d1176f7a89d1e019329374685cb51fc4965d49931d38f9460a9287af0125bec07ec35419b6481c3db77a998ef1810484a87c86347ed0018cad5f41c8f23c955f598d4baa7f3c35bf5ff81432cf26196cdf494b4c289d709f6b8bfbfa7541a3d7449ed8708bac98956caf6a2921cce974e8c1e8025131544a59d84d3325956258dc72978da329e0dcaa4a286bc2d145e4dd2d24d9ba21b104ecfc1951a7dffbcd3c00faa53610fd6d07f4b03280ec21954f0ffb2ac208c63255ad434a469a3310efe7f4e97090ab23bdbfbe3df8a9e94c11cd6575631aad48a0f6e5f7f1273cd095dad5f9785aaecb4bdd9a4c35f0f9433594adcb6389d6b19dbf99684e0017314c9b3cb1122e092a8b13840247f9a83143abe2531e7bb108313e777b839f2defb2fd1f50f8317ec9e22aea609f9a358e23d8f6ae38dc01aede35421def5a87a45c2a40c5f3c84b92357b2b7964a48e393e1371f51f528a435c6da7e751128c4adeafafbc89d428a56d05e21da243b26b5a45ee52a5c0b5bc5cb34b03d9150d367dbd6787e6c29dc48ab0683156834438cabd89f54c6b7e29b0c50c8e715321111c4a4f0f89d4b5e28e4a5d7ec4132b94a02e4fa81da221704d39d6c9d50b4ecb2015dedc2a781982212834fb6b4813f5c44da810feb9f005d625d3fc885bff660b76d4def56113ed4dc26a22ea113f52b7e7e90eeb92271f28793282652a1d598bee8fbec5015c8c40e37d4a410a06307dd204448828044eefb495c6b6b1300962d26d07dba54ea18c5d75e8a466527ed2abc9f92dd8d1a60ad365c614b8fea88a0e23a9270698df2f979c9d5f60d13ee5ed29221ed44408071b43f652c6bc6db064805b1ad22134d5bd1673f8a2d27c478f827c7f5544e457d4029193cee4a1d5f5a70d6d1c77519ad7c1b2e6a25bf08a715e6460063bcb4b34f1a66a1b93c25ccfea5231e8e18b6a12112f35ac1a4d38b2787cebedae66afb32e881cfb7d456a8bdd82f1c4c36e323bbe2d3ee54d880d3d66493e129a0bf3d2a4f8436c56360c12335408efad2f62132fa1f5bb26ac3bcee0d87ed452944f3d46ac2b270ed6290381a0101e8c4e2bb8f4aec351d8981d5257a0fbb3b0926887022fe8535c073aed4e3b064fc4965fa13a4753869bf370bac06aaab3a85f8a09390227357fc3e3db1d467ca484b7771bef377a11fb940fbb52d461a9533c8893a3b7e26307c28868bdbb75a99ed9ce724e6d51d6dd9494a2ae7cfe877ed46c6e8832fd7ea75397f8869bbded95d80ea314849bb3f487bd3c6e33f3213b68c3b16a184e661d80ddcf582247a9b20f1069430e6f48e36db59714d3861ad82dfdfdfbacb76799fb8df391f2f30d77fbe78ae00ee5d33e567816625ed74a7231e7d4a668266893d4b772ee4e03d1a7f8673e7b9da886b2a48a2464d1277d006ca65b4d1a78071ea1ce70b2e03dc8441408ca89726e725d647665522901452ee734a82b76fca9be05e527f901424a60b6a0e6d5b74ea39f32660b72e28f34e2f92fa2c01dbad1582fd4ab15fe39de65ba279919eb5af9fb654b3c0f06b081b291a451fbf20249be4f00284d42a85a7d50c0525c258427c3339ba0ffa6985be8401e929f127da957cad1c71cea5e21598265074822d57218f8c947445d906c4bbd6a0f70bce51992e3508a4df674d53d939fe0e293ef25e67c5ad2fe7e180f04eb6d6763d590fe73de0f0724b54da7b7509c47c614f4fb604b6b4fd652ca4015cf4a9f079a38a83fa2f68eb6d915e5c34664816996d388f0da17286265326c3e0f1b5301ffc9cdbe3d5c909b5a758d7fd0c9481d8879ff88cd73ef6d5b33b17af77bad7c40922f24138c7fe70876135a11d7b94ec77b802e4ae93a889785a3ef5d51923011374aa471298bd3d69d85a94dd91d4830f6c5d66c6f1b91e8001254b52a757167f534ac79afe63cf2c1dda4e5cd1fefca84800d6e3dccc1b0124607c85435851f1323751b27cebd5787f070a1295a1802caede6cd1f013a09f44d256d865e73f2ec06825dd283101c2f78a9feb1849397360123d5b2c2a8e05f5f2df6e44a7120dfab72609f001dc5eb0a837e7efef268aeed3bbdd4af83ca924bbed12c6024ca96d35e92487a291c04fd125242bafb1aa46c569051688281a295a7ccf4d2159fd3ae784f60e1777a024940e499b04eeeaeff2a5277eb442f4dd9c1f59d7d872874ae2ca9c644564744d7d83e7d9350fbf95c84c1f310c196afe81b961b9efb79a7b008b63fe1c2f63ae5ccf17c1e1dec27cc80b2d4d6a7582f9d3adcd7afc6b00e22a84e83c036033f8a72fd4892d1669d6ce4d42192c88e9a4b63afabca435d19c41be1f131f7fa92d4c961201ef2d53a9bfad0bd0b8b2ff60b3707cef2340afacb4114b61f519892cb081bde01d4dd8d1cf75ee96dd13f84bccdcfd05eb461508c1664052cd0a665d898159ba4d9d1f1005c9f62b840096aeb0e7a473edf38831bd3cdc2edcd455d224a1791ac139fffae4ca506cc7c8c2956eaae94dd14a75e0ce3d764f996be8f054c3a29197aa6de52855d57f14752d5ef4447a7b09949ee70f431c7b53a03a43e5b5dcb4ab30390e9295e2fe42b368b6f5a1640ef811f87d1a788db79ce43d6d1f8dabe01e23e23b94a18a2354d5fae7e00ccac73b4fc0d26dd5f9c014e59a7b55e85e6be8e27af10e547d06120be03eb7da562f1afe7546b7c1f77d07e81b39bf7d065c0834a322f55b44eaa98b027d9c7c690dc7adbd393e98bc0812991664b353dfaf002abf90aaf06b5922f49ee7872693d0b3d28e03d1c4ef6b71bad779bd15ed002fe7e0dae02726d4485cb456116d623894b8d4a742399e7b545e697a7fa0ce8488464f796f23e9e3d8f7855f82b005b5f7851c8671f5d68b8e39654586d84c150f89a660464072a6cc5139cf16f3a5cc623a1dc939c2e3a03633b18afb2a82b9bc9b952bbe0c1ac61301069c2bb9ffdb15842941b38173ea86799b4bd17b451b6bb9877c207c4755f914d59d19eee74bf5cb0cac8d5aff86c1861146e7d1684949f421e1b92a12fb70afa7b63912d910e753fbb3819902fd0dba153783d55178cf5502262acecdb9cb5672301c555bf35fe4387d53a3a3ceb13cadaf0868c4575a57aacdbd1f4fdf95f40017dc4a49c25ce67f3383f8af6c6a016b8b434b0d4c6fc8c326ff888d37c53d67eb838b118653f2b3c42dbc042681f3b5620aadcc08388c9e9356d6a785b7b85645a0e588382bea4ee64e99592e647004d0647eae19b1815fac6a4f23937701807be3e877f010e55c21eb055fd35885f9654095ddcc02fcd8ec44863eb053f5a94ea6ac5c6494ecdcfe41514d159d7fe893545256bf625eadc6e9cbfd9aac552d330b2c18b0186926d8a9668344dd9c1735b63da2733c254aa3fb7de6bbb2de6e4fc2ab12a4bba81d1c6743b3fa4f1e295af02e6a752a3ceb566aebdcaf302c1dd6abb884d23d751355237030d05ddc3c56e74830634c362b0d87904866c2c5c31d18729dd25d611da35461313c0c11f6996c19541c2d321752cab09856fccdc46ab670580484b46d025ce18e2256ec9d42ad2920b4b0a49228eaeee26c77b02f01ddd87203c73e1b915c3db2a44e2c93bc7d0623fc0a779e792bfefda46b100fd7b05be55883a4f6e3ddea5dff10aa329eabffd2ff20e483bbc857e0f5f2ae847230200f37f5bda531e3ee2973165acc40b9784a531584e03f1330145b833b898d57a70f01ecfbf7d4b483fc2c95b62abc2565f66abe57bab06b2f15b446e88221d8a1966954b323492d60df4cd8e22fe210c2c0218049e3febc92a9af55b259607ba8f2759d2eaacb7eaca6980d18bc9cc94af0aa4afc38f4f98a783de47a1160e9e1df9426a92deb1b9729e5961ecf8bbb6ba3e8a4a02e6d1baf0879cccfc55fdf327214eef7720bae3a66eb1177ed5c274d392e46b965e49407c6f3baf72e282a631e53cfa571aa0645c6c6bf7510a8be7ad7a05295533c4d991e03d5427c553fabbb749430f3aa8aac367e5f75aff7862e9476b009c7715858dc098b4a1ed0497dd3818bf374fde1e3b79a7b20be16909c5d8149360c0046e2d071f955e6e42f9d3c1d725a8bccfbc499add4e5af2f92b2db1217cdf07d95105f3e893eaef9af43e851a00d2a31794cf3574e0e254f153b3303ef0927ff780708af56a32e3c2a840a70693db0bdbfcc4134eceea1df8e3c1917158f2b90ac4b29cd9edf3b38baacaa0dd02e3ab70623b88ab9e3e148afe6dfb7550adaf7a943254346b5bdd5cf0537035a3267e534646b5aee53114290ae143548af675724e9c2cd8e72b3dd7c7bff3513804a18bd56799ac957257ac1dd0e326290121854af4767c7008cb2bc432529b6c067b6ff77ced0a93fa8d04995f25bb48cba50fa556ad714d36b4f5e577f06cef60960dc29e5c15a595bd32412e302f5ae98256c98dadacd29bfa3c3061f375eba0e698c2cabe4fd6a1858b5fd86e9a36815a3770bedc9215bc875e7bd9c6b7c2aa04cb7c344496785939d7e7e5b13e7f81aa688caee187f422fe808cba0260a4521fb1d101e93d0eeedc1becf6d6c2123a840d14bd99e0924e02f79d183d7d3558f09d683d006590440189e40c1353e8e7aff1a0c82c3643795ae05d52cc94843833cf368af4d85a461bc623c55120bedbde3c97f711b58f0e6f869aa6ce3bc54d9f9b2b1c3d24ee66d88f23419c9f7ba32e3a1dd94d3a42258c8301b8b92eebaee4aa3a5fe98070e2b516e3e768b6c7eabd006cb8e5bd2e9e019a645fc5f4bb687b4ee9bdeab9c7fd9ab0c6538a19e8ae160ecf350d55ac32e20dac304c0bbefbe6e677fb51f43b97a6ccf292788356be5067cfd502618be8c91a4cd8cf7d001f204d700fbaf5301249e3e06cb3de40d3f092d4e9555afad05de6ebcaceba30d1bc9d7e12d6fc8ccceb8548602ec94914650922820ac5a1f83dbf3732e01d05b6f6127bd167fc93e92c6926fe39e7d9a602f8efab2bb5825d9d9f31673449941af6ca7378508a7f7b877d85b47d3140d2ba50c70f578b8d3dfc0d268090af456eba125b358620005953706374a38ff64215b8271d246f763963d97f20edb5d9a3963426f822238e47b66dfb4652c5462ecce4fa507624a2bcb46c10c3b91a4934c79cdbde68911bb1e453ff0d1234ac688635f6d3f640a413225483298e4e4cc6efb99ee29a918425b9ca760ec1992013e3976f1db5916297c8a0f10f469caf6286073095ac21011b2516a907e8ab14cd20da618ff6238e3f37c83d532d2da0180f369bae9e0df45876639b1bd8e3cdf0c2b7608fc58dccd4eaff54f0b5dc9440f42e865ab7423986b3bf8ceaeae0b39068a13352fd890873c022511ba757c34b9459cd933b7bcb1c9d5268662635e23899afed8a2887c7dbdd64b5cbeae00fd81c1660c952b7088cf4ff0b3baf7293fd59d6b93da8a570d565f91ffcc0d6c1207c58c77fbf05ed582f51a6e8f4ef7f4c0e65aa17efda259f51c601426ef74282e2251db4e65ccc7e60eb20e388cee50f0928108d46206633f20b5ac18f45104f33104bd5c799f45e28872f36ad45f56626a555b0e33610216ad2e64e5bf0fc189839769f865f01292a4222f90906024701a5bc4431ccc566977b19fad4b829ae1f310ad2bbaa5d8950de6e831267efd779999b4293a1defe8d988901f124b1ddfed16adf85d4f51aee0b1383c59b9932ae3a1e9e717a7a6ad6552f3a22954673ee63a1ba1d0ddb7aa7268b00d97260b78af0666d478dfb21f67ef268b4543e51fcf726d01d28f0a662255f992aab4ab6b9688726aa2b886950fac6b6205305c6cc730c0c6e7ca20193b7afc52e436809d406e5f292d3ddd5901aefb6650e2e18d1c25d7979442a2ed00532d32cf41101d63505e1b95b34af68ebdf27aa02d69b7d8d41fc6958b148a2c2b96c1185953c4a5d80c98f621418f1da0ec9873e3d8e9917feabdb46728d917219014cc74ce29c4690298c685798555561f25d40502fe20c64431ed0e212e32285bd578cb36528e924b90ebf8a809420f5ff5e96845f569807d3ba83d7690b45c1e78fabdd54cace27ea44ef332825a3c6377aa24a0801769dd1b2b5b583ef9ed750cc404a1e1a45f9d898e385ad66c174fb79e2ac620495463ab73b10c9f7835d0dbfb8c787b29485286402cd832867d63f708118d20f5162f024421998f50959ef7c8eb6557d9252501d3809c1b6dbbc3f3d57e55cb7a0d6d0c77c633b0f9b8479464f98f816a2e5ebdfbb762a1852a066a9cd2d2426eb26ed4ae642731a971d0e06803c090da8733bc03f13508dd79a1e8fb924ddb6f23736ea5b9c67721432e2df5ee5035e0e0d4435c4879030d70eeb270030e2c07312e050883a50b6e717e56a47e57fe0d3b5a085e52a48fca57d109a0d0888b7a8c944dc97bba43f8be50016f812c56a8812f172342f084d272a5ac4b9057f74932f2e9ad9eb9354e655cf8842fc063d1f23ebb37a5eded68799b7ecfddf879db627f847db00cd1d29304e1fc72156cfba2c7b822f228a19d9c915e03c0db3b5117677962b88456a9b71655d6779eecd5f862661beb5abfe446f38d3086684441ea77cd71f688b607b68a3f7adca38d4b5d69f4736af43e64c800b09330eb9a2498aaa032bcdc580027ea355b0eeb83e3dfafbed4d1a002197b01a8cf8c26c2d50150ce0204787bf793e1639bb5d015379dffc9354d2a87b23034bcbed40720c796f79b090e4263a42f6eef47fe99f86bd5eff32873c95f95ecc5a4f9dab2bd35f3a9449726f49bded8c383ba18a214226022fe44e4c5f6e5a4c2f2d1c150a72b980ccbf9403c262b6a62c29f349e3361f8c0fbe1fe5b34908af6be70df6a7f674ac0d64f05737d5bc388e5d6540ef75ed795cb5d4c84c8f944300b42df50503b5e246632af6d94c9174e801773ef9b5734eec36579ef5ec348aa20f19a8d2f1574a78f76edc4892dabf006827da57a3f0524b9353ba14b4fc878261bd8a7940a237969f22f25f737d06847618fae61084bb8f8a945efcdd5a93f275d5ff550c9668c352703757324b336304efcbfe2a014a3056444128b71bcfbe0cfa5990952c20ffcbebf4bb59ab24c05f3229c79a2369b9a6565be19eef53d8c6bb17b1fd438ff859690c858594962fdacfb66d91df44ff73ae60662edc08a059e1ad61185a6dce641972832edbdb4eb9236b8aa98d2b3e06eadf5088531e67cceb9d55e07cb4dbf8573b0d84ece1a6313e91b90bc012cbfe8465bd9b789107135af2cc1bae49b131e8da5de145e55e536e611c3c51b3c3ed358f337a250c992e88170b5f402d6e2ccac3ec5ecb9da537e25c4a301e091079b94dbc28b5f999d694141ead671f3043798c6c4793edee443e5b5cbb3dc865e7b955902802a99c1a9194f325f86ef20f22d94edfafed06742af9ea11f83ffcc7a97ec8b6958017dea78eda0d32eacdece26b3655c156a3e464867ab6cf3da25b9f30f3579340b42c08515d87e03dd5abbe32612ec0736830c41ac4161809a420dcb926fe13b8d9d69b1ac378e357a3724c9cbab6dabde733c53e9768ad0b9c474739b627a0d30b277b6054f706aa9713682787abe3031841be185cbfeebbbb2f1292469d364eb3c14ff8ab8cb2242f50dcd25cac8867e760a3ab0baa29635bacf55734f666447ff2617b792524ca92b5aea41f407404c7781e791e0e5249516d63d417687dc059c349ee0d2f154da7d08bcd976e99a0e9a486d37d0dff6b8b04d1f35b1e07ff79f56e17ff245b69f79290fc327efaccd74ee6b57df07a44bd4a9025dfc251d4baa08c34acc9a9c274f3ad4adcf949bd02088c010046aa2f38a82a6a6db5ca09e5f5201c89872adfebef7f8440af3a6dbaf650f02e7474b216589da50278d6b9f69b42334f9b4ed18ee1508deafe1aab22cfad4fd0f82acdbf2a67cf97ae4c336bae368d8c68b26f27b379d5143f1d1e8f5889eb26508abaa0fcb1898b0df20383ac53b88684543b91634aeb630a85b60430a369bde90d86ceedf656e655daefe5fa5b3aaef2dd252f5d3ccb2e94697024871e8905c17194abe045f6a60e76ce0ce29af781ada4de82db7fba74b5d1085cd956e054335e74f498de634d13f4668922dca1860863dea60e7e612cf21b189216ae593cfe079f91b6d41ff6974a46ebdc5157a48e8cb5f2c3a1b57cc67da55426ca2d8c1a6fffe7a292e9baac1b12398294251731fba2c6fcf33a2abe73d57c376904db042acbb47a0f226d5581610840d7940be75686c95ebbe68bea078aa1e03251b21b1706a68fddcd120e78605ad396f2fa5b1e4e1016318b3fa5a79dfdf40681ff19faeb4ce5991b1e0986eac5b2db423c83612f895d2a2ab4a84d26333f0b75c9fd6a18efc275b4d58c18648df7283417c6bbb9dbec91a0e0ec356e0d488e08bf9c89908c58b5ce900f9aeb7901eebbbdd35d5a445babd73b63706fd84d4d03ca7d2d4685c9fb564c863ba85d4acfea3683400ae81819215eb4bed382a8d2d8750d44c80e36f5301530dba2f28c47b27b4039c269bf665e946964363dcc908859b0cd26cc20077564e7dd1df0f0dc2dd402cf463c02211ffc7744d2aaa5ca7a04af20074c7829a811c5fa30e4a97a50c363d88a768ab958c9f84ff25f5eac5438acedd02ca3966c2091a9a73827f5cebbf26c6e7077388452afb91dd43ecba59c27bab36e7ae9abb1e44e3df5143776ce3913312719dd8ff96c17d05b124896e503ea1f9e5584c950fd06bd1278e3579609318fc992dd26d694d9673dd28d1bd827f10ac14d2e1bea26985f053c98718ed2a917ea5ed878f49b3bb822d6bf8e0c0dd4d51cbf8727ad4479dc52a6ff51c9b0df721028b9d3d4448513caea026a34a07b109726c54e7906be5403882009ba644ec57bb254acc39f76865b7971ac5c57a8dd9a53f925914defb45bfa9c0ec490b8e3d01c10ff8bf5651c3e275e2608de1fc64907ecf37b1e4d155a590ebea994b1c989096c895d13ebef2ae2260e4953fa1abccaa513cb5dd9cf437420e1ced407d65eacc1b8c71149a7dfc7d30479aebbd4545584d039b7e59908b67365daecfd78ace6f1cb2814c2526e68ea850b729e0c9cc43df606a525bf2ab77c91d6b6770cc704b26f5a6687210efb4e403d2f05d29b8d3d9c9098b466910df96c2100dd8e039a10b4d344bf6f7c19f7b90e22708ee3112b6694cefd570e5e13cc9ee9a4314ffd15fb95d33033998862765bbc272ce78243f8f4a61db4d30f61ee0dc61ff9d7a9c2e461633364265b1f76367454573e6a1e5f930a760ea2d548ab35e436bfcce35d43f16af406b89eb650962c53efb61269d90ff663137fad497fe3277e375ce5dc36885e3178331c11a8d5944f237d9032338de82d8abb43ba54b3dd8dd7e1bdcddeb62d31c46dfe7a968d115320ec3e1d5b29adf52fa3fb1dab949c912ce204acc1cec487b8ce7298de286b686623576319f79d43696b74995c36719bfcd8f3a8c144b798576c3d8659fc02e7fd6cc4b924e4ffe08edd7b0075957aae476f242122703bb06c0e438511728690f68f4ae31ee0a2b1360e239799dc772f1cd4ef6e5d7f10de6fa2ad6ea0ae0d1d9cae735147511cbd898f6f5c1091e04f3992ef96ea5d23e0745dd9b668301566cdb98b6984e86161c606dd52c341d847ed32bbf8db7d832a5757cb2a81ba35f79cbd2e2702fc2b0b8bbcf189dea45134e50eb44584d05a2dc5d8b79091360e2c242285ef0d1abf3cb78832b413b9b0f24bcaa9a551bbb2d94feea52ff67201ee51c86777b7cba26bdda3b1b2a1c9783d065c3c7447cbe059f5037e3dd7c187080ffd886b6496fd61e1adb6cfa947bd5c27076e526729a02877a05c43f2ecbfc7e5e1c1281c63aa73b14ed21c9ffecbac71a6a8eb67ed0d172b1c611575152f6e9aafb4f070fc8bd66ec1da15e8958170acea1788b4a0d411a3f787a77c6b3f0c452493bac073f4db72a68a6cf99452939d017475d395ef8d90821a452e2ad81ae033654a3324bccf097f3e3bbb30b5d45f3da245ba55a478f598ffbaaccda8914cd4dfad1779fddf8ea034375fd051211c42bb97e9e54a9a834796b24a195fcff9f223653900e2b8c6a432726c585bae09fed71d1a539188ad47ecc3a6ef9649ff004c0d4cbffc1b63f0479fc6b1c119871e35c2d9435896a50570556781c995142b2b2492bf269aa3e63656a59e05e42384578e8c761655ac98083864998bf9e65f936fd60c20915027481b60919bcf85557d980b6f813c82f744d8edabd98e2f01403a6e1af686133c6c1bdea0dabb813c609f6a60a81c708f9bfca280306d91c5a6d656eab1969480342a1da32dc5e798efcff73b7084cade4c40bec131195929063b83749c8a5fa2da1d884737fe053415789c90bd5d63bf26ad0e35b121dd083ebf0edc3fd07f1de0a1a9924c22d77dbd5ec1a5ad52d15d8fc44e114ed7d80d514b5cffc7fc77cd9147d725f1c9fc9c61361b255a6fb6b6b868648173ee00ce97028555cda2a3569c76b6ad4776c6431bb682b6df510130a991e210d75ce9e91d8b3765cf9697cfec2134a86a452d4818f172d9802c44b31b5b301e7839174b9830b784162f0d42943df1e7453c40efbebdbc9e447c9c6f5df451c11c7c1baa77f4d12b465e75cc460d3e58456ed9e7bb76f4d1dbaeffa85ccfdba02d1703c27bcf74c05559e295c675cd356103a7602b3ce6456f2505e85efc3e80b7855ce5c4a0522dab9446786b67f6e04eb05e61a3ca172f1394acdbc20eaa1b4ed38e2e7637331a5a5fc1c311f929b9e3fa86e81a1e68cfe81b200a5c162543f1ff4fe638951f2e000aa85ee45c5ee87eeca0a62443e3dea97ef3209343fdb2a273801a0ecc5711b302ad3022e4f8ab0ada7958f3b5b2b27275728310e5d051dbdfc5c481b4540e4a316e5d7e615df01c9583f10f3a8d137c250adeae4e2be9c2c146aa057f4aedddc3062b17c32338680d803921335b4dca5184e8f6835d9683e8c0dceff7281506f10e8ea43a91b83d5173cfa65ccc1b25fa3e9766c039e336a87cfa2171597966744814fb48e3dd45f142165622ad92c0692a5140b8711fefccb8411a13c467b3e13d5f7c632e47f3005aa2d87baa404269c13f840c40f1aff4a278f83de18431d9ed479c1e31215db73613b65bd1da577805881a7de3701c860f440960633bbf316dab08151a46c2be0a94e1ba600c6f7a385e1600f1a31496bfef3083d2b2e3b74cc0921769172f65e2d67768d92bb42825685cf3dc74f5bd78d6dd94851011e1d011919cd32487fc4e28df096acfecc7f07a39239153c1ba7053e3eda481f62ec646e1511456312bec0a6ed7e8d42cdf8644562c615697230c3ade1a6bbcf77730562919511947b95decf60054c8140ca4af85806c3abdc535847fb16e754884559699217ecf5fe9e0cbcda76bbb7837e702741c21387df461518a0c258b8af7d550e86bb98513029b976789ece265c67a1a369ff21e5c8ab46fe447d4cfbacda8f21490fd91365f4c750425329ee8b91c0ab53f3c02aaf355fd3436e7fb10372a23056bc4b82a8dc925c259cc4cd6d80fe45118add76fc788ca9ff48de40011d03bfd389a6aa01df625340066d9aac374de9cec5a2662530199edb00d957d71878f5bd0e247cb220263a40f2bdf43ba8d51fda1c8da8f8ad2d913cc94f8fe9024b4202f52e420fe0deb97676a00818fd95654752abf587f9ec506b0fbf651df4ddb3bdb67810323ee63b3b191e72be09129e123a728e21a1b9a9b5888130eee498bc9b4520ba354e16d5faf1b19d8b71cb8f656a27b861de678a0d59a9242ff5b80d32fa351ec4ee350cfe49968ccb86b69fb0dcc1c307af95d6a26943d71a6f820438dd1db1c2fcdf105a5a700c35a256403effc94dc2949c7dd1de7b38019bd0c01705d47a3f0fed3004aa252c0f90baee41bee1fb7d5b6fc1b6ceab09f9a67646226bea8cd88dd14c0ef5b4c9f30aa3eece5dbdcbcc81f884a29c81bfefd14db6d4fd77b8e06e45ea4bca7190259ff2064135c5a039a1082dfc236938005faac66fa8c8f54cb4aafc95facecd2914c5d51929e916c85226b4101cb58a2fefa7de9ee88048d885c2ff9de73d92df8338f180305c3dc6b21e2389eeae74f82b452a0ebbc570fb9910f045cdd069d5e1e87e70c1ed45e2df4dac28ce9ae473a3c0bef1c9b8a099e2910e373a4988f2b704427e45dadf3ff77793220ad947935c2255ffe102f386a933c4b82086e863b3f72cb8f46aa3f2734dd10b1fbe2d4c05f41090d011a20a067796a54bc22609eba2a47e682a4bb43880f430c9fed9d9c77b27557a2e59fa4d9b92a64e1a7340ffa8b24e7d9c79593102bf16f403afbd759dc45fbc72dc4621e9c42fe9c003b5b56ac245aabf4931bc1d0e5b32fb298c38272a9ccd005a3a9e80fff1f84c30a97911be4359d8518ee1fda41f5b0e9fe1035b097cc0d95a387a20576b175a52f5e3ac2b55872ba472b9e94adc49436f920e0ed23e8046f85646f7a789c1c3bdcd4dd7a9a6a1eb720719aacedee5cbe1bd28ec5ef4f818e10325929f3832244f61c6cca3435ce18ea1d901f0f5933622d532b5e9e329b0f141101f8ce8f26e308ce2a8cf3f607d15000eb72c0d27679f867042c092fd4b618da7a9cebe64dcce4cfe5274a6d8fcfdc2e0e12e20164c6b443f1ddc03ad4af4eb9a2317aebb44676d9a3b643e2d253b008607d404c54fb51c0e22f42854a855a8a318c85e00bc9266de3012fc05bacc7fb087949b3f430a244a18ea7d2655bc0394ae1f12611cacd830cd1f5427a367b0f4a7cf8b55fa35795a0ab1b8b889e2ab06a1523330b5b2680af4054e9e2db4a76048b6f72da7592382d3013ff814f8c50a0be0b3c5571e403977d8351ca6ab10b940cf673bc4cf796bbe7ba1744fd2fe3ede162a9b02852571ce94ef0f4b645c320d051c04e25da4026e4d6b9095c98435c4359d30ed8cadbad0aaa0c3e101e1ef9e4ca76fb6bf07a674c29ed57003dc83dbe16a3cc35c9faa584a4302d285e86e8dcaf9aeea254755ab244d90eba203d2997a8ba2d36263507266726e2d953e93175ca7686dd177a465ee52f28f7a75aeff8e997b6f8097be28f743742551d48e0a698f6bc3ae03e17ea72cc454742cec2743addb6a8971d250f2b41497cfd387c1b4992313e12cba8212a8c339a82bc717386944618c58905eb431d310965bc919b71206c02c430abd62598e62ce0559b418f0969af84b2300b28046e98b5e1e060d3f963067ed32cf480afe948d59c4ee4e8ebd0a206179d28eea7e4dfda77bfa8b21a7f90c84b8d45c0101fd97b9ba1e10c75df58e739bc681b42bd1d089f1449f76c5fc91c119c9d92cd66716c5626c6255c9f4f820a35d20f68b31f2d1252ff356e3c48925fbdcaa556977cc3e720c5bb4c3bf96049e620a228461ae8139f2d3a7b77dfdae00f729001dc1283ccb56524f3f571bbf2234f2a82ce059c24a727e4af055a542d555d4b65a0105c585267e2b2b33652fc8953fa85f44cf00941b1024dc76fb41317b83bdd50569ec746b76d29bb2fb5d32db1fa1d9388e7d3b057fb71f639807353992b7b4f474098a856d2c7d50a11f75e53efa8372aab8dfde4854c62cae081ab786b41e79d3eb826b14c361b6862bddaa458b1e0f6383d1dddc4311be552393425aa96dcf5a86968869166fc2c80ca0ad4a6b77aa7f4a17413375d6d8151e58785cfdaf33b67665d6d928f1bc53192b7ad9651f50d14c65a07661887c629df0072d3f33fb07fb070fda86e3a5ce49c8c9c50d3b55681603234430f581f70381137a090098777f2771a993d4e7cc31c5252cb4ff2344c42ed231e7132f5f15c4b0b261e5f4f0a5e54113051314e15c14d90b330afdfd9f5423b1fd5ebb70d59fa7536562a39fe7d035cfcacdb54649b5db7b32f22782d2b12e13534f074aaa09e18d9123be8b6e127bd6ae3b8740707915959fce3a64c5b06e7b7051de28f5c22e7e30676de0cc8c967078f5357b62267f41986f7e5b086d75a7d71893794c59b4c399513b79cf89b253b8e5e94f79f751f61","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
