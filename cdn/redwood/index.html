<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df44df3c8e7c582386601d271cab76d3fe3d059b86c1965729e4cd9647fbcda12d93068d43cd4183b64b76d8d6a1d09ff1ddf8afe8a82de99e6b94c92a423ac622f19fe3d18ba93274e75dd5b91b9eaeb44df0f443e2c34d7efcf63bb730a0ca13b0e71d2c2f8158736a74f06c53dbe2a71d4512c0955b2aaa6c486664d99f1f23e57ae2be5c7218da880ee3b660942f70b0b36888f5703e3b68ce29f09af035d1fb9441d10840cb3977e46e8b16d84d30c2c8aa66cfdec78c72677303c043811f3a612ed2a94c9b307cbb592876de9a82786fdfe6acc3b4e96e43202a4c4d72b51f5ecab75237b1cde37f8be6f592544cd35d7b9e02f598d66ce865ec76d680c7e43a1db3f8bc9119aeb5ede0dcf399ebea6101e8d2a081259cd1b3e68c5f2c0bd47f933e84467a67bf6a9ccb36f4bfa850b939fd3d40a9c6675858d2cd45f35615a49cf46a2536bb023aaa3f44a391be3df0ec4f071aa7a38c74d3ba8880583f96bca85da9f42306088f8cedfc69e90ce6ce9bc9cb2fbd6265f89cf98e2406653af28e24d7ccea910b0e5003c814e4a0380c68d8a0f524b50843633216caa134820a94b7c2d93308dc3e2d6133db0927305a481bc5c71acb110e2b3b75cf32fa01c18e4b555b8a1e18366afd03992434cfc85f7209b047722ac5d088f9e647fb4b3d336d12b53722e103ab38a06a3080d2ef4e7e9d71afb601c4009de13f5cb85f3cd66a9d233f1d31d8828ec2f6f36720390955d4ea906b2aaa18361bb7a0e18554a50984e723a4bd5f5f29c6150b15597ff7c5ca0687b89190724e6873a79fa66aee53c48964e8a2ddc2fbdea15ebb9786392aaa49b9ea1f6fd512d28213a861274cad636f87e5477bd364a0a47ea423ee9fd29114485ae893648905761e35456c23b1040b7dccca0f639bc943d94d1203551028beb17374184b355828dc50f740d5880e6050865831a504206b2ee61488153bc68e8960d052c564f0f0ce7967780bfa9069172de745efef96a86d823fef6429b94e06daca78d9a6cd8056751f8f3478f3c409b251e3b0a2d8a63a3df56767bd4344c89ee81639077d7bd6374a4e89337d8ba370aec79ad9a635d6dc1d4260b24382f3c0ad24d25553d6d47d05e5376224c49d6048d6fc046c8ace0f00ee7f5c748f9f668d62108e358d6663bcbbbb01ee526c447776e58af78716b33c1aaf06a9fcc0020b6e2340a5b4df1f27142da8a5a0ee18e569075318a376ee3d7d015e092226cd327124b211de7253bb8bca4359108c655c0ed4c53c1009448d33eeb13a0b9fa791cfe9d79aabc34aab56745396802af9b361bdcf805997f5e9a1e04767114bb9c15fc3cf2912dcc5e2c82149071fdbe0d3169cef2133f5edd5c4525f74c1b48b7ae44f49d4f7e65f87b5f9ca090c003832bb1df008431030b07ed91d5e4ceafbc894631d2f7205f450a43de0e7cac2b5cf2663e08c748883f5e310ef8029cab351c7971cc214dc1210d73c77c7ead7a8b2182bbef047208e689103a4a43de46ef962c98723f7a85d74821768dce8038d38eb9cc86bc6b0d2f51c571e4a76e68f219b0ba676a8d79f8a738640b3126d3aa86758db8c04f1c51459053be5516a0ead1334f475a731fcb40edec57f8df69d8494e34533108b180fd183fde13b8efcc925d9ccb9ee0e7c53fd63e9f3346df3bae25642898aa2531b3420558d762fc48a051f216ad717882df45b830b966fc2e1e29d6fa6dc4cd07f340bbc55816bac45a1e737a3b09034cbbae85ca233af8becdc80553060e0e1666de6c438b35fdc5cc4bad57f41bd6157b6787e3570db9f315f24144f5485e21acb0c7339ed00309077dc82914d985b92af808fe89840e4cf93b52c77e2655da4f667cc66f492e22e997f1685ba37f2a7409e8d8d451c2c8dfe7bda241bb41aa963eec702731b68e9ab5ec1a9e1a3ed105b68fcccce32f1ae6cac31144cec5dff62651c50e3ae5b2b1568871489f5b52df27d1964cf81e04672a441437f175cbd0589d590681326fa2382f9472735d299d3e797b514df6a629b074d9ea2e01efc11c08c812e1236a24cd5edd54b7faeec3e7512fd0ab1fb8f84b91a713723520486386ec065e5d448d81709740a4e294904704c640f6d21e9f3b962502d6647ba99457ef12cb66fbc5f3c454dbdfe3e8369d50b7de22da5749ffc119132a4a05151f135ec45c67e033c9c4c5794e63fec849f2c5147e72fea5d56495f95a612c7a0894d1b6f0e31a1f1a5a0c3819e5d65a51acdabce0c557bf6ca8915b1a3b2e0f408f0ad4d2fb3c2ba591c89bbc1165c823f725160d9a372b0ebf682994543526a619f60dff3ab4565e2943a29a8fc10d7405dede28a764537a48712931a76fa02253bf3f72f861a7265e015acccbfd3f30e093f18dd340b396e0b32456f3ca326250fa0afa278805231807f752a42feb0287cddb695f3704022b6813804bbaf92bfdb7e8e7b86218db4db3374a35ccc788e26db94f3474dd0f54d7e229379d0ff976c79a7b5fdc3da92811bca8e46abebc179be4aa4b7928c4ab24d8e3f60842eb8b8c478e2745110fef9616b3dfd66583b7a92b43d417f2d328bbced4fbbbae61fce5406eac0ce99a8a4f053bb7752a7747345874a8665a4e5895d4a0cbbfd9ff25aa34167d9a8b290a8285a0a25d7cf192f6b5b1c359ce3964ecd215493930c71a0dcc2c2a6f4f24b4b4276beeebf8e923e4d98806c1b317a8824e941f4422e03fbf085ace77aeb0d6537fa59c651a66817dee84ce9d7d9b9d853e761028abdeb5028eedc3b6b276c5b67dd8ae2025c966f61aea4b4c405a360edcdc4ec1b7f2d99c675b66d2a590a50e1e5966b238647e704b5fefe73de86fc58838d1576e7381d213470000c501bf762003fbb6a9e94eac87d8e9b668ce62da496560338c4cbc77e9d97cadd84e13c133a055f726c3d031a5b305c9414af1ac4e9f58696e7ff295f641d08d721e7e4842adfaedcd1d9e9a76f306afadcbc636d139aa7bcfa432834131f8f8015b1837afdba0681681562b54dfff2552af18ac1448826d0b9432e52c7e1f9d1fc0c3c64b8ca0876288d3544a0445bd6a6fea5ff894e6b3e252618f81857dada3e06c03aa375f6cfe942c61488d14cb1a72c52d9b6b1b2bccb3e00f7be3406a73dd08a08fb56dace4fb7df04fe312290716cf69ee1f66dc8fb62debb13e56e56b4f7185e614267636fba497336d6c990e8e572431c4f5e964da3bacc34b9aaf0df36d74789de3d83b74f7890136cea8ee94ef771846cd873e37b8d84849dcef7a1ecf1913f9e12e0cb9ca2c006ef6301305bc1645601458e61e633f31f3f4056156908760bd14e4d278ee925e9a5c0a3bccbf139d90d387abc0274fe7201520aba9f8612e30fa0d6c53564487a7f671d6e6ed3ca7fb4dc76676d117a6692d53deb747cd9c3e8e8d9ed3efab1e2640d8eb68b84809b323e5f5e1ba868b496d36397079a550a53b5fedd6627f7d22adcd5c94a140c6a926b5e3642565429219f91a7b0cfe5b9371e2ca449852e63ff39676847a77dddbb2e21cb7cbd698e0ac42e11ada60e5dfdf8a2faefefa731d758d4a4a0a02482e2b3b40a384a995f9b779989412784086b70164806f5ab891cd3f2899ffe70e5ede41807e8596fa0bda8503f94fa8f814dddc8e01c45c1254753557652c256c94aa3ed7b8d6534dd8c30b6f83c4023a829bc5cb09d0314d0ed0390eec67bbbd127832d821cf72eaf28b8a97dafc1bf24f55abd113e10d7efbcb3664ee4dab6a38184481f204dff838a1caf2054ea7db6638d5dbda9a0fe796c76bf4db75e7b332cabaaf5a7ef4425eff5ceb8e0353dd4c7cb33f8e2d6cd6cb710c2ab50a0c7fbd4d70b90d8c9928460db712b7d208fbbe789d840617257d3aeae90b1616dc17b14aaabebcc4f9cf9966128b89af31622d178a4da32f9c05768bc821e1e9ed1101392e2e28bd600e9f7267e8912b4ee60978c7cc2b7f7c17a7a1657f0b6ba5503444adadff253a68048a72636d8d39469a700c1cb2143ae626079efe8d4a7d65a52acb99c88aeb6f10e4ce89f2154d92c578a7c8a53ac082b101308641aed0fa166b746184f5de856a7ce97582c1e4f9ce99fa6404a7ac397e99d7b2624afa19741fec0f7b804113240b22c7fdc1715475339f8aaeb63f3412815c6cb73b1284779402f8cc0fbbd555c0d4fdd1ff0311b4bd5375be14d615bd0a99067f2ca4c7f548424ec10d12e473aadec9c3329d7a7cd108f3ad02451a85b5a0783ca1f9fc4593c4ae7684e612bb2ea67642a2783e3fbcb76b38856aef24b445a8614bacf832502478fcbe834ceb6a7659c6925416b6445d4af264fee8aa3c5083b338a7b44ed2d3acc6b245a6d64aa4380ebac2885b480c6b456be0445f096d88b1b35903b35bcaae1d24f01a33ab59331c474314be7be9c943e9b1c53f1c3ed239a7f182acd6c23501a510ea8ec673d0fd453ec7f5538f0f7964fcbf0a3ce1645696933274afac3c94746cb11a5a1676feb36943dbd14719b5390d9176ff37e4f3cc63311849a1ce8870126627ffa71569922b6667ad9aff9bef0d337ec1f30f5a24e7feb3abe3b2b566894169c2e362a395f167b988a71b6b36afcd2644610643200dcda0bb13bbebccefa7453b360cdedd05d48b682d740785d278faa513adade12d3690a4fa1328aca7e2e712f093b04bb666578f3e7057981638f48676b71fc836cc41e7307e046b0027ee7dfaf565c4933453eee7fd83e8a8320af05118516d2a459c7f491ee25e00006885eeef32d375c5ae6fec7aa4bc9e646399cced1727442014e383bcf344956e48b80d45328e4484d86e65b11da05de80f24def7e2d7a9df5fc6061697b2220d98ebd4faf66ac69342bc69bb23d48cda8d30514bd69c7f1d01c3c70fa6ceefb02e197e80bd3683127eb8da614b8b6ab8d782f0eda875db326f96947ef3e51a306de59f345eaa42741f5ee24ff1b96cd50f16c5e610cb5d4c35e9c9073bed75f739a61567a1304d79432631a3af34bc34166a9663b7b2546115d7b5513861fafb2b0715d757e2d9ac741a01711eb417b3cdf22a8f78123c6bb6fd078895b711ddcc19f3d2c83a0ae9c3888223800b84fee9e56c9203792e1876b9f2a145a21bc01a044a7909f1a365b8a028d71cda44c1553778b3c021a3c3e25cd183c58d8f4cc6bed0a5e01c93a014fdeef486c2497143733f393ee86de2ed23fccea146ac7640c4913780c0b1f4b068f2f1b3545107b6bc218b61767fffd2a3280d0df504cf15dae81ca03b22a6a45d8417800e7cbe6377f9caf5a718efa790480a5c17abe0e2d696ac32491766ceeb5443eb7ddf4918ff2ba8da3390649f4fc0bc7f4cb2f0ea5b231529553e2e5b372a5bff80765e95d59afbe903c75352f744a1cd263b504556e6dd78f3a8fa81194ba13a1670b64e146f272ffd30534528c3f1b656df8fadf76a3d4338361c478d8051f3466e6dda964c2441587f1a6f068386875c180387e04348213dc4b02faaa4c40d74eb26db4797821fbd26df15202a5b904c6f62a2070151d30cd936c102b67f37f7cea72204be7becf8dcdca0ebd1c98925bf5a912c79b530dfda70f8ef321e2fedb418a3e83446ddd28af975f2e0d7be63066e8cdda27c783c0b976925a2dbf6e21484f9a9cad7aa275f2f4280b55fb905c94f5fa7346d54ec584f3c8b846fb07c0aa0d426a33a65f179144e2638b98d71c1a534afc204c7ef92dead2571597472b9a7a883b7ff12d94945847fafaa52493c011d30f577b232ee4df14b5811598504f38a20129c3ba8029128494cd712decae1d4a4ab7c36f755e2d8ccc9b61f8cf149aa81dbc9655fdc89d9b8ac91e3960b8cf31e9647a0d3a7f1e4d81f687865217c740aadf26d409f049ef4c407c64788f1c01dbec95fb806c7018fe2750897a3915a47e96a18fb38e647e639681c4c68bd20d30e2f220b2cf5a82ebcbbc1e413eafd1e3f921d76389130fe8d3701c41bcb39a8f8cc2d144fc4c5ce9f2b2080a7a44282320fc41b0d9750ac88a4d7cd5d5b4a0e07f2a542883cb40ca8dd83e2cadd25db4b163e1193439a41acc316f40117832c3be90264e2d485e39b18787c550e3e5292b032683ed475807dac675cf58bb473afe06314d38fc6774703c96071618b39e9b9544bdaf97d9f00abfc18570a4ee04e0b71ca87f15ef102e2bbe0e7947357fdac94655efa8903edb2bf34fbf52fe81f7fe7d89078ee44fe011b3dda3f25a011e753ab893470dc34585864966b895452fc58141288729a46accd57aac66d5b47ee914c23ecd99012b7c8a7bb6998da8e21840f321b80bcfe86705a8c2793074172283efba3c0d14192f736075600b659a2b54c5e431a05c5b515e5d23510eba1a33994578fb33cdd9f07c9109e4128d87d3e867cd676791a13494fbdd3e53b2cedd0c068e20ee5a9902b687cb9d437e945f876f4551891201ab6fe01375fc149dc9c651d2e20d85b2c6250ba10f6f5df1178f997a7aebbadcc97455ea867e43e11de17146bff733a40a2e3867166ad86c9348c159818b152af0f4681aca70ba0467079b425e00e2f9474e006b7bf6d1f7619e6b035f0a9d39a8e3a1c10940ff23087b82dba8d92a8396eb56917bcca306b9747581343af615acefeeefb29c9874cd135ca56f13e7e12045dcb4db9d1a9e9f38a16ae59a2d4607e464e597ec9e558329818d6ce8fa452042f1116211ae69898db35c0c2e01c5ac31735912ad8b70ea2324204499b784e679b2b5521ad75029820aca4999e1013091f41dcc37514b55ab3c430d4140710f6eb485ae5038e38331816e1f2da12d89b69b3d327cd1fa75f779049f04a101bde3efd92c1111bc470f933060593ca15b5851d52097c9ff26392188f3e0d5a4700ee16fbee769de5a42a5a72b8e884db85c130a934a962b152ad40ab5b58bc738492d5dcee63e1e7baefaecd0ab9ab1178f08bc8653557cccf393db00e49bff37287c2ec27fdf62d3de47f6a52a51c983183347f9363689da4102173d7da0a7f1141c157e460af9661c69db617015e9d6c878135590c895451b9fdd9c9b9b6db5dadcb15ed0115b6e011fd40d0a23d6fce789a8532500215da3da8b92d2266459d4fe875b44675e2e667701a4c324eff5b4793792e2f15a18f6621fd081043594b225e4424120c3cf18a90032cdf0cb1d55ab493c4495cd847b46d11ad91e41118ffa2e01949567912c001b9dde34e8e18a044c9016f51d758a0a17b6bbe561aac395dbd719edf1c8a8b5afd545854eb3315b946f5e6a9e1a7e4b72cc5ba16e0e36ad8a252338f3558ea272124acd972add292ab58a6362d5bef56bc83a98a142e89aff6174cdc16271711e1e8220d903e926dd7fd77f959a8be31d441b82caa425c0509685a323839ec962947b6082a2e32069779860a69197b1bfde98401ae8e91ce7cd80dafa00fdcd6f890d568aa46b23ac765551d6aabf9ee9a6c302b350a59f5e8ff31e9b27c42db78420867aa7e51d0425cacac0cf17583b14cd16ce28d48d86dc45b955e020e5cea6d48d6ff80e14af26c0494bc37b3a34cd1b4f30993e058760cd5c307cbb310ba4c50184e986974b55d0adaa0d4778b37282e325caacb86657bb7f7faad04ec4ba52d23f5136331005f09a86845b1bce26c81b0dbe016ea467673508379d443fdc960058e1a970823b2d6ed5251e7d6ae83df51630e9b67cb22b5d6fa6f0ded639db7da973ce6c9f49d02c40caf8f8a269a730ae8785c94396942f27bc7647dfaa860d5ce37837b7ccb1e2c8d7ab25199f800994420824312b025391e1701f8fdb6b41bcc76e194a0e9c82a9bfd4eb53ef1c591aa408c162fed1c49b80693c24828699f68e8aa9580b1f45d934c3e75632b4559057cc486aef205dafc7194ea1cf0aa804f45dc48faaf7475aed1bda78bb6a6505ad53449f5d2a83ec3531db93692cc33f7c671fa3721198d2f6750cee13ec417349b54e03689ebb5dfd0a11cc2be977788c78f1f415f67ed85c888ce20b83a74400fc7c0e3d437789a9f53dbd1bd6394d770f673130c3e1f36f9c58ff361aff86abf3988654ac62b3e44d3d491bab3341eb1dd14bd22222ff3ab82cff9e81845e5e9a06f8e42c3f68f96bda0ceeecb15af288f2acd39d226342f1864978dc0b2e128181a5ce16d1a7d4e317a9de6723e755a3c317030446d62ecedb753e6610fa9d722fd50e1313e54badcfdaaafd366b5d667399d697cbecc2ea9ad3e9d7bab008752027e61d95f6d22642ee7ab9a16a28496fcaa795f3d86822a63ca9718709f919dfc8052f0dbaeb270cdc1552181508359f860cbe178b58e7068264b75c283933a066178485ec6a721054b04e6bf68244396a8d494c616c4ee1d6573f04d645bcbb7eab07e7cde9ccacc6fd4c28033297b70f7ea67077c91d2d589891760d56de372b5d011e4133ed32500548d247bf3990fc638b349d871e80daaf6b2bc1a843d49e1c5dbd0aacbe47d207fa211ba43e8e4f0e81760c7c6d62b257102a3c58dfeafe32bfa5e9ef41285f241dff621b48b5c34d3fa545a9c77c1e5f785859005ff676bab67a9a4ce5b893fc6a02efcdfe2a59071645329f3d6e74b5771b57ab09c84ba5cc0fe8f70770e766a3e2cda9a9b6ada7612b17825ca706ae2e4e1e3ae9a75a3d3eac583890b5281ccdd4373d1aae8cfa1030180e080d6d667d65ed2270859e7709afca8a633ccd1e1d7caf63a5e2d6964cf029d7cf6fd3ead1d3ce7ec41fe2e3aa0f841a6e0fa1944f9cf95dc4fd440956540024fa2f794ae82f571c045accea0c38b66db5b6fa9e1f85042721b413da7106014c2e4e8236c48568769b32f8be7ced53c43eb64477efa4e32ed3a9def39e99801c8d273061aecbf10c908cb5c2b6f9a88961ece7a78b33c1a50092ebaaa6040821030559aabeaf4b48e3571b8a2f5614812b078bd811a1a2980b726fa6bde24dabb091a1cff2b980ab1bd703f79f022d4cacbab634fe0da9a7a874db0cfbf8d6e4c76c44df2f1898735f3acdc2e8c1413351437b42b39ebf140ba45e7aa29e92efb04bdf08e216bab1e57ffe1bafdb258a4ec575604834ec697be257f8874e81e35444c85505b18bac447b5120eab35464699817c733018e7de5afbe3481d60ea6e63f225ced4f7a32948a9ca3f901fe5229a2948260d01d0a4a59c5920c96bd4b3dd31cb27ccd58f88b583e4048a7239324f20eb6a6785cfb46dad27acb50349133e5e74ffc779b261d7d9ff52db17fd45011a730929bf24e264587244de31103a7e5d6659552fcb7ebf58633216c84cd1ec3666444fccd703bb5bc8f5de0f7c87fad71f27e2224bd6a8b352f28e2d78d796ea79a2acfcd0c911863592ce5d507d3bf9559936e26264af852ef681f67110bdeccd0547b5ab55beea7ba53f8bb84184512839a1bf625889db7bf5fe60b39d11bad0fd04e50e782fa6735b8b48857a054801d9c348bdc8c1be61d9792d5ab6948963ba0cb7307d4248752926fb27b71c8c0ac203a664393c9542847b2b7bed56f2545d103512d61dc2b82786953d8c67c86669779a65ad301823fd9dacb38aa6b7373d9b90daf4d7c3cc1c1dd0008532e931f04e527a1f4e5bb4488cf43fd91a56e60fb07914a1cf2173ef125841f886089e7efe054522ff9f6a7c04e5f010ba77b6599e6e92e1ac011cf19878aa91fa36f236d40df2c5b6ffaa3f2591fec444db0b22f7340a9a36df1a53723af0da2c2e1f7c83c84665fa2d683579cab3e9d0933976c19b2afe40cff3d0bbd4336527b7583515e19420219972f1af0ab9535ce3ad98537c777c117ccfc32b2b0103083492b1fb766267b04431309be269a2f36878958ac229743f90181967b68724c02b977b0f1455f3f89b41619ac6653922f5cd84ffb6b67ced9f3d3a002f25400c77e531e6444e32c2c18b4194a0c706908bfbf6a9046425f2c78423837e37d42a508894e3886dd3bfcb75db8175b7e23f99b0ab17f715d8ecada94d04158f93a284de5c3f60ceb42eb80c4850d5bcf25828b64d784ee20c1e13437805ffd99ac08c938e8556367f618111909363119304d7b5c07e6ea19bf3ecabf856cfbe6bee809143f087b1950a5e9ddfda1f77ae9b88c913fa2d68b9a30980af856f9c93de8f14e6b802953b72c8ca4edb6c08d37161de8cc5361206a92e6059c9fe328a846642a5cc7965a310cf5c8af2627c77bc2983c5f71c82f6ba39e4a2bebf3d88dcfa67c1aac4680e7dff2e630e8f57b7f35052a4c9c093d678700aa612f60aa2b54e497fc1135efd9368a4307cf3bc07e27d042bf08cb9a83d982c454caab42347d156145d8a1f50ae2e243031197dd6f377c020b032e1c763cfe1df0b0465d5b2841007c03faa00de8a05f03d61c864ca77e8d1696d661947b491f06544bb1e9a3236a3effecd4ffeda1fde3ddaf1c9a491150b9596855bff23a51c2aa93d1d8dd1f57abb5ad545541262ed23a71d9f7d47c035028f8ea369b61af792c34f45f71b50e485058f3e18c7f6182fadc081653d88fd3ab6f5b590e845ffff41278b5b0a1d01628d420145d458f553aee72bfdcad622c9ad9076564308b936f7434c6a75538fcbcea93aa733870b83ca0ef509a0426b08aa58ebad53198437dbbe0be22572cefcdbe92347b7a971e6e24766bf7e979d1f668dff3358a977b4f799e3745eb884d39a457f600b5e74006298e24554d56486257af87d71622ed06a0bb1012b05fe24639e9df83532e07ab51c3c197a690b9f1a25e545e6db95f84da27df9b6aaeb244ddf22c5b1b229153cd6e4dfc411990f78832ffbe5f054ec3667e17479789ea84ba88372e6a210497b307cca3df869e339a81d101340c963a83e21a4941430afc7763c3d6268f6a81390113ca3d0721fe53584d31dc527e1bd17c7ff56bbef4afab17abb2aae6039aaab399dd58b068a0ec8774258e8bfd69a21ebfcd79419c60f960839773320bbca42d6ff52640378ddbea9563396f93897dc803dc3aae0763f85ad5f9342689bcdbd69588c4f2da5314cdcd320bd12942f52e7997c894aefcc833d88f71c47e7168a1d3b8d696d70b3abd481c31a002dfeb9111f48c5db06546e93ba5c969ddae1b4b19734712f6b37a9b0860cf82a9fe1b66a4ec0c93ff93534abfffd5298d18dba00f6e7a1babc294dfe66430e05f9daa5760d2542218e5097d25c8b11f4b546c02ae083b7fe8ba4342150d317d66ec74687f67f45a9695612b91226421b95b9998b7c77405263d77337220ab8f8394c1a54b1dc421373c5e5b3e2040be6daf25bcfceeae91bbe585d0b170b55e21d18b65b86fba91a1ae6b34c904a8bead372c76bececff05b124072e53d15adf3a9012758498ae30ae48836d35205888b8f3b4cd97a69e4ee8931da0b115ee37d27fe3fa26a4f66324f4accd90787e9729d534d0a6d5ce4c73cbfa1378f401d03506ae13f2e62a1c2cf28b11b0c74e57a14cc8fa3457f552e9298301735622e347281a71fbf84ff83349cd55cdafa5805f35b6cd392739148e2e977bfbe7b8766d837245ff04bc0db8d8ee32de544e20c0c8d76e668e390e04bf162aceab75284883a0183441968450679464311042f4838f065b4fbf8b33e2c3718ca45cfb4642ec6ac4f8e815f3c384f00fe6c328ed2b9f892cbc4184bed9dc42a707be19154bce123cb117ce4c22aa5349a3642743104a08af382d8286bc05e4df8b3313e0f1a3ac3feb3a6ebe8e97f84ad80c006a8673d29524c9e097dc3002569995b923fe4a9d758b93fcce5c2e36ae87ec98bb83373c2b1f9da71af12d99edfc99a7ec028117fcf8ef34296be56a0109ca567630494f5bae459c9ec4482d94644161c5bd25b8bcc9c2735372a2d479139caf5722553d0f2e9a049efd8b15f8c1a04dd9d82ce23a687251c8dca40b9de95308f2cdcb06dd80196f6ae285e190391f40a286e10541ae90ff8b1f9d1abc73056bc3d87e258ae70b626a883c6bc36168f2b17fa300f10d27ffc8a1d09d85d8892fcb74fa894890f4f24fca3894fe8670f24093f6bcda595cc0c3095be58638a4936e98d08e422eae0c49938ea1ebb4c53761487a66d5026ee498f363f22628f5bed68fec998f76be36249ecf170998ae3d62f279b669f9990efd5110c3b1065dbf9cf7dfd8cc9731de517bafb2b4f90d222a5146d8a53ca1625c5aad4891e57841e76839641111172af09abdb6ceb4d888c0c93c10ebc1c164b8e8c893e2b3c082a9a54d7eb58624ace0e730bf6aa386dbc29bedd01292cdd9be3153933dd57407cb06b19d31538c3a9a85be705647686503fa40056e97b79e10cc2f0908d120b70319b9646264cb4b19d34352749a7fc4c66b6868f14293561003a4259c6134789b9ca574cfd5492c4874d23989ce6f5843c53891523392d44d7e1301f6f0453eb3b474421ead66ccf7a31878303a08649ed87f7170d6d11655aed5d77f9f9191617a5bc3b38ce4fc0e46550777fd89ee9941673b62635a0de42b92c0cfc29666b3b591d6adc00b5bda46ea8330bbf704f77efca7e630a4b4d9675837ee81971dc70742adc01f7f206557e44b7ece8889564bca51d9976f5656bbbbe63bfcb9c0ed80e8724faf67e6425f3d98cd94fbee48b48680b47d5904b43bcd3bb8043aea9018828b8a908f8d8e13b8eb1b246294b78ae198681ff36eb0ba0dae9b2e7925429c899fa7632c75094f772a2bd0c57059f044abe67a8139d3a8e8e1e1378b6fe32cc138b4e095023577a052d0a49f8d7173b64b982d10c30a218ba3991d72de77dfe152af5a66ce0d0e826e3f7c6d2b599d8cc60be28d464840428cd1f11627be254529752e0b6b73276c5fba37f3a3d3493dd968c44f3727a48f49208f82f80a185920c12c6d4bf689ec3a0b29d1fcb1920d4c0485095eef96041106a2e5093f315496e5d99d6ea48bf52be2aeb47fadacf8a545a3a38f452d15e48ed8fe1300eda0feff081671ecc08809e8c294e6c5918b367b9e49f27142677eb8ded3f280ed1d4619d45011fedde5c24cb86514fcded166cd7fd36ae12988097625d3d2b58765e07a6387360757ab825a9e025a8d416bc2b0dc68644983b682f1bd97682c599651348a5a438d4efd5dd30425852310898babb8c1575f68c354ba0b21be00df2b3d5528585d0be86d827aff7dbdc7e4d664dcba32002802729c3fcc4cca01f38a53272b67d078161dea23833b4a673cf888b4d19fef6fea0a6f01a00c84e2c44698e8c52dd942ae8712dd635810c2ffc215138b008c6dd40c2789f27a856cad7aaee7dd73ac20ba0a77e06e83576d8c36c33c4d388f0e8e29c3e3daaebfe8f5ff0f78bc3697d031df03c5e1939e51b8ff2cfe1ed034d75bd2b1ef06a1c63edb872fcf9aa94077cc2227e38bd8c315b366eb0f4f04c25e602277b16eca5661788588a92fbba684f615e11b70faca37afed482d6a155157bdaad293b8328833c682b84910b856abf7d5811caf3cd29ea56da7efe5eb48d0ee1fb032a512651e665f2545b77dffe7d1602919310a2c5751f0725cbbf42107f44f2b328f050a4418d521e7b27f7e2bfaf2510c29937c9d39b1dc1c52d77528aa227928182aaee544abbe563c835fdc5b24350ecf1aa08d397f3444f401433ff13baf1b1a9b59658b3b5a1fa165e978cef4de055d5ed1a7aef42fd0f687a5631dad764c908f83ef645495c1eee97660794e8f4138579b85574c32c74d97a83eb242f3a820984b09fe032c7b2edd690366541e9b89629348e44345f2053f003b6c0982df98e2b7c105b29b6023f2421e5eaea29e1a1658bf19cf82f7265dfe4a824a60ab0f46e00cdf783f487d9dcca66065407c66197af8eaa798065eccf956f508b774da0c5ffb1382cb821abea3b281212ff59fde833ed5472f0fcea8b5bfa752990885db717bab31e9019415bef49db0c5853aeea92637bbddcbfda3d1c2feb9f890e57f9f314ecdbb6138951bee47b7dcf6242a0381d230158efac56d06314a4bd7ed9d05831fb2de5223940f5a283383f393fd57c3a7c770e2546ffb725c2d1271d9bff3e391d2b883dc207363e18fca9e57cbfbb1efee0cf8e518650ba69c5cb857745a3265205690b2ef4a88bf07a2f40b20e4ec1126c95d14dd0ddb0c8518275d24e41bd4a6611b2c1690b068d0e08ca01b74bd7c75c7f1e7ac4c8b3c11c7d6a8ebf6e6f3c6928fe4ae835d47aabafe5f8f685d5f0af762deafb9d9bea746166e396cd7676052ff6f4faddd3a097a4654847530a7dcbe33612c1f22552f91bba975e713fd898db4e7b8c8164815c901cb47224a0d89f8e858cddeabaebc60ac928dcca62ce31b436b63d571ae5e22222a8a4a3dc442ebe5ddf6f286f8f22142f958ded9277e0b44727a08a801e1e4812493b44979dbf1527994ad9e42e13877483c599bad05ae0773976e7842fe6c8ddf878a4d1748ba31e675152024dd55e7ab78fd6bb189a8fbe7dec86dafb0e0af988ce1cb26587e76e759f51bb5efe27e6f1d5b9f15d54fa2ac23b7cdb8f12407a6b644e54887a510ff6b4e62b5eb445b4fdc3665314da2108a960afdb1ea0c55e9a0554885d5d0c461a67f4f6ef07f87b40d831fb777eaffa2eaa3f4776e3847b6dc3788079d353fbc47cc9a79aa7146a7ff88f575a952fef66812beeec6910dc7edcc6485ce7caf073e0d3d391e547fa00efc607426c399df08c2913fbd1a2c7ec2db3b2c5335e7a1f31108b807010b8ab643f05e1c04b0c88c099b042721849338db4bd7341a0950bfa479db11a257611d3add353fb970a9aedf711bbc4768fca966cffd22b9bfd60846d1653e1f80c3f6afe5c7bdf3dc29630354d44a80973d7b24ac69eb8a883cef58d6c76c39b0978b560fe407c39161e5add60d6fe875582e2732be5aeea6252366b2a4470ceba327335812584c2d361c79d3aa2423f0b7fbb37ac18e28b8210e5d79a6621a8bc1cf748d3a25d1be65d5c1781225c052a6ac426a72e9f059d9527d7d6cf48def2e8ba3637a36180a7ef326c8594ae0258d5249eb1faabe5b0dfa87cceb0edabd57fa48af3a0c7363f75640737dfaded1e173fec9dcda7ccdb55df0a21d826d42fe053c54b8467e55f9c397ad4450b61a9d20e9f8b6af415686637354501dace6254c7e9dbc875f7a26cba7bad89477957845acca8c5292baeff14706f6d1ed8b67962203018a04f5b992633a4e34f67323922df42d958b4233b709e9fcd0f1e2478ad5f6eae0aec1d8bb1aa6630c3d0c8496a174c5c162872b31db553b7f3a857653ec4c2dad72aa27c4fce2028d8451afdfa1ce57dcf3a451d6a32f8d7d08b8377aee33de6055c986c87a2e5de1d332cb53a70be17ec3d35eda06c585a17ff33da2a38e24a822e60fd126ae4fe7d1b5c17ef02cceb920db70aaa238c36102d5a165d0ac152ed37dce2c4829c12f6eee428db8c427da408d08f4b31b88d9a3bf9cd11df4bc3bb28f7b0abf151765c2869ceee0a06124b63b71f806fba32fdc0cd846702dbb4e499681f90fb3650d5607222cd51813767b1d89170aee00ebce788d7fb70252e02bc6cbd43c3776073f6d54d8687343a3742e23337382469ffc13ce6f46a0be97834aff78debd152213553a4d7ddcea99ecba4caf8568651891671726f5a02a01e80decd3fccd3e11357c51cd7850764e83b000756b08820eb6d8c6371c6f5ef32891cadc37351966e47074924f168ae3265cfd85a41d65683f4388efa98fe7c36a38c44d30cbbe2b19300fc83cd79d404825d638ad0c363d4ffdea6a828f6e56d6b047cee204bd9ce460c4928a9cd1bc2e162f3eea564945962bada1171b6d671a7e23656984a3a13056398d31a0bc5978b64e7eff0a053b1e8b4bec0788c1dd4fed22df126a87d935efebf81e53c77dc628c3ded359c6db3a9df16153f61564d3ba2e7b8d37398b9b8281f3ef778d320c13a5da4f16d8020f16a3bea1dd3978f2ed9de18d12f417372c01437a9029e8d3910c91bfe847e9b56b69b9dbb95ebd13ab7b0790ebc95753ce06c597cee4367ef4f6a9cd5113ad07b924d45dcc950413c70d5fdb8accaf5737edef46cfd41ead29921adca6bac6c298b36e3cd5c31f66a5bb5a89d611c1e0a393f1218c622907319b66331b31cab807d1452ddbe3a3850df36c774f97dd2e6a000ad33e4b129e0c639ef9d59cb253c94bc0e57ead91150d6f79d079bf132c5ea1192833ceda8b892167ff4ff611e745843dfa74a5a0814a45a7e9f2ceca5b99af74595ab360f9eaa58a0c44846b377262cd41b80786521367fa2c8668f301a84c9f984bf53053a74bd61464a6bcbea312cd7406eef4b647f719ca76a7bbdae99a595d2f522e17900b8026e89c8072b0b4a1d9b396d37b185ae6b7b0c49294af795c85a4ddb0e1b2ac21b2215054583110af056e64bd0e5d62c0b0bee984898a5d527a85562d432f318909d1379919b7d6009465cc9523479637412a0bcd499afa1850047565bd22ce8982857e5ae7b88fb59e0941e3c70bd77e87319dab4917c71e3845559a1bfefb0c73558bb6ea249ea36c78d8babdced40df27742febbc8006b507a1c553edb517af67af304b091dc70e45c3542b1af24ebcdea3fb40ef518e90fe25772b02fbd4cdee92fbf2dd83849f16f21a852dec4e4db2f66fab8798754227d6e7cc3a215f8287432cef3747b3c4280b08e02ddba1ac931c4d27ce37ce87150f1fc2c5d8eb8f02d066c370f47d6716be69e340c14a5cdf83f7f45d71531fda4fd9ea2ef8dbdfc32486798e6c74abe0878c69361fb339e47462d978ac8c98f1fc68fc47fc6a8d0e7d7584d1d998772e67e6710826fea2419fffc59624bfba4b755add3ab03fbda163220df3d0c24c8c4c49f451075bf447c74fbf223870f04db04d9780720534c3427bff9c311d8b5d9c0d4a6938c1f80ab3546f7c50aa6af6ff2f5de395ea57a2007fb6fcbc42d7279ae6ec5c773e5b7e1ce445a8b74463269f74b939553f2babd0e9728d2e31fb1240564d1161984023683563f88a64c0072db07cdcbaa239eba1b4700d25dcfc270a793aaaf8d9e36a29bdfe54b19a71b1c0f932157316189b1b1e03a380931052530e70e4b335667776c6e23dd72ab71ae69a15ec58f70c199a295c480894dcdc41548acd138d09b0dc08a29c1ddb5ff670a55ab67592d9abd5e36752bd615e87af78e4f8395bd6eb6536d3b4ed0187fad45fe95eba417ac178354ec4319f844b5a0449ea1ab99c04ba2b771d80ab3c5ae9e12c4f851c1efadd4b8be7535a37ad26b16c682d3554f147a6f0f62f760c296e229acc1062d9382d7937639aa4458f6eb18897ed2a90cf99400e421a1d999bc267158a245e3121b2cf53895acbd2cc1e3fd083ff1863e2f38c29b73eee6bcb7452783842124cbfc5f121764bc046e426a048e5523c6d4ec7ff8790efeebad753eec601eb1fc8d20b6c9739992ca7e83d6b70765fa4ba91ae74823d14f2efc920f3c6d48b885797243b474e271583ba16d74d71dae93ca3c271d896c6bde62cb402a84deb85c1aa1f669de14acc0883c226f624eb0e318e69a33d853fba061d64bf5ec59cf80496ed9bc87a6914a5b879589e64c2ee7dcf9cad6188a23a1c7be8d74ea51830a15617d3fe63c76d630dc5c0214ef1dbf4a78774500b2338198d31562be7c2d758b4c581d00ae1a9d56814da4087bdcec95b2ac1a562a36df47551028279c4c5136279880f046a67b8ebca9decbf606178f161bf5514a0eef2fe092c40b28e0f0bd5aa82bbcd3003d2a58e8a0354fbcd12a88aac4dcc54e6dd53fad356cc23945ef4390f3f1bea9cef68f86fd3df347d6f88a9737f5d90af80b6f55e69d82c435c1a2919858cfe2397c6c7563974e9aec809cc2800cbad5afa244f24d698ccea1d4720f929423ee08d8a494f081ae41995170200afc369b9a8918ceade801a25472b66b0b16402242a12451f859a4c5e21cdf65cf4bdcdb21af3ffe1a88299fce0981e080c769474e97632f8420191a0d2ddb3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
