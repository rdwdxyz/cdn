<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e57594749f4b7fe730771afa1bf71a811f3c1842741e0b9be426cc9e8dbcfb7e4462f040db3cd13198e32f59fd0e8030612e9a8dff96356ad4e000f3d576a3d8112e6d43b5603d8d43922b2839229233c4b1fdcd2895f3bfeeb6e799fab94658aeea5b221f11103d586c13eae0b91f179b522457e057045b6be0384c7c9b27ac824169ab1909b080644073c964448dabddc108e488f3863bd5cc499439ea9a118dfad163080e51d4cb827d9d7b713528b8eb4c9464d76768a730a5d6d577274a3afb375d8d3f21c6c31d7ea17fb33af3ee4ad2515836015fa4c0c9d095f3618b1b572d5402ead5862340cfcf701d5781f6bf965fe9c0ec5769838b3fed231ec2091347c63c9b7298b581f50b8b62efaf2baa708f557ee4989ec671148f9b6d5615a1b900f574aa6f761779dd4ee5f15fccb88e9450dfa133593f2302c35d37672ee23e55472a4b58c357e0334a9550478d55390cc2fcd187e69fc8d9b8f4f65bfe238d527c4759db9a5a22b2acea24bad5103217445b0ba55d2eda8aecbd59ff80dd7709d4642c9d926aec03a7918029c76d90b1d5e3d0c5f18a9b67d84ee6e8fc0bafc99d79cdfee6282c4a8085e904e14c337c7a483a39eff8615cd8073f47951655cff89c733542a6d508ff832416065757790c2f3a51411cd070f805456295568b1efc05ebeb340ce2e651c1bb759ab002b2b786aac4bcb1ade26764b74a9f708f849d5934ec4201bf46334fec98e4df101f8114d6a1070b1002fa4ed55165a37bfce9e606360613298f7c57d0b90a544682518ee09c3d2c974d6da91db681f980e1586a989cefae333072fed18cda6a65ff319dad6c68d7d06caefa26180a0f3c4537a8876f2eb15d2b2bbc5beb88a47704815df4d0e269ca91ef3426fb134b3d2c7182dea18ae04bb0d9d4697d60e90e7042fafc695831852db54442fa401d8325f4cdff03e942d3d780757c64a3f436265a0d0897dc8a624e1f2e5b0fc0e37fce1c08caaef8878fe7005e8286547d2b893d70715a4c8e33bb4ad98dc7b3551d0bea4b2a52b58b38b9965cfb5f5bb7dc63a0053b946c303855e27fb7a74e485368c441353b4e8f11270462a09753a85b0f25a8e81f4c2f104228d3f7250d9cc6faf2a5b458423d0a258d795ed66e8553eabe0a6515f37a475a4b02d5cf17cdbf1583d294abb46b0149f3d2bf6e297fdd56d0efe0b0d9d496f8ec12313a1b0a9d575986e9a44ef43910827e8035fc5666817b74f2f4ff4f9efd0dc86c6f5de5158daffa7915613182ae95cab7110c63454c1a0b1c19b1ba393031dae527898362ae741ae5691f517041fb9f54f8159f8fd991a41f515f0d811aa7cd28db9bc8553853aa2e769d99a9797099246cadeebe43bbffeeb01460e879efecf0f17298b4e17aed2cbfe9a390ba46a38ddf594e656db9e25f43cce088b2d5dec84e83e52117423139c4402701ac0c253c5be86debb927732f37dd3f6e530770ee72750b197919103a68189bd082143bdcde4f8f43e9b0bcec6bb2cd0c83c423b1ed6c386c0a1894517d15259d2bcea1aa0a1509125d7cef14be0a09d2abd3b3c25a6dfaab8c9d9eb3fa67d3063c9d016a7c4158c7c319b5a5ef8374268034f35cdd2493287e590fc611ce7e2ed93d9bef9bb9926006b7869fb8a8bb1a61308b5811b248570b485784663d9910e1e3c94614b851cdd4fa3ab8f1ab80ffd1ad7de0845d5abf741e9a5a07fb17164cc6d87825f303b7bbab93427e60654f161b105c22b1e6ee1207916fbc653f1aefdfa931d8a3c25ae883d878f11915d42d6460f7884e0ce6626d33b760dc72348db2714bc1566804ba34ac8a631c72e8fc424ac5c2a5118e1f8ae44afc85f72b08131499a1de62210c6e2c2b1fd388d5255bad9367fc392403d6091f4534bb1f47853ab47d7b914db1a6c6423a5df8a621faee08519f7318845f618d11c8d446ab2d08a3699da93ae5ab7e252c645d20505c3f1d26b610cd3fe7599842933df2d690f8d77721e61b4c3996202f25eaea02b774ae623f66ab468cb2ad7e7b4ba2735817bcefebf596704bfcbf637c68521cbe05b7e36e3177a3f2f96aa2599eca71aef36fada8db9d62f5e8ab76bd9753a94b0159431f39ef7d6d93a23ff172b8a56b784ba92b23ae1cd3b5c8fca90ea50fa74cf2895fc9137e00bbf0d160da3fbe1571824f9d0cd25eb034b868659845245579ae3df3154ce0f83ff0812c482671a50da86474179fba098c51efb2f4ba8ea12151a75c02c8ec89517e1dcc0eaa0c098f24ec147109b957e00535b5514778239d4996bc50485b4547a2bf525d32ac6804f37a79550a449e3d2882c92389191040f0b6f2784383edaf5f988b567f43c8f715459d8f9c4fd9ddf8a6dcedc1dcaddb4cddd27ab9a98c7f6bae555d078c4de3de705c6c5d04079034bca1ee0efad11e6fcb72e3413c024c1858c3eb857f9f3d8e795fa4510510bd577029690e133fbac29aea3383426c37f8ca86b3607ce25fe418ee9669ba86ad40d090e90d10f4ed5254f4ffa87620c4f39c4c789b39634be0d153f1a4a17416829bec067bacd063c1a0c9f1b50101b8140fd3d99671655af84f0e6296becb39987c5ae50780428041fe502c7a1c8eb48ae1a53202bd93f5ee8aeec8a51a27b7aac8df5a4aa35e286a98e86ff14972e9dd3b48c76198ac0ab40e51fdfc55d7023b3368695103b1e87676484155a407e85576c49b9af60b0f4352d252e542d10596ed990f4943f9c9702a221c9e593100da16668ebb139cdbb79c9f81ef278d6a86440fa4807983d826a13b47974bed7abd033a5c0e1532503440f393371a0c9d56081d15e61a88f83adf8d16eece86bb05309783470ed81b27d51867933fbe3381bd73caf4bc6e22d6fca16c7843440415911b01b161af3bb8afc2fad1e78214f4f3b7431d9089904690227b7ec1123a68b187c67cdc77caec8e7aea34a98140d2bcc33c9c4d1be8987f819962baecd3b438e9c6ff02ce612431d25d93295fe6434676f2e43132488dcb448747e075363d16fde00a0581f2fd035f94e6581e1fc2c9aafc3e0470b47b18eb4d8b73aa516d1bebafd3857ca63f4da82d05e4982a89b75b50f85c263dcbae38a8abcc5d36baca2c746b91ee9d1c41837f18136fc3fe006549ef848855d2b28104f4a13fe6f1069c380d2675b225557d83f4540c6915d2b93eae32fc8d4e6cf53ba0432cc7dc68a80b905c789d6909bbb38a21de9f2892bdb24cd6a007b5ca9c6adfed823623cb200ad9c7ba10c549a99a707fd2a5558c6833813d62dece7b777e659980c4d50cb71d233e63e41690ee31b92fa3c464c144d9d2482dff8c68909c64813765ee26c0521b56f1c513b96cb79f2f060b97be8d38e3cfbadbed56e6ae13fae41fae267acd2250f7f1ff659f60aa86855b5cdebf2b5af4a20f9ca9018c2b875bd7391d95d162abb7f3d45c6d3447aad7709f0c32038f148aec23b2d22a8b714e214960a737a5c60722bf0df227613232142085d790ae098e4d557a3c5986de24c0bb370b75b3fdf579933061d51a251178a34b1058ae3b84a11220d2cf433ce204b608ce279a86d84e96b166c0138e6ec99ef84d2cf118fe351cf6b261f69835c6d616e1d82d4d4ddc358c2bda250113647aeb4997c46d3d335e054e09e2122354300ffcef4962c043ac9b54d6f0e9cae7e90605b1d0aa7a307a8af34842e72e7f8d2a6b04b74bcbb65ee2327217e4e9eeda003457f3f4215093b52e539fcceedd54d6239b7022a46534ccb9bee8ed25d90b3be05120f9d3b8411c3f0bb8cd2f9869ca13dd0fe47c7c93fd31ad701cc655c5861adf9f65f3ac76d0d4da5947a5c8e4bf7540ce40fddb005872dd67c0031db561d3f82937a593376939d0da75abae85d11b0751b96d407df2c74b88dc0e114bbb1c728329bd977a817ac9a6463dfb2de760ba899d0ae380f0c553dac75a5528a2fb0fd7eec719b420b187a25b5b93b32bb76b7f7ec42d057598bda959eecbd0371618b1825a28812d247d5d1ec29336f7a44a9ab4790bce030a37ff429480725369130576730b023bd962a99495b1fdfb00a97091b6f0135f20cf41aede7a422b3d31845079cfa8726bbfea31ae908b2b976d7df6689127e41525a7af75306e4bacc430048659512d9c8bc214f04fd5767d6d576d1de88518b221751b5bb06ed085fc396bac151f4084b5068f68deb564091f4ec1cbeb5d4c59577a2545154eebe9fb4a598d8ff7c89e760abc10db16a0204982dfead2699aa7cbe9082298e7d179081443148a0878a468e452063d95862cc9cf8ce3b4731f34a0ae1499f2f871221e3fb20e00794077e4d1f0d64e3c2192e1938bf02e62b2168e923cdb25f89038fb34011ace81c0d0f4cfb8aef7e9ea762e5489a0ee44a4f64cf8cad08fbe1970f0eb1c88d403f7720565dcac6f91e5103f48160511532e9367303612f5322d5c7e16bb12620bc4760f3c917d8de01e645cdfdd6b3c4a97f743f63d1d1d15a782fe7771c5c746ad0dee7c53ef55f13b81a11a7c4d24779b8d929c0e89b5f90f5c268e408e5acf829e4273bc0c20f28584b20f1402f0c8062e7123800cda8c49ff5728cc53f9352f4dc2211eb5b9a765c35220ba57aa136f50a8f74241b1de76674d9b737aa71f8e6435bdad5c6f5dd54aabb3952126d81476ef05bbf79a30a7a2becfcc39792ff7ff06547c73547cfee1bcdd9043b55eb13057d498af78bb758a379302b1952009e36ecd2ca96678adc53e3ff10f36ffe41ac893c3ddf02856f4d7b24c80005f687af346c4849ef1429a0e50f516bbae09844dfcab0717fa308d8afad19671dbdf60e4ccf3721a1fd7a154fb822ab6a28a5115a1b6a19e913273c0659941028435546715808f04a106b22cea28d868ec87a60a981f51204d3e3942243d0ea1e41da79b22392b0b7a67b45c1510b6299ff7af9767f90821b45f0632fa7e22252b218e0cadd4f094f6b3cec61dbb790a427164530ed8a1a628547ff1adebf588954629bf0f36036128bf1f536436bb034db6424c475feb5654d3c84771beb00747e93d00d8e6278e1cfbf4018150831a93002ef4dc62eb09ee22c7542bf53674a02e3755fc68dfa87700903bb4f0d007b687446fd23a57ed90a8680ddc7f24a375364ac1746da435df0d17c2cb382b5620dd84bf92cd4cda3e6d46c0d099f77b1dacea987ae40d2c2b2584db1c7fbec628008f54ef65b5851bba01006750cff74f6447e1e44a2bb01919f84e02399fc433ddecf2dc2f9d877d201bdb0e80af89763712b03fb50630d0dcf1f5d94b6ec57fe3997490b202de944f2bcc82c7b30d275f9d581de89693c8782890dbbd4b17e69a7601a520f427091fa34fede6219a0ba279cf9b3dcaa8c8e2bcc752a2597ed5500483f8f65132c95bd09a629fa1ce2552feccc82db787366df2a6dac9a760e069d7ffaa6ecc7ab1a2103791fd6604f8c178ae07c1dd8f53f9aa870cffb4f3ccefeb7da4502c9e3750f271a41c74bb1233535937400055c0ca6d3c47b31eb055bab4edb62d891d3dd8d8cae9871a0432f5f60b9a68288f5327295f2030909f0c03360b2a9da7080a0af50f0cf1c115dfa8d5284826b3a829167e32972b5c805b0b7f8c3bdb0a61fd63222e7879fbb7c6e97abd225261a82e9ad646a4c91307f114ea6fd49764ab4e762455a93da95bcad4bbab30f149f3bfa92a0e677640551a292ad57eee4368095483a36788577b1ed42507cfbcdf52e6857f1f55156089e4f03f10b4f2d09541d22c7b9ecc5f328c5f290b2636b1bc3d740020dcae37011918d0f9eca1ced9e8b79398872f929c5f3af8b4b22d3b7b41b0a42d630019efa9c22072a312be547c3684c28e3785a4f218d2dcc53fd7fb88788213229af21a959489646f396217b8d9dabcdd3e3062219d03af655a014512528f6b341d0045d7f51ba0339c117768dcafcb2876249d01fcf6b4abb555584284ff1586e40e8cc2233f3df0aecace1beafdd6d90b8feb66b6f8ea54d5ace4f6719eab1fd080e535ae7f1052aa7b07a91758be399fc22b6cb372625a45ef2ff8139ba7b545e73d0fbf5a439fd325fe9c9b20a9fa1c27d518505ee26ecbc7f740232dff7702b55321840cca8722ff9e448c35b6794de1ddd81f54db9734b50c3be7c6b93c34447502021fd14b3c0217be6c5bc17ca84f719fb203eef606e8bfe1ed9fac6b63c417e21545e35c8c9bd842f49c06ac08cc89d9dcee1a1161a8f0242ffd089ed85f6d579daae94f4b65184f5f8a31f171aa277f20700dbb156296284ef9c7d8e8bb987e6a6e5ba737bbe1d968950cc5e305dec205fa2ba5636ea0229793c293dea11e4696950b9c1b54a207b8c014332fc87980b5a248e93bd37ff71dadab9bcf900d09ee1b325848bd9d68cd0c88386d1b211e5abf38b1c8ff436423e3f8859071abc59feeb56796f6123929333686749d3b08aba36d4d65349144758946773c4c857972cfd5b682d515e1888580f8f079a8d77a017625e4e09e5e07b0505d4a6c8897ac27185476efe8c739734ab489bc40516ec825f08fa36967c99743d24b8cabe7440ac32947afc9ca13f478293184941f754ca2b4407510e97860650c58d68b67f649abaf9ebb7ab24ae3bcb28e4c11a822ec4d2c3151224db895fb2c6831b431cec64a4fda523dba6648ac24dd4e7127a7dc944fd29d07e2b835475a3dc5f03836d1141c7bf692f3d2762dc1386d56ba3464a4f0a5a4ee7a070955da8a65d0bc5437336894c4c2728cea5a1e4829b217cd72281bdae6807dd59e334881c45e67dc20195c57944084756ea655e7a842a2783b67aae16997c484f13526399e134846879fbf35fcf50cf9568db3e5d010f89d43c2733614be908b9fe88e6f7be15d230cb5c525833612f660f91f194e158747707f2f1a2413dc4d73eb63a4ac87a381af6358cfda1c908bfb82f55b456f462a7b0099c0f0f6094b0d4de2c3e868374c8bcca5cea826313a2981723d7e5d5285a23578ce0ed77f9b09b7cf16ec74b07bd96095d0deb3fc68b7e5dc64f7c6dfc5a65eaef6c8a627a3cd8e3b212d61649efc85a80901bb0648b0bc176f248ecc0fc4fb88cbc6b2f947a374c5bee62cba7042e01733580d6fbc0de49b4ed6becc602af64654f030aa3047631b2a84e1927e6a720115e3222fc1e9c02cd0e4d1548aa50c4d5ec45178b272eba513f72d253bb0a5b7451a042f04153087c751245c0639b2729fb9690d8cc3d29368cf2f016a9fe006f0b49b42906038b08217bf8f093004b03ad8e6e48d7bdab92b660c192e085e5f84770e84d75354a724eb80b0dc985f920fa74e5d948ab60e74d608b52aaccf066dc408966c6796682ac8171e88326542204457e8c201c079c48be01e00c6d0883f92d16411494aa693e30d9edee0788659d3348357692723d01a14cd59f862962f3b7e750281fb4ff742e544020bd420dc70bafb0852ded8398da3828f94ec308e8e87d0c188c09584f9ec2095c43cc738da9e835f54271013a0e946b37f02e08825a0d0e1c054022d76a7a8ca704403c3fc5fc3664c6ebeb1674cbdfdbd09c548fcb3475bd1531a94c1add56cf1aafea7e0b22bb0d6ba82d37be73b118c624b64029b467ba3b032c283c38b972653891f91cc3a14d10b782937655edb94b1ce4cebb63aabe8052da478a5dad7cd55eaf6dfce7bbeae9192c0098a1e4943f759e31e4f63b96927e734fc3b2aa3594ec9aa17244e25a685f7f513a1ee78698fdc986f009b0a4c0c7f3563a97b08ef329c7c482a8660c1328e3edfb4e5d3b809723753a5f38ee0cba33820f73d23229c1cb3e82e21bd82a51e9e7c5726dc5ba646f12449e116a44382b1e67a141b9c2a0cdfe30958f91da8c6fe9958e443e380131cb631986603a002a01af075a83b98a8d765c6183094fe43371ed1dfd8363bd962d8279c2ade97ca9b1fac6283c562706389118904409c98fafdae3f1ca3aca041f3ed33e6b2532ca7ffefcc40ea892ada32ddc8b504c672ec1b273e17296e2a2d4609fafe3bb4b74040690d08ecad961c9ce4ec0e58f44b1f0b615c1c317e25389b8253b677e93a7703331c4009b289c09d92e704f2289a1d5aa9be78ab403bdfef10125cf7975ba9061ae18844927aa4aa500690265f591b42f2a2ddb91b4ada6b80e922f1ba448985d49151afbb78545677949539ab2066ebe77849913e237b318d8ab1d0ba23f0fc8256177bbbf572073efe62fbc6212eb45186fb62bab28361d8ca7b7b002bc1816bb26a759f85397f9d8e682b4f545a0f966825f22d18dba734a6f91b117cb2e4d4ac0285017583a1851397d30000085565ced854c54dc53603ffab5dd57d26021f33fad16af45bb500f2093709211033cf2bc61de1c4534881340fb3415b8ef6ee7a7a3d5a350a3b1318d6483d873698d03b38cf5d7abb99acdbd6d1195adcdeb356a718771a85b7fef832e77105254960ac875f91b9fe94827159c4c85bc830a16be3685a7f578e85368163f4e98ad9ae922dd114799bbc22171ed1a49012f08bbaf5fdbb64a2f9d4bbd7ad069f11374bb2095cc59fdd9fba0aeda8aa85701e3800bb74f6406cd1452cc5c34b22210daa049ebcb219be802332e214dee80004068ba2af91e5ffd54240513089c16cd041b7f48c4ceadb0aa1b2e4f0b85a43df186681d30eb63b57f766f05fc88dd9f8bb842dc564dc809c989691ac1807b2c176c722afc78d9100ff9b3c37d55d4bb9e5cc55ff8005489fb00afd621b7b357bd6be412a5305826f4ee22b17f2b556c0cb4755b2a6e9e13cf4bad44e95c45509c0a9f10af14d575b3874e18f8aa4dd33c63be47a6f0f516f9db0e787b2b75ba8883cf46ff4e751e315e746e05ff10402b37646c245373be75a28200c96d55dab218c2d257f37207297b29d19afd09c1a2c14740d687876f91e5c9ffa2e11824e768814c58965100e0aae6f6ad1fc9148c343f68afd105fdc086bd62efbf809d2153c17d8322116bb190b9490ef4abc918cb0c3541fb6c8e4b5c19cd2d765115c3666513ba4507ef9c84bc56e97582b0b0af3eee615f12315f5baaec0809d8d247344fc6078a4f1fb06c7e9395053d8f792f33d2921a2963e2ee868db9d6be3dc4a6895addf7a53708119e2ce78b1dd91aeea92563a2a33b614540ec885cb8d7d16816aa4ea8f50297f8b20ca8fefb22ff79e2162e6df75b3f769e86de33ba9e2ff08e79bfd96e597b6e0346e44cefdd95f5babf72eb287a5e69117edf7d6e4a7f95ddc49c40194f77b9b1bedd46baeef65a74b5282ae479e30d5ffa215fa3e9a3063c909de016213e8e4507a5babf5f2d7f33e5a43e5477e3bc6e37a42cfcfcce1952f4962929db4c944ba61cec8a2f9011f4ba98b50088de5841064ef34d55e0392360ca010f1b1b4c3173723d0f0354ff89b042ebc9588da0852eb50cd9ef9bf0407b562340f9202baefd889fe73104d2d04fbe052e8a41bef24a9d3a48aabf31260dd5c2a1172753b930d5f845bf37a2b9dea61431dfcc6c18287df59bea4f62e303c68a08f70d36db92233d8abafd79ac2f70b9aea44870e60ee7b6935519f8a01bdc7c702cb1e951c8709afbbb36e888ee9988c9b17253cfcbad2e33120237b43fae974615763b75891dc8eac49a21e8641a0247dce97e2d46bcfd038fbcee47a3f64188d6e5ca20766dda570f7f2641a4c89f6672c46efef98a54eaa8259284ad1937b0d3c950fbb08ce28ae8bdd9bab54ffa66651be224df63ce618e4278c31d7d2d7805f9c207e58065349b15cace6e72eb649ece64b46b13a572afa3eeeb99aa4c73fd14128907a443208e093ebe40108ed1ca795b2ad1b1bc1f5ce4d8e14ed11388bdaceaea5bc1fde010eac233e3b0f061373518ba9348dff9441226660d33d997e2514d85afa714f343094e30858b5c0055e702044cb416836a8b341d268b722a13c5838024a71a193fe8ca602bec0849d6e843583dc81a6b8071ec7f00586a1d978290437a033e8d0a797bd6c2b0deb621685bf3b8716f2c1b19b57da295b60f4a7c97311fbc9a34da48c6e455a8143555496e408a0c7c71027a0eb4620bb8b68e67579bd6d0210de78fa50b05fd6109e820dd2891495a072bb983d4bf0f59b2a7967750eaa2aa6d3cbddffbf2ffc2c327584688b2a735cf76799ff01917092e7f2aed1a62bf399c57a25c6047293f7244ab7850bb99393ecf217047f2e9d271e93bf6f5e3caba76c14db04d171dff835ede86c256332dc3be89fad1140e6d1197be1a7131b3f4c1e5847a2ea19a17ff0612e0ccdcbd5e68239edcb8317b25084d339b856fd971ff96119098e0d120ec9037e52ea994d4f4037b1bbacc549a7c0cb468fd8f386c2e9d7220f93c4c500e452ef7eb6259672990adf23ffebf8f25c7f2011ebbf12749bfe18d2313ea60dd82655f63decd96bca532e604a94075f690d54a0623fc1e5ae0d1a108dbc74d62235a28ed5767a3882f57ceed40f0a75e2037bcd54f7e84b3c533bae112c485822ffe8f00b16d1d82cd7b732c89b8195d7287fcd5fec1982a400bfc3b46e152c06f2a779867eea22c34bd2ce5b61bd0ba0e828b6ea119d2efd78341ea7eb4dfd5d6f413b7c73d0e3bb178df83be4ab531c44096572953c2170fddb968dbf4db4ce24768e7af04940c4c4a33a731d67e0b9db4463a95e80944f90aa6e370a93735970ea76d439222bd68761c5a38fd334488c41a66647f2c128389798639adc924df410d145b4d879f35e34c31893023e3f28551af5a317ee3a6343dcc4433c8835499a1c1f89cd7dcb293f99dffd7703bfe513b1d30139448f6df0a9a028d1c5420a12221380fcc1c46589ec29eccc15f30d1edd88f9f02304d5d38d82e0b2d80f698908db21d85eca45fc6db64551799dea279baf22279a2ec7f32898df15c8bfce1ecd4efb56c85f6193f4ba392b8b82501049c61fa5ae537f1002b9493ab8fe9fb968202f4f3fbf68d84dcf4b334f8a8c4698848e4057cd6d1dbdb1944807bb16828cc05aad0faf05b2ae2a4b636b72e1774c1a5f30103584ba213d7b1d69ca20fd46da0c6567761e98672f29e4cd1768ef74abc7bf42eab370bb16656df4f58cf195cc3bf35fc21ed1488462a6f837b2b3031b331896ef9b9aac440ae36f54d39018e2134e5ca8d86db0daf6635f516696cee001eda59e006b2632da8fac759da35fd642cc0eb7bd44d97767e19d765221bede07ee36f7bac0035d26c57551c05daac15a74428fc1c12df8ab9ba9262437a9b53f4b4eaea2c1e444be3e459741b0415e05f9a4e8c556fbb194620fa443766200fb7e3d0bb639c4af14683e3f810ee375068d448aa233317caf6c77a34c80a7255279aa5cf377683d0505b0f3dcbd9b797e570e460ded9bb9487cbf464d526798ff79cb6523c8a5a45c17f890e47d0ddb66c3ac1db76b6c38bb083a1ebd0c4fea658b1e6c2cea420b6018dda43f9e20228ae51c7f53db6d8506df76b9f16b824627bc91fb5047e16f581ae125d36558ee607420881c2635da52c49fa4e64d0e7cd13cb4a96778cdeaac37c66ce3db763e14eb5072afe8d8c5fcab7f76dc11a077985fbc25cd02bcaceee3092b21f26b7f5d8affd1f19f7dba9697fc7b11dc3f65ba3d6658ce8cf43a1604f3b3b79854603bf9618b123368df4186e4bf5a495260c5d6bdec7ce1b261215d330ee8300c4f4d983e813ec0cc59ca2bbfbe38866f87cef55f6a7cd0c8584d193fae00650f80388e8ba1ed74422a583a2eb4ab3319f94aab4bb31c513658ad3aa06730bfc40d3cbb8e0482eb054548d83ac97e5cf466732231cb5889a391cb9fea9851f264f983224b77916597a537bd123c512240f1ce289cd86990c392d2020421df574b1097ec6211811ec63780b5a53935047d4c30cbceeb89655669503813975b1d556e3252e8d1092b1424be3cf0c3e66cb069fa6738aaf58389f574fd175e41ce225cdf09d39464a4d0ec20c5c826c7736da01736341dd96a148490312a7c8b26733e42c79fdc9c36acc13db63915b54c9921c5cb451f3d2dc03d19cbccc58fc2b4cf015ce6c5bda07484ab1a3ce14cc464d8528f17ed78264d9aa04e41d5329c2ccefa4f1775b9b39a4c26eb27d45e55458350720f2cb24b63b20691e4edff8ea9e79d2f8623d8bb8ed9b893c70a2ba0077e4a5c19f499ceeb0a1c4d2596bf11af94aa431b2ac05e15f9616889cadedaf4171bc6aa439946c386265f03b76657df7dbaf131de61d64b68ef1dec39cf56e0b374f914ae67ec81de66851583d015e5ff3c6d22a4b677f765f9743cdfd5a27031fe33e7faeacc200d54110aa8c90925b8a320b7016ff06f9b122ba105e4e6351fd94351a7bd8c7ae8e94e963899eca30512d7cb3fd5b100acae2215240b607b594661fded79ac0277a0f403e67e91846d365ee73b0c72c4f4331dec782c91e79209a5c6111bc0e23b79dec49a22ca8a5adf589d7f289e67e8ff9a4b8749748d8f20a2b851f0eaa389b250ec1c8bcedcec789811928e0091637824b3ca94e177b36037cad4d1c69a51d0f4321d4655ff1a058eb605a47aa76079dd620c81d3bb481086343fb640ad3d03bbdc942809b9023aa5deeb5280a665099ce70ae79559edfd30d35b0053c52d9525014101e922f181459e1d35190d2d0ab8b4f7432a9377548e6d0d2bfa4942a0b84f2383c714552472f20e7fa5002e59af138ecc6e5b1b45975368012c94b8d426f1139b669cc924ecc52d05957d2c143db9029e6e4ba006eb30e896889f2757cc767a1b821a0334057cc17b15bede7f674879d5d76cc103842290325f0a24955a990afb452ebfb2f55204cfbdf834a616751796267d7bf057671ef3bd7cb73cae7ed1ab1d720ed7d5b237db68d2131081912c5ad5ed5f575d5c8f9c1035cac290efc11e7086087ac19d6b8044a7686698567337d52f40947c35f6a1061934a7c24d4455f51cd3141a6eac133224e4ed9a0b6fcebbd67f508f628d3e241d0672ee934b726701371941c068ad6af5d991e648d7eb83331d867ae423ae7b82153ad42c1ba6f2e2e5c42a2ee77e5ff4b865b1f82e5aa807b7e0f2cde983301ca49ba5abaf087338d8acd4c9bf315b709de9230f04fa244928c8ef9a47c9576fe87539ea4372572b5ffee8977c8b505b19b4e6c35fd9397da28aa7874009518ec8cd3fcf89cae433f39ccf8d3ded585a23fed572ec0dd272f4659fa24b13b6295f8527cdd7df77371c030663c2f6818014711db2b143dc34588472872fd9a7c1ab5085dad436edcdf8b8548c37a5d7247ab4996af2d048cfb7bf97044124a6978640d3857fa30ac563d6146c54ee923099fbb35cb12ad3eb3b940ac7a4583f6115bdefdc7ff3f821131efaf6414aa7001da2e3aef66af992d8fe8ce5c512c35ad6970d3eba5b36c79a7efb5481d180563d67f07781fe00ccd6a895e00d82e01220403478ca371e9b137b7ceb22b10628958527b3cde3a62ddc42271cc2640a1bc9da524a6a9189a1e86905b1767bbc65c60c4fa5aa600031640dc792d5dd50e514213afe31496b504b4df4169a0d3603a78fe17c4d6bff1133682a02dfc6615165e9bbd16a492d42177c09c043af1e3b073c0e79ccf9ec7193631238b887ce2ba2eb5c5db5f6b0ef8697bdc2918765cec4119ab0022c4afbe140ab10dc8241af5e3d45fb378c06ebe6c54f25cf85c54c4dc9391700109fe72a329ec5632f89705ed29922eafd34d6672b2ed775b3358bdc470875ec9417831efc0224042952c8085eb56b5e9b63e3090db81d8d4bf096f3fd6a99f7d346fe5d005ee263f339fd3e250c28819015901d29a1c510a77c58e0b49d83aedac6da1d69426eee082a9982c48915235b2c735dfc7579c52e7fbdca35714b7a1230fd18c87610afe8696c00a762e3ebde850f10b0e42d8e6d20ddbeaec4d396c078eb49e1db4df066146586f79febbba4c935cd97431035ee0169ff28127bbca2fac883c1451b0b2dae9fba1df80d52efa75ca310115e24cddf5848e58eb37c92478030fb1e8c49e182d09d2d43527c408edf740074c6553c08604ae91a151ca81bbbcabd9b01796af270fe0a8bb6762f54bab463f1aa5b69eb734c094ebc9db0778377c20abf65934fd939f25fd87ae0eb10bada6109bf32c9446ee902fa308b2bb8ee9991681e7b1317cea5659d59b6e408ba82933b1e17323b19decaa2df07eac5b68099641d46de2acced820d92b4bddf7c56f18c6b41c470b31a8cb672f3b0a8398e9855bdf66c417366db10583ed45c00233b01f6a37f0b6a842c5ee0925f1fd4b9267fe602715485d9855778d646ce9507f893e035432547222f19d1a5d89d923695681e76a8aac23b8925e600cbcb4eb57fe6e732458f528f905c1fd31810adefc9e51f40d53bfdb6309c311f2b0e3f66d716f00300debd4675dcda8159506f40dcec88236fb988d3ccb996c97e4efe63b9426c964c8c2973229344184c11197f6e18a77f99fe076733bd6ffa5da742a7cdf80dd696f990b0dec19d2f460987923e82764e69024bbbcfb8220dec015c44444e35b3d769f8a24764ff025bbd97e00fc84135724b3c79d4aafeebe97a9253833a26d8dee8cd719deaba854d9d7983c2fc037f8f7bba9d479afc6a84bfdcec43c9e63330ea5cbd90720962455aa5fbb03eb6b3fe320ac465c41d2ae306933079b2534563d729ac0aacbc6bec1e9610f08bb70dffdc674b854d6599ee80cc0242d98305aa99f62297cde89fc0aca7a873893c2303a8a385c6b314c9e79b69b51832aef2de6622859d46cdb4fdda745ad72a5cf4aded0538f117677d0d77d08cfc1136bebca23ef338004927e876ed646537b1dec8558795f10b54314b2a4155477c8a00d8f361ac8c80b786b48866ff175bfc12041ff095bcfa7a8ab21ebe886e996d7d9402222654bea91f6c464422fb7330a35281767009e10c3bfb8450ea8c34a68ef2b18b675984af3469d15d8fcd57b131af16f31cdd391541686946868e0d5d279f8e7a13e65f805904bd4a9ba6de534a65d7de8228da01c752a482eaed8edeb4ede9098591af8da9d0d28ba3010e430745c9b71fa49205f82a51b838487aa885e4da0eef5ae8a8691fc271056f9c3a18a72a9ffa26c2a43ce7ae494c05569ac4f50996a2892984ff6640d7c1535e5fb10f72b7daf0855c3189936e0490f085f8436d23b03d1bed6da00cbcac75cf7e194646a85669fdc2990c1c5543fe64d55526f064547e1ef8c730112ca279fa91f49dbd5750c708596f6eb4c980fd07044dee326075f46856746bef9eb4442cc98ec43569df7bad2f1c5d918e3ab2f8b7416ec6820c8532fbf064d1a2080e0d3cf94004ec1c8b23bbc549a8779d37ef87ca92e2c7f5abe308a0ade69ace72b3cd5991dfc48545daef120d21cc47563d0259b782610191b4cbc92e80c60e91c76aec5d40ab35613186e661415c381847e1efb551e271787a2f4b16be5e9b51a4fee676279ad12d0cbb62eff66a8f71bbb7da33c0756eecf5106450851b3687dbff9f5e1ad61bbf4a107a55c3ff91b0d6180c6a2492ba5f96b38c80eba2d0c9f39f0f9bdd734291bdef6a77302a1aa885d1251c251961dbfa3fb322bb448007e1d35be48f144357fb89b56f8e61f8cdf97806166f9a07d2362ac2e5bfdeb850e6dff5f8b28aac9647fe4ee6271273ab2ecbb30c6ff6e530d1d25411f684404a81ef3e600c811e2998d666cd70013869570861498d8bfa5b8bdcaac95a62ad67cf4f9c0e5f54503c54e681472db0457f8a070330d9bb3618288f01f9e53a5b249ef84d3d45100d172ea48a6ddc3c3f940738900fe576ab72e29b873201288641fa89e2b658d3305c6f01a5d85950b269ed9e7a40439717fbd113d6752d69591db9a3bc1a8214a6b600061c0fd920e846c162b5d442efc47f9efdb560fb89d4058e59055e0964aa291390f53a4338e9bfcc02f9c0d3b59f7d4f0801e77ad8c124306b32b67b2bf5111846194f347b63257c5996b81d821fa0911cfb5ade3a05c6e70c5d550bd31e97f60cb8f06b59cd9965cbae0c4f33e7ca35c908006f03d978fee236194aefc276e80ad8c8b580c46bb6f8bdad2a46aef15be6fe5203e9fb5421ae1e123534a676c54086f225310a82b5049e9890b4dad3b9831f634fab8e94a2e553bc4892847486e80048e57ff9cd5db7ddcafecb0b8bb0b2939bdc3a8000d50dc0a1db55073bc1de7bf0e873e3befe63056db368f846185182e96248da887cb79b4e0660196baccbe16551fe22f92ed9083c082e3ebf7db8ae95a03173af28d9fd8f3088299ae55462778b509ca22ca828a869baa19768a345791d5755dc657041eb2b9daca2fab15bf985cf67c4ee007ccb18c50b412ef9d415a80b05ca31295d4fd8a272f9f57414339bcbe0ff51e5373b9dab46a5a95daf1242e417d5ecc9057c0fb618a7201c706201b2cf0d0be87a750e287513960f44a10429914cb530c1411ce05685cbf946cfd782ca4bde605855668aacdf97131c254a493265250a1a1fbca83cbeb9975815bba8104213a087ba1ca0245f6da9a473ee4686dfdcd7649d17f2e7c94244b42eb51c5301c8f3a7ad52affaf537cc64a86afc8202b625d009853eab8f014f62c32df5b9c0463f352db1365900d877390fba37756712a0354d10aac1a313f31560feebfa7c9c1142d7070e56f8f47027c4d56dfaa2122c6cc7aa7abe711cede4258c5a116a5ffd1780880e3dcac484354d7f28e0ec1f7171d9a89a5b43c0bcf3e17fff78e48de60ae1c5fa8c5dc52c184a1b1dee79061bb6ed8d6f8912d1c11cc9aacd991967063ad99a7e09f6f14a2d9685dae86fd0d00a7f7f36b866e3dfd77fe206f1c604b0b61337578ee3ef8938b691994c6b08a759717357e67be79144cccae02b3c2e928e1cffe3d51a5fb333667982a76deeebe419c26f9bf66b7d53d7dd044d4461c8e256c5e7afea4b0b9ec8d87de1e439858525efdd05704e3beb575e0ce16b3f3a19b775fb8519cbc1a25f2b340bcc7293c082e52b595a44c5c8dd2b6de537d2f390b1fc90dc4915c69847ee5b0279e8c65c3d8e7e4f84e5c7fc2c050e5b7e08d6ae39f544084e9c7525c682009b5ef4014307cd8c5b3e451a5bf21dbf42cfcc8d9371c81dc0dd11a56ccb997373f979160c0ca82f41d4c70f683d2d5f8185b8bd6aad30326095465e320f93c670bbe1fc4b7c88a8b9ae3cca22b1157481f78defa3fd0df0224be75e9e26aedd161589f32957d14b6e5e086428a1b1a1657b9e8f336209c4df1bc0ab6f9a89614fedc1b7470fc9a328c06a490a42c9b19de557334421e328f5dec9fabee22c5d2f3629b6d77ba06712919fe4428a66d016a884db4df30b823ebbf61b16cfe112de43bc424bc950311491375dec42cb5e9bd567388b5e6d9521502c9c4b27fd5956a5dd8cbfde24ef5788d5251c9d258dddf5d55382f28c64a40c567ffefc7660466c61bb67a1deab4871a48deecfeb4f776d3d0eb447e5352dd1ecf7138daf46cfae6dda4e4ec1a3b477dcdaadfe0f150f43d8af2f7b6303058d7fd50794bd86e02deb7fbd05ee3cb6aae8df004003b8d9023915ca1f445576ee04c4dad1b9995a31379590869e54773d124937d72fe2a78a2b219db513942bfbfee41dc8175cc2a58a35fa527a29d23e7bf7e9500f147308ab4bc8c059c919da6b879f71e178d6687a2b1cd92515fe8d1c946c88ee34dc2dc4c6c9a32a33964bd621ca0b8ab44ff5b52f5e31f1a782679859d0f391f3222a2e786b6cc59a1935f69bba44d8c6d7ac76d64ab315bc1483ff1141d282f94dd3556334075e9b49fa8366bc5c8cba49fac3bc786d376209c5d5eba12445df4d8ea9833fd707b9c0163896d49dfc0d310073d3063fef0fb65c40ff41eae2aa94b79fee9b9a4b632d98747f0dd4720c70e93966dc2721aac7923d3b734aa1c531d6c6b4c5d74906ead67c0d5253796d1fe374d8c9b98d7f8c933c459ff22bd19327606217d5bbd9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
