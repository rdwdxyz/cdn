<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0596b5db5a7966a4f05b16fe93e9d3ed56db4a957cac90d2642d6948553dee76066fd5c8300647d0b23a1b3467240eaab750e65a6dc582444a68467cd9c42939883d668ab08e1d20aee13ab248612e7f2093c9add551eca3787cd23dd7c6e5e472aed76abeab74e8a3df0afe4e77bfdb8eb0afc258a3675ef6d8b5b6809cc2d4bc31ea031283c3b7a2d252316b713ce80a4749435d884d3cb01ca6741afd77805b5048aa9ba6b654310eeb2e46f2d90059b27c11814e27cd59468d6803beb1d4104c5bd34ae6a2b4164a7ebb081fb48d56128952d8602339962b95fb4210120e9ac105b3e18bb4f5fc05fa184f8e4f44d943e413e3fc46a341f6324ba79ab8e973e0d669689f4a5e9c10c6159492951b660eb85cfd4384f08d4bb31218b70edcd4450b54d72481a29ef6979e32077dc6551bf5a22bd0b4a7d3c8fac75f1685d372f0e02b283258cb7b256ed093d6a3262589a44204844183f42abfd01e8e857f3648dcd21b38b04c3586f0aa8638d460eedd31ba7dca53ac48d6f9348cc30db6ac16538fa64499c9b0624abf80596b5f56a20b5150d788300278d175cb7c1809a24d7a71b2ce4d03e0afadc896acdf55d618d56dd928d37a7b6610f9cf722744adabb07a05e0cb6e264f8a2622905fa335c3b30fafba1486241bb3f4c67c06080335e94cc21aa4f9b33479c384a5515106f2ca3098903c85b2b3350600ed62acb0137b86e85d83f39bea3e926590dfb8ac6f4448ea4a26c6f4fa70a55c4360b3f1cb9c3d21614bd27a06665e010bb786eda5a256d1f6f6fff6c5365230ad68eb9afe61e6ded1830822f2e55ff97d3f73d5844e0cb5f4e3df65a56002840286d3bf0a3955691af87bb212ec8e9fbc1276773f92ab89ee8d7cefa3ac9cd7e8edc70e90e93f1cedeb58e2c774040c79eca046e86bc388addb21a3550062e1716a4dff4c3d0d5156f16d2ad3fae835a5a4a823f96ed6d0de890c15eaab41fd060de98987630c8ba89950e01d0d336642651b6e82f4b6d293c4fc3e431d96301a9fb29e8f4aab10931f9d8608a7275462d33bd8d1e9e056e05780dddf965858075de8e4d304171f1d372947565e24cb7543a17ead29018004bde4dadeee1ae3579a32e1f1ee6240ce516901e5a6e50f3eae7371b98a80823e1546b0598725d2f991899f11b76445d1cf3770394fc185e41d2618a869756e7de7bb3504d378d5930f7b5dc5ccde4e29d61730b470f6b96af864acc976fc32e9aaadc276fd8105f544252b47a57ead8afa03db67019d71c3b8c20399927b11374f3de35e228156696793e99a7e2b2a93f7c1029316a079f2e7f63ab2d2e3bf6e46e21ef3b3dc8991d1044eca40fde3c575953b0bcefe6c313cfe75f6f7bd2696857876874e65b366aed6baecff92f1624340bdce9ac26cde428e8888df0d89c49e56d4b65fb6e6090146c5df53292233579281cba41064569a4dab43f6f05bcc79a2115e12add7bef68038ccd8ff2cc4dcca90f49206937fcd9d22f1a9c9dfa1b0dc679a97133cbe6f14256b481381946a2afe4d852915a0299186ce48d67b2d0bd180eea46a519acf34f2bea6ff2b91cd74d1260971f74689dbeae8a6e90ee7b241a2a01479b7785f21c8003ccdbb128bbed4e4847815c25bf1c67cc0acb4a565ca521d9b0c55e799e146c1f088e8e53bcfb1fd819094623959b6b19cc8941f2c70ab567a3479969e850ef8ad0298d87d6bcc2687f13d159a4f019a7bd9c87952055da32c4a752b9c0063662a4c51b90bc971a450fc33855ab4ea99d91e8e0887dfb4ce007f5ed5f5d09969b8910138b756e2be5a97b6b23f72d4dfd182ef5d4c4a0b4a949be70cbd93751047df20f42fc68f30f5cad207238cba0b9080a7597f1ce3c40af17cd8acb9483cc44c5e364843d555285f5a549012be5b1abb1fd781eca44450e20029d671d609038c6495b11b0a8e9b4bdfe1efcc7d1d7380bb273c41d668ede8ef0b149cac63fcc85be0704fce4e3c28ab401a558e5b9fcfa951402150be7ca51bf8302fb72013bb32bf677349d6d03a20e9d07f651fac443dbca7f6b2667ca1cbdd1d955e8748c9cc2237d01c22fdb2695ae5c908e26a418ccc7fbdf468c80f2028a907738e536cdd79743415c8d37de9334234b6d037c87d52f53f9dfcf75f029bdde2621f46729d62bd6e370eff40f27f5690012230f053c6b16021ae4aa2004ebfd43eb774682c6945636cfedc3173d0b9cc51f331b40be017e3c26af04691233ce7d40722aa64886616af1ad6278ec6c8b8b609474518365b29822e598c33eba2428696bfedb095520416d084184832a2e818c1a2783403702ae2ff289d374c81e67f9954468ce92bc4f8b85ec4efd2186643a829ea5fb439c3c1cb2e28515c61255a56ac14213c9d291468dc5f213c20ca5a4d463be656b355ba25a61902b80f6cd8c2665e4cca4c8ae18a2401a76242b3db5a731b83fd423a3a16ab827a80edd9910afd63e3428ea164b88a3030c6b871cdd20f58e801e0df25cc12711a41b737677ec6d3f052338053506100ba4c5c7488799822bcdb8b2bc4fd1a5c2e9664cc3ef0eb8138ef3985938a0547cc91a504036f6907a4dda94d72b92b097d3c66327f242ee19ea3a8e0afe1fec44de345cd31d1e5191deac70a88f150780b981837a2e7da7df1a840b154e64f66b9bc996dc61ff6addbc7928bbb258a7272ae37d8dd939c99c175bd4adf56d0cdfe4c9b1218949b1fe10ac6ad0caf8e41a98380a817bff892f0ac382e5be2aac3c4c83605f875f9ddd47722b44cd9260e60f7b04e9c7818a1ef809ec322117b881786e3ee605c44de4b5e324a6b5afb329b05d96b58b19a2bd027cc1d0d90d97679d44850ee84b5946a8bcf56fedf229370e7ffcbe11c716a6ae95969aba713bfa0597aad73d0a2a8e61df0b34e1ed6e8e655450eae56f879943bf1782c1ca245b73ea33599e077b8b463bad73a1ee39b921f782c821f92c26f8655f154f7e3086c95ddb30e869df088bb49eadd220c3d0c0c31fa3cbd7e8a85a50eec95434a2f2b3640a9970dc64580254d84d1a7e400e45f6d3bed5ee7038b6078813703dac17769a267d2a73cc8ac5e0c35dc807a1078437705ffdac55d702afb0b4f14ce48d93ce57e643c405a4e580b7b732baea8fc74a742b28b72636a9972b6af4993cf3d35031820de997d8955721093bd402daf868ebc104583f5f86577bb34dbce01b867b83381790be13d374a69b1b8acefba8da55ea8c2ea5d341ae1fe99b3520da3d7067e162a7e2a85c9c7175f1ed986c3fb8d5a5d19bd9397bc2f9f2d488d6cc6535bfa2ba69df8a978daa91024936f93c5c30ad6ade67a47402a91e5dc6cdb6ff61ae3555b259411dcadf39be701a2b0045e7054926286f629c00b57df8e6ecf68079d0ed857605cec9ca655edc504943bc7165eb18041b7507f1073038eb7457fab6fa8f71ab8735694f8331cbe5ae7b8acbc38c2c3f1a9ae949225b4cee32ab87db4910797177afcde82f5e97ca45ba89eed00443afe50cabd4166cae453797901ff384f5e8156390a27bc76f66feda76ce4775574e6491db9e1dcee749f8a273e15322963429e8e999eb5d8bcbc61908139558825a73d44347b672c27bfaf7a012ce7f565657016964d9fc8fb1f70243764cce3d15d1d0873692a70756bfdf4c4a306d033dfc14d3dd1a2c62936a99f3814160d5c44ff00b0076b0693f3dd231c18e2c4dbfb7c93daeb2f1d5f5c33a112c5598391af1f634c5dee5eff5cadba83f866e1e384d0da84375df9feeeb4a287db18e2dab48b9193cdfc4650d4b052ec360203f733a5ec079dc32a6b31e98ae3475edd9987d4644595d3a75d02ed6e5a066be8b9883a0c5e9604fea890e804af8ef9b6c3404f4d2077e2d4fe8d946265022d56e6651456ab44e0d64c66c157330557875caccc37079f77652193be03ef05acfb8b7a3e190e3d308f6a2c722eb86beb5ff96dfca5de87801f472b7fd3b7ea39e8ea221afd2a1995b2a03c817eb713f7a85ca0b05611b243a1e67afc365e8fd49e56358c36e2be10571d15c81f205c19182a0136a0291a8ec6db8aa48e5f6076c2b694e69c48ea9749cef476ca51a6943d586376d53187e0af111815382d9a9294c0370181a574e70a8d70265a9bbcc685ad32b6935293af9dbd707ada99858891fe3516b4d42eb45d0dcc80c5ef7a90514916df7b11165198f42f9f0f9e49e54816f0e26d7deafc27634c6f5c38a149784632b6813f699f1ab06d260259ffc07cf505b7d4dc143dce226edca170da013a3c05504bb3e4767f74a917a06c91202cc91160ab2887afc3cf268fde247b477e1c9746cb6c8e621b9499779dec8a8e3ea2c3ef49a3315aeb3009585a126f12d2ab2405b56a78d1bac8255d00169bde64766ee80ad2f704b4b9fe408f99299b8c5eb83ee6d8d8e0c68cf16c897eb31d38ad1e52651fcb160d687fadf9cc67a2e4fa5e4a17dc9313aed12597c86c2208332ab90a707a8570337664d04559f6fef95be32374a9640317f982d3c710fc34a1517c5c50cbfeec2b362b99f092a325fa0cae6103967e44351f31d5704f3efba64768281880d79dd0427cd3d0fd061e625f7a4a11add32c7458a748ebb8e0ce598a553724dd761da4b045373893391da9314f9c8e8200e6fdfaac50b5e412247e0ac17c9f1d905f16d1be746ee9a45150db3c99ff7703551c73a0f9008c061efdea1f8477cbd4ef19d63b5015c96c4ce55e6d426fee7d47366c5c3c77db6c1b5762681f4ca81eb065378534416ab93d13e995d60d0fe5e7cf832e9b949f55f9da001a8b5350f1da663cb36223c0f2857cb07c6a6f880efc2c9d06b7d7d68cd53e170db28cd4b537c2a60339a29a4be49e31bfe234202e467a96878b3aa848448adcbd00da2dc75139ccb3e2337bdfb3f4c7c5472cb7f8fca338172c1f22af49e1bf53c672a19237224d81aee8213a3d68c6d58372e0b5f9093a9c63460edad2e975c3dd8351be13f79eee96fa62d7e025e9f8e85ba14d68021326b17f801acb865346bc3cf96255d1638fd7843eae7362ac28749c77a1357d28ecf4076bf9dc1fafda40d9dfdaf5c8587398a2aefeb14e249c1a1abaca31395429684e17289d559c9d5b2b33a1b9d47fa56d26224420c4de3b0bd268de9f799ee8dc082ac05fe874588a16079986cc929c29c6c4d4d2825e4041f0be7294082fa549a3fc799c4a71f6e2ba727a66da0e75b8afcb1c573395a2ca06967e59ab8f439b038d1c602f0ab0f338ecbc62b0a4b67dcbe480e717dbebc3ccb844c77d423252a3b4f5be4be91a4c5608de0a64dd1ea374359a750dc111805473fccef80a775a6504fdc18b62613442d24b1fb2ad0dac0ef055aa6fdc215d7d7551ec6a31a61d6c3cfe03126581e4b0bc05e58c34569498087fe0c91dda01c3546377ee5327f2100451e237a6feabb918ac87ed851b20ea775ebb882dedd3e64b741d71adb612dae683a24aa00f7efe5c08ef02ebf196398e371c920fa9a0b06338abaf826ba145c319ae7b4e8f5221bc250be4f18c995316c1c39258c052b55bbe401c892eb2aa46875fc57edcc4170b624e4a68932258c340f36595f91dc3c7fc7717482bb103165aebf47872f3127573b777e866b881546636e1b374994ff19aec16e3cd073a9fcb12d2b2dbd999bde37ed75e34090822611cb1d1cb06e765ad6c7ce6e971debd94a73a57a2b42ddf0b75651cf33034744e7edb121bbf0c175e88a4a27fff3fa425c1292d27d8ebf4ba9a4f8a60755ce2e3742bd3ea6e2458ece4e9bc98fda61b67a908ac578638d9c30ba0d55420feb2fcfe111f05a2aa26645e892118e2fd87cdffe1ee0c17e29e563f8a86c7ed8a423172e826d9d0d319b61972aac6d572dbb54cdd375429a4beb451923eaf844bf77596cb2996d2dd0b2237e185c613246e193bed8264ee0dcda4c371c640771ef099ddcc4cc544bed802e42767c9ee279e5606c49770e1fc4646a3f8f5cd1dfcf8f9176cc3e54846c24b6c0641a387f1bd15716703f84bab1460edbc95fd672432431f57fb26377a546c3944de522c147f5a33ce352fa0de535464092586f831777ff7f57999e4fabd339ffbeaf6a95c124e4b83fcf5530c9c556aba11689fe1b26ca295dcb0c1afbd0a65403f9fae987cd405f978dfae7941808fa84ca150b27ddcf07853eb7837fd88869db38dac8be4b9b6ac256589e7514a286dedd81d6e9fc3ca39e8acced6ff51271fd872e14ac1cb9e76955b087415723337654134b52c5337652c8f1123d85f3cff65acbe15ec5569a1ea1bddad02dd11c32dea0ee5db4643daac683c18c8db77d869751648f9bc44a6fa8efb5070897257425def157c14b94d3c29074d44822284338038a0146070cc4e0f670cca9425d255856a670540eae0bb696d0861a1f8943a542abb09284761033a65406a85cb1a1e3d2d2c8776af58a8779b35f9be9b3f6692f1a5392c183a501044c4ae73019379b82cd26cc76a625007f2bf0b0acdb47ff2e61f8566243cd8f1d37b0edd22131f021f5b6b9e62e625048a6ee7957002ea9b4ab3c9fe2f1e83bddef764702e9a4da6c37689b32bf8f69e01c630786e2adbaa247ba145cc3447e6cf0e08605b08d2fb2f44df2b73eca5c455001945cb252bee32c5374f63e689314f990e59d64c19273c79d29ab54df25d6094f18a7ea21c832b720bf18363c2345e8f860d68fab609e59c5a61d592c3a1b9e61f9db527fd5e54cd3c61b832539f665ff994695b5f75fc4427ee65ed187d588ab7185b741029d38c09bf2e856d825aa0cef6f4fb90ade8db79e06d63fc513582f305c7a7529eac72ef8ebfc19c481229a06f307a2d993bf1d4b5e2316c4969f8ba152b008ec1da30a3a0c8f4ea41fb90a894b92eabc8b0396a9b9b0ab8cb3fe1c4867943ffa555ad0e4a656ce13d9a14d4d8fdded2070303c370d2116fe4a546ca443abf2dd05485e6f170c01bdd16b78bfff1fc888af7d4461c1bacc4897646c5a5848e8d928cfc34a31862baffbd66cb0ab52b3b154ef5d4a56f337353199bfc112e51bcd4213996e18227b61bca12f4659298eba70a43f5be0916c1d90051271a07e5f68bd7e65fd1a28a824dc7544270fcc650caf3a232a6a3cd870539d7697a89e3bc99f246fbd4d847d8e2701ccbadc5d5115db6b4c3bfc7e2d39f9ba857c85ac643e1bbcbd9c606e17833fbaae4f768c9938e29092afe848450e61d42a040b2e2b20f65f294c3149e880da481de2acbdd4cc86f9bd6c1da30111d56831325456c3ab8a369b7c95235a0162b2a54a1cbe93ec677044949d9b8b4190a15ea6f21a7e11014deabf361d494a747fddaee6bc842068a8a573bb18360f7b9074db125138ebf54bf2d5a2c7f710ced5cf60458b29e8e4abac912cfa545889ed5865761bf199113b803a24f126cc04a1c2c675df6b362b40f3aadc5e87f21a2a63ec2bc99bcdd5f7a06dbee358c6fb173adc4d830e1b69b9054ad885c3d06ecaaf0110ce5cc704cd0481f1037ff6e20ca394c365439ea9dd0ad7031901ffb98d368e4e97663d4630f6e2b8e00632a30e3578a8a8e23f4c693aed278714fb0128572772b1520e493ab61f0b771da263b9f8ca274c2a5ce00eb72d9b56aa7fd6fc3ff2846601bc7509c51776ed0b8c145899dae1d64fc51f00f89557655c936a0d4614800e04525727bf7e76d2b5538d961cdfad86d93c0a2e34bcae70a619e47b3b8a2cead214c6c751c47cc8045b7f8059d87934d1c04e78dd05c067f4bfce05ecb07e1df74977ee0a749d110848a69fc979645d396d89a098ffae02746d7dd8335b67dac43c3036be0df107a194f7c660d7f01abe0c1ef27fe52d684a0d697aea3eab9d5bd55dc7e07af6855fc775351cbdd804b06fbc987815f81e39aa39521f07524b14d7d96bf22f2377b87dbc7f109b4379cd1898404674c31a9e5d06eefc8bfe65f2b6758b9898836f45a34d65d54c40b34f455b31e97f0a879b09a4c26605f413d70811d034d72030d10227a2f7a57fba13f230dd5cf52605a2e902ef0457e4760958e3eb58da7e852c35f2ad31fe0e2eaa2adad3660c4981e6b19451d11f33cea4dc0f48c8f64823074ce3761d5523bc15831d46670bde9c4b6d419d2a0755bdca4d88258276d549fadc868ad1abdc0c4057e4c4c96af11dd3868261e8ca66d0e31f04a09efed3c6379b41aaf4886d9e4ef8ed8209b104f640fe3bdbe5e8ca51c78635283d73fc8a3fd1924caccfb2800097a4584ab9d1db608d0e2c5aef5c5c241e8fd910e6f797ccd308475de5a106771ebdc027e30db0b30cb268e19564fdd0f12ad40378ef65cd7ea13e41f5b67d276bd88760696f787d254ebe894f4646bdca170045b19e49b822a5ec7973d23993d7ca06e0c003c66f5cd76a9f8b4a2fd560c02382acacd716698ace808b06d4a4bf52b8fe9dc6229215914778b46a80cfd34d291b9fff0cbf3d90483c2877b7bc40c9930676842715898a48b631d0a504bfba9bf753ad44d937141acb5a77caf627c3096ce1920e7b1cc2f87b980fe6e5590f8acf2980edfc201d26f07f4c9ad4f637864429b3fee3fec6f96d17414782f63259b4e29667ea15140ad17b621e997d0a00640debf81166b357d614512efa168a853ec7ce1d8361c669b7c1cd106434370edb7b1d6d1a73954b7b261fbf5b36906c1569acc521e683ead520edd669048fcc4beb700ed3439dab894e27b83a03fcfa3b06015e9a7d9d0f859ec56d5cc3e2df48d298c25459f23c5df6b840e2e21f000bbb853c45a7fd7a22abdf368e72faf7b414046a0ecbe3b83a82b2e3850b8e1b375c6641ae937f6b97287a023156cc381272bc3a9ea7e226ffbc07317d203157ad61cdf6aa8f67ac35fe8b72037ff634571903c235f4f3f1ec7da9066f0f915c35f2813043414cca9e0363ff13b3ab85dcfdf3488e2704a4c03574b550d325d0d12fa359aaac82deddc39cba6556f3a165059a3304aec94dbba081a87b7d5eef08b0d9fcc97633b87190f7e65f29ed05814859d779720a0c951e2003602ee91dde02a2e693f26c8065183686a47bee61a1a04912116b0533c86bfed989724f34c0355f4ead425d4723f3b64cf4f9f9d36b7c7d693e9a72e658c1ed71c2d4ae569745bf636f0822130f6c2d31a624573a836ad94f44a906cdea248b045538286d33415fc1997ecc925011acfda27236b71e9bbadc366eca5621916a69656d38d703d721922177f5e5829925d9b4e94fe8a4899930432f018e9b2858b0b287d622d092c1a6482003f405250b243076ccd3ce8fa8d7998068d84e5c0441adafcc094e370f96e61ac37b4fad04f0150b0a17c814b91670690335e1fef7b1aa5d783921c200b3c003053800be45356f62721d4a6cdb3b096455891abcd27d0eef0fef51e3ebcf9fe29abc1d9621fbf73ec23347961b000954295f1addd02932de3565f6f68ceabd23ebeed9a02ebf4dfe0cc5f5b985f5b8e3504adcdb9c7420d4cf66aacf54974136c93105268f7c036d74d0f00a417813ef1d65f496732bc055cec9795ee5aabaf20c96c3387a654c564da0e5310f4feec0c089d1c445abeb78a3f917d8a245ca1997edae822e67df3d8905d541ca8d081d3550950d7da066146cee09f4597042293570a29b1170d64160b42273b2c3463f4c295a61791e5d30ba17018691809205946cc6f06e8c0090fead6f11f15e28d8be878a48d5bd3a6fecce0a4b4600b9ed2a8ff5790aa6546a6430650592e5ea508d5d09f9f9eb5361948180001d823ef92f350ace2985280396cdcda9815c86a65fc576b7c5e07cf6b76f8af3b22519f833bc2e9d5ae523f302c3e47b6583de47e8d037cc6de19b3e1687e15b0a93a5e73da7ae461c7f94427f3215b90e55f30e94f872a8f72b5e9e95c0c6d9c01b2d3fb8cd9acb2a3412c5ebb507a9201cd92da094e6d8c87114a512d0316bbae913824305667593622582708f65442c9c1322a0ab3c9b3ba5b3194be617ac3132d8a9dac4944e0a38d43effffe645b50bcd9cde20179a4c72fabffbfaa49ff41e763187f449114dabcc6b6891395397d1f16b7a134e4b4c98dd142a50c8ceac97fce73ab131261f597b2a5b2398a9025c36fa3704e0fbd0ce7f177557280965c362084beb2fc7caac822268db7eb846f6136771b364f4686c9deea81ec961fd0f58d321d2e1611a3d6ee410255d2417284a0fc8f1ebd8a6f1eeb301e7bf9b2cb7fafe0af923426f98197da221718d566544c053507f4b00c7c543c614ed22e14f01bb62e8060280e6d7412ea144b156e369d672d05ed3328d2cafba5d61452f8c4eb1e52d8029f5993d6b5dade49497cca91eaa16e170d0ab647dc81cabc8d337ff76826c57abac5f8b18029d6618fb48fa30fc325c92425602b94c667b171101131d0339385a9a8ba78743f77eaed8e27cb72303645b19bf82efcc52f30e9bf40bc861d5972ae86cf73d492536847a712ea345499b5aaa7e767d106cf8c6c500d2511de3c3db395cbec28b70e02b3472fe8c3f8d70bf370b2d9f7a969f8c90b2c2eff76d0411d7b20056d97fd97eb6d1a315bef2adaabf89b70bbbb51d290dde6bee7fee8436c337229f6fb1bf935cb9c0a8eacca081c251dee32c54580dd51d7f7d00fc93219c8eae45a0a70b1e53d549f5fb58dd3ea246797ce7a67414cdf3f9c63e7c14ead8af4d3d7bd8f57fd2c4a84c97b4961232cbb1be5806d29981481d5869f103b5fafdec4df80881f7d5e457a2c5fca52d2c9ec2112eea0187ecc1c76a13e8fa281f916e32f6a2f9830856cb955352d8543c2ceff0d1e49d7d510a64618951365bc53754736523b6c8498912d47d503e7d143618feaa7238ca72caef033aa33038ceac5c817f6ce7ec0797127c2eff6cf286e772e2372a78ef69f24f7ac3da43c591bb90dbfe58e3d2aa3d153f4409b3cc65c8a2a360caf560d59f1c1b27f762d5afbd88a3b0b6fc5e9f1fdc70dd7d47099637f44c0f82962a55f7cf5266ae8fd46a2bab6199b0caef9a8f32ae0d1b95a8d08bcfe68e035a6fcb36ef8c1df5b9439e7d3e05ba566aef3e858188ff67608ac4384bda641acde6f55ffc292dca976e02c09dec35a81564c75fff374081b7a4cd99e3d4175f6a789a91ada5b661a9a386c359c92143d3e87f9214c43fafce0dc0c4540ae55b5393477cac44993c7993004e564213d080585825dea0bb3097ece7de1b792cb3bf332a76abba9264a504f4f6ef0f62a6b431c687454188f76f77b753ed048e889fa923dc23bcfac017a7629a347858847c82e1c8f7c06cdf16260fec05ea7927b1bb2ae45d08547674a421c3e0ed7d5dad95b9fbc68c2785a023cecd07cec54bc752e382d92b8fe33d9bdf5764b1069c4b907c73f4abdde5ee80d195ddd2de90204973fe134607b69e0035128eac24b23c427677d6fe0041af6ce230772f2d17d7e56c3fe735945060b24b9b270418e58b8e1ed1a5f9aa8ebb75c508f29dc484fcb8a9d27cb08bf75bcabfcc4483038f57691fffa89ca679e2fea5adbb1677d2a0e248f612e4c3253a97e36b71cd969faf7c249659038904e2c7634758673d827ac5a03ca0d457117555cc0f893829745a224a4c41a4d740eda1ea4517e33c969e0fd39c15e95b85f3a69c6579a12b9103a38e32c6bb341a57c6ad74ea9175ca655f1989785914f6866b8f86755908f204fde5d37b6c547df46036f77edfb62f5bba34d95cbe11594d6c612dbb723ce86e33889f14fcca37e57771380e4674f292673312533656a5c8b041d40e7229df418c256bf14e3a2195cdc3d3314d3ef88856b7159b49baf055135d734b053e7fe6bbaf966e8ba300c96fe10dd8ac525c267150e9b978f0bfa61b2a30367c7a871ee47d71fafe5d3ca3f496aeaa5844daa0055e29277513affd23ad4633f0c079aaf0897696e6d34a267b6c266ae05aa050af7055c9d0bdcffd6c03b0daf633f23ebd186e2b71be2b3daee9ce01dcf44e1141360d00fd199b080173621e5d8d46616bebca7ffacf9f32469dc11789c1a62b19947394e603e5bdf456d931ff9333a02995abbd01a4409ab21aca8450cb5153e638664901b5ec354e5acda77d17c546ef614031682a75be3658b0c89f417d052e90b1defad72e098735fc5c0d2a35ffc46cbcb9983643816e5f6a60c0b4259a90df1ff314f365e98d52805bb9ee663b33df535b5c423a270a77e7377bb216b00cfd6d57de3ef10a0a61480104c72822e2f31fd1091d299d8679463fc93da882782780bba86179cfd177a37798c98a51e8ecde085a1ca311d4c1fda0fd678cb57ebc1ce58b1d86c10f6db43802eb262e507cf024e4c1f942e65c0fa8b708aa33f3e1990ff9032bb9df20a29b32d720e726f0f0fae6f78985a363871f98393b58513094981b2551ac720a19a9b61acaff87fd42c766a427bdcf676529eaa3b46db4270b53bb96a1b2bdc801950244100c533bcf2fb895186ae966f85339c41ad2b96ebadda0ab68e96ac3a71bc55413776cc12694a875c690252d1fff8a1c1eacbbf84cd61f138ab852f2f137e7ea3a48c7cffad3bf3e14200a7d896fa99c3fb7ff7bcccf754479221db9f81aaea29c3c7fa116ff23d94f027715353a95c8218b2c3ce6124e2ee495c7e8971fe50b76ac4fb9428f422bf79f68f0c4ee4bfae090eec509735f79e5506f98f04426d089b10ad68d3c3fecf5ed37a0272ef230316ffd95c9d1b8d8d87940f5d451ef9aad19ca06aa27c296e4c4d12037e5c70e9a1a014df500e0c71f6204fba8aa7155b872934b78c0c9070810a929a9ca426e65ca44b85ab629e70fe596dc6d9cc5563db3be3f21edd0d52bcc78ce9f2475238e038c0d31d82b036a4e95b289741594492ca721e98abe117fa396dd796fa48b88d4a4b86f96ea7904fba32e4cf7130231f3847c555f3f07dcbd8dbb5a10d9324a82281f7a0363d67e58863b636b57f036a4ff77a1a10f21710fe1cccafc9dae6bdcb10e75819af97be909924e778154ee98e250bd96db12bfad4a6840880a17d6e572f2bf59dc75d6234c22b09c06784305621cc32be7557c6ed882c22fbe9182858f50cf397687bf759f90052018a45cdc4122e2c62feac3f2b068d8bac401919f2fb05986b30c39e3b8ee9fa63976dcfb13998508cdfc4c6eadad552f5fc64ebeae0b8983f31cb1bc47b4a161b6e49403ac8b04bf172844d6201eb66c4e1c6cd18f9afe8b921750d9aec7d3a6cd71ceae6dbb2b2d4491c7e3ed141455700181cc7e24fd6dbe778923550c0871dbef9642f93e31fb6da8afb0d4c3a029011148976dd5976759cf6dc34e7dffc99f556c9ce9d16792cc57f22eae48020da96dd8adf8bf7f697bd74107964c75067b51aa3f651900fdb862ed71665e5ccc247b17d43749dc2c05830b5f05e43b22b15e914678b2f967c8d80c5d40359669ad37092fb3d21d152c279c6f57a8d5cb83272accb2b9c525c140fbd63b694135bef02078d4aae1224b782673e2967c10d22e5e1f35f8063b05f53b1fb40e81f83946333b0331907c9677669c2234abe8a6128427fa7a3a03783918e5c8032244178ba1b1907cce70c4937baa0914eb8288c9cc167676f72c9a577938da011d8afc294802708abebd3a0ef1f15da57ec1a8962eb8f7b53a334319a90e936c08023273e46fe9556b0c62db62ab704eda06776a934bf8533fadf111a39ba8dbb060b7d5789473e7972f991dabfccf353172e1a901f5b0fe8d849f25cadcdec69cad87530493fca68bcd5e69997473f8bf1f748223b4f50b214b78b666398358b4a7f9bd1c5fb147af40b12b185560adce677cb25066b27fb796946f36c63b80dfde6b68c87cd89897d6a08131c04d9cf560a7569d4120a117037e6654651b6575d2df48089a722c4086dc56833c21f681204487e789ee5a1bb211298bc758fe0abbedf3403dd990b4ed53736462491d9a0fbfb87224b2e22f86de2f1edb5009e8d5b2d8d0752ad8cd8bdd81535696b73a634f5bfe0c6f5f9ad5aa2dd5d66dd1c0f9921fed1fc8849e8141aa8607447d3717df7bfb5745c080e21e0649534e5ca65d80d1303e7f1202b3197abf3e4284b5a7edc07b55c9c811ee09f8f90da56f3a03e6f2dd7781eac47a537cb88c7f5aad3392483e687340eaa9ce992f8d076a4243aceb6933d96e8bc042d0085738451a401fbaa18ab74ca037b79f718e40deb62f1c03bec48e79cf2f4f870c6dcf13155653e0977178331a27f17a8f127d39fbdeef4cfd4c8e5bbf1f6ea195cec665e6b3a3197bb14982f1a7777e6a8d59a662891c6de933668536ddde32285528572447569fda817b074e294d169529bc0b934e8a3853640d8df7a3dc04bc994541955c0c9c81305bc56932ad011932dd92465a5d05d004aa1d096c146aeabc33840fd69d91121fb84722c5db2335341ec1eb9448891fc20e6ff8a3a5ebf849d7cb668924751b0b3d945468ce9e69475c0975c853a842ce26e0dedcec1d8757f160f8c2496c6ccfafb1844639d66facb575885fb9c6b4adc2627ec6ddfaf4c900824e79e1176a581630d87519407f318875517e8d3fcc45fe2e161236ce6bfce336730cac6589fe4ab88df22f8da41b7664351524a19228ae10d6c2fbfba751866bf8451abffceb21f7e481685d06f3d08770adca331631b233b8512b0ac75739e818eea40c8f910a05fd26a009ef310e670da91697796617f9bc74b3aa2394d383462a56e34b591e7dfbf421953614807bb89dbbc48fc4836348095a879a76a1e43923839596d342fbcdd0397bbbac03f2097e67108e19027d1ba1f2feeac4b2ba85eaf81144623de5999ace2b798c1924ec85f100943cf7d2c703a80a0d3a24bf24a62deebb0fe573e17ec66ab0eebb1ef7c52728f5e6ed5834e71200e6fc5717d8a0fce20eaed60eee70a28809e566b60cd0192e011209e0c56d5d86cf6c8505ec09b49481d80a66ad3b53d98e0adb41f72999755d70883030a79dbfc14fa16d76303d3012dd76aba01654d2f7674e87490f186201cca020aa92531106cf2e41b645008c34d3005f2e1cbb1d23122e2250414a5b36cc8004ff058c371c67325f3c7258f14a7bd0c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
