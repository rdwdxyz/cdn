<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd7713855cdb4103a5fa27ac2948afe81d255619dd13c51700ebd64b1bc1cbdc9d95b875515d0bb672bfd1cead3669eb90956510cff89fa924b54a120562f00adaaf960013e76a01af99848e2e354ada7c1f589f92ac424f4e2ff31eeade18da7a32e2941ee1515796d453c5e96428cde33bd4be4ab4fe37fc6b4ebbb214267a5c2c8cb4e089223b0991d3a8465e5f69b18ae2de18e72d46eba8f0e961e3f5d5c88412514b8910f0b030f7da55ce7d3be8088f2f98c725efb96dec0739074c3245468d9971766e500fe1489e00b659df39b26a503535c6722d4f73d2f78c55825a5b2254ccb2402edc1982288f1f7efbb04848806f5c69de3185510f4289ae78ca591efcc60a91c49a2505d1b8fa76fb49a9f4413f313e8537aa547688b8fe7f24915269820eec1ace34fa583f4a5b1b0566c2a036429821fa21ed51c2587c16b576ca5c124845008f3c124a0f32196410ab5be1d4e7c4d7771550b9896b34456cbff14a0eafad5054c49cfbfd922b7b0ca1177253f22eb36f2e0f3d41971af0f369a87da2022e6532cd007de7cd7f74260070caa54f8a251dfb3b0f491d643544092e8e2eeccd9fc0af6562f74d5fac19e323f6bbc14815860c7ec0df802aa5ae637ddb0fa5288222f7b0dc4bbad4d61fffb65cb4467d8a50baf341ad99ed3f95bb73e40bda75dce8e8887dc32a1fec472afcdb775bc9eb620d2a4909992ffc61ba3229c1288b06ae4a9439f07eeb5cf0b409f24887b2b70d6ecea0acd78bff42739e9c10bd729ede182c0c98b2a18ec1457e776c81885d7c49e1601e27cbc7e32a0fc7482aac756427599186f152bb4f9a71d761f18986b02c4cfa5a10b2dcd35148c52541fe5022f8dc855a3e970dcbf1c085b57572996481c44aacd187b729c24fc47ba695fdf1b5192877aa05b5cf58138c9a1a76be6c551865a4429ff67c18b0975c8cce12e5acba476913c4703501eeafb64d056c31f10232b3411a26327cf3eb3549ee408e80af259a6116673299376a1ed453f67caa097b0405bd06f60fd818810016874c7eec5599c925c61854b43510660a8bd5f951e857fb789dd9241b5a3b2ced5cd103b747398efc56baa99b1ecdf70883ee72bf4de8b3eea51438210ba672e77fe58284708fd8147b7e530284a4ada4362fefd53520089feb8caa4fa01221a55806799206089f4263968003ccd48bebd56ccbfd10b1a763377a5b0b2ba3bb25c76fcbd18bb981fffa1111a5fd18f9efeb3b1cab172d23866f37b682a03da73c65f7feb29d1818b1a6337a93dde47c05ff6cacae9694f5221fa329182b7b1a4c78dba192b604ff6d47d62a516df2f5daf98677d8a4cac73d2878915bb5d5415e1f7d4238adfc06fa8617edb12cfecde24189c65ae357fc2d15f1645c92df042c560c5a44c39a21a02c790880b72f041f9fc8d7f0d1ae6af803b165d5120ec0316a8af744ce53b978d1c65beaff355f6fd24010f751bfb7a2c1746d6661428e43e3e02802e037303ea957f35bd4050824c2983566ddecf0529e292fd8beff8ca4c51c02cb6339dc93b8d9c852428556a378338938e422182957c92b9628b420f98e6a0724d5df73a38d183d3dcda55ffada2e26e065274a4b1067504e440bd21917a039c3b693402f96952a46189212856559d59776bb8316fab707da32af691c83a347f74d95f01efc8ee5cf08fc9ba8322312b9e026105a9de5469c6346db322d234830af31c9789dc9971a67bc833d03526a942e8f17e09366e4925495cb7fc33b08df2124937c3f29cab403ce7d046332dea48cbed98ac1667e5e29c3b5565008451177a21931a0183ca276f352e38a499bf38193ed1d8bbc12aa405d1be20384290f82e097f0ef0c95c485a6ae42e56b67e4343697cf59302c797342f637fdad501839b822eaa965a817d80d958cfcbeba5efee16ee436fe9d574eaf9055ab566880042e0fa236b1cb8be735ac4a8289aa927ea07243e89621e83cb32a880f73fc37286b04a7b9c24fd465da80cf8b3ccc0ed303f1acaeda667ec346c34b5d2ba57f7cf98cbfff2927255adcb1b8d443de784428fc56b7f3470e05f9640086552bbd69a3ede97f501894971a8b6770712c5241f2bd2396b9d7c7e2938fb42458546a1f7bd8032271b1ae2b08c009af2fe5905b0419b10e5f9bfef9794953d3933c5031bee7bbb133de6ed252738a48efaac096c8f77e9f781b61f2643af47ca168853adfe467d84248ce1c81064ac48838418625e1dbcbe0e9e7a966d228390b2fbca9429b585ebaa883e3f8c0fa910187818a940ff1cc391ca2e86f682ec65a2f3cfdb24c9761bdf3e0422b22479c38119bcc193e6a4f70d13881fcb38d19e90545fdf0a8ddeaa895ef5e30ffb2d2b27a63736c121c202c9ff7341cfedbb7be684b480d1310add25ab4bd1702efe408f1df0b18f14051c8a59a290d41943b01faf6e0c0b356f3fbf50b58e26cd6f1562779147c59b05eed28f9afe65c9c513805a04b474c7abd795a2fc22c1c970065424e379e3a034d97367b13d21ce17c5add38dac40118d71445a6e5f10f728be8d0ae7747982b39414e537f6a523e36f59d344eb9d5aa1803904894ec6ab305999c5bd2163fda70829d1aaf3cc10adc4ee26bacb03d89d4111042ce5d5546010dd2df93163d7e300d2fc23c70e17ae229a98dc666d6c4139872ae668f6fac9fcfa0b30463c36db3b21f4be94d87674d73b3819f42c392de044a85bc75d31071a2f128d445a9932f9bbf362437f665f8dfe3459531b88fc1c83966f854c6bc99757e52454b951727a1a2cb403cae6cf8891b5d34c4b2470d8be08ecd103015ecbfe0306072fc2e184c89c97777f591452406e4e627604657b6e08cab46573a5e289eac0cf4fc840754d97677f40fac499bda0b584ae6b46479f51019a46c02aa13d6a2b4dd4a2bed874dcab58e575027251222a0b817dd584e0edd8f237033a33e96d1914be89bc103c6fc6491213c2e431b7155abf021dd0066bf5349e41ca732f9dfeecac4aa384ba67ef8b5aa4f8127e10d976aedf2ae7875864a957dbe5f7164a52f8a59d04547dd73409bd1e11278c131d6e9bef64ff5971804efe23ba24a884b36d5069f05134beee52e7ee1ad61514adbf9a4d2eab411088579b9af475d5d527d09653a96aaa5cb78e0ecad65b26f387f90c64bfa15e4e916ed6fc2d99bd1e141af0b431390d623b4bc236c016f4dc865486ab01f44657cfca4ee4a00e22283eff793be85aff30a7134968a8ce1ec92ce6bfc86f391fbfe578aab0ce540b137b230bf27c53b577827166edfb0d04b5ba2bf2d9ca16e787107585a56e1f459d3fb13d3375e096eb5355343b137e454149b89fd5d80984a0870951393853f83b4c83c33dc65626fcae18cb04710dabc7158818477e1d9208c055ac691bbad4f2ff498186d5a6e5ea3a22f246ef4d3eb296067c343a5d3a0c2db9301c171fffb417c8d71200c4ca0cf6dc049e71b9b44fd82a443ffe5acbda3dd7849d0f031ff768b31b5dd5418d81c7ac977ad8fdcb501f12b3e48a4e248da41b4ce29599d8aa0b0be0feca089d66c1a6dfdc3a3754ac267f4377955f54edade20e7c6751a148f2831b1c2b645f2d83f1e4b866039d3d08fa438fbe6b1aa159f56a4d3dc9deae4abc4098caacb61c1c50ad6a524f1461f60fe8df22651e624e9cc08ffa35ae497f76d93c3b1f80bfc44ffd82a002a23973a06eb23250a0010a0f68b317cec13df8218fbb9e50dabf13c7d96a7f0d61ba7c1541da34bd3b9797a2bcff7ca886fda0fccaa0f29a9e69405af486b11d6720d3786205ef881d263a20867dcbab9469ad57d3d420d0d04e8ca776f4d5f071ff09fa7e7caa5732746329fe3e0bbff1e2621301e190cab7d16efd336a7fec87eae4892db553f6ab7c29d5d31f8bfc421c62835b921cabeeeceb04a279bbea77c2ea987043dff7d234a211492e018c6adc33f53fee204457677b5dbba0bb06febf5d254177f3626b50c090cbd2d19ed8844d01c407f14c63b1bda97023f95317fc2c13ea94199dbf5e13d0cae66e81697ce5923d623facc4e76737864cc922dd7506071d47b508c1841d3b7e99aa7161bb41054d55d50e5aad3e381895fc57b2a8bd8e495ecdb32cdf279de1788a0dccdf2575cd5479d3deea05bf3135b7acdd4be74987766cdab849bd068ca57a884652a53936a9c1d0e63f69932dabe291a132788706d623bd692a4a7375ff6af18754d3a3eda57dffed607b1687562a67555908f78cb1cb666f1357d006c24757a8c164ad3d60024dc0e85a393296ea49067709d00f3bfda209e2b5f146961f9d18ea65419da213cabf96f6cc28c329fef1d45b0b810444002997e03be19fe9fca47b7535e4ee1627ab7d385fcd271709ceaf7b0b44b5f3110ce31ed6d6eadd53cb037bb0dc96092da4c819a64c7cb34e404fec9616f2d9cabbdf4f4d362346dd2654219e965dfe310503ebd965b2cc1486ccda227094df3e17ffa987c542afc744d574a6eb25f46c0b9c9d7607252d19e7c6aa3f034b1c5f30a482c328e1eda69df5220a29ee78c6ce9e48a7331fb257b55c235a1b5de2c18fdf472a4ef3a450ca153ace12c7f15d341c5beb3be0cd612ed4c280b36e3977400f99a3990a09a0b55455b3a09fdb3cd66abc624230236172dd222ae9e4ec4baa258edce1912de8a28d5b7deb9cfc95f2fa7d992e9f45eab3c44961743d4b211773d1077c5c6f664b6b4bb6077e961f8909cf6b6916e923b1f9359b33b2ca79a906a727c7558aea04ff8d1bc3172c4b4169dc1a0164d73cda5db52b6f9d409293e08a2df44ef4038d3c8e995e4b7d376f70f2dba78f7fe3b28aa8530ba75b3ba66e160cc527a0c1ec0ae827a03139d3ae8b2556e3424ddf12becc97f8da10c002e082d5ab389a5db86413b5428b5ff732f9db0179e4de704872c0d4509f0b4692b18764c403c0d046812ecdd93694cbc681d689ff9e9da92cdb23b8c84b6aa02f6420dcb48a8f9d2c0588148d4c5aca831f9c1dceb6d7f848e610e0d6b9805366e8a4f8f40b36d6bc0a48b1989b852a0014522b39644be852c2f7418842c2970690fe967019d2f07ed5ab75b4ea25c3c8402f6d6810fd080cc52f77c023e7aa09ceb6164065fb5a09775d7d92963a9006cd87818dcfa3114ac751f9ff23bc9b2f0c599a84782aa240ca0f78c75573450f4f8a273432745fd1b387c86173400b5a0afac26128d98125c6b0b81c35f41841cb76c4d5fa863783916f6daac67f9975d25c5250a4ba9723e2f97f7e9aac049ebf4333859ffaa2d470f8b325a71ae292cc58ef81d6f182c3ac2239e1fbc21b0f259ada5e4c189905447784291644c3e2120f6f7dcd69b0b9721e9ade5ca96849dd9a2393b590465897cb8b5d3b1ae6826a193d401755aab8a7af60fd1f8dad07b378de22165ba5fbd192d33155c64af35c6cdf67180b8d744b582f01a5e7ed248567e6d7960d5edcc4146c8a3085a9ff38b77f6e5a9acd8459ac196640978458ead850049acc175d945322d840abbca84d9afbcbc58a7dc0b3d5a22843cabbd898c979ec0344156fa31ceea3787889f5f548c2bbef271f0fd0f15e40f03878ec3a76bac7a3914ab0a0100faa9145e2c68014974c2c0a32390287c81c9ea2afd61788752c6b84dde59ec942a5143310bed6784fa40cf6a555dd2f50e229a9c3e394cddefb29bf280c67f170fd3bf5fb578d15a9cb1e9ca865df717addea54d70303d83404e990b398840db8d46514feb555d460841ee391f2917ab5a9fd03bbd1278e01f3766e4c1b4d5bfea8d4d7618439d402850101fd980f594346d91a832bac0eced984cb95be6f8eb9b4eb9e7469049795d8b4943ad856fd715349000a8371ade246fc06ccab1aac331a1f3fcf62c28cc1852b6b1f3a83e56d272f4a6853efe61bdbd5ba44a82636e3c12bc9bebbe3ca5293f8fb47ce6d416384579a609812649910c28b64c6e5e1baaa248e6ce1cc191738d8024e768ed208be99287786c0f374284b02501aeb47294daa6245cd0cb3230c8724cbe865fbfe92025693049638485b56f9878a9cd9257b918fbc022af389496692ac56479755fd346129602facbd964febb824e31beb3297fd95f677dba3f1038a016af31ccaa730862daa49f32fa8f20bf5cea51a357aab51169e945d1bf5492de3a246a7e93b37b0e0d60c84a77dd030b771519d918ec55164aa38b36479ac042366f419a9f77a5d6ba146dae3a4d10122bf1b8fda04a596f617d95633d664f08d83bd63500a3225f42e3ace9b4ce72f221ecb29c29b535f0bc7bd7227982591166dc3428787eeb1e302c0d5e0a5189bc3732391335beb61b2073098ea3e7543e8dcaf2ddcf8af9b1a422fabd74794b53d38fe996b3ca8cbe36f3396d929f8dcc2aec38221ac9e5d8a4c09f79fabdab90edad53bede34f9b8f112bdabc2e3eda84cec3b416dab415dd4064176a30c2f5e933b7e8af919b74e83dd620c1214979afacaaeaae4e34a731d4064ecea9e853b09ac3d5cc571d5856c01e0fc54781e83e4aae071e6f96afa283c3ce47059ac3c3ceb2ff37f9ac211956ac972b2258849caf02423f4d8242dc1c36ab8e662c9d208d4df58b66d8708f5eab0a3227282ec6b2172ab07ddb8696d96fc91f8046b9e866d2db3648a1e90de0bbf10110a5f06036ea15457f3ea48435920e8cdbea1efc1d5067ace7f7b8c15be0cbd19c3a6075821f204853bbbd4abfccb60ebf9852747ac6fdc0b481854e7b6444d9643de36286653eb2a472db3cd7b92af0a395c06c8f53a863db8b1ad689c0a225b772b6d41ffc91b26037728607dfc1ac8919c266fe927a3b937f7ecc89b2689eb740af9d285ac340ab347db8dd42265aefae1dbe55abcfb66d04639f0839d04377ebf4cadbf990766000245c1e8408ef43a575a571ac8a1a7abeb703b71cbee08b4ff80320ec4cc241478ae4d6988cd4d2435cef3e372f3cfce55774f05761aef1de433ee3bfa674948f9ac18b721539dd7faa0d167e6d8b0f01fde58bab8002f4afccbc997c20ea26750e075d70e59b0d25b2fd21e7864e14f6a782feaf7bfd9d948bea7f6163fc04c47af841f5198bf5d01c3349d393c6cb7c22eeec343db0fa1408d05beac2bafdc41d7e1a0848dbd2e5b11530fef40e89cb61210e55b403fa392a1d8de320f40b0083c1e76effa5cf53f8ef2cf67a1707bda2c3b22372d7f2bba841443a1c325ff348bed489cceaffeb07fa498e3a14ebf5706d752b0f842e877faf36967dcf4889108ad4c3e0dd10073eefdb8896e7abb3bf20d924ce5bf1594bab0a61ecd33f8941edbd7e235d63775db153950e7c0a309b3af795246ba06ba2bf0dc64e597fc0d82adeb37b2931fd3b7848b7c2fb6945b1040bd753c7332b93aff6615a19165f9503a9d8ca68a8243b3916a64cb5386ca7312681069e06514872c3adcf420de69cf0ec23f213467c7b6dfb4d0a3e04c476d70e81207a75280fef0c798f47be25f2d4ce8a47b361b5f24dea1cac323c2fc1cb8fecfadcd041b331a9d7bdd8030bb355cff6de4ec510cf286498ac3e9ebd71bd9006da717578e7e75fc26a5a947cc66e7753deaf54e0bd4742761963a57bb044fa3d5fe7496f99974cc39ba378577301f77dd4f41e487fbaa06bb883d1b97b689d2b0f80a3f35d8cfed1901e64e1a52d82b7cb2b141f679c8a196edb18ee71fa56f7502912d88935dc6c5b09998da7d66c67569e891e6dcaeaeb261da57e18c18edcd39d78cb9c16008e5f336a9a90f87275e02740b7b89324a2d8a74077aedce4d2c17591eab90b8aa3e3b5cd9052d3238082bb3391e7b8b682c729aa5474fb3760d3ef1c2b874e0cd71f906b13e763d08c441a7042bec5c12cc0f8cdfcf21efca753e90dffd7daf387f67fde7b607a1b2f222fc7b0d5067cdd7646847c1b00f4b06ab99fc4855c2d3a51fb9851a2588233b3574e3153fcf3f4b64f3d4b446472a3a085d7e8c22d2c35939168054b8e158adb88939015691969db448eee75abb55c1379cc33fc66904203d1f88c6f15f3bbec5ee25a1e3d32066bd3991dd9e304e30f472a0d4ff7a09dc5c10e16234a4a58461897ae948a746b8dd9df06f7471e608a8198bf9c7aa315d048d61d1e834cc2e152c9fa37b137cf84bc8fb35b223617df36375c83cd1e3836235ed8150c7f9010dd23eed8c017de2d7781818d2bf7eb7d84386017d27f392f70de21bb5698ed74a4a3d59eabba983ac0a127d57f468360e3d08bae96e4c4f9ef7d3b8b1440096e6943fcdfa74a64c67c31b0d45313c28a205a1dccf05d17881d618f63deaf8b04444c11dde8a89da061a5fcd842a06c440a57e312430c06d1c73f65bcc27d8dadf4467b7af56cdfd57ecb47c7745271d38f2d9d4997e798eaface301412bc17beb90c70bde7d7af4148b492d8306b14ce29f33fb26a9e067c1a37381c5766b5af8fb7f4141e1af40e48fffddad2fde120189cc119028d97a2dfffbfae6cccc10159282a864c92825c52e8202207f50040d51299c7332db8b8293026741e11536da8e9df527d86a7077cc234252d74964cd52de9db6d7db3d51d26741f0981bfca917d429373a6de565f117bd4776b64c658ae0217c193f13da96990b6cd4448140f5c99d56c31469001892c56fb3cd6ece35d43f4fd5efd6f66de6d5a1b61610faf3f333ab6fde4dbedd7bbb701ef321a30a61d3b3837c105f8d74ecc8ed8db8f203f627da933439a2a519966a4f9dcd16ef1c470fdb7dd3e6d713b84913bb71109b99da406f6d9e4a88bbf46e59c800f26db4da44e6ce6bfbeffd7cd6708408993196298fc1ce67328a949dd73abbef6669580b9373b53e6d443b9e2f0eb39e20227df6cd04e173d7065aabf6dcbe1c723e75fbebc1c20a7c60833b06ba7a9f5653ec849380e83a382704d6b168af6296c36235bed0b8d0de4a40350ef11e2a4037036947cac2776d85fddd0f4d0bcc3bb8a01138d03e4351787ff89f14baa622f226619f6888148f7c1430b2f86bb189bf040dc0a5911f22128d5c8b1b476e0d07945f9e7573095da7af9d9945a481b1b1a337bb4066424774302f930184fd9d29b3d59e595cddbe9ef6b7d6b8c2b409cc3d3b946dd4c94b514237c9a0f611475d7ea4ef32dc3de382e73b4f5e38f40b0574f7cf6b2e53b3020c45ca74a037ba9d34aa4785434d78b494034a954242dafffe74222d02554039d7377407ada9853748f755cf676056f14d65c8e41692c117efdcadff6467fbf0ac6ae8e5668718ec06c735498e1925f9df400c7ad117c17782f1e843e25beb062848e113a8395f71c40ced988d080d5820d5b4eefe72e64df6a4b52e3b0c9a4abdda4423f6f2442028667731f20af9f3d4f2bcea1633dfb41b20c2a3264a2880a8358619666e1bb5d2475d610c4f9e2c08b4c6792779b476880e767247eb77f69a854fb3f0c81014f3685a9738e8da3712ca7012c42c3f77e8a890c53bcf93ed5eaf07fada0c9fcb6212839a2a22e24d203bb6f1aa86eb48fe31d17bbbea68b7018317985e7553db270decdf236f4e441959b24a5c68b76f6b9e896dc1c5c4b04162ccc3d4af0d2b154198845b3743ad2a17dc642226971a5ede9e117c012158dd5b5482b16e3881c9064af75d9ae1ab742e3a28d8b2902b3e8b440fb3130c8eb27d07b68c8ce6a6fa9b633486033cf48183cf3b548c8179cb151b398ddd64a0cee0c4507051f6421d0d5d284aacb178b21faf07d0dc91364372e92e84444d65dc2be1132990a850e9dcaeb05ce32da2ae5427ea4243b9ce80d5d6ebb9d4539c55a3864fc885e12491821256773b8e469a30ba3731f7fdce84f7ad9fa7b28482119cb1553eb6e455af995637851816999618fac952c0b6fc0b020b52f4ef82fa34bd9150f917777d60a67ec5a2269f4e27258c030b35003f0c70e80e9bdc0232661b2d7f0aba67c760b641dc886d556c2e3a6de587145cb533169adc4a834ad778f48393cef733a14a9a9633189c5bc745933f5526488d134c1ec2a4cd94b3fe71de1fba6be979e4c28b9ebbc2f011ccacb7a1b39eea13a9e85e311d7c41e6a3547c5689d78e4f567b89159650df67df7bd17c5de35145bb8eb35b5a7bdc7ded4689d96281e3674330c3083d9025d8cae5684a95716c863049752bc8f843fc774bbf0654f8d28c5ff50194a3ff537206c75fff65dfda8531da7175dd4c3a2bc09da7fc7481346da9c57b9ddd2c3af17205cdd07a0e44e846b892f1bf0da552b4841256a3540f7a4e65882e90baa8076a7a8f4e4c5ec3bd83c8767baf376ca672c6ea5cde4acce970a383d59b91b6a31d21c3eabe41707fb708436021420b7bfa8c1180ef7ae2582e5436998009ea83a88ea9b1a34dc11b387a5ccc678fefe0d34779e8f357b059237af227e9029ca0bf649d3515bc35fc9847187bf6003bf059ce4a8a98bc83747bc184dabf9d595da073d39f0872bf945ae58854bc8b846642eb2928af33ca7bbe22b623e99246df933b381d77bcec143948e583cc0ba1e02d3f9085692a6cd9f127bf5ceb7017aa928d9f96da3a958f13ff0e6105e46410f00db3ccd2b43e48fc3611966dbe945bd8f673d6c8f2dd727f26370c7e2843af231e4ee0538d88c7132d6c58dbe15e930d46536d51e36e68efc7c321d945d3032ce62caa816a1ac2f73095964b651f14ee3052304d47415f3e1e078663b1c8929bc774b89de12ad86338c395019eb9efbdb998c37670e51bb85813041e2f497b69f1111f388969c895edb7db6a8cf25b6ab89fdcb99eb4509376a24465b7172a1b667647ab1e767cb3b5485cbf83536f6ce7d9a39a851f9a5547adf70a59985973202f65b52200b798f21b99da829ebcce56bf17a3bb6fd2b4f986cb89c005cb8951cce462eb4618c1f21f71b86fb830c903ef993494021ac9513b6f95fd2c6b103261326bc9cef408f7ffdf4b4bd332ca473992c7e38f15c1cb4feca18184a4a2cd79196692af4a02275d5cebe2f4d4da2c418bbac58a786db5a883bd48de6c075b958401b80026deaa86c8eae01132b55a0fac4b39263ab7934d7906a88f2bd1e78a268dc54319aa6165c483c49faf2ad3b202c495ed53435b84dad00c1a11b0a245e1ca899699df1b2c6ac2af18f07af127716b40bfc5d77914f494a8ee5049990d0e00266d6c7abe6e25cb2b8d923c09c39183d49dea9e529ff38d3cb85f348fe9b94196c1dfb5564f6cef1202d4d2bf21ff15a5e3221c2513d423c3e6384d5151c4e4fce5bbad7e079b3d4bc665ec439514c4c3ef477ab855a6b9ff07d5bc8c270de53822a4b6985ba1c8c51d59eb92d2cac362bdb4fa485d10ab1fac30d6e5413144ecc2c714e28d84f56d80006acb73f68ecebbebbc5b7ec9b240ea85d47c6cd7e6c802c30818eed97bdcf41cbddcd439d1af529242a36781528169b7fa78bb654c3891d7d739ba87c840f77d4a27e607fb3872acb08de5f059109333f996b56619c5bf31f41daa7d81eea49ffb24103406d3295d72b69855013731e6f01dc271780e9cb12e5e3a8306865263543d58d9e13bc6124b4e4eb97d06272d60e10cab31102930ee3d929f614b410af988e98695a1730ca386ab16844affd9bc6e37a35f0e2cd2bc854583cec7c9197a1cec1e80c8d697ff9073f8f0645778f29337fe3f9d4a614aeb8912051d8d591e5cef76651a74a755bfab7c0f2f3f0088e13d26b572964a5d8972898d12cbf7456e4dccfc009b5003127cc0cc750986a13a7ca215598bb49d5783a12f5d3ae0f4888dd40b46078561f39b2ae0a0f7227e92853b8caafac27208c3d7e3594f5069e91341859e96710b4897f3805943b8dc0ff0419bf3b8370bead11de708aaf9e8d4d6fa58b86a316cf0306c473123769fd7be214c0f2ad5352d0e7cc03d5eb473b758260bbddb48fd93f5e5917b445b7f3eb036732251a1069ac7c0216373bfc4370ceeeef16a6d52683548b2605d37aead2a90a477e4b3959443648d207e0d4cd7ff30fc5dd1f9298dddc1f6d1ea42effafc220ae5906c3e9c3f5b5db1ee7297c9a83706b7a4c4c54b07a3ef3731c47cdcc10fb472b61d20fd4b7adbef28542eec8600971c0b451de032bbca584737d78012fb7c36cf040a3ec64922b2343ee034f7b95aac398038ba79746f5984195e5a1b192db4ddc1a42053790b44aa36fd9bc7011f75c13ae884961339013085b7abd370d78379d059df04fa910d821b0038c25ad21b453151c6d91cdf9ff92eee6a10179b539c9bfbcb2a13a6544c0eb812177d84a000ccc0f44b575226045dc91442091cb388f34496baf9a40254daf942ed986cc9564d0974ba49756ce958650e2caee044edb31c653aa02cbc1d888a7ed9cb08c77d0408f5898bc234fca343d571f3524c19828bcc4eec356dff934f25759c35655f26a29f5e6a680eb57eadf47c3a36902ec883b4f4c842da243ee2d5ff38936bdd1d07400770e801cba08f319589c2820d55f492c9954c6847cfda853afb0ac693884c876873d1e04f3c465c0dc0e8dbc1f55b25082fb268a8d5e5ac10751e9c79d32874a73fdd99230df47c042bd8848b2e15ff05f320d7e547a82b9f2e1d4c509bcbb6f7fa158850fb7550c6da426558d916196245e288fc930af0e28be9ad8bac340ddc646048bd7567e929cf768072278bf40f10e98ab7ee487f9c77e27276427e40ebe6f38d1c5bab029374bcb6a795cf0a86b9e58567594d02afd68b581bcfc79247940182539c16375f6a3f36b5c98d612e0318fd6baeef73eac649779c76804c9e646a9e5ca0f4554712194cf6d962e783a148362e616a7c0ec294e8cfa4b84596f166dc3a7eaf61060b00f3c7ef1ef70cc97f44b93a2f56aa772a1df59b43e752c86ee94c7011f52728e9bed5684d5536eea8dfc7d88d06c3147e2dc8f78a36f626bf845f22ecd33d5c0a54221de038f5efc76653ac8f240c56e4a9590030f92bdf8d0c5b5f13b3b507fc2130fce1c1045476b10783f4cb9387f36b74c0d379dd52e016ec9dbedbad7b39ce85a3db66b62186f397fbdf6816860061021c27ef66404b3a8662620d105442045220abaef4ba819c925a3d4b4b20e02ce97aed64a6de3cc2051cb7bc08b2c53a05cdb261868caeb431317b63215fedbb92947d447516646901459dc7cf0951edf82ae0059e8c1e51c6460ab65525ab3f1d412c41e3371da153a7b14b46329cf4a8f483ba8bfc351fa6bb1f8d988d50504c3d498ad53b8318b36f58b35d8e2a57e9ab986306dfa34cee5b97d35171c3b85f2491245135a12bc0a98d25241963e283ef02ce154027a3d0c43f88542d25d2350c480171ec1a8b84865ef50c69f0f6b286752e81dd0e53a202b08c7e052868e91f14f7dfb039c2073c5548caa08d0f42a003d3536e8228d905aaf114ecd1f61c4a03a881c2171314b9341d3520206e7ccc63da661a9542bb7a4adbd5e2392229227312c770bb1b1fd894ecc24bbd12f4eb502fcffb847f9ee6cd22c99b4b1c3efda082e47c598bd3112f62831be0055695742cc1666d841752a58079abcc205b0e5e4d7906b26189fdf03ecc781e569640576693da6f6300b9c7b702be48c6b5fccbd0d17c4717bd69bf8f10cafd257e3ffba5c5f1551e3e60c4c9eb2b658b4ca7fb9c84b7391509fc2541068fa043749d1c81fdf9dbc7ff27897ee52617d2e868d703f709bb8773dea11f43b84ef0913385ae26fe4a54a9e1d97f382154bff362166446371d64ab0437ae8a83a19cb994a67a0c9c3bdf2df10c69e90768e145267258b7cc4d5f6d8e691e1453e789067a30b4fae9f459b6bf63d280b26a72206ac6842b085a6f6a68780adefcb0afbb3da3c8bbe1497c39259edad0bc2bd385cf610977a866e8b2a4baca632ee8fe4b7ea248be74c6086b5f0989c28ab9cb372c6c9a8992b038cc9dce09524e56f14ed9792282e01b031952546a89306d13c9456c9fa022efef92c9d6e023106ecbfb6f80d8bbf4c69abe87d675d7386a2fabedf76b2bf3a572d132f06c2ce5c2e0805a72c49909b05ca38de5ae15727d047a301c63f0d24336c43e8bf612678cbf52efc4755d67caa9a20e8abe7966bf4a6b1c5e586aa6f4d9b5ed78bd11cb37442885a19204e899e825e0bed3fd1f219ccab5612a2ecf858ca790190b8ff109aeee860b94c8426717e81c94eae13991aa79f4887eb5a87374be454c96b6f367a845748af2613da0748fea4e02e9522caa924f0283c09d4841fac7691f270a9f16534f9b88972238ccd1f0dd0e1053141cb3571fa6ec54389aab0dd2087bf2f1445f99e08f6b3965622f1438ddda06d1730d05f8517fd46e9442ba2cd6ee3ac172f866c1ffeda44d39e44642e9dfa2c0959226e32d45fcc2fc63bb4b90f06e4b1b27a92ef5e0a0af136d5d1269604f446b5b4a97c2f4a300acb74cc494dfcec47bd837adcc4014e1200ce7f000106f4b339dcdc129bb026415197818731562cec827040c4c7d03eeb8f3511f2a4a2a6c633c5dd32391eb41d9352e8eefb178b89962a7f7152f539b8d6db2676882d790e5454b37d33f50c10375cd77b1982e6b3415b9ea4f84cd0b8b934a2ed57d415ec750f57551a18b56a680f716253cbd63c80c033097b0efe57cd1140c0ad2367f27a43ff377c6f66916599211023f25c234039b918718308942bd606a089123e939cc4ac000a9ab76120bd63f3affe6b6ad2e4fd5aa09a04426ec0f874886b536e10ffb13ec3a43485f07bde7800ef1d385b99ba161cdc34bf3341c1fb3183da6493146631d118f26d94e2a241793021de7fb19a684c058cac09365368d8622031b9dae1be201088ee78e283747c02111173d6f59482c3e3d61961bf93ecb3632f8d6f00a81921429a6dbd461cd0912f5a7e95e9760e2a02e2f9b026c2dcba02834c1d6e3860489a98de89e861ab7bc083f5fff5df64cf1003953a28b0b4d4093ee8bc88e8179ccb79380bbea26a4a88bb15a147e04f50fa0b88f171d0d1f088a0351698e52083f481d0346de19ba4ad1d17292bea996450cd91da10aa9c484f18b01f5ad3ddcb122d5afec52773c2d45a363887d41117a40148d019dcf0563e0f20141ed8eea92dcccbc6b1833844d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
