<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"010d1f75ac67b34ee7d4eedbe3f85d43c46e54270ff1d2ca72b00b7d1f550340196e6e74021e3bfab01c7a36c1a15da252ceb79c0ebc84f9ccd87cd8345e5010694585636c6bf36d0ef19d9d706cfb7de2c39a5ca6712489471b4d400b7c3abcf0bd8d50a23b1d391f79b78de32173f7358e73253eafdb65640902bc490061b98d5062004c03cbbb521e26960aa9a4e31408667a806350da0c7111ae902b72f9cdab2a4639a9d6e053905e514ee8d7f53115ecd34fdccac44621377fe572452880a2f37007d23d2561953940e43a9fbdbc628dfe4c32634bdff5fee967e9871d0277906db21a254f0bbeca4dffec6919524a37134e1dd5caf606de693d4c09bc2f375b193cdcc83d21c09b6bd934ab54af6007f4e4544c1d22be2d4d15df44de3dedb106e559b074deefb8bed2d539e7b38a2386600083a64499f89bef0ae9f7f93709ba395573ec248639d613cc4faa2c28c7adccba5177591e95bce88da6f13c4e0f853b6cc9dc40f72d9a5f4e0f4764e1c1a22cf8a132e4d82239fba103f6e4662db1df8a12a0774f4642a35e4a27778a081f0fec0b81598a6ad463addb8ffdd6994d7e975ff74c207f6cb0d9cfd8bba3a442c8fa7ac08c901a8555c666666a2087b9b775ba4ef95722524519d4f89e0767f3d9438bf6a38740f73d5f1db94d622f03a11b4ab3c4f0609ab4ff9894d018edf544db1bb2a780f64b3d48e647847e44094b7527bdf3cd946ac7084bc982c12fa548343791c11153ce11f6a2dac34528365353c0f9e400218f4e8920fd2a9ded7d1d1934ce7f7c1d68068eaa1fc38923c5a8ae1324ce5bae5232fc1c5f788731e6b42679ea3cca63a875682e11a800c0603c8e4a6f26728540568b194771fef49e92c882134d6947d4f5f06738ab3f73dae1b43e6d005949d5503df961ca144c788a33c403dd620f594df2d248bcd99e644e7ff88b4b1279f3c17ffbe4ce17812efe995363b7d7d2f201289fbc8008fc620a5a91242b06334b5b89f029211a92c5d979b0ff22b947022ad5f5f5c437940bf6ddb49cc67b9682b25151f64ecebb2ce59c0c32af7912117119310bc3dcad487a2af9fca6160cf55c1ccd4795e7de16c2f948f5e31e3183fe09c486997ab8fa3552b9ea638ab69bbaa53912900e7383f077f6e0ff35b4c9197846657d2ea6f4b772897f09470d8c28c46aa07ac64c52eb58f9f72a5729ef00291bd5b3bddeb7b7b3fc800b819c20380583f8c5c2a5df001432a9dfbb405d6646b1191b15dc59eee66552f004baf4283298330beb5edd35ab05f2b223458448a2d4273375796429f344edad9a47848a20904035e8b9a532489d229b3d1e837714f39025bfa18cba0cbd4cc80f7a6db765f6d5e47fef968965b495a0ddbeb6d1d89777de3d2bfb5aa810416eb452081f0190feff2cb5486f0d3a935822d8b6647a47f8ed04af74f5a90693838b692be2a08e5f65227ef2be402c5d1628c59dbdcc7ba2ca0b57e960e75fcef0bfc3ab7db510313e44f746f566beabca25fcad532c84076171a3747b4781647863437c37ffbf3faf6b7260532211b530035c538191fbf8a91e5a88bd36966070b0b751e2e7dbc55157b042af19d32ac7cf76a45c6bc1d1dd634b11d5251864adef465203e34f297953150c01382d0e85fa24a09c62436a678443e4520275f7e4cc6c36a934c4cc88d3027fff9c50423824ac164aa31b9558e20d575463dd4f54be49f085190ce1784d005c67f5a169f4c903ed015f2035634303ec4492b2ef824a673b2fa505d1300ae4640d18cb282624c41dfaad25667b3dcbd8bde812d7430044b0acf8663409c2961d317f675a68fa43260b90f30603506e00ca70dbe62b2e43a203a92fd0164a9cbd0e5378046aa008672d033d6812eac03b6169fb2393baf5fbb7d1ecf0efb40d23280804ec87eafa25325d70d7f1980cab8b46a69ad950cc3be6e2baf1686c8d86745ffaa4236de046101199c241c13356a8c3adebad06cf8ebb039fe1e3f9dcf2c4dbbfc3e6d58cf1cd20c006a64ce15d06fa044097022104fe005f0e96d2e62f184cd8f8c8f28e18100d5e350ee552a40db67ae095f8b41a7a3917a1b0726c64ae1d4e45f5e64def4d6379d6fb8b61d703384e3e2fe140bc71f4337e813a99a747d1975cae13d6c317872e8f4d043cd4c9d2985cc973ed01dca00b7ed57807026290545b3de6136b166b61c56050c249ce8a4551ec2fc43275fb7efa491252269cd1c290f09165ce116b6fe5b66d729f6593705219367888168b4f8bc3924f511739bd304ea15a7649c11440b9967e1dff38ce58f5f9f45d6b3cedff37486f8c88c462fa0783701609aab0419983d758aa0bc2a2a46b72d398c64d3d4f24dae74194b8a238ea410ebefb86714de410c881ea448a43269e6d91f06f4135b6b0ce03163bf9cdf9affde3255255743b048cd2b318f9c0fe75355d8ca51c69dacabb3c147931b1a1c864b0f964cf30c710f969a8f84c48b1a47f83abbbab978b0c0399bed9f5c1e61772b637ff1277175c39c923be299b1e832efafa6a28ce8faaebf927a1cbcd5c5b32702b7aac2aed4b6b823bd84e0713d5350105007f2ad4771c01d3e1adc0d90fe3bd187a318febbdeb1d905fecf5e8dfef7431712711425070f1c4d5b6dacb3417011404162b8cfd8962dc3240af0a621d479a95bb4760907d510c2921fd9abe3fffbee54fff3af5978c5ec537cabf63ac24845b259baba49b2427365be5e01e5b1f979c2a60c0061615c24ede59d86d4a5514f84388f86fb912632df49dfc42ea8bb58dea1be8220cdf05382eb8ef60a40129bce194c6d85e29d9df0b036dc034f6568461264f9f9e8337d48196f07df0fc9bf26c12d0ef290849a7e67e52a732381613b81b12eba402776d74ccbf0fb904c57a350e21158c56d6ff668900a784a9d60aa115aa296179c1d14ff792df633e53e5e516d2aff6ea09f488cda516592a81b830802c7dd5ca949ffdbabe0a5c6cc948bcdd552c590b4f9e3e49a73f1d0b2d8ff8a4755df6f18f94329ded63c8978577b6bb03ab03e27c4496cfc890d8d5b65e108a2ec21ca9e27b906e5e56cff00aad72725f9b3fe4cb2d180e3777b5223efea531bd2cca597443c708a332582d3032568f4df92d6481f1fa1721869e013de07002a4e4e0c180192e299fee38075488a36060067cd087c64686ca3f092a9dbaf6c9498455a1d65741f2a1b57f523a61747a063a0a8dd48b65f5abb20471daf3af0b684c2cf4d29e26216df48dee56f63883ba568f9a918a2465badfd699b1ee67a0251ddbbf04ea3cb06169fa651bbe2198e38b0d0e3de8f0e58df914f5c5975d76a71908330012a7933ab968792941d9885eaed8261b425053775a62214265c364930049005ce07352aa402abd4d0a630dc58ba27548cafec0a59aae8cb65b4673a40ebd003f60116f8be73e16acffef329d1ff886744c8e829fd8ab096a8584295162a7eda48a6bef60d2981e8a14f766160f66b743655acd103b2e82d11eae8aaea6a39cb1cf595fcbe2fe6b07121af6300162513679515f7c3edc25560274e1fb7ddfef343265bbed42b1db97d6cdd530992f8dffe189bf8d153771075061b6ca0899b8d71574b5f71fbb43afe396052af3d4aac245837a037651a46078b12347ab93171355f9d269b591f902349437ab4700084aaf0413ab1499897cecff22778f0da9c8801e31a717ccf28281560410b97ded020f547dff1bd9f10fee14f1e8b9a27b15680967966ce1df702f39ef45b9da438648a3196a8893fffe0e39372faf5f75b8300320ab95ab31a345ecb0c463a850c73f3a02863f30f717a3fc6bf9efe09636e76541b2c0069c25029d7b0553a4674d50fd688ae4bb6fce02e90177ae600f83e9f70beeafa3f052c2e68c9253e6bf3aa985da709c3d636ce37476c1349c7b601dae3f7c17b8754458f8da1cb41692ce115e0c19ed97e5f3b14bf1ca1e2ea69cd742d50247ec5ce22adb4520e1f8cf1b3365d975455a5a395cd052ef1c76301fe61b197ac4d064aaf07b91aaf45bcc9ddd16ed6763b93c924020cbb28a5397542e35bd570518070052f8d470af100747dd2a17c3b3e5392b32685d69139896d370875e844cbd36a6790a48c8309a1ba5f5017305459d01507dd507a52230f6e6cab3622a41440c4cd23b9b6e57aac3ab3782e4931ad1fe56108bac836eb364c25368d36fe005d117f41647ec0669d2bbfdabbedd00d0da0cde598b135e08bc68fcfa3fc8f61f98d745a3d1e19f98f0fbac5e973c911c979e4d51e7286fb1a2ccdd2c1577002993ed01eb77fd5161b6ab704e765a4ad7f20e01988a950ec97b5f57fdf7a6ea4f85dadfbea112240670a068a9dc2dd6ae98ba17337e2e50762a3c4b66d88c961a1ee3d27760a8405a66fd92ca1b6523814dfe4724adebd5c10b74d8df849eb8bb264430e6c1e8a9ac68dc7439987bc319bb3eb5db06cdacfcfeb87c9c998ca79f00e1eee9264488d6db6b7af5b31dbc80cf6654fea00d85ab58ab620dd367679053554ab955fedebe438fdad8076b2a3dead16ccc7390cca0809afc28b2a5298ff6d1ff1ad9faae1824ec745274249136b199b8416aa1ed4531a989afbe756ee88aa33c70412194f490ea8010dd4cbfbf399ad52487a40f51dec9b1aff1a2ada05cccf3c2af8da4e7ffa219f86150dda314054e9e35f59498de3bada0723e87088b0dbfd1bed29545c8da6608634ff4dfcde5e12ae9bcb61639605e920f8c11f44b962ddb01a78a7a765d134293a9e7f7ac3bdd5338d74def547621e8190bdbfa2735be22608c4efe07b51801591644653831a279901460434474730b5b8e05c9142b82e30ecc1b2163c849429f8404c205e4208a4ed8fa9219002bbe6abdd8974354fa8ff6f04300aea797e75aa1debff5959a77d2e6e1112a84a39ef95d64238be0891944c71e0b106e029c71ee920ff46395979e284d75709414405840d1246b2e29869e3aaf51f7813996ab637c4dbe666ede6f909590790ccb3bc056d893d5f4c3188884d2fba7b421b4c971f45a8463db66d09048a3e554287565d6c349c7ddcd38142ab9778ab4b9797619d63b087cb36dec2b985db30c8186e107b823648b777e82cf5ca1cf4597e11c5541e0ac8e3d3aaa5a384074578fdb9907754cfcd7ef74b5868af058409d1c359882f29f8e5a6e45ec1595df4caae10023384ba2976b8e9027e5c77c5e33bdfbd0ce67ffcd7b046a2cea8ac29de57ff30d2d291ea28dc708b10b93b7e4623ee20d2b5c4bf3f0e54b2d3cedd420feeab00d87f81e6e685e38463a411eca41db7423eeb43f5bea196ba83f95687e9556458dc0b934399ddb2e550865c863993326c22eb55eb1ab7dbc8b0a03d1c64cfa24c669879df6f487bec6615b41e7c1560e3149fb5c504d030f9ed62c0f3a922910446a091a645d3e8d19d95202c5d473547d147e28101b2ff49c4b3eef232ba5895c7003fdf24d34d4add7ba5975ee041cbbac7bb00d850a26402597282327a49119d4951f55ffe6039f56b6b03dcc885107fa64b5e45ab0147668a05cf7fda996b0a6727bfded5d644a2234c075bc5d673d2831cf662d7769af641c34697672c55e58cc27622349ae61c33a6b134c6e0928aa6443823c4891de1432ad22ed3d79b763f80b0d91701234fcb8684ae16341427df0f2050128590fedd7ca11e89f51aea186bd33b090008cda21b50457e1a711965b65b4cf02f8d3727ec99b4772f56bde4acb7e0620c3ee180672fd2d468c659cb0be5ff4f28d75bd85af3496b0e5bf14064856b4cd537111e0590b96c400b6b619b791c26facb1b9cd4667e5fa5cd05e6e3dd006e1a0be7661735b57886055d5a052089bf2ae77e1a59be637d8b147e66da46b6282c527c24bc9cf347bffdfd8a199c0bc596a3c6fb52af35b42c15bafa7ce3a2601e097be850172ffe0c311d430e5efef8a38771d5a1fefe99fd64a09b8398d8e19696f147b7eed73fdd4dde29a5368a47bd1469fbacd87ff956ff350f16620189f9e3a5c63ac60e289a9c1d25e7ca075e068e1f24b7826c88e75c9eaee365069c53811186ea0fd6090e6a3b8c755dbe5eaa68ab332b32e48a8a681debd2f79710d638fe4c412381b1af7883352bbf0c016f1e643073bfcc531784c45c505a55e872f464b6936f046c1ed60614c7bf4b7728f70de4883085114182fa41b19c59309fb5057f9355964bedfafe45d919d6d41f210fcf09b9eae387b92246fb34de96ff3031f897b74bd8f15f4df29e34d930bf5052321598ad6be6ebd14b0c7924322a96bd3eb2cc20af3c0ac7aa6327689f7fa24978088975cd5a49ac4577baee99172e6ddbc68f974aacca9d3046a9703276042ba28f6365ae48331c740c312de8a52c8ac0af7637f8d5fd2fc97acaa138dac721982eac61504a133ff288c512357b5a1962e7cca50a649d3dedd1b3d3732ee0f3adf3514de1e38e80c4419ecd5ff08d7b295a5981897110164b84392e8d9ebbd92302c1c9bf52904d322f5472ed48d8649892323b813745c982ac4407b30f237fd5837dd87ceee8a90c0f468564e03ca38478e72c40b9006351cf7a49fff1ed6ec4d99cdea2c44e1e7ff16e80bd71df7a382e5469b512a64f8a2697f57434559c9df2a08eecd4522f16f50b35e09e6309c4462e6332fde7df1e6fdf722bd13848382a40fbadd27903df9430ac3adaf9765ecace3722370d2129180374d2eca6609f0a77c1b3ded3bdaf3895ec3279a259a116ae1d0fd389ec294ed49df4bbc532236b8d9eba31ede9f513b2b351d31ef28191160b71da12bf5db7e97c268b7c5ce198eee392221374a055a5fe5fa813cdf71d4d8b7517c23c3fa537c507531d28cfddf375fca6e9db15fdf106e3d88b66d4090f56cdc1a8c30ea2a53d69a6e517a4aa9ee110e7ae73504b58d6d653ce7852d3716ecde756da091798a1440db4d7a6ae545bf5e3110971554b2d2fdd5f127a4c89fb69cda31b81c7803d7c31a739790fce68fefec727213476341cf4c13895440cce038ecfbc4a72a9c0bad919f539e5b7745500d71b6bca9d4697ade267655aea77de39fa5db880994e9d0460323992f3f3798d39627c06713bd659ac69db0fd676d558a8654f16db9f70379f4a9c4c73b20ddd974e974498d74b4625c1561de90c2acae5b95e31e8194601f367700067d3830c6da65ed9917532f3863a306d502d7aa09cc772bc6c7b37197c62eb954bda26db69fae47b4a538ed3a4763dbea68e8a9c6d707629d79e3cc4c7662b2fa568b87dbd96467963c2eb81482df4c324ba3ef8e2d1ab716fa890343c9e6a44dd2f1a4bb2ba2f52df5f8c509e9df01dc4c0a2c48ae65c621a214d7b8df6ed7ed68a826dcb7ad7068a745949a4d51fb235ba00b5f7503bd02029ea0024a0393cfdfcc20554f06cd3df8ffb2456f9f0d0f3e31f820f9ddae7d4e17bed293ad0334ee961a69a4cc22d3a68bf9ca453455b4ed6bc68e30b7a5898722ba4acd7134d3cfc8dfde631cb2b2c94af6690a2465887104e11774417f005c0e5a4505c4c1f825a133f131b243e7ca80ef396bd8464206df25ca8aa42ec2f21d383ba333f74b960a70b327d515044c702a17a3004d8f8caf8f1ed8afc58720e2567b44c726160b4b76c445efacc80051e929a4ec861908d9a5c71ae8690fea1a96e28544eee27c770976baabbcc8accae1af889d86380058adf50b574afc7fdb9df6875e7176142a75821a5b92b20a0436c6477598de89fc38c8c95bffdc5f3641e3677f718a8231b017f1fd7e45de769fa386c4a9c176aa4792432ec0243bbd1fec29828e60ee2e4ea7d741eef94afe4482f7ba89e6c7600444f4a5a1c770ec9d797608c999cc400e85389aa7dae7b778c4201be7bc3f977363e117f4295840fda1d88f77107a98a5bc527866b1086f5042b66012f7b0c2dfe4a4c22dd49f59cfecd35b8fb76e63e2db6015cd44a25d70751463076e5016adced2ae63d8e7ee88eb9ac1b3f32c4a3ad75ebe4635c39f79dbf5b6d4f56d9dfd1527c523d2409e9c105841952a332f70a1b5ea600a11c8c3ca4cf62194cf33bab7d17657dbacb7a075b8bc2ab69b36eda20fbacfd2054d5125f55f82208fb2f20a996ca3540c2a51dab62fcbd3050493ab3333e2fcda1b03920b93b3716219e0bddfbfea75a96a674bd20d8d66f4c41e55f0846a71da9dc5a0166841cb07456015f383b91540af3f21e9c24e05bd56d68dd639fa9d3a72f63c22e7a58968458e70ad2852eccd526baf738ec9c07def6e688cb4b158f5bd2ec684bba11da7c4eca7513367c0eda4dc3771ca2682352b276eb2443fd05473eafb13e7518faa40e79917647b902c86e5e9af75501256719665d2f496e8c5283178807f98694083c6a2746c31c5b065d632640a5c793bc897549c8099edf231e179c5f535d3e3f2c4be2990cf4be49a9cad8c0659b2ae26b6da9eca82cff9c5b2a809e0fb57b02defd5e7631960a158539b544d6f5841f8ac5b68e7edf5d518665db58476ef1fab11cc815c2f884c8ac1f4bbd8ce53a8f406f709bfdf8b4ef0d50c1e550dda2cb0729a71799f25cfa3c7895183425c74166ae95322bf985585569717dd76654ad235c9e64bbac5b5bffbcaf4035b07654628200411f1e72c153ad2ace248ff20c5d02d8ee05c18af5c8514147e6cb67833757b15c8e2610f1bde94251f90365c8633f53bbb31571ac1af676a2a68560991d8ada67acc80302de0ae79413e7d3a7a3fea89418a4a9a9becd55d307fd27bf387c12e80a64b1d15824234ff05f817d454771b74937fb1ee882cf617f9b135dc1ee5bb5527c1ec96996a1377356f6cebdcb6671a5cff5eacf4493d478545e6cf8f03661f8e27a9bddbba7c8c04689d8a9074b0985be81b0f9045150552dd4971b4c820ff74312b76e7024f9698eed97abfd4449f0222fe7021af32cbc0a1ab9c316b9d6a9674aba0c61f4250b734814e2dee6afab95a4dadfe49e8e543ced1e9a1aecc4fd67e15e9f8ce24973b2d1c4d31154ae170e395474cefd682ebb456d43aac7ca4718fbe08e5980c437f1041afe159bfd2a844e4d2f110e5933963d5b460cb2d3b7fa8152c69e7499aea3ae6bdd7afd1514dc89dc2cc948d1c265c86eb3692ef5d1a10fcfc1ba9b0d28fa3a02187cb43dc988d44ab5f1bc0dee62663819449102543d8e186a5c4c686ac5d6f097b14a3cdc12c30f6885f19c8179e4f89d79947417de11410af407a4a2f92d59e288d9e3ce1c26dd629034bc712ed1288591530d5eba42577d9ac8cf459dbcfbdb8bf7bd622633d2acb2ea874d52d6971c64856574e77bf8f52f3e8053985a3e1df178a9a4e5cca963f0c64a0c7a82f4a38157fcb27277269494bf9f48dec4bc7b59d22a809f266cd8d9d98a149eab038bd5749ebfcdd72c4ca1903fd1a83bba9966dc8b7e6b5b7878dc5c1c6039311ba46be52874471e58008b00f71e3387a582b95e542ae5aec0c15d663988757e3e20cb716e7b26e67d47014aa5b9740d47c6d9a9458f040accbe865796a50ee31439ff247f67156ad9670da4639c03ff8310445cd1e94a60e68613a4b4809f9bb1662f77d26b1fc2cb46998b2e2ed602f89f430274c897fa42f9c92bf1d64cda49fe1b0bcf16d53584e61685c2d9049a31d8b6c4a7b4b6d3bd4dfa8d08d1a99c9e3ac3a255f214cb037ffff449413e3f6a4650ef41045a7b50b17c8fe7910fca64db80a92df23c5e934b71c10afbf7adbfdee95fd99e7fafa32e9971a068e12dd3264d1f6947fc3011f98863a651017f843087a0c8c3fe37c5bcafcb48e2dcfa407528cb56b78f7577b8f1668287c5827dd7acd1eebb2e201c15e3c57780f8c018be51d60023a14f5758e04789774c9f3993836839167bd22f548cd73a7667587df3d7e298d14158832685871da985bf3edda008066a830c3cce5deaf549e3c7d7312874fa71db4fa3c9701c8abc0884404e9dbf7a62fb5cffed7a900ad06e67a105c0e70f0a90f92ffaac89cdb5cdcd5ee7a32af8ba82bdf7c09b0efa93a3041a4d2a6493dff88be692e808bcf44e259ac63fc3bcde121022e40925f3af9f0b9766490ba1506fe8ba192ccff3e6bb87dab865718198d67fc442924edc3cff9389beb8e5d401e1bcca36fe35a400ff2de48303c0da8f1a5a9ba38f1e7b1bf8dda8819fd82147811202d3829be77fc06e01e1fae3c2e84cca3a77223cb4ccffe3fc90389a982235d2acb67f544a65cec2c00b8118c0c417083e4ff8524df255a131ef287e142691b702307b306ca38f471561aef593b7c0dd3e2d3b7f861132218269f416ca59001ed10c2dacb37a5b137902e9ac23d929c3efa2651a14937765afdda0d66a4da2a2830f5eca172d0cffdc36159dec13e9221d84654b165b32cfa22b2561453c872afd28a5705b4151d4d252797ef8b6825f25f6445f87b6d5079ae8b01d65d63770e4fd4d959429b4e41ee17e34a72045647548ff9fd5444475464f3bba6efe3c2c70ec52d1e14310a52850a7586fdb7980a61c54fbd9d913b8094aebe4ff9e6a1916daf93b1e8677472c4aa950443cb12fd03d3d1ee521236b00da98f382c2312a8f45a775d4ffe3dea8d0c7c5bd59000cb531c560171664a6707f54eda238cf78e8d6f6cd9688bfc69e0b1a7f909b658e64a013bc8fd83c775d7e7535872b03784239822d598287199e1172c4d92be2945798c378f37bd049cc421846b7323ece3d37b43c568175469e433c93b84f66425894e6b9b9e501ee9612edf7e97c718ff92c2be51348bdbca9133cccfde88da8850f7332afc820b40f9020621a89228839980f84bfac9367345919de7470baab8a9b8e2f8a76a19859cf205f8d2c885c529d5c307b1e4045d63678bcfd856402b5109f3bec61c82fe271851eb94b36c97fbe8310e1009f5c9d7d78f541bca4ae484bbc5c2b8b21cf54b1c1acefe1ebce1222b5b12a45925684663ad113f823b8b1bb44c99ee6064ab2479d294810fcbfed916015c22860fbbf63788b698ef00ead801d98ec4a20ccb6c057e4d1e5ed38dda8b2bf7ae340c7c89e924212f3b80d3231dc55e7dae2ab3d64e8a8e31d5c6f2c7267310b8a6c8a743d2453c12b3a1286688f3ea34c908e6ae4266a2585038ea6e86ed22224be1a5a6b0f919521157f7276df5dfda28618dbf83e30343f0b635562dfb2a3c14352cf1d73775d66b43f2fef9c57654d6b5dac8c6ccade602d1361044e50847e82df0de8bcc6c3c9c021d71fb079fe6ceecabdbeb927012f5dd3678f2bc882d71fbee0ec2390580d72e8bebe5ecbba4d8e6587bcd3c66f9b5412e45f69b5a8deaea699a544266c6b224cd2febe81aba186277ab97c5df1eedab868b6e8afdf11943a68f0f2fb0859aab2d4f525ed65699003a8c5b76a8a030b2a931047194488928d72e0bddc68b419e3ef0888826f561dd6bb5590685c677e402a78de81ea465c67870f5b4cae839a31866914594e6261fce03fc985a2c31a1d260c73850cd8a2cb42894060840b8310f3b671e045dc9a5e77d88814ee0cb9326ead6481f3b22ff4db239ce4bad063c150dc290c91e5de9d88887afe51772efa428ac57e686c9523b6c578f22a203b470cf068c2f46fe5e5a208fa99d31c639465f379b90c6ebab154802e6de85d941afa0d7f8f5030ca85500b3fe3cee92e0ff74d5e33fa62d4fa3f0b75465122c20aa55d2685281d07d12ee47ff4cb1c794e08cbc39e53eaf51c5d5458a26354f0dbdd7fc9673db1292d19d5e4c6e983e27200fb90d67c42d5e370e6f683ffd243f3cb505b239610cd84859dfa9ed8c6ddb04ca344bea0f70e5ed96d029b2426234354fff45b11e37cec5a039cae556fe1c156867548dbfc1df5acffc7aacb494a6a8ebfb7681f202ad654a3b32337e29e580fd2982ec243800c2504d00221447614e4089c43c324e5264d1d7eb41a30ca1534ea7a57830b708d97102b8b1e9cf548f263388067bf457b2f5bc447866199ecad2916f3a80336434a633f0b6b4c836c2e55b52356c5bf8e48c63ad51ffe82093953e52c83befc316a1fa8c73418ed8bc6dd90106dbb02adcc5067242c634440de6e6090456c61f03f96488b666f911338e8d3fb98cc9f20e46f0710d3c90f0c3043240268e64d8f2f58a7745c45cffeb9a9a6cf1c9ba2733e812b01c84eecb8864ead0368509ef7b89c9629079db0da7f21af53c1a1b6c8319f8116a0b393f6b1f7c1d8113b13378ba212b8a2e6a3058969e4a0cbdaa7bea1c50c8aa4b1cc5c4235c9e56b4a61bb2936cdaaa57817ca286ce088f650c1e451f27e37c7ef8ff7bbb11bf8640e54475c946bc367da8e0e8e107b2fead7cc855fc3e1a4161f69c15c2a6448eb24fba43ade5fb21ce81a92ca6ac88d6aaf2eb2a4d29fd9c2829665a851627ab52626c0be8d94f9b0bf2c684c3a6d56472c48d4fa4edb8cea979c4515011cff0d2b7ec86cd441854aae08d190aaf24883e87c21850852876c9d6bd1aa0fcfe9268a417670e235003bb7c682fdfb1c8f97ae1f575f0d7a06167d56ebf7b2e7780fb41be50097c30af84062f45935815eaf29783fc70428e751ffb4894afa8cd8441cdcffb793d1e17454303a21d1c39cf8ddf31be6363aae1c6bab1e971b983f437652892e594665177ee5854b9682002b5ac40e1a532d07757086f62334fa45b4cf7ac9f05809a24a0d78319184116efb27f717b8a624a9bb8b73abf904cdcde223a1321ef17bcf797335d5eb034ecbe14f7038cd329055362b50865208857b00c4580d2953ed23435daea7494e5a603eba4524ef6e4c28e214d7a782cf5703e68367e30bf36aabc13b00575dc24325707a2a93010e9e0e2ecfd66c1358bd9522201ef1c62274dd0e7f77f5808b06935104dcf334152d3bededfa30a3d5beb3d18acaa07135a090fbe5d1c288da8d7f869ddc8c0c3cb0de6a99f505f05489e3c6d57633397e9ad243999e96535c6145f646c8f6a3f5176c8e6d932272ef4ff256f68006f5034da572b9e8e099c135885da94aee382f6c7d5ec18d4a3b74f830d4174b79672a96a2298e700aafc822ca6b1ad771a385697e296793618fb347def070fbec04e16f4fea11074e35021d02d93b646356b2ed9b4c3d85957deb43b11022ec53a136bcd347d5b0a0db8934d7e6d095b155da6ada7cde3dc6467e5c220e6f89fe32a8f4533c75191cd548179921caab68e92dba02f362ac02109bed4ec05a128030e03c47a95a89d841b261d941c681b91661ef7ed47879b2f49aeb5e847df8c15a29f47de8e9961819c85b38d7f6999afe4fb34bb028909822effdd349ceaa4d593ec09d3f61ba84b3c0e17e7841206cad7a49e5ac124cb5e2084a1b02af209c5fcf17a119d3aa26b07415c141fecfa79e95dd1403a2c9590d95ed8ef5261cf19787450679a5834706489b86ce8e93bac3aab5beca9a489821ace3a00d52cf1f70f4e94bcc9ea7b0c4cacd9da1d330fac0cb48f778ce9fb7601431a0dfc602948f23794be840fa82424604e77c0c22c032222cca1015e72bcb483004314b19fe6b5e09921266419a54c5d70a35b2080d555567861a9ecfcf38c6588cc238a23b22b646f677896d1f35ec3ddb2cfe882a90aa543ba0abe1454fffbda764ce9263932fcaedcde0e72af2c6daa1b87c244ff57333f9abd61a63467f2256dd84c1e334923388090e0af89c9da0846c50f4a3c98f49ef54997983bb94b3e2082b8ff718dc59c4f065ba96a0a2b2b07ac5cc5375b7cee7ad6580688e36d8f55e51e2d265f80a835f09d371da99b7bafe46fc35bc821084c201ad822202509bc2c69e68716fd619b4b711e90587d25d352d2976c1220a2f13ca8e4cf383f81477e717d86d23f3a52a4597fb9ae274194a8d1fba032ac8d457fab53d1958b568dd8c3c17638696b55a20b1e2dc226b109ba1f41a288d2ff86999a7bec756112d5acdc8407e86aed124a2b2e7615c139c9020924310e3d2b9b5227574f189986f8e6ac66743bcd8541df511db4b4e695d322806165fb98414f73abd7ace306bef63ebee3e5877eccfd6b3cad9fb04e1382efbbd0b7c38fdddb9dc2a31c357e292145123112dbac4d27568d989b6623af458d2e761ae01895067f1c12270829fed3eb9150c27810904ad91edf5ef6cef0c2bccc314aafa690469f8be22f99420d851bff4e5347ccb49dc118489d69e466776e32d9409db6895839531bc3cee0e9174883738274678d67c680ad0da84c3578a48187a3e6bb4f030b01b7406aed1a36a3f8af48701dc158e58d0446330488f0c02a9684b90ec077bc19d75ee43f747c0f2e029e27014735177408a993da26b886b375504669c064c6d3b8ebe7bd3d4a7a513b8c157c8e63bf2aa61c4c00e5ef32efebe159cd3367445fb053d74d833219ae6a4040b7951f2835b63cf8dffec706551b3e7e33503d777139bb36fea562ebed4b3ed8b6a847139227f92be90ccf8384c41da80572946f53f64be7a0824c818e5041b41b7527058ddb63d998ad63be965eca719909209f6e6dab4b537e9e1eecb90314fd2ddb853dc2e606e9ff2d633764d0aa80764a469a56c7911862a6a488ca3b0f75d94b7ecb2c947340bd54c25a6484362cf23a12860cafe88c4f4dba57e3c7c55453a7bc26507650cd0e6b25bfb1fa66218c2733fb1acb25813f5c10a984efe11576ae7e531415cf9584f2fcd2e5ed855fa2d7f68242e5bcbda23b3ea3081b7622b598d403c18c4757197d03a0a583e3c591c1c7b7f9935edc8ab14675d4cc65c6e2b8e05fe4fa5a03ec057224d1ff8effed3d8dd8ad57de246043a4354f0ca19865e0e2d307e331d27e91a647364e579c351f788ffe501bd3f681d871fdb6d0601fc38ef3d23c3d2d589b96c80ca992f0302046f2aaeaa9f29f2491ca6a1e9cb3cbad770743afbc5a56fc03603b9f003969846ea71304a4f55eacd1aefceb2af608bf338589fd397588bbde2288a18c71849a43b92dad8a0c3129701b5d5ca328c8599ca5bd88b54358e6084cb406f4fb4b29d6c4a5a7594be89c82e25fbf168fff9ab0a7af53d5552b46dc9a4d936cdb9fcb4346b419c4291d65d847eb312a78119482bc7b6372f5212493daa27e2967bc76a1706e5c41d7a49143c89467099e7c457f1e43e59055b645b912881f5d0674e3bd57e4e48ef3e524104cdb74b223b6e654d4fcbeda8edd842b04cbc326936ec04a800aeac78bcf72fd0f9a8894b5490ba8a7764d72730dbed2cc0143d9ffc0d8016a9098360b2a20faee259aea2812348c441ae7f98332983896e8f957c01fd703630131485270909660f9e0565f295af8c8219572e9020a2213cb66d7324d25caeaa74174b65201b11aa37b19d30e84dfcd8d66a4cbef9922d98f6dcb4392141748719f045f1367d3daaf47875ed9c2ebc573129f9fa18ed6ef4e3598ad5bbdadc6786baaf31ceae707925141e44f99eed9cf14a2c27a0f0734a46091d8247240b5e1876e8b31fb3196c675e1989ec30ac460e16f6b01ac9214069c120c26a5785271fc8fc851dd5fee1cc4579beb7082c2178588ecde7a0fb2784681b5adbf89a6b9f10c822ca9b23c5ccde5d91d3b13d6e02cb1422710d85bb42200874a6810207b6d150f87f212b5beab0019bf796368c1084cbc6496c6e8fa726a9513a806c9aed090925c51718e8e55b289e92b2f18b1601c0a0358b0c0718c3374b9be013fc4d756ff7d5c37331ad8aeb11a201a632db04b57311c286d9ae34e3ba7a61059599a5885ec69cffaaf71a35bcf7a7dbb137b6c02468b87a2b987fc3a6c874a5227e2655fa156d2aabc4add05276b3d16decc74bd552caa01e6cb4add30972e5671e3da267eddf9ddc0832cabcc7f9526588c93f47d391cb50a51aefdee5502cf4874079bb0dfa64acb146bad727be7709db41c87e735af11be252932442de5df9a6c6fc5379423c951f6f43f38486ef128dee08d25fcf75f9f510f72ac87f0a86d265cc3545500ff0ab32946a6d162d907634b5132fdee65452afa545bd14558b2f948b6dbb8cd6eef13a6b1e2e0071b475aa5881f442107b8053e452dedbb8292dbf454f768422552cbe00d6f35155e5abda6beb6ca810088e11337f259c290bd91f921e02ce3f55b8119e7d87ff14d99bca360538103e91e71cc04d82c47b75ffe6d230ce3901652d3ad45ea86ade49bdaa123742c333beb5e1ae01e092ff47d81f9108b1f4f1f820a8660e8b6e4c8539495123ea112ec0293b98a547d156dd2527fdfa043b5a75da6fce81066bdefe887f58650a579b6388c5040d7e9424f0fa3b5c6d4e4d6083a34722ba482970d893722c35ce204e79b397fa8a980d8b3bdda36127dd405478d0a1582ddbbcbdc67af5a4bfc236d9d0131592ab9020bceb432b43be4199e412a6c8f0adfaa3fa141c2c9a1a725013016f3b761294f06d1ba6e833b08e4d96daff9498707ff06c9306e2527247515a0693f2f3323adc278c836b438249f14df71983c6cf44ae2b6ba1a3340aefdfdb63e794945e29606d0489db50944356497f202ff85b0f6e22cefb876f06eedea7e2580e853017b99ad94a3e49097e107b63ee38eda6f2d3cd0c0e7c1175337cb0ebb38795095096048419c1890f3a17b94c826c9a5eeeda9d389a3ca57dcfcb72e22b195bc5593832b001eb311ce8f459daf79cef0915e8fec2e69d60abd9f440c4386c03fe36d7071f238a3637f6152d407026d0a8c25310b39bbf903c65b8c735553b804b55c4bdd2cc5a6d8f7869dd7cabc9031c1f32a12c8391b6d52fd06044df47a2377adc40b48e42f3ed977f592ae89ebe4623b1cc449017f270a8dc0cda43afdbf39220ab689d4f4f8ebe530d07aa620d7ec812e8c1f8b209d512c073d7dce9a47273e5a616eebb47f355d0045b4fb9718c22ece3c731f94a09d86dc44149b599a15f15f9445c14e9128b49c949ab60b5a8e24929b8bdab44afce97d91e1640ec5127928c16f6c68e307e215bdf2b6d881a5c3571febb6a66d48a8faa9533cde53ecaf63199fb68b47101d3b9037144db431db0002d7445d57f9e3cbf99e0841e8b9d306e7b380d75eb3bac83012e27402ca2b03f99b3e431d1762bb59c9e88e23ab04884a7a2f492c64dfacf155f0657066906af540bfefe4b0afd1c1ff492c308250eaf14215ea3840eb1b6be33137297e786735513105064f4dec06fac41ba28611472d1b556e021b5253d7243d37964f7562bee1a2fd5d7bfcb1f89f67012c2e5866fbd97055bc762cd0cb8081f66d6b57c5774680c256bd6ac5cd5dee0e885f7699e8d6337176598e8eea8c8a9e0801eda6ccfb31a0ba8b513c23b02f40e7140a5bf7d1712ec51d75515e16bfe0dcbf35a115a2e9135c64ecf5b1ce5fbcbd0df431072b8b3b5f89c548c3553f9630ed6cd7cbfb7aba4849849671315a2ac9bd15b5480dbf2668cff63d9af5170c7440518e8b774e407368b5eddb2efd95d3e4da069e434c6d6826e4e962d2e18686834cd9704a52cd2c6cc7e396d5fb1834f48a2eb53e30e1913c95d4954442401ffdb22cd0a2e1568ba595f400390b2455374c2859355f3ab6fb38b94f5cce815b750e38d86b7a1b1256c96973a48c112d4a5d34e9ca7f8eeffca7e365d036a29a32b649fa9fd88e7e253b6863af98daba8246d0c7837f916dc4237f0aa6394a6e5054ca2ddd42ab64eaa1bf1f210116eaa611f4a7952c124a72357a3d1da29fee403dc2b95f62d6b342267faaa2a68b6e5c0bf698ba6d4efb52c7937e9c71f6d4702aa060d35937d611d1de8f994f3973c095b0b30328e676f81e3898a88a299c2bea17f68de5641c5a288a574ddece10f8a23eb05f12c6437ecf4c48926fb1e90f81c187b755e07e668837903c162af19c60d251b8528f380f1a3659dca4a821e5a06da06fa88290be2ca0acebc743289547b4dfef3e690621196230dce0be19eb229002ef083ea6a0e038a4b56c764055aa199fc8a069463f9113e15a3160e25682a6863db9c1a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
