<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7688c76688dced8ef9ffbb20b4c25202f077d80214f6e979b29aac208d1b0612930b87ed7b6489819701cef7ec298e2ce85d051f5df4a0a8b6c7d2027d358853948668ae0bf2992ac754a6b638dd5ea2c4bb1714a06bdbd5aae0fd16cddd427ea7ace36f3a786505148726bde6696812cbc395f8b6cb0aa147794ed7625aecfc0d819d4b3310fbdf64ac57a5ffe29eeeae4020cace7e68e967404a655f70754f8d88219e2d7cde6313911ae911dda7f96e6547523100b5cf0f99703c030da3fc13e993a1ae23f6118dd268578b3088b33f0b2cfadd8dfa16fe2829407d1ec20032fc32f8328fa9af65794276f5a7ead7623189c653be71e09d00250ca7177109f2d3e9598c56e9d1e083d3f0836fb7a38dca0252ddac38521e6b885909b12b5036bd1e054a5cd443721241488ea5b4cc58c110fb8503adac8150ead5ed4f87e053c79f290192103b793dab191380482c7c1b2a5344e39ca34e52e2f4529d07972aed9799ff48473b29dec080f26c22a32662e53333b8bfd86f9eeeef4d0d4cbc16da86b686ae85f22dcd5ab2d1c20bf6a4a38a9d80263a8facd82ea4f13dcee3a972549352ae19daa15b6817c1dedf1effc69192008bb3545f37050bf12a979b8850c2781f19c7fb7840d287486564ca9ac3da288bb45b21e5003117dca5d29b12fdba065a92ceb2788bc6eb3bc585a266d512308dcf48ea631ed4fee22248d84622baa4ede55c548304becd9c816562678ece2d1e92fb17aa8ed943b066f7158a8697e17f1bf3b91045e57e5ac66af3654138e3102a02bc2b2056bf00e261d7b9484541db0fe403da55edc224154b67a48854ab00ab47dfd10b7eb8c3dc9a25f6a6dd14396c3bbd38c295b87ef67f7a03994878a47dcdc4cf23c491128b866286f647234674bb0f9eb909b6ff862ed7ff1590f80f167c37ffbf0ad184606c1792a6c614390072b97618fcb94a6566ec7363d2541cc7f08e698f8440a5707e576ff48b3ae5e011460e7cf306a9f4625944935d63891ee53b8eecdb6dc3dcdd1e152e2112e20ff2cdabae2fe4298a8992321df1c30c969af19bd4ccc08dd6d149d2e5d3d401599f6e68b8b2d33f58d543f7f203ab0f96363d3f548c3b39bf6e6ffb6d73cc72a961f4057a178853116ac0fe6bfb69daad3e7d7ff54113dc26f9cdb18e72edec2a0c702af9acc7812bbb2cd9846776b7e0c9a7b93cc2977e1414f6af29393de1f573065518bcd9f8ba400a3c703fbc8e51b767651ae05713cda3c87cc6ff3aa8cc929653df50324255fbaa034ee69ee2040dd2597cd95905bd10dcfc65441e6cf2a8a7932c2b485f76a4817250f04364874a868416f29856d986e985b2eaf1cf60ddd3881a26cd4da08149edb13dbc8c33042c82bfbce40a583b205dc6787e417de2905a67cecace15857afdfc5940cc0a588b5105c8a3097d5c84de01d8e7decf761e3d374431dd980707046cc7c7009d59f427feab46c091f2c3e92e930476cf1e82ddfb3d4a33bedaa0c4911f7e51311b57a7abcdb7c9b92d7d06144624556167cb91bebf2d4718633a93aa7ca0461eb079605ca508cf42e2324043755a330f0f2fcf92709cc570f19d3df6fa36666861eb4954e2949c8ea74b8b1cf5394fa71daf09789db168c1e1711010d141c56daa11b0210791162149d7e05806c2e2b0c48b7c122e36e55367d13adf1de88bf504c68436b49ebdafd2fbc0aa068568e77a2e644d5be36079e2bbaf530b4ad1e08122dc411813bdacc69da67764ef1c47210f7232c6fac1b794b3c590cdf5bf1167cac90715fcce162edb7a68651f6bdc98c953fa03ec0b65c64b0bb91112d21e57e12fc5618b7365f3bf479f75ad2ad5ef24341b6a84a2e2137229f5cc5f321de9f0f68707e047a35f39e215506714b33a07368bbe286a146e6e9123986840ff6b676016fcd491de17a462f75529ad954032027df1a1ebccaa0c39479d6a22a97b5ba7806e10fd005d6dedc16ddfbd629cf25d0224befbdbf4bc257f03371d21e58874ae90ad3bdb62298c950da56a1f266212941d23765fda35c75c6939c6f610750e7ddcbc905fcab453856bef94a829bc435e8fd7a7fabe7e035f31ef98c6ac9f42c57b0bbb43fd6392396db61e87ae4507c2fe3fe2d4fca380afec6df6e2cf265fb0900b72dbf8da49a1eb24e72a164863c5413738e7f84075538a1f2b7786789a1027790339393af856f0517d3117f18e6e6109bb9b04579a70f17d60daa636720890c21cd035428e3fe5a9fee844114cd92fa8917bb3216d0b38e13af8d76a3189ae8b736bf72b676a9c2b5f8cb679249f5f4e62b19a8a46aa20f83eb1340c4d91f161c98af7ea25c787ffb8e4d52fe1dc7e8295bb4b3e09b6976ae484eb156196324085931b90f5b165bf1ec80bc67de2205816bce8a6ac561a544d28a83196bf0c6ba81eb069dbb1bfebefb3a36fa8913401e3555acadebc88a3bb34a7db3e945e548a70b7660dcf1a62437f8d7d1b121d1752d609ba87284476f0f1b3fb952a4fd5bfa4b97ad3bfe188e3b5c6f57294a6434ed917469b94afae481974cac939d553fe5a5f0cf97d5813cf2e1e8c2c0f16d00ae8d4deae21ad330e466f5df1e511c679c7a3e75acfc979afcb9a087adb9be58b91329883f632dbdae4972a4974deefd6b43d5947fd89f425aebf208e010a08a66ddf2c0becb3c6ec87ffaa392b569270f18dd44b909483bce4287540ab36864272b70a04a71c8631d05af5458e66e51f746a05ef693450e9d16a752754a25bd124ba19a5fc4a76e505dc5b35492f73a787a100eda875407772c9690db97899077b20d63aba36db1d7e2231c794d85378cebb54d5cca9eed8c0888e4d0459082064a7e2a8947d69f4793093422c2fa70a4b2b4139b5087039834ccae4a4aa1a53af0193f70b7499e6c5fe3e7a72eb4fd48e319072d85854b89676383532924e5285737a6e4e494b2c090e1c5d2b2fe5d6c7c1e2fb5f1b23a3d67c4654ad9eb44f9e8644b16019fe08990b3109c0c229d933668a9543f9df5411822a659d3728181257c3ddd0c69a4cf479fe1c86fd3afa9e018a587a9e87e060045b106527fe53f53ffdf0b6682545902f573672c6cd2ec872913a996e1bb5c2e704997a227f5b47a870545815480207491abcfd9588246f46887396103391846296bdfe46d62c0a9df9f40a08911c39a110dc2d3c858c80daf127be355cbac7680bece9ff1845125eb4fb69324c9025b1ad43be87763b3c655dc1a25a0810b2f529b1271365054afe274e7f53ad93a529d185e225b99ba3940dcf62389f3e33e776af2665e318b88dd9a6a0fd3f8ce4c7d07414d8ebd638952511a6bd039dc1875229228c96f85deee7075cd8d90641ec056aea76b12496ba97b1a8e2c0664698542fae9e5eaa09ca21e8de54f6a5f10f6aefb2fb92c9bea8c4a9d5a1e8723f92bc581c1efe9f1a62a1ea832ee61e959e446ec78b8b7248c8b13e885bd6bf5d16efed88ff36f3e6faedc55257e7a66c7a6d73f1e19df34654f56706a704d394e2c113800716468ef7f31ebbbd78935f5dac249f609d40cb0747189aab809892b4b562d2d69765c5eacdd17818d80cacf5f210a61ead1e9de20137df1722c85b694173797e55830088a2889dc6cdce6819011b251947e0e21efe094411e8e3559942cfec9424857aaa6a9f2d0f80c894b55cf5e7cb511968c80c22c54215d5b2942f058b57d77724fd980702cf56f3ae8958b426838055348e88c0e0a6d6c49deaf1a7cb043f6f87d74b2ae06f2f3c6cfafba4786ef31ad487117b2ffc212fdc041e5239fc03d58fd3079ab70c2aa9b9ca425c89a8fe5d5959403c90c4fb22979f31751efaa7def2c1584ce25abe0433790783499ad69d367233d86d5271b4ec82eaac3b95b34ee9e6a0de4ce33a74687fb32dda1663235df481d6a04fdc42496ca802ef6ee51c7879832af6232612e2ef24eb0cbbd6806627d5a2b5f41f106b54d463735f4fe8eeb844b41a2651b66844cb811c975bfee663068e60a174dc0685b38d9f69dc2c8f02eef22ae3cc376e99b32fac494c95349443b62fd44402f91ebfc4fcbec9e812bdf9eb8d56dfd1b3c68eaa6be3ef26517aefb14a75e084660b438659b2d1d03051cdbf9ba080ff7e55399b9faea223541458a1b161e7b90acc023e78ce42538c0529967e45f58f394e87293ab11ab81c9ea74fb08a2a4f183a887268491d4f563d38200eab9919b213f715cffd0e6a605b872d403782541473d18495ac48d3d2bff66b0641bf16e30633fcb59bcd15f4961450695deea1429b79b43a3334df62e5b9bcb215c656c4b11d15136f539950a307a6f4458b8b1d2f03a40b830f5f17d067f2f294d0f3ffb859e28b021b8f90c601ea6553d910f00929fdca0665fee8eead5322c4d8032894f039595bbba25614e1fc783491304aea7c9a243e8d7a0e61058bfabd7bf8e4ef4f5c1a9a5625541592c38e9366e09847964e1b36d551d13ca9aeebd8b893ee400a4316f90d1f0a7e14b8e9b316698460a6f3f522c05410106daca361ffc44e7b9d01700c29406dd3be737cfca8e85fe6b3253d82034ea1e2187f031dcbcda69ed28a512a151406364465bd681c0ad4fc21840d79e956f07d73bff7fe3cc53942624f41bd3e17834217a4bca92e3a2eaf159f2bd6b62c10641245b7bbb3fae9ef09fba484f0ef3262e83e8027ba996bfab34e9ba9b2e5a3a5d426fb120145b1901ebe5909ae9b2c8df5f7f401c755fc14ae2d362b968e7a7b4903fdc873fc9aea730aba619d97c9657d669800b18f0d17c8781b49089f98ea28ccfe5ba364ef222344710a51f7a5e7df7b06792ee02f5aaed1b7839037f887a6c35846f9e27075821eec85329513aa44ed15af8e2c6b5b8990cd5681470593cfec240c424acf4c248cc01a06fdddb86354cb1acc3a8d1b24dad5df0ab8f659ef981547efb2e63b742095a99fb9fb2e6ca9a2c5c5df84d2a6b75de88fd09e6a9cfdbbf704c25723ac4087ed60b74c92dbdbbcdb26c0e7512f139c7f169fea13ed671eb21e70c865a80ff5f456a432834703d8bf710f22807bf2a650c98c9ac0ff82ad11d33ec2624ee464367d5bca1575b97da84d3cfa22384abdd64eb27fb0fb25504d3592f919fd5c6c9d4af8eecedbf54ebcd17da443d71b05aa9a1150426d574c6883ad350ccc2fd24dadd8ec3b4dae5575fa629408349f38d6071313b2d56817078c5bb0be2c915225237885006c76f52691ba651ef0fde2c737889ff455b99ec3d0fee7b18bc1cc4a98ccddeebb23de26468c7940073cdbea1139bb6f0bd020ac32b90b1635ac6ecc012d57cf64f6a65228aa322b0bf68309858d25d02f5f8e802190614e7af403fbe4329a5e72cb2088c1b904c4dbea139011342fb1664bfabd53691a905225ba2eb246464b3dd857eb0842139cc150a0f2904e589dd986d1998124b381ad6be2604aa85ca2a116407934228c4cf23d691301d245973964cf7ba95067c00b89be673a28161d9a009872b3638154265721489c6ef4bf4324244633dcb63249968d9f7de9d950d40e2f201ced72d768e343c1a80a8609eb8f54bd55126b2b70d2cfe4f2e416ef9b26cbc5e2e46b86506aa67320a6ee18083816efdcdc56010a7458ed718d4c6b53c73432a26083994800c9243eb286613fed61a57bd917bc077e56facf1c84cb3fda875bc7e252b27b502f071abb2377a0e242a70f9d0f6eeff7c0f48a9e4354e9ceb94955780e250930d23c2f134e547055f94ae0445be6b8a5201d4696573577010b4737b1b7af02bceeb5a894e2dcc22570a39c823affe7b34078e7103d44602807b76c9b41dad0f6328ac8cef082a8d83a0abaa588253fe8f870cad1e43df6bbedac8cf000a445e99a24e0a47fe7e2c066549db079144e1d9350a0ccb17a380d55b167ed4bb13b391b73744d05f5de7b412fc27a3992cbe96207f48bde7013fe4a44937698459aa25e419628ed74f0540e7b9d980c1c87c047f9aae729462faf14f2dd097a266dfa530ae3b8c8d59e019f6105fa7b2bfec2f366a53c599ad561c38983cfa1e9ef4b14eae945172017d5f30616b9e292d329b5f34f84152215505ede545d46e7d4b3760e300afb11aabf788288d948417890f39be027997e7b5ee2c263d8ad7a276d8a6f92303822de01ae69dafafb8f45e6f36c2881c3d19eb1857fd5abdb0ce630d251ba11f70a54836c7b00ea7ef480b6f797da622490e03a7cf0a3009a4416a65d0bd7cacc32b6cd8540c1f648029be98b75c51627843f15bdc39c1d946cb96f84ef8fa55c9deacb01223a91f1f6751a0504b5903abb4645a7274b5c4d4807f8d738e801d06dda46c9712258ad249b8c5c95983b8b5db99a23b60c7e74a46672b1c36b751a427d1ffde5f2ecc6c3dbf513d2535eccd31698736d67304748401b6080faef5c1a593627ed25b823dc91c9620c4af3aa76c33f7a7e6ba329c9a94f7b8aa16d7e01841708836819a4a2b522dabfedc7fd59a1c7a83a76c4441fc18b5e305fd5b415f58a3c79db3fc8d177d0f6b8eec4c10280f12aed581fe60db104ce1248d2d9bbbe18d47779f9262c482961c9733cac368fbdba14ab43f65c242ed282a385287d9ab1cf80e9acd40194915a0d155ae345994a593529643b9007bf7300b0e80028e8106020347206088337eedaabeacf321f385785b6b49a0e717a8e09013c2c6e792cf0f46707b4ecb961bcc295741482f7133a945e1f833d6c08a04ac432d852dd41a42188f18b561d1bc885555002da2a3474d07697f51b12a0554647acac1648f1c869e0259713d866f138eb4bc2a8f4814e86019a46dc8c3295f1fc2639e9ab453b7bde7a52b4867fa8bace81148b32b89b74ce1a609bf85f093d1978493dd26b1d8630d44eb28f0edf3636d1ef15e64b2d8ff8c746cc8cf58aba94a898fa12d40c3e4c7610fe626cecc65789158ed43d9996f26c2e6622135a19b31c80ec3e9d2db752629429f5f0f0dfe5b67e23077551729d334b5021446c65e6cff921160b156b32b5461e4b5395b86f9af8c92a29e4761fe0be88a72582528b424d22eeccf3c77ebbfe926ce4455374db71b4def87afedab1e07209be9f55c36c62d74e6818bf63ae8a24a57efc849a2f3274d254e19b67826a2a1760327f265f5ceff666a7ef83ad66176930ba02ff51cd476f6db742f41178ba269b7442b2da2de7879a61ab1627de550e5103798530778d0e7baefae6e3eeda44fbc9ede7754684778f74df2d87e3109d1de72d272a42d4531fc2d536d810fa1ea61529accdc92987befadcf26c6faa5134da15ac773795a4463ec54db9a660df6d29fd0fc3de26b99243dbd47440b14335f0fe0a08b6baeab68807264b8c2e5d3be189f8815a377b5bcb359cf1ec7bc30b2ad1bf00a0ca400e0db240152a6f1425df15aeacf695d56d77149aa18139818a918839f15907c8b3300e6f1a96eb52401c3b6f7abf9ea8bc0f99fad12a8112a5fda65e5cc1d5c143c2cee38146ec5e2c6981c441a4e1fd6bb26abe4502efbb7ffd80d1dc9beabc9c306e2ab53435893bb4c8494ed0d44ed68a650d21767cdb33b39387a79ad8498d0edb368142f7568fa48863a329120f4ec655a5a3f15c63de903db9caa21d21d2495b78cf8ef050c606f3e90fb467c30ef080e74a6c0c10190613379a88c3da89100e2bf2cd33e060cd447f4a1fdc3df1ad7f34b0e8c90e8e7e8a4b5b2089b0337d974e7667ddf8d964cceeefa14e71d910e376ae796407bc460d7de78892b8948d5bffeb5d8a0c033750f2d33d9a10caee7a0c2417d815f2909db5106b5d912da039d007b5c0355e38c9ec538ad691a3f33901a095b5c940861f81034d6fee667edc7567c08585599cebe9368b3e0bfb3dc65e86fb3d52ae3dd6c2ead48fc85771b45bf308ff619dc204639a6374e5706ef780408c9419b9a40ae294a2a2daaaf48e787e4e51ce263b64f04f697336e40a866f2ce70953dcbe7ffd72d018243d3f58ebcafb716307e5dbad917c10867af709e4c2c3909947400c8cb106565f7a6b1f346d2a2787d24cdef371438824504197ef46147134ed0a30dbf7fee5b941f70e8ccba42f49a10bb3f700ae3bc99000fa7c9916a7c68ff344e6117ea07a65b7e99c43b4a9e354b72c7c8c95b151b381bcc0f97284d3e21300682e90ee2ca9af86ba4ce6ffa85bf7799201d6d41d462966b6b7277edb634a477fc65b35b52ae78c497fb4c07f72b2e18442675cf9421cc06523d01ca97d81fb25a605a2b07499b238ffbee1c767de1bccbff406f8fe4494220c7ac5d88c74a20c3c347bb06179547d63de85535ec19babf0683a5b93190a58c703fec4c43edc94180aadceba0ba434240f166bcd12357e0bf95133010e1d90c22469e207a0f059b3f7d8e7c50434b7ba922c71e4cb0cfdd552dc89d744ce0ebb715e8ef2aeedea2244559f61163c4cdae9b37278333ad134a7826f0fefa8cf267bf06ceb7f2177c1ead38b215c9315f723b7766d109913d32e9de23aab0e8cd281111b6a03076b6ae9d18d7a7c95f8f5a0862f160786b542cb815ac57884cf6be68110693df1105a8098b4c0a8c035cfb9e4f5dfacd48f8d906b1bfc9aacc3112ed8d07892c955673529348a3ac41c68053224935ccbbb839291073abe605d2f6d422fd49ff0329d1cd5e3d01819fc23fd66a61f0717b4c76c17b18388391f4a70df2f4f085ff4c8cb71d19b32bacf5cbab4612b3000a114056e070c20624409c09da73bfe59898bb22c011c0d201df6f96f85499a1b1fa33bd36754ebfbc2e7e8d51b5cbbe752626ec587fff59e2731270e0b41fbc8916e25ff3b80b873a16fd0f0f533c4eb8d53ba2cd36b2d9776eadb14707a24f79fcca36c18720283a611d714b97ea18abdb08d5d8fa3bc0ab4aa6206e8f9cca64408690dd8dc8a20d5383ddd05f1bd714ede616a5d15019481d308e0cc0de7c5c71a91b4c64d0341645fd7af2ffdc015f0c04e9964b4e49d1a58aa8942634cc51c8a44a53130b9981082788451af9a92de082a00581fed106d45e10cc1445a1e6fd49e850b2bcb4f2545cc1323768fd88236af8221a6fdf5fb69a4befcd0c99f603034559c3bee0f1a683d57d567cc07d0c33a556d610914e9fc9e7173f281bf58d8bffe187e1ddfaa3c11c1ba04f2991e5358561d044a69f42b5a2228a1af3b782754fc70bde52fa1abcab14f2e1b60262a1957752c260b8243de1fa61c655a1ef3f1f5020a7e5b2d99e0851d34ad279496ebb59a26ee5c068e8bed3f493ecb1b110b35205743263525e83849f26e7e533fe0b15344eae3438943b16e6665879b9b5beb24626afdeed0bac9824d85c544727a7d0fec3876a381c1edcfec4959ad9f29bd262d7f84469ecc4d75dfe8675d9d7fbd58016b9d727e6cd8d9b2d2cbc863a07497d88788eaa0638a85217e778d5fea09239270db454f8ea91538ee0ba963d1cab6461e46cc80eec8bee5e8e1b6a347356adaccc46caefc49dfae119811607db61db7ad7997a516fdcbdfc8d4c687dc8460b883aa797e545b572ddef4512d12d84d41d2629df4a385cb83e86767794d3e6f4456715f371841d96db9ecda8b88ab68babfa6107396ba03677c9c09a8bd38812fb8637ba608c6c4e84102800ec0009036a9d6a26795dc762c66666694f605d7dddae30c3b4bb3c3f173e0808f8f6a01a6601e8dea0f93886b6da9311cc07f3b274de19c91d9d667b4b31e1a251a2d952c87cda6121180640e3ebec7f649e93ae4c158b2cd5b2ece00146f45af45e4b342c08cd839ddfdc46d4832811772de19041e1863f3e2b829988e1607620ea3e6921c78ec9d02b85c8c26345aeb91f7ce3f7d3e6e32b53d63acd2bdf05a5475c06f1e8e2054b59050fc3c8649db26fffca19fc9933a0df12ee6daa57dc23a279b7a17ccbf58fcc2c71e15129a0456363b7f152d3fe0ab8d7966dd433cdcf07d4778a6bac855cd8d80bd18295f0e420cbfd70aafaa60ad71fb786ce168c4ba8674c6ec55d9625e71b483b9c296b5ae7ce29e50dbe9fad178647be40b26cedd7c72e7db09d8ada6a4ed72bf833e6bda1afd73fa33ea4924ec738219391779ff0498ced8bef90afce95c5299e96d3e87e949a3f7b0760c9fbddb5df9da672cfe1d4378beeb225f13f7df612f591e953234585788edef98a377c639de4645ff88d75667c79f362433497b00874d1ba38e408a40ba17672357421e949c2aca77a8fba1c8e4bbb574d473d9421f3c895f5e6b13a60f119cec3c7c90bc26d4adb080fb15bb7e53b271dc962a0f8a20e3a69117dcc05e5a6dbabe53f1106fabf638d4320afc29621719c4933af6dc580b6e198cef6630ab87b79cf1bc0992c99681bb2211436a666e45b671939a964c730076e1d16523962773d9ebe445b5dbfb2f7cdef863651c49f96c13fa3a029087b67efdf1b63681bd0d12fe8182a6a830be166cabed003fc39b9cea89ee26e4443ba17535b06cd32a8142db7aa722e1e783142daca2badea8a65b5b656bb871df718899dd4a9c193a411fadee4f6d5eeb4b920db728a0012851f150461c39f91c0656ea60508c486beeab4db869481825f82c0e8f661c38531bbd92f481c3680ead9692f20490f7ee385fb8e74f6fb56c6962b332b9d13e0463a1aae6c5cb56d3b09ae6039634c11fbae31f76374b9c532c8d1d3e791054bd1502a209b4ddd95bed555616fc3f4b8b0fde6b3884dc53f12ffc7087cf2b2dd6db7982ef6faeaea8a2a483464f42eb7c657493fc61c9b834ad142f152767ade01dda3cbface7802544c62425ce7805928397aed4f2c556425d38e3d874ec60bbf749e74fb7dd36241fa40a27864442a2363acd5fc0a8e06cae935b010b88de02897323c1a92b25790d5c4834def1add8b2ccb64020a3387de2ede3f17bc74ddd9ea98654f8a49e6850bbd680b289ab37b10689c139dd1eb7b4d53c2a9d76b542704994a55e142f698694201d28ad30eb098c08149dc96df1f27749d72b3ef555efcdfdd0914ee183c6fb8d3b57cb241fb1eac4ae4be551495c68f150b943bccbc4d04d04a435ef03dd760e5d88c51b4d044a713e31ab0bbf9a1734043c3739d9a7a5170b837b1513cce1bf11f605f9e79d08c6a57e5f26fcf3e7e86f577b2c762a1a196d3bd1a8d8bd72df643f03aab08f13aa95ef2c2a345c1af38e0d4d6099d7756e43d3d12e815ddd32bc39d5a8a2f501214872312fbcedcb05bc22079ea1b6a3db9f2a92c3f589e41a430d2e65f291871f1ec13def076c543fe8b43680ab6ed9842e2900ad458f7a6c1b327817a417141bed5f526afe1c57956955514a3341d1e2d1fee155df1957ed8d6d22b23edde479907fc5cb26e671f0893a4ef341da94fad8055fa1cf05b64e9ea59e8f6897a6bf8fef417932cbbb3e55b12afae039ecf6a22a004f5a7d44b69f3e4eb3e5194cc99ed74e97ff0ccee9cda79b6ac49000e05ac83d485c75528ae0ac78e58be229c1bf305cf80d8cba688794f0e3ae59a105d79a8b51d21f7eef38ffc007d403dd2530bed44230fc80f6a70787faa00502ca23dcd714c4d33e1ffdea8242e900d00a5517882f8256dda012448fea029ad3e9648f779b55881275d8eba53dfef353138e1a70c976134f8e10c905b767e1b58ff4c728d7fa68c851d3147ce29f035f9dd5f4239f43a7328395e2acc837d2882b0ebc7bf5f04c0bfa8632a5e074ee5f8e8b83cf3c8f74740dc89da5940c576bb21c160ccd8dccbe13fdc93cfbfecc15b8b4239e8642240941221cce6ed5f17687b0482184acaba18c2cfbbcac88259c66bb7176a9fc3357d76b204c92cee6455edc610b5f2c396b21002afae679768f78ae3e6b9ea921ec009f0cf30246384432b039f627cc00d657e9f23d154e90d724236617fcc21380966c65d12cf8f0bbc9a85f4fc5fb9ca83d8fa68af1c80775c6e0fdff536138c41a0c1a072ed2333d99ad6371157e3abd1ac7d64e1fcbebf3f4351cce9e62e811b6160b358afa950782ddffe9b2dce3ff8595ee917ffabe9cd4eef95045b28db808382bb16c8742bf4b6bfc5e458bbeb54cc5550a200e8fee84aef1ae9e2a345c5962136f142fc3ae46ecaeec6635d1a45d5758a2fc78ce8fcc9fb426985d1e7361da2df0cd38cd28aed9e657fe3fb38d637b83fbad97356373cd1a94f5ac7afe59b7efccafa459619ba59e90ef19da24cabd18bff9172456a1a57ab251183faf9028a9e11f71f9491cdc5222bfc0ba5dde277c6fd21fc627359a6da422b9388edfbee171d9fa87477fa03e1be359949285acb23009f4a886aa5e61c78c4d00d1410ea2e7ede6e1b68111fe5309fccf09ee13d4c2cc8c026717a4ef4fcc87eab397dc076f6ee5d921f049516d9a88e9b07d05c7594442d86940083a81a26c2fc86f19c214168817ecfb469b1e88948b2f0e59d5a880d9285330bd63aca76946786744fa1f3c014e0c312b35db94dac3269ab09b31442fac273dcb007059d2f893a6021abc4b77f3aa6b68d85427983cc5b8b2be45f5ac715c7779096bb135d9340edc911185cbbfae074867ebeef167f88fb3a2c0e9f950c48e7c52a748faeba6b278e6719b322533d479fb095447abf4f19d6e37d6abb1866307261ad84bd39efa0ffc141b518894927d86b05f5a0c5810665a265f0c109c5d14544f42722a6812e9b841cf980756aa35ea79937b0507c964c69b5a88da964cc21bee17f9bb39998261e0585301e7626fa2e1d7a89e9581a763929f60f58547e371849d396fcdb5d1afc4851b29f6ac4e2c8f8fd94ef2f478394c1bc07096998cf83d1a6c6f661f5c3422dbe7817b4b198c1475e9de68209b56afccc88a72cf786e1c8b58b6d22630fab0de3e0c48d448e5b0321bb007232fe113a3a9221c42b80064a3a90f55a817bf6952bf5d12bb50187135c6e9354e87756ef6ad2a238828cf3e230d6f1485d398f1278d6b1c1afd7ed38644007c74fca8a13748ce4d0aab6b6f77064208952aab77cc7a2b2b1230c89163ba1fd4015775dc1c559e6c3394731ae47a33f2c93c83b67ca84193a2309ad43b2ad2103e2fb549916d8bef51f2e3bfea87c18d6e8291660019a6f2b11d79d49729c1dcc15edcbe960c691f259bc5e7c8e6ac37e395e4fafaca440eeb142eca2b20f76bac2550ec7caa19205530a60372606c98c3babb76fe7f557b31cca280de95e5fc78ebf309ab3009bdd06b9f5f17f96cb07b35f4f3d7538d44361ddfe6edd76aa3e961fabc6a347503f5c8ee773611b0b5cdc40f63c07babafb5ad252d5d3f0bf07b04e2932f243df01f1be36390436f640a601a09367fa845bcb82da0163c530840eda9192bc43668029dc26a4fb4501b76579dddaa9447155ae33347dff6df5b2000c99dba6da6d4efd5868768d74dfdd131b54e09877239f117e51d36debc11694d939dde4c9238207635fcbf723caeb58e90054e86763b2fcf6ccac6ffe18883ac343978db016000f5d0b50fb39a6a3c8d68206438fc9a4c95d5069454520d8fe5b790e92d224e43b3f63f27730da2fbf58daf1391baf737199da0dd7b687648fd96fdd3956b80e1bf3f32368471f5aa366821cb5990d04359d60af75ee6fa4aff23b017c49dd1ffed2f692aa0b437a6a51168b92b32a0ae375b376a559117b3128340f4720732a11319b109b9cf0f9be66be068473f380ae6e871b57d9df5970738b9449a3ef7662c67fa5b921caa0098ccbf7218377372e7960c77086d871d3336131e6d10022e3769026587ab14c535f799ec5585ed1f142a8afd84a97244758c1b39d3feb6b634f0af3921acd835459420a334671a30ec57a3f44dd4595bbd7f2022e7546849af2869b77f8f133e0f09d473a4b0099bd3036e0301b7bd7ab99576d46438a46705bc5e9d9b6955d3b45478386240ab2ab7b7bdcee9e22a44048c2b4f6986ace61c3cd016ca7bc0e5f9b16fe2e7f523abd4bf4cb1d8edb4aecf8774e213be48c2cafaec4c31b6ce4355c5de5b13ed9daac0c9f97088e222a1732765e0fdfacc9b7793f6edf84a94d7c1775319319aa4e04fa39457a9165af7f86291be2fc5ce47a9b22dfa702e1bf23155795b646568528362cf9e61c838450225260b8237fad15f92779ea566476aa38cd5be720245e1e791f6a9f6e3ce1892b2f3494ff34a7faf16ba23f121f8b184dbf5bb6cb9235d9943a78aacc9a4a9a88a061235dcc0fb7f24df6809f91752f98419a3a242876a035ce5fe215dbed8314cd7cf985e07d5ed4bae20571f8762495dc5a6fa9a10b4c12586af7f07fb04398dcd46e3ca0addc5761b485cc677147ce127401b83aa4dc6ffa5c8cbaa8613abc99a4b5f4c3a168d6ac4f00ec738831134289eb55f6ec27c90825d30d36a39e9883a3d42a001517e61a7d1e61e51d0c071dd3738b0c8378b96197631b45c8d1bf9ad384ce2513adcf63c86d6916bda3a9a5caecb4c518d82dd0ee73dd32925d00850613d0efabcb0a918ea8d331df7211b06d53a9269d686579b4d05bf9ffba3512af833d3e0534228d210db50aed6a53dd25e8f25b729ad5aa640c0d5e2b145c536f8390af4e26d318729a8bcf23acf275bc58703fa28d30c4ac1285b5555c3311aeb94f06b6cc31a8b05a03b6a12814f20d29eaa2305bc3b5ef79e2a3859a188f6a4f06b6b4adcb3231092355b8043adccd29448a288babdc2d102a7037d3aa7cdea4b2f863b73ec0b718bff0c101fd13e037291a44d641d0affb1bc05686903bc8644288d6afd7b884bddbba2436987ca6689f134fee4475ac3a0fbaddde6dbe00c1572a0990d10db3cd2b36a75c3218aa061474eefbc951786b128faa55a59933aceb73641542258c86b9ffbe591cd6b984e8f544646fe73f7d69783634a26f493e2885bb1de0be0672c8a13a9d542ebe6bc85846b874a22d0ee3847d3828c8eafe988601d418ec7f7a86120b37ed3caaa7a48c27d9c5f1c4c6e82fea31671d817339182f611f4bb3604da798ba7beb2ef9e67203891bc410978a5c5c81ff95e48f424d8f883fa37bb71267f9dbca1f11c2ed20e09987da2a5b115e4e28c6e0882b86fbf38d7f5080930ff34d822a752d4434116fe873d85a4e03501b41d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
