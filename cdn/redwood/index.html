<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"826a9890b62b4ddd859818dd0842232f22779ecb39387a6f089596e346117a017fd03c315584961cfa1557a2de28df2f8ff5ca429618e88fc470407fb8497fa3b7c840b242fac73a69426caf42227340eee91ab6a4f39fbd908562006ed1299c0016055be1c48c39528f76eb2f21e29ff97b72a21288942581694087f02004c4d086897ad2abb34cfee5f8254b8cdb3f5b44cdc0dba1742536f4739e60e0f73b216bb03ced98212cb620b84e42aa65e5f8c6919179b3d1042fc3e6fe76c86525987dadd564b86c06a7213e6eb7c0a0ea80efe1d647d9c63c85ccd55831469c39455f989d9afa05857b8cb909ddbb5ac2c9374e84ee12307f404895457a41018229cc334e1616982539818b0eced559de12b9a8d7c4dfc8d7233bc2ebd4326aeeb36359f2e690be9717a58558680204a5499b42021b0a8a4b07ca85add01ed9ccf2ca005a3bab45813132c02a6664d8dc241220d834c188395088a1afc05d99dc5edfcf6f0a4a9cf131da7034376e4839217479b5ce8e8bcb1afd5510cf85fa91c215725402a21df9d5f6044ad9d6fa5432019ca9aa863242e8fe6d92fcc0269828e1d20199a78a04ff2aeaa6eefcbf4d7a655d9637a0671b868b905486a33febd53a65607e130653b051ac3eb2af56e7c22392dc74bc9c1e5e4105ef19d6aaa38abff4e6c9a43d0d278c3777e7a1d1c963677604df867b4bf6e07140570f1b1108992163ae86d641ee4b2b63259644ba716584b3df2fb99c70a9b8419b98f1b4d5bf097618c68c8e89900bb71590faa464ebcf6784832579c02ac6512f5230c5662bf7cc167f1ba8aa26555688cd0f4c12cb9e5042a7636c02d0abe4d384005e6594c065326b97275e70926ae8222174ffb51b26828b3e26a8bc48cebddc7240d4dc8917320b27b1b30bf960d5444b1ae03e7cd7dae71125e6abe3dea17ffb877e8037443ab08bcd1b058555dc9c23a59fc660b570919b54543deea953fb07da7304aa8a438a5c5917c4c1f706777ebdd7cf3868a94ebcba407c9d1139cbe7d405293b3816e7ba2af7a15767cc748edfb1911159fe354b6d5df56b04044061f7157bd32dc35fa44845016ca293490c0f06728b5b95c4bc41be1eb03885c5f9f37a55d07c6a746f653660c7cf8aa3ef48d8c740af5f727050d3ff06650636ce5bfc5d462455ae0046d563c6a0374ff50c5218ae78eb0eda2bf4288a0c914fa1633ebed4d45383cc364b0837182ef19bc34a60bbd160d52b749ae4fe9f3f801c670afdba801154cc6e30a228158121fa1ca61f6caaa18bd0816d42054f61be4498e804acd2341b535f1166230a582c2b35e2e4c7d7c94eac075e4b8b30c13d666f5b7cb014731f052db3e13f86ab1770baf33125e1876d31d5b5f2575c7aa0784f0b862ffa4f4536b1f5510a2057cb223703b37efc8fae80962e23cf4fdde730e28f4189c2c067a22c1be8f92ead183c90c3658c602fa6f0f3f59f67c06951f4ed68e69d08f8bb16cadf50fc31114138d4dba8398fac7f9188eb978837a71b9c2270c9065861f3a7ca1a276113e6b30c56c4a327466a83cb9e64ecb75afb047e2dbc66a5a58033dfe6066d2f7e69caa1e8cc09a981fc9487a8aa962b06d165730bda3b01847a4789585097ab01d29f2d5a8920da3cb125e4d7ebfed9735f0a3995231be2106d7ada56f48fd5224e01a640951c8a1baa669cc1ee7114a0e938c43cf1ff730af85e78d88e453db9a64371093665d2c6c1f33140b3057b4c4c10a7b8a4a03031d33a4755dcfdf1c51819ec9e3188f7b3a3be8e930ce14d9c48429b2cf7869d954e13ff4b6fdd13b5828717588f116f5de7cdba0d20eaa5c8fe1972e9a84d11db716909ad29b5b62872fe2f29a8cf491140dc3b74ee1976d9e11f27ada29cd646b35260a54ff25c6ffee67c4b6fea7feceebb35a3d93fbe91229d0134bd939a8e603d8a510f60bfbf5a5851494ba5eaf9edfac276082c2783dcbb2e4f982299b1b94e04f56995d9f83155ef606facd7a97d9eb4c31c6ae777e466fb2cac8ceecc6c4a5a8118df7c90cf69f2bb196baad9ecbb168cd3abfdc9fb626f4a98572e63eafcf86aab463fb2428764d36b12f09854b7fe9af71603a95ab9e85d924e6b51576aa70f228a07f332b0953d86407a3073228377f674357d2c337ea77cd220c815418e59e174060238dc00de68b239ab498b6affee199cfc57e08932bb3d4ad05cb78d6819dc724ded2a2b3a6cc55d298194dd81d0d835974bff31abb4418def7781e8481e5b6a59e7715b3365d5af72f24c1c9846258caec6d2c3e437f6d36496b8bae446e76dae8e9218ad9e823dc55f182ae3b36fc806aea392c3b9a76d95af70feaf37cdba741515c01d3bd78fe9aee0131d80fdd379130028d8e715774c352b04fd4aaca3535bed96ebd106e61bce4e0a2df99719715b0ea64a8b9315f677439353cf7d0b4a94e93157ae9709237190f1a495195f28759d61ddf790a0995d1851db9d19a51efe300ec724b5e073bcbd7a4dcfc78fbeb7a40f72dac1418c64abf75dee82c78a5a921b51841c8decbee227244b318e0a31975b7e89197954dc3661a2c229c7f728c1b1ebde95a46b1300aeeb3105429fdf6b081f5fb06e4101cfb50dfb309a6d7dd18803245286dd1fb4199db1aec1c96f98102de759b10e8f8d22c17677dc51237cfacadd66158b5ec88009627754c63c4a15ac27f1b51452f2c96a63febdbc57e0f815644620329a614e505601d23b088df1b65a046bbd30be1ef6a5088dff023b36c813270f5177e135d0a9edbec37d3e6c964c12fec5b70809fcfc9187f9cba52924abc7dda0edcd9b41b068d96a4a50ac0974106740b18516372a55ccf7a78971d3e708a7f3b5dc17098cf9c8a3a4a765f98872acf42880f33c9fd5df2ccf08cfd1d45521214b9b88162bbb39b7aeaced0beab145cebd5d5d36f1800c4e0e94a61e6f4e1af56bcb0a850605381caa5ce9d8b1ba5c59ec7de014a524eef175e8bdeeb7e5c6acc26b389509fb9b8fba4ef798e44a5960f14885e8f89c7924195c9f374a5da9da5f4e7b75a5ca8ebd258b3da97234f21cc08a831317fe609258d00de699f00f30bb6c3d0efcaef8f945fc04307c4fd9d3dc275e5a16bd3d3cbf2c7e16f48ea59786c0c0d51cf94c916667183736fdc837553a0708a27ecd9096c18e01fbdda588f78d598f411bb547345b6a4ea22bac3ce684dd25bf5466f4897270bd5d647f9b1ed16f6465108dc009353b43ef2e2aabed2e07f7af6251652d826f91553568333209ea048c014f94c757d747c3ab44f7fcc38c9780033adfd0c855c0454d8062509cc96e0d3b526ef6b3c21be0b090081c9950e0216b9dd29f109538461dd2c6636cbf2fb74fd79de5e8ef3d6678b7d5edd0a1d3b2a95cbb0502b2fe92ec5f2265a9698371eef3796a25ca328d1993cf2a090a01468d39817554594f7623ceab95c92b85345badc6d56a8aacace9ce99c37ef102082fe634c8d6480614c2a01f4e88cd24c69624e29505b0b9e342e9432425486d31c9064f492af8578d90e82e9e64234c9572eff17ec05920a23d8376d733fd449a699444956d750724c44e53a2890c3cd7e4f81b328f1c6c696dfb8220f46174c705d2d0fc66dfe02305a716390e083ef4b84f7eb81048abf42bd10f109a1c70bfbc4928b453292c29086043b516b344e1d9db3b4f1a8eb9b0dc1fb7df4d1936ead0c38acf5b5e4b17892a6a706d030b747614d74f656b6803f1d1b760c8548f69efa311cde72167aa83f355418fcb1a1f6d96757cdfaebed46d906735daa8284f15e2e01382d354a99cf948283b7a522a547436e4fd8591a946ecf9064149e61f3db5985a0f6aff5836f18fda7a5727586ea4cb9378db1d219eab2aebb9f393a88fdd0542da49bc60b19da07dcbcbce5126786e670ca47cf126d00bd1bff6c9777df851ef6545a6890029741460eb2d9216ccb0c14b11dec24f61262691dbd69211f5254a0548a6d8d55fdb9b5bdc7c989885b53581efd0c17e08f5869115abf165bf8e7a5c9b9cb3fa76201e403f016fe9cbedaee4d6d1cdecd62fac828673ac810633961c25408ab9db95fa8044a552ef0f11104101b48790b2bf4eea920898282df93d79c0389074e98eba4d0651ce89b435ca21a9a94f474cd2ac36f79cd48c012d2a93caa03c5bd87945a95081c92b11e2721f8f8b8cb74abdb787d288909ad2d92dab7c9b7f9a008828b84c285541cf1b63ec71dc5a145e2c9b221acec9c0cd4e0a4c1b300ce44a4a2dec041a9b56cfaaeb68327b41d4708243dd377c264f36a19e5b0b0e16fa43c9b9dfeb8eee2a2477f7c79f5eaf3d86d7e03813358440022d68e64d71036314c1189b1961811c3d47c725ad3187e929ef67107171ef3ad371e63f3d627c44796dc78d4483c7aa4ba3c193689643db0168614ac69a916db5c1a8e38a65831b7bb003d8747561352b5cf70366864700592ffbec5836f1d4a506d1d71449c4fdc562c556c29dd6166ea65f8a26570dd2cc7fc156d27d1df3184857e8ad4673ca5e3af721f499f6bbe32993e8b58e286269475802f89201ba726081648b3f0b2c47e8f24e508097ef04f12874c78326af799187cf6d83c22ac2cf4753ba4c86ee8ca46d8f6e5d276388cc096e726f09500a67ca2af36ad12c83542303466127ebf70862b4c3776502ff5dcc0cc64a83b1cb477db192cc472bfa19b8df4fc4ea8245ecaaa4f82a10dac5218ad0dcb6d4f63453e56c67d13bab2ce0dc388d96cf228b78570e2dea86e1223987dfadf4df4f9b3b17894282553678b262305826a119df1625ed859251b15344782315281407a995e1fcfd47af2416ef3cddaf4f4f677fb7497c95d4cae6caad78f911097cf7af5f22b4fdf3442578ff85415319e92539e497c029840483a13eb025481882e6fb104cd453423be516b946311cc7aed493b6ca9429a4468a358d67e02d11079fc5662842b51247d503e1c7e850d7f7bcba88d78c91a501b6974ad46f0832f211551c3774999c2762cc9ef282e90df5d1f9e41a37ba9e799dbbc1a8a55d047bd69ae2ebbe1c577b2e945c6fbd9c36a1d01875c8dc0214823b5d9ae46f9720f5bfff8ffaeaebac8169b59e0943031d84a3aee8c1a313d6d2cef5c7259d2f7cd92aece51ea0eb6cd28213ec54e8b6246e6caf621ffce6877eff6721743d9beecdfdcdd6cd4c2eab94cd18ab61f259e8e67b6a91de80aad4edaa2f8aa8e438740b20b7b2983148d9906f684a469c583b5f43d674ca3522f6c21c9ea085573e0c035a99c503ef243425624e2cd556c5dd9c0cb2e67fdecd87144721105a2e0177d04f11d435f3f12f12f601233985b230e43914478f771ce5024d72d8575c21f2b0b862649a4f41fa17531f2237a72f40f5ee8bfd5ac583443b300cf5e029c93c9d9a7c4daae8856f1f2a0f80c79569897b72427b58fab27bdd7f0e089745efd81b99b2516a3f6cb3f3101bddf72685eb0ae8f58a3856f13e6ffb6a92389f13d88b49751c4decfdede8c650677910b572c4531282a939c401c7d882535e565c8bfe2958089266556ea777abeaf4de8b5722fca9394db738014283b4ee2ab7be5f72c3aca6e76cc461bd281b86c4dfa9d1a43c3994df0ec54c2291d8d5c4c0a53fc517e28e88df5b9b358f5c2eb60cec90f875ea55ae9e9049fa14b214a7b3680f056d2a2dc04e91537eefe3aaa037fb0d1533117fb61ae2fe4dc6338139555cc8187edf68d6bce90cca4562c6fccf52eb6bb321e9735a1e029d8c5bb4efa139b2508a4c4178ee78be68be4f1160a06796488a34db194ff4fada312f859b0284bf5ad0e1e8005187dac5de1d8bd947b84c262bccfb61ffa44cf0581dc1d3776a715b15f2f7f1269a18d18cddbd033e079fb4fee002b1093aa6adce98d8de04191aedbb250565e006391b0df9b1a98fdd91dcd154de9543db6184655e1ad0acde7cfc3c1580b66078892235d700d87cead831bee6da745440b2807e63460268bd552bb54c05caf4634d9832affb3e58237f277726f24a25f1bf59b6a2921918b09afba6be495d99fb0286d931b1e4477e24ad92f03d875fa177db640c6dd57f35a783bbaa71b43c602e319cecbf629b8460dcedce6f26851976578a737992d46dee455a5287dd19afe3c532a2f0085ecb5c407f5179cc2fd983d40f9a9211405192cc73682e9e350c6369980f68edeabdab5971d0a52400e8f49c73f6438450a41032e70bff6e9cb3d1ca3ae3ccd54600380223e2ca94111ac1e2e13c979a3fb89af77cda68e1994b0e23f8d7ea9947c260db46209570848f9ece850edb1cdc8b8189bc7694777109ac918ce00ad719b6aac08f2dfdb94d8abc7f37102ff2802b8765e766a2c46e27f460e059e4e2b3a11501feb74302a922c6ced145aec08d79f987cfbb48458befce11718efa1c6ba9cacc201d0078607570e1258b123c671ea217e8ea8897c49b716ffabf6b64b2151d061f3dc07f1ac47356c56a5f86873c6aed36085495c1a363cf3167ba9ed98f03dee77efa88eb9ddc1062fd3cf44bf5cc744189d2742301724450224582fe5f3edc46f7e3735cdc272e57298a55949b1b9e9cbbd8811121f5d7b8d0d17b365ba3098e087bd89ad33a0acde899e618733d3ef42412beebf7c7cd52f16054e8f32145768fb437c28e905261a47387c9130b9de571e5fa94b55b35b031a0ffbe8679f9f2ea525a799e1a0bf5a9bddfd323cc93846733fcf94a95994e6b407f98fe08cf8c6f0dd5ef1f3e58bb5b67050d17b9d23d01b9d23d42df9b4f565d67f49f1997a51b6cfafb828df7ad9a7781b133d26b7840f9024aecf79d484459f1ff0ff4aaaa3107505b8e1e7ae94f65683b5b05da6bff000128757d55ee0c111bd1af9b642c7be7553f98c777f44e54ae0fccab8fadae5d448843e85bccbb096d578bceabc7376ceee64f68aa736eb1d37dbcedf729c3efc411f4c75fbff98756b4baf5049c2d3cc81ce2b0f53d3fdbec323c3ad8a0d840e691cb86773a0c14c5d084a70b4537e2a34e8f6bd53632cc5c08fd26d2ae1385bc4f889d48791a948b51fae138aa4af115f2893e3c4f52fd15b5a6d7d64e92567df2d8b64a14e3d3888be13cba44b29ed9d268ab562873b8304e4c998c053911e188d9db415488e06b32514eab898223f5681490ee0db34fdf51c61154734522390ca8ce49f29e53956db991338042052a7a1c9a1c9554240643d6675f441f8302cd9b7a812af9d1b9422283781d6dd4a73c21afa6fe6503493e8e6ad0df5cade08a010419ac2fa8e5e313ce4b8d6331edf96fa114c9be7a3003ca34f9b008d27db63b669811155204cfce0b455ac343ed3bfa55e4cad20965370093336258934b6b456b8cc2168eb2e2c8c46dc8601a7e84a2b1168f04e27191b4962ae99727a64d8a4020dc3881e500ce735a41cfcac29386d5b30ea83e33c08e46a01f46a7268d423da751817ac05e23ae6ab2a3c5e954a33dc50c8921b1ba295861dc950df23968b5989ef2b5483ff0d72e8a0cc8662e190a4663db148d6fb37b140873a83e5651e9f09dacb34da03b9355c8373cd32ac66d4e093dcff2d5251a1aea05122c59afb915bc8c32212ed696c5d1a347d9547b6c0e84886b3f86fc65011b9f796cbba962c53a5366d0a577a89ed5ce53fc261cb820dbd6ee54225eae7e9d7f958b535c18b9e920ef04c1a7add47703c2ae3d3ce9822ffbab938f18eae5ca6bcfc8f6b066105a59826e2238b4552ab171bc4becc812aede01364a779a2d5deb24a4517ee40347643dbd3e24e0f60bf5bbf748e774af64cde30274a70291af429eba1ed4d3defb5e84d3d967bf63f86218c8edcbbdf167841f4945d03d02430be3563f2ca678908f255a3242e4ac8a7616c7dc63e9abe349d2b75f6bb5efde5a508eb559e7ff507f29c9af015dda604951d4c95baa00f15633365a09fdd8d13f13008643833dee254682ef54650a45a6e30ee5d8b65eb13c84ef9ea0b33ab18056530737ac9f6e0864f9dc0947ed632152912d76b20ec5843bf3d429d30292745c8237f2da955dd554c02d39c41aec44f143ba8a8d86b4b9a18d9399e7ab132f7417ee86803dc79434d1b59009d57197b422d9937a14fea6e283bb9345d5a32ddf0f4e4a4db8aeb532f765f0b52c1f5d8f6c360da55440d64ab2a08c00ef123d920f1f78fdd75532e6548d6130b51b22ce36f6735bbf9e18df78928788b4948bd99a39a67161b506469014ae8692e0b75a8e3f6ecd9c179b58abb695638661db6c9cabdfbecb47a7af06a0bdd392f78ccf93c02b46891874df1e2e39f1a3803f9a70c038b3eac635f0c97a08fbb09aeb2d3d891f55955d8f2d89849f46452899cd52cc0585ffbdb8135a15c24757c97ab721304b161dc881abb5411f3149c8f5bca28086104e08673fdfb6e56f99f1e74b926dc7c3608dd5aae09371e7ca883f7b2f9a937eecbccd9085df185844310df24769491e91974eaec55006bd7ba1f67c5c3ae16c94b0bc32c367a8c251107fcf3a60d98b841d5c51db8621265cf1a89263d110a6c465d72357f96ef1e2e1fcd36471b3ce104c10687eb9b06d1830a13b03cdffbddcdaa533b0f8e5da642e8a38ff7284f649c07c9a1c78dac82c5457c2efc28a74c335087a984085f90ad76cc40188b455b906f6acd84b14d06a1f864bf59cb807c8e4d0ff14cbfd7ce4ed64d4b2277020a0258999e460084c46b04c21b5dcf15414adb6e42f4e1c885932d1782f53f5a91f71123a83eab1f7e37546632b50a1f3db7b0e33c191d14d27e7d58263d9a113e200fad2d90976b8e7171afee609213435b07bda8b5d643072f856ac3e0c2e90f8e77672c2b6b0924e36d3ba20a94a4dd6490cbec311b9472c8a83bc6300bd21d1be49a275c88b53b384cdf09d61ecc78ae1b1c1b9db0e6f38b73d2cc84e89736aaf7d55cb7ec9ad104613aecf1142df4f521aa96d3d2900f76a4975e08fb2b8b0e194e2030ff1b33bc63d0e8fd72e21a4ddc767b5bd266b4666f2749169a8770dd4ab1e2d97681e28699a70f75416e7446fa9e73d13af464b6c663180ff8dd3ce3941cb72830674c74eac94d7b7c88a97839cd0149456d1387011ae9c2c5f3f4a0603b8f4560d57f4ed9023d67ac5ec4082b7aa77ecb3186b51f23e408a8aca8fb9e6ababf75f0188f7f1a2e491e70d7528278d146f09e24c3c25e356382a5a02c0ec22c85e53e40a98914e426804b3b5b0a8b8011f8bc996ac93bd139a971558e737e361d01638fbfe339b6a1dadcd1965299c26d95d1989b09613f83440703eb3671b574c61fb47291eaa8c9f420609d1f50b3568800248d914e3439f49c0c73123dbb1f27c6a7e3063582221139719ae62da2ddfa82d7ee8d62470b5fa1f8e5666660841d262d5eebb9744cd4f846bb977172baec44c91232cb88f929557a424fe6e54a461b97efca78e021cb4b7f8372b2d9472084d1e9651547629eb102c0650ad106e23cffa0c8f61f5aafdbfa61f105af8f5e81a603cdfd7c66dcc979516e0ff507543577631e4e128fc1d762242b0db49721985e39dec8fef6268b876bffb7f8fcd90e1d377a35b6bacc88b53d1e242cbf5534155e4924dc0ce0d2d046c907a2a8913d8ef65b710af8586c769fe3899769b655b2240b3980a4663b8efaabf53a52c12ccee63662af3a51677d93e28ddee848852eff6e2f1896defb6b00e71794211d3130fd7a63cc53b58652558183bfb903d160d6e2a0f998d7144e9c740627ca5efdc17b64162fc3d7f03bc39ef44def7fab4852e656ba3bc528753724d58a4f6c92272ef1eb3351c65ec5f01b90f40a0eee5e74a7f96afadf1d22d2374277555834e0a1baf2a03544a2d1ef3dd5a31abb37e3139e075812414605f04966fef5a2e77e5e37dca39625e99c431697bfe7467cdb6ce347dd1588b14e12d4b218e60dda0b5a08feb55186c304e4c99eee19dfa79048e5879a18b7d64b5d49d8134fa2f04342b9793ea7cfb0854391c0b78f8c78ec75f75c3683a4bed91a94397cbb3dafb6549a1b74fb4cd1298c8183855ae89cff0b85d4f6ae7dee3458f2107b670f272c4ef892acf9800e8c5a77cc830f02ee1d67bb27039ae74e5e93873669e08028c658c5ad13939d164f19125fd546b831f6a2d38bd2204a139a4c8370a4b7a0b3c994f116ea27532cf0c437f9eaf0c6ff83436cd49d2d197fcfdadc3b37097a95afb4edc881cc6e158b9785b5b29ecf768325caeec7c9562f38fe3287bb1ccd5dc5fff57f03616b0e6f05e3e48b841ca4283f22ddc5ace2f9733eb9d7783721a50ae068d553f68f381e2d4d64b878fa6129970a23a7ec58306046e59166ebbeeab744bc442ee8ae8c77941cab037995e34ea7f1792c09f53bf4fbf5eb43f5137da2f0b5806454764fa211d9fc9ac5299d64c595842357e64ff6049c099210e953426e7ad85bae87f5b0846556952452d608a4d278fda9ed7372a29809ac49fec9674425552f5e00a7040a76fa1c6bd9131c5a04f2997472aa057cc2e9b27b5066a3a597f94a0bb00793b96cea4bf5148f76476af698eb8f1ad0927691ec233deee2596c5c7e270baac20b40697f4f45da272e1c5b93c428a529993720b37f0be8a565cd3db40ef7a43714a999758ea501e45527c9a44675648b4ecc3ba41e373c9467771d94a6b8997d2f6d1da92da421dd1e012afd16da7c8e16d6f8f32cd397c53618356e9141cbed2e6ff1774f69649d7e40c59a679357cd651c5d1af3abfc66062f0e75f1454ac17dff5a6f3bc17987dc81f111e7e227d0ea774c6b130c92f01b9061f0fc58210471a14cdd47d33d2cb801c71efa83ee6cc081cf519c4246d7d0637b50253c347c8c178f5094e3fbd741815d18901464d78ce7eb8a966e1701c947a03ea1282d96883f890b878551fcc24dc7296665888efd8cc5ff4ab2f288369ea447b979403b44835fbe3d8f8968da8c9aed048918bd9d8d1623012b01863befba7f6eaf08c0ceea0584377b8094b53d751812d05ed1b521641e5fb35263b87a7e47454a56d817609e9abfd3b16a2b0d29c32b5db61fb785a93f5b14a73f1218469d80382ceaab5cb3336454a44857d5036bddd3b82caad93040fb893640392549327cf8880c64a77ec49fd6da1fce7cfe12e7dddac97c2a5311fc56fc5f78890fdf6ad4c1bc23ca12369eed3d676f0066b7feb256763f3f614845b2d5425799ce61958b151c2357859deebc9b464ba3cee36d495f859cebf3980488eaef81cb62b9789342d3fa495afa47db4c94ff2e672f499981aab18f5a5ac66294faf2fc350d6eff53c2a495f2f472284015f7cc919e55cd49f7138e577f0218987458f28b51822f6f7ddcee4cb47bb77962358cb40e3402cbc31aa35d547b92854c86bf6902521f5216c6a83ca68bc48b8ac4c14730a2514a1576ff2fa63f38bd70e49d659cb140fb08697344bf5b0f08a73e1650ec63ce01edd32f0d67e223b6f58bca7b4a04cd8d12f2f856b966c19b416711a32972700947408d8da890da1353767a9a442d789ce81ee381bea77817605c88995f96ac12c2bb4da2f2513c514276cef9567b48ff6961fc33fff7b174b509361b3b36b959193d4f918ac7573e3344a4234495c54c1f169e3237e1cd19991dff8c459eca3caabb4e8de290a0d537b4af975cce3df432b96a989eeedbfcf3f243d1a091bf51db09bef0de83efc196c0f0253bb978f8f170faae7d65215ccf9f3742dc9b524ec9a1592dd83745b1137ca9ad74290b7dddaede8daa1f305946c154d49711a495d67ec79274cb465c8a9b0ee96d15af5e2e7ed3f039910278df44ae6850a2856acff9d63b444d1848185272cf22835f45d342dc098d90132dedc5a8736cc4bc55ee46764d3738ad56bfa2eecbb588a21751b094edb60b7d9e63c1dd8c75a7b90d77f79c1240acb09661e00bc1bd0d9811cfb548935308f077a103ca4ff05088493c649c4b5760b2dd19b2e24f2e0ab1d56b7c056cf77b508973237c16f9f6eea768c79b4ec29124352ce8ea77e75de0ddfa46bfc210693008499875b8ddd929555705dbccc8b344c0c4f97e557653710a07406ea2145f3a53e0752ac04f265c30e5e68653aee3c90ce13202abb0560af4f7f01c04031990f1d39429dd444059e6ad04087d3fd8621d53f771495b39906772c236f14854151e26ee59ba9f911b9cf1d18a6f15d68495f6f2e1d960c4bcf5fd94a08033a2c902032756dd8d2903461eca4074009ddcb9b8a10d13a0406e36c15e52d75ebf7ce4e5f1f56359928ca80cf569b6cf70de9b20f4844744a0d2a5e683c8c7a594d0f8752117776d85c880a2f99c707b666de1d78dde5cffc96384029b7b7c70487b4961bf5d6f746a11c222a0682ebde68b6fbf3df4389a587b283659154736b9284a8353162c348b45b0892f3faacf42ff7672d56e3ad14e095a10cdda7ee2ca4aeb2c9531517be4e7757abbc3598d19aa8ff6f6db77bbb8621322a2ea7b1f17aae646562486ae413feabdde2b2b82d628740cc6f3c205b065953c1e18fe139ad66b71c9f4f52ad3cf0001f7b2b24c938b1e4e6a11f0c20998602ca1cebe38b39bd3642bae4566884d57b37723468b254012b7de55ea1cb0b69c0c02d06eaeeddb277f0b6c7f144fd41cead11549df78a11dea0d66d4bda6b63babb16d0ec4399781024930747c1b7549bebf8be55dcd9a8aeda728f0083d6f5dc7f4cee4d8807f95e3c3db42c9b5bbb63b6e22aba4e5146dd15cf5e77fc7607f242d66faba8f78399134cc1b90f85454f5fbf9ba32332692d788574efc6c449ac1846184d7a050ae32ac16ba963426bc52e9aac0ae63ca1b82684a8b9eccb15456cc031ccdf14e2e29cbd7382feb0733b7576954e894a649cf015158a061752bf7c03ad35b50201ca03a39f563948169e373762fa179c5b1f134b1bec76e609a80eb0bc4865ac78c07df3fc13aba3dbdee5cde815993c1ed55e43d15efaa09195400868784ddb6b87aba1db12b2ab98b0286ebb269f183bf2953084867c2ea21f390ea8ff057e4bdcb8531bbab7e1954961592b51531698c81c3d2c4f738f44ea2c071e30467a29e0bad52e5a4884d08d6497147413bab425d4feae3f3abd8c258d3b4fbd3786105a09e4f88598eae177208fb81e30708028a67d2e3f5e2708f54e5c261b0e99a15eddb8c48d8e64fb81cf85af669542a7ea109891f2c226d83a88053108a2c5594eb37c9133025f42e2619b2ec93f40c379916b788cd7ae212392e748475d93a536b4780c6e6d7530c7fa9664c6929ad4afbaf6ddcac2fcd182c08003e44119fc40068003a57f151922b335c9d793167236550c5b1ce053148fc1ef5b7dcd7379b06f928321c1edf4d32c90dc14dad6086205509a32dccc29b4bdc78835764ba6cdd130779ca868b93fdb3640b515461e8467ad1eaa146ed786bfbed00d49c6b8b0166977f5b60856857c13a2cdcb2f8d388c6059be5992e9c27603d18f63595aa461dc9220802dedb82397f3597926bb08888a4bdb47c009660a539d5ab24e33f0a09a7ac47def6aa429451decaecc2ac5ddebbff6de8e8f5bd3d79418ed7397d15297dc0b78e29395fc6b7a8d90c6ee448005bfd4078c375dd378b45fba2144207f26bc703284c8aaa124c987b50ac90a1ec51909302759e9f24fee7dfd997b38bb336bfc747480275a4c4a8086c42f331d0b0a43b09173bdad14a113dc075ad8a094909516739ee0fddc092b55220e717b40516ddf54c4b2d537dbb0989574c934683691ce8a7111008090534c93e069d9d81cf60bbeb3e0af4964d500608963b00cb48e7f0a4304b3dc5d4fce183fdcaaca59e27780910dfc57349f9adde365f8ad20744cc37db55641cfa2ec19923489346a26ec55ed20600089d6f70ad16829bf337defd60567e629c28c5d40a84e8edaed0950777c52cb4696b3008cf3808849987f055c667c2536dfd246727f5eed3b2d7081170d8488973d197e842f5a264f22c14cc4950360460383f373f043f6a4529aac769777bb62d55cb5dab5f5de982164f9d3afdd9e6062449104e592370d8197e3ef5ffcd72883b93dd04a8c6528237282987b75a12783243ab424b3e9e5985b688cf8b4c9fd31a8161ebcdec4caba144987133e18189ac82d53817431f8c0da6f748aa99ad75f9fa1b2774993417e46bd7f6b11d8a44ffe9e449225406d24e5512009d39527237c073c5c6d63ec46b10fa5c4649cfec7601a85f0a599302426b15148f3fb9fd3ea611071f6ea69991a2752ec087a2f6e25f7cca844a57e3fe3d5623121b6b8f348ef4b1497b6369d4e026440962e19d45349d5d5029391f9a17d636af0022bef6386cb1364c725838fc562b1355cd67c0db0de5e0f9f16f7d2cb2aaad391b46b70b038734a9e64bafdd35ec5b740f9aeb4ac54693ec331ecc4fd659fd4db053435c01feb6a2fd5b1f550270161e178f83d924419322a3d2748d7d659b4baff5634d946dc499e1e902d756337e187751bf2efbc38e4ddadb7924f63ca20ce364822f6ee996aefb2954b57fb192398546f6dcbabf40134fe7fc7e6c539f8beaaea8799b7f0c7256123cbbd8e0cb34ddf0e7aa43e1f06b5bc196c3ed362931f5cb3387f5a6ccb70545b7445b936314e276512aa01d02a1ac4cabfb757658dc357723615483e08749dff973f36ba497c9b9b024c8987887b3266adbb59897707bcd9993acfc09139693f96ab9d1e9ac0e7217ef8a04b1bcb261faaeec687905b107cf9ac680535487bbdf8e00fb02b7dad7a6dd4ee0b734fd5796f7945b21b41934acf0935cab5abd86a2c0879b9f24feb0ff8bb4bf392572ea10b81b36d302e09f68746d45facbabd689854a51dbda062b27284a83496f6a47dc17f65cba1de8eb8c5377d6e006d6c88486a83a47645fcc769c656a520f67fb4dd18c5db2505aaa8a4290bd7ac7c90ff7e50a6883520a897c15aedfe2e74e46188e333bbef3d85da20dbfddc8b6aaac6b11e0d546cbc4842b1fb09131963cb2cd7e72d8605406969ca822a35e160f1ebd900ad91f8de04de0be8040b36e886cb2985faa0ffad5ca6acad343892f89871a1b97d7fe8208dbd07939b9ba319942e4dfe0694e8933b3a680154362327ec8b36f64e24ec08adb3625b2f3b94686ed97501d4bf0876d317076602f851c3f6091c16c212bc3aa53d41824cd66f99d65b07de40fdd2ad44c7abad448efa86cfae8b1f4e0ab36fd065f70efacdf6bd324822944c536d90cc9650c64d817bae13bdb7c7d554e9762b3a27b3f2cffc0021f284679ca80dd36efca1b8fc334471ea5aa4587808da1fda60d8436a6871d6a5c6e3eea9184f134f5ae7c2e996b64c10b492a2f7a9419f9d6f0eca7af504b30c32b3d6ef5fa154f582499a7f7a242861827741d0c855aeb6495b5158a27db91240d8ff50400aa9683e6d4b9c31e325d163257110a914b7a33486810869e6d9ff3c03cba5985eba70cf413b34fcc21f50a029b691789d38f77b09ab9701741e8412fc900aa1296715360d361fd70f939fcfbcfeb9f4f45eca4f63507e93501ba5d4426785c0f065fa8c06a69b0158b5506360ffe93b076264177a62c8b726ad3d401e6ee84f73584e51726e5b2299a8791c5dc18eaaac5e6240223d17d15054d2140f173c55735c5e343901ca77fa271fc7cadec58055395e26c43a2260d212747a84bbd168095de1b82c8d09e3f6ef77fdfe8fd511fcd4193b8fea27c60494ecb35ae1815dd615695faf34440c2fb07f1c7f919495879649df56019850c36d2c417f3cec353b7418ca59c002792e2f377627d718000ba8b1a8e142a78f78b635e0e0c34552a6f8500f6db883e1ca0ad7f79b7960904902368886f5aad1cb3d7cfcd9449bba7cba5abf8b10b048cda99263a976f9a180fbd235f334b41401b850226003d900509ee37ccc20e1c5342c406da74ab64bb49e21c5f302121ddf1b95632f8a8b7115feb3dbb80f253cc2e754a8ab3a5d26df81bb021225b47a15966e4e6d5e396b2cd40472dfd75e8ee9ef136efc52aecda64a5a9d60602d64efbbfb0fba79dc7c56f50300dbe100443c3301b6ba401d12025fb6dd21d5f1e10cb08fecf7390b5c5aefec5a5533579c0dc6b0f3a544d75761a4494779420e02a45ed3d3e25d131b4654738541099981a52c3930829e4199f3fed1383c31571a0911a2d3db640c754773aef6a7d3b130bb6fb22abe9fce7161fd86ee20ea03ac08f62c329577d6956fc5ad580d5917530a7fd864a5fc3dda4e0e37c50103b31190e0f16df42a7a658a1309cf09810720acc512cb5d06230db55043ad238219c43971f3d5e463a7e0892d745a51ae3e53e280369811aa9a5a0a9d7568a4ae9cfd1727ca57d964d6b318ce4649da4822ed915f31a853b6a51874e35f722affee910765a47a1e7788c4f6931e1acc9d5c64b2dc15d04e9d97d5c219c9348b3b8fb1eef2a12a4ba10b1365ddf2dfc4cbf7f5f16d95707ebce01cef6b06551e1f69535774b57df9790b7e03f60d5ecfb98b37f6e3f759285d24f9a25602b74acc1e3f3864be353c862dca0329a7712a7fab6534ed531608e20b0fe1850fa671fc9a6377f8421eb1a35fb1fcc9229e882aef406189172d04aa100b8808c8489e58af64c6359cf3f56594fdbb2b6ba12644778df5548be5c7c3daa7192a8a62a9f3ac9239eee3128bc98921c21b8ca7f63046c7c3841bc80b670c95cf5b337185793d28285013e5b61f942df188cc52883b07b454582b6aa65996a870427db0f088e2e6a5a50608414c6453785d0266251ee9034cfec9c6444373cc22090d9a49b214c3f9f8af34dca311a27b14563fee6d94a545da40f144475fc2eb80da77be93d4965868c32a2a6fcff322d1c1b6daeaeabd78399fedaa1128a9565f45426c0291588f76d1fdd134417366e48375889d2d4267e238af3aa2844bb863f9de42e630d4ac25332828c1126aafa2df15ceda635eac42849e124ef4f63d1153c8f241d69d07636b29da166d7895698fb2f6be79b3c9dc6802c024acabe7aceb8073114b6fc665bda28e0905899800312795adfa66b4719e440d0c2973d48ec2a5741c679763621ed934a5042b4d97462227b0dfe90de1b515ade31fe5be7be6836b6dcdc7f79f665ab0538508f855f021781fa9f8ed75d03d70528657de2040a86bcaa7a7a4808672b8926fc2db66003c974d44c86fa52356e1c88f51a17ec5fed3e94c1c6fd3f4ead28754656ae4f437a635a99da658123006adefd1ca0411515b516d7f3a9c60769a2bdaeedc8ae7ea6c2b5c615d74af3f160fa478cb1541543fb43a27e1a6602fbf6c75485a57c105503ac391ed6c6c695021bd98063538100277e9425c0103554edd69e6dfbeadb67ed436fba2fba719a517730aebf259efb7473cfe3430ffb6e19f08eae6bed0c7bdbd6086f68dab42502c463aabc918aa7f5922805f18fc348c4ee0d4bebdc21b617de3ea2a3f300e56c69f835bbebec5f6312d3a33a22f71875435c041dec617038ffb7cfa2770d80af90c01021965511d756885cd98bbbcf7fad3be03737b3e615617119ee4d8ae882aa35c20b4fa81d9659bcb8d90d94df1434eb7c8e52ae30292b36620d69f7cbcf6c84442a0e4fdad3d0a9d8390da33f9727d387bd49d980e03e03209005550ecbb153e5312385015306eea193bd7b0aba240219cdaf1adc4e9d65fee4cae98a537ecc4b4420b112f9f459f375c675911c921d38cb35f57715581198c2fb26e7d1ac17ee33254f86722ac153f38d59966f97dd4a0a30346751accb8ad7cdd8b8b249de506f838f400073df9b1f60b90064a6848280c70a8f4c8a7259c642796cd910d75db7b65815df1fb7457277ddf5d7cf6688c02f406355f3b071716277db7bdb44231cebd3b47d9cc3868a81765ddd35c0b1330f522dfdb26e997da6cda430d662866efb3af6f8116c2708842e661e9aa492253934917aad9134ebb8d320abae6bf1df24cfea3f3f25480","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
