<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a5b3000c2fda11c9ff38d61d676c541a16fd1eadd1289554090b0e8e5737fcf9d922e38242f09868db0ff0ee9ed4546d078b6faf254283910f27cb9c288c0769f92484abdc45de3c6d380313be84b6cea139ed3d72d15703efe51359fa40f78eb39fb691d34163f253ae154b41f230083907ccdf8eb8e6c82bf5bae44c805e719c007bf8f1efb281310eaa774c1e5f9dfea05d107732d96c181ac0cf25e703869d89f3d6c5643814938ebebfa7d89f57604f7419dee1dc3c0bee9bf079fd199c5ba0cc44dfbc145d99481fa3c4336f6c8d467e2bc5bceeeb81b750db909930d78317ce64635701b164ab3ce63a61040728028e4ebbf44c85a9a17214be6d6cd1e24ddec47f06d806f479484322a34c9f9310062e629ad5195a437db937dcebab9aa20d8805f208fe8e86a9bfca2b2cd256ece72f7a8bfcb9985b1092f22e3cc1479df8cdb3c19c11510a7b14c1bc7bfcffc6809cec63e23800089a2e4f4b9bc4fce075a78f1a894b6895ec148829e38e78a04f163313b89ca57acd6628c8a0e878f8d9e73aeb1c09ff998ecfbe49f27b213794ab03feccf4fc8720288f910a6eb438ef202a6d7342c062e5c6f6217344ada3e6e43a9f45cbc8202a582b82ed41ac2fbe25fb97d854459d4a1ce0c36900aff717107dcf7d6d34d38a308dd4286d4f6ccdaff9a82e842433691e0a800875e3ba30532dbcb290258cba45a674f14536334d07894c9255e8e2d4255868ac31523524b08ed5a33b5b55d5d935ba77afa4b0907129ad2e7f48dc4d7d817f6ae767b150ddee28285e122c0814e81a46beae3fc8aa0fd2ff9323e0de35990a36b2f9555726a05fcefc5568d19e65673bc04062d9b0b7bf5f4b461d8b537379d7c501f3878af9997b0acd89d30e96636ce3b2db32d6dae28213a15a1cfe2a3ce09ae1ddad087d84888e240f8998f78ca36fdecf3961e4849c4e486b1d427a11e9be97526325df7549619c6b7f033d6d49f4efe79362ad96c4363113079e4b87888ee291aaca9f8b9e965a752abcb38710114eb86c6fc0dbf9b55caeb37b462a31e7418d0030a15dc7486ad7f2e4f76cf1eff512e7c4a7427c10bacadfacdb5e2c73d5bc3a48f0c590d2a567c522912bef87fdfb96b90b430af515666c6c2528cdb2b27d53109d45007835cc6aa572dc4c1250db21d3794fec598c8b813ded62cd6bb31eb0af174745ffd516852d71373151e379d960b4b5c3b5176add07707da963f5de00fb2144d78ad2dbd6961a4e8fd64ef6622abc918c872ac9490aad8cdfc5ed9fc3291d2e16779c712050252a2bd4a6afd0695228a440c48e7157002c901f636372d0fa3461a60192b1973b439068d6c69b67a6419e2bfbc7c84a6a3f349eaa5aedda9014e0274d2217f9ac501b033fefd3508304acb530c539465a17a534c58acdc548062b766c94d703ca4bbb662a5533287967adad81593928f2d018b66b20637e26f764f6c553dfb44e21d3669a8e839cfbb4eb3e8200600e53740d251ef78fb0be2746e1ddf54196c64bae71c8906c16aa16caaec7e13a79708e459e351a626ae0b3672af9e0b7b0f667cb719cb14efc84cd713d308863e7de497f52076152c02a4ed2414d28c9b1c895e12e4b76860ec0be01e63e4303ebc52ddc2edd45bdf7d36bcbbb62742cba7234802f192357c629eb330640c7693753dc3caf6d95af3fc4e2c4e50d8141f8b7006a5936ac4d10d425ec49b3f9b44c566d5e49990d573e3a3647bca7ff0018a55bab63058a9c03d4b4ced327ff077ed774f5df665211def38b45af09ba654c467808250761a06b3dcbdce197d5514df135675f2873b1b028b8569aff43878e7d2c8724078eaff7447c390767021e8848888d508f3251a30009cfcef5e56722768c35cfa2df85e83e226752178729dec0393adaee0b0c8237fa05b3d6e70245a4196073e9325bb6ba3d654b636272b91e8dcf33f704744e22246d21f4f29fc5dcd9c7dfccd699ad6bf5f272b5c9a60050786b532737824617966e0538c538c4b7019fe9c40d648b685809dadb56223b62f4b21174b049e64b7304dfaa4317ef76d6cc733665ac2aa77a412b2339fe7e5271b263d2485715a821c089923f84431b21c2195491666a6660a87c7d3f07910cfbf41b915b8f3b126757d63c5c9015f44cc8fa5f7e72096a2db85491e3826c364b271b26fd916be5b3b3da8f88479a57b54dc83b74af3b535979a55d95cac0651f59895d59e054853ceef0393168017d08bee6824427bc00000a4b4c4f258891f79a882bb0430f4eddc7620e0e859f13c6bfb64846a932ad24710dc816147a295d15edbea55d63bb3987bc11fc1fbc2bc4347aca87fc9a8205bb226d9a546ccbfe7bbe1a0e1cab7c0f009ffb4a56941e730b921167dac3fbc06489e26a8a55620b15892052e48b23372e7cd8159350367ada489382a408f02deb31846c7c5c8b833479a6e148b368c1c9eb74517dc7f8f4fdd87cec821d4f3b7289e488f8d08953cd4966e165ee5d02c19fe86608a548eed460bab1b8772c3a9df49f792f4f4c59b80a77b02d3b0b06b409c0e58b9817240e0b0fff973e4efbe856c828e0c7d3ad2312ba7fd2e98dd2262f17d39450ea00604d03d344ef6a8a5d48e669eaec7c2f0760f38337dc26983495a49e52941496c0b5a3449c5e74fad3997e667c95388cbdbee8bdc5cd2fcc9c59edae0456e765f451263ba367340d07025820eaf1f2ecf692bdc0027f6dab402a3c9ac553d359e04ee87daa62b4bf9416b659e8cb75cfb0e2b42c9eb7f48dfb1d454d5158c15ae6b34879575e475a664b1b4145784258c370c78ef94e3a4789a09af54fd7c1972fad2402e8c55834823bf3ba78b519f5f4d48b783faf3a72c20be65d942af51b73778291473df63640f7ac19a4baad65bcd5b1c850b106349f22692c02a266fda6c1fb6e15a29eb126eb2ec64588bc44fa7df382bcffda05a87c6207665d76aa0e0cf6251b03411334cad460a191cd586b0e6f5cee94c1badcdde16870473dab32e92b01c43f70f84b0e512d794e401061a748ba7053a7ab86e8e72138fbf2e3d783bf1d8f5b5223b5312c0fa985fe323e6ec9a4919b0be7217d62daf5cbc2f9f47448312ed26dd133d4cf0372fe4b0a7ab76ea4f9ad91e7d8f62b1fe830fa5e8d1d18b93b0ccf86b7a8ece6b8093e57c87e1979d58e548cedf15c96907bc07556d8124eeb94eab9d604855864fce59d6a8d21747b8196d0e82007e5ba25261e23802282fdbbe65f805b508ee9397c6d44aefde93920801cd590bd61d87021b594705558375130790e8cfe717c0ec6e54f65141bf97d435b24841911931760ec8f440f523a97a196f3ac483d07ba7c981731e0220bc7b90d1cc8dde9ea382549f7d30a16ddecd03b85e1c2f1e23b127cb77f4fe51acba77e82a94b95ba1445a2437dfd30bb9c239814d1d6dd6ac0aca82430f2d2afed9d5ec42897102fae396045be5e1fda5e99bbf47378f9d1ee53dacddacdd88cf29c9e9107043d62a9e19a0e6b178c931021cbb53d61ccb700271e6faf98808514d90f4dce176a66489d948acc3e007cae0fb8c245079f0983173815cabda4a3f81a383021b61cd74c63f3b1af7b8f1f2ead377ea2ff88b4f51764289e499d3858f42f8004221200d48d44c5d0110b97b61fd05dd83f8ec00c1d60e1b87b6551146fcebd5e6bbe0e7c601aa0cdf93354959293485da28f10d4a4d169b86b331162b042698cc6acbb7816449968c790d5cfaf7a4e2a5518a0ca3bfb22b798741e8e0535f6661f5558fb2797e31376c21a526da4ffeb70281dadc0f05a659aa912a33e187c5d4030d4e4583b32ebd720c735f5bc58c299036828601d10fee2c3069606e259fb727ccc26c65b23663f44712a2b6b3b3dd68a650c0c4288914f9143668d935f7a77f4abf4134dd70f37b431625fd76e93584f9560ff0842b4a87508ecb4a5e41c10369b2194cb151285a4890770297049572711cdcbc3a09ee7acb3872b99cedea01e18e32d70371eb8e421a86f8571dc18d263f6eeab31b46bc1b74713328303d844b779f3513c7832938b5b8ea4dd87adc15ce9bcb936a4a52c44ee8d90b593174a40204a81a7e776468aa21879711e4595ee73e3f1813de6f24754d905b3738a3892ed82d8b38902d457dd4cccb8f5111aa995fbf16c68f720765ea51331aeb9b7f993aef396d40f22173c4602cdad77152bdec0ee14485afabf373019c42fb2d0391a2b0ce53e0aa710053350f3b7248a1d5fb2346f51ea3d04b074ec2ea55d153ecbcef1c5bdf2225c5438b514067eaa13dd89f2e4792d0f3ee4e4fe53cf95005f78def160bb8ef3093fe4d6be1a111e07973e5284935351692e156c2f79d33a84d120775212623e822134107a06ae3823ac48ee7a1c0bbf489d5fde122a9e289587fbd35f4fbd2929f5787b75566166faf69eec087ca5ae263690b0bed04f0cc448febdcb9154f885ee4d5293a12d81f8d732a1e6802bbc758e359ed690b1a8b6f3bb1d0d733b8a3dafd1e8e6c300148148ea1e3f38a2b53af214b7e6305c82cade746741614d343227169ea2cdc71c2cabbf338d09a672bf8fee138057172a893792b39a2bfa3bd44086e463624bb1b49ab68c9587c52bc19e333161f7cd3d4824d1ce98260a8502a801ea8989286d00d1a8c3dc49b96c5571801d20d26a7bb4c2d6b7aac42ac1d7cccaffc164949c391ef08864de1c1ae5e262a797f0b0bb2137f2c9b8e3d2a77a4ba30e35bca73245c14a18ab9d6e48888e2b1f6405128fbef8acc10a97fafd237062ecae6d3b3123d323ec2e2214ba0c23a87a228ea2ee5bcc8c8dc44744b80fa2380930b7eee75cd32e5f44948bca8f9dc47a573b0dd20259f39cfbcc3ffe08dedef26a89728056af63319b8e0b676d85a5f587f4dcca2c1a44bfd0f8fd2e24221450fc1d42baeb28fd38d71d14fb420a47f6983acee3eece6115c2d351b87efb6bd477244750a9fc239ef3740cd4ba5ae92153808d5cb2d8d92cf9afd203a417142d855f9ad2301da01ed3be71d830da5fba79675873b39a245ea39e9de1714304328d1c88e1e51df08e0494e5d52ab1885d47ad36245de4845f1829285ee808799341d776ed27f25e82172553b6f5c746130ee0522ddb1fdd0d367edb880be2ebe20ad1eab1d271b3395cf10ad09e2e6bb40372559490b34f165deda266b4bd8da49d1dab10eea092b032402cf09c5232b03ac168682fcf333e9648bfecc878c012c8d820ac2b21095025699d156ae34087d01c47038cf8185a101e3799dad5cd85bcc181b5da2986e6118b178f27172f6e2d5e514003958ef0f4ca1341c9321cf05fa21db262b9f4ba1644acdd58f9583357116c55d0bed2d52a5d64b75307b80a99a9fec64a5d92287dc03149bb150735ac518f1ab456498f6a820e9e234bc8691a85396dbcabc933d344f38012cb186cf1cf45646220dcf1dde79b9e4974df1c65d2ac75934e0e4e506e1fcae9c509ba8c93ea2ceb31e0de31a4a20e896320218ef6dbeedf2e6959144e223fe1dfb0ed773917bf18486dcb240827de2e78c255c57d58128b9c618464a759c3d98b35e9e7e29049c0562c7356dec5f62517e99fd3be169ee31f649c4b5252ef57ef4ffb365f4fbbca41ae54aa1e3c393a4b098c21b7918660955b54914fdea7e4a3b20fe631915e675570182b49c65d313acab2fe76df322d55d74f410f5b9603169c5875d2c0bb4fcffcf757f0fdf33abff5ab48c496a9991f36383e3b88d49ca3178963ba81d6e8a0a9438b1a867aad95a9f5974a5439ddc65afae3b7120174825027022feeb59b9b7e377a45cab32b1aa139af85f65169b25e9bc38a3451ac0b97abe6b23def132bfedbf5daadf8c5b90380fe335448018f4fc6fc46dcb152852c61b1a59505c792dbec5492188651ac5bf8bb4a1c4d6e9f6d788ceae336a76969e72a0c93cd9e2c3a28939b88284312fa4d0c3ec1d99e0b9ace3080496b3dcf0386f2da22f3c7e0e429d7d5319daabc70c6cb0b0b7a3453e8243f2ae76011dd38c490f16f2689b2b18c984e8dff7d251792dd1e424051acad105b34cf7d8cd8810377cac53042390cd09141703e50822fc58d56d86e020fdb9008b9a52a1fe2fb0aee8adf1c21799e68931304614d1f1289cbe47fc3c7ddabbc7cfb85b9439b46f1c5a0b6fc2612d4e96d9eee446814126cd29dde6a3230af8189156b97dcce9e1d304226c650da8cf8e714f71953c647f0ddca7d53e6f120490e38d83b9be271c23cb2e87301e72ce441b223cf12839c77ab3697cf329b14fd5e4cd25dc494aa14aeb7f4d157f6f0fdbffead25a88a33d447d9ba9297f73794cf19cc559c89e4132c7531e3c86bd373345e41866fd1834a2dcaa73941302dd88fbe7ece9835f34cf7dcd01b44b160b15627bb43abe1b48a9bc7612e5642282e85983122c60124c57aab69bc00656ed04bf7edc10d1110252cde22875d8441ea2277887613ea1aedfa9070bda4fad7b6de9794c9b16619dc368cda7d37cac5f3ddfe8707428d5686aad08c405bcac9e5b9d5d934c8773fdf08ca8bea236217af3e941792d5b5b94b1a4e3304173add11a1efeded9c7ff51ad60b55b149510d5e983628001f0eebf99261fac30afc2f2a22adb5e6e60afc64ff9d73289b2e68c43556a3656cae9394680b8809a6be789e0ec7b39d0d09b6243981d581bff198a7a6f06f85d0a9e0ffcfd33ff3601d9ca74189d66c29cbd7592b0f4b195cf477650a5374f5e94d25a0f8a5f0a33d6bab2a2ebe9cf9281d4d721ecdab77f1beede83538902b7e442c7577c7e8df351bb8e96030cb6006dcec360620eb996f8151b4c27dd641912f60c80a071f7ed677f6483c6f986b8901995abd4c474d1513ef316202770df47ef40365ddf6e1fb5b5f179b2abbb74434ce0950563dd1a995966da1eee5869691677548410892aa8281278b213d2a67c73094372911a668fecce9d97c9a45f9594ed6f206a6603bec108ab98e3832d829d194dd5cb2ad8b726cc0e0519a44a79ec7dacb4c80dfbb2f45b0763cfe6e3d57f5f65656380e2487ed4fc340a6147e2fab00368ff788b6d46c5373519625ca3eeb35c7ea3d25ec47dad94e4cd3877bc27d9ed0d73bf44905aecea164e32b94db911f3391e9b609e8acd0aaedc8316322464ba83ab22b7d5810d0cadc83f93b2cb5f1d4e4764fc3a161f17242be9b5a4225fecd45311daad7dc9d58f76fa42549ee949b08662329b825ab6a8d30b54a8c1eb6ab371731ec4ead0a031afa7f008d77a219a304025560d7fe5f436906fbf80ab3946ea4154b8bd4c017414ecd1aa1eb3ee7474038ad5c7803a6d4ce332dbdd63d83c935d10e4dee335190a246f09effc633cb2f0754c16d4f4a3b173bcf1b75c1478bcab5cf4144981f9aa881dd78199bc04d2c8988080b15cf3d5a5fe7da9f2ccb445ea6ce13eab1bda0669aa9044cb54848d7c9526f9cf48aec7e0212a7532a9adb13d53b2cb10460f6d79e9bc5196211473f8231678d216fdbb65979fc98866725520481ccb44ca1ef5bb7ab3efd90a6399a86e16644a61f03a90019e0e035e823388e937fb9dbe22086bd8aa3364e27744d378c69bbfcfbaed1a4175be8bcaa965246ba000c3a565445500563aa12e5613c4ae5f4b3fc6cc6eeab34868c22ff5b7732f65de663a416f3ac346bec9fce8eb7ad5d98ab51aca280761718afbae488a479afeaa5c4fb5f5a17804643aab8f7658f7b0deca374f9d00c18c4f42c02b1c3350ba0d4a5dfee598dce95b128aa7727262941404a4b0259869b380cffda7b31a3d6d36e675dc4dab202a217edfb117a7f52d90148f90d12384b8ecd73cf8addb809f5aacf1d3691ede2ccfa6550c3ec0b5d37ed014416e2bcff3ba2568879ef43a31ce6ee1ef5f7a3249951cbcfb42987bba334cb8d51310f80d5dc40b07826bfe69e9943af021fc92191eb4ce6efe536b983af5d5d3e4ee94ea90edb33b18d48c0309d52e8ad6e715a71647c3322f5997ac82f69972de896ed2eafbec202a652ea57827f91a082807f8417a0eb7fc62354d4de12d7fd1413c0e6093b71a548cca447caf6e57ca022b9671fe52826b019c3bdc96d315f26176da4347411591e33c0159eabfe3cd8650c512c7a6a45892f2f5523897d654ffc32b8c340ef3a9f8423cec868d27dfc2fa809e1b3c03e1fe8af57ff969ff038d25c4a02f56a586a9df3683863ae1fef12d90ac8bf100efa4208fec59aa3a8f5a39415f0237f1edfabe3b9fc33f04bc13f1d9f5644d9bbfc9f3ca1f9f458bf9f67a74642b947437b47d5a47bd121ce92ab297cd2cda2f1415ea21e487d0836cb526ccdcc768113c46a8f84de3c35d207847e7f518365d2fea6318363f1fedf4f6f6aacd952bf7c5aa756655aa38c62e176643295ee8ddde784c714a397512f69c21323a02d41a77c8b3898b811a28671d44a2e19408e24f4048c1a710dcc2ee12675f77d553b61ac746f5b71e90aba4fff9363023b02b3207c5df8ccf5a2decd6d8ed6de715d7366c4939e433304a644d78c609a6509dea18871c905ffc37109c77284abb0f8912b946525066d6689397d7e7068d69fe92b7b2a7a53b7461328340ed8a79ecc9ad5e1014a8745887dc0104eb5f25dbddd07198406ffd0670994b4e9fcd4576b277e0dd32c95286764f69a4c381cacc185109fe11f2b81b6c6e4ff9a69f6cd4a6b3ea2d8601e02cb4b792bba27c38eb46ed506d1561adb7ed5bcdae9eeeb3cce8f1056fa1b73a448cd59fc733ff1d7d6920724c5615ec38947d4efb087c000d8502b7d9d84b7f8719a6d9cfd6686b4a1874041d1ad290f5ec81bf351bee2bc57ee07404657e660d7f104f4ab659aba04e5053cd2e1bdaed629d0617cb432b6e36065dd300328bdd861c4d341e0dd0628ce34d3a0c4c36a77971a809c9dcf15efc580361ed97584408d49ae0430ade3c115303d4facff20405294e9c7984263cc0fdbd16bc59626a2a3f243219665dc9bb2ab7df801cef21f851af8d840f652b09d0cc1e1e2f5c0f8caf40e4b5ffec2217f5861459305a1c72332872292c4080193bd8d5dca4921e0abcd6b58dc44086ff89b7b9bf7038b28afb1cb74d43972f3f8236d9235caf9baf1adb21e0eabe34e9e37e6881326360a6a78537c97186e50e825d7742bfb94cd895153f8543d407dce7cacb4b9faf8593bf537ac5fe9ec78aea79e961d5faf3efae0b4d8ececf845bdb82308b582f8ed11379620589bd947d1db565168a401f35bf7f17e01c03a49fbf04ea2f37887c4a11ca15fca37361b6373111cb9584696074b00b04c221e19050e2f1a723b73c8dcc68b0127d77dc868bcf8daeb20ad3fe93826dfd100574fcee5f96419adbe7babd1beeb15f36bea3dc2076c2e2c4d1c8a06a84984c325eec3703a772c329bd2d7c5a50cba85a40c7e453edf97093ab9f0b3a87d614965f5047cd794c9a0f127f2ffa715ca715f9614b4d02fb0bbe4328e401331f1c60f7722f8d4b1dba1c293ae51db9987ea0e860df7b0b45d7ee1d48c84076e615ff728043835a1e28b58fae6583afa2c968350111e09ecf126161aeabe0fd388ae886fd5de34b377c3087a99f19b7685bc8ab85eb3b48a4bbbf9d1c7ca1079d8e1c18332ebbd2fdc66ddb8c848a9bdc7850480cc95b9dc34ac18b9cd1de4f78b50da34b887c9625a38fa6748cd83bd4e2e5ce4c6c67eab2de3590901d8ea523df46a2e558f0384d756034f6726300e01c4a2f0e9a6f245051a0297a29865329b32c268cddb2e3043f880d454615ddf81942cf29474e17810cd4691877ea7254bcc52a557eadf72f561a5fc68475aeef451f0af1dce536bc10f4c279c5afb112e2133a0708e1ce7e79461378fab57589909e1303e0c8dc897c4864e04b06b53b38a18aa6f2ebe0dcb5081c5330fa901895de98d3ebc4f8d0040ee94ff246fa79dc8ead5e426d044a31d15f72354f3eb94482b7f6e186b4ac510938dc7bb5a3194a6af23e8895bb32db8059e69b96b1a822708ac072b6bd51eab3644fbd4c5da3b33071d28ae1de06ed2ab2bb9c2be807d07ed548ad16a9227c12d865da49d479de1600c3b5a4312fcf75d8712f706a5f7507f66e9ef71de8420e62fc8552719e2753724bc8944d2d4e663c6f9116b519f96c9170cf1ebf86b42b31fbe16d5774f8bebec9a2b432739ac6a8aa4a4fb40296d4cf9e1d561108bbda1a681218887e73261459e4a6c7f378fd018892a4060f397125be25a87bd50efc0c5dd9503c3a4aeb5e5d4dd842dd4abb03f50bfaab14fc8f6a97ce83fb034ff8920bb476d76e4ef9465657569b96ee0784876c8e6b550129f2c47e57f27175113e98f6deab7cd38cea67bef358020aea98669d342f76833f7510821a80f305102a67a5f174f8da0fa69f8f74eee8e6ec4f14cb7141a5604781e63d9e91a4135a67f141cdd7674f380e7985e87c98638f55f073b138fe7b9bb807091e8348e0b3cc2003e6372b75b12eadb533526b8b667fb49e0e955ac1a2ade75d301eee1d0e802cb535eac66a3c6aa96105f62bbade9aeb096615af427d3a781c047109c3428a9881dde7da2eeb3e2afceff72c9bb11ff55e7ae2bf0d6eabde1643b861fb3b962208599170cb37eebd504496cfcfa3428f625dfa533ff89c882813cb3c52887f5ec9583a39da19627ee7f69df2f7aa9e8fffd8349452c5da317f725b34da41bd49215f31b0e85cb4db33de14a2429d9935dc20dc46c0b458c9e9219539fd84320bef37e4b02eea8080d84de771083e22d97ff6b7e25ddd3e74ca5dbe31419d9ca85e703705a82702a5fffc8dae5d26596464144772472c8fef180fc00221fdd53d3f604d4a4721e2bad2dbd2be574d3ab713f7c2f1b0e3326c0cb454e9d840034621bcd0a4aa7efb3dfbe7a7d8e60fe67e6e3a49b6340246b20e5324aef178bd2869c5e5e6d29dea59dc815ad9a1f91922cae167c1b5cc7b7d07e3bd740cb8efe32f2b3c2f449eaa64266cbb458de58d64fcb8031567775a8eb4e1338c9f70e8042a4d21c574eef669cd72bcc940b51186b5826c7bcc4a5ed2f932123922741df034dfd4ccd2b654a64c1440b0baf4fcc76e913a76cecd86ecba9a0e010f7ae9329639b41e2354bdaca4f959d7cf620518d0746088ecfb39c27ddaf2bd0809af87de681a5f89dc63154c6987c92ebcd9ed40c241e817d86b55eb749765a67f3a742737d5b7c8190d12e55010f26196d59a112b1f8ea7bce95bbc2b7bc2fe71a958f69c2de4b2bdb930875d24f2d703fea819efb6067c044bcc9d5a76f9e9ff15a56a8529fed27bd433896ebb4fbf94b31a3ba570f4419b486596e3efa538819de37b1a798ab795dfa8a72c840afd9d8389f7df05cac0c698e53c07d1f4b47103175e8cfb4bba7c78dfdebd94d0f4ebc3796855f3d786d029c963bbf0f9a584efc50371daebbd6b97f2be91eed364055445903650ffa65d4051ab474a2145fe9d0b865c417269c4366e344bdc4fbcbac92db5c8e11e8e1f082d6ea6b50f17499cd040780bdcffd662fee6c6de75a6dfeac964dcea8acceb1ef13d822684b13bec5d7dc15dba44280800a926566afe1fb081b9074198dd4f9940fffd01b2a27cf6506ee0c66c50533843e5a0476758d3efb99e6073e64b4e1cbdde7c57667054aed872f2451c247225d2583a64b519cf44104c7216c03aaef291cd01fc7944e2f279e51d3cc3c392ce7746223a07d0e1941b20c928c32078e19d2e2ae75a05ddd2ce9adf022513db08b824b3108cdfa088636414930cb7b742df54fd1f65b5daa893f7d2bf04114fb1920e088a9d678000a65986c0b993e3faaa21e9e92db82a00cf39addc3e64a73733626696e78dd219e2ab7c7e29b0c4c7a239dbf27e07403ca39e717d31901d7a044f5bfc8e55ce85848b2d6ef3c4dedba0a441efdc3c1d6e9c57fb273250cf1b38ce6c52dfad0466f52a5b6c87c949706167238140041d081dad308d3c66204ab64510a6270cb8d96cee5ba87b3dcdbe9ef83bd0bd741325d7ad7efd4e7d2628d81605b85d2f1a26643f3b9b37cfb15099adfc731836faccea0f521d14a2a33f57dc8703ef95f02904db25b8606143ffbaf273f8e30c117696c8af9a0679894579906415f511209badd7f7732fe3a9129c9b785c2dcf2426f368ee26d14f6dde69b8b720118fb74a4f86e9a68f47e6366d5a640bc5ef4e98561cf47111f7cbd1bdec76c2ed573a275f6b3c5aabc318330b9596b36fffec75a86df87a9be83a38a5d104c0b484db96d0d9d1c2da938d4fe7ec51e11a044edbeb7fb9ea4f917941a13bde9c4968ec218809bad1f1c449de09240e049de79fb4ee6e6a1796615c29ff8fe0a07122748b30c0dc84546e1cb0468b9b6fdbe65e34ea465b40b6eea4951344de8833888e1efb15b5fff086debb5c36cb24f04ced889c2746f224d6b9b8b1c0c5072708c4741425086da8d265f6c6c74e0ddd10c78a25196494a539893137d99d053ffc90852a0e49891bacd3702e42389f848c694dff56bc5082ccd016ca52340f0e74c596f651590f2c42bd5a4321a36605f33ad020f274d4cabe79493c6b9a0482adc1ae3b579594ab4e6e172ba8240990a93d0ce15cf107aa34c0bada932a007510188a04e139ed7180c24b3a79314f188e609f271051dbfc96e174fb979f4656d4753933e1f4f5302ff47a33ad0971b49145822eeb8dc0027378979c558611509c20562c8984e5a8da4009135da2c2f24ac265a32eddffa1c6fc090b7c882357e41895b1520d75b1b4825c48961e6eed2c9def8b5f2fd06cad77f133f890716564bb5439ad91f80fb96816f18a87a1d1deec567a40946dff24d3aaeed5dfad9b6f6a75d4519d5f9dfda468b2b19c62ef91b661d5ec35098f987184607e941df8a79feec2c0280325ed6c570801ee19efb900904ba9acb5d5b03145e555a500e6761f21003ef0b6eabaaba806ac98a63838aff42405a7eaac6f041de0fd5c0f23ce0207ee5a38ccd2f490e4f2ade207233b3f1677de1885665eb0e13b1eb51cb8b5b2b340e49623499ee921c8e670bfb48e8c7ba0c888861adcc3a027a8c3be6b2aecebf6a61ce62dda3626c8690f6df3a2c4e7a26b6ae32186f8f834e6a506f7a0e2b03c9db24d6d47c2e7ead1c9a722720024103b910c253f58170923cac7f30fd03acc192fd23da2fd8fd27f2f99ceaaefd14d3e0759d0dcf64ace47a6315f02475f136db64f6da867df1df5b952a37dd2b6dabf222c6b7864547e7a8a34361c32bdfe8a24803b8c99d5448b54e79ead56c06dafb77e85cfabdd553f2cda4eca0d8d2228238ef83ccc6995b1dfec6358352a2199d445b842218894181c3ddebdc23f49609cd8ebc03962bd8216337451008ba4f616bba493f1fcba99780b137bc62f3cd5b44088f59ef796505bcaa82234413a63ea9a07a50058c6ea4657b14c6201f0356c5a028d6166c4baf165797f3274e76e542b5199175c9f6584c558f7ece8a392dd961129cc7d21ff335a820eace65bc80578a574ea43dfeac402a0aba9c07dca04d3843267e0f03f11b752166781c04c7c4fca027e089c68261b2364c93fde668ac95de717b5f2c3952ee24d6f4fdbd9cb325dc90aa205ad0fddba1181da125fadc76e0327c0e102941f64491f1e002b370a2e4a14f57596e5e9160cead1f988b5b55b83983e3db7234f1982dea8304e883663e3f14e2a2d114eb53aebe41d3b62c80106da63f372049e337b4d3dc53b04e28b3a5faa35ffacb3da40eb8405f473c901d9907ab61faf9f65ebade3ca86c6e082d8a5085d1495d66f2ba979d5108b622f995dfa4ec284cebdf4cf22f94460c529c53b6df5fc2d17ee792ee1a2adf5f8104728591e6e90ef81fd48e8f5fc18ef79c82e4dd81f0a20aaf9780fb4ab9c78b564d28ddf0fd4112d647b2a77c31071b40c4fa352e38620c3c0304fd5d6a3907522fd89e9a73abac6689c86e5a55c762b869fe7fa36f65198771301b35c98d2c4bf466c5676c8a0a6e16c22d097e3aeee0e5703045ac889d601ee5236e3d21c1e807aabf5f70d7d65a27686166e2106bb54859815767ba7c8ef5101af185a4a8cc9d8c9a865f3bec4f793771b373ed3d8c0fbf78b2a51019959e390e6160735ec8688c38d66f989e70f50df35428df0820f65f8d496b95f271c21ca041ceeee0764526522a3020e13e8ca5cd71bf12c48a421128036d09d09b1cc0f8f97595dfc4fb36a135a404a0d7b7a1b64c335e6a688e8c2e2453e01462cd4b85181083d4d348b98ec07e80453cf72f011160bc2dc0533bc39cb093692d55817b7d4d1dfa5d7c317b33551a87642353dcece7dc08c0f2ec5d722468e96c9ff58af24e526dd37ddac3ffcd4bd2c4c5a5fdfc5222ec9d84d2102130ba70e8bac57a390fe261d70a90e8057b6f9f0f8ad1b85456913fc0bac7efff85ac7226662c426440fb7545c01cc0e393bba20cf8480193f2eb01fad31babf32a407ee243dc167b07f0b787a40489f13e4a1dc2ad6ce173d25408c20646b99a4a905134d869d8510d61a9f917c62db9625ecc871ac9c775dbac924823625859a410955e612bfe0db71b071fa922a35853885251ea2afdec4e144411c1fe722f4b9441e853edf5653f40f50abef2b3ff078540994d66ad3101c18280baa2c25a60e03421c26af8eca4a4c04cf8288aaeeaf72d81a96fe151474800ba6ccd8159848435c16ef27e91ab81922406c541fafc94f95dad44d18d2044dd4808b65d698c913f58be75498933085c14c9fff644986daddec20d875cc3fb85852d4352f5b7fc074bc5cd9283bae74de239c18ebc8cc4f556e4fccd45449dc2d1a8e9f30aaeedb2352a7cd81efd0205d8284f5d851b65f259280286a3fbe9584fba9daacb98c58443781d75e164f3ab34add6066bad7c88ebb7f2111dfda48b2b833409f160fc6aca2341ef2085273ed8e88835f3dd77d40ab28b1e920a940cca3bb05826f00a0b20dffbea3181ab258d9561d1e435d78aee0cae6a74e69b37ab4cd546337bab0732a12ccdea0e6a5dcf55c9665e537d6de5039d3326a452dfc2abafd68ff592d189f578acb7d8862c0db5876838d3b321a425cafdf9b57e8f8c18ed652953438c5b4375d2681b429f2fd1f534d92c57c3ffccc0c864f4039377298f03ed83019ee9cc1447a8ab0b7c438a424ac4058a322f18985a2b6027be45ba8b5e511b73b0b5770d197699903c34ddcab0a3e22fc0f48a58ee4a63e424f1121d28842793264faed9bae466f9a3c277a82a2779e7f072bce329f6ae30aeef7a62698b8a3261bb4ca166d0e3ac40ef6d82c6feeb00f24fc4acd3988e634437bf614ebe3f1e34f3792be8c3b1f947fa7b8379a7c0e0012d17c5e2443ae7f7180ce0fd1ccfae50fd49ec0b1d1344d3b3a39111f2c8ac909e6833350cd533d1cf7d750940ab8634767d2f9663326b4fb20cf2673af8e9a9f9dca078a5086064245973ff08210b9a6b054948987bda29cb2b7d177f017d7cdb60a5a29af33459b9c9c204149098763225bc56efcb206704d0f4c7db6b2c33d4e58c15be02b379b1604d862f5c7cca53115bf0fcc068a4b40aee1ba128d2419655173f2f1b74c10baf28897e7e02806c10b9b00e30abb9266a0ee7c369376e810bd1d867a3c9cc52395e91082b980f109b142cfd4bbdda124129e476062ec056415acc26ccc71dd0b745814ec7631da2b5778bf55f725f793f6ab4f68c486c517e53708daf3a96c74cd6b7b5b74dd94805f53e851351e5574c31baec727fd6ede6603917ee84de3ec713ab5a4a0aa3a1a4fdb755e92b99abe8ab0548898565cce5ccaeb0115c6bbdd509d25415ae2301fa32163b1deb84561a21eeb3e730a48250b81bdf57de64dba4c9ccac2c98a3229ca22f5e7adeb79184d8631aecca485129df8563be2817bb61043ed9c37d6ecc07ea0d35a2692b17377af6019689a3cb61796b2380585d1c90e39aacafd7221cb146f996257469f7c1dcb8ce7958440141dbd58175032bed570f4de2138b6b6edc82d225ecacaa93d356ecf553a7dd1e397cb673df21f045c7fee7046f172aeae4c760bfde1626b9c65219c6c16b95892a34881ad04323bdd7178dc5191282aa6377f7b288cce0a9a9ca4edcd6797426b5530381dd3e557c6953357dc29cc29ec084054f5a61fe92045907d4732ec875e679c04e77635bbea3e21a0a69216cb16f2a90a19aba326f48f1593b473af511b2ad43668373f88e5ee545e0c56000d3cb7929c42dc2f9fcd3a029f4de1df944206a0d6fa049d5842d698ca2c42fbfe7c26a557700f1a4b50b2ddea0cbcdcf52f53451863a8c7e8d753f78688564fad654c716dacfb552ddc257e1558e9e731f235598d6ee778fc9c75d318f8d45f72bf727c27479b5ad623d0e101a7f1046ca144223a869900dfc0ed153428e84fc9ef65698625caa4750db5169ff69f68bd3f987b5b2f6c8a2eb944fc5d91ad7cf78cfcd5ff606778131c26c43c0e24dc6561b0ef369a8a25cddc28ba4b3457d1e7f88432361e618491c927c6840000d020e8d92c9f8ccaf23c244efab61dc89c15f134126f7589fdcaac568d81b9710d391fee39d92efd52f97175e1a761697d49c8c7b1e75d18fef3b5001f14e652291beec57752f1a01f85cb19ecb477d51ca5379a5bac8f8b24f378a75d5ecf84522b856f5e63e5252c4ffefc9c62cded3165cabeb4da582f70f4092f2f786a82be9aeb216e460e4f8e3b1bd2c4fcaea67ddbed792d314e43392e400f4e77e578f4cf128584f440052e6cec3d9aed9a397d20143d5a22f90be1e755a7361253f4146d314921857239b97b9278fca7fdaf3d7f4d2d2eeaf7f004f1e3629f3ff116b5a97c1abcc4f4503dc4394826428a9dba8b991825147bcee56a6ecd3698bd9e2fd9341747f378b77702155ea3838b3746352fe3bb43133945e6e00a8b69c18d6760ef353a56924042e4019e82cf548de3d2a12702b95f77e411bb50047446e23d74eac38b2e673da8827d1ea6fa878569164c3ca4f8fe654b1715fd0e17b15419fb5368ae566a4e19296b814336d874c268fa09d0fc949c18f210b1faf5313110c48c5293008d49699b47b1a224b90249c44a0546b616b74988ed369381249eddf9b7c1ac19c2736448cbd504a49ee3952f70b8b05c580d832e0ab59469409d2b4ed45b54e8f363dd4a1797ec5d9e83ebcca31e18673fd9969c5a4c4a062b81a3ff2621e480d152b0eb7a06a1db4a8c1d99c925814f13d0b2fae1e884f34e278c5dacc89bf176a42c9adbc470e3dd5e7b8b22e63030f7e1e2cbd17f943c34d92a520c1ac835a659cb03a03243fe97e31115c284243138a65d6d62b0f94f8966bb4b2a7ac3f0e10f21bbc0b81e130bf24dee1f973c76371b8fc81cebf6938d3e69ba74dcff19770685ad5eb793c704d628c840ed78814bc0e1cc88a7308b458fa6f2ae8c4bc248f750308b8cbe2d93702899e24774703733c4976eb35668e5984197c8a6bc070d30907b000bfef28e3c3c1a209df1dec2384827df75faf33a4861027da1c819d3975f4fddea32de3ddb8ef8fa19627bbd484d8a415cd7ac9a09d2b8d5f7d25de399f03502d3298b07b60c4f748f9425bf4bbf05bc8ef8684aa6880f1d05304191ba69d50423a1d8f27ab6f1cda74fafa9801772b9c3a1e58e4c83d2a49f7b331632753714c41d6be4be6148f75108664bf91d0f2c0ffcb21acc7af68d15aacb3c1a703d4457a0fb217cfcb7a34b6e6dfad342eea4b4a17edcb98bf721fa1170d49a6c220fde53329a2f7a97219d6894b0c5ea3c3004f322d179eb56ab511458008ddc0365a5c4d6e1f80b6001d5d39a7e1707a969b5424927f38e7a1ffbc804244a6262cb6702cd47695e4bc69d1ff07d2745608848245fa5695dd40c6077118664610149e9f5996a1c07a2d94847fa29a463f71612b97ec4649eb66c6422da7e4d3964fd440a2ace527c0239a7ec4a7a3466878327d85c351553e0bcb196ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
