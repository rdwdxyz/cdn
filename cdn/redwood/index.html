<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66200ca9e99a2e2abcfca80e8947e3756ed7e8d38f45ee84bfd4617c37a01e15f05d19bee9098dbd2994eb0f9fb46d5f092c37b4ff0779d54abe316171fa90e12f11d89d0a3d2d1621074eb053ce8f82808495ad6a150375b6f23d307f07583b5ddd8219a0cf8d94ec3ae8feb6088d98ad34ecd27d4c26e362b026d7b96ddf29df7b7aaa2af3628b9d2c604ce6b11328e3bb4fc6ffd483a7d3bf74eb732cb5e6eed294555bcebbd326ca5ddae9643dca8c6f5a5f477f5957f1e4e352369bc979bac5f6bf6ac41639f2056c1dabf7b7060527823e16d6aecc73c761aea88e89d5ba0b8ed1836c778a20b02606d26dae3530c2ff36e7f193db4a87768ed35dddc9d9a078922eeef218527b5fa0afee09e47f7163cf6d10a516c48dce2da2e3ad9df36f397e68699240026257bd9e9b962b2cae78e4c303bf923bd3bc1b0b355930d5276610abf1fb791bafa64ed05546c052d139895dd54c3644248f308a840ecb01f3c27bba45fd3a348837188b06fbefc000fa9cac6d3903b51885113a6c019d156f9e7a895c9052c9f0678d9faeea9a8838f0b17341c7fca7c7775fb41c19ae3eb8b1f97d583e05c4903c9b16adbfeb8555d954e94fa38f1a1d56322f7625c8af947ec9c9a61a10ea07fbeafdc279dbdf8c2326820c20536654fc5b71e7d551054ab401a952b736a79ef2b4d91ef6008e0e6c719ddd570fefbdb5458653af83443b1a0463bfb314856474460a5c825c020dd3ad830d144a649a77afbd11e425216fa2b80f744d88c4cad7d5e1a163be0109987da1a49e242c859d1c7fa407b93ec484e6f69e94de0ce7badadea9d0259918eb94065e0f665ea25b1d265d2fcc5fb8a1d6b47d0d9d32d6186894d47056e2eddb7217c63a905fd89ac9301d7b0cc2289aac2ad3269d35dcde7d34011391abe6a17b6a46205aa7ded3c67b834d9854df875311058264935109f88ba35a8fd83c2af524786f71dc900bb3e124eb489c2d5976e1b3ace71bd5e93aa22bcf3bb75922b2874e2aac0f7e60650054c79b57d976259755a0a9397e840fb545bd095c38378741eede470e24d40da3ad542aa5a0357a4f6fd15bb0a87d2b3aab93fb9a739bde1561f2c75c1e2a0c116984bda9fc363057ef33c3bec6d93c5087e3af5afdb99052b3917be2e82906ca707e1749f233a8bcf908831dd57cd368c815992463518ede0a5e700bc252c857bc2a9e33ac3865880f3fa0cab82f6eb467fc31eda300941142042fd9193458be7b8fe9c3c4eb3ffac46298aa06d5e1b17007c9dc059663843a8646f87e6820c6481bcfb8dbf9665bf342f14c53bb2e2b60380c81176429ec35a50e67fb0b03c132fbfd7bd2d60315283be57f9ba5597a245006f503ea70d91666f44a9b4c8b8ceb7ca4cbc10315e54846d123afb191b9c006475cc6b6033d7ca70d0f75a86a6272705f70d1aae62f6e2fa068238584486096d4b026359bad0bbff30cc8aba33fc2b495492356b7d493541b7f0b757eb02ad5e7cf453377d7cda8eeb683629b714ec7d37e782695a17817d5e6f93d74bab68431a5679b372895e232d864ec5b9cd02eb9bf1a0a2af5e02c31f9d453c1743a9d52e0a5d68923f2835bc3fde880d54cb5650da7460a4de4dca3f641ecf6c572463a9a8f1ef67299ed1900c3f902e409219524e3f3340d837bfc6d3df1cfeb9604d5245f646c9ffc4509f399a1f2fed11d94662137a577208cdc859cb10f9970a8022733305f2e71ce72450bf9a5dc52aca8ffc7d711120d7b8188b98a0bee0275a8c7e08812127f492eea668a55fe65a3dd7a24d2e7f93aea557d999e53e3bd5ffc45bf4fea13ebf87fb42549d324a51c97a91f7a2d29e17a284d95c9bd861fca59434754919cd2eead26b0bd1022e7e45ec90083febac2c283ba86db3fc575bec64121147b21b73d62a8c90af3070abb52d373534d4f45272ad664a9393b5512754aadeb76ef8b956f3e4ca239c59dca5d2ddc42d1f53df843957ca6e98e494208888ca078ff42ad1aab694836cb8cc198603f91892f1b48d31da23799ff5c6a62ad0bb92fdc11b050ca12ed5cd2c746956f8e863a0516dc9fe7267a78e5d878e507b859bd0982851f93965149feea4c7097b40e69b950ced7f51d62c5e18d377312adeacbe23ecc8cd074eef57f55405535eb3c530a0177499af1244822a4692490bf0846bf4ee1e03139b65154626e13f04f84b961092159c4a105fd3dd8c20acf8cd2b7b7b4c2fd265b17a648ecbc46c4fb02202f6b91b93f7fc0aa02a2b49390063bb897f901803e1969eaad9d107d8cf3dca3f6af1fff9531be56065121767ed3e4372253e41c5e2daa8cc9d0a1e9afdf5060c44a92a4e9c38d54eec533b3d5b53057aa5864c552da6fe9f2209e8df8369dab72522bd2872425f2a86304ab4892b809e451a398b1f0d24833d0177b7e2a4e3e179cf0ff5cd666c74126cdf5c0f2f8084cf47821c31e6ead24ce6f791769e543d871d6a3aed1a3c47f472c638149f581a17cb35274d580009e6f1407fbe00010132562d5ebf5b86bb53ca6e21d590b8cf098ccfe61695fecc7bc544aacc0006c8d86be2f7eb981fc335df05be22d8575fae9f268978050be6627abebaf70a7f771c63fa8ecb78cad6540e0c83c06002a21c0a42303b2c0175f3e10bddb05e8c87ecce7337492f24656e64f4f69c683d6b9ba417806112f86a44fb6a77447b2e0464619318025f1482edc796017368c7517615dcf75d403e8998b1d8db601d83a17e40f307d168c119db18b9b9ce2181a7b43a17c42d2ded51cf28f0112591a73fd06b1b18d12a85376062bf59caa30e21b8af27aeb8d4744a209489be6a0d0f57c0b576f211dccdfdbfc98126457752b5eff576d754904908f3cf85c15755c359fe2e517365b73208d1a3281e5e33c7d94fb69d08912110ed7d370d68e1a6aba80d9c63fc447e85e1150e29c47226c9e016f6e6d4f735eaad0e4467e9eccb887735da2ea932ff6993eb2b8ecfaa89759b56421095c018f1a99c8691db473b4e928e8c9a27703255769622d399aaa03eaaa59a6601f3eee676f9ea351459a89ceea1c83adc02f4542d43fa3122b3c8783379f8ac111c2ca794359f60156ec400a0c53d1374c1dd8dc7e8d9dfbd3f71ae65e705981a553ab494f7fe415f3385254dd03a48709e19b0e372b2bc1247172190b1f3112554bb274ee8af7aee5bb2fee6fa912852ef6496e3f8017729aeb574d40a8abd3d98a8be38ddef0d45170cf50f701c4dd5c60b1ff3b08a5f31e026a1ad7093695198d403b89599407b9a6ed2bd491cb0774d37730c60797a3b045f0788cf43a02e5f23f51ebe6ae09ab9d63430dc7c4e5f80d146013896050585c4fdf88840492fbb0ba9d4315ff072bf82dba4eb8a29a83450076ae90f4566029b9b57506afac622645ba31c2bb8584498a60230e05c26c46945be189bea521c96755e90fa749e00dda8ad63e43f4e6cfa7f74c8c33c567c6c694f874099e564fdd8142106d6c8906f628686278d6ad368425d9b2f4d00b3dcf66479834f70049fb05fe045f5e20a9c5dab36cbdbc99e1462cb856aed43b38bcacb78ab73950b1eff89f62bea21360fd88d4a190802d1d85acd755d9a3d7aca6d6e8956df8695ac880313aaa213e634316d8b67f9d23081d7747c54f15bfd5ba972b73274d53ff45f80ebcdf9aad25b3043831cf896a73266a5da95d5c570d9315f22540255da85e8b0d353272de9c314ebdbf74168c03449987253bfff5167de6c1c0fdae090b854dc0640e2043495b0f24d1f880434c3e30897a366a63b241ff8f44ae6f1d3489c5634b5bbf9c88bc33f7fa2a707f29974f5bd71a38cc441dfc43311d701c74fef71a053a10ba710d392cfdd0aaa62c2d6e6c3a51138fc66f38759629be7cdda46fb3839aeeeb6bb51dbd97e25d7bf030ba777a56e8cf3ec87d9322016c15f85cab118cd526311eafe86c5e176491176e66f77ee8e3ae0c58bf0e3c7abfc818eb7fd58ce870daaafaf0648b0b2de7c7b5553c2a29019b33fa3053e2a61a37b414ebd611d00903ec02226839671f1d8132758ada5cc8df0be0d7ebef8f83f5c98a05aa7f54343956eb8d65820ae20f471cbd76811809a0cd74ef33200a3bd814405ab915945bce12a7798067b79849ef67db80921f18e45d55e586f2afd6cff6681bdf46446cc29d908b70868dfa8fc212994d994eac26a942490610c98cb04bf31b5a343fe0688b2d59adbbd50a375cbc1f75bfda46cf8efacf32d88d11b73e8ef11dac6c0b41dbc852f38ab03728cb4f7bf4050a51d55dd728bb54f8a7a122d4709824031f190bce2a1bcc4655f8593cfafc6d2bd01f880b09c488124591769ac9b5b58cf8a4df7748532d1240fbbaf012765d6e52d65f37018e0821daac68101a26b4fe15815c2a84342a3e40db32032f4709994d2069469f3f3f6dfc91df2007f6b80b33420800d825637b01c8589e1c87299487ecd8c60b6d36b192139cfd4afc7b1e799df8fef0789baf7c917332dfaf1d4756c807d5970cb4b2582d2da5614fdebd77ae892878654679a3c634b13a65ccb1fa485f7d10cac22d682321a7df952562aa55617250d7d0bd0f02b80ba83bed008a99827b54edcc5fc5e39e80c7504efec5acb036db700cd96387e815d70b9f9689b5cd262b02d155ad64cf130bbd583db97a0b53bb74d7a61073bcc5b5e165df5d431cd0a4293fbc187568292a324ea24736a08184c194b96cd1cf8daafce9aac3208e19a98e1eb1c9720938497c812beb875f08ca653073758f8e08eec9f810bc6297186df49df1cc39ad81b32ca754dc684b16ae9bd269e33a7c32aafe0ddba0ef2e45527bab18908dc55d208b8070f71cfdc59f877eb8902c828b2cdf5373d5870fe3618d98a934107c87d2cfe2bdff458279e973c8a0690dfcaf3ca3d24adb0f11af3196acda795198e8d609e1e1aae09b160b0aa98a3b47a4cf4d53cec804e9af189ab03e3c7ee7b1c54c0b5bc24fdc2da878d9faace4b630694dada9b812b11a9f2b60ef2fde5ec2feff3d8e32f87fe76fb709788dc81aeabb3d0c120943ce20b02a930c2f27401b2bd9c9104f7440a9f440d1a8cfc5bbee8066906076df81799bf4d8568b384dbff6aae3c972ac346fa783a090b5e8ab52e673c979b82ea09c0cfeb9c4951e52f9a2bf64970107df3620239eb75c8fd5e36cc97d41cbdeb57aa8572b860268717bd87bb0131a12782b0f2fb0db6ee2eca6d5f7e2d2e872920ce3d09292f4168c0dad5a0d6e319ec0ddb9ba8a261e94452cde2ba94149092f3722fcdddaebd4e68c772b5a98dc5e5d02031f6d05f017f7887e3e889b61bd8dec325a2f2035d83f25794d7e617e43455eba88de09682a56d4110124f3dff3be7cb9ce925f72e07259a3ac346ba1172976c8846ef1a0e77cdba972efd2d4a39a2725e1cf828b42d081dd2517e346db69328333c45c61c152fcf9ef2a3e4840a042f3d1b14e1bdfb0d76e3b031f89f58d952e18ad1b32041b5647e6650079c56b29da162720b802c76c40197fb07729504b85d3892311e0fb38de65f076312f9046c973a0178f16c9bea026b44adbb95207df1af49f1817093aba6734d36ae775ef6598ff4d73b1adbee23525e33d7d741f111136374a025b67f12ea59b73694468163c2b2f2e23db36bb32356f9864d5a1f5829ddee4f1e69b25605f674513b3a0db748866154c3a645ad87e4f8e16a938c78e84f8d1ea7831ea460ffb34ebb0e2a0999f2a636864d85f00b79c3be520468541e1751f7e92bda8d229d5100e3e5969d6e8ef8c2e70993ed37d0f864c2f2e326062ffdfe3cc198a8e2af4dc83bb4f418ddf25e2ab3dd14d8a7a4512db4fa24daa2f14d9fc63d56272dd25ca6943589fca1e614971db954e1594beaeee4cf196f2eda16fba9019944422dc1de46a9c208e05a629e1caa07af8c3ffddd50913774c9a4965640d60fe7a6224471bd36b0d13114a59f1a8055d31d115faf45568bd837567ba5d0dd61c49144eb794782801bbe5139896a59ac4a930b55eb5e83f0f89289ca158cfd195efc142cdf0b0da34af97cbe61f1d6442070038197aa250e52cbe0a804d3f1e5d85ba873e80d1bb99859260f20054a39e2fc6e6552ab78f50e1672304ceae9b4e7b46fc74dc5496673903a90fa5df2375292bdaa17c60736dd4c0b6b56c61931fab0c0345041862cb598d741dfccd42e9cb22ea530d6440592569416fe00e442d7c6268a2746786dfb7ee3e75ab78d8efb5b692c77bcf76eba52fb849dea6854ddbe4877ea8f09833f510a7cae396e03f05605f926031cabdd806cd671cbc304bfbc3c053deb339d7008ba445e42f7a1b41b77a14eed79be1073a0626a818ff27f2461dc41cb24df9b9e4ecb1eb4d58d4ec92e82b94e5ae775bd574a4316d01ff69efe1fa5d064cdf8818a1f4a5e653e02110e0b37105e3fef1cda4b26a71636fee9ec0ea0eb1885bdbc80ca6c0d1530c94b9ea2e753769df61b9fc2852193c710b5e5d05aeaafcda73c06307d0ef949b8dc8ac6962bf4a8b02a18def0b1b640b14e1855f36779b0e732e2196c182aab725bb784371d3b94afcf33bbc2006f0222628426ce966aa19cde653e09b1341f79878995cc47ccdc74ac325c06a0600b08276cd9429f9c453a29084355e8ab35383a9c7d3f42115d8211ec402561540c03ab3ce5fbfe7073583171e55eed8881ee866a5977f69e16a7382074ba9839dcd1342d5702233b8bde52c9170fba1d5da6cfc860b92557c34501fa83ce41972bdf7550c0d084a33ed0a903912970bd6ce386f909dc22a9b7f512159cfa91c074573152841e2beb6db5edd73c06fba51c7ef92962377554157019912f7a2b0b77f794bb7d5a3bd34e1f49f4761207ca417f7159394e3128ecd1327d829616bc225d27fbed99e1135f390f15e87e107656eacbae07fd8f961a3c5f6da39587b98fe80dd102bbc78234a91d498933bed81ddb2b5fbbdc4ae21266a841aa52c3c01d0b6133264502d4e9bbe58a07809aa17f9a7c871f16cbc4fc9af68885c0f90a0614ca58ac7c805678ff80637656497a14735c5a496248a8de9bd2a107e68efb403a7fcf4f23d2201556bbe9a2d2f70449b3204d32e0d848caa0677231c11990b2d4b225615893023390627d6b21e621b35dace98c5d136380e3436fcce955580f80c9f6f72fbbc027c9d05f9fdd6690a30715d4074406b2219abc3b6626d9b5d791c56aed87eede8d8d146cfdd1ab19988962f0c435a0194485931dd2fb33668d425caf39527bdcb140b0038f5a03c6e9f2890b7d14253c836553355a67159b0651c8d398367265f874cc0018ca1fb3203c5c7d8fdeb9df401641b653e9c8c84081e829341066b917f5e947d85cc488eebd4f45e86eedd94651bd3988ccf74e579232d80c54cd7a5489ff94ce0e314e8febddbb61f78da2716c13bdba9aee47714e52f850df798ee612a5bdf3eeb85f20be740cb1d4a4d3d34d2f430177cd8fefb6b535d188895da45a7e5e849f594fb74076b60583f56ae66220218b26df45f84fce8d6dd7936fd4be623d9b2e80e515dc3c5aa681a528fed72531ce6f7951fa898c82175c84b2ff0be1fe7bfb651d95b5873ec1915b5c8bbc53fd795c19079ccefa7d6beed205aa71c3ad5f649240429513b4b7af49f795c4c550d4ce7cd9313b0e4182c2bfc2bc9f44ff97488580ca76aa42af7b9a06a907b4d6765e02a74f793d516c0ec44e8db6c8d0ce4320082a655998a28c9d9ade773367da898b9f83e833f40118849447b0fbd9298c7e1f1ea2ea33a7e26493c92e46baea77123870ed159d95a7b1c5ac756ffaf2d5dcc5b210dfae9345b71102ec26494441f704fa5e5979eae8b61fa2e7656a2dfa1e0e6a3e2c1e81230e2bac2472c3a00a9f4a67f4db14949bf758d878d24b0f22719eeb1c622883a47898fe38a154674c31b36544e30f9b8862b8681fe2d252fc36655c42dcc8c9ee5a0a0c26eba7fa4fb040e01b6899fa4d68bac9964509bc3226ce4666e8bb44275ea04a760c674aae8115254772733a155601cc7479affa891e1d11f7e3121040b9072c6f4a59761914dc2c9eb26cf74a8b8353ed6f51d078bbeaa5635cce97a1dd21e31a5d44d47bea2a4bddfeb080ebafa39d738c1545db3ea82d8cd63d3caf36ea5aa81234a1d287322cdb2f7ba06e69a808769dda8072500405eed17180964787dffe2d9ec9e46457b98504d974b017fa1b1166208354d269713e37ab7eec3b054c8db763e5599585e7bd93c7a6f820717fb9afa66978e165d730a9a01193ea0c778f96ca80f930af2262e92fe31a556506e2b2bb0a42281eeba6974a747212824c12d68dd8a43d095b9d4edce0ca107fdf5ef6cdb60a4d1a90fb8d8605e9e9915f439979768bf9cc448b0de92c628cba311021d032097de180f0052571a054b2ecb1d05f798cbb811c060eb209dc07a3be8800d543be5b4ec3416118a600c32678348938aaf57f80459fd29fd3b057cbc623496a9c3871868c76355e54dffd95cf8fdf355c5d9d7f9a9ab48baad9c59f623ddbfaf83d64c95fe133d75c5cc6cbef0158acbedd963556e260f526d708eafafa668cd71f6b43faf8aa6cb69ed0be55e4977805c643a8e9728ccc7feb6ef268ae85aa62c9df1622bfe8f5deefab0ffc8b83606247ee57701f6b5a12afeeee6ea95a39e1f98289023257d27e8a2f4f0e6fb04fa9540fa0cbcb6dd8d220d98dfc0d397f7e8d75f08388c663f8d9dcd00461d7cc24ba3d39e44fdce9b127ef5f6161ceab7c3a7ab0a6544fa43c585c2daa5ce9f1384345df810159f9c656ad726ddd564cc8d7a19ca0d0e9f77f86b246f93eef896e0cb0b3e42319d95d29f47df65c1fb49f8b980fd180924f369caeb4118797c1c8ac2e284a05dfd6ae14a9df3d55986b3a4a34143bab6cb7d6d0f19265a6071fdf5b5bc516833fe5026d03084fe7e9987ac4db6cd6d45040efbfd6ef602146d89c6ee712ed3c63c5dbba48683c3ea03755f99633ebd77550393783034f172a933bc6742fbde7d3eca3f0e17c0557e3980a85da818ca0eebced3e6b6c5f8bf9947b8111d1ec7082e8cbd60000b17d6ef1eaf329646c7079c512fe9d1a700922b008e9192b8b7aede16f6d66748da4ff31bc21e97b26b42de7aaaaabde79b0373c5cfadd1f3ed532ee815a9d8482309f24f8baebc75c13c48a7f9bb7225df8245ef95a858ff0560f11cf1f8d00b91d5c5c230ec73d47abc8631bddb4c93e9727ac76e8ec3d8c856e3172a293129c46e04a2e2de9189e610193d4aacfc6b0902e445abac6eb033f1a5fb9b2acdf971e304391ee39089588fe38256bf5cf03b0153f77050a3834e0e9dff02cb1286f35503da43d26d146cfe65cff3ba1a5b8503deaaa2063e140911c73e73455efb4f9245bc245c98549496c34f27228c9e445618804864432a8e4e4d8d4e60dd5b7bff442c39c76cad49bdbc249c496970d6db97e4e888d245548faaf71e7d1a4bc5c0e553d0cf6fa04419b563cdd16d88d9c99f592cb45eec5c901e66db25c8e31023ab9670b0041747fab0acff07a39b0d46c4cebf53f73a77ba2882032a168b38a803473b59162910239cbe8f8034516d446c4190a91a47535bded7e741e6fa98dcafabd81317051a5039e496611d5225d9963f84caf9ac5610c912eb0affb435a26bcd3922e15bec09f83796cb0f5b7e46fade0970f93407e9bcb8231837c0a1bc319643244cd895794040fd939cda566907a9c96ce3f3141b319440f61ae3c1b612a2fde6e868476d88442de813535f83bbe89e978df4c88b7414a3b493e23e5111940bcd4e76efad071fc1fab110ff1e20a076ea428265c5f448b2cae8715e4b69e71c9086e222425f46a53a7040dacb5a038f6a536f5b860100137d894d34fc3cb5c821c9d241710af52e4b3f118a25870ea85f47a01e4b20ddedc14d348670447fc1586fd4b7510cb8b3c08140de3714462fe73ac73a2205aaaa1979e41a9cc75a1ab3782868f9285b0d377053bc2dcde4bee60319cf614831c8227d942c79c4e5e4d9775153bc7edeaf73a81ff4c3e7d88185a291af0c5ae42d44dfb53afd43ef2f160088dca820077680654c7130f6c6c3818bebe47fa80ce72b65442825062b903dbc38148c17e4e39d703b48fd2c91541b8c39b37f1dee0a6e0a4607e5892d8049680dd19d2a4ca8cd53626bffb7214ca37fdb2b56dd7ddf8d4ab5444422bc006c8302857a6ae2a0757576cd4eddc3b3f121ed41506ed3fb35cca1e1d0ff2a4b006f89d4870c9a78fd7bd270e7ef5d8461c57895b0825bc6f0f2617eaef35327dc6eb0a6b25730d5a159e4eb66768c325501ff0f1c3d7e054d2c1817bf8c6211724c0c659096d02ca2759af519518701559223f2156ad2e7814dcf652aa66c75af2652ab617c1597e66dfbfd1bb75374771f60194db99f8216ea410ba294ddc21cda2bd3641509e261e1f884b1162bacbcc92826c063d66e20eda9fb7aad135989d985125ccae403d65c48d9d057bad4788549e14e585bdb8547b21409d0b1893123981123b5b1e131c1e929910442a0514d9fa3fe96a213682d3c3f89583fff3aa3ce46f95b91d5bf2a247437c38ad1182997c5ea95992bd9e1750e80214f2c33a48476756e297a4c5ac47b87b966165267dd0614c438b4ef143389873e3f9a84b89020789ec7ce6d6a9063f7e272f87416bc2563593b6a3b26b42b21b3ec5bf97bd7aab24dc4772aac7807247c45a31d807a157c731a541da2bc63ae4bf64dc69dc93c4074bab05b813ba557efb97ec87e81011a84e913cc720cca276c13500c1a7e0430fa4eb6d2e39d12e298816f4180a21ee9fa69410d4f9ccbe86ed6f9cd5441f1749f99b49c62af76024d09e527c1b8db4ecb6a8859c3b425b220bcfaed28fcf6388bed224ed49035e65be2063e632df6a1af7221957c0a4e649a1aae91d8cf1e76cfe166256975fa25b97408c462f4c838c1f6fb4d87f58bf3b331701ce0d8832bb800698304e510a296b06db232ed817c9d92a2aa1f9d16377b9d7a94b55f99dd1ca4125fc9f76fa9d75d30fac8b36ba4c547d52d4f4f9e344188175b85b0f28d47212e29245cf6d36d3a34fc8b9962167e15780b860629297351e2bbd4180598feb678d2d70d240c457e033126a99e2af7389b047095328dba8c854bda431f958ef7429d06dcda8d8b5136d79260cffa905ee601125411331c484794ddc8144a1c90e5021641fea9c9069ca2afe52c1ba1f2ecd6ef1f7481d26ce779dd83812bac2b8d20b96644678b4b96ccc3d096e4484bc7bafc981323f3961b2facccabba53fbd698ea2f57e3838d5a955ad1cb3cb6cbc7be07aba563ffc421b91c196f8204021663f0c8a70714e3619c8be9d5d00202ef3026ea51e356193f0930f98fe75e6e027dc075a5e0261afe319261c2dcfe54d8598837bc100bcc159d3b8e46a69410871e23d43f3fb73f6d7f5828b6e042edfd369d8ab22169f837edc17f80381044707be5c06f1d4ebb58df0f2b44d9d5d0b1562d4498e2c6a995ecc49f536706c39bcfd8d7d025f5f50cd0bc9988c7dc6ca3b65ffbd9de5391528c9becd847df78f1f14dddd294f3600a37a6e8232b8a7653faa1274907fbcb8cd4c506d5903a14a1f161cd31727ce976f07d85094dd4501fcfc18b921c13c4687b2c707b10b9ef681c668ee242a00a23b75f800f374d187fb8629d9e7474ffb6db7a23311660973d6d6c2f575aa3013b6d680ed9fa488e643f3f0475628e554e46760a93622da9d64ec73305df7940749854f08245068434e05d26774859a156664974216dc7a78e0dd56b38f1ad65a2b811a814750cb6044077c9ccf78ce65d1144d64cb26bc49d5fa4888ec6b324eee6d8650caa34f4c900e6912ecde2089398bfb75fef86b259156b8f5be95a7f2edf4c2066ffb021d410ef0b18e10f2a956bb08ba3b09fc94d06736d4fd659a2e97ee9bb0ba4b5d115d2ebee5055f695d713f8c979fbeea738723e2f482dcfecd3d7dd8bcd59bb972e40701ab6339a72d52b0de925e538d99e295e09142fe3a4941954ae75156056f91428218827793182451814e1c3f704af54aa115fb878ee821592066607e3378b50fa82ae4e46e2fdc52452a7e750151cfd0d73c1b74f08773bcfa81e8916a33009c8eaad1df6dd81384db52e47d2d498de830c1cf8bc97fcc4b7ee701ce061003952fa10b909fcab2f27abaefa3d2a4cf867051fbbba3091421e5499acfa8fce6c7ac9f63958cee21552875aca9b13863f97ae703af666666e61c02c8324d809aff4cfecfca1ed67cf0e4a8f845e494db0f62e297d3bd7aeae502336e6f963f240b64ad995fec5fda82be4fec376a863628821cfb6568a6ab70128e13cfecb4192607151f5db4a8b2a61e9cf4077e80b065532b225a2017cad1139d0d463a78d77a5f1af5d331bacc428d822728e70cf41b3300a42c73f653cb11cb62e9514bd6dffa39fa3d3498bd026cc3bc552678ff74782a462d0e5d07b133772a90d8be6a154cf6888e3921d6762b2913fe28fa5b70285119b209b95c83cca9ab2cf479ae3f31f3a50dba5b741a4d48b8c2cde3f55bb1e4f693a222b7790c437f2d2ec5e133cf41db1dfa26792a6f9ae1e1bd17c241ad8206b49922d0a8114b0938488dd68111d647181af493d0fb2f7aafdb4bb58cfd256783976cce6f56e45bf4cf7d65d31c171df69b28521d316f46a70c09f94eb8c9ddf8bf09a5223622d4ebead8dfb360d9b37eb46d0c932b0cd675b4d015bd8130f4e8fdfa78e56b407511b502b0173ed394a8bd727417c28b1c23095bc1390a94a9113e1322592b4cf65153f9fc6440f377dea6df838816dcc5ee86d8e25c4d143330a35ec2c77a11f3a403d502f5bf1bb3a6999d048cc2f580843cece6354a8e8aa23eb0cc45d18f052186547ab3e907684b8f1ea851445ffd7134496b49a3e1e3bd8f04441c1d19c58c85ed12be710123584e0add23e38e39eead4a212613ff57c7eea5b9e2211a545384c543a02f4ab859968eba09cb98d9b7820d5ebd7c1292b0900da000d78f334f69fda5452c69ac4389ebf08f867f011b0ec968cd724da3e5fac933da8ed8c4d0f3e2eb9cb85fb2109474ec81b33bc022bb2fb33ad959a64c80f549d12d69e6119b5451c2193ea83af6734606506d504b275ad421a710e296714be29b5276ea86386f7a95e9c195c0b3a2ad981511d4c119c063fecd6030916706bf436ceefc93ab13fa8d00617832dd25fa311d6ba3cfc2a5135561831ff31a0a45cd51c39e989609ea2d616338cc85d78d1fc0c32b34c6b63adfc164412b7e4bc02e4a680bd25befced73a955d5f01bf02fe0fb5763da16eaa79dfa63a189897b301b7c55d30a36151ef8875af8fe9e2b27a148cf827e80fb66c5737c8cc644e7003736587ebf11be9aa8b3bf6939e977a41df46eba168e494d92124df03ec63090d4d76ed11e7b2258ceadbd962e647e60f0234c62899732352522185262577abd7d011abf02cdaa34c2ee81aa51006e8ce88df838902f43817d91ffc4ca6cf31926160673272884838d04e5593eb17d4f6845a89249048600fb1f8056dbd00574bd02d73af702bf1b5d7be503688a2618589247bf9a24a47b601891d52bc2999477ab535fb24d7f013297e2f5590700bcfae30af695cb4e57d2c3fddf37f3f1383b7f58baad17570f7a7f6271cd805b3d2c83f7e958631de8fdeca2cb2acf153775fb6c190edd7a06c9f819f98df603eb2b30910aec0523b8d63ff63b93e1c3fcd90d0aec1fe10f524abdecaf5bc78ace14a918586fbff6db9c7d2b59d3a87cf869e01491b3af7741bc0320d38066c0e2e0956c2f4312b36970fe7393534e10d9686b3235818141809e1aa43145717e04d2add90bef4b55a5a9d00ee9bd3629ebc1a3924fb26647d3dfb56ca21fd02c438ad986568663f0d62f4898dcebc1754a57f9fc1f386fc272397f16030d27a2afb31d43e83d3429d9cd3c1fc060bbc24e3aebb57c9f4a0d1b9ce63a5c95e069935770f38cf95f2971928c831f8f2e88a81bee04cde4853640e6a3f0a2e583e30913a94059bae0b55be30fbb317f92417f2bfe25e3900b4eabb8070eaeb7d05a42bf95fbdb2e6b353a5578274ced73c2bedbacf11b2a0407af8b418af01d6072a3e922b45cace04c975240fa3427695c11d03d9a79351b117805f27002469c4d0bb5c4834fc4ba84be91b4696186131dfe29ab63556ac235feabb9e545f6c9c68c2bbbe9ba9964a0744b8a7c137cf3266179ad123e8ed2774fd7f0d220bcd4615aa7b2ffd1bb5c7898d5db6b3471aba33017481c36707705b2fa7be2f34751dd328389d95b36f38f31359004db4258156283e3c49f621bcff6ab1e7571d158073fa760634503be5f8e18db6ea26f4df989e46ebd4dac67a80dc47cb5d8f005368f1d269b8ad69afe564f3cecbd0bb124fbbd38390f128f8235f5b36a363df1ac5665058c7488fc68e8ab35702eecc96019a4f4b2723141b876e4a97b47529be57f3c34e902695a983bb53b9de749e3c737f856c86e384a9e30cf8126dccc6fdf2823120319f3f0ea096c6f0dbe80960e9b8e1fd0f3f6c4f60435309fd579e01548b72177f07e5b0eccddd688b8d47617130841a13fa505e404429e95f85f61912d8b85ffdba5a27c4f490cff77163fa390a4a84b66bc590f9420fd53dca3457d7a8f679c1a9b7135bdabc6576da0f10fb2f0e9ad0d968088ce89757721f7f4ea0b28ef2b3b445296ba89c3f0fdbad53cef67a733744f4f686a535cc5b8eb490309a20eb4b7c08daa2edd39bc7230bb3de15510b459999acfd59eef94f368c93671d77bab5a36a9cad3e313396db327f1a0e4569783feafe100a9ac6569c9e9455341123a597d5955c10031ed2276ad01f175f1a537bef12f7218132f8a0c367a3340f43c21dba6659b7cc022e3f9fefd1340be67f40d0c25e9e7b0fd89d0d4138738864b5967962701ddf4eeb7dab39e78f7e0a6994ff48d46ce0b9ccc3956c191d4777f6765cb843f5d4a2e9ff2734d0794e24d538275286470a6fe1fa468d39e8ea3972e5dbd76692b899e816054be405288cc6924faed42357b034dec824540f9bd962245237d6f131bd3ec01a90be76e0c3ecc51a42f348e902f914e039d20a807f3ac2923e0b6ee3f1c040b89ed7e08d76306f949857707dd2d816f054f80242e6baea08083cb5d2dc1f83cd9df2bcbd5f4a0e3b3ef9da6d7e65b6140b6ab7aa5fa4b7fd4ca5791381e2e714e1b20aa00526a03062a7c23b6f41748e519848e6c6f8f68bbf2b25726b3792b265d881f340df5730fe00406bc52d48774c4efcccfbb9e7a3abd6871a0bd5f3e7e3f6bab046d87cc64622a36e2ce6fc4db85216864c8b96b0f1fe9672d25f9a03084d7a7130ad30ea11064278d14a87f12bb9338ad824c7c4d1890287d137573dd82cfd388fe28bf12cdb1769c72af02aee02b265de968598a0c3e6fc04c57a72c24981d7d58a26f70dce0aa9848b44fb6a43effa14f62471c08e9bec54163fe5e263bdd362923cf0178ca8e3a403b553287f17ee9e839961432331cbc0b3a47890001fb4c1cf8a53d9245e8fd44d3a1612bdde5dd57a39f5e23f178b5b64b4bd79ca36b9c5775d2be32ddf8472c9da5be5c8fb535ab7c85974a01d64231d8b539c558a875edba7ea68cd573e16b797e3dffe05b3899b9909627c0074d163029aafc5d36b2136f8d33fe6ec1c2bf22e95db469c03f97ed04313ff3c67978dd9e1a0ad46923df3169e1515084a17b0de8748b58e091c34aad15ea14dfeedef67edf601c38eeb3c7625462c4ae012987a3640588ed60d30082b2694f3f00f3872ec275f9aaf056864652c28c306c6de98ffe38a754a534318b403df0b83260a931a3b0d22ce6c846baf356d2e448e5886ad0834846f5f8ae85f2ddbc4f0d61502442a52cc4caa6cc818450a2743a1f55093d07c2b42c62b9a9dab0f154a45dbe445e87a297cf9f55e455eb9ad448c9990bb4ba57d486e6c5f9193b40612c5d6675b4b0a579b8075baff17e3cc48897ebceeddeb8e37be75477174762cdfb83b268db87c61833beed56cdcf777ff411099220c87f3ad5b331e75482ad73ddd724c1d98948dbc6125322967c206e6333ebb95a73dbd80810a006c662fff80ee547deffd6150ebc93e44630aedc7b1dbe8635a4c790cb8e4fdd63d637279034c43d5c990113c30edd621d8925f2ad2d58dee7142c59d043f7507f43876dabd693675b2c1abdcf77f371a51826c85e83b1475b73fd64c323859976428096d85906f5fa11a29e6ed76cc8d458a4527bf90bb0da4f6acbdc3df0edecfc135c7ea97568b4940657590659b6c5ac16f47d8fbffe428a0e278e528b40f0807b3a166a0338d05fbfce6e4c40d427cb9d58dc7c2ff26e1bc99fb03f189f4d4c9180b582f7692bc550888afd0c74562a0d77543bbbc96424191d2dbfb5a5ec0a24ec2363306ca1687fd05a2ddaedba8ac17a74d2d8ba4499538c22da88e2b26b6e8fb8314f1dc33bf1569e6e8a37c449e2528c6dc9301fa67e4dd51b2a95b1721ac8ba0919341d422b10ac0ab38fe5f5efb4b49b793b985292f6af003034efa3be9beff34f254dcbb86a08a435e14596cd5fc762a6a8026cb21a2c9f4f4692f41305fc47e5e0895daf274ac4fe3c72a339d0dc1064f3d755e0dd206097e81cce05a5cf35e2e7be2622020af51ba469444e44311e87c3c37160285d572d5673e7912ec2b55999f0db8d8c666df68de529a913b52e1244d51a79883b752d6848e0fe184e7ecac175c70539e8ea16b992bd4f9584575393dd4af51bba3e58fa8fa97c4adde4fbb14e91fac7cd373a0f9f433f6ce377f536bcc49b948bd3fb914322a9cda0283268f5daef21175017d98be59261140e3e926cf70089e71c2ed2dd8d7bf731dc325596b231f2b046083cd2a93dda8d9d3174e0b89ac6fe3d1387775eca84fd11548676cc63f5babb6147a350a705b68bffd24993cf34d4a5cb2c5faa74bc5a7fb78fe45e44692c69d7b546a100ca0c1b0e8b1e51f35762a392920a61acd191bce81dc08d389b0eb5855e159603c451013b99f8b9492ca8b522524fe05edc1ce4df27a67a59820f56ac54b386c5a80e570f26191a0dbe19fc21a452385e7a79dc1896c06b739cd4e775c8274edb353746aeb28b0ceadc7b8fb85ce9576209102e772aa315376f2d34db25b8888c8aacee505f23b7a9e3084f4aa9d335c4630bf6cba85a21960fabde15b50ca6caa292cc59cc4958dee3746a90af37ec82d3142e2a64dc273163eaf57f82917e207223af6614acf01dceaef9d39effdbdca1c0cf9dc79dc39e5b9c38e1ca437f4658280e3eb072c4c05dcfe846eb13523e6b29987294f28d52bf229b8c12ab70854c52597ff2377cfa72c0a70e2b2ff99f5db1fbbdd9e72772c9283e3839827020ce501b58aee7ddfed7c47cb2e82025d68464d6873a453b8a8c7d55812e2f21f3b9e76b3490f103f656557fd4afb8d490b9cbb0e497e6a7a808db57becc036d903a16bf2705495eeb6d0929e511b01b7acbdfcac7d92d9f310f1620565c46ce9e328db10325d2c8371d8c57472323d98bbcb2896ef75c215cd94781adc46896754b51d4ad3b8943e64614856292e2d4a2d9bb7e69d56f96de46faeeb3e154b5c28bb9b08d33c23b7c86e201fd5180f542b6c87a046e45c0ef940465da686e51ba085e81f789399f2c88b15bb011070697ee5581ee5a048a06106d9077d6740258e7d7fc1a56c5b9528bc047d852732549629dc59b83b74731ecb643a25fb6696b996c56cc485ecac8643518fd7851ca6a2a689fb8c7d52332816e0b5f12d6eb07cb7399b8f9a557364559466f2a80796fc7e1fdb2d13555415ef0742cfb4b42776cc8cf9add669a5f1d1bbf0af747993b213644ecc4864e4e8d0bfcd5020e1f877e58cdfa9a90e7b6416c0863ecc0fcc78b90ef439180f3385d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
