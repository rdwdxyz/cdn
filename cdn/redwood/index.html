<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61ac8f817abaf364b81f747daa07ef47ceeb10f07ceb8180d95f79c1133d91b12ae3e7b8a782db8330bfa8b67cd27d0cfd4d9c1f85c528c3087001c598ed25fdd827aae7ff5b228fe1108090706812ba96152e66a1f569268c15b69da2b33a409d06b344b32460e0dc5855b193eab5bd17ac16d2702fe308d39d9df3d647c60579ce1ea9c1629f7df472a73430d9d028d6192d0246a034f7f8ae2ca3e37ae9d0c05169d4c70809743e04f3f2447fc97485fa485bb4a239103880a719573026af24395141e458b793aacb4af8d9e95c229b448957869a6c4942355405527cb115ead052d7a86d61fb6a24cfeb718c72c9cea8a17d89c9255a1dc33ffe0048ce0f700b5157dcf7b74fa5b38c257bc08331da815e980d374f2c45fe00a1f693b296f26ce22fb965101759e56ff4bfb676b468004ad2faf2c243ccb4e7a078069753b957a4f6abd6ee12b60688e6e48409274c46b84fb416c14ecee4b734e47866f5a8601569bbc448580f0a0196bf76b3ab41ade61729ddbd2b7ec7964d4b7a0de612c3aa39938f6460c44dd4d97a8a90d4175eac5953b6b776081c62091b5ea2191052f68ca62d0ae3c5d4d39b5b2d75f7369935ab2f2298b5a44a8a672fd6b0aab16485bae732dfb062117ede0591dbe692f447367137a4a0fb7d36755fd9e07098744e1166f760aeb74ba43da7b487908b5e9db217b3ed5cf5c2995e3df6ed7871eb015b6c445a00356936ab753f580c6ae1853cedb6e2eaf3e817f7f5ae77cb3d2427785fbcafaef65cb6b0f177141af8e972ad28ce00bcb2494220b576d28c07453ea33e953ec52be1c6703b2fe65cc1620e4d0128c101750c01eea1ca41fe7a8670039d0f20efe6f74afeacb183f38dee7ac8970d6987915105c39a58321d94f185121d7184f2f9846c2434f6d17b57637a2f97802995c4c05defbd1621182bd3c927e134b19ff8a5665f27ac359ce405d927832300bbb02e260418f8863c419e6f7f7753eb85e388ce3e8b7c69245d6a116d9d3cbec40627b4c9d3fcebfb3e5ae836898665ea6656a06f4f593c98a7f9ccb560a75d6953c74102f61abc0cee4255336a21a94796689290d75265aaf8e6373ef92509538758a856ca490e135a24d7badf9def60fa58e431ddabf44b4b13768b1916c85b93bdaf40ec97810859ab711513b2cffae6993094f9cedbf4d631d31784a07c3cf6afd0e647a83a879c71948f3e209f76eedb6f70390011893546771e0eda9d6ec3d483ded20651e71fecdfe4906efab6142acf58c13819068c243a48b92747dd9510ed158459163ad27e93ececead1ea254dbdc8f5a27256cf67e72479e13ecd64205032a5a67cf9ba1c522b08431ae1f74eeaef4958211414da099d9d255e9cf68301bf7c37a9bfe41d5193f13748fdf72361d583c7ce58efb8607f1f9b9fab04802d3906df66e1924ddb1830c14cdcb2693fb5a6c71a0932ab75cd4dfbf3cea2fcbb15726d166ef02f9ce3ef0e484e51a4dc91a897ed24b85b9f0adfb3d01972b58285e21bc9611b1c80487fee0b29d07428a286b20c6b287cff7302c0e80de5e229cf272e01393352343ff8d926fbd9ca743edd128aa5fdf6ab77e6960536242ca373f333bdcb7679d2f1be17a60e589e2b8707b958c206946bae206f2d1cadffd62059154938684b0e9abe7ddd2939997b8dd23d94ccddb10fa4138710bd7176b038b549bef72930ddfa87dcfda5c9568303e9434f13ccae09eb59d9036edacfa168656976b45da37242fac039321ef2d0e8f8e08ce49972421e4830c2f9235d099ba7b13ee3d26d923d659b32c6e976b4a81f9672272fd5e30631bbd73aad6b13f26b80b9225a414cb01a7d2977f3204aa58a8d5561bc447c0d7367bb583350e84564c267bdc77378a7c0afa0415947a9c084592626260b067ec314973a2c24e754540a1fa46a827c4f8959cc9af8117ed2bd52f55834a16f8b4a386e38b3d5a3943cfb0abd966cbca82100e86e0d7a5653cd6829e7debfe6796167a49295f7a10de6926abc42bc463252e95b6309e21ed25b067d01c4714f9e488ffdfe09e45c117f910ae47e47024ef7fe8ce1f9d936d18bd7f7e347b193e2ff1661cd8836d9a49b6bec156629b1936f608566945731a042a96d9a04522970bb55565a17ec24d0a6e272c58c932cd2cf61f317aba4905860a7a8eb832dc0e5730349dd34e05be8384e57c56115221fa5d279b939541d0eacc217eb11258df9faae6f674ba54cf50924bc79f4b58a5b9d1fa507c4df44f66f3b9581904e25d17f0188ced1574c2479ac9594c56d72023a8f0e2f5a25715c44f0d73c3dd85dfb3d5742bdfbe7e99826d51ccf5fc281d6929c319b3e41e6dbb906b667701b22647e6cdba267014c9698176d9e7353b5b1dd9a0a45f2cd447d65ddf8f987f3c4e8542754d08a5c2b355e44779ae3fe0daa405b1010f3ee27f53486192690e45fecedd67813246f69e3ede5488af2b76aa1b6f2d16d658af34404e9afb89653cf4d52bcf7908f9c82a870e2b3432d63032f3726f2f703b61be5a0e94a1ecb2af38f04dda5836716a78a64801c512458a3139d617ecbfd6b9227317c3e241facc18ec8f19a91a42381942d3752176e393c8116c67862018eedcf5407089b4b0bbd1454939c3d3e80444ecfa7df92105d52d1e345be5a4607b27f31d7af8be35e5517eb70e74f08aef7cda2f2710d65668b9e6a22903f93ada37a5e4d997d8fb4c83609b023f5662eeb603199360a280038c5a154102795245a80d668cadb7bac0734f533526d09317cd1745e813825289313c2363d7b7d6da1ca38e705deac5a1f9d8e81eef3a33fee442b3725c78a1932513cacc8ebadfd88982610f814efbe48f017e2287e276fe6e8a7ace8a395fdb0c0af2e690f44b2a837f50fb27b9e8724f994db4fc1a4e69378ecab3d60f53c4fb8c790544d4152c2da8713623003dbb801057565fa416914e525fb849d9da8d8fbfbb93e9bae4fffc775d41b296cbbb4b14d90bde1917ab18b30f73686575dddddfe48b8094c91f62989ef7b35c42f118e86560c2f347446d79c0db1de28a6949a5da44f60eaa39056d5c217c36fc33fab2550992b32837b3325dc1b2fc548974c593a5fe52d222c402a62e402326b95504d157a34d78d2d7addb1557edc6a9e3de4af5aafdbc4d9d0ae7b144a168dc6112c0507caf068f3c67761f2070d2eddd0e09902605c4ca3290254612ffdcc32608000fc026b03b8045c06fc0eeac265f9706e46ae7cf90242daaf6124326a6c61c333bb53e08ae6fc837992e7fe238cb3edf91d58d49ca6c133822a06d9e48d9c179a57026856ccfc812dfeef4f89830680e6f35c9780c938871e53caa624743103cb91f63a486ba7db68b161e5c37b8afefe8671e41c5ab54b35ac3d106ec2e0058b206e155a970bcad5f111ba28f68ebd8984ea8545737668e82b18ab6bd1a2e5b66b97ac59fe65d13f964b566c9a72dfc24b610ebd341e35779f0302fb6170ad13f4ae401ab23a35059c58b70973deb2f8e57c96e839eebb8414fdf74d13dc53862fce080815c4a4fbaf2f3d7474340296f65a460694e717f1ac26bd62c9dde110ef2681e24fe81c7328a56512efb7c0568f9e6a7ab565e4fcb9fbc2e0e54c5755cada6d89ac4666f40678c3600910f48051790281a9201e477c3878f1cc10838c4e7fd6fc0dd1c80dc0bcc3dcfe52db29457364494e8fc94c4bdf9048d28e9c4e8afd5b0965540db74300159dee2446dae11969c0f656774e746035b0d6f75db641eb92188d36655942b6fea37f42791bc2d3642ca7157f2d04c039e421f12d08edcc33d336863ce3ba4f228d10516f90ffe2d73cb38879156f71dfc18387791a7ee6125614d7c39fed88fe7b1de41fdb46316e9940feef33c7f055c4f2a9237c264bb81f6f1c91b333843c7079c6254fefd15c62910e41db5d26f6bb9c39e6f3a70db1eda9d4f720e2c61be5424b26ed64b33638c330296a6f379d9897ada654727c28edc0c4df5dbcaa58d68c27e720282a643dbd4bfd67cc1e8f438afe84eca0d2b8acb9f5581003ae50044291d4d188fdddfbbbaac26a461ba2608178d891f419e128ee07afe6c9f1a42a7536a9c6970dcf3b0f8addb0c9f77f528fbaaa676f3c5fd86e48e4a46d21c5757f0a8da591f6ad398d0369302ded22d22ea5f646882d715bae43760ce10feb6ea3f79dcc637e560dafd23a0cb517fe6d520cfcfb434d3d43bdd40a41baf2f94c3db319bb0b476ca347596cb4eae92b69f285d7cb8624f24ce993b0df6f7e609c98ce3560ac19840537946f938aa0b02f42ff31d885c377963b3419d143de9e11433f821fb5d17bdfa64d74cfc3889c8732a943a8327c96ece5c3e5b4d78038e0e0cad01a3812d5064947a047eca5e22387a49778e9ad2f20f55dfa03dc20e1a1ec3d069545ad39cc75b42786c444c92cf860deccd06111c4d2ff7b20e629d5de451b307d4ff22d834694163dee739c0ac7e1511e952fa1262adfdcdfd6b19627ec55a61143041d6b3dd60b644e2acb041d90ce088208200fc0891441a0a1a99d0bff57c157746f49b3d4d447d122a128547c0b975edfffc86ce1212d20a7166aacb693037a1c33a88b604b8f9eaeb47be8452be1085441d7df47fb0326c826e66daa847fea8d4a53dfb6a6b820aed713ea908b67d3ed0d0e1ab88d23dd670bd926f194ce01f5253753d6b34343c62e36affb1917e43543db0c8e9a9839e92bc45be35c66f7c914db6bfab5e82acedce67d8ee996b97663f7f1c2008822b45debbc07dd78cdc75e57a68b08e6ac91032cee33997c4268bfc7e660535a1357c0cc200426eb2ba16e95dce5f4acef6bb20fbc0886f0210f883f3b43d1f585f3de93caa307a460052a3ab58276f63d42bbc41ef29cb8876f7791ffd167bcf5a90437a867e67a3c8c2799efdc76bab86021ae3eca6b6336916750fdb49494edf9fd91a448358a29547a2b5ae2d2e066f5e75bb4b4c75eded679abe31d6cd0aa0e2e04487cc211b801bfb59958bc27f66915203fce7fc7fb03233853886d46337ab5d29b2b1109d24618419fc5661d4a30e2bb60068be2acdd2cc26bee5d8f4fba5ba14cf66e5a46d250abcf5844bf47479bd2ab2569fb8d5ee7495d919a05202fcca3a361824c66d66d1c2ff64509fdafac84caaee0ddd1b4779485b845709e31acdcfde49804e26e24c5d18e54f1c18d30ba2581d33797fcd19e48fc5c41ffda23955ebe3e484f29a7ddcf8f6ca16b48601b871c2c891c918a1c55bff6cd7ba533105caba5c4877240d57f31343d457173126c299c78af96a323425d473508eb7ea804a7112ac414fcad3d07e73a66078bf4e025b14684533b350d28ce9b4f08a2b49fcadbcc8786e98378fcbe30d25343af7191c7bb7fee32aa57435705919b635a8598556454221c1dfa8a397a8a81b0a9d2846cc11b93a995a4320738b3c0f1b10162f2b9bb65a2642b90817629485a734b95b1f65501b329e1dbbbe08d1455be0b2e18a03c1252240e0dc769dc4fa1996a705e685b668cdc0919ae51debef932af3443449112e22de55303e859271367185b86303d5914c3a46407ddc3cd7189a11310898c505e5a068a85c8b25172780b2f11125c113682d269725a40d6d70e689dc229fc8cf072322a48d9687422b932af72ef1d258bb4be38ae0d9444f21491f09c41f62aff91fb4db25856b1ebbf0f08afdbe6ecb0ed74138713cf12bfb982923f534a835bfa037b4ef296cc9c571841a1ac68521ab083e2644762d6ed19b7bf992a3d9c6d81cdb652a3985a1e223c8b260335c21d9037f64e375bcfaa94e272bc0adb4975afdf5144e324a61e59e7eba3c7f133b554911b31a9ab3fa5cef4bd3feee7efd7f22c78abf1a0eeb4745f9a28ae3106fe3ca6ef7c928ddf2810556a6349728968f98bc8e4aaeff3b4ef72891d59d9e39382c6d54cee993f6c8c1ceec5f7ed2d9ecd60671854943cbad2971c2cbd9c6ad7c3461e14388f504f2ffa9fd9d0d825fbd6a6084b2427473e2b83b8130973a2316850d96c2fc6457a2a4876712b7dd20b366ac615edeb0da4d9b44abb50239ace7ebdf5da819ba5a5056f2722161c34cb41acd0c27fa3cae12754fa7294a51011423d8878a575b5a76c41263304d1047cbfe73178b28641966d48bbe0c51a5a5434560ab8991a97808713ee040da817129b4881d07e7be3b91385da3c0a4c03d38ba460ed8e9119fcd3f838b3562be8d3b78e8481de51b82d02652f6246a40c77590d8b636be5e2ca365c4ea9c4ed5099674af2201915cb2ed9a49b312f465c9ff71f6d96557642c46486c7b6366642e72b54e3e640b609af4a3fea5b38bd3c7840972112719ebbfd4c258a4793bac230823c828aabb49d5d3abc905ee4f5bf7fd7f23fe35068a7cde3a0ec3b91aa8776c29643ffd924d249492d34bfee12e4549d3e84fd1f1e3c307426d162ee0fb181aa1adc44910305cf5c845fce932c5c2840fa1d66b963787eff6b58851ee7f83d58be9a0ada688b94f9095444820105d93426ce9d5f920e80fd339fd93ada986f18658fabc53e83d0e3b20c05214c196f49f13e9ad417aabfb727ecb90cfce29c7a75921863ce25fcefef8292a182371e4cd334671c41060b14d2c8ae7ced04319f2d4fbb5bba58bc25d2016eb28b40093a33e21f3adaaabb3528be45ef04c94fd3845a448c36feb604c5dac74ecfae56a287a02fb30d3c9ef460208e5b1b111a8cb5dd29e334d41ef7944ba703eb2f03bbe966a2fce40c3af3b235f3b180168fb12de70f6bd4152ceb1d5f215584b14456c2d0224693e12c83c4551bf56f42979c90aa6837fc484a79e8e175445c8266dcdd48d8e6cc253836905542770526fdd9c12b54214e7e6b8b3045bd1ec9a19ad779bba41510ce22c51d3c1993f24fe56189b171086ed15bb9f86cc3d4f9638c1c4624455012b90f2806c1c3559b0e3e20b7cd080956a36f2354b44aef00fbb4d7f3f26e78d6df5e69d4eb2d73e23ab6bed4f28d09eb13a6624acb5a3ad07d98c4672ecb244223eae6d08fac31470d3e0b28b612daaf94ec295adc35858648c7e83de87e9a491d6d9940f0a97d24b467278510b2ccb70a726e8755ed19a00e34613e46562cb8e2354171a6a63b9d82a052bee58f7d162c36f2678657dc9169cff03d0f7dc8f099f59a0f73466f3bcde9858089203e3c5dd88df579aa9a31d7eec6bb654416ad52e05efb4c6256618a51a26ea5dce4a4bd47ff6cd61a7b4cc0d1611a3096aee56d15245fee7c57c60f78ae680a11fc572fb87429ee5a1c0d1d350019edab309639e9a5cdb5328cae4db452a56ebac0c935460fa1413b33e1eef8e4c15c78265b61b3fd22f9fd4ae1b1760f7f001d93aafb3d8e5f16c26f660ca198569788f6a87c48afebfac5ef7370bf89df96306ee8dda7f3ce384f0ec05bc606409b272e95d1d403b8c513638a5ce2108c9ba8bd1d14c495c0369fc2a2c3cb2c5df63da831f2177756671f65ab494b8906e1a575ff40356b3c6ecdb18ca329d2c624d7e662fba92b480e6e3ec3e581f0c2412027d1bdbf8ce6fdeaa5eed347e259f9e60a8866ebb0843b66a5cdadbead32830b51c436ae034dcb7fc5552823c4ea00279b7d1e2cd01498202867d3632f074c538ca437953c7b4f9641d7cb4bb8a42050802791b69910088092e96b3136c1cafa69fc14d0cddf2cc0bba989a171beace4fca64f380bf4996e05298d1ff36353b78f32d8a7b7861380ce68437c2a179b0b63831280c401549d5f799c782189d4dec17bd05effcc479b90bb3eb70a8d39cbcacd7a3c8f3024559cc35d9af6f35eb8abb2b00a913a9018b42fd139e95c2575cd72f77c7a921fd20eeeb744a7b721d691f98c64a27f080fbf3e2be676b926781cc6be79aecd84d3c63d2838cd060bf97d6739e3331f384122104cab89391d62e3d9894e13e302681260609015932221fe5f9c56640a28bd3c7caae2cd57395179414f1c25bb236573d5a1eada0c69eba8022f4a1874991b962233cd6959201edf99375ac0985785975b6a6b432c3a10f5dcc614ce63d688e5fbd748e3f614f650ebfb5abb570244f5aa3dcad08eabeb6612062598715a8173863b06d3f30808442ba6ac75decdfa3943e3d7ffa6c4cbd279b68702db5b70d942ec515fec02465eaa8b1d9c00876198851e515feb8a76a1ae3f022b5c4f5ccd4402e6363c33c55d9e67013e69fb30ffa61a4ff5e3579de18306b0ac0ec5ee3768ce2551266fd48c0b8a4c8d05ac739cca48a78afb8d2d1e1fb0c6f617e994bcf0c5057bfdf3db1f9103d6b13d6fec1d050a395391106de346683ade1819a6eafdb32e9f89ff592736239a8c57c36367d2c0ff2b51f10b2180bac4103a4d07e270f7fac606990a5cf1351e49eb15118bc2180992c26fc5607a17fd51be1bf77a22feab37a3b6f0e2c60b5f9e524f8c95828d71dc1db76a637d3b207cabd49190ed3c72b5a100f21ebc89307661a2ecf0738e8256ce6920b4de4b0500ee73df1747ab40b1a7add25430ed86c2b91c3aff73b7c88112ac7fb402218da9adf9be5a5cf9e7c9a946ba6fa7fbfe4d1f16c6c122417c5a52ef731957e3069334a794bb13b70bbd45ff8afed320097a124c54a8c785fd4fef5bac3a833848ed1b05b05f16930cd2944f0ddaf9e9b5a7fc2b40dd319f63be2a0544457c636dba1b9cddfc686080d369b6391fc66f7c2068732579c2afd6381c708b3671ac62f3cc2e4228a5f748da3bdd025e8597b101111479dc13a8da62b50cdfcde360ebb009d1eefcb2593b9c75d0e8fc82afdc793f750f687714e5d30536bce88745382d6c48815989aca3e882fe107add40b02fe69e790b6946f26c20172af98afb6f448ea1e62593d97622ce3f6733bbedaa71d85c6a6a644b03fc96f5d24e27efc3ba628bf69a860382ba020067ce254b68e57947bf7e517826834576c412f3bb2d7fb18c125e0979930b4b3a1e65535061352b87ad14caf2e30ad36ddae945cd3ac723ff2c910af01d6a8dd83b377f4d54cf673fb4483fc9c824b71878121a9f6bb630ab8900e09a3fab8ec3306c46f5747f92da68ea0567eeec6c9c2e91fbc20984ac7b95d8eaa4c8501c293866bf642053d77e1d0453c983f7563784945ab9678257398a5bb2a00114d5d2872583a706de3d7d5d30e89813227bd65df28abc1d6ce657f62d29c56b5ae8a5ae5a48887e9052df84af90c2374f512378d8299055ddd5f94eb0c75e70f403d58bd7dcc9b09f7175b0f52400ecc3bba100e5e468499653e052360bf01bf0c2ecc09e6160f92526b46ac3b221abb4512bb4306fa31e410b8e1edf7263973deab7c355ea50b58f21b50ca8dfabfc5358e605b26f4f9ffb4bb2628b7e5dc03900d1a3e979a1482543a1e5c56bc94dbb75a7f18033793f0b5c0a04563599faffe2c13182b192a466dac98546468f9d5fa9c9baf7a8c3b410eb3b98efe1e4dc6ee535cd7988c85181f39e853892062fe7f9c5650df94190aaaf54e68597919f1c2676610eb8f67b29836684224a82202e03b9416cc5d7149849ea9a192c6ef4d7123504fd4d431fad2021faf2edeee8bdad58ea80f2dd8dfd4a15c200bf7d1800925ebe88e6d7d7bb352f68ac46b54ac67fbd1ca18c7bdb104be8468dcde25756eca0e8a465b4412970d7e7e17456607ed316cf95c3b0582d2a63f4cc7a389a4ce41d9f3565582b0a91d7dcdb46ab43b119acc046351bd3249524310fbb27ffe7808afe566f036f56df6d222e2a1f12fe7e3855f98aa2902f4c7c2b67fdd6e3cfe77d7c4c157446bd3eadbe72574e2c5e571dd117cd055384d574d28fa5e1d4e7ae2f7a2ee53d25642a3330a2983b635cf411fd3c63bd7a84d11b8a930e5791b748def57a8d276f34e93c41c602b0f3cd6e004d4ed12a914a6e4086fb6aeebdaddcd3cca1ca54af2537e0757bc35db50ad847ad3cd90caefec8f0ab5a962468e2e7d056e183d9e1e3631f6b8a513edd11dfab448ed7d209102bbf6bf4255273951dd5e898b6bd291907b570c3fbb4cae72072f08e7aa17f2b0f319118e0d83980f97af5293d4c5788f758bdc50a3f45fbf96b9af260353226914e3fab10e7e1721f1068e0388bf840c8c3f0937ae9f99c9b837d75664d1701a5461d67911cbae039b9fa3bbab593a5fdb66f053035962cb329a9a7ef37027ef2327c28398075d50e37ccb5286382b7cf61bcabf07e2ab907796d889edcc8509ba02db183de47b09757edf86e21c20ba6dffc920629dce14098d0b22d955dc7b768d07aedf1a9a4708499dad2a362df8f306275d8623408d78eb9cf75b0164c63ffd31a4434140259c00f0310fd3141d65a4996f59e652ba8c1732143dc482b6994d4a679fc337480ceab1bc0fa45945c232d94dd4e3ca908f0f18ad693742f1da6bbed746ab7ae6fce123c3082f6bd9d4111e986f4a3e51d86a5fdb3cf8a0deb1d06a40eaa901a1a2d913bd1c36e9b85c887d5957185b5c15d95a190064f4d79b9e691c49f248c8bd84d5b20108adb0eac650287d2acbdff3c643d929ee59bc472fb74c03d58957569c4b4fd9317a6c3d56f5b8a192cd58ea041117c7fc16d3d7dd348cb6fa8e22bfbf48807435501239e4a1148fbad20951df6db89489c10440c1b2c9976f551cc14d073c1da1c2a6e8ab6c4ecf84e5e11b0f87ed5aff8b48299474907b26a97e2006e986d60d926f1f5293f53b257ded91c1c084ade37cd9ccc1df16073360cb2379e194522a690ac2e30806fc5ed639db7156cc7ec23ef0804f61c231f0818ddb46df10c168a1c332b6ec88627400f73be9e0b26f802964e350a8a63e460831d527fafaed87685078ec2cd8e55c13a48742920189977abb986fad881a42b2dd773535c4f1f954f17a4438557ff9675537c3a7c77473d183d5e329d0671b37d3c0784afa649f40a6a9d3166b39ca3bfbdbe11e491ca913bc838e8f0ef5fb4ffc51bf95d7905389403cf20305b1d6f2948c70094a44d81ee57af49bd6279a3bbe3eeeeac44422c1d09e6f67f6fb4f6aec02ee40a433f819b29ff465df61157a912c725d63b25770fac65f4108727fabb830277ffe67313ace3e7f1f712e842095e250a5e20f652696f03a7cd51fa22571b8637634507b926b42f3ddadc637dcf682e9fab08b279b901cd3cb37a387e3d312430ef3d1d9c4c9505cf40e330922c5e4896466a6b859ece6b42a243c49797ca57e9858607b1e1a1216bdc04d1c550382a87b715bdf22e79d16c25faad00e07317e4cfd139f54896658cc51859677a12411754c8b9a024dbc6fd571e69afd4a69f8c69fa9f3d33d697fa1a9a6f3961e14567a7581ce84cf64aedc719d9c3043172ba584eeaa968fe2263640a89a387f66acdc121abff6c6cf21ecb72483cd85a9a3a35307945de6bdf9c39c8d990e1ec59c780a2966b0bb6aba00d1536dccbd0972f2b95d92a08be52cf6116c4f5a42fbfc2db0436e9cb1ffd810dd68fba28d53166859a2a09d9df917b915952f5693728846a4d73e1cb232628c5af3fc609928c7ff88ccb45d315efa20a64d693ed70715f0205e252b0a1b3448bc31925ec20040968cc666987bb29b4e6e738305fe5ece9b90d4cfe31aba76cb4a7cb56ab06853f172726da0b1b3a58400599b4b5f686029b2fa414b645a587c1c1d36cb64c6f73610aac721dc812eaef5bd4c16ecc31b6252f86ced8b103782ce6b1ecaa26bbed60ac51c7baa31c99ab2067348eae92d2b2135efbb7d7df9ea8ccc61c998b09d90ddbb76b5a87b2a59d4ebedc58d53fd081424cf1fdd6bfec2ca9b59adafefab9af30ea61c787b55463322c16a6539a6d21ed6c0844f44be023e550de71e90fcf5e59b9d9bd10bdb6d7a0da78409b9802117d7c5ee0cbd22ebf6350b1ef754bd303219af3ce48684050a60239cffde204c9e932946144de3ac5aaa44fd832dcc8e1deada79841f7b49a2a1e490207e5057146fb50eae6911fe218f68bbf55450a2bc97fcfcad2b605eaa988461aa67026e5bd6615883bac49172bec1276fcfae994a802ebef2a5d670e5b2c584eaaa9f9d60b9a04bf167c5462e4e69b01989806c146f22d142e1d8d3d19dc756cdd15e36ce212a456ac612c611c04bb3d78e5550e85b4c89d56b55c4fd9f89acf3ab17d0a3be599dc928fdd86baeb92cc50aae9cf15450e71c99bed046bcca1b1aad1d88f5d7e011b9c84e6624bee1ab38639553a08d071561a1caf0d2f733564871d201896330fd49ebdf36703567f7ac4e02ff31322166b837c2f4e60e43299d2451f5373c824756a503844f48f4bfd342d59d6ac464d850e6f292cc71b1fd65679c9d94656afe24de1dc201acf2d36bc97c65b7898f2ddc753d2615d3ade86efce7825c397d0ebc2c478ff15ba2b6e6de8445defcc9f4540387430c09011707d4ab0866756858803bd062835ddc50ffd6f3a660c63097a6606aa38cea8059c3b1e069d53e1484276d9f1b5c51a2b20cad148ba6a9f783cd76e288f8b471b871f9cf608499d0b4aaf310d17da7880b33d698930dd660ebe8255029d383eb4b6effa3a06dfec40865072d4bc36192793cb4d2c86fd8b33cbb065ccc2dc1fe61ef0bed2d12190c657b1b820ccd53b18b0cfd2a950420d06460c79d8191888e286876e1487072f678c1600cb225547c4b86b6b02eece5599349d4bd42b1c62b4d8705c762c83595ccc765e3089127aa770b4a50ca6f9b9bb93e83b56cf06e8e23482f9e94bb9acb3829b8e8f001d9a873eca0c3ade3eb5b8b76e110ac789c35c7cb2b1cae5f53860f209dd848c6fb4523924c757d4e8627db9367a8b3ac29c00c04719dfddffa0ceb9956bd40a372872eff71bf809ff3850b6923f87498257acbf016ed125606e0584ad0cfde8defcb3b1e9cd21fece1c000558e1b27c44af39332c5688db4f8919f285696aa0a9adb336a407c350f12c49f1274f3b5529b0fe3add3a7d990e7b617f02c51542a684d80212be971f7d3981081a6ae78876957e112c6731917534be052a5c738e6afd0d799e799667305c4f3a3e43f6517780b06ea2123bd8a0bdeb82d533cfb4c9094036822e30451c0396e394f402d08de4f3c33f9623a1d42b914f6908b2fa28f1bd4d2f380b65a595d575ef1944776f03caa78d006e2ada03f864a3562993dd04e08143fe7d6444b12ae80f34bb64d181c7b1e791af105cd7be83fb95499b03ad5f5105a992b39c01a8496bcbaf80d07e10395596fcb5ebb38b41daa61fd6894f022f4996cc8d47dc3560abb07e994ea21faac4663901b95752bee1724c830e494fb0b1632ac3a14791ff77961cc5738088b6265bf73a92160b7fd5a6089ab26137ed8669766897cb77f45b85b04e3b66976e086fa76176c5a76b17064d65e815a1cc6d6712295b57c840863c559d26a5dc0ffd16202424c69954e872e0572adcbf1e7813933f31ef7868d5016e38dec91ef9efe1423032f64ea75de4ded02dc8125fdcc4f7fc0f825f0ae673966a04af265d1a5b3ab65ea003cf64c745648c9d2353ac2f69717130c2bebd0fa3ad70f0216ec4b4a3bafdffbbfe5b945c528199deda077d65fd7d75cce4a681532bc91b51bb940f713803bd17fc353131324d2c77dd1f9512fc94dc3432dd183faa67ef6d2ee6b6e50cc891c5faf5bc1d935261b00a69703fb3422a823fddd0181b990c201e20f586093bc2ed9fc8d890c3eeb5ff14edfbe668a64d2435d13ac488444295637d238cf741916a38e0a07c6a0d8db90e53c7963ced5ef0845efc92f05eb0cbd63a1e93c264fde1ea905954156471bfdf1fbe808a3cbe6515aa46ad004de08ad15a38096fc3c00b05fb43abcc716a9438cf30830a8529cef4516333491ccc6a89df6db3dc8aafba7d0b883aeb8e684023b4a313ea44b3c6bc74d77d13c6863bb1a55938808ff2d4c4966a4a27f5fd374241c9c96c456462dfba83f8b2db5d87d5364f8c4172fdf453ca5536d5983eb286c3e2ddc8931e3e9ca4672930dd9f268caca28bd9f40f4efb37cb45dbb9d17c6bf064729f51e70c7bc7fc4361c30d79cd87f6f708734f3737801075ce3d93e73e9ad4d745b9fde80c55415eecb4e4bb319410826dbdf83c124a05d3eb3b894254f1cea04d4604a3e2314f26aac4b16cf57a763c2c998048caf0ea7556c4aa2752f47988c249a61a311cc4e7913bda920c330b62c3e700b89c35d91340d63ae2d97b6be265798121988ea794c156809e868faf376199135819de5f0eb10c36c099a6f599f74bdd5412bf81fb4339e2634b060c2592f32920318d20edae33564e4d1449d7f2e783dc44eef33c76930aefd83e553f6d8ba11a9361a9bda949faf2069af85d6e564954ce740daee95b3b772a18b8bd9c5dfd4c4082afaac787d936b125a4d7e8eb15a0699f564dc4a5135833d5e20def62a70face9f20e3d0a4c33365b8b433aa01abad5a5a08da1029086bf1a75f01f22de11a20bea68190dead902df388d35ed90b49b372054cafd2805f1b9275e1cfa752086d67fb98323bc43b1ba05fac6e822de49b595cffbc600151eb287b98b4962a369fc89c642f9b576f51a7de9dd3dc9e842efaae3bb54a01c13fcb1049e73f8e9e5368991cf09b6cf823027fee1beb00139e1a13586d18844c392602f9f4ce87bbce551c1e242cfc836e3c61263bb0edfe3bcc46a74cbc6ac5069cc9f13f6f57fa609e564269595833d6e501a23dc923590008c958bf5f019a4ff44e169941de14b677a82db873943a6de949130340af356aae74cc6f180f866654d7622b2de587f49d05b136aa6863c19d8ad693a2e8c055716f4390088cb3fe59045b3e60217800c57cd055ab98875ae6726bc3df01ea83a22f4eeac488b651f95c9bb6e7d159481515318bdf6682d39ce01462e8a9ae20a82f661a6dfc8cc08b3725cb860cb82406d16c3dcf0c3f6323799442e93dc11a93e82c112fe539983f806594da274a342d93afb51984484b2fe13a4b977a3d8df56f6ed1b9f2d430e8bc1787200930f9145e34536fe44e924539337f8e58f0addbe35114dd64aa16f38adea137edd1605822c71853ac73d92ea874c596da7cde82152c4b75e968f16a9286f2b5fbee19bf48d3149c7f9b8e237380995a57acc6ef40af5349486790b15a89cff445af56e2c5d4e31f0dec6e4c6cd89b652761078923c65bb6a8e96cf06ba4a4bf84e6e15257e5e5139893716d34210a98cacebecfed835fb0230f3fd28fdb73aa17a98cd3cccec49f2d5d9b1a56b76ea3a1942d297310f06ba4beb699f82b6ee10d13b876c6a0475f79c74c11fc7638a207df6a954f443c93bcc3ef830d6f65d175065e68f344b2ef166be12e36c1c7885c7e464738611d7f7535f58eee62ab6b4d19245d5895f546163676925cb5a4f14410b6def9f4950ceb494fb88a7cd9a7ea78ba9807abd22255f3f79ac178be74d11038252dec14d7019225cb2fc87d60deb07342352b93dce4eada27bf622bc5b8bc88dfb0ad491f21dfab4ea1cf6e8887e4cb2d65f300ebe56ed99853b9803d46ffe5ddac9296b95e5548d18d02b11e5ba2242145d9161696df399e81df125a89d574a00fd11c6c1d9b06a74076284646a906d6c2af1bfc0fe53c9758b21087a62a00f2951301acacded9fd7f7d4f513b40381cc9e2602620cd3e79ca5ff210599df809104cd4d89a460d03d2110b2a40955fcf84dc669f5c361eee4d997632cdba98a985e289a117dec9fa81760beb5fbd9f84ef2b72f0f598d557c427f6e4123a3521e2047b0d37e5958263edb025d8a2ec8c70ba58e9d5c6a482ab361a63ab01fd14ca7ac617b328fef1291d45af5a5a3e6676301bf251da941de573fdea22709290a1e27cc05b078d477d5e9c9d716e03293a7194794abacb44f6b4116b3a6ccb8916d8b338523ec98ebba683aeaa2a86155481e18ca3e796dcb07e1738b0f4f2104976c47601cba47befdf2e6cdff75afbe6991618da5a81dce0cf7b12513d5f7ee002a19e47f1df3ebebd41845310e884f64a38db39e480d45c5fdfdad37070ab4d3bad27c942785bc1557bc8bb2bb29e2f234065369cd9102d53f863a4ff14763b0819310539e91be4ffd029ef07d632b3df227db4605d22ee01f29ccb7d72e41539ebf284568ce61b88b1144e4e2c3a6b23ac6410d77781375a5d9706ba66119db6bd12e71336b22f761d851b4ead5db41a837e5a62fae98643a50ec26c007959a4ce7700a8774b02a8647a93273c5f30f8e1c0207b6a3b7701f9b19c44b1056d317c5123bee3ddf038230016e4324fe05dcfb4e1b0c66eaea508e2aa2c01b893eb2486f23d4bb75945f9a3819a27c968ab5c3152597705416a9d216ed78bfbdadb52a44657c412950d010d4df6bab0aed5b73719ec9bcbf44aa9f852206477aa3a3a4aa2ccf3718b98c27daf69350a922b18708d9b742bce8671404d4ea6156322394c627c5e0a821e3b6fb7b200df510fa1e7c605cc8b2fdb2787b228b88abe0ce7660acd4bd27fc7d1cf9c8b4a93a5f2fb4bef6a42586107f81ede5ea8d204fbaf25f6b9c23e552662bd37f8d18bc6935e994587d1d01efbb5eb57d6a2459b0019b48b9c71a976926d17430f9918eb11ce10ecc6b9d56afad89f241116433095e4472d8b8c545d5bce2f7f104297e107067ef814dc11d408fe4d451617144efc8e11b63c8fe959e0bd55a471f407704aae1e67124114c7ea73816407d77f5c61ba83fe342358b24ad2c87d7b92d09a01c77e3566cb4e5189699c52820743ee2a459c707e2f63f68d30deea8a51561193e8e67eefd967ad88d93162cb63cf49dd72cd6dbc5a5b8f590347cd81a18428577cd1e78d9ddc142b2f6a4c1a4969ff5fddb4c4ed6176d29d8adeed333f1ccaea45d5d1d9ff737aaa2df43549c1e034e857953afeb47afeb28dbb82438ec7c66e3a42d85adb78643edd067a0a708622260ee0d5df1e0a7890828dfbcdc4683e05244f060e693ab7898f178c8ee5e06cb072a507a433a4809f1625f12a007e931a6eabc90a88c04c20e2a3eb4ab09a0a707e694dc59902dd4edb706a157ac1e757eca4fe775d82db05da12757f92d1dc54e574463f1c8ae8921c65b3f71f903218ce080cb864b52209af5bb072498c1996a69cc081c018d0aaa6d15c05acd7dde234a860b2522c6d41a27af4008233df955a172da24c0375a315d3e1beda92cecb164d8d8f34e7a4952669b7b024bc1fdf1458d7407841fb1afd4a46671b9eb84be872a1b7de7f06d1576ba63b2ac942977d0f1384b3dd6aaf554b6781adfc0cb0f2b0ddabaa0ae3fb0620ba6ec4bee5904920c9300557928dc1341d5669eeece545c35d0a8dd7d9190bd1e15900e6551b4d480ff5b6682ad8c0546e323fb958b457bb9c089ddb3afee71e176d154979759321509d2bdfb7fb457722042d4624504ef1b9459dc1ab4cad2dd8c29348820c77a7ac665ae648ee34f35770dc07d55e27700e7cea3e9f6bfd385b66ae496342f6d65d7b45b6803eabb9377fbdf8d7a47b473df046dcea092957c73cc6d2a7c8bce65e1d45c76741cbee8f2c7276e3dfa287a420a19b4f05642e818e6e8f25a00d55fed77ae6a5ecf5127987124b76fc8e755709e7c306148d5181d5b59c14a52f735d0b7f25452042fc45e6e9bd7c29f75c75ae6fbe6ed4b14a950b3c0f07eb2d78303abfcc9ccff93ab144af8b47dde659ba8d947f9eb7cf19b1d6810f7a5b873b90a110232293ae13d878df9b4dde10f2982db4c6d2ad40b2e417f720e6b36f9389c5285bfa5173380d529bfe9be3e8d1b1d406c8c1dcccb70f863331cc5e45f4f66beafe17dc6f1411b9b39b7849dd0555b8df8d4ae6da9a92755740c3f45910c9bde4369d33c1edce925545e1614ade382bf051466fb8b39928d96dc46b6c7262d6af47e862f8ab66c621a6cdd04933576275b9a8b81c87a20c31777bfe209d8c5f51d23db52910d8330af68b7b3019d508cbfd69e7890454a78efc4d1e9c2a8b4fad2e23c03bd6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
