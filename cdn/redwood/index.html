<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d17c7706eda70a00b7b7b9d14dfbfde3239b43f551e07ebda0c2dc40285c9fe58a7f963472bcff87c39c3e1030859c0a3a2c48cd70e8a22244110a3d2503e1b8b6fe0cfb4db5ce3885d3a36f8f3a7db83d1bde39e5be5a1b013f669155dfc82a59892f7f34b8e8ccdb3689956e51c269a6439698d814f27c158629fa89ff295b4d26833f8b4d9af90255b95dc648dd481a30adcddf46cfca4d56e27f5723cd5f587d7b75813978473f6a3622b40f18de7e28271a706306c662ccf2b6c9cdbb1e196abfaafbd03c4f998d6b5ca2c7386c1bc495d790315ec26007d4ed3792a7cfd071cbf53ba0c8e22b6cf5d2c57d83304df4efa8c0ecdee418b461b08553686d2871320a13dbdeadae89432057919b14ecbd90d6fcc8e1492c900aaa09069bab7156e0b7265cdb158449c9eb9d9097e96903acac7bb670b10ac7a15501c614b3ec74b7f434582e130368eb693eddcac3382903c682596f753f4ce672c73cb30ae70ebb83ade27b05f8210cfdb7c59c4932afd7384967b1fbc8f6573a4adb3c662b9f0c628a69c9dd3637725df256121de3151e786400c65c7df285f232e111e9b3746747fa181c1cfca664f6df5bc090f9c269636d24a871ef894cda920a9897b67bc101e7b43afe10b20a92144374cee56644cc05f1f915d6e52dbebd5c81f2e670aa7d34b92c1d3fdf250fdea11ec8dc8ef4caa6cccca68f71ea2e3c3899c3a6b81015ce63aa6c1f654922fdf05a10fbcf07930e0bd9fa5493bd14ecdf5c170081cf18fd769b19572cf63c330e2dde1d87f3dc1558a8ef4104b9b6572f952c14ab81741cfa003c7dbae46f7b3e6a70de49692bb5dab1aff1b5648553024d016c64ee4f2e64ffb8f0b15c8470f30f51e83e8d798e102ae24ffdec8b3d653b827f11fc0b4144a146fa62deaa3c85f26cb50b3f04ff8670ba1d91b9190023c660e5bfd7ba1110e5d540bdae05748385883d5548054446e4a0dd0ec547661e3aff9a0af4fa88d57ca6d43f8ee57dda1edc4b017c3fb43b78aa67c7294ea15b08cdef3f4fa0a30c33a6994e32abacdd2be27b24ac8bad491de0ac1037cc3e79d5d58032982b13623788b6410ac139aa9b17d8126d370bde6f68191497bce6ca3aaad06a90508d06a8a41dde4dd72e41127006e148ec82175960333da6fa174956f7b8f1cb610e68365657f86468ff213c9076046aef5f32472e78ee74adf849cf7402179bcbfd76c4d0be502bd278145e993808c265b586c35f3c8ac5ac5815aee59a11b25316d6d3c2f8f7b76b2846611fd3b0cb808f312a6a8524140c87ecb46b069f2692c468888d56136dd01aac21d10bbc0b992fe823f76f971c6876499ccf7aef6796d28671b213fcc74e9a1bb45e4a844c9636b72a8655766436db1a02e590280d3b1afa60fad6e1169e7e1622cf43d221a8aaff2272dcfa3ebeef69d416d91ffc6957009c67f8694e84622f7e979e2bf69d9b5e8babe2e4d448685cda47471c10daecc68a367ad2498d1c500e591dce40ffd1355d2b2ef37d6fc8362242c14930da4ef14080c86f485cc799faa8a377fa744371e5b92d936086531494367107732abbd9729eb4e3f18f2a9c53c78b4eee32136bc143671ff42bc2694b25c162354a99bf71d16811372082a3cf0b785ab95453f6f22425a5ecb7593f464dcf05e62d8d8ea7b55cdc65da76a56aa268e13bc1bc413255b63db342b1b96b924d00795039d4f52ec581359044b16266ba3d98cc76ff57532c1cd83a800875e1128e7928fd06669fa8e5d7362380d4dedd24ec8574e7aec815c3cb5ab99674cde716c3174eaef529e07b24e853072786017ddf3ed101aca63aebb87a60336f2f71bb0d68db69ee2876779d3d861607ba342a756906ff9bf3505f7f949e673712dca224a5e1a27fc287603f53d77e8bf0b880422fedfd834594084ba81dd180afd097d5e20705be828757829ffb76170695ef950ab8eee59664a1f2d3ea003e538c26b2aa2978148b94ff233d95ece9473cc5a94bd028886ffacf170e73c062ec73fc35320d33243aba71bdb3c4223d7c83e5567bcf221164fb5c65ec7d2d33595ea33bc941c370c648ebd0f34a476f757053f59a43e75e60f10b3109a456b2f0dbfeda6510d52b3f81b2635f38d619406700e9f1f2d3e62cf3812fdf84c3350df697588432ca1c4066d071efd1f462d5a25305fc7efd42e24c19118a6d03d08affa0f922605b076052b62709a787e782472ee4610f761deb09ddf5f20decb684aff046ece67d5335aafa4193239f69c695dcaa5696f33e7306d112ebae5fd54bebbd5bdd79cbdd1a9e38bba639f2ba1d1e42ae9ea3c03c4a65698ea0bd9681c00632e8d7fe9fe702a14bea6208a830d837b2858a92c0f8593ee1dca144c640b215d2485559bea0aab5d8790aa5cd49bf94025eea2f37522cf94ada28e9af15e4a32cf07f6638d90d005cf73d7ac848625f62b51131cde4251fe647ba1818b774d67834090911f33f7f586016757d14a7225f13ed7814215dc4c0c1c17b6ee877c0c8e5a04ad768a3569d774464732c3c17944fff4c708d6157902c7b50674487766b1fae9f5fafe6d2fc91c9a3771ed87f4843882530b659e69d8e5e2346cbbfa18c62fe23da7efe734a6e4bb5b619ca72b2dc91c70199bd5fbb9520fc84dba8c2f5112ead99efdda79c58dccf896bb8f16f8670eb868f13c707caded48c4ece2e389b94b342ab43f74ef661be033e2ba3d3552c98fc0ac2c514faae9347afa0cdfa1d191b6eefd3bb4173804ae88bfcf56d2108caa3eceb89802048a841efbea527baa01c2bf57617f95a678110a38d6a760de9d5e31a77fd6bf264a6187a9b4940bf8c5d47d40e5ed878eea1c0ea7ca22a3e5d99b76608ca83fa735a6643765de417e02fd11e0ab0872e3ab9e91fbe5dfe41b42d7c9839143a6ffdf514ee8564014b284f8580e7712c4ee047aa96fbbabc5e88a6d333e65093718bae2d912531774ba197a661e9aeaddefe65982affc4c2e384be2ba4371e6c9d2c8f95a525355e9d007b2d5b7e4a6b79f072d08dc97bc4058f0e5df8511fad53c599aa6222536f2f1c52a6ebc2ee7f688bdcca9d70ea068a2d3243abbc1e8e14e13ff45f39cf1e07989509d5739c33cfc86c4dad69cea5aae9bcf8f685798d66d75ba10999424b8531e0e6f18f84edc0b8011f9e5f49ef5aac1ec97aa3cc07da067cbc1cec1fbb2ffed7103d1263c0b5bd4a52a9c680c3ce5fc4d904d76d9f253797dc85b9e6bf43747b56d8e1562329d95ccc3d4e4fe9023128e3653f5511c8fd35541ce0924f4012849195d668b72c5db619311285f63721b0db8f2de5d9258e158f33482cbde9e8d3e1e755aba270a304dc9f0e101ebe63882efe1e8483e930b2a93339eebcd6e71e10f1c9c2bd05204b86bf29e5b89f156c0bdefffeee7d3a5e8839237214d34f2b3fa6270166422a117193c9074380eb976d56dccde9c5205f09a9fc90df652a71c72d8ae1f2f5648f43500afa5ddf12c5b6d9cab414d19a5ad2c8a72541f9a157859bbaf3307bc126f01dd317d1a992cf59d12943455a4d1011c1f861eed84158add01a68e6e3034e4195c7d25498eb4708500a8a3aea0cb9a59c9183bf734f8fb2c7570a974ba0190e2437ff768c6e212f795359a585685026438efa5dd316347b0dce451e80a77f1b87ebaddd903f4217d3a22e2c013f520e4f61ea62d6139d62cbf9cd03cd9e78915bc5cf309a26c7a84494e5dce6ca1f572c99575c8eb3d1020adb490ecacf46c8b937102f57bb4f75db61fdabb879d51e5b82c5e27187ff75b3e9a7296e90faf095e0a0125208a9081467cc6c60df5618c73ec3576bc12b012672852bb4255310db6fe96e1c483e97427d364985beb77eb423d0c647735731206139b9c82869e294a789f1aca9cfa1d047240a36b6eeeb5e0f57d7f5bdb4945a42f0570ea08044b9c640c0ae9be190b5c98c0cd78c24edc98c8a2ba544917ea6059daa0e1d89a988165c38b316a2b587d88c355d75a71135764a31588302da4cb43f8dff5e4adfadc82673fdd80192d2d57ef09e8d33708c56be1bdee99fadbc590a3cf7accf3320ffe05bcecd908bd2dfcb4aff9d1b139696855b66aa4cc5b311ea686a638b6a8ddc93f3702d930d8ef67dca100b3a1d2889f51cd52e4f4ce46c26383982fd60c5099900bd07ac808f779b431fc1971b5fa31ad90b1df7e2bf5dd56e72a38e444a4de5815f82981e0a018e852931a958f8852402f230765ca52b9c8d41091d8df5dd1bb2bbf0b98ec871c07facdb4624f916fd16cdb98f4b9ebcd5e4bbb1dc235baf2a0829fa0d3c17f13cc96b0db06895ea9f074baee154f8e118c4a2b7d429badc71a0d65de3666acb2e446bee21c695cfbeac73e03553a8a18986e7ec41db30927ea70bb1659467210924ff89e0d830f6ac2a39acb13dec6e52772b1c30dd211c7603c0ef3dbe7696e552ab3a0b5645da896e367f0247a8e15225c71d885762f7e4ed7f0119d303ed0236c0a963398495d7a2644b0e1e1889a2e68c5343d271533ff96d0ca54df680156a9c3bfbdfa545e4a548dc2596e2bb86977193e26f5afd54467eb59423f1ac38e14e82f282d3f97085a718c369054f46fd7271e5c018d69dcc25c460bf5eb47a3920948e09ebc9670fcc4358ece4af1ee77c0ee57529f4cbed77b8bb938ef25f12821109e5a9ca579d48d893256f01b7ce751ec40ac957574af13a9d6d4d2c354a6456cb98347595221f795c1eb8d2b1aa765f518aa5feae1f5f2d82b576d5aefcd3ab35cb92ff5c5044a0be17759095ef14df0a899d00ec8d200b275002b905467a805cf48d4dd740d93caca5376201557c233092e0be04a054408f99161bbf71550507d1e1c53343aea6b39007f7f45e487cd25b31f4a2f1e181b24ef4f69eed06e154a41f8323a9056543f7a2c5dfe573d2f3dbd7a96cd8851c23ab4454d7d42a993dd903ea34bfa04482eea7ab12509375dd820c56a06105ff22c6181181cabad3769bc904869eb3b52df3a588ab262cb67c048fd069bafb6aa6626d2ce5c52f835870911328e6e74a6888f7fc47112d5cbcb9dc38d74f3e23cd4349d8ead703d61ce7d78fbb51c981583032436da19c172d8928da891af84d2f9482574d578457a61cf6ade0e40dbe2c19b36304adb39bcfc723444f11f7559615e74b8264bd8d415f4204d4507e5e02a2ea1e987f4319463d357bb0a331a92de79f09f73f9db16b4bf5401270a7786ea36de9cfb9992c4d66b350d04d749b2f1f345b5d9de1b74053e8dbf06279c755a829fa824b608ade08271ed689db4482740c4c73712a77a972e652a89ea3b8d0398abe60b35af3d69a173dc968c4e715ae629df9e534ec68e1468f86669f518bb6ba4c1e14fb3d3533438669c5ccb789df59c32c900af37707179ffd99e848bc8d7fbb72dad46002fa19fe663a3e9060949842b75e1072fc9c44cda9a1ee7686273e95c197fddf859fd8249450cc81c8a8f7b6dbe6f5e9ee93984c3ccb69ae04dbe357eef6a95028b4d01973bf10f19142816de748752fe9e3c9cc8d357fbf1eee910b831b987778309ca027e4e8fe588d2a0632d825b13ea065d6aeae5de2ffc806dd651c03f26272c80b4b0481fe73630a35b08c22b911ed1ae439b1e786298782db862936706856e06cbef07d27c3f2991fe64cb276a1fee5f23da86d2af5b4f3540418fccc1a63df716f2532e017ebdcc28337492f21e2cb62c56b579567c9cee997ed114fc570e1eb7330c4708096838125550d15b7470bed5a52e539eab982553d2beb877668674c6449beb17a1689e970dd3da6eec6b36a5b45c2f3bde7d959c56333c0daf8d179d7237e38dad97b6bef00b9a260c3daf040f8a7d637b9fd69e1f1d682d337f0350d717eb1f8d62b7fcc5bc47c2475fc23fd247b5fbef37a583520f4bbdb66434e03ea0c73d3a687f712673693cc0ea40657f474565a07a8aa8516f87c5b74b59942ed8b345cd9238adb3c028c3228f197ecb4990a04b55614288bd07d0d28cbaa5d2ad930c5ba9d843306e1392aaafcc5ee6b7e072d068aa16613e8cd624568540f23bb5df27a7d8e6dda4870d253c7c7684dacdfbb979ce53823e171dd795006c843c9a23d0c8a801c72a2b6c8c2867ed5601a074460a7b631b17f49115312860819bd2e359b581c88313228b3a245fc9e580a5c791d53c8494eb3e8012d298441eba4f8fa89784af53a4481301215f9ac1dd9837da94da01a73d662dbc7f56f481c298aca4e11fa565bd1cbbaecf6b6b2b6a6fbb4a6c17d780070cba08f0abe13f20e33f2ff40d189ffa38fc2dcb056b1d6ba5cd2a12395a511c9c5f77ad090a74e804a1a19adc35cf5c28df15cc945b6bef981edaf027388dae7a715252d6559ada344ed498a87f7588f644ed86388f32fb5519512803b0fa3b58b75e0ffcc5377888ffeacd322bd5849509f917d908b728197f64ba99fb42dd0943d2abfc5f6e5ad3f893c891f5730ba23d7cca5e4ba13e4cdba8bc53e12449f193e95c190921fc39a3773e3e8043d6d95649b5dfcef36efee62677a1df9d161970a2fd53ebb56b6744309a98051b91686654bbca37abfe5649de97e792eef8daa2027e0c29f0e88d61f4be906221242f7e22bb997c2467aad21b7fc337a34e445aa3f74d1dcdc5a99d6dc4f300d037e328cf40f35501fb6991e36fe2e5cfed1b9bb3b29f808130575e3c30d39fecfca5825bb08eb99c8765123525a00628698d9b2c8b790d807f3d30316ee86e9b8049cb3e35eca6edd056f51ced11e9042871b96bc5b76a3a78973cb0a15e10a0a4cc02f0b0f144ec048fba4125c1f08144b317953945740345d215f5f1a2f8478eec8f3d2e497e72b85f829673890beb7e4eb7ce6f0742a83d107ac21608f5ad6c3e3bd7fd7ce3606ffbfe4c2a3ed4e691426c6d5c8fefc5e3ef1ee244234c7fb48ef94f197f56aeda7919cee5e5f776e845aa765d02ee5e0e53cfc976da8cc948e2d6529060a924ab99c0b0524b9cb21af613174052d00fedfc7e33bffc5a2bf492885019adf2829a86c35fbc572992550fc855517efab945fdd363cd8662add4b2fe268b08917cf16279e08074fead859da2671da6865a77b84108ced9a2ffa7a80a087ba865d02a71573f30a459a242a2dbbe066f9e781f576e7f44f4b39adeeaabf751d210fa68312c36250b038e33915ff810e8070f67014db79144685d2cb3d76071bed6238fd0c45010cd0156a09a38402683b1ce015e045a044c325154a1e285377de38ed3cd300f0a7d9c5e899d2c54a8cced29e21bd1b976699307e06adffc7a2275648d256cbce418c12c540b80a8c7234215e800396afd617a2227615f1ba7a2f9638db491d721ba0c469badea60de55fd5c5444fb178e55015ff805238bef4f9e0a191eaa3cf5af1a53cadae97fecad18c219cc41c2e41309f4c6d04403ee22ad6481481214bb1204ac5c0c0a9e0e7011059a9dda7e19ebbbcac3a1e14aef212b3f5cec24fb81f95760d589358d85e0790a803b463ee19cbe1a5cf5ceab8563be11bb7d211b66ee012f28c7eb1927f4f99b9eaba1725674c541404c5b09f436cdccc128625222d98fb3d32efd2b2d4f6611d46e367b769038cd945c0f29218ca4a56d8d5d42ebc0a5252f593387ed679891d90b6b8d642916e60ad9c8b6206ce522294869f8f531f666efb9542941d7f6aa54f0b5c0313d39814224ad03a0da814846aa0de24581b5525d626926f7b8a9adf6d80a534fb43dc3143627aba171c1e9606b76e81c8e21fe468bdb304179192bdf900631093a7b5862ab2d8e0bb8b96d783019bc1188d383d68477aede490e92d0144d186f59c5ba0cbda420f1d3ef51f5e1e7f7f1c15ade255dff8aed85e463cd37897fe80c78aee97eaa07e18903d65700359218c998174a969ac181faa6a09833eb7159cf00659c989a8cc24761b62c9cdbe660da84f0df415633058fb6097230465437005c8d6ea5a6d693d2c46e6e17b1f89db928b8fe7d9d630c4f1c01b64bd6ac584a2734837da6bf76e98bb2caa06697b9f4b44ecb3c14036fce37e02ccb7450651042d5e3e8c1b211402c04d190b24ff88b76664ff523658944dd5fa52f3c3dfcb9799fa8f502d273deb5c18c48e8bf3329db2d780907ac343d9ff0ff50b93a96e101384d1603c45cbf5ebee10e7ace8ec85107ce8aa15df832dea4d9bf381d1033bdbec3e66e4399c70eb73ff6c3c14a6681f97f49970aab386643df9a827079f7a680a51de998d6a400ac70c8daf44a8e2b80f1814f10066ceeeb34a5fe132dc61ceb38f166b19a3619d86b413b598ea754d26e8e9b3204d06eb114cfc76e40eadc34c31ce496567885abcd6af8d565cc2273971fede9f3e0279f7bc075f07e535b7773347c07748887c15e397778d5c857e7fee941c990a195cb12472571acfb8da46dafb8a50fccb2ceb34d513d313ef05ed9cd79f9b25bb03423b753c135e029eb4a819eeb854fee539f6c0763ec1b23e7b0d151dd0d63123b29e0c955decae496104e8790144b9840c2a3a32e72b6e28044988a0351927be666155f8cf59173236ecb3be5b1c9ff104e358a91615e0746e60524570a1d22eefa1bf1b1948c4043b7fa41dfc514676df1ef95f8e85b1f2ddfa09961186509db29af6178f883e8965b6592ac8a4145a65ec4b580dd3660c0e207e452fd203cf0a573fc2a9ed958c386eee3f9dc188548b02d19c48ff553965153122ba36067a4622713bb9dcde52a495438da723cafa0e80ec0d1282c5bf686ca9b5a99f304d8529a254af0268ce70fef21cedc1e73e0d8e0d5519d0a35d5b8904d9b13b8982b356512a95b43725dc6c729de185bced351ae48f5e6b72f846714c826d4878f264d853464cb1109f5865b19ebdee8a7b7b2a84dee86c2ef1e399a3d4461f58aebe9fbfd1e2b58f0e832c3e1b2fa54b9cfb6e732b4d2d552c8dfa91fca40af7ddbcf97daf5db3d757e94f7366cc07531fc6e78042ed2c54a704542a00268cda00c5a31199f4b92ed76762b9ce21d6428e48ddf6f122b0fe98c8c1959ad3b07fc3c1f26e48f561b7ba6476ac572af40538ebe6c085e38bde200d15bc102d0dde04cea98887d080fe78b7c53603a0268b70e09186a6a69d2cbc0ffd3264c8aa62d452ca93079c40936e03e680a29d83f9f2af451ba072cc2b52e68b27977b41a63dc2c696ccf82d2dbb82ad06943d976f012b5b4f753a81aacb3263f595e7d491e6c87250168c161da2b5a1914a638fdd6a5ebf1c744ab62049243732784415d6d4230067ef4568967137abbec50780c28cbfcd3d2f0dead02ec3eb1668c9f9c1f3bd29ea7e42a18a333cea7eed4af285e5e78bc4770237362db445d51531d2b434e64e73e23ddea053cbdb4c393f4287e871aba92c9addff72a1e46671d1284df71274b72948e20c4f9cb3390ffa6e8fed7946ff7907305af98b2408458074df01c86c21343a7810478a22ff3294ffdaba2a90fd1b9a7ae40b4047e219dc94de1621156f5f991d9798c2095461eb84c2f2f0b87d76c04c5be5e10028f98af7a014f48d6ea1936ad5da3f207deb5625f9b71ee0735a50d79478b725260b0acff56c2214d1fd1035ac34fe11603b157f3a01cd330590b75bee664804e3dd6b34924105ce7025114817c36d159f39996fa97af289b674c9bff3b279fb83c9afd84281f745b0d1020d1e7935fb45b4fbfd807d150a2d6f65eddd8ea9c9db5ec95b138d28193359133140c41e71732655cd1dec1d368f12405e393a6371edc48d0ec1a07a3af2d366f71c070552dfa4a7b581c24349f4a779b72306ac2067b4a1888f3f8bb717a6c91e244bf7dcad448cd956afb5392eec4168da3184edb8e24c42b1f58cc72cf4d1c2fc079e2410f7104033bdb18462cfa2666c284c56f2ee57c84d4314f4b7c440102a66447219bc1ac5b30c17db40dac67aae218f402368350b916b891955edfb98e4714c9578d3224d1a71c9d22b126b4649157e21def53fc8b085059a5c4bba18475d63aab927645ab62b78454083ad21043c1e1ef872921708fd2c4b61707241e281f2b14cf7abcfe1d6bbf282da839f37f90c18d209f3f782fab838db0daa453017a9c7c4b08257722939dde0e3d7fb0c286a2b0ffe276550220f7c4c9c302e55a5a32c6aad16d2abf2f18058f0cc29a346295e391905d44d2b76842fb7648b4403b3ce3994e3e0294a9bc76a7595f404b26ae6b6895af8e0db441679d6a2b2c8e9c295534fc3be13eab0a275f9b4b0c59422b95bfb28cc0e5750e42ae96f34d76ba540247f6e5cdc5e7e07f2bc7cd8831dd7bea8fddcc9d6653ea2732172e719833db2adfb942ff76efad67375beef8c1044dd5dfa979f72263032e36930e49769dea7cfcf23d6a54fb83d15560c3c683a618fd73ae1b58868e0e7163967648fa7af9fa16df4baaad88bf58d1c57933cbe5aa3e5ca742248c66d70f8902b55c0aeb00aa81e6129eccbe253a1cd97b6c1b30962c8f6cbd52e8c224bc486cce0294a4a288a5e7bba5e395af1957819d241df836db4c21c6be1e59deea346186c3175abb31e230aefd3dbf3138f2078b1e915568700022f9dc0b62e95b060082776c47d23d5492b151a8a134ed3116a5433e90502d5c2e2d59fae93e1229f7148996cc32fa13d4fab3b8bcc61755d344bdec333ed01bdc31dd6109d89a048c75398a383046fe55b255bc9bdc751d041478864cb00394cd760605e394d059594e5a47f37ad76738faec0d79bc2a7fcb6efe0d329a62f4b3c511ab9453c554bbfca708614cdb868c3d6b24f363f0518beb6dcbb29d6b6a6cbbf768a10bfc42ed8f55ec69a256df4c75a3c58c2a581f99bfc38eef72a3ebc10fe970f33ccdd414b16020452d4aabc1853165112c064ddb50b44cfe8022367b4639f0992dea1b605e925df69e54a2f0d719d650b3c7e35ffca39d6b3b9e4d29635bc965514b9d2aedf8169e934386096b357d428ec6840db93891a08514235488a82f569ea9f20c8e3b85dd498b955e6955288b70b1851f4bb5e6c5b474354d86a131628eb3726ea62dabd17d4319bac0175bbe10ea39ba984eb470b9fd9074091a7eeb573117e723763dde7d03d3213669aff4b5cf619eb737d7191ada49a3e98a1a15749ebcc48670438f7ba584dba6f08d3ed18f9b434954a722ac0f29bc019903674baf3a1d469e6438c4b2f05c14a5222ece515288bc20e102ad025f4f86bb17fa3ca6298e412a3ea4d1d7d4f3a7e443b0a127a47181f8b434feefb353bbb61ee32f9f43349e41d1180160a56982b7d7b998075c581df0ca4a2b82cadc6c7c263c9043ff3922197673a6d3f6792e4f72b7364e5225b1e86192ccb676702c8dbad9113f73432422f244c45b405e3405cd8f71d040c97dba1ea77d65a164a816676fbbc33fd6183f621a454d0d181b602ead0d3b281bfaafbbb292aa7d034cc3abaf29c0648f74afe72d7780d694c0138c8d4d4d8499e98d05b12429347996313762647a42a2b3a72283e7cf7d4316ad4d89b1dcb9da82bc52522eecee3cd3144e66a23276ee4a4f8691331fa40f7a9e72eeb6e5812ed23abe7bf8b8fbaa48d3748096a499dc6a4f634abe493a360eb3c0303659eb597526d4b2f251a0a74b7df3d430241b9bcddbb6f16b1ebc8f3f94b0c696b070853d0411f32d8c9cd57cc5c416cf0291500e206269346a2617f33a2e7cb8329eea29242a4e0730c9a89e21e4225c424644fa0abcc3f7d9663fc406fccf84d14eb7d2c7466ff50c8b0a5e3994a661425fbb3cf9370179c5846bd9fd351ccdfb619ba2547e107111fb3f155a1aaee35dbc3bde58a455548b713c2170352855d200582e43ec98a0530b72585689f3416695a846533b3010310541b7e7d9873dae0e46b3bc9c797fad10986f4c812a9fa7b79f3c0e5b52eeea733caba591b44056fe8c3f97b709524acc67846cba8c33d3eebaa4f565a01558ae7ac44bf4107f31c8a5c10d8e151dd3d3028463b7954ed68e4b8a81e869ec1dfa2d4f2b5b5fb16210b6826ab0ef0820dda38e77907d9970448c83ee312dc967fb40d044b6b20c84ca13d8b0121b521b2c3f4e6906940413d04f395de79b5656e004986164df94122961ab4414056df4ec2b91532f3806f6fd0e71752a45868ed75b4302d365ea5df345fb2115106418f2043a248ea3a16f2e7d65756d3457fa7e9d563323bf2cf7e4e274ecbb0605984c5ff909d5e9113733519fbc46edb39a6c90041384627554499ca1accf21f45e62e829ad8ade6c256b54269c0732f1236cfd6c64442639b94f94b71f5b72dd6390e1b158a7840e84d1f1a524916e8e2b8ed07fe356c7e8b8d74907c0f9ea580ecb8188165076f1a05f06d564028d4fe6a511c6f90ca4ccecc34be0fac30c6b8741e6ff96ca013f8594d7fda6e30f19887faab3832188962524b1cfe674ae81dfb91fd875f74c0722f44d9e7fb36281d8f3a317a09e01d9e9e701060a4a49af7a3024d20ea5bd1e096f07fd6beb6fcb9c7fdd332df0f21a8481b9f59dfe66a5bf7c58c5d5312d2a28bb9cd352d12fc5ff8f5b92fa7b394e43414caebf697cff1e06372c47a412c99d76a9b0b7af7068524934b6cd06d6914b92f9b975c2ab54ac459a03b156e45170892c2ff45bb46254f7b0fb33567061342f64584bf420203755eaff289844a7939dd1231508f3dee4514bc6a3825943c7ebf613d26a5874ce12682e2a951cd141d2d5cb193ff7bb0bd5ebec3060bcfba3de3bc5c50d1a03c2ce703351d4188c4eef20c5d526a3d97b6bc6059c6362e770169ff7b5e87f66fb30dfa3d475a0d79edc36e0eb005a39d4156c84c100dc3435a9a3bacfa192884f238309bde9770934803903c2d92ff9fd12f7dcdf3ceb0339387d54c30b9af7a708a07b98ef4888288d2bb72dc8bed87948a3b89393dca4ee679fd699267f4e63804ed7309b8bde34013250449fc3e8bf2603e1635d1364c7cba58f4d12d90b3796932c3c7590c746043af81325e1efac65a374921339f1bb2475e2bcaff0a31484443bee7399eed78e09b9ee400903a90d89276927b1914ad69f5725f778b850e1bdf227fa6abcdaabf3270343550b68faf52e4b2d0efd072f5eb4f78b2dfb32322d770635504c5ebc08b7d45b3d58fdadb9881e0f0ec93c352289a5637b5f9ac422986052a86f7675a949853aeeb1690283f525c37ad9ca42eafcf5c9eed6ed64b611bdd0d9187e5617ea414b4cc8be72316171c191971d1db84b59b6c0b37ded944abd3db3509bbc035aa08feedc1cde22c67be7ac483cb9d13660f905c604d31e5d2d414548ae59fdf0e26055a0e06fe19df55fb3d155a06dece8ae8c3894461302617f05b6d44f0e64b80e7e22b902908a5484a6ec7a0e0cfce38d4c784d4a91a00f44cab936bbb1ddc83f879328131791c42de051cc8b1539ee0f47252bcedc9a40d0ac88a06922c0ffd55e3a33e7b9bf48391ec43185644b0cf3738cb89818997e35ec7f7a8d45bffdfa51b9bf47cbfc2dd16ed6690d25dc61547362cd63d1410f5311ca6a0991ad6761c741bdeedc971d205751419b4ba3a4469efd5c2d6e6d696d7ac4465748b704482737de546ad09cac8c7121f07df59071b0dc50fa784fd7c03c5be686c8027fdbe80f9ad0d071aa7576d48143b6a7e5543604233d9589b20be0b3304f7bbd979c969ebd9e1189c492243a35ff6904df0f91b2cf8335cc13bbc6e6801edde7e1b803a00ca438c35255d39f4de8524a9221582ea7f409272d98eb99515a859c301655a1167736c54d4852884184185264edf598ccdb009a3f7353c560d756a5f79ada8cdba56ddea7c6791f864ef3a3c3d3794a2b00fa6683ca9f899b846d5b19eb8b4a7b5c9363e6a8c27ece8dd3d0e012c71ff0f50e10b50e742cd9e4e5880ec55a30759e85a46f83eb5f342786fb10e87bcc25a2efd7fc57c4f9e672874d91b947ffe9aed3c4667fe8da7e4e920afbca1c00cfbfd94d3c850bb5812d225f0eca42d1476448b60dca87a8d77019b12bd10ff5f75a47c50c89458b3093690ba6c9416cf2d4438bc5912765c257493c7d04691192d69f170c7f8c8ccce2ba4355244a96be72760bf38e9b9aa04f42c7b60a614804bec23b551445fbfed479eac67d85310cfc3f53064fc1907cd6b7f434a41a993dabc07eac3166e8c3b4e403a751e54a422da5c234619991ae16b61ac93ecbb67f6149652a21317e0bb38eeff93250c9399bd0a377fb47d091e9391f691331219ffbe1889869b6b97a717de49eb65d2618cb23f951c1574f3f4da046ca88b76174dac34bef1b56d65b91b7827e43b120cb922b5fdd377b94b228d3f9964bb5db18823409077970fd604627a8d6eb1c48d5fe5fdd4d742cbcacc3ec323a86147d12b96c8f1677d0b14ae23bcd96002993ec31ebacc9c6c00534e8fff904da7355f2a9debdd80e68d1a8cd0ae0f5cac09a15f3b929135a95c9e8e602c50e68ba9f106ee3d5060ddcbb8a104fee9485c90dc06d24601af9755414aa8f9de23c7745216b937dde6ca919371ed0f52c5c1c4cc377a1f50c8e473e6c16ca48f93e41601ef29bb3586afb5a83a2e3b61d81aa3961bad6ca3fc720e181b80b519c741ddd6207a6b00a26e8d59a766499c45fcf27346ad9ec87294f886417ce53bd296998e873e71fd930072318eff2a2aa1b3f5803ea603561a028556f420fb917c4f6a3c4b23f3fe203f76c1df43a8c45b3584bac380db992c058974c057896faaef7ab1c02b78ed9ccd38f2f8aafc97d029379df51f66ee12c735842eedf9a00e54443ef179b063b39827aff62c1065c34d3a2517e8d5183dc44e5dd64e3dce92dbc8a474d6bc2a491c21f36ef6bce246c84d1ba75b1d92bde80f1ce26354e5749faa41bd1a07d45487f99498bd09716ba94e1a2b4c09d4de7b5595f64dcf600e10c8d19381ef932f3744a25fde68eddcb71ac1a66d24d27744fddef1a51bfe855818f97c2b114334df9bda59690aff771d208f9e8619e5fa6ddc286a9f966c5517a7cc4e76640d984fa5407a2905ac947eb170768356770daebe951d79e6fada2316bd149abd346e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
