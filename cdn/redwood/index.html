<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d4798bd90b264c62e761088a0bf4879b11a776755db729b687d0733f68d86f05dd1e0d7ad951b81bb5d22ee9aeb24b198446c1a1e58111c32e0b4b83d11c7d1c575ce4ae4b7fa5864259ed418a1ea8ae7ebe1849c063b40e3495432c18e4b4783198cbbe98a883cc525a26e1ef2bd1df4c9458b687c51f81fb5eb682f4669de73c91ed5c21784485af689d2651d8d7c498f42c40c71ffb902e9f85b6aac50484dcdcbe13dce341eb9e6b40491631e8da63f1ac0dc8f3d0df4f4abe1479e30c94d0671df4470887957fa04b65c46338b7823421d9169e0b86d6b05ac8c7e9d698843f229f76b4503d742840358ec509d29a2e65cd76a91c56a5987aa880fbb2be453cfa47b3acdffcb23cc5eb591a42cec76636749da4bb1e5b9297bb79ce4167f0a828e6f6bb77e4a0231bcef8ade3aa4536a4ce538d766c4109405f03f046a8f50fe5f01579e61b7b2229299162cdb037e1cd7dd0117fb0e3cdbac240bbaa0a0f1434a28d4d4992d8585fef9c4112a92d5eacad8a6c2f811e984dd76bff3484ed19bec8ce261007d5b9d00699bb4bb1e1cbedc7484bb5ba825b2d5f2c0bfbbcd97ddb165f97e69c9eade60e73e877196a239b421a46e67502b930fbc222fec6608f10fa008d0bdecd6680327173fe8e9dd6bb608664d10019d0f297f94ae764e398615fa49530ec70b0c7b6d7cb06d31850d4b1f13171f2c92254d2e9ec17ed53ad03139163e6aee67ab08a46fec08cd2303a795b039fa71326f0b348aa65662733985e84208a199e581bbec8405230a941ec320506fb042cd52247952d54e7a1426ee09cc0c51c1671e08350ad61b962f61268c66143d61b6017dff53f3c215ccc1dac2b0ad5e57f2acf2d22fc5a816246274b8fc617d751776d972b311ff08db4e145c6e731b15408bf4652d72824752db1f89b9419603c85e9f9a4b4f9e49fe9e3d89ea4f987e4c06a9c1e1e4f98589e07b8b204e9a9d692fd38762c7a3232525d5f45294e79dd085e4dd47883cb133ee7211701d1049ac377685382914223b1aa555b0d7bc49f95307097ebba27e8b12dc6387569b7f820e271e19fdddbba22aaa9c4171d9bc36f62f9146f0de61d20f43cdc7eef5a986f7d113229b017cf4c10b46a2948f7de574a3edf645ae2290c70941a5dd55b01cda1bea96b0bc8dc9ee00a13df216f726b1f1d1bbd26499adac562c2fc3b1d853ec47cfea6dbbe4b36f0c4ae5a511444b3b14ae0920d4a1c6815f7964f0eeba600f83b94d2efe8bb2d9d3dc3e31c042c6d229b53cb521fc123144cfa2d7df301a2c49bfae31b9a9679375e52d53811b4a89e70bf8269dc76e155a2dd984ec6299ef480ecd8c6e0cdb873ef76b2efb28d4004964614b6d197744f65520ea9b4de36b3ae06f5d6be330b51c52622ca2cdf892db8e9fdfad7b619748d2f56c802770b9c959e64b45245f19d43f596f2218cb34dd6d688ad62c16d8b221f64290412a98b8f1b61561707f4263c9f577e267a35e798aaac2cff9ea95cfe47a821e5bdf010734164790340e2b54005d7e598bdf38cdf5f77f40cb6480f06460d7f189d375f5c132b4f53996ae0974e8c849eea7a5bc20340ebdbe7eb966a036ac62f10f3551ed05c060eb2b63aa1d1229ffbd7f94350b3f0b4c4318925345117522ed0a19bd85f4889ae0a6ec0f7928b9ee7708b28afa7ce5d536eb525dfc4229a67c6a9cd069d0428a0285c82b3f17a64cff7d71cc2e3a6d6053cb12e998377835442228ee1a8bd6aa7ed737b562086453fb50761e0e5eee2fbc878c32e2ce61bdd5bbf35f6edc873fbd6e81ae3f2b60df1af3cdf50b47222f580d999d89dcf275a7d7a6ff745e04b15bac7c02a92fb0f30870150c51520c9ca331071babbe1e82ff0dafbb86b6959c3796770b0e85501f00073695bd1296fc45bc90002afd0ba37e5d36832c8115f6e70f4525fb11455f476c331a27ced0f9fc6c294bde5e54f2c44fa5f09b21f3dfc9d4e1ce846eaf8b321e22c96325eb576fd95ec4b25405b4bb701bcff643b0edea4982c300e6f07db5507564eef72da6a4266b3083513ca3efce053d111d26407cb94a48b8be61a41fd3fc61f9d977c8c65337e144730d8af4a8092ea9bd51c5549ec2691e52c108645bf34bbbf181b0a55a8dc861e073b40c2ab2ff8d76950a5ca74dffab01c595513b2294b5832bd360d78278e3dcc993f63427a3932472912af432feb306b65d666e68b6537bdf319858cf336dba86b57f57d2f50d967bd3e7085404c00273d3715a38fcdaa081989505bb8513aa09bc6521d24b2df2064eca709a84d62d532ffe036a271b269a042a5d984ce1e35686c0462056c1bcf3723da4fcc77eb08409cb0840eea6fed8b15d6a575f7e53a915d2b73e9da63c6c095d5459f21d05ebeac2dcfd1b8157b53069c750efc1c089be57cbded4aa736c3aedcc29084bce7c59b2939dea8131583de29d3cc358cb19d2246881b3af636abb8e16c3bea10d20d37c3ca3e0f76f94a0c8c01e21dea948388e19688a8061315ce30f8374888079c169bc8b65c2c1a027d3cf7b63efa3febad13c5ef4729bbdf9e25c841707a7ca9669586a766bfde3ee045c33d19a4e4456f2f574de0ea147aeb349543ab28703d8fd1cfdad760ddc5b8d0586db465f3b3e8f329abcd50e01d1555c4e6453c47e35d39bbbe8277aaf3e8b9ec1798af9fef2442bdae42570d8fea416a545012e437abd4b279ac7a1e3ff88488a6f2ca00eb75d7c240f84df19e7e35ead0d659da2df48baa500ca66b5dfe86dcd02556cd91a480fb889d087fd5978a6a8a7f854821b017e72feca186c562e3920afcb4fd9e32314d5ab93d90576b6a4e0e83e64fb18e21c487773f890a5accb65584b4daf7010d877386d07b60503651ae9e4644205613b854ca3e1420b2291e8eb616d485d9fbc3e9f3f00c101316d1b6d359be82d9931e538ca495e1c0527c4e79059a74de81ddbed17d8c1cea616fc7da14295018640c2387996237c391236255e2a179677b74c6cc689ec3021cde83fef935fd9609580a254528e708dcf1fe808b0cec289543df8e688973fb791065ea1c44bede71cfd5af9f69d1c8279c906ad9b9dd80f094e7a634e47da8f4681f54b8525024bf376ff63d40cc04255ad4312ec4a8c1bafb26908156740e62d82c5cf50880156e31206751be4c5be03258beb98ccf821bfba7393310f2f10c22c49c92e101a60d87831b411d580a7591f490e5e90b5c01d867ad9100aad6112916a3eacbcbdee339b1a2d863e2005fc3aa3851615be88a21fd88390fa68310973ab0e186db61bd767a1183a8351b3f68c3f4722ffaaea25a8d77e12ab8bd194069c82c4cae29dc2fc7ccb636c33ca9e5c06a7bf719477156bc98394c27dfc5d76b3d4f2e9b8e67db2364571aaf45392aeacd1e1293f78c59541f3c6bca4430215e1a56d72b3f58cba665eb6c116f7bf4442460950849ba843e7f460f8836c72ce387555b3303fe6dd04f0780397f3d0479999919adc5c33ff195bfbc5c3523a53e7c3e67aa6714877b46de98b39294be9d0b2b1fb9d4b743af3cfd2cfa8f60ed1dbda2ab7c92bfc9d174497ca320777ec24d81914bfd1c2dc00fb00bf63bebaa70369d0691e48794f797aa079f7510200722b72b411c757b760c73bf76985c6d1ce5fca6a997a34c5ee5b0bb50b785a54823b74ca1fe9be6b8e4f6df86545b2ee426c5f540472d101d4f7d607470649ef01f7d60343740535d12dedd6929fd5b881bce1a15f6fac96eb78c19bbe4681fd2be09e0dfdd93f620f60032b8070a77de5ab5ab911bd4bba70615a0110fae865b21ba67ffcd43d4145a6a589b2ca04b593e495e9463d36dd99b79375bc5a3a9eed174cb09356f503e323476734434c1ba4099be0af037e5cd650f1f12c41c4e1e24ac670b48fc1fcd94a581de02e40ba8e3fe9292b46cea859bd661045ef7184dd6da3f76337282e1ef1924eef6ddcd89d98b3c64b9b7d5b94056ea81e8124a38ddc70199ca9dc7910d23b193e712aa77f57c81167be7b7c0d9466a7914ad127818bc33b288570740dfc3d457a509cfe419a2eed96567b47276d393f2f097de2c08e0c5af904ac10c4d3a5941f68be02119ac10641615d3ed9846b2c6cb7403838fda7027259d10d4aef70af3af0e3861989fc740b0ecbc4573900ea1baa9ca2547c34d2bce9f39b790ec895cacde9d2eecbbceabdf49edbb45b46fc8759225b522f536f37a2030599d88a4c4067df321397929277bcaa6a25858493cab582f2efe8abf44925807ec9b2d9c99739a763d1593ba7e4333e1a13df297948d4762a62783db0b8d997b9c6f623f7dcc3b48a887ae6fa608ebb57bfff062b0136edea3ed5d4256a7dddbca0eade3538240571f1c757b38e69fcc20423f03e3aae16641bf5240e6d104424cefb0f6efd8b85bd046d3aff632e617e79cc3319e0e33de2776aa5d26248dce665b1a7d11e9df828fdacee181b17004aaf251c1ee526fe815a3be478a7ddaa6a6a871cfb9ed210589422464e70cd2408f143740e7215184af2094c7017e67b0fdd4f4fbda2717d40426301d61fc96a186e8000f78297d1f53533bc5ba6e6084bb6fcc730fabfb16c3ccee8a530dd6f8cbffe1e8a2cff643818c1ff3c219ba3a2a811e01b62e132d87d991e1346b7f095c4810c5614344432321ce51276c59bc3d65256228ee6d492a0571a490b3e51b4be7c687411757b300c831bb52a4022d22a04cf37fa098d5065f88833dac1700f17f9e06f433825bc167b41460d08e259ffb908b95911ea754ad3f483b851c95c34bb358441fbf74ee08135221daaa64461dde4cedb2625b39e9db851678959721ddad43362ce280d9f7f6b0b8e9d129d2320adb55041cc3aebc18c6dcf596f685b17636e6b2726aab62fb004af7c0fffc54287fbe1227acec768a627ebc5a4daa096a300afddd2a5aa6c7a8b2708e1ed8ef9618492d0d6d4e129f7c41dc6d782940c503fdaa85ff25f924a611dadc8892a0c6361db5fde902cf5e281833149a9a0be5ce606d21b7d8440bd9326decdd0aaa518c56f9636bf55a320f32633e3d99068715e165e339e7143c774662da1e88f5b3d9a996a79a7468621198a5ea5572edb1ac727bdb4954e9790bf5bb1c35ad4a6fdb20bbfe513332e1a9d88940dd145b9a4394ddc0c48941a03b3efe84afd40405c75a789eee13aff45f9e32e4dc487483418e618847ea868b76c2664b03e40d6f59c5f8dc766bbd2d2b705073994a4027986d85fd535e5938fa209e0da2023ca918a4703fead9853774f5d6233b467fd5cf5f16d0c73bb610b6d14a38d4a3fe1679f70b24cc04a07f521571f9ebedb035ccf2acc1177b1bb7e364468360eb61bdcd5d7cac4fee0c4ce16efcf935e3c65aa08c1b508474f2da5a3fd664bdf1f215fc49f656f5a93288474f10b3a7cbbada52085fe735d19d8d021e2865091b093c106865ff41d9dea6e05cb8c5685e3a1642462832a508493662d1f85abb1bf95d83298662da117664f04e4903036c633a67cda1462068c58a746a546691ee22b79938d2e50eacfcb7883e4c49b690403b6fc64c4e9ca20bb9e3c90f1498c101030328088e1438dca77c9d99ba089da69890322fdd137478b993168640b7373d5672e7a94bb085f2a44f478c3d174c841726c89efbaedfb19ccc5db261200414c4b43dbdaaa98cf46e596083039a0bde6fd1c5c401732ebb64643760679d601c3ac8358efb65c65ac9197e62c3f15df28ca0096ec6bcc3acd3280b1653d7e74d3dd04b8f25dc1a49c7d5ef2a4c6213c87f787299cc7bc8c3110f7811a198820b8877cde108bd6b27bb1af6c66190c59de72f7ebf6f5f45b2e1b8a5937c2f3c839b128d84643f7a79bdee5a577564463bb9cd2371fb1c2ac84da17ee8e38ccd624407ebc372c094b091d99374e10de0804e0a53df230e694a54f5d2bbfa490aefe14e3497edd4087eba96aac0b7700a1fe9254d194d728f433ddfba348c22889f2dbfbaaead10d991831a2e8b321a23fdd3cff8a28d98962a8715a2bef3bae5430a7e6540e969a3d5a81cb55ccb361456f2421b391c93bdefb1845a08fd300b91890902149e1c2f8dc8c868a2f6978ef4c1e7ec5e5e69f78ab89f5743219346772b96118e2b17072b9078dcbc53f5b2f0c224e7523b7e0339c61afac84531b07649ffe2b689b13c53a4ae06ac5bc6d0cfb9377cee44ad1bde7e79dfd85add9772200f485eed092e22553c7230fa1dd7fd1aea58a84d06208380a30ea1443099c9acee7bcbc81cc93fb6614bcc292216fa57688fb6df4d09f65635a1ac331eb7363a68bd466e57808186ee8e5c47334fdf280d488c8a3ad770be2641b3bce21b6df562f84828e918a52c756f1f75055941888c282d8f32b1e9e9f062d924e2f476816d0b492b7b02f182a8d4580623654702e56dfc275fadf2468f7bc8ab914e917b021d452204dab5144084588ca49c19793463d05a7f0d31d79e22d3caef66584e5345fd2f7571ecbb5b0bfd15ee5b707d78a954e5ddab52261c6c3c6faa3bdd5837eaf5fad8ddd5e054f389942856ba554840bb9ac0462e9615d5f7e0af4f41ecec0421fd9326729db31b36a7d50720f13bdfde3badb0ced0daeb55f75dbca60e46e1271dfb9935ed09f541e93b8dbbaade3f9a56c1d4bca3569248ecf6f342bc110dc349af4e6fdcfa62fe930af76c2eda3aac66a8ad820c798bc77767b48f2560008bb4edb875a428f0016b27aa37c9ea76e0c4e735701bb54a7eba8fc033fddd58722bd192e7741228ee13b830b87109d307caf83f414d5bccb3165481bc531c0867b9fb4f1b4b6ce66cfdd08cee45150d66041048e7216ebeb7ff0e52ef40724db82f4ddbfd2527b64ebdda7762f12856a246689ce79fe96a0e3a9f5325b140c9ad3930a5e9d533df392431d74d22b76ab8b7c7af08498d61db4edd7588a91051519819d465aa995d23d40c427fb23940236da0d93357387cd83ead391f31f895ee645e5952a1296fe0e842095868337c8cceaa37b587167bed52e240f0b4408f9b14155907cfe5160aa53e489ae93050fca32c1f35f96699db08ded09db63080b289eaeb648a74e976fc169942e8d52b065dc3c2186577155677098fc0cac9770dc0bb21d7f5d7e7aad9761b08de780083eb0c2b376e74d8bc78e5b999508c4871a35e15819e8ed492c6f1a4ecbfebab262808251722bf2520c6dc5767b806b684fde8c22f9be0b6211797f60982beff60fbdb0323dedaa045ccf7ed6a0a6cd72b13929c46c6c376dca256ef72bc53efbb6f2288f4755473e84849f85da20614e71ada266306ce7f9301716f23d5c68dcb21fcb8491cb734213726cf0beeae19f306e6884ee93facdf1b4c21009fce6ad026793c7ecec85df532766b57be88b66a002f783917e90f02439f5b59ca0a6fee1a7eac70bc802378185928dd585ba081a95d267f65dd62a6addc70196be80dc3c124e60b467a6cf41ff088f6abff6a3385359ddd5a15380a44e070e5addc453604b0c4a9c1954df09e71711865d082cebcd99efd1712087ff2b5d686c24bd27bcbd69aa73dbfac20be18e8e07bd93784df50934492423d222525a21ab2f59a0115a84f1a59a41a16d4a7d8cae539e0c68d4ca77bd5aff50ec829ad3c9553dbe7efb49fcd55df2bddcc4678635a1971a33188c4c24a41e2a9e9494e8b2d78d4c65fd213c284a39f9390a547c9dfd8297543f0c5351ff46c8939006a4c2880a391bd99ca31b4fef05abb3493e665d8de0ed0be537d3508d96ce5985d28fdc8bee568dd09a7975b83a5e04a80e6b73be9a2d2c648738aeef8cc10a8590710aba2bc693656fb20eb7af20fcb9b62fdfd8c87cc7f1e3925a173912bb37f5e3d0e4bf4fc6dbb9c4f767b8031448806d6d80f3f7ac9de0f747f5bfa20c92210c91a8e384cca6accc836e1fa117f589d451b91b8d7f85a9a31f8f72d1e7c354df4bfcddadd0d11686cb085d6b97eb63a60929795a855b99f4676151efba83b5ca7ae6c88f16e66c15204da3019cf416514ff9956724db7e6980855726bf7ccda6610577594aa4bc3c32376e10646878bb5bc2dcc34b73f86559de3867c32f66374c638538e128750bc3425d0cbeccfbbfe790655e135f58edea98371764e0334769572b4f4d4c99dc67c3dee81bb785db709c08bacb99a76c4319f4b37e0fa4238f1430b58b656a71c45ab6ac35b8f389279d9db50b09eeb31f49f96af28a32a26e3514eabecea9acbbb53c9606a47e9c11ebee3c07429280f5f326fa8d64990d5d04605f17e230c8a78579c39a3e226f30e35d8a8d7660794237f62d17540938eb09e6ccbf5ee1775c217af1102760debae642a9409c34273d4eb58e33b320c5d52a0ae83f880c9733af74a33262e71b4267d18add8c4393fdd7e35287f60a1c0d2a7d4eedb37dd022766ef1003e245a6dc7830b96eba5c4f481b0b346f1f7d7065a3898f685bf9886980838219d448aa9b75d3bf0a4431c528cba86caedcff1fb7c74083956581c06211367287be675b0076e5d98450697c4e8e3cbb69b50e9e9dddc7fb6d6717e829f750d9fdc7241eae36a7f9d00914742397dbcfa0caa9c402c65270a0093a72b74950682105205b0c4a2b480336a91395c6649680ad07805ed59c5ede5b3d3398c47b3a08222a7abaec551bc771148d4f1a56bc198c3ca8bc5e6c300c67fac0381288c466da3c36831a8180f3e5cf72410883cda3f906c042e9e9079090a1f1ec2909b4c131613f16747c494f81d093f7825d062a0520f4111b165b82618ea60f16ca8fe1885299fa619bb341e52705d2ca7c264482d146b7c6dd87306d9c1e465485eb7869d63a95a732ef5143c774ad1ab379d95f76d7cec2a0fd9599fbce9da89cf27b973e002a11b0e48ca375087be9592f6714ca6ae0ed362aad84c86f4429fadc1a5ea390bb92f7ad1d0b08af40047e7c64b661be39fb50aaeb4451f0abe63f715677777f354d2d412a29681de0aa4662fc2133bbf9c12981661bd7d202eb8de897c323b78ba839b5174cc3c9d6ec4b83681db0d298380c3642fc852cbb5bfe44abdff90adfb2ff476cbfc4fc695e1a8fe1eab8dae02e55b773dc13d33d24b63026704ae4a559d4d33556e825f9b71da64df3d20ad7425a2b5c376720721078c9077624a566383bc7895a65081333d5b1ed24c197b007f46e81817885e32916807f5145c8a06479162dbf28fca62e085c4d5887ff6d1439934f595363e9ea43a2c9b1b953de605e776ec792c850a8ca530b9448e9fa3216144e665912f7000453207d838cde21e8ed0948bd87dacd4742486d65681aaa8ffb18aaaafc6aa4d5c18cffd00b6920db06446e743769365aab1309270db972f6089e668407834507d3c4543de7896ca493d0257ad33bc8da320f7b506334cddd6ce77391b43745b9458319fad35708717e149a825978edee9744759137bb6570d657ae20dbf07ed9de3061ae391542d5ee734eb06dfac1c121c3e1f1ec237f6259f4a06ad87613dc8ab2d68b2871645fb12b6aa8d36aa3bf78ec3c6010c451901e99e14e86c411bf3eae15b38ca49150c934932b1b989c900e38b539964cb6180d4fbdc41d5e930131a2341ab22a7cd76275888a51b2cdca529388b469cb2eb17d748d20c818cb00376bc62f11d00da8a9316b4524cb2eebe2d96a7e0a6f2e86197c54203bf2fc5ef5b1da058badf26b8d9f8373182e139e3a8ac7190cc9b8da45beb6d079e183530d4ad4c98936b5e48ec6aae69a72f6e33902210775b01e75ac5ffdef6b225fa132f5464c945b2aa03330eb2dfe43aa1736af10ce3d2554f16302f3e41a68ec2b0431dec38411f3764634a78fa0a103acc9e8f6867cb0bf5b411ae6092ae11b720e0cf4abe9d954497285c98d9cb9300cc2b8ed10c44f3f8f4f8ae3074fd56396528f66e1ebffa50c4d4028c9e9276e392783fc31f313b519671e445d1d6363de88e788587ad569913bcfb41292b3b3836445236e1007576d5f0e6e31ea2d3a1b5a3c90c8b305471ebc74e6f5163b3e6288f05abc1db43427697520727046892ff72f7ebef6d7c23df82e305ec383af56fedb8dc245b88fddf10f9158df901e1c1db3d1bb6c4c0704e240c593cd1b6414aba12c9d70ea5c03f8a0d043a146e771f4258d5d1b4fb726d8e0a93aa2487443e29f82e0ae3002f9f78c92929ee5cbda5a9411dbf9d9bd6372092da9f75df490384a0fb417f2a23ce4cbd82184d6917186651128244456ca7eecab9e4728b31f1bef84b557bc5acf4ba0eccc0b5a58c633e0e0603d86235118226f28e159929d9525d12528dd7fd5b28725e5400feacd342fe78753880e02fa5b23037c301b1cdc699b9fb81aa307aabb4de747456b5f7374d29a779f89c3550d3f538c1dc0175bef21bea22fb9c956d534144712a6377fe19d08fd006e5722fa070e5df3b76f8ca40090e5cd148c257a2cd2c20f6b42f2d6ab5f5b2a84fc44eff10dad3b65fe7ed32dd90e1f65e0ceda10487c3d177ba3776abbc5c077433007a8ab1d97338a352bf7249897d12dcb62ea404954504fff7a64a07f81e88f10baa7cad50b4e117ff7413d9cf7239e915506657a9d771b927527e9f1a70239e16ae9a82efb77d37ad576f9864ef2d8b6893efb46d8884261c80d492d0aaf8ceab4c261bdba33c0d7dca9fe81e7f64aaeddf429896415da27c99f81f0415d074ae17b5b71039c7372dcece93087f4562693f5b0216699dc8b1cd7b2b20b15c41cb3ed9ab9179883d1a62e02f049c33006dc30e290807ba0033bfe9e47ddd18e5180df78c64993bf32b1f21d5fca2fb7ada0d67f8b3268a20575ee0fe060433929fe3cd652d9bbfb7eca6402504c26b9135d1f624d57b15cb9941277f848a84d76bfaaae8bd4781c56e6759878fb6bc8a8ebaa916837abea19ddc3df874aa93cfe652fe9896085ecf70f84c483edd13d0f224267c8e4227f1a45c2a8844f05707ecd239d47f2b144ab800986cc2e9f3c8bc20e6d10ceeff4e962bf166449bdfad346df99c9db9be2cd59dd5a8d531541c038191df6e7199e1475061be8f8ceda5eb94e798c0afc9e673161f3e35ba6ce4bbf987156ac489ea8202c0d44b05dfb363f8d743a57965ef34c30b8f3f220b9f71d21a66e7fe947c5133837ad5c630d5cbe453c3612452ccabb77d17b084141b79e7bc1ebd73a90644ebd64a3f95fdd64e8980f4d9eac479fcbb626a2e00ed799112c7354fcde3d7ab9fc54f5bfe0aaf141c89d0977e82ee75a4ecfb6270c4458be488a953b251e4cf5eca5fca17ad590c7b2dfcaba1bbb9c51461c5dae0846f7f00fcf4110e07ebc2bab200c08c3e47e9a5c1c6a8e7a34e4bfc895f4efb62c1f5b1cb7e3349aa0d50129a02e7cdd5e9b6e2f584ba9dc021ce3beaf059f9a01c3e0c98531b6138ce1344b119bd913b901e66c977db0a42761739d7e3c15c7a6766c1ce4217715c84c012a4d9e1b32df1db009a73dcda9f564059468443e91f3eb9f7448fef70cb9475885e9756c04ee5416384647e586fa2b40a0a0d3781985b4f1b8bcd41ca78142fceccf1923111dc0068d9207f5d5a1599bab3b6afb672e28db67d83aa93a4a8cd57623c1069beb40dd05d7d57dcc8e57bfc52f1410334d4f3ebf16233fa7f794795ce884d418e5ec697205726a66d48b10314646516cd0ff14475c62dc92ba1ec5adcd803d9e2468c3bc485ad1b628d028b549c66c10acd8747355746315d43d45d7f4701f5f40ac943d7c4b083e8015b715b8e7ff121a162c462c5daec04adba3854cfb078b13560176ff9440a31ff1227a2613deee6df9ede0868e313f026350a8f8e69bcf278116076595405853a71a034f3a9ef869867fdd59e15fdb778841cc684c1f166c15d7ec995403c8b229f1459d873df3bf63fd89e9276888672f592177ba081a5d817b78e12f4154574f2872d08546744bac78a20856c3f6b71f9971b315ad5aceadeaf9eb56de50a897ebe5164f6f8b94c6b168e5d52f1b7857fb76e8ad377055808e1dba8388c4753c5ae3eef200541d48e26f9f3be3596b3796dd8c1ef15512f2f7c42c8e3a423a779e5c5607176b50f7ad59299148748aa43c12de8c0103f5bdb0a7c61a2d30515bf3179f71196fc38865afc3283e42ff307114034cdc7f6aad1ebcbfe82c8986a57c95e2dc9b8fb7598d4328c289c13bf305b0bc4f5b39d6dcdd49c1186a09fcab84c2a06140c0334d0bdbfa02c643c66fe5bfc54a891178c934abcb690289fd1117ae22e426dbf06fb8138c7c0b69465e3d8009868ce28e1448d64281a7a9da22a153727505d9cdaa17d35d7c28f98b67fb078a3fc8300c7a480ca8cb41c18d736c8f169a7f2b4eec72dcc4fa650cc123fac842165ed27330076680af5821ea762fdb8afb30c638b37885e2b3eaf247bd489a24049e8d89ae4240a6eeba90ea798d2ee03f84bdbec7d03c9e60a1f47b0caf21154983823d497880529fe06a02e6426fb9a6eb085a205c629dbb0b1679949a8c9d5680528f91a46b1cb84aa82f954466b1dc907396405a4bf9efdbca97ba6d78d461af693d7b463ef83b4f4b7aef551a2ebc8c750a8a30f4f78622ab7b7e6c83df05e9bbd7481ece05b23e7e5329192e8487eb910f6cf77a02ef473893ea3a02820118fe359112ca84680015665afeab49d0829da6c62a7a5c76d01f7dfa690419432dd603ce615bb7c44c06698b1f48eb8ea83b144840a92c148d3df13645b1d9d49d6c22d32488a3d7d9162277476601eb2da05f5231d3050d26fcf15c39aaf5aabbadd1be7de53c82ffc9467d33876bd6d65ce881f08eb60394e6d3153b2052038eb3ded52df74b30369bd892ef5f7c40ee9a6676006c90fde3598c535c88aa79306b55ed2220844f72f1ab6298b4f54f62ed6a9cff122254ca52884982e352b3e6cf9bcbadb5365929a4eee1152c9f5d5b9ae93bd81f12047fecc79a721ce9f83b7046026730d9d1f45819f856a958023e4613b455ba9db141064dc63b9e58ed97a9d60d693c12c715b7adddd6c26a392654960fd7db4129debe8a6c2808a1f1585f1680bf44dca0af9f3bbaab2baac742296bb8701b5a1c1770a72dc0de24c81e65a5632c91e9ca95b90ac4e454a3254c76f8d1c0b691a20a883152e396040a1bedecd96bf33cf098db84faedce10f92a0da1926055b8a7c9c12950bedd873df401070d22f525facf18430536181b8e07587bf6a25e69e3463a7b5481f843611860838553dccc5462188a3eb7df81cbb11f2255d721c72b372706012b3bdc63a8c4a65e1547b2008067295b38550f96ba4bc6bf6f6d92630caefd77be8a0d635581315683e0badc1a443d989272e3a118e0320edf34fc4b5dc63fb5215b06c88a90223305db8bf942a8700af2051d6af055c3964c443b8f394d103ff973f52e87870e83e5ae1dffa510a7ef36cf8f512b17874f41a085fa674607948da98add91ad8de8e49b233f308f908dd35818a6855fe6ab5c576f3f0310e98ae9688c347bc0d3bce112b8913e6eeb1fd08c11575e1114cba97b261262a4d405d40b7f1066c90a0b6ae304ca1bae562a2dd950061cb0eadf26041e93a819865af6b643e0cbc050493a0be8d087f21621c3be1cb84af1e877f35560bd158b932dfefca70fb35d320210d8a98b7a55ba127c19e680b960d1c0d315c3e6f705d22ac88934991bbfd24eeb345d4644a919b05781ae916091a097f8fd31850c13ccb1397c04ebbd051f045e2851ee391736e4cad0cb684a231ca96418f7c9699daf75505cc5eeeff5a22f0b913d1b1c640f8ed373f2f9d59179e45dcf0e5a7cdcebd5e3df57c71cbbc27525511a7e0f4505f6229195bd34aff51f8eedb7d898d38fb01f0e3ad75dc21f7e0a0ebe383ee44021c701a789d53ec74f2fcaf9ba74c81ef91e133980220b896d006546db83d2ad61122b87bf1f9e40c21ae5f1866d539985ccab191e9f1b688072f2980aee866e0fb4714ed3c2a03236973416da059614844d3a770fea5dc060130062b2bf383c93e06dd612e912e4246c71b27347d1a8937eeef1f2362d5b2878862ef62a85258885e668fa257057bac96e0e6066d4dc58dd5cf100f559a6293ce345d337191367b7be2eeeba03e519340ea825ec17c1bfc7d98d314d28181eedd74a59bb3afbcb7a290b95cfbb3f2c9db404bcc0fa34df46916ade38f31609a4e5f631963960f44d0178700addcf32017dfe4b5fd1e3c6ecf26947ec12a534721649841690bde019e6114833a9bbceaf80ac79f123ff5f3b49ec8238c3974b7024e97534b68be9a9260c88f18b6ee5b1f03915b9b2f0bcb613b5939ef2335c6631b28bfa70023b5cccbd1247b5d22a363687df548b4e9ca3c215f311ab1808d504fac1ff4e8da0183994ada19ab26225c1a02ebdbd4b30ac3496ec9f5acd77b9a73062a2ce604f78c138a7a933c46b829c72f8461eb670c02401285eab1881303b804be605ff83fc3b8d3b0f15cc22e04c2b41525cc080aa96f2eed027bc204eba7583d43094a2e9fcb6d299d72449f3fe7ddff33a1ed2d9e7cc5dbbc9518c28005c42ad21edc8049566a29650fefc924579c79c8ae5da742f427a2ac929a7b95e05fd95b2a026caa3bc5afa4dd2027df24ca0e7e4da385f81b59d40b2019cb5790d6716e6319435ec4be61474621c59b0b309abd53c5f7aeea5ed1693e79e29cf637d6621826fc50a7212f4199264492179feaebce074e4127968df31a1359017a953876951c99b82a84d10244f8be7ea560cafa9bc6f1173194f7642b9ccd9470353045fcc7f96a9aef127b7564a33b7e3eab9cdb038f31e37f0a2f88732cdb93f9983d69918c30e18cfa5334fca5ee388b65f0d34a71154489c15cc32c38b6d2b109fc641e26b4059e3f91ddd81911de737b1587a59a273d37d945c1e3a0955872c677d46ce59e1182cf8ba0fe08077c37e280fc8fcc7ab20e16074e588c4be2da9f3db6607098f66bb6a68390e2ff133a321b6eb9b906e30f617d10d1843cbf53ec075c8994727ffc257e0b40e799f9592eff8914144cd984c7ef9d269d8281c8d5b03a1af74b43a11b53b51097da8f11dbc556194061e9b7878dbddbf31765ee5d2ec862f4a921214e8853527db2faa879fb9fa61347a9840e27278f9d073712640315c7b4d3e9eaceac39a4b0b10e6cb690a9cc76ecd74ace14b97d39f93fc05ff989f365d0d098b1e359445d618e4193e5532f2d977e675c02252c3aaefcfba84b6b3e93b6df43d335668e19c68554ca451fcaabd160dd363caade6fd207bb9462fe9fcd30ca63dc879dc6f2d5bd3fe3cca6f54d948d4e59f641e724397ccf760fa928fa423dbea58828c59b45a6f64cbfcd64b61e0162430e6f4e16c4f41898aa4d530939b2137a90115ebe0fdcd8d5fb2536d4809a7c0e6cd352d71db0175a4b60e6e3277ea028b9255c856a04c5f7666afacdf13db0b593a136376e87add9dc6e0b4e4309b4a6bea533f70a184492bfc8fb0db214f22e1b5a26ecb56a40f0fa92e40af73ec86d524d21771f46f2025f0721d8811df8b57dafbefa1be6a6f8cfddba4c28911a0bd9c36ee5637f33728b9f1cb3b2c687f7571601243c5c6f5df2ad992d0f51cb5fc81fd239203022813369a0059ca1dbbbf7873c84222fbea98a5bb1b63759535a3e5a02c968b8bae9832a55a4ed1166b10ed93402993990931e684f2cda1d65109f34e99c1ea21805e74b89040aea4bf5aaa4a6f644ac969f88ccf3f6ab9ba9d2dbe0269eb233b478fea82c4edbef222fb7eb5ecb484a00a01f52b0b3cfbcc4c7f295a1f4e3f8a61224519abaa6f70c4e2b6f3dbf1ead39f7ba202f6e306de9a2ad0d3156d3335ca34822669fb7b80fbb3d2f39db252bb952d48f18ba74b162896aea8ab04bdb1953f20f333f5ece5178700d0c5f45052c6e958ec55652bd8e006e61bbcd9bd81e9de7ef59b79d1d5fc6119ca07dca115dfe5ff94ed0efc39ca08983300adfe9e18814ef3510929b3a18c9ad85ba79562741206437f2ee55de5cf13a0a692986da4d389885323ced0cad686999940a8135e4181961544059afa468b3cc9412a9f52fee0508178b7236bf059c06acc76f453368b85750ae30ced41159237b823c0f891cfb73acb780cf96cc8f6977880126fad64f0e78aed8a91a5a64d7497236f107559dba1bb3979461508c74799e8a74f090b9d29bc23280c263ffdbdaa18c8831e5530051f7a9c24026b53f9472cea217b0bfd2e31f964347fbc84494ec8b7dd96e025a277a21235e00239a6a7ae4bfa2d4b6be35de20a1f16ef1a8205986f90ad2f5b752f3678dd5340d1d9498298c38cbffa263726066662d537f60808ce95f20328bc4a0d532944cd2394e58b6d80155c5bb3bf04a6ef699f02dd4037cdca52c02df2fc5c71f1bc57ce5c9e5d50ad438bf9153618fd4f25d103f653efcffa20f9d76324dc0e4491a8fad07dda5637b75ff20de157eb20ab78e639942483666bcb159caf52275d75f7c992b39b408d51910f31de6956f286920c36631f55e6a90cc7a0c2d06acdb429af2008fbfb377f334b0b4d2ffc665893c51b7e0bc1277175bfde2651b2b9aaa6134960f750ae282b5ec33e5bc751db91213d70781d3a6267440a70d918ac6091e7fbe9465a5e6807b4b98684487cfa2d4dd9f44911202127014121127f72a7cf2d64168cdaf501cfe1edbd9692a98111c6fce261d633d5c97d5b3107a785ce0dc6d7c636353661a61502ff28b4026d030df553f1699ca21d80ea44bae7200d3c5c9098115a974adc647d0864e8a0d1e9c060b44e78feda7390621b8f38ce02add31f41bbff0e1249fbc2c31f86799d8edf70f4af4a204094a0bb0e1d3e6e5ce2eacc7efe2141278848dbb62a928333ef20f02b40ed03d88f25c27835e4996d0469b0edf8219c98c0898b1ca9a7757206fb1c6ef9024694b3fe411f94da06ccbc50084f79d8a78a1d57430667e9a6343914aa32ea1249cb9e57ccc4923ab839c8ac9eca79e71904919818d4db7ab90ced8fe9f264cc7c520feef488c12adb1883f72d17cd6a565ca189a6b180a80d28091900cdcef32834619f6eb42825c112facd7d710a6d48984cd9c7d855d14ff2f97c98f1f25250b8b6df9f816570a6d53d323211dac423cfb80fd1aacd9625ca7d9a44b4694c48c3f7a8c0f0056622a54fc31f4d748a5c4fd21df2db3588f01f0b653657ef552bb69de60c763df69ddaf4f8e03e084e5386bb8b2d9e0c5379226c719496c186f6a70b2e237f4c392b0fb73357d70deedeffe87b87491ddd1e826b05e27d4621c09effc6fc0048a78ac980e8d2026975e56d31d6e950dd24219c2d24dd3d5191bf170c17da56800e4d66ff504db66202b3625e86b977b4baa81afc859bc958ee98aaa9085d8f0f496d3170088ef7d39448fd2143fb0c65696c699722ad74eed90f2029835d0810cd851ea4b4dc0c130e46aae9cf053f1e79147c7651e68e4e3fa473e76db158a2fd81500363fe7b548e1f9b3990f8022aaffbd03ec0e1c0c49e44b2fb2d39d7b80e42b9dfd670590cb5919cb27811e6aec831fd4fce26d0c30044ec133be70933bf3f62173391665e32c6d7ecb190192ad222cad5badaa5fee12e098390bd8973cd95a3db8c072880229ee9e99001f3b9f14069ea3b8ce8e7462ecd4f9fc70dcc61594027ed9dc62a6abf5658a4d3de5319741e656ce8c6c1737d3ee270a6f4fab7dd62911c35e325dcaeae21bf9a696edcb4511b0d79c3c632544bb69c9cfc37bb3c9a8d266a4480dd9585b066995fba7b2afadb0fcd3da982ce96a66b29428904a7cf17f80da42c91ea36cdb9b2dbf83eabc879aa5c44993cafc2f502799f43bf9b591454566b0531636cb418525771f800a0464c3d3614c28968abee0c5e142ebc989c31b14e838245832151a3fab21f264d81c6e81369eff985408123439b6f718fde339b6c6c48ab80f945d4e1cc45eaa26e9d8036ea759b2177e97cd262470215ea8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
