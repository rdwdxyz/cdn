<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"523960ce0f2b725507e3659750b1e2b2847d55cec76bfd133eb8899c6eca09ba614ac25354b1c6913caf6695e0f79fa162dadc93c3626853981bd3cb16a675a7e8b5c34cc39db143faa1b3536f4be7817665e7810f1a1d604ae42ec4578a3d14f3d965b856320c471dffd3ea54d7b7f3a56d974738899b56cad8ce19c99f63f21ea34a07abeba200bfd0652aa0168b29983bd1758352afbebe29f26a26ef007519d8f77d7658eb6fb6e6cff430a803aaba2686571196afd32433f833095ddb46440645c6d03fd31eb1f109d2605474291cfd776b1a42aaf02d593e5871ddbe93c7bbb3a260058994c53251fe256ad6a2cdc34e610e3d2874dc392c6a6c275c8fcd09faadef71dcbcb7dacaec19e5d8a173692f32031aa13109dc77a6d789230962a23fd6a7d43863065008c6d297f188a8ba50a9ea227d7c727cd6e364e8d2b5bb320f2c988f9155444c78d2a10522aa2e586a91420e7c966c1512bb61c61f55c12b2f1ad0198a72f83126ddbdf0539ae730586c5be8fff3b08306a509a2bde8514bc1a8f9677d9a989b34bc609c3dbcf8f860bc27add1a83a5c3ea597fc4e990ac1a162e17458e5297ac796f4062b7db1d80d003fc2583c60e50980641a1262015545564ad8ee248a82f8e7869bba9d2e87eaeb9aa397b8ef00a2c8715fc12aeca47caa9574e208a6535b63306c31e6acad9825f42d719022d6ffc1198aad1f7cd08e2cf246fa6bb6221f971191650515eaac70b28d88e8b7b1f70f6d937fe57784f5ef3de5c29548f201de9226ab4afa349fbb9ad999b8e1fd6c43db4de719e7e2a311e1c59a9eb01856c5506a6c59e34253bc39185f32e472f9fb3b6d4f7c130144112fc2bc2f583c4cd10ba7b6dea51511bff6d3b243be7fa85580d9ee426693421b3968bf6fbb9fc50f792ce75b6ee167d18da8364e514bda53a750faed4c6a4d2a1c3cf13d922147eb7b3513e2ff978c596901721752982a0df106d284ea7b8a170d47d2349d4f6a1ef8450ffe8a8731edaeeda9af20853ea79cf36afd6341baaab5d4fc42d39ceccde7a917812ed9564a886e6808e9b2d2cb371f1e445c21e6b2de94d756b12bfb8576fccc26f014654069fada78102634e4c6e18c30ee8d90afb622f1c5ac6776aed0ef6b2b720e6e841e5123a2f1e305363b66e8b5c85c819bbbc3d95f72acb78c35ee8372e1412dd6ade30da1e44d9ac640d67ef1cf8fd26530e65132a56bd73aa9a7c20e39dfe73cce4b5f71989265945683c87ef88c7f3e36cb95e125508fef7cd0cbbb83f2dae6a0651799c47528869fc6b4859ceda3d021e04f11116a1cdb622b37fdda21a4dcfb86c257bda7177d06d110b7587cdb95ab3136a5bd6d8aeb75302bed9f7947a8d8731b498738abaf617928896239fd51caacf7884bbe0ac1ab130d1352ea57eb64a2f101b9b1f42ae2df9749394bca4ead40bfaeca8e58fece3cff82d7ecc64a935a326e64a56555a72c57f975c907b4b1c90e85711b929f354cbf7fceb8c2dd7f044ce6b68c0ae23746ce94a57aea6f8e6c3902fc5ea1b16663f615fe5dc36b675a08450aab10868d8e83b1f98ddf6e1f5fa710023a2798dd52eafcedf94336dac5f02b7c2fe29393dedcfd84c4a5c1db8473bdaf86a1764f2a321fc4ea6113bab67baafc07c87bd89eb03f67ab90edde0d697450b827c578293a9f4e47e3d88af69babe2df396b265d4fdb51e837f1c0418044a59929971e177e443abec2af9b6c6d225f5441a2efc4a4bc6a4be0d78f7ccb0d24aa12272f7e2ceec84c610b0c70128b5fae1623874879d8a11f123bc0b0b22408750505dd2161a3b5af7d0bf8dccd8be715e2507ef9cb79e481cccb220d8de13513ed31ba097cb668aceb6c3e11eb557048235fc7b5a2db9909f3649784c49011c8e5bc38428366603dc985244d0f4fe9bf75ede539fd12f092ab476da672a2a1ce0ca5e72905550f266d33a0ba32fc314fcb1fe77594f224f55cb50c7338d443e637f544906a4b717c17c48c98e5fe591704d7dcab31f78d5ac5301aa777e1c9d54ccebf74b0d4f28ed8441f791a88b601770fe91ba3dd1e5ce3b284c2aac8f8658c00e2d3356e41f68b4a6c818932838f45dabbdaae50a0f9816d29801d9df51e608d458fc82ff77d7c4e9d1e05a7e15945258e04ef9beb99827e1ecdbec5d8a574490ddd504a4f5714eb875c6b394150fd31c4d862edd1092ce403dedeec28d876d5ea9b90c2f33d7b28f784611c827c0707eff8fbe23a564ebe562f8d6982ce9dddcec68411b3ac09cc23f7b515bd948add45b00fee55d68b7092b1b18b06982922d2a288bf72d6f76346890be63e9f6de8f2f26363d07ad4386ec000a3a81aa6b95e6339b057c1913a9b3e17779102725f5859422da306e7fbf1db27f77d55c7132d020afc73eda4ba13b8a9ac59a277c3f6a7988452f1145465899c6f6f3450585ffd513f29538eba84d2dcdf5c90a093c0a82464f8974a52f1a793a7f8eaec9b31e7d6c23cd9027f565faa3248e84d51c4cb57f687ee4bbf800facbc6ebed9bf50db8871e7eeb3d88f07969efce22272dfd35915970d69528d0c8cfc162f332f77fe21d6646976f651de8da673cf6e9c3ae8b4ca7660838d7f55a96444dd8efbb804c30a0cf800f1bd1ba7d68d80330799b9513dbbea913225e655adb72e120b39789677c382df45a6f04f5042350a940fb4e3311e27ffe8466865bf88ab049d9fec1d222f551c0bd7fad3ae52b7fa5d838d4a75891861455de57450c52f1012fd4626116215eeafc1b5238c59e8669dff34ea80155f1174ac9682a185cfcb209cf8ac95595835640734e130b038bd84945a5c094eaf60dcfd4cba73c603185597d77b458d17ccdb1494ef79d7923c52498b95ba7cf565af29ad44e8b7d8519e1f9835970e2ddda7506bdbf4bb15dbe3e3321372125a3daaf5960f3eadd55e11ff2d03d362446ca9c294139231ed7130486d8b6a7246bf2e7e136aad74dbd2fb8d9fa1e63802be35ddf61cfad0a8f1238e63559a72c76129ba41771c2ea453844edc0da97031abc46e171f51754816b3c69572fe75965f8d9c8e7628f61b010820402276c746939a592649fb8a60dc6576b24fd059cbe60c90f4069c14b80033b00c0b659363222c3492a0df8761e54b1240d300290fc6457630330cf816efe87bbd088f6d878bc21d93655b7df8f2d8acafd6b32eaab64589fee7c71c34b9e456e6c27e3b26fc1042754914964549b0bab39ef88d39f6d7c363abdb07a8850fcd6bd35f2acac10341c6a21beb5399e81c623455732281b763dc5f1d3cd31d003a201f1a88d1143b2520b44813d5fb2650fa775566bf06c98f0e7616333b1d0e5d8621ea288519a58dc3503387e7561bc2d733af69d94aa5f051d57ff7e62c66423f52745c5d3bd7aec7d9d83c3d2ad4e92c27731dd2fd5775192b72ecbe6452fd4bfae00c65f4490867470b62f1f7ea144668b97bfd859307b82e92ddc0bcad54ce523b82b23daa35107b3f5554f48a835ddddd6b81d50cf0a533335eab72dc540d1ecabb8aac55d87db62327d29ffc3e0ed410518107753c317e3dbb957c0b7c6207a374c6733823332c694b82fb4ad2afc08d187cdae1f3e41cf469e6b30b654129f5557634e83848ee9732092e209e17cc2d858ec2619b4a83b74ab2efc2e5d9da42cfd9e08d7f70c937c7f4048697ee715adbe1fde2ca88828cb47ca1f30a2320725fe85641f9e0a6e16a107c6f9f25373c7eeaf3a4f218ea12daf33fe14cda70de307359b5ca8830097f8a93b647470cea56248d5cd583c374da925c57c42f95e6fad364ae3eb86d198cbcb53fad6d2823a73f79ffe384bdf6f00510e2b7aa0dac9e0c8f888aca64752adbc6bb2c2cb3b325d752f3b16fbc7ed289678c21cb395e62fe4f67be8f4d5eb35885a94bc732230389ca3c24c29c9b7e4d728ed434a84f143d586d88198ef51175093a71a0ac42484cd8377534180291e2a3404a7ee25b8ea76e287fc6a6225dd71cfb98e12db660105d3fcd310a5dedadfd834999720eb9c08bd6e7c97974a8e0a637501302eb6d28568394474b55b4b1adb13a054530040aca730465e0334abebdbf39e2a2cf2a41ef3f252da9ee30e943c9c80217f3aefa284655442eee033939e1cfd3d7b42bca513615b6e5199712e62e135d55bd3280e9a21ebbf87fc1c977acbbca07c1b7ccb84b79ceb333f5855a186379b3c35fdb4c45f8f6355365a2d362eb05394216b489babf72ebd39e27164ced0e3c8b0994f9e0684f3fbceabfafc24efedd1974d1367455c30b4808243b7481b38904db48d90a0ee13dfc4600c1507f562406e279bf0950807a6bb9a13a5b898cb3828c2ff78ecec9c748be1eaeae4e57571c69ae1ba8e3dcdf13e957aaf7351190cb40919577cb5e14345ffc58eb8db093d968bdc0d870351271c07ff34b5ddf493d14ac6870a7d9b975cf75d53df1e4bae2a78be1f4c8c657d1d4e8b57f600fad973fe2e31ad106a7e9f071f900c5ee741f1702dfa17da11f7457b98ff049aa3503cc7ed6f00ad3ba3196b39b8362f6e37e213fb5776bd0b1cb85d09cc7b8cc842b7e6a3d7cd53eba416d5bda280f896f8fa7a0df8665b01fc618cc71a4c08b6fbb398630e16e1a25e8e9553afdf2aff897b1126cc1061138382bf918c1b4e801fadf33586a1eff541fe7e608da026158670c1ee7a991735c171f5f198d01d834472da9f75f3f62eb3dd31de996af083811a51d5cc27a5d23b8785eee64827a67969e819e7b611be195dcde109a0c7e7bbd8f4289f8873e543b15d5aebf2d78e8c439b8e1dd2e2654bceef7756b78a6aa96012f7b72fd372558647865059bcca3698445a414cd5413dd00a03c28e575d3eece66bcf41d288155336550e3a18222d5fb04a309d487955030a1323b300a3e698572f07983b67cc9a15aad1a25eacda2b6de27b9e82e2e227b4ca470649097ea2c54879c403822c1c201ff7986a357cf73ae5962fcd66a1b224f8ce39c773f2bbe64d27099dd48fd7745e55098b44565ef1f4868661f18b601bef39a2a1eaf5f73c578241b634232f8bd1d439985a27d58522d0e2a33bbca85b286cd83b918c6efb7616921ae2ea1a620622e08408945ebec50e483eed162a3c4a404994c17a19125c41f4548effe62ff79fdaec2961085d00b33e36566ac4720b531783ccf4edfb09457d61ba9e09fb263bc162d29c3d3ad12b1026ff0ba207fbac852ae0804a12742e61e989ad21bb228861f6114394251f2dfec5ae26a8f367a9f363602a98b26b36b0cbce8bf1bad7ce430ad420269e8185489a5cca0e0b50265a0c793a9b0732c851d42be48e48859285b89de3365753ccf6cf0a67870fc8ab5eb4139e28cbb5fe14f7a318537043755f07f4667a79700bf7a1be92bb17022cdd1304afc42550b357b9200e235aebefdce443831a6236102bfec83a3641a8339500f5bc744237faaf34dbcc19a84e72bbae309d03dc0559994bb36d388279a1b9c7b1f5b109ad5b21ad3f283fb1e0486807f669c1407bcbcbc2a89f01d62278bf7399b3d39166773a872dd81991c948ac2506de691df79f39227bbf72d5a121bc1c99d5189d70daf15effc65eec6ff220c090a10e1aed4b008cde292a9f3ad552e626882033608e7a3b169e24ae53aef8eb389c12e92c3fa0b5d36837b580bf8f9ba93e6be4843c30acde95ae989a01c570781ed9df5f22291eaa175c702342fe375a3d1e0b32880b7015819eb1fc5080270979ffb88a90f99dc79c2aada0463f000126e15bfe2f3e1ab48f0c15319fea55ada935235bbaa991adf5f2ac9e1695d51e6037a873d8fd23e4b1c27b3230e82d4131e0e9f697300c6514dde03574c28b3c989c5db3c62282092b28cb791b646233342338459a56b9c28774c68ec528b91ae199c27c6aeba4ed93cfaa5956d8c75b9486eb55a6238507c3b1b10030954f1e6e347011d34ad1efcbf191253afa72e44f784bb9c2b96cf756a90a2cc5e0319c71d23ca13a7549290435c3763b667d4f729a8e9f1ffb222c71cd68102d9f1da23521f2c153ab21c60fe2c29f8ca0c0abf9842fab6b052434f619e95aa0eda0f7f39e7095b2aa83b07db5d8a9b5215de7499850a68f2d80f4e376369d81b329ae883e9e9943289a745f1f6587dd04d4acbcfc45948733aa8f2ea3519266d18946a76bfce4dbc07e6517c630531eafc37effaf6e8d3a5e0c69e57315b99c2baa320a9c1a520867dcb7d5a0f3aded711d3eefee3c9982eba279d4b151e08d7fdb5d3826ef5532e51bd3390e3e4463bcad49a8311c2724d7058c8d11e9979b527f4602596c20bd1bf433b55fea177359ff938935b189813cb2c129cfbb85e8d0713bdeb55b01ae255f6df1e7d589998bade5facb7dd6c6527836ac0fc857b02c5fe97a901d6520a87a6e309d4c6d29fce57f5d57c745b2a26cfc341856127b45b2f5da48688c0a231370f35ae49c01fafc2d97c7e0d84b68cc51ca552eac342b586f4a782c360f0ddd4153ebcab38e56483810512aae09fff7d8d6e105629d8ac91964550be369105f6a40df8cc5429ad3c4bd739331174bd2049e731660e5e6baaaf136d79c10b28326c907c41e6fd565fadaad5a67a8c5eb55da79417bfcdfd4c7a5df0bd225c51e190d896b9377474ae5128f46196e3b864a0ea43790759cb1ab0661cb86f2d5b970bac0ca4a8fb86ff71f25c96d8ec93bc850b56fc795abe4dafd467fdb72d0c337a828c2205e15a5f84edfb98bcd673f4674c7a6cb0ef6c59ce092a16e8c8fa99465a4bb1dc576a19626866b5245ef593e75d6a1b203f3c94f3fca5b28b5884d8e1d14a48d6ae27a79d1e0feca75b8fa99c4e5c21bbd5bde7da9a1439f1cfa483129298d61cd2207f71b6541ef6495f720cf53936d658ea9aa42b99ff56f0fb147a52ee2830265d4ce846afe4796791185263f565844bf50137cbda6d5c1b4e7c2256311f35070bb8c707d51adbf608bebe07499e764beee5ca01f90ea4ec38428f2aa3408d5d3b82238a13f8fe0148c2b4c214beeabfb21b49cd86df1c224cd394f6e485269ad179ba27f74f241c794b0ce165c36e9bd6e69011bf421aef83a90eb59ea441701f8dcbf0cf617652706174dd5351e3d447cd7a3bd1980f5955e164d0beccc14007ce262a132d4df524ebb974303c82c49aca688951ee484884fbc9e17211912f134a9aa2751e5a8474a55af693609e5a629a79e9db7047e358a0d83cb2a1d46b35528e818c3f1d592bc04bcfd969b49958370e33b5ae0d349c7025094d1b07f78da1c331b342a9ca7dfc120f17e154a72f19828df4ba7010c1734bad652ff91d0324ba089bc725deff4682f08e46759ace30a7676dd9a1e4b11ab6263cfa08cd1032df39a7fd9d8ebffe3823ecaca9c2f6c1e9e4e51fd4e11b7722837a2ffb1192bfeb00816db867ee6e8865fc06da56fb77b6f6ee69dc8c2e3664672f1417e6c1d6f8c1d01eb96e3e4b45f0168dffafd3c4968b82c081b280370380b4a3cad557d5c5f918b0ab0463d7837f9d96c3e82ba4528c59c5407ffd6090fe43fb445459e0576f880a9162d480649680dbc12b5f4199f84ae8abf8aba13efd565745a29dd5c0c2945148f3a43d4fe49a761de81951174d4abc93e48c7c384763b26a79a27cef67614ef0495d7995d61e9773bfb30e4ae25ba4c463f33cb80292c257fbcabaa09e80122d0eee14906e48f711e7cbe893059163969f1474da5300834069369de645658672b46b0bd8818d2331d6d745088c80b52e4bdea799d037092d8b99eabaa57f449d3089ed54c3277b4f5ba0882a658aeb95136445266734d5b03d93a43bbfeccc0e779861b7adf1425c801d8af985f3b5d47fd807013309cb95425ccec33ac9dcfad38c2b56f3d3adf098be785730092c43e22a0fe877b8809202e6b5bf72a95eb624c8acfb2660c2439bfb35f2b2298cc86b99952341b26bfc33d976ca7f966864f30ce5174b0e3ec603fafcb00fc205e2b8b5e3932121fa4d5d6890f318901374d9d8e7968636c4576b46aec2cda7efdee2ddba416c858976c22503c3458c160db766c54ac827ca4f3f96613b2d2b0b6874d8f62092bdbf54bdab147c44719f55de4471da9d0649e11a6769867800f75c784af77c22eae0e2e09faffa63a5889b7227387b46d9804644cfaee2be5aa0dd63a59028145222a21a0919b1aaf4a00ee35dc85101253a7db493f0ddfbc8d73ea4057bfcccb1e6bb031bf5dd9606cbe0746c4315228fa4622b7f692259c8b5c403b94394fb4ff13b4c9be772167601afb86b08f6a3427a52426158d4e3013b154ef658fa080cd0264a7d7cf39e1c81225d3eaa42722c619f61cb9db98e55807fabe72d100f895d4ed115dc9d19b9c1a2d14b546620dc44f789869555bfc022128ee9fe1274cb5bc8d854c8a1cf6df66019274fec512b4f753c91f45ff4ca5f81c460b883ce55ed411d45272cec8938984294742c52297514fde405bff880e2e3a8b24a15b9976cfc38d75978291dbc3415e20aab547d4624ef853023f8fa46fc70c8275507277404f3705aea154c11334a16f65b6af5e1d1cf80fbd64f8ecf65d5d8b046956dce0ecf7256cce5bf6f95f269eb0f18fd707e855d6fd7429ebbecc59a6730bc2bf1c025bf4933839f15b484cfdaac98405a08e1a08dd43dbc96a101ebecf6e757d54c3de9090f8953560bc811b6719e27ebeae2d614936d3903b725d767d01ea94b5ad15702be00e661c43528fbeb40dbd10da0dd59e62be445ea65b2f9cda9cbce4cb34f9c05d8a08ccf30ade07a3da04f4effd8a898cc5b015c232dc6d9ce23831f7cef4cc3d6e0d5d642f97a6f63fdaa772c2c17fb5d165e207f0be474ae58e46f1db11e7a297685043f4cde79277d70d1bd587fbf42ae043b1d3cec5555e886c659d97dc931539946ae14dcdf43445b51dee5b975f6e0f6b49f54bb04c36088af3f31c9ac05d22178294965a0857de63c5ecbd2d5c4ef2b706dcd75861929cf05537b3a7fe6a79930c7b4cb5731db9b98ae89c8491d1b5788c2379f45e4138cde75d7cc8790af428cf554f0a4b210f42178f11f3de5f2c4fc46d832e7b453cffc441d4b98add0426168c39984c4e5d6a6232fc60d8ede1a51c6da8b8c3ecdf5b774ebde45ed4162829fd9c642afa491eb7794661e9aaff4f3346e3b38b11c06fce15afda7217867a7c53216686ff7c6a3d3b3971f1a7392c26de6f9e0f1f6b03b69ad7073b705057d130fbeaef1195744d8b147047bc88541e6d8d136a22b28e99bea4e5ceacabc6918cc9d54f99f379461b021daf2d4a4b6d03c73982c886c0620ce8653ad4521884f49e54d6b31470054898b0928d83c58cb1d44eacf8a348595082701301dab5580c80e5b96cda17114a5d791b3da0b78bb1654759066a59573860b9b39d80914f27ed35c3364d273a0c1edcd36da75b8a69c0ec6ab1685602afbd9cb8b249164d844096f0a48233a9588030469cac3513a8eef12a152f63cedbd192c25055d1beb23a0c9b5fe69f0c19123c2a74fd6cc8abd71154bb04247d67eb7eeb72bb2c37c8801dccbcf26dd12cfacf4f4dbb66872a70456028107d633eb140236562c5ca934190fa5800c95fc6cab576611725b1a159597ef4674b5c1f955caa95032bd84e8012824577d41c7c87293228fd6bef7f43cfb2611a5c3ca970f412abde94e57e7cefb84fba9fe2d4cdf53b792ce6d6e5f4022cb252a646f64c6819970684db5675e95fd254c170a1afb1885ab351b88f83a2c3a24532b4c63c15d68e0ed828cd201fa93f35c7d5568337fa6f1f90abb2c944b86d8d04ec7dc421d7c9c93da9961df98c1e203cc5ada77521595d38cc9cfae6a6b3ff655ed02a5c10c2f294d652dbeab8056d5e9619653007b42b6d7771c5b31b08666249724c588b5e344c592b96f2ec8d9d0cb3ca26b5c36a44c8ee6678f87d25c826e45559fb560b853dfc23a3b413526ed0826cbcd8fa6f841b9ebf9ed62c0e3c3ed42757e51a3940e6ed7673429800822743050ac3fa7aba1eca4602b13f7b970e18e4211e3484fb773fbc829e4150a820749b3e0d55d638437ac1a30f9f0750f013e54b2630b0339ae7c8d218fe5b016d07dc87f9450fd1256fa21aec49069252c0ca52f1220ea41553dfc762073d29b90d66044ef0ec8947188ba38692b1311d0e94af74cb691d5a6dd77b82aca4e43ef00e5663782bc0575a857637c7cdfedc4e23d4e361aa18206c891f0a322633410eaec476c9cde72ba58b7bd824f2b4eafdb1dcd237cd52c5607a5a4f50e635d275f845c65706de563c6b5daf8d99a2b684fb24896380ce91c4106f6133b2914721b7e5a9f679407a9c0d7311ec69e508f35a5c1a915ff60c9ea031dae917504d0a29eb78efdf77ede7ce6c9508bd87885cb1de99d448c7b410910b354f6199faa613ae8a50e3a68d23423071df1d2c146d68537cd65cefdb3e9be0ac580feb3ae7a1e7ceea1b4b4b61d366383e717608c546f8ec3fb2c9188849d6e2dbd5ef1375ca5ac1e0cb8db184fd69bb3b2bd61564e6664c9f58d7a4d13c061330b1d4515d3760ba69644262626ed53f067b7664b656cc811bb3af2ba51f83d3ebe183843f536fc72da06403326bca7a5a3644667f60c9c44d7d69d8bbaf4c8ae7610ca4afdd93dbc2afb3ee1f526375caaf74047ec0f92eeff11f1b0f45298b1387d85c2198e6f7aa131c2b98a03eb1563f2cd0c9136001e64f279aa411a455359c3d3fa1091eb60c61a27d7f2fb862a8fb1d1a3e2080dbf12fc052aa83192606bcf18a1e2764601710cbd901456e28603f442c5eb2c1cc362d09ef68af82a48ea843d901a17ba0c29f05e48294d3644ccf549ab8f64eb6f26bf947e6f9acbce804a9a0c458596b4600c78511400c7e782d2c58ddbb47b39c39780914300f116ecac364adb8093c3019ead863b89be80792acdad34011cd8cd1a9b367ef4e41e319264c9f8de512b09fd08dd5c1fdd1d23174d6f546d656ad9a18817c8bfcae47dbcc74d076175aa4ab817a36a8a138385517b82b45c181ac8e232e4d07c686d449d560c6d6c329d918d63edcb8cf95dbd9f12c3624cb88fe841f241744fe3ceabca52265a13013f512e6de7dc0a10c9ba4855ffa1a88dbfcd9451e48fd2f71ef51b9a9c09e6730530d55960b27564f0ce4fed6a7bc0b7bc7e94c12a2cbefb952bb28507892cc4124a3bee9c998c3fd9e0a104cc95cea544e0f1af24b0fe6e1995200a45bd332bab5664e39add01ef21f4435a6e29f9d3cac19431838bb996af20a2f8e9ff60ba6318ad83642f196e36399be1e9c2ea4c79b727855675807a2d4a3e418fb4d688bb88f55ea200711d6057bad61551941c04e735ac6e0e270e66c9daeb3763673813d2394996393cad3a93cf3191cdf5f198c2d3b35b5c2f8a6801f8907080073903a91cfda02f587226e1245e853bbba2302e2fc35113a59ac4925b2335ded56e5baebfd4a41bacef3d2331e01ba8dd22f7cf6e9e33850481ff2cdc0dcfaad50a9dc1d3ec4df0c8896679c0a6fabe65871f3714af3c73a8d48bd5662fc92e23fec55532e4da280b24ab845cdc840e817ff6e2b3b82c6e0c79e404d8c29e134241e4642a6edf39a0a9abf0d4e612b267d0297c5125d973579540688e2aa3035b902ef43c988621521265cdfb254743f41bcf9c246dc85d06eb0504ca62cd22e20d14675d4c7e8e3306af1e33fe4e4d55e0b9285bfb6bc22d8894e70a46431fe8d283d2449e82bc6b879c16f0c6a0036e55d2196870ac26e76a776b9e471e799e0c92b08670ccf36a1aa91df7683c9952261d1199e5cadf450b331928182ba217495438d4d7ae2656aedb96b79eace43e9436f0b9d29ce1343f3e4f21f35cca22c12b27e42efe3f4f0153cea21a982619a2fec77bc8baa0773996d80d7321d0e6b825ada58b2edb40df865c2b90cd82d7ee2173ff737c47afc93e5e8f263324b790ad681bcb709861bb82261a68f4d28735835c37923be999272bd2535ca14594d7e4067fc89be4e513da300f422649d313e84019cbc96ea91e100e4090bb68d592b197df3856eab9c09b4a9effb2f82bfe6d6af4a36b990248842b4ed20fad77e467e3c71aa9cba752eec76f48d877a61beeba76346b1207d1e804de3af6401660b718121a0f249f74789d86d31883e9a9940a3d8631be7557096e95ccfcf67d4b8fbc7bf96e2d2aaa6af884ceaae4b458f6450b0b4a5c5d039eb217978861cca0af1fe244cbfcbaaa1f0922ba7bc6ba042aaec2f77898db9fa46f2a99ebe64c37aeaae9c90a62aa14de19c429f69abced15104e858b9c633b01648753dc72d220e49786697c92c945f03c3f5974814f9213f4949471ef6d60a52c2dc265b208161b32be4a34a9162b102ba57675d62dff8cc332ddf06f07bb397b2ebda5f98e29d00903b9e174ecd5852027372b76dd5021366ab2b4dca943d29bdf39190edd12978b96421e9a739006c9fa833b4361648bfc3651150622dc8470aab841eedf61e7dcd1bc23ec2a30af8ab5bcd3f5551f9068d4b8cc2927341cb018c1cca048b481f2993c024bdeed52fda88d936779097610d759fca1592f97bcb3315f5125f096c80362109e29d567bc8a3f6e36ef162e5421bbc402adfd156dd58911a3fa833739c64a252260be23e138b541d7886452fc2ec10c06e5f13f551310e2cba2815e05d2dc8511e2c845259027750ca8bc68be9b7b902cd970ffc4d61c5bd351c2cc333cc74eb36c48a1bc7cde52c392e58c7e473c5210b7c802712168457778e5f10b7ea6ac1439ae61aff438c222d9c1ff26340b1c9589de8ae6f440d21b2f2fdf45fc8df897b7d6efd73c7dc64b28d8fab9bcd329445b676a5a2677e757eb294dc1ce789ca95cb652b9ff97c594f285fe69c674f3b19cb077f923e4d96d7a0d5dfe2b5d13b4922e6d55c82289821802f9fc628144c386d854b6355123d05e8c8a5da258bce3e56784d0cea7f02609ce81c34ff779325107664b2bcdf955d9866e590ab4ed819e1fc52bb5c24258efecac9276334ebaa8379f1e946d4bfc56901dfb7c543a942697ea2e28e5b171a39e4eec94a0175ec4122bec6e0397bd9c33e1f75ebaa63dee3441b99ba45597d157b912fb9d159784c50d547e824a4996f21f145c1a6268f468678a8b773fd1232ca13dc5f7e7f42e3fa3166aecd69525b000eaf2e0e603c98be895393954649b2565c88696f58efaf730a0b67325c9ba138c7426b80ab665db7db2fcf1886593ca9211eb02eb2d13481bcc1a20bdeeac2f1a970e1d7d6908dd4e120664239662b5485e6d44c59af91ddfde1fca8c89e7cc8c05a226f7c1bccf32d9f95c5be5edf7ee5b348d82596430416097a362b10d8a08271fb1a9e619bed2ded331468ff18dba02ccbc8b121bfd52434d93c030e1d27480042bed275024f3c82c3ff6c53297472cf1279da5c950275d0c58d0c8656ffcbe626b345af46710da76b502cbe367a9ea22567cd752528806a4c1f5060191070c0898b22b9b9aa043b3cba0014fc76f0f342e463e9fedc91322ad4bce6cf65499c195344b971bd67731a38e681f3591011d6d42cc9e473544afcc3358b60ff97f333ee82baf2b7eebb774f003f633f8ff19d5dcb55fa8216d5eff7b8a23c747d24a4267398c208002280020b5b8b1c137df89634a0a9cb9ee453e4e71d4345a14d8c09232a40bcf410a8322a8112fb1c976e42594f2a106fe6f16a7d85b269513ec6cb509cddb15da1c38421f3a20f875bc63a2285e2e6c648a31aa90901b93c33ada62d07ca6bf15bdb6634cc2758086534fa782e49cb27161f795740a475aaadefaa88a347a39e830dafa13ecf07d2430058e57665a10a04c0fa73c10997e708e56e3d1270c8ffa3f1dfe6c60935779a1c61e903d4732e6bea75edf5ab1d04f39a4fd4821d759b47349ba32b304098eabf240c4ab5b6ba99f4a0b276d5dc717ba0860ab13d22bd040132672546a3479a27dc2fcc540ec75cfb035f0eb32910456892619880a07bb80eb6e9c2b362ba9252fb06db0cc921bdc8f38265cee96b68fa3fd773a8d876f9636bb43e8ba5acfa03d0e5bfacf9e21914d627625828b23ebb2f68c6a42130a9e7bc9c07d3a3b08f30a669bc2ab88ecee7b4f83c9c5ccb09169e5d064ef5b2081862ac3773779cea462ae658f87053802997535627d057b53bd22f942cadeed28b73f9182bad2d62831b29ed6bdcb3b2d2907d2711fa1f742ac3cac62a43aba6f9a1803b48e1e766364e48face2f28eee7c8fa8fb435b3b177713a4eb3f5e5296547027f5064fd4b60fe5d8c6309e69f8ee7e842dd5e54be090fa0e8ef598e1a09846bf6e14c9d63f6e89a26a889a2e9149ebed9bad44b2d69aab87bd9af7eb3ab9d8f7f3fdbd76cc0b1ad5e0526a099a68e8e7a3c42c899358c8feecdb07c6c9bf94674c85599b6be2ca6de753d28b9077d5a316a339814031e585873884c94bb4e24c2e46353a9e97283a12e8d2a5e88f4f2ba07118b3d9ea0082bb7a6c2c9a85f82788482c2a1d8d8165597f1a5b7cfc072fc2afece053b30bd516a9ba4880e3271c971aef79c6c0dcc308117cda7a6880be42dcb073f12f4f3e45a70ff8616e3c226959a4fad42ad961ae513cb05c28452f226dbdddbc77ed5661b08d65267a80a01bbfa74016305e49212add94ea5a483469d663c2b388857ea1959fe765c09a1bd77e7c4ac051c9ed06ff79d24e46b1deca0e2340328a41cd4942a9917d2f74ea1092b45e333fea43acde7f41be63bbf9d6ea1a0726cb393d058f9a6b2ebc54cfe39af4a2d5fb2a7b1be856b4b95267143efd797f1388a8ba18ba2dbd820d2ac10d6f35351dab20e85030c8db8e6016d5dba9519a5f67972d12941550cd6b07249378f58e7bf6c1beeeffc8f3f4fe57fe3a99ec9938796faa7762880376af82846ab7ebae30f395d3505501b7816f59921904b0cd2eb09f1b93531deae0f74750d384d2a2434c41bf9ea2830f64202c7f108f9a8fea1b479c6b3e8cba2b949e94b5fcc06449d49d376e1bf97077029fd7e7a463ba13a65986e19bb2ec7eb14d09dc46dc9ebc7f5cc922dd536f9baeeb88c94724bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
