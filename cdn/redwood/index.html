<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3df1937fcfcc43d1c4eb44424a3818ec5a55968c72de8637ac4bc3fced4e19175e63e797d314197a7c02096767772392abb8b10e8305b4bb5bd2b8acf275d0c39eac37a0e214acb7c5408c6e23527e13241d7e3d39a0184902c0491d872baf45cca76e3305136e87decb9c9cf84443fb629e165697ee9a1e858a9ac9cffcf5748500171aae26f4941858f4c9508004ad8b73cf109b9b6388436ff505ba9eb24bc71fc8a5c18533e72daf5d6df0c8b70809d1dc66899e48a69210cec5067c92f34d405b436d067845772d3ea5b99c989389713d1fbeadfcc08848d45c85fd17a18f2a4c05b4006290c82730959ceca41d62f701e2bfa2cfe249e5cba6975cee7a8774900a03a2119f0944baf6ae70f243b621e9cfeed99e46af538d5762f560f04686fcab08806b276e3414af05d05273d5cadd746b0f3ca22702defca3f0c3cfcd56f1b55869ab6fd755993aee0d3a52bf68abb23a69e7d27f4bb1cae5aae11ab7cd9016a7c666848ee2a811fc8179b5f0f1d04bb42c47e8ed892bad2a9d217f8ca98f49afc024a3cf848d74eca8e4d64edfffab83671bc2022efd28d91058d9925b0ee65d93d7ad860e213727521931f1eb39c61e92194bf290b06a7b23306d53333dcc501d4eae28e6aa61038cfd629c2df51427d59b573461c6bcd1de97e0fda0186001d84f67c9053534989a5ac447118b145312f48b0c088383978d32efb7f624c269359e109ecaf30cf4b24e4241b5c1d8c599aa877215b5dc8821a98bf2e8d1c6535e8738984098cba0f78b0db901460be6e00d4c50fd99dc05d3ef0f423e72783308f48d52c6ec00ba9de58ed98ca9b7597d508f02baa245a2fe02ff094a6d783c6c8a3187ef133ad3467385d725cba0c567ab3c9602577768b282daf4f6f32b35357cbc9e5837e60b0c29a55fdd240636bcfa82e2998c882876a408be97e81d536d646977d998824228ab0a2279feff246e56ec8d3c7be217e78031eea45f5b5a224ff80f71583dc2882203d20c539d9b5102e2a58075c8a7849ba6bd2b41a6efe61bac69699e8354cc94b4136b25710d33ee8a1b2e17a8dd9d0db0e021d49baa64c053b355c7cd41886038d5de658c5ce48b1579f5a4d3b2bffececc97b7583502eb7d2ac860b82a3c37f1127f9b70190f49024e09b4928b14c04eed3243e463520ad6478bb0e0e831fe563bfbc24a60ecfdc4d828c64a69c8803f880c9a41dcfcc24cbe77de146fefadb3ac00f443e6eff5d93f0b34d514ae4214ce14c9e80cd8394c1bdf041790400771b81fadcc26092ca354af542a635d43eab22f5d16bc46e11bb0c04476117b66fa945e7fc0c8acca2bd0b28d3d6aded804db1fc608d223b3a5e572006110849b32f3dadfa94feff2250c0de31341157789fe81844a4698796bece284bcb0628c7e9baf219f95dbe4d36f322471eb2678a1420682dfd27c4f423498b6ddf1e886c032f9ac83ffa04fbc3464a584d1178187b6bb7acf58e79bc5e6c553542ac0c8dfe337c61b7a09e90fd6e8016b1b9d47faf4fdc95fdcee393b4f86a693b98307d954e1f679d8ef33dfa55a4f734de0386ae4505ceb73cf31db605ed165e3e619e943d52c42a068c17bce346e92706fa454800dd15f0ce5077b68a67196789a0d3d6815c8439982c70efae8674a3869f040d4e910249ca218ba2c4899f12aa126662e56f71f92a9ed83df066359f4aaee6b451d586c729af745e9e3b81e114102866058d529351d6d94cc9cbe3e302dee2068cc2f89e4718a6f5a4805dd93f4586e425f883c4057dcd79c17f295684c296b38c2cce977bdcb143d5a6bec1df52468753e59560138f36421a0b944e0ec68aa7dd2e4b2ab5a46475ef279ac574fafbc7108b4d3362739905ab2d89c2823efaaf9b899ef344a1f351eb2d2d58a6ec58b4ac89407c9b41d5ba7b9e26295ff846096ce1a1e9fed9987eadb225376df667880897852926d4a1223fb2b5e66a4360a3ce9e4f7220fec634c11874cc746bb5a41b24395b492d7369ac321ebe2e13cee226319d881873733b290585c287d5aade94cf1a75a8a3544c730c04223f0d90a685e0f83dbf2460e1c700054103f584211c6e302c445baf56ab104ee68dc0a06796eec0d4fd9a2a13abcff2814f797112aae999f53fb9e026dfc815d23bcdf14cd73568735fec29b05f7741347a1188deecbbda7dc3fcbc77b2b9e76209bc50a2fe17ceb0be15be797cb6d105280bf2e1a5b5b5d956e3c7c7ac54d14a75497ba5397b4444033d777bdc164d7d3e1ca1d47012e6b1d3ddb5fd8ebb48d5cf241ff06cf5b8d3cac1388f34e3f7fca8e8bcf65b8f4190aac2826e64d0b14327fa325107514acaec325b22298d6fd4e34fa506fdb6e50533f2794a6efbbd12b5b3e28c57b716393664c74da2ebfd5fbb12c1844b70abb59b980297c0cee6b1aef4731c49ba519d40120d4dbdbfc02b339321f4ec23d73f27c945bd07eb9f24c543a167e448bbe0186e3299f21b3a1f9398982b5b1285bdec30e54bd7b7f544f7b7a0201f4a7b9e64c2ac1db6c047eb4c4f739b3ecb99c3d19c26da0924a55f3645a5db1cfb97b85219d2811c632a2cc400b8914250eef7c54e6a84badebe55ea8aade83d3e4a73bcb6874ec679c0e955a1f22c2ec9129fe57cb105538addd1e7b61585d65d49eb6c92c3dcc7051a500d4d5b619d7d654671c516388f83dade7378f49cf0ac300af63607ccf4823f64c2df78034ebfe53f0c7c656ab8b8f6b25c76034efd330f60f2c0e1bcec66cc438e32a78d40d752c78adec0088c56af59230c122e53ca4fb328ae56e0a9b4641760b0c48f790bfa8b4045fe7d9877aa5e269bb29107563065b14f2a9fba37eec2a0f856c10d99fcb0e3b5a418d7edc8e331d20101178d780cf312d68df5405575383f868d19b4a5c9c1978af12f4fdc163b33c922a70e85b5ef1d7fe7c41543404e493b08d14fc76abf71374558363daf8146eaf54607aade56a5ebd6da6212fcb7a7cc16518766b43bce3877d8f8818db773afc84b26e5e624c3b0eecf6639e90d1f11f5566ed1b5b2f22a0e6ea64969d9b6ef77a77feab4096d68b9c15ebfad4ecb12398bab897c8c4d12696f6808a135df5f836271185c8d2cb1ee4433d3271c9345e7902c650f8f20d6642eebc79c5789acc08b841c73270e2f93a9dab668e57a5cb51e08953bf7ca0371d62cd35ce8e3113651818d0b4c04d0f8f95b4e7816772a692aaded8171ddfd1ad03e90ad0b86d9560bf42f7b676fefd33f1857fa23f7dfef343a987ce8ea00acbfe31ac7c65b913f4fae001394dc438e230fa71174849131bd281385b8aafec0324c5a11052700b9a3d78f2b87e7f148fae410cd5c583cf95937f564c5c6e213d2b8928bc0acf5f3e7184574556e7641dc168ecbbc2a5c5637e3f8b822dc043ee3c9858c0741c88c35703880d757b3626567ea654618784fc6bdf2c4c57e5605b8c34365a2035727e135172ef9e574d7947b1f4d49d05e4714926d8d1c6cb32c3013029b3ac2fb840a3b37df1a84d0c5edc3cc8e573cec70c1efa52441f798fea659e3e21e700cc4ec10ac1d2c1091ec109cf9c40c846879931c204824e1f741435984a6ee37f89068ee963b23df205e48b0660a6c3f2d87d77509c64694330434da3d28b12179fdcfc7501343705db7faddc751312651cc0d39d63cfb3fc44a652b30540810a0d903cae6415f4b1d6442e03ac0353188a6448f6418a92b662c8459a97c7edacb8dfefc0442390c6f020ec5091ac7442ebb1493eb6c4f8327975e68479dd8124512b8586b205698f51b53def254eba6b65260dc8109d92e5b5eb30ee1ddbc3e4d890f6915e0aecfe6ca33d490c0ef0a6d01ef94ab088008cc043e0a7a764bfe98f40aed2ea2ccf055ce080378324bff567f85fe80c9ef75940d454c35944988ebd24624c9dcd84eb2d241644132cdb1141f9eb2b1e67cf7f7cd5d9e895d3eb66912eeac6d51dbef9e0d9a34c1669250d3642a25606c8b625665314fb8dae90929c0ae8966b7ffd814498589801e4d49a8c27cb9d30ed2f13c397100f94044f1bb6e0c805bf9b24449b5815d0e95d8ca5cf9a5bdf6a0bd2908a89461ceab3df5e7a4bed05fe19e6663f11c2093fd4c04fdca33c4ea6ef7c2c22ae83a4116c3455c91ac2587eb61a0e3b9c4a8e4f9a373a2a57fcfe4c42083feabcb26379f285638328ba09fdfc5b9294b4f652a9e5cb83bd719ff0444782231ea2b5516ddf49279bdf90bdb211b7a8cfa0d10f7540a8e177284056c380e1d7adf85bc010d7a97a06448401d1cafb4f97c758943b0e84ac9cf361f6202458aea6fc0c7711a17eb3edef0b696ddaa0e49d734f4f15a45353f4469ca143ca285e4f1f9ed8ba35afa5ea4bc1c6872e1accc3ded257cd473c7dd37a7b8ba024db9485be6f09c25779c7f542bebbfb0f2d2481f6c8dd0b4301ce98eafc5b734e7e8f04480a811b45e2a17012534569cf75e35d0cb001c36cdc668b3c42dcd985ad0872bf3da398fca507e0c582e281bfa3808f655f5d667e84803cfaf3e1b6f9ac09007ea15852111f38f8f4d0883624d2b82ceb9888fa227c51c53986c6f29e864749bcba4417acbf02774d43ed6f04703e9925c2a5d9661c3501f7dbb454120fbb86555a30d4af01ff3951d734c836812027160049aded62950472776373d9781448b31dc912a44d8000409df33111d0a55dac8056cf0e70407686d044f7fbc5884c739068e1ce9338d5e78bdd564109589c926908ffe61038e4c37ceeb16f5271f1a9f184f59eb250219c29d83127b3fa1725e6a74eceae6e8ee1f1470cdab2af595086bdbc3ba9912b6ca00b22ee265486cc7c7350bf7fbd9987d57a3acbcd41d4089dd19241fac699b16f53bfa9dc4d5f4f9e5927d4fa03e658a834ff1b2ce0da07ad6d5b56bc6d0eb436ee702fd14d37e81e25e71af9bed800d0127cd877e9b6081ea25c1147dda51670f68896956ffbabfed3f37d055643a9874cca1d9bbbbb631ba2cab77ddce71a4f88a126d259000b29cc8e9d5885ba62d727c2d1f45b2be6cfcf502cfe77dc3ad58ca5af9d8872c7f497c2e454d1bebf3b90d1fe3563e78beb44d108de26805f34e9a43b4ad78517b4ee2a1d0dbcf498e5ca14d08c5b8e98055f8e1babe79efa3924dbc1922a0b61f2b1e38b972be37b02bff0f4b67d529fb00bf57a2049912a3e5ab1a5611d52905a2f6a2fdc160b3e4c09e6b598d400eb3b6014e5f20eac70944e7cfb59240ceafba78120772aa17769b29fec21c9f7bdf174f38c15a57c3914199084273039388e1aa2c49aa35b9d41adc41b37c8fbe006f0620fe10c6033986f3411a545051a396a70119fdb58b12b7cb2ea1fdba800f3d5aaa3d13af7108dba3b94492154538aaac25ebd70013699800fccde30bb59b58550e395de2e06c49e30cb5ba1d0ee48198799744eb255fd06c26ba84f661e8ac2a7957a7fe9825f3693ad5009b014e3a45a3977575579d7fa6ab393441966d6330df58ea323765cd267699b95d53740cb45048bdd74b212fd82a005b7ee652d80444b9bf1fabf1da864ff04772108fd0cb4c6782bc9af333d2f0cad0db309f48e049770d90ee85708f3d1bdb28ec544f06b23b41ad2ec2abacf93a160121f3c8b6eabadcc3b2c6918e2ad69d9f514e1a811e50aeec5706cb9c70341c980c85d98bfd3844ed5f73392572a31f85b24c76d4a52368d256f79537b120b707db377baa1cca4e0d461708727cfb2db83285c39eb561ce1f67cc9f60a41af65cbe99248e8e0079d8c44946ba49983b3d2701610a8af5c0c312a419246e416484552f0c9ac9d39e19303e64ea24af71376036d714c3b58982655e8b4aca1682a74b79d601f42d9ee08fd7d0bb7080ad2a86f355e499a3ec40e31d68498fbd58f99c0d43e15b42e4706f9a275701744d70c25fad1639d04877dd86c5e4fdebff9c7b5ec26672ad0d8a747cbf82afd107bb626ccab88e05ea54d077fd689abd6326fadc2b6452e3cb10f41a10d2962c55a297258ffabe351b09879d88f17b8b29a0449bcf419159b1378e700a30f8b47ea31a7de3970fbc5edbc15f6fa929684a81b21558d3fa8c2240df90a25f84e2e2d4b71b5a758a7439ed85f40e61ab03fcc7e452051af0c1ce643facec7937d83f6df65880902b2f9e68772156da434d21ca6d2ffdf2fb9fceaafc786a84dda93e7cd4c27123459d6ed16232a340bc46b73eecf041e95217b0a4dff91173138849f780573e59e14de9c0bb4e9a987690832537426e455a261182c0f9e010c9cf9694797525315bdeda6940509addafc23b120777c3c18f4eca8fbcac1a4e5c53ba3d808e585e125530186c144fdba724be77f913a221420deb4e731dc264dbaf08f166b3a56c2e20390474a3b9bd6015c57ae901053fc1594cc09f13227420822bca1898c33a9a79a73c9dc8c086f3fa5c13c70ee68bc838e8da389566ba387b74312fd146c93ca2316e371abbebe5b1e4525bab46d045618e8a02e79b9b26b1c66481f0104410f1a6dc854e93b8d9a776d56feb34eaca815007ccf8813f09b7af929dc66c12419621df81a106639dd89d3df69fc8ed18df773226008177d29bb55ccaff1354e22ac8a4b9c0f6267e95a8d2a415e362dec31435e276377fc68ece355339b4c2ebecdf78ac68bc119f55e782172a6f841edecba838a7b5be9ae5b243d12e12524ee1984e7704e6fa594a4b3a4ea68cd38b8571cb63f61562e9b5542e916cb78bd264ca186ed4be1dc2e647d52244fabe430f61a59286da3bb3d9175da5dfc7517eec77faa662f053924ffd435cc022965ee92bb23a83fe32fa1901e7c2e386b92b032fc038830fde51bab4f7c986313cce3703e8792e301aca6bd2030d3a9b430a59bfaa50568fdca9ee2b744399660a2939de29247e8b817247ebe7bb13a83e6aae9a484b8ad97950c455cb3dc21abd3a4e6197fb2a091c5ad6c28481599a95898f6c77c9ffa8110b46b44d7fd75c8546fb6c459d0caa2f305587471ee936a985f5f15988cb5448d2540dbeb029c2a133235e02b54ec8ec7d9b04997d61949ae41b243c0ed6c0bed95e2bfc7816cb7e3b52014b5938ada5148cc6e0a95469d907643b4b0f04056e9378da37b8bb30386be55bdd4b766c8e52671ba26dcdc3e42b3be883524744168203fb4a5ae80a407005cc2ae203e6c26a5075521f9d66affa8455fcff8220110f256c4307c99ed5d0741cfb6d1b3a43980fbeccd6d73fb32776362e6b4b451e1c4406772dcfe2d39ff44a6607734327c3f48c0d3355ecd200903cb8607550fddab04324e281ae55a745408cf14db1e00943fca3d5bfe978f1a82d2cfbc477f8ae49bbcfccc5a0de5f063b29b66c026fea23c230ae0f24712fe1088266c6753d5b56162346465cf9b9bd1ef210b77de330c7ef958bb9413fde3ea6166fa4926ec03bf7cd7160919795fe46fbacd5a511955a0eec06d365530f749539cd25f88237f04110ceefffc660c54ef4f18138407aecc1c5ddbdc258144489b677f641a441c7afdbf4d5b465ac8dd8e2cb5a933e59c65cded73ca41aaa58a9a78e40112acf29a63b1b50d3a37b71e466f2bd7108849b5c61df0b78391e153cb9c085e4d14a8ed840531dfffcf5e71fa42412a0986a3c6a2a5f863cb5a246820fc03e0be0413443d042e366caa4b52fca24af71e3069a837845131b842ff6a52ad783a1eb86ef8ec3f53b75d86dad158b0a7cd6562698ae830d7a88332de453712b25df563c705792df2aae85c6925cf4e7215903bc52a74b051b5adb6d7469d014555228d43d102a9d6652381ef860591f7ed216efc01fee7f4cb7da77d4dfab7940a57166067c0c2df60afdfb71b12d723cf941c9226c18bceaffefb098b1bb5bfd2ba96a6d48a57bee61338acbcf4e896fc49d33a70f1995fb86529339cc0aa0d01672c01f73e430c659295c308e7fb885c32355fae5c8d65c0c5b5ea67c62c6830dc1ebeaf21e679f263149d1f240fbbeec1aa6a6d94a7ef9e4e168af2c406c19d5c9f959e11a779ed7c438f844bf22aa3d379cef13a3d021e5cdd90b426ae0a52440abef6c44ca7325290b63648a0569ac91dc47c2f8eab5196275055d9d08eba8b1ff2e70fb34055525db16bc3798c428950ef730c08ed6f407ff17598efade01525c881ba02d553ab3b68ba28f82320c3e8d0b380007b38945f399cecd7718097b7ac0f03effe6d63bde2cf4cf5b0f988db6307e16de130208e285adf0a0e5e3c03d9849e894a515edf27f879b890a9aa95d60445959909e24f50615c6915406b408efe7e89bed5737d55f298d5b1e838aab15fa9079c3ecf7d3c1b0415d527c2cf116d75aa92401be152c97533173af1c3d7f05b4ebbeb67696296ffc2845138f9d01871c638187ddb502694c69131ad8b3ecaa8018f024d85a6ec2befe5018c61f672bc5668a40f53c6bb310dc61dfc012a61f6bc068f75811bbc08f1b1a6a9b6fc50053783064e16f97072acd4ad1eb231affe3b49e0f026318359101bb2ee344a15692a38c8efed6a68b012a0df964d0fce96d08c7fd5bc31bec4d469ed40875a8c594db2bacf736b9bfcab46541df70bc935c77f389f428b93b7b61083a2da912d67f6c9f6bca71f415f1f093244405512c3d39ebb68491e60256b6ccb3b0495809d99f3beb254cf6d486f597fb27b726492aec53b8a4a68d8769e18d1658a6b58a6b1c8d4e2c410648d274727835059b3cfa50a15e2584674ffc9f595eb3f53f3e4b581283d0149ce77ceb4a8f49b4b58723bf138ad400fef9363e0fd07538ff54aa6cc41442ebda3e3d7b967abd9a01908e6bd475b6d804dbafec87a1328b5e5a26429660448242ee66ccac4a3c4766cfef0544a442ab84ca73c3b0420c8911502c7959a32402d90baceac0f03452bb5c8134f5d7a9398417a5e2ea0f57dc707fa57436e255dbe3a69181767723e17d9e30000bdeba43e4f2b9105c4b7ecc32dec4706af3bdbe0f1618dbb8808a14a752621ca7b2930389d5220dacb93f91de4c634d2a302191345c41696d8346ee501418f7ca63c83be1ad93a40443a18bfb4843eb4ec04a3f66a0c5f5f0ad947f968aab078e09a8bcd4e4de8d8471697cb748bd14419985d6d1582860ee47df87c266b252c730ecc39b0648c8cf88e35f5a705951d630b690ca573c28f3829dab4cabf07ce5cc22c9f42a70607695ceaf903bcccd8c513ff1563a0556831dbc31797e5133a622e5f63cbc7e0dd6e75b1dcccca81b901fadfa251ab60bbd53b09295408855c660905177245b77cc258cefe5c91b26a0edca14ea81f61724535c8b38b352ec152ac4830bd518ebca97db233ed7ffec69650dba3c97e4baf8f02eec556071ef6cdfacdc4f0a29064614e4b525d0d65aed6c1b5b3d28f0f21c17449e8bfca69a0b2ad8075ac6499c0709a84117e66615478c710afd56d110832222e502578244de151152be73f8bcf6352dfb24c9f6c05a49f930a817ac9a9d70cd104ca835f72826859ee77bb1d5b9f042bd58b50c3e2fbe78b0785c9ed60e1d08a88efbc04cbb7313d2162cbcf14d7889ac123c83a9d83767248071c929f2bcce3067db0b52bbac07dd598400fbce0c75114e38791970668fac98c720f4d44b72296e02728d1b38b632c6545390b2fa0e42288fd59df1d40294ab8c8693fed1cd6da5db792c89a515e1d8ef1d8bd3b9b53880c03a3941fee36c6de21bac549f4f65d9d7297d7b69bc64a79c450923d6e6d21a41fcdec35c0dc6e19fbedfb6fa8b49b9c392d54692a21ffcfb14306a26b9d04ec99a529e33e12bacd6620733be5da19af48be8517120fd4a8528ec4e16e06d193fab7a2a0dfa3d9d79ae3c3b1c82317e7741e4a7dece47994f2b6791bb250ffdf19370f0b085a74b59ff8b33c1f0ad7384385fc555fe6261e42f4267a008f300d3febc8b99c75c06e40d750a3d414c362e1e3d5734c65ade04d61a906ff7949c71404369684b8902ea3f27bb13732b3deda2d89da01265aef97df3a04d65d6605988f3fa45f85b86af389f46c87ba4803c8362044342c9e69dd99e1748f5c7c94ccfd477c4d00d077bf50adff7ab537e987777760a13c546b10cdedcfa43fe05795beb5760f2aac75a67af2b97e6953ba1382612912063058b5fbadbb60594d9ae85ed4fa8d4cba8a4f1bc5dd780f91274cde36ce1097f26fe9518598aeba59645de30196c706053c5cce1a1c89a3994dc69792f4be30842b816710657de3808fee1d2089ecaa5134c85c5cb49518644033416b0065e29ff8c814501fbace473813e0767a11d87988ecf98b04f92bc2dcc84d808fd1ce5d46ae6830d8b8b0b86295ac5214c7e8b0b14a7f9b736bc3e063e0d9dc4759001f9ad2b4226952458731f20c49622d9d409ffe3209980cff827258d186b630f16f61de23fd26d47183507f7f513d088f92cea8281da9ed11d0caebdedbb1c0e652fe8b5cf8b8abd8675672ca1f0e187c68d5117197595f04cb000f8629445aa3fc36b4aac5b7c5e7b9c63cfd48ff8d2d019084a6b10d4a0b502eba8ea32aa848710abc1e0f9f3793df60bfc18e0784fdfe8ee758395f96bb1102b4b291360d36da17414ffdbf54b74906717959e0390175788961dbe331c7f4f57d7426db756b39a435c73126a573d85c1a1d615001663df698d52b0496437ca73a415bb56ca4d48addd083eedd8cf27e452c71fb79d13e4c0e0fd4bb1b3f580b95aaa130fd72b70c4cdbc58e33de0446ff3f3cf088df2169fc8459845e22e11f2083c4328f529bd820d4e931f1340ec8a3a5911e1e8996ac2cff514457f40ef722928b884ba7474fbc5bc9fa779bfdc21f06aab750ed849a00f04379ef3d0bcf29cb4931124bdc1507c891d7e43363c5ec2bd716c50ba17c5442f52cc7355867d3a33fe6efec77ba9f734576656c7fbd9337646221c68cea641d3d5eddf695ad69c191e084e3272f6d78a599f3b29b1b8b1165611a0f9eff3a9a7efa3a9ac90b2c9a4372db6f7e57493f7de1a37b85011585d6e1402041c133189dc383a4661c91ac092616f58b3b024396532a1851ac0863c566e30328f5ac140384e979d76d3721055e2e5f27759651a5517b32eb3480e5c93d381e2750330e09f6b012cc3aeb9d95a64ccd7055753b3825d9eb605c6e69ad15f6cbe86577d05105b82f1ba5ecfcfa7d02a2056ba70e0b2b2a88adca0cd537539f0bd4352925387a9da09026e19a4565acfdf487adea70de01c602d0ae76824d7af01105ddc734952c56f2df6281029ecac232f1f9a2ad944534d45bb90c40631cd52b829b1ebea125b6e7ed4991a24e6050d46a5767396e09228c7709c1b1a972c34c6690a69b6990fc9a744c55592141c53af2fbc652bdaaab6dec2de26fbbc4cf25550a4545ecd05d47d7c3fa40cdb2ca09bc8938fc896cd71398de3507bd9325110fd7250298c96aacc03e7b5c2f049b0ba288d32577834f0c8b79feedd730ed591823a0d42299284fd3b87cd7365a4913ad6cad9c857849646587e20916020c6df852aefbb8b4d9a5defb66eac77de9c4cf2de8bedb124a9fb16e4ee1f1a8eb5a5e2ac6c469521b774da1d8f4dbbe6773e16985dd0a3c583f46d513498a91eed257b8194cd29456e345a5d56d1dae9613ebd2f7f85be7f819c3ecc5b7834eb7998d4426730d698661b376201c269de22bf1e1fdc7487add324251071b37745e54b340ae97dbb54799130ad1e02bbbc7d1760bc0eea6e6cf91b32cadc64053633a8f3ecc193db8753f728c45856bec05bbbbab6d60e4ec6378039805dd7714a995958e50c67cd527da744bd6f8c658bfac04a4871636ffc431040d8ad4a6b13767a0e94b424f98debf3301ce456c8a4c264778712e309aee10a4569effe4b6fe5d8bc7802e9fda6c22c7a76921fe8c5763f5a02dbbc5f63c2d0e3e5d20ebe72e86f6efac16f23438b6df0dddfddb43d377ce8411da18ab73c6866f1f57e0f8153c438af4c2f6f34c069ce1907fbf2faff5510d5947a8fa18d955186a32b326a3801323d13bbc8881033c2c3f420fc799f9a56ed4ec780e105ec0b35e0849c8289c5de91bbe1b58db21e2f624fac8ea33edc47c02a5851149e5be4bbd73d034986545a539b55a7ed269f2c14c87b1678fd0d7de289dfd2154de6c7e896ed761d7f8cdff17daaf3ee01d6931ffdd3a6815d69c1c62bf36903312073661fc9e0e7d8b29e0bb62931f2561057e41fb960bd62f097360ebaa14ba6114f84acc5014199b395a5f2069714aa31e04a8c5385b2ea45b21d92cb1fd977743ca138889412a55920653d08f00b0b1d6f0173b50079f5878f9f044df64d6572cafd65b24e6cf590d7bc51765683f4f90bb68b62c1346ee7846de5e755e573e9bdb2c7b033b431b58d31d3f7107d20175c14787725c02d54f64903e4a42c68b8619692443d93ceb6238688eb5468361b387d713b613a4b014885db288176d38d95e81b46d29c41a00b13de2f53cf67bd532b81f4adcfe956cff42a80804a61ac03fdf34e9e262aa74d6e7fe8ecf85a4a38f527413b94e14c20f44ae8843d7a07460142c65107651add5b41c55519471e71f7fe774d52bcb51fe745f43c62586f04fdb47f591a7bf2082679e8ef8ba61712ab7b596e933bf5f7e328b94476d058102e18c173a9a7dc6046df037da769cf98cddfdf7100951007f4182b5604a49b0ccb299b5e4059d2f7d36e6167e13a3bcbadb7704a6e3096b1919680b871dbb82bb69daf635b6f81daac6a1fd83a25148d12288b2986b40013937456c92ecb95064497505e972ff20969e13432b60d67a2f422627cc0c9e2416d278008efc8227c9285dec1c79df21d7f6496e40a0f0abdd12a96f8af962e48a491596fed7c817d2c12567c302d5fcfdfffb01a87fd32774b1326ae74fc46abff7f8a4c74da7b81f963c2adf28c517bae5f135ded8c84290d48022b1012b8c5cf9b4c6b0585a64313aa9495f389d4ce4581f57f8a1013495c3079c689c2e6edb1903558a5010c35cb2486d18cf0156c46c8a299ba50d54079641bea9ad7e53a393add1cbe66607aa4d2cfef7017cd5f96ff618a94d15c722eb07283d1152e333d2fe47d50bb47278170ed73e151c2046ddeb8004180dfde1340567538e0ab303e44a51aa9543a9fd70364f2fe69118facf6eaf7446f8deb1d69d1d24f7d8fc464b5d7e07a1af6efab9ff362f5d416f34c61abff115f5b84fa148e606c038207feafc5494cd22bf9b3f4d0cc27c6bc0c8dbf6b3ce7d529ff8744d94ecce30b082181277463dd017250206410bc3976c5eafdb4e9a6eab6d720e911379a754b40edbd9b03a9489f01272ec3cc0322df247d8b7af99d982f7f65034d1b0842afc1dab66f15e1b40199e8ad9dc9abfeafaa996bbe511a3fce3c23a56999a84f135cbd0647ed7bc26b15f997a27c5fe5fab834caed464fc6a3465eab04562d27ddd94836b53b89af21563585d99c18eb24991fdfd71cd5663d7750d9be006bc0dae0f292b2d9383eefae8ece00c51034e8c257fa1c0b7730e1f8be8faf246f09d59243ca8fd19feb0e37502beb343c9cd52df036a2dae7fb896776ab64f0aae02d5cd7b7dc573120fa5e5586f8f4bdb05592b0651e4f7176e8dfd1f1b49372474b15aac5bce045f742656f2b90a004430cde6c85b62b088a8c22fb3319646c5cb7ab6a6efa5cf4396ff089c3bb02bdc0977adb7c151279a5ec32ddb2603c74b67fc03fcdab4bbefc9bfe0b11a42eea72fbeaf600cfefce84f3b84895c548137a61ba43104e674c943eed0368897520f48d363e2973063b4388e0f18187baa601acddf5d101071ddf36b8dd6b6fe3d4bde5b37390975a0e76b6336b605953c0a334da76d7c8981e21334064c8e2e68165ce58f0505cf89aed5287972aa7bf7684926e4d93c0081e23beea55d9332fa57742385663d1da17c822ef2b21141c5651c9cb417bd97f2f04ac70f5f37149ffdb92f9670f33fc008cd9efe491def02650f0beb34eb58d455d8e0a95abd068b031ad2fe2a3452e75e34d0148e1ddf0b07d41ab193101a3ae11d293cd8a04db72dcadc0156314eed1b80cba21c68a552e7e3072b336d49590c700dcba83113fdf8294b7db2d71896ed7558991f22214737bbf34d8038ff38fa130e77655cb3aab1a72ce102ed284e68e85e28d38ba69fb09fca025041babe28ffa24ad582679b66da90133f96c7bbe347ae29a904454cec263aa8d2ccf8d8f7877e7fa1e2fccaa65ccb81ae72912ee855f03592c2ecf73979c807fb719b6cea0c33aaccd75ab5aef84cae61081ad85d115208ccf2b9b85f0b3b10e9906a52720163771e3acd8610e017c00ae4ed20b91644ef992b4b1929f577cbda58b62a98b0d1c306acac0215d7522cc0a50ee9695253be268d9f1c886585fe3b43979cc9d38ca1a7b9365a3bc29fee77739400e98052cbbc09a97c6bc38a330c26b0c2c0b5dd7536f495f506acf0f1e3ceecf44f651f8e681495f5c40e40fd5c977b572fcc96077167a10749c35fbb63727171640636686acbb538e38df6fd9029a2832d4590851e047643fe35fe7fb108deaa011d243431e52cf891747d5dc6a9fe9090604c2276ebece790e31be226464a92e695002ebaea0a213ae51c8192e19ba843040f99c4617305e4eb09fbf4887167c799b28b52b6d6fd79f6bb8d7bae017793f10b599824aa6f35ce682658e858e212625beb783b0cc087bee4183cb909ba4cc234fee68a5a1ee541e17640c9c7005fa9686c55b49dc3660af0d2ff9dca4cefbe483ba12ae03716c98f3ea212d1c29f321be86bbe924c7f5999b5a054b00fb637215fe76f5e582913a2d2258dbd49ec19ab8875af0c36a70e94e5ed198e43c046eedca200f12cff90d2607bb279a095824e670a1682fd5edba982a5a71fde6861eca986d6a8261079589e118cd90e55a146969a356fc1f949cee39e0644a074fa43f9b0a8084181cb08160792e89df854291e6d90116d780b8ead8dbd8642740dac48d16fc05cbb65d64d6f8ea9e74faa139b9ba1e5d78c97b0fc84555dff26b7a8a42c73c4653bcb1ceea93781234afd3a525d9975d63ad5850bc0ef07a10b0c4d65c7528d05bc8301f36de67770227bb814aa17854456b8787a19c2fc6b10936c2a1420a39c070b0983f4d70967c675fe973e74d5db2a38fac23a1e1cc881576b0a61f7db7f51c78cafe3ebc32c01cd3257dc7a320b5571bc3deca33ec9b4a0666a87a77f5a602c41aa9202509859add6e21bd44a6603812efec8f0bca315c789edb29fc6b83d17dc128e7c415d3ed90552f6fd2b91a2d74d10933dcd2b12ac0322a92bbbd6558d85a22d228136623dcca5b5a728d9193c4de27edfe70e75a6189663182167cab9101af7eaaeb1286d56c4513555ba671620ca26e94a8da4e2b83faaee21dba258bd613a61def6157f25f4d9deed5e7373f72a16445cf182b84042ad0776e8d6c961af6e426a0be7074658f2d73c5c53098983a245a49a76ccd3e7d3d2188ddbd6bfa0b5b1db6852ffc743baa89574341cdd942a6e0014a88180e9ee18d2fbd050d54f8ffa227dfd61e980df8b6885e19d0b5e3c1cbc9be45c03a5958b7c44def408078d4aca1e27f881c7467a597e52b719ea585a1e130b6efea6d46b0363917b95cfabaf8d12aa897e7348b44f43301825c7e480dab5d2372cbdd5002e440622a5d1812f1bc9220ddfe931088e76df8922278d86e158ce7ccdef8b384443151c49c51e3cf9f0627fe194272748ddc27674e50833a9e7efe4dcc6ef8087712d2a3ae8f89b98bd931b69cb02e1fa4139ea597a6e8753db7ba152b845087139ba69aff7f2998f87ac934735c4f05370fc0f3526c4a91c90f7419d97e4a367d1806221389636995e80151c5b5a516820dcb5d666cd1c58c303d766a57daf2db0171de06c86e0315051347b48f538fa0159cc7aa5e572850701055a091516c291e09d91a7d780f89cc87db1e7aaae58d226d722de46fe4678481906e6b1adeebc01bfa505b0870b39ab7a8dc748e573eb934e50ce9668ccb7a55b978ef13cad6f4783369ef097ceb78e2f7c2323baa1dbefa3a81dfd7c35a534f16b84b79057d9582e7887c3d23ebf16b5da389a3c1544bd7aa7516ff68ab82c273629e9603206103701eb7000dcd1df897876316d22b730d2d5a11f89fb9d4a04f5e899c61a645102d8d11f8e0425e5cbba0476a6e2d8caa1c093920883e0272c00adf8e22a04a47ae8fbdfb473060079aa9dbc391ef13236ca7cffc08b081e69d61ef3aa1527b9a242307dccd3070fc33e0f395f4d31b2f76b5d9fd3dd1a5e882f64ac57fd72da6816b22c2c1d7b1c1288c3c98d199426e6eda91de3f17b3a7e434ff91f2b6b809a66af943aa9ce732f0a93c7231725aabbe57c9bebd5b3a6972b312b88690bcfb388fe0c1ffeb7e1c152ec9a7c71906e65ce1e7ddeef5616433ddf0f73946cceb39a9bc00a14797caff96c30c5413d173466552a2841612575d1c06b3e72915ae434a6a6385a865d5d52078a890cc51595e7c09f9d6d6f16835b078c6dec898fed9019d8976b053bcd04f4feb28287c83c70708c802cfedf0c0433cb35ac8a5dec74f94ce3dda95aa154efd10576778d0671b032fd233c523454349e4b3b6ab803090a18b913ff0ea01a8bc4ebbc3682d996e4aed74d64d04e9f3bb3ce208c913d156fe6b678ce5d5f1bc85a534454527ffdbd3dbf2391eecb1867f59512cd452a502dc9d29ba207d529a6e931cda8eda80b7aaef6394e3e6426fc5f177e92dd472778ba5fe7d369d6b9f5e4e72f0dfc7e1bcc5cb019d9c1398e23b133cfb7bd168af75a32661a37827d6188cafb63d11d94c0dc678f6ef3e5cb28948e9ffc1dd6e9271175cd591dd357bc62e88644486b800306e8ab26c29e170ae6b38cfddb190f9ee806dd415d6a719b565a7202086d966018a6c0bbacf691b5a905d7539e9a146c6468e47170cdefbfcd481650429f29d8f9173d99efcd359876b5f71f3b10603f00e8f01c6bcedd44770795870aad5312eb4bedf40a2e72f043150d0f9fa5c9e3214f8e2ad393180f1cf930151bc37dd446946c1b9661be158841def01cfd9fac5c546ce6458425b0db5f81cd38e4ef7b314a1eae272df0c59ebcdf6409e89122803fc1c4d12a29d9ee4cad68edee2eb9ee1c77467bb1f7e08b0de0e053dd21962338c3a22a355ac581808934ca22981d8517868ca1540171987c20933244d22abb8e00a82bbff0d2626e0421adb663dc59a2da2a19e9cc0196b6a981149e95a5c06daef251e2ca623868d90ee31f2a6195c199b8568954a8d59c7bee63981cc97298aaa9c8712b8385b1d9bf57b1e1352b0deb8ce284303609adf1aba90f738f097280348730488ed2caa5971b64b8b8e973da3872e286805c3ff7cccc9e4e1c38cced528af1b7aac91515e9544b1cedb655f06bd273023b1bd5cfc84d92ab496fbd90aff10119f4c230bff162f2a4c0c113e5d7b06dd103f3448f0c23ea63a54051df6ed23bd1a410537c968faafdcaac66e015298c06e5b34c320a7d7e78676fba1197837426dec333cde1a9f1caef67115237645b66647e81ce614c854d2a16e7551dcea75f26cfd261e5d131a878b5d12fe0162c978c7b82106e03a8d6dba59b5c4ec9a7fa5cdee9e2642a34e855de4ed32b53764fde1c8deabc2fae5ef86a1ff39f58ccd5de49996399a2d132fb50ccb50917f21af86b8a8e6b4858c4518718bbdabf993d778cfde9d4d95d869b387322dc88ba441867cf033354990d668eb96a114a989b6274c9f0b09444320865b2aa94c72fe7e7bbca28b20593d48e1e8556f7fad45a3243be3388b6dfec1a9491313c8b6e3d711acdcfc4e59dbe494d7ff57c34e4a2ee88c377dc350022546dc2dd69d56d074ecbacfbe5d08a6a66483d7b1904825b6fcc510a1814f76453ae5d0ff1705f35c42e1c772ff4d54ac1b25262765a155f27015ebf97b4cb0a05b4bb23c27fc3e3515a2ad9288b9677a13b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
