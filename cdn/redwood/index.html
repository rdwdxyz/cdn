<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11c124500b54098bdb24a3f00f582f74541e6eda52557afbd74dc2c1f555689af14fb3d8b09115597fcdf3d5913eadf244891cd89f0a1829b088d8551f2e247430e48e043a7a92cda4e7abf34575afcc600e0be4335ad92aed4efa19cdbe9ca489cf57a4838cd02461d0eb9da7574cfce87ccad04682be845c8b91ab34181208c34e4a8ca82a620673a99b954ebfc516c31fe546d626b6f7dc0e9fd1725b890f29ae3a30b3c1e50b2183f05d8e70282cfddb603ce7b782e098965e9a5dbc98d3bbd1935c949c289fc01961b2ef02090da7524cfe4c091fe3464a36ebd7dbdbe065ed400a2dce40acc5a623b943037df72e5545bc6f574d4265809bbc0899223ca26da234876af4aaa145b41e7f968b02d24fe94bfc073737cabff90a700e03900210e006f604314ea0a48b3bc150f192d1c6a44ee803a9e3cab97380aa72c7f3a5ee8c902422534093df5bd2e20cd849b04d2213d95df9fa758c72d0e1065d86ed94afb10bd320bd638e85450cf276c3c87b998f27f48a2f46ca3d9d04a79a8736e4e3c15da8e4820ab56751da7b2982302315764d71d38d188c6c59079600f2b7ac01dea76417feb01406259d12082e6737cc5efb0b883b802a129b4197940f30e7c3080680c193ac5ad557938973017f67d45f434efa5abc6d03764eea7905d07b6063bc93a012eaebe07ef01a1db1d9bf9cd5762347acca1603de30306143447ee73d7fc06bd09bd31cfb0436483fb25c8a7d62fe30a6dbbf2bbdbf11e77f59d526aecd3fd209ac6ce61f067fb41c665199bced61823766f7cc94adb21ac556bb2ff99f4612763744eb404a7719e219430cd6d134ee48446b60d6d08e14dc66864877d2f87353c78dfdf1e70388bc99ffde9888d93cd6698451f4cf37ccf3efb790d1066305e775ed9efda853d0419bd82f3d1af07a9a837e0bf92171630431618b838a904d107ad914735f34ff4a6fc0eabaf31db8bf3328b00963ad0b41b20419c43c09db362d90bd60d05ef7d82d5dc59de7f9e12bb8cec22573ebd325b95b08d54c65e0b81bf99aa34ccdb6ebf470a7deed23f0f28311dbb0a6193d8e704855f6fa62280762d7273b02e31c35b62f2c61901c9108f46f792f1c5d9ed902e5543bdc67d331d2182b401ae1b211db0078793bb5b1ce75e407fb20e30da33a463536634886a5c270ac6f870f4b633082a41a80fa2f62f8a70f015332b56a28673bb5101961d5d68a71a2af77d0e5d7020db60e6054b59b1d971f83a12dd859536edce26ce44be3120a3b77c54d8b42dfcf9e834a695da16e017cb61e5f3fba8af6badd44ba845696bbc21f3ba883147e6e244b4576671679dd0c273d4b2b96acffe72fd30d520d9d8e67475e4d2af695843184146571f9b28a557e002f746b74c57e2a9d499bf32dbabca3765cb5672fb0c266a4ca385bfd8b0ea702fcd7033c5785f1a1f743ee8a2f57d5683be678524dbcc03ac55cf832b6a798005811bf12d26a029a43343745b6d80718ce922501b91a09e013ce1f9a81818680eb2e3e798ab000f059fcbb9120f47784723c21e4b216d97a7d3f0143eba44856e41e9a80042135e8f23981a2a9ad4970a729268c6705093163fa21e3e87593b068b514acc927b78f06dd97f60410086b733731d9f2ad729025ef957cc29d4ff80eeaaf7c39e7940637be31a635c63f075a6502b4cac3621ae8e2069c5afd4a81e839ce845836f6d7e11aa41fbdafc951b29faea705b9f4b109d290d62a2405a283f17f439cac51701510f8a5325dddfc62bdc727b14e79919dbabe53410ab76fd626063f18270af4f94bbb482f1d9b648e73bf615eaf4395827968d8133f898de5881edec58d0c208db648f6317bda0f7e145c11403311f0015b03f00c9b1d5545a5d0a93b97cb1f2e5ca4d38e37a240804bcac21888181a24aa81f669cf6ffa5f76c4b23c3a826e93a4d2e58c027fca472e547108be9f1d1ff875802034a0e3b2db844c21a789c948a7d4399c9ca24b1ef8cafdd30db8eb69deed7da94e4140d1fa10ed25ee227735a1f2486a9ef53d51d1156d2d4204143bb943b9a4fee6176e7dad462eb830340a11aebb6aa78bd67a1a6e01c4a766eac0bb9fcea9b8db63b19e1b6197e390f103cc0ecf9401ec4231961857da551e05cf071ae450dae1026e09c29e15ce040e27d479b74333312d8a3a5c9e47402572d8116a04bda3f3cd33e02fd35d568f8d881ec1d876c4212ebc3b40bb63006464c0363d96dd51b137c13c2c181e9b34e4b6143e86848e40d8df2b91dabcba875aff6d00febb950622e7cd4297e71a6324f5cf74297cd026f64c5fe6f0030a39f6e8160503aa7754eb869471c68ad69cf099ed793544902172ef808b546e4fb68ffc5bccde9914bc808458a91ff3458548f3a0629fe2f223b85ed9d31f5035e6fce5c18714a0c97d0dbfc7930a6a99a3dc3d5bf8956467baff55ba6f88ea6fc85948403ff5762773daaad733f476f2709f626de292b9aa2e60bc7824bcb841536bdbc2ab55217cf72f9728d3848f5c81b9d356b79b2bb91e91688a39f7b2bf97f452b4d9adb3073522cdc0061047dda3811542f4c65704ffa53fbfaa3e4899ad0022121f894b184f8775f7238d6923608bae5820ed782b536ccb44d9ef53c5e06cb73df399ddf95d118dd443c7aa3b717aa821d89f946db8da3c1861aaf7c84d1843d90ea44b4d31b35d2048434e271edf82878b22c6ebfff68da051ef401283858821cc165c96cf0a0e17630b93327347ec64698b8066512c89f054bda0dc639c124f2dd3dfdcc3807dc844b293079fa81488662c84ff6ce422582c41b22c897a490ec63305666e2e06a3ee3003c41e650aa7a6969858ba1d67d21479ebbb4ab46284e79d96440261f1194ff77567260095285cfe378f148b7f3f2d74ac43a20f6ff5f578ed3ffb566b6cc94971b66de00aacbfbfb1741a228614ac3d6eda689390488964f6f4fb33ba59ed571d5829b78209d4f10ae1dad5c493347e85acefdaf54ae709001a0fc266e46d2fc75cfab80930bb896cf94d1a55093d33a8aa85b41579408da067049aa7d7803b33aa76a64dd8d70c4929da194478700d54026e754362141ab7c4544ef5d471eeb1f09a6ebbb5fc1847a6c88d82de57d0352bda681c49601a5be8d69317f4c02a64cf6667a9fd66ab1a5a49d0d16156adcf3ed97dd98522b219a9e55ba744da108cfc13fceb48abd797a39abadc62b7778dfba831c078c83958e137dbf918b922647bc5c058e46ea32bd359b585eea1f549f30974c61caef057a8b09fa4455d8e53906f1dd27cdfa1bebe04cc68d4881e9bbb87d19b5bc9ab79fdb7519783b69481378c6bc573f999af80ce17fd39e727186791be11746a1bfd6a6fd1b75dfc7ccbbe483edcbe6ddf98063d1402182a306ca1621c4e93538450f6f4cc630508e03fcdfe3511f64c388c1cbf4022a74f73a29ffdbc2c82db4a778a6c808500e876fccc3f33dbb129d3d9fb1cdb31b1ec75d47d35c925cf366807454d254a36262f32a880f6b64baf19029c0e9051408ac6d39c7943fcd6394ec77f6bf0e694d2769ab759fd7d01031466974a77204ab809d48c5aa15add6f5c4b2a90325d426c450a7500bd82cc31c1054e952b113d1c140dbe32fd86fda75c8b2e55f8592b0805db700abfe28febef3a91e1c3164728dba8b0d39df2392d40f58e67c670edda4844ebeba5a9d1b0ad4717be44c50dd89498eb4b856f2b073c8442a7ade540e5535bc0a2ead7a8dec1ad85a873e6785871cb6de07e3dc3b1ff12899c5631af57b702d8b976e25a8c27cbcbda87dee51067b4241c20a8ff5078768e26fa00a5b1414107ccbef7889003f3324e68edc9f65b1442c59f90b92ef9e4a6684c187f4178a80a560c6c4d722f79f20fe8198ac0ea13708f2c9e02331db23babb2fdd4658f6a32a645e6b80177801b88cae1c0313639eaba94825be7ba371234bddeb7a9398dc0b8f47d35ceba0a1634c718fe94fa13c2a0bcab94d93a794eeb922b03e31effccdf460565ec26278d9bab9a818d3ecd043c30b41f52dfc1b52f6558a0bc1b6f5cf266dfdc4a5325222354c61078cf3750438cbf6a7fde231aa26e007b61344efddf923a3542af9d601ff735812330dfcc4ba7ed94004678f2f0c7418cbc36273aca6a00b0cf0f58bca0625023fb55287dae4a104bbd111dcd7269db8afa67b8a49ca6e6995e98f62809786beccbbf354271fbde28443f76e23ab1c92f887f921628f78612b8452147be8cd20668c2f558c45b0958de8393a34557052d9fc7e0c2ba2c6e754712060b4ea9aff3887e4fc882e8e44aa7c4223da34959496df5b5044742e907fe9a920aa12c2ddeeb75ea531c339c97dea9f686d756e0c8fc50e057a3a91b6d28540d6ddea7944790a4933192bcf6d9eebf12b75858783f8e5f01049e81d7776d680cfae15658c328497f3b9f7b4d68ebabdceaeeff534a3c5c43819e269b5507c310353d5e06ee99fc6bf6cf6ef9868894335db53e660c027bf7128571c19fc1dab0b78451734966dcf556062ec0bca4ca2a32acbdef178519c10f71cdca365d3313d7b33233458fb6a07858e67092284974c4051785b1070823504824dba3beba459f6e5496f3bf3476be13aed5b8f7844bc68b7ddd305599f452b21e76d335239d13bc9e566f14a3a67b1de4e006b83de0d70624914ecf5288b27176d12bac58c7701c60a6754ec01376e6fb6a0d75161e0d03108b0ca99f7d836f98d51e87915de6a920bb435f4805bc9ebf516c3ab8f1a3c7d667008d3e71ef32aef926224fdbb97e1c825a73f4b2f239b77d5b3910868942c53b5783a40464a6c33f30338a89263843bc0a40de26e83e307100c52307498a4b34e8535ef472e45bd9edf5726f93f186040a9fef00f10e93549135bef5bde99d6e42e26e8810223a7fb116e69b0cf46fdc6b6f66007337185d4919b86b5fa424a6bf8189312a86780ab99a98c50dd0801484bbc6132055647888d6fbd02f4b48de6834481ab99484ea6c4cf318c793adab4d2f47d504161a6d81d14df3131a49309eb9716e5b82081f0aa738b135d9f459454e10bbebb6d24f7a2c54a6fe10c643da407f747652de0f11ef6d723b6f3786a6fb19cd349afb3c298328905e02184fb1f54c21ed2412fdf8f0d047c946a44066a0349038fb97701a566f09117dcfc5b8334443b09036ae55590eca33337e2aa88da4efd3f84c4ccab6aae11f103a93a9386594eec21305daeb91e9f36d5cf57cdbdd09007c72778e3ba7c91eef02644c92170e96527088154127236b9329671becde1341e6b2b7a43dd34a93632b993f66c97500dbf112ab0d8a62e7be0d2ab7d6db39f9359e218d831ac59108415e1b1c8774328e5867f137c073a56022eec1a7e33e038d2e9ee22e26dd9579bd3d8940ea57af5f0651dfa0531840a0652aedc8c3626fbab1da27a4a1379309a2e695db495b4e8e9033b76c0dd4e717d2cc8458ebec4e0d38c372ef8a50896d7207a2d4b788345f4f978cbf6ca45d94481a8cfb60d09a3ef89f685a8641650da5f31afe2385f0dd26c2f7a26f1685c3939526223a1204b924899a72b6060ee0eba5b38af1dc4826591b21a14d56b8dfb7f3f82bfc6197e83407eb786170ddeb573d893bb10f15002576cebdae6bb60ea0f34a0b17e200899c8816b364b3ecccea42d83ecfe5c5920b3b36bc1d8352de7eadb885d213b262d83196b7e01c8485803d82de858e03346e5015b7fbc7f3fe17375623617930e67df185935da5bb7aca581e53f11e9074e65526eacce8cba56034fbe9f56d566c38105eee398f25cff2bf1b0ecaed2c9ed01a31f0b455275a9b5c23093a0fd330820ded83deba404cbe7d82be4cc7bb561bb348bd5d20d19b8a5f1aaeee94c26523c3e2bdf3fcf8a3e39a82ab1e0f2bfbeba7a5cfeebfb483cd96d215068c23781f586944b92f24685fad0d923f580a9342c4fc30e168f134602f1749c203d8244efa13e0c18b0f47f8cba5632aefc91e37e018b62acfe5b89211a43f982bbc95c8185a60a9af7169597bbd3349931fc48d57adfc4aff4335ea22f789b1e6a8a36719efda00c4591970f94b370d7a229df39f53c4a69fd5c0523db0a8cb1fc75334bba31919d980d215acbea592e548f6df2d69bf9b053cc0d94a34243719605b6f4eb6b919fe0f0fad06ac1bdff0ac7db9e58312a00bd88fa426501f36881a56edaf9a425ee2b2baeb0d745742be8e101b242a240bb5bb91b1221fc6421f6208616561346b250fdeff2e285a2ade41ec136f07e687e33a03e50dacc0482d7ba4db7a6aaf05fb61d2dc0c5149d5f0e75458e66d702c0447fc58038a6da2002a4b3ced690b4291c17ad08f4354659fc46290b03cdf79d04fefd6e143272e2b238a2f5caa8ccdd3e7e126bff58b1e60213bf1aa9d71449ed051bd92dcdf16041631f2fc54b6d5a47f89859c3372edda90b0aca5bba3d1ef45d7cb310ea1656e2856810aabde274a35c223e6954cc46eb8d50db4920981ea7375f8bef5b5319db3c659dd4104d43c1cd7e3078a012e5e95e2b4cde336aadd1e7c638f6f51e3d6336fe09e9c71fc10f1a2f1d913e047f2bf2cdda6c160b943ecfafa396b8dcd8fcb13a0694643d9a3fadde36abd23409f04bd616f3802cec53bed330a225437d8714bb9f0036d361503633505c86e62fb99fdf7be43e420f39ae60b0d6b923dd2248e37f552a88850e64265fd8ac1beea344bde2cc395418cbee6c8ef110dcb65ab6be86f5f1571d642a632c1361bfc53790f565b535427589ffef873c9b822c0c22ada012d87e275214598754b5af6ccb73707c97cde3e1ed020352f489fd1376820d6244c6e8e79a130ebf6f7a0fd64487d98af95900fb12b02b2f9acf80090f850f9a2963faac7f1a273c4cc034f88d380700454f1a1302160038b9dcdc7dd4435bdc2ad3c0a05261f19513217de9fbd36988b7215013678c887f83be6afb8c8b2cc9e13099cbb17677cd7e5c7eccb71555d36c99af5204ae2a1ab013ad079dd0f14133a861d68f1a7ee52c0f3d6c7049e85e633352dd81f1bf1b9591de3132f731129d1dadf1cbc6dbdf20d6c4bcd5b4a4b34ab65b1225084ba1e65d9434786ac17cd3bcc7d6618d4fb93e9361e52ad3ad441ee01254632f514fdb554099e9ad783e2ff7316f150973bf417fff42dd859b639f9929f2bd2f93724bab7df6a2b7d9da9f969ef0e7b667bc8abbd7715501233309162c0fb11eeae33b59204e425ae3be9a21deb8b5027656748da23d9b976b401cbdae028fcf5ceb4c5188772525e63b2ed8e61e3812c6b0169d27c2038eca7c60f1fb20a19bdaa62a06a950b2f7a41d062dff9e90526d657e8aa415a158ac07cfb7c99bf7803e0f5375fe56d7c6e6b3bb03948f2815071293c6baab75632742c665f32c79fa1772904cb127a2817a3b68839f75881c95898daa55ea78b2baf60faf107b0c5e7c1f4217efaeae5b90c2402371f52291536c20377e2bcd7e9bfcd8da562b9fc138c84bcf31cb2656d4e7d05112ee97a2daadc7baedbb50d809602e1f2f1e9722f0ff6206eb746ad90fe4e89dc969284aa9e03b92b2bf824c9f52810b829328fa793295584a0e5a06f024a860b1dff9aa1211ea25fa9f0fb5e279051892bedebcadd1999e1451d8d1d4479aee6e9ee480f0867887995f3a331b880f0cfedd5c9d9a7c975155ee65276c149b5bd82e873a9f5f64b6de25e0991e76bd53fa4f46144519180e7017f9b7f2cb684ef856a658e89cfe6f9afef2274222c0e837081d847521928029639cc6b919d16cf865386ce12dbaba2907b7e31d2e586bac418cd4e2099cc913fc587fb67748e0462846bcaa09ce2985c39b250662020742d442488d46657a5e83e2014145904dc227ff85d6dfae9d134cfc1b6fcd09f38f8b5714b07e971b91a3de3081cc8392e3e9cb8b25489f8ec913be29ea5bf83a883a2b932461eae3604a7e4eb151d3f7138b945c9ddd1295f4b4a523e7d03e1efb82d18260134f1a447792f8c4981bd014e56858f54dbfdf57a256bf782f86e06a4e1ef672d7cbc746d9657566c0f8446c17e66f0eea1468e8fbe2bb71e0b6c09e00cd2f6fe6b02bc591458c34ea3b1cb00e752de767214f802302ef891312279e44558d484ac04d2832ccd24a19170551bd6acbe163ab9d8cc2034d9e97cb2a0f6563086a796815ed2229f87c962894d4f940cb55617059351bca9a92c58724c394ceff77816f14fb16b249eb19a92ef5b2b5e650dad061207bc9933bdfb338c2ec8f4cf6111ac0c146da20cd97a9a01035372775b97552401c03fea6df863dba5d1df2d8e396c2bed774fdce2ca313af13a772dd2938aa325844477073208e33b6e9c880b105000316ac36708b6e76235ac49a31be55742003bea9bd8e973ddb4a03ad81ea529580ab9793cdd09674e9e2c250163d70a797d320abd38915c40ee6e5fe969d7f9b7265ae482e7a8f618125a1bb1cfe7f35958caf7cd22d9e357c4df9d90a44e569782883caa4bfda6380404370165a43242404e961039687b0810d63c5a12a7188790217c99d81b300a825c479deb6b190bcd1a2e988943c825be4a3e3689f7cf5940c193b43729916d28d274085eeb0b34c52b89937f26e0c415668f694471b0692dc5e0b7087df208a2b3c4dcaf163e9fedeb56cbdb569601e2d881167dba371d9975f2f235fcc2b96e1818ba51670ebdc27c65800157a116824e4c8e1253858e62c191df9859252375195f21330a17bf04eab97f61228d7b2bc725dc9206681d15db5856b514b1b17753b0f0787dd978356a7d8b5f96fdacdfa8edfc76c31fa6d38033dd7f1540a64d8a52fd73e5976dfded5c2ae0b5ac41f6f709ea11e4d087aacb721331358376da73da4ce3ab66c0b99e53b0dcde18345bd9c0ffec009ae8e6db9b20caa316bf6a46b65a996ff60d46bb3f07135ec3be1272410d393a6ac4c85097dac2e5491a9392a2d44a5d860eb40c383ef75a316ed96862169c167aff4d48186131a2f8878dda29cdd8f28d1fa944848802b2c6cc92a18b19ada71ac1696f0cb2954c1750210c478e2316d7206e9029947abf2776fa358846869cddd411c7b254718e483894f12b9699e9d6c60c850f219f298b2434d49e8435aeeef4f7762a7055463fc535639752976d6df5b7b7fd7d7951aaf20f87f5c52e965c54cb022466c6040d6f24e4ad7853b7c4a019e2f5c226ad45abf2078dff12f2dcdc2e87b25a87ba0d01953a317503fefaead342e17d2b718e9e617f0bbcc23d86d14174dd85bc711b4b03f4cc12c8d481fa3e2f677153d9064508f2e9f7cb763bff8d2bed4cfe6538581e537a937b6a612223135b2ba22b9254ab23f504258bfca585328158563432f70935a0cf07f8bfe1cafd6e438b91ae6d4f6a5deb455d1cc3a772510eb60057e2ff2c5bff333896e2adf932a449cea2f77f7866653cc2c7231e79a1cbb95559a758dc15ae619b9ca2cc80722dc5790f35922fd95a521224cc5189e8e49c245bee617c6dc67faa6a322889dec501a4e87c2e610256691eaab96d8439f9252b9e26e580cf60cf8c7da11b239efdee6ee555fea65f9cda1e41be83abe60f7796063a3fd0348f0d00e8e2b2db9353f29fa107e3c012219e7ab23dada1046f0ac2a1fde0760b6adf07650d814563379d2034d45b0f3374b503363ecdb7e2a80ca6fda83e75f23a4721f49f498b606ac59dc46d19da532844251d196ad3e404554084b0a1db49557d39b97999419c55cb5d7799feff11d97c4eab8adb8f45c14e17c6d843a7e919fa52c31120331b1bc5c8a9dbe276d391caaa0855445fe696a4722fee3c109f0960866ed91559151266644ac896467c60ea36353164b2b4f33643869406f4fb15d430d8a23f24cf49f2037774271549eac04eea9bf07aa85c36f04cd9063c97b9d784d30b275bded7a74ebe1827ea76a2b1fb51844af8547655dab23563a26be9b20d2a593eec07b73f106ce8142a82797466e5ec7a26dbd9f96e71283134f35f581b614d327eddf3440a289cdd088696cb9f95fb88668572a149e3ac660cf6b42182fabecdd745c53ee57dd8d6cabe2c594bfc963f2bdfd65a06fe8a2abde3ed1d822f6f39bbbb2417b1b6fce3919cb9860b85e477d2bd2ca5dcb48c79d7159bcaac07f28f4d9378ced596fdb122e78b68cd44f361177627e7ee8dd697c9455b9f6ad95c76a44a1bdda2509a0626b5396df1f994593daa0b0cfa460d0b25438c0882562eac5a280436eb7ea32986c260434bf590e5a859879e973f25fb59467dc58111741c1b096f8660d62d8d25aef3427605f31b276829ab33301de1697aa1f60f4ecd2b34ca06b7c7392e53c2ca5e9756453c6900c4c3d25b1e068bebd3438e7f7feaee8f78e7193d70a177715a111bba07dd99cca8b0f1c644dcc81a4fd1f7d331aefdcd5062eb7b06c49d1011df0c5bef30f4d3174148a4a2347806d7d8e6272ccbb9fba7c94f59a8bbfbb68ecf0f69c43cd6c5523924a9a6463692510bd81af954561f877622191a93c2c702aaa66a4b2b0a42412d6f5493b2e4d4717355584bcdd12b85361cf6c58e1e90125e66af420a5daacd34e52279cf436d7b7a4e0d220a5f4b04cbdc89825aad11bd7be622ccf736de09aa937987b7d24447169aad0433de5b265e3460052a48e6e18e4bfe23752db34d0c6a5c404d795db25d72793509bcf424ffb466cc4c4de291e2d24b92abf7363d868563991a2b78d8b9a19ea2688e55822791d77cf4e1a5ce83b5f7f026dc9821c56007cacee7ae6105db4a7f4a55cdccaf2945655bff6e585a0ebc7e50aa6f4dc5281d6a5642dbc0fbe55308a737ddec9d28641c868c39eee4005e74c5fc8c4c0877acfa442ab0e1359b090810749dae9bc26cfcb9f80203f8225242b4a5d868efa05f654dcf6a6c642ea9f6b3a7cbcaa58cee8058af1636daa883e9fe2ff7d1944b9f30a742a3d147cc5e5bc503ab5dcedac2e8b576f354fc026fb6f05b4e1a873d4c36344e8698c9b9e813920fa00b717f3f21be08210431eeedff8ef85d08bf14e6eaa5d008614ad0cd22119ab118377e8adb741c1d28940e7669335034577decc1f9254e8d76449f1bf4d34453a8a842a3eb9eac38d17bb1e87055d32bd1ccd9b946af289ee098633c110299706a50df3a9708462e51ccee6f99af5bca908f492b1e20fdeee0ff0a40cc853d40aeb729287043d12d96f171fc4c8a3927e31441a3bb522b7c79e519f6f66854eeb46fb073dbd9e197665a747b68805acc6657a811880685ad977d574dc90182eabaee5bf319d25e15d3087a2b9f000fe6e672b2064e655568681852817e296e9c1b879b821fa52ca7dfa357f2ccfd5cd1ed0b5f33c284958b9a9b378c912967c6b2d1437e0ec72f644d7e4ad0185e5bbb798790f824424d2892efb9150f4e0380e4c82641157fa138ab4fc31dc362a4f72845e6ef107e9830099596abcec2b5b8c763852554c9e43d40f212c5e1ff00d5cf44ecab978e20713ed9bb53b545ae0b649e71512d2d9544a1d2c489ccdbd7e55e21d8a004f843b3d708b36c67f6fdb89f0a06b3dd1d7fd7bc5470fd1de7bfd4a451249cf3947c8fae68d2e91903e25cb2d6e37438aa2a52fe317b90fdbbc594a3bc57861c7a58b91b5b948fc825275ab045a68c111074b2fb700e29f7653ce62b9baf843ffc51d0a587e39c3a78d188683e543aed8801adad429b5ab86b43d88d4be6ff5967f46c9ab7d625aa5efc0a0b6fe14c80c54c6126ae9f775d46d2ddaf4e43d4a1c197c4838b2910cc91dc60ef1131173525c74817744bc55d83859fba654a8ca30d34a0150e6b7d722c50e205aa99805206ebc9c2d1aca0bebd52e26b3ca2ae1310f942f903f2ea1008816252f465c9a50613de14e0680d7c26c6396b2784774022813fb36bb5f3cb89721dae48ac4c4b783d3dfc5dfd2de34dce53df497433088705f5857002babfba74fba14aa92980a7f281f01f37f10796fd4fa177a1a7083e21c2882951511057c737a2ed8f319296d8b3aa11784055b3e88d44e39a844ac822e90f989cccdc323934628a2d225bd67153ce45f69951122110eaf2dfd4dcb4b22d3eaca2daa369794ad0c5deedf4c64b5f97ef989096d48ba3fc7339b19d9c50722b2c902f1f9734d98776cbc8caa779d9e84e4e912178ed15e6ddb0ea932aedff6297e8234c756f905f26dc1f27711c5153f2eaf862e64eace8198df601943cdefcc7e1f8a5e671db4e860a05365404297d37ca72fc8632cae7a7949f11cd0256e4706e7edae8b10dc9e6769c755d54181c9666f96445e46eb8b4889bc0b054a1dad7b407e51d3e36f6dcf8f98f48cb92167c59f104aa7f36f38f7f2b6dd18473506d6460a247a1befafd651aafa6b0afda0715a404e0c24698744b37c5feb5dafeac00d618d33948f82c422b05c546e8de0882e2677293ce6f00ffbbbc152a1319366e4072708644ffcfc1c49013cd61b23671b6ec415c99d60323e817f4ba8ae93e7620435b27b5f8f67b1f813d8879e56c0b44be577884192f433c542e38506651bb6354f343f496c2fa44df89783eba24211345368d8d8f67b586a9f0038ab730b300165042d061e4499e37e401b6c9a899fe600b4adf5b37c9cc1ba39c2d88aebd79e798dabc3cd33819466215a15bde9843f6af9bf89776154783e0f4fd3d3892e08d9931ef822bfaaec27899241509158714283116590f09997b755364c10dd2fd795d21457bc58e81316fde506a002cd204b1111c98b26fc8fa619cf3cc4038edcc038dc91a5128f19857bedd4da118fdeca8c208ee6edbad4595b9a46227bad30093fdc2f4024b3b24149d213d54197c4f330f3f4844810326fa7e0b9d225a7c7e01d4ace8e115b2dc613d7d68127f6998e5e8db0bf8e5895781ae40afc5329791db19b74073628d54a3ae17a2803e76143b89e8c29d8137de5c1a4d67d670d6f15e9004fff22ef610ab917dba83e6a9e46e2d7c83793a9b3679bf0d7ae2131e2101d4cff026e8a462af534ec608604432f7ab465627178f8c005c5479a7fac1e5236a614ca213d5aee714f7427e75a6d744c29f125ef7acaf83aaaad6c4aa5cb41a4852306d8e4c274d4930dec9ceea354bf35a9f7f35182e1d4fce95a414576a34a2180c2fcd724c98651b6c14e477efc1fc6dd0f4a01fce7c9d4c5e6449556e82ed7df14a62c538a9ddfcef7a116d4b26cb1de8d3c26604fb8b7cbdfa4f298494fc0276d5c89634856f8c2e0ae896e2d63ef1440978a4517b0afcc16c5e5a4a0a7c10202f7e8850f3bc2392eee979ddea0c2fe64b39c2ecdedc9adb9b4da8458532b8c5f78268b4315aadf85cd6ac62d73364b4245cc9a39871e8f44877df13ee021fdf5c40b39eb489f4f291b0d692fcea071739429f3926cb753d5058fb2cb931428899f900a8e659896bfbdd43496b57737ab7af144aa6fb214ab3aae9218f91c3c1ccf985f1c81fdf7f73b67acac30c78a77f4dc20955dd1e411bd6908336340e71e59dedc42b356450d509ef2aadf7a9af7eefdd9e0667800fd591f3dad507c13b74c211d91e0d925083fa24883666157c87a1ae8c23c43dac9e7ca0ce200b12477c576b62513191a576d4518a48914b4b6d0b00989b1fbcd1ed79bb59d0c3e05472444f49efde6bc78653ae0785388eadc41936d4421ad2d84c1bb1126e0a291de6151952970f74b24dea02a9b4250b2b6548c85d871f5e78dbbc020cbd1aaf67fa48f7587ba7d8b095ef986f03290e550889482aa2dea81dfc0107aed0d6f38fc62e3b09d24c10d6240f15f2d2047048c848e6e9ab1abdbe5fe3583f3b1033c5f249aa316ba3b83083601e3a13cbc76d9f1299a1cd8849df2f5f205e6ed2b7b20906062908e5102a488df14d864f002f4f82af5a9adccffca1f4403062dd2263c228d49e5e748a31ffc75a00127126b9a5623db860518163dcadfc9d11f84796618eaa032ed6c26438977d97fd9872d8221c010b1dcf1f39ab411505472972f1a3602a1c9055970fb596290b367d132ad5ca3b062ea4a24aa1cce91548555cbd6fb72f897bfe48bfa1bfce2074dedfe23c099f15aa6357da862f1af7867605f2211deaff643b6a8a10bf547caa986b269ba2743e0244d133ed62a60e7dd39c9d46983880df5bdfcae60ac009c69938110c209a604a11e077620c75d55bff221f0b32a7132c6c5aba31227c0722342a3e158012d8b3e9fdf949036cccf572a48b289af9b1af3b904a292565e110732017b33b3e651764713dba42ada2577ea60c2dcef7dbb21557402c6a7a0482a7b5f800cee3294236992904e2dc9ce565339365cbe34ec59d4c4b85bc61239e08cf77e4c0657846a59b76c645e19c1f2edbc416e68b3160c705c86ae057e2aca6f403b594172781a54adecd603456f9f449519ece0f889a7bfe49cdf2bbbcf6c4f0f76084dc96175b587a227a6981a2be859700c224ce0f44febc21ad141aae0cc8bd5d99f18388680c1f3fa19a6946a454667ae109693752240ed0e0e3f3a417d45579128c5ddf23e0e06f55f4ea28bfbab9fa316dee02dcb2a8dc31308b175a1e4a7eec3a1d18a22b39b968191d0df02b42edb2fdc9c42a57e7a4bb6f088d2aed66fb1a8beed9209ed298fdede4124a49809d81c7a2c3cf6ce7d2ddf323b835a601a856e1cd3321fe7c57b80855823a1f588b4c4344f7ee0917c45d981ca1f39db828f98f13c778f352423707f47fb8d22459096d9946e47ea7e2e9045109f122b427559014769f22f79d3c1be242fdffca33f4f7e22d9616b285a8fa36af735fce7e202c003590c7cf53ad1a16d656ce8a71ed052d3bca081980d1d62bbc4c55a38ef945652d1d726746ac737db7ed80ca3c7fa6ef5c899586254380a24ca4a4f9caae42ab4d3c6af53a1d62814edec3848c930c6eed36c92ed0121a4eb2da2f61fde36d1109359b878cd4de36a03cfafc2fcd1316fabcc3c46ce2d362b65a95a5b64211dec814c0f6b122ef0a492f45c527ef3c9088eab7548e928175cbf5174ec915caf477e78ad310406f979af0eed7310c956bdc9686107fcaa2bb6538826eb8e2e549341a073c0a0579f63c06ce0f8ab06071e98cbb1c61950203ad7bf13dfc62346d55ad65fba6cbc1ce12a99f5fd5498c8f7ab0fb00d3cfa426b6ae18a349f7ab22b529c0f755168002f62e30d7a713a5fcdaa61cb7eb4c2160b4fde8a424ff9764f96cee14dd53e1fce46de4b1527779db4022ce6dda3b69a09d5ccaf7761c82d11aafafc56c0c332b7c1b4b8565e626745b3a90cb7503f5e24b5b8e0edd0fc969720165d15ad80c674e360d518b4c5a83bb3228eaecea43bbbb8cef5983921e5593a9f444d9d6f4c4ff245333f310ea04ed05a4071683b710da9a9529b2183c9e1e14f69a31c681dca030a44eb649fc9e935e0e849c03603197d2bff3264c382ed8fc0a5bbf957892cdbdf205a9af9ffb19c3fc844e40828584a0dc1b682174cdf406b2f5cfe9a899d8950d741d3bd140075663038313ecc645491f3bb4ebd2f874a1e78ef09b1d2d24691ad93cd7b1e318ebd3a6bc8bcb0e7dbc60cde135ce0be900dbc340fceec82aaa430ba23967463e88c8953c1cf32e3e56b721e0edc614bcb234c6801a1d5c9ff8408f3b3ea08ceb871fd6da8417aabd5e85f963c0f4ce59feb404e4d42ef8e6ed51b527c80a273d32d186f9664b8ddafa0308a72bedf3c317cbb6774d3a9925a9c435df86462c26a64359d1dd27e95107d03d829dd932d0b0635b7d2a1b3d007a4614c81db890806a0cadaceca44da88268471933edb003fb858835d7d13d9e2c2b5c7f27713c0b2454821291676168c0d57553975c61cd50bc5e0f8c59192449fa7e5d26d5f87cd35fd392f7033d873edbf5f6062e49fdecb17e800917035ab8306f11fd66dc32518be43838ec23cd7d2c71e6a5cced00445328f24a7eff1af3a9e64ed2b8a1457ee1d1deddca78a4e245be311d462081fd02620250eb8c7b4105d2fdbd0cb2973a3ded1d1a153b548e44a7f8f99b4726ebe81b91d0c3bf33837db6cc3593ccde58e942a59e0a57c3cba8db48aaafb2445f215766e4599d843fb5fabbd27cf0e8e29e69ef6bceefff001cc4e2a840258b7cc1de3b63d013621174649f7c30a2116e209687aca5af6eefa5d1f11878734c0705fbc9e8acfd217f7883b63fd8d9e15809e978fffb321755724381865a933c90a539504c6b628e4759920f3de89bb4ed3e961986242944b05c03a34e1886f48fed8db6a288c854c7a501bb0b5833275ccbea2bb950ad6c4e01e7e4bbd6e65e491e5c62889f6214dd28067baa0a762d85d2afc9bb8b821ba163c44fec821032139f90bcfd75a1788d11a2fa4dc30477f8d7396b347354dbb2e13c9c0957aaf35dcd033fafa445e78c56eb78f1c769fb34698f3ffd577f38b3ef5ae64999a73666ec50f1b9e66c7364c6a4f782dff28f04630e7cd9ba37d4c2ef0d655b5f6f912c2b86d25c01fb914a9cebea2c5d89d2fd8a55da8b5e6add11fedaeafa62c8c35b22a78b5505ea441392a7d355f3747b628da84a92146fd9e56f014b4fe0bda213c32c25d281e9875f128af0ac2d462baa920332ca66c6dedd46223f2f212fc6d598f53a9d3e073678aeb60566918c6a70761d2d8555bf76449580346b7eb4f916d1e0fffc9ab143d67a3ba46b917aa0070c5a410599de7d2c1bf40b923af8ac3e4a96d3e461b70f32cf3e9c9714d56d2b4371ae26be442815eb7cee27e3193dfe9549e2d411c0ec435cf1cc1252b71e113eb2aef4696b6b222947d78a5303e98dc369dceb1dda433bc5ac747f52547c845ef60460e60c3cac8756cac720c2b0a8c0f7109e8616a44301642096b66aef35f3831959d8babc01c06567fe64c1958b7b86cafd24ed5d0b43a12acd672d6410abaadc3e297c80ab9213c247bab349a468778d81c35d600cdd09f673b820ac782f6752912578d2c545e6823dbdc882919a65f67dae1a5ca7fbb23682991f733844f281001e924c0a91ae9cc40e43ae598f206ce3d7f299fc4d7df908c759ffe8ef58168aae954fb1c46ba5de845faeee6ed61f71f1ac2935cebe17ae49d5313bb5dfd07af14b2d5d3ad3af2779ac382595dfe9b89d2d2fbf321529ed91bd6f205f745f993e15145713739f210c7e2787013dc1b80ea6c02e962f28893ec10b295534e3cd1fb3943ccbe3c2a8d27612747e92f3de2964fe66d2b515463be57c75cc1234e66dd7b75db412aaaa0183911975af1985d86d36c28c857572e050dfc972d17bf1bf1e0fba756f574c6f738765f77fb50248cbd5d4a653953b97a54663cfcec99acbe6a9802bb2c876c9b9d38941b28e5dbcc082ea93ff3126895d5a47b19ae85b36ae7e82639ab6bd8c2194e35d3287fe546625617ba0e5b782bf174947fd71172c111ae0b8a548387b34b3904ea9adb2d0974781ead079785a3c5e2c6fbeeb527c1a2b42bfe2af8eb09fa5416cc45e66a12036ece29e8f7e4ed1ab15ff5ce3be97c1870b60708b49df6a94bf68ad0d178183a8e24e521c64bef9046248ca4a88a72a434464e28dcd22d1bfc0f7bec80b05e46b3f7d6ac07bcdff0e74a2b1279541ea4c16775e7cc12513da741a75c6bf5e5053cf0cd10589d9ca4c37a63caab29ed528a115b46dd049b8416d06f59b6179a4d281a4807310b0f798ea147de4823698f6b50afafffa41fd76de502210d5ad1f5573b0a3c04cfcb785394e769f7a785067fb5cc64be3a618e0d98d448bdbdd8532b830f3e50a5701c97368207bba17f9dfa7d5a82cda7af1d5882c6eae286cb955c3d541b1aa6330608799aaf32e98b9f9dc2d58dcee2a1ad09a23cd2e66d5bc7fcb6545a162208e3f06ada81c9cd4abd5838235e75a9715135bc0c171f971682577690b84aee593abc81a502e09ea5f100ef47d3ba8b52fcb5fd8ab00bbbc4edfe13e8fc96952c3f66df98619086dd9bb157b12a72b9500a3d3e6cb6cd932bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
