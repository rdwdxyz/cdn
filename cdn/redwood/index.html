<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf9bf6640404a50168a369fcef213d786a4dbac5be2cce7079fe5cc2349d4140ef1602d7120c538c4f51530932bae4af3c7836ac367a5d5d2e10b8b3c086f9d95586d6df1380aefb9f35cc9180819d3c477b84d6b9ede553e231e5c38b663e7f1f875659abd54048f1e895c09c641560c40a224dd0110febd6d30f21427ee8f825ecc1ba43042acb48f90060d41d0cb1f9e2813e7cc81197482ad13bb4bdd28c3711ef330d1c578a9c5cc39bc48a2dabcfe212ff58e3989a3d5bdf5ddc1be671ca6afdb455a499883f4173e797f52e3b961b7b4db8345c1e8b4f4ab12c5d9ea7503b1d91b77c2dd877ca55e7ceff2834f390341ee31e947da87c24e430429219b31d06c92812c22d9f9a740a2a2e3590324e3884ed271f728827f95b262a42b2e72d12692597da3ddabded94e1eb05f839a84c20f6a97b2d5337d519b390d49f90391298f0475c93c50380af6bc920735aae456cd3c04ebe7787ba0d4c4d7a58220db2dee18b73005ee813f8d9715a4114ce42fd891d833f9c9961129a0d902cc8a728eecc277a55d76cbc1717d69d00991bbff5157665a9c76e68dbaabacecd878d4df160333c0f85f2b93ff1d97d11a7caeb41d90404df74e5bfab2985341c9235320e0871d570d3d849b36309a30425ed079c83dd381ead723e90b92690bb6dd471387635731527324bc4f061c254c03eb28a2b2df54cdd8382b9ccd423ac517046860c51e52d06e8e969d04cc94782eb8a45a199032d40b38f26a47c258e7722f28080765dd9269f0c05897a8c4978acbcdf48772545d623ed3dd8ff3da3abf578ceecac1a01837d3a3ee7f54fcd275a4d1f2bbabf9c744971bac7ad05d6bbc4405a84675b24efd6831f92682f5a35590c6795513649775de63cdc31f87f21f59e0ee1f0bf193789e062e143e1ad603733f7c71ad321d6d29d9ed952c0abc58bd452323532584f6fe570a78d6334e051fd04c99afd4dc7ec950b6cb33e634a42dc7064a2b836636ed45d759253149f9ed40882f51823aacb4672adc2e52c6fcaa9715e45aedb45d523464767bbe72f7678aaa3e9344f6a76ca9d96f24c544696788b2470845344ab56bd23ec150946e434d82b46a10b7900b0543e87dbb767175639cf996922e42f180b4270453fc3790b203523d32b19cf13cf554e520e57214cd421d5ed1abb0dca8313a014fa0d009276046dcfe3effdb2d992db8d16eba9b6a1aecb54ca091506c83895a0c2efeab71b32d868809a1474c1a4d2c344968bbc397badc471bb32fd9b37c6228159d7a184577db5dcf0d3448f90393805e4f121de34af8b9e12227ae560daa47b0542422cbe57fb0ebeeea70268f6bd2f98357850d9f4e75ebad76db71cc8836819b7a9160cc3eb8497299817c27b9c7b6c52c7b9f83f6bff9c63691534fe440902931197f8d40708b6283de95da91ff87b553fd93214ec687367d42eb8d5f66dbd97119eb75600e369441dab7a505c6b3755929e748b85f723a7c7a8a6b690435d57b2c78c922252a67fa0a610768384865130ef46bb0938b1848a0acb4f423300941115543d3310c67b712a6a72fd770068b24a4ca7888ad881c8d3fae310cb47e20e432c34bb5eeb0912c81e09124130b90b7732ab027ad49cc4230602679c6d44d40a213fe9cb69f88fbf01d92aca452ab9ec0a9989e52de4d76876637184021ed1ceafda22fc3dc4af9ffbe91a947728cdf87e5daf907060968c59f4da20199286584c9c3f047340a04ea2bd365606ac834c5f0a52080aa52afe8444961c28450969c46ddcd6c5f128da479aa9ad329251431f6f0733e9350b37624ac014de974c42b415e346d3dec1436eeb1474bba2f58314f3a68cf21df7229668d2b1b67f8bb05401ead3a7e8aa029749fa53aa7d9200363e620c5ea76f31024290e3cc9ad8c751b2073be4586bde22f88347e537fb3a4325fd4925821813867a2518e5a01101411992097753dfadaaa82c7e5a97dfe252d2c1193a472a34e7c1c831060d21b6fcc26d6c646f954ac8ef74bb18381eb7ba33e2744f4c7f8f6176eb0b402ce7380615e2e52ab3220cae7e35b5d635e5337696c60dfd06a209761da379b17180fbc4bdbf0ce140f220eb08b138f60a3c4944951a6ca87e9eda5626c9d1df5abb14bc123e772439099e1b1fee1fc2e91c5fb216a2fa0afb1984149ba5b3dabbe065409a066a73310dfbb001f2a3e572164073c1b8eb5499e8fa5da4852e2e80e0f5b359121d5f7d14a0ab4f28d793f51abaec8a5ffe5dcb4099f6ba1ad4bd6abd34dc767027672dc42cb12da6079d5ed872b0fad492551d84a5ea84f55e82afe85cc3cd979d92561710a1bea6eb29976fdb132d552a804a9b710c6b0b43aa938a1fba10f2ff374a78f378028728c8ebfe19be5c4d1b8226061398e20c05197415720f08bae4ab4ac1355c5071d54d2a56adf513db34c8b2324a3d8e1365c32df828de85828796c510163c29a713638ae0a4818a848d1d6213c05178958fea8fa37e2aa4aad474043af60eff24978078756e3c045387ccf6a58f63250a09a700aaeef934e0b8e314c08e4b280718e268c41319075c18111a31b748db905c8e9fe156492faa776459f04e547f75081b787e88c95bee04b1305f35ea9cd56918657af018924eedd2ca6ee1da6537439c9a896c79ef3ee2c43ef313d19f0036f2c2455542fcc5b2137fa1b38174fcf50dfdebdc94b64cb9f3dc74c7243aacc40d871f3218752d3da9d7bf46cedf7a70cf10dbfa623047962205f4d16a3ae8098e2be7f2bf8d1535d35087d38cd3d8d3137c69b75fcb306d366824594e8df3bdb669a2fd198149f49aae91ea7285b21a600605cc0fe597bcbba0135a2077a71331eee47ea5e419d87580548b5237953fd247c1707441623a346fc639443dcccc94bb9867af054975d9524c003c5fd2fb2e3cbce80e4e8e41e71ea492ec94eadd957746042f99ddf26eb8c9a24ad48de82f2d6894b71e7698517b51d2a23870340599072e2df7b09e0d28b55d76544bc38d11b1c16a9a78d8779e9a843bc9b9d17b3e73940e919f0fc7814823e66254ea5351199f097f72505c27dcae98692cfad347315d119624e240eef6d95605a4e7bdf167ec113817153908cca9876f1bfea8de04865090e9598f283c88907ce9f5d0d112263f71621ff0b2ae12a231e5c0912e2065461fbd3f04473d682cc8cc074560861ffa765dee1a6a1dfc46350601a998783fe6dbe28f9e9f4fd9069b2a4977234d437067b6c3f009a9be73b1feba6f5a4b28060a7b1f76cb356324bf12a5b8a81e2e76019fde0c2236db8bd46425f2636377d5f0de2dceed37813c2b587d5ae9a320aec7acfa2e42304c93ff2682611b53a31476d81a24576a5fec8d82fd3baaa782ca2beb41dfb0eefde4b6b58c7a7f67c048f956aeee731546f824f425f66ca2454f36f325c05b743ceaad086a16dfa689016582c224dc31510da7efbc31fe9c72f0d208b45f264874c9c37f0eacfc5c8cdc3eac859c916ee0c3497f63a36fe1379b7fd43b5ddc0326a3c0773535f7195d88854432d8b3c471ad57f9e127b77b95567bcf2856b83c6f329e939df5e30fe744820c2ef6d35244e9d5b643d3fd4b05f1029a3df695d1941a95fe4d2529633d4b3dadbd9ed1bdddd72dce1373b30ad39a9a69242d5bcd702c9aabf5bf6059044e0e34320aba7d6abb99e0363ea997dca859fbd6212bc87f1ae0644bbaf3917be63f68c0af5783093778afc8377e278dda46272ac2ef192b752d0778a9399804bcfdd9bde68253be1cff04c6009ba2b118b3070229406c58aa17c602d7c4ddad7ebe4a8a7ee52e6a673d1dbbd4916421dfe5df949c77d7421d5f9b6ae923c5b94e748ba3c88b7f2a597e76249719ffc38bfcd13165590813c618a05a42dae3c0128d181f0a947e3911e4e02fcd15e2a2bd19900a6918658355fd63fddf379049039934ad6f29ec0300bc521723106c2c89d8354a99fc344fcefc0eba2ef72e87706d706231c59b1b4181bd0566b34708dd2002fc69746177ed4344e51a393ff855dc303c87db7eab3b66526beda7713cd1e90d9c94a3b2b91854b5d6282bdae4767711342e717b5eac8647e5767b8a4ec57383cc9f09229b8bd0d9a762a4701b55e602f86be5043c16ef9ddc249082f8ff11f699b8ce7f390bb949f1cf561a29016ae1255ad293083c881508ba6089c9c34fdb84670904cb964bd089c1bdb60bd81748b92f78979caddd21b1f4ed77bb0f3a9fb91bb2f0916e0a636fb559eff11e0fa491e428f131e57e2b5b7d3cd7d83abf7a4261b16bba33bc459ffa6fa34dc5a5c44b043c85a1eac72e3c0e1b23c64761484f0cc66b58d376294b12af418379fb2273d9ac439f7792113916a4c683f7b024f0c519ff7a671458210e4c45d1235bc0cff831e0692e5bd13d87b5c254f7519dbf6410fa04ab52964eca73fffb937726d2f5ab8bae6343f16ac2abe38d4bd237e274dd25b63a1fe925f22ce805c7cdcb0743286c9df2516cead123d57c3e54f2665f86c1232d1c601c2931088c8b3b136564c480556a710684b13f0648ef3b36616c2b3c3ce1309bbb724ef09a5a63a0a5f90e93e88f8e7f420f2a91015a1e911d9f395098ecd596e311cc81b46868077da336cc47b79a480aca414afcf2c19de8fadbe27d6499a2d63530887192dd82e62103ef7a10003b4cbd15f2598ac06a37ca592663d533fb57252e2b7aca704300f42898ef6f609a76fd7acb0eb68935174197844e9ac7b003d417fc1739d74286f60168feca8ea58d6e91b18d0995b1abd66e7cef999544e8276f197f43c47f44cb453ae164c957a389dfec9aed27d8d4bac4daf85820391c24c6d5d1dd16ab1cf4e236123c6f66593123c8fbdf2c76a35fb026f29f499111552f41b2b6821e320c6c7a72bc62ae894b26e0abb8d7bc4272b84d651b0b34327738912afb5ac74235bf728b1565275035244ad0ce400119e62cdfd87cf44a18146ec4da7d9b37c7e8b22fe7d8455359bf2836b77aa081df58bb30f014fe376ee0057b1638d291733599afb86b4f1be092a0e84da9cada9d6c587264bf8feb384e0a293ece999d454db261449071b4167c22ec180ea88019ac56770ba1a12f9556da018fa00c786aae6318abf61413843882fe8282a2131e1ad55235df585e5c5f3dfa9572c62740b043bc2ce32d352b231b244e64a529454a10e2abc1ec76872f3389f1c005c8a13018bdaf56fd4886798b91466f6449591bba911d252393035ed2bc24a29c8a7bf9355ea8b91e37f35e1a60b3d52b116fc1cbdbaacfe1706265d88b8e2edb510888268cfadbe56bb7d99220cf0aef7f3230e65a117535aa81dcde7ab16478a1a84260cb4568b50ba64046f099eb2dffb58b7725513744f6d829a33460b6cda13f8899ba07c8491c5c21ca5480ea98ec99a141a0dac10ef915ac947d5a04e7b69ae53a346d6d57bc7186226dfae0ab85edbb8cad4ce203ada5259df9be6968d5d296519bf4d5ccc539a8f8dddbdbbf054225abcdfa08f14a1c6db09e76a377bf919550c6e85dc88dee9f86128c35449b8738c81b5461fff98a66a3042cb195a668c69f96d5f896d5b4524056bd5309e63b13ae069b2abf7de347ac100c73e053e843bc79ea6d7f93452ab7dc2c83ba026eca66afce7515fbc74e16aa09cfca5aa6449242baf02a9e905388ce1a5cc8a45ddf327edc59d5ed6ed70af50c828dbf2c83e8585f3220ea1a9909222ad9b498b486044e6ca9a03a6de03c871f09746c1c9ed5531bbb49bc1dceda965f14e7ff1fc390b821c890208cf4c14e6f97dd01d0e1865d71d30e2c44f9de1a3442023f129b3b6620c480056ce617f400428731f2a47b8aadb17c7c27e822425531b338d51594cdfab0afc11a3c64352f037218fb1b20c4ac3b930247e3cba7cc6685d758d78c63fc9c071dcbe6a0f77cbfece892121ebb72d0774b5a8ce29198183956f9eaa2a8626c6893a38e884e7ae82e06dfdc40d4372dd5c2c845c5345f1f0f62189931f9d359b09bca94a063256bf04996520ceb4097d2ec3c3878f25943519dbae80378e6c95d8db9cc30253c992469795369c1e5bb026db6606c690401cf1e72967147ef837a1a6550fcc1124f75de8eccb75a282d51887962d90daba139b1befa4e87574353a31ccd02762c74b04fcc88e18694a83adf4f4c682d15ef367012b6794d79bdff971074059921b1ee6c7ae1f43cf466ac967e141834c22400a8e77ac9ccf7133779533595a30961c915f94b344e0bf098b616aa81265fb672445224b132256df1e08b7c7bafd770d6e4aa4737f8cb7772a30eb9a945d3ff6db6024acedad1ff164347848b5e1fad576cfc48eaccbcc6a5651a50fd3cd759a564ebdf9f785f7a6c255cd89670d883c7d35088038a25ee90d00e6bbccce06287a9f66ff6bdf7df93bb629fb27293579897b3dea6f63b43d79120afb2728ad15a275a6033ef7539679231b3bbfc3830272539d99ae6481cebe78139b0d8c060c91c0921fa82edf3476266592aaeb8c6a01b33ee5165cdf230bbf6cd4591741573e2f421dc380dcbb18e3b2e4360424dc06a2631d0eb5190dda274ab88fb25960bb8a4a74ed8c8b5a6d17e8eec881917fbb6df797202ee77b51bfa9c46e7ab9b904477c02fc2821df0eab146d5fba1ab49ccdbc37f7a00f2c041dfa0f33aeb05c422e02c476e4e139bc9ef0f22b6960d7b77e1bee1c97f38811e718d77d70b412569f32c68d5c1e4afd83af74d6bd00b41e3ed5313f70c3e0d7bd14150e059e9f6a4a988588f6ffffb13af802d637c6f34e4d7c220b1b4197d2b152ec75ffb7417a8f0e7d8b409576604550bd7e3c44f997bc5d421909582d7fc63b1644ed90a8f97d25867e2ca002c9a984e86de2ad5dd94857a8aad1812ddff927ef77ef2f27b24b563be4d6d9791331fbcecdfd036fc6874473652382d46c3571251777e8a926e06e27c2b911fb627594eff492197699b545b93b9ce164f7f6f4cdf050457e9ffc1ddb2c791c8043b56bcb470a2e4126bb540fb1c1eabf99a57aac023a37d549d985d8bee160f78a94c2b45d7c822fdab49ae646042f707a6e95e97e76916e91820670b1a6f9a0b17c9c467aa729530f1b7d0bde46d1d76a65bc3dfb69f05f0559bfc471b60eec462c0fd2b0ed859c4769aeeda59ac0871e9bb72a137b5cb8d0a06ef0610b0a2089c46d1f8f521224f7cba58553d82117921b67374bc327604279270b447c9decd064b10e217a7d14f9885cb0fae8d299344c2ae2016f5cfa96e1b2216df3fe234035e69c71fecff7b322bf2643086c8f1776a6f083859e10605a9f30a25b32d5f1bb350e886d4c6e60affa0f2080a58b361fa020efe72a0a5f514c320110c9ea97d078816c42bf4bfa07b123734b598d8352dc924caa52d197863462034e8e27588fb74179df37630b67bbef5d4a036294e65fca2d6df87534473778fa5a08d33da7dc98d69fbaa4f83930a8a18d3e2338c6521f758149629ade73de05e0b4660d8aaf47a86bcee46a303b490794bc8e2b1bdc48e035438fb6c5c8ec9b7d87908b68bb1a09de32068ff889d2d22a5ded4cc807a12aeb9f56c95ca9aaeb917564f1d0d2c3426b08d84eb476a31faebf4d9c430ad4633995a308478797e4e31ec09d4c8ce7f15ead4d62060b55712cdee5e1e71da75ab0278c767d65f49d7a3359de296d50528419d4176f79627f0461f5cc2f5c13d782564f5c109326c123129ad2721d19010ce048affed9ca0a9a7476c9ae8107aae0baf46ce0c2d9de315254b16e951cf675737e8c24304278243252204ea83f88fd0837ba73caf550059e72814dc0421ddd7ced392acb05a6d6691cc0f0e734c46f6f4743cec77b76662a199ad744da2e7fe3d343ae42eed5619cce5dee5e9f6c2c6116f9f204544460040b421ac083374b1c515dc5bb8113e271e3c5519147ff28b740702acd94f80f55884cead0457e3163fd1d9d231b33117d9abf7a2b4757c0a07f0ed621f1da2b6bc2ecc8ec6500a5ddd9cc961ec21120d06a3c3bd8e0232b8410a8bedcb99ee7297855e85ec17938a4e827fbebee7e4253d08277ea76ee9c7933554a1f85c768488fc74d64102e54591c6fd4d501677dd6dfd1fa8f36c8c903b5d69809eb5820c1716e2fc325c1819b8e64faa4cf3689e24448484e95aefa309694ae4db575d4fd7b3a2884f5f4260c3a6e2e76e8c55dd92420d6ec80390fc4beccc067c51a1c9ea251ee1069e1019a37f742213acecbd4d5286072a356f8ba7eaf0f85d949c320c2b80e3abf2575cb60e6c99c94890accb25681a25d07f2a9fab9a2ea99f91128cbfa618947d6e08b900e10ec7f5daecf77c82054f93fd3ba9ae2647c2cdb5e3cd0fbb962a80aae4362130ca99f707d608f3097ac6d91a2bff6f2f7df039d96cbce527eafe5dd2c783dd71cde2bd90c0ed68f21dad9569620573fc33afa34ef30be047dee335036376cab1907886ee1a8a6c7962cf350c2de33e3dce96ae51389f0e5e85dcdfc29838df8c0089f81708454932fbf5487775dcabca5d37063e851aa0d730c39c147f16fe88c7fce5a83af5bcbbf3bc8790b8674ec0a9e6be1764c87af5d290d27b4e589c1e777775f64b72a4a056425ae713228e874031178201f8efd7f9a72e9da632891a66393b4f84ea5f0abde6e17bb5be3113a5c99d27d490bd000089ac220a026bb05876fbe970cc9173aa8febdcfdb6f4ba56840292148435efaa9d1b1a01404e5cb8217c9dac32b424cae960d1e52eb499d0fd9a13c7bd89f47f3aa59eb4765a6f91561196ed0a75e88b3626b56a103b8f6c45f9ec6c34628b88d335c90b6da58eda991684550901784196cd2598c9b092bbaf263c60ffb874e8413687754cffbd7916ee33bba610403eccc327022bc213f17c6c6193d3b0690531e64c4074e24e2f516b78ca244a0438e566d06ea37eeb4ffa49e20cdd87b7bb3749eb9a1ec5677a51ab4c869e55b9888ca99e3d5cde758fcf28454ce95f11afbb451410cbb1c2b7dfa946f22458c121a9418c916ef83c10c7811dad874e3ae4e622375a95baff81f7b4377e90f2351ea0bf2643784a558472e11898ad01bd146c625709618a92e897e6b1f1e83646b42156f9ed273ab1c3f81adc14689c664003db2ad57845a41d0fd7a16a91a1950f6abfd6440aa965dc76d76c85ac383f34fea261921f247f54aab2fe0b82079f8d67e8b8d949803e3a7414884697076790637ea76a88e73d599712f8cfca3e50abfcde6fe401e93cc4b7ed5b2edcc906e5b5a3d5c0a0f40794d64123ec8cd702096848cc87da17978ac46fd22f483d532deaffc6979e864cc40f3eb14b117334e3b0007f256601871ae07c4cde6a62406de1f773e2d9647e7443725cfd2f8d0d75e528654db5b480cfffb11f98a281ff73fec226befa87785d1d3503335f3622cf50e8c1423df0e5a872d21d48cd9095728886242aee8286daef3d0d029d48192c9583e2b8fec342d807ef6945be6640e8764dd3493bf8d53f8cbe9fbc99650c862f660cf46b1196b459393afe31ce6637d6f8526ff3b21b4f4eb2a2bc2a56bce376034c63a0674b85d4439279124cb146ebb9446c907dab4a0e979a8f1b9e3c72398eaa5d076eb436edf7479ed8260d6864dbd68b60851dfc6acf6ddd9eda4d5a8c4107cdd4d6bf782c29481517fbd4873473ad6fb8cb3d7bd4f5f04ba2efa3f5db20d81ac95a700a0ef8423b649e432be843538ccf244f27e5639280f2477909b6dd9da16819c928946ffc5e5680df3b22d4135229fb39115ae76b331e6d8760bc94be868fbc364e109ee0cce598814a514d9824ededb5aacf8b66a4c7a63bd21889a10b06a21577f0ff4b970401413976ecf4a14c2440a106ad5e8fe55b051e4d03121ba7b87ae2176f495d65a2d4de5fdbaf9927853d0c3033c37dcbb2b168bfa6399b545d16976a770e721afeb25880b7519c12d48c7d53981b9df1165bb1dfd74443e9e777807313be1679878d2bd3dae6d75427ef9396624b9cf6a7c2c5073dab5addb9a6f6556f94f27a8e4f102b0bd066928aaf9856475b146eccc78d6d2bfa838ac185ebaf427f4311fe90a603c9fa6fe5d9bf780275edeef325a9ffcdfc85f0c968ea075e113bf14f9bdfaf48b2b56d8c15a5d8e691d86240fa6b569d06ddb9400d34ecbf4c20965677f5a4c58f7f70972536af89d4de954c96c71d455a6c1c8bee32267542ed577ee3141b53a7dd31aa4a5cec2b23723591211ede997a36f542fe3c4dda5eff796cad427091b825ee16f200d7cd7ed5e25a03d6dc51990ecd72b581ecea654efc9909ad1359e146782da5d124b32f7ab0d20528194ce5a3d6bf1ed88e7b5b78f1fcc7520d716c63b0a8d14e32506c2059fcc62a3ba155881d5332d5be7acfcb0401a428e9613d41e84aa712d238389790f81f9e77786510734bb49f789ce6c0958b1ea638b255f6bf5ab30b32427f799751451bb4012fbb6430eb029cc1ee7591345f36d15f58f3b7dea9fab4bb15f0abda29a62b89dd251f4e974d040ca4d3c377768500f5fe319dd8e0db19832c056aadf41f6d87cb7388daf95090483759c3d047ab0d6e18784fe17b5a29ddf5b8988f22fce8d1d96a17c378a5812151c2c395bd0941507f59cff594d9f44262fb91be3b7470e0d371dad76f8fba490fc8fa2c84aeec6e57991367809d6e5368d321c1cafe3cac37ac750c6f095cc15dd34e9b1ba2655752759ec58ecba45462722e2719a9da21b1bef3282fb761000c0376acdbb2b9e1817f7487eea9421d87364da1d2331659e673d005a7890e2025982ecd127a3e9982e576761bb7e598c8f46402f2d63dd25d7837efab4fdc41686af020e622f95bf6fc380821eeb196efc42248c01e34767a2035db83169c5bfc117c4986ba91fe5bfa953795ea45361bc730c1399b5db88b92dcfbe3b1d1669b8ac95212bd2b8e6f408a40ee4fbe2dcf9f78c10dc4a8c336a2cdc478e9ae64176a92f1d1a8a05afdd0265ce6af0301ed0a4cbdd40afd0eff391f721456783e288f28870003ff02b98163332a2f6a73b8d2bd4f0e8883e746fc31577bd078cb8555581e628bbf8be9286044604d57021ff0bc2f2b5997be06eb0f2ddbfbdb3c098341ceba5399cfc6bd631af3650e47a5c92366305797f09c4f49fb1857bbdeb1f21c783179a2a17024a0af6193a783f8c1d261fb58ada5e205ffac65a6952469e8e1bf8736884f14a49c1cbc23888bc7691d29eb7780968add95d8fe166e5bd4c8b32ea185d5bc17ca37d6c59d95dbf8db792f69296344925008be572127080c7c798536af4a2c7793f4c2f3b3d9abab682baef529a1184647af9c59e0d0b6156243a9a6ab21bc5d2a553e3dd3c56449455ff49b9dd23508451e8eaabf1afbf2dce8948f633e1a12757b28270399260ae8f9350a729cbc1991bfdd5c3ada6107c3b08124209be082c3dad9132adcd76466c44c69e5e46dca3c6062ae0c4d2a5507dacddeb95245b39567898bf6e351fa8291d6cd19d5826acc0bd7a9bced1fc02a7d6fb2918eec16c68ea7e4cb3f5929d73fa026c6da3a3d0ddcabad91c4ee20c8b50bf0bef1ee7968e402e2b8173a66c81dc5f72ec47819c706ea85cd3ace06741535079a22b859a0b2a9fbab0dd386dd0d1e6d1031f27849954cbe0bf3db570ecc96c858f165e2cdd3644c98820bb8b11d619a03b5a53047d82a35bbea5bd5b7aa091586026e8fa705c984fd979d714cf38ea1291c6989af63b567e681130a786ea4ea207736bd306e8641b0031f22711e11215d84dd43fb7d30bbc020e257cccc4bf197092180ecf83f9257835c798e679cc3bab1a7a847565aadb6c123b4acd832ca5730c93ff9d6ee6700dab9b094238c4e0645c2bba219d661564e942dad3f671445805f08bece064fb819e05f77de8a6b4dd902bc099e08c40bfb8591d9aef864c6c5418c7d70f0c18bb6b41c03864bea9b345dd8c9ccfbfc56800f674f3da7dcb59ae77d0a020ba32c66b920be756638a87c5c190d62b833c79be89f12030db799aaee8a961dc1b0ef8bb6a4416628cc6ff22eeb44433cc196295aa0ea5e05c128ae7da7ad195a1f2fb52006f54c599b7409a0ccb98a745c3a4893f28383ff02b778500d9e27a341e29c87a4fe378aac44af3fbd9be478d54b38ce28df5a5648c08c9852b61bee0b29016eae45825aa39992ce3e4569b4ef2180221725d96180cd644ee67d24434313693c680c55c62f26db44c6f53a8185e317328cba44a1ce3bdbf432256872301d78b569675c1d0600e59d013725174c67e28eb40abd19257fed7ab8e6549f08f845557fb8009c8009394e9068f9f2f819008c00a8ad431c3d2279e28426c64a85b1b0672fb9a56ecca79aa039f8d119779d452d713c6403930867a5a4c46f752df216f94b882006e1aaad261ae6ad4c72f2643bc5e27d75f4ec23c8457f3d5d172b28bc6ea822e7b42cbf5256bdc84ea6df06a27cecddcb174db55c4c3aac379032511f8e4d7ede6657ced34ffa359b48a324cc89b5cb8094407c656f14da3b269cc0f5dea90cbd732737122c18d97d95568c4b91a1e3b9b370003f6f097f87e82b81609cce13f59244c009784d8ec1f4291a19c7891bd6ed4d74200b86b79a98ccd7588e60d53f7d238b30542e7246fa02a26112f3f6427ad94eb7f69d03a1c32e7d4ba86f51edd261ab7eecea9a0e3b30a0f19a7edc069e935aedf969611d40df523e59df5bdefb626025aea96192c567b8510b690ebb48c6f70b817a4175f265d942b270d8b2261a07aae31359e4ba13a9bd2a4371bf28e025b164876cfac2deb85f92044f9c815bdb061966912899523a18d256d557367dbc58958ef0330da9869a6288e3811b0c380868bfb63542cbf76a7a1bada55b150a89441c464c96ad4fccbea5b085249a3bef8551718bd200b1a2a8cda48e20d0a5cf874d9b017f04222b4c571a37e5a7ed5b7d2a435dfcf9d215f4d067360ae0f2473ef2e70344709b651911006730d496afb9105e1b3e55d1e0bdcc412faaa16129011273f1850d1567cfc536ff6a1f96e93035bab6bf1a75954ffbf0ffde3c3e8002d849688e5581ef8860f4e3f22f110099f56d6d7453a06cbbe198ee1b06a5985b7c999052f2ab1cc653d0124b2cb856c5c526e23c16478b141031da1da8a589ce8f20bb608e4abce320b62f19fe2a69a2990a778897d64618212a16363972473e6211fd1267db84d48f88c46f74ead153a2194ad5aa6617b188feca3cce5716888745fa73615531ccd871ad5e98c32927e33242cf2f8f77556c2e3c8a9fbe51fe754d528d5fc144f33839d7d1030dd56226470bf985cb8da462249f62f36a35225c99bd76fb4e6163859e3b48a60687d9ed82b43325e3659868dc52d0f1bfe29f9574d8dd04228093f5cc7d90c1fc089c9aa21149ec29697d632cfabd49995c623ad10fa0bb6d4c78649f81ca8c2cbcfd439da4d1ab74e8d3f0777eb1f02718bb5c1ab15ca0c42b0d8aab0bdc9bb4c76f17d23548208058c0dfd4953ad800cbec449412e34e0fb275008dfb2d7c416fc7fbd9aea595a49e1124ff5f85399ffb84324dbf19aaf30e775f88626d6c2e986338128c900ecc414b2811be94d93dab59739f4f14cf89cfc6c2a30b11cac4cfae8776768288c1b025ef0899720b913a86d0fd9d5593af2653a1980597d9916087815748a42aa01e7b82d1e23b81131c9647913fa60244c3dfeb704911e21c7d7686c3351d5ec94c09d658060ec558697a5cc0fce84f7bb8ae129225551211f921c26f57c75c305e4e24eb5eae20ccd2b3dfd691f0c79fa51f812a424bbb81b5ad45edb029add06dbf06304fb7924a1a6423d11b04895b373c7682a1751975c3adc419e809ff9f20094f5c0b54021b12570a2d0ee5d002d0e1e6be0eff79f3e838af4064c88b4d820917b7898c1cd0dc75ad3958dda26a614a86784616d72f713cb01fee7990937f47b5125e9dc8e23c6c7e222042e2656fb2fa2a60e2963c3774c2578ff87eb39d478781fde3a3b9107fb608b21c5c35d741bddff20617ec1d3a5b8aa472c90001ff58bfe0af7511073695593a6f55c2179a3aa68cab2178c47b92d4f10c56510af97caecac62755ef9062f113480a873239a41c3619043b0b3fb14563b3ca73e0810e2c158c2236c671354ab4028083c2666a069d6d1937f6f3e6447176756198a60cdf1bdcb06dc6402b9251f9ff994d04daa3048647576bfc0e97612cd60f6b1c58ba954a731efe17b6d4afd6f9cbc0bae7473df17dc124c9484809e52dd159f69f3b23d76ada94f3ed185ac81cd07963ec335231d369bb16bba39ea59b873cd0f0f724bd81129d5f9bb84bb017a07aadbcc920e094587f609ba6ff13d45590cbd2fbf45ed02f7bec32f366db7efd5881922a0bcdf9085c27440f510ef4c5624d8ccc3b4447064454815fda4a1f4425959e56861b9e9b37fd75df6727c2fa78962fcc14f117d85b71152138ec9cd357eaf4daaae15c9714da371735049d82de745e7e1ffdf499aea28e3f7ed64cd590721d59ac65a5e0786cc6346f54baac5bdfd5055c8bc1ec2f0c84f6cf01ca4c47796be93832ceeaaacdc9fb45685fdf7de59b757eb8a25409841234b16451602fba0c4f9330d3f3c13b87273519edcee250b7622061f4b8f9066c59db4ed552ebd944c30fa8a9dfaecfe5bec52b9d5416d554c97ff43d254f3d26bc3c7dc80bd6ace6b0db6745c7a232fdde165e4ac7c4cf98d0f3e089290a487151de3ec1878b6fcdea5f7323667f2c480706e0e4a992230fe67cdd9d332b1a4dfc285d739715c1fbbfdbce34ea4423e36dcac38a044924680138227e744f88c45a8d89df86a91b75bcaf039472ca358a89e00c52791605c24e12873dc925e5ff7e91ab8b9cface3844706d7c52fbc045b2bb2a5a79f2f4f06e8ae0b320a636dc8bad7bb82b0e3648a4b08dffdaadcb4d300ee4b061cb6fa43f6c5107a97c1e383310a29c5f43e3229582cf33d728d6dac3ebdf6a021a47b21cdc94154d8211f64335d44c7a450afe7a32be5845a704227b865cea59bf810a1e5627ea11280210afa49027fb19053e5b1cc7fdb333ef049e102b690669ef149e48fe49c37bd2446c84e4bc59b32962a5908a28fadfb239962f93d5ad7dd87395bfc038210c71c27cfca329961be47ea4e5db4a8035b728d8f6060e6bd3922111cb94e1d601ea301b9f92f980dd1aa046052a5214d4c8ea378a066ea7fff92e7476b802856370fd5346f445ca08e78750e934db2f184230c7dff38a2f329a613095508e67af875d280fc7435f0dca8843cc69c437b32e0bebe47a479bd8259e2d39ce773bfc1cc2ca75414354168c646a83d695cdfdb6ddb9e4bfc1fb2b0df933739eee6d461ac0d2c92702bf0749b291451b7a509d2581e1bd727c92a0f723ad934dbdfa20522b25f7ae7b2a94e3205bedf6929c2f6fb3127096e2ae7cb758b40495bb6729d50415c42a3826ad3779829e351432eb5af8ab7e73ab550f0273b64fc45780e85a98d0754d9043cbdab231958274d67541d927cd2e20973adc52efa6328a8b649efa02ebfa5641e2660597567484c9e30ce9d240ae07f821f24fc375e55011b8335cf1f3ab4a86e7a2b30a729cc0b9f931ee3db1e72f1d8b97794413d9c6665be8b067c5d24f0c7d5b428e3d547f345fa15b2171022ec8cfc3217a72198eb6aa9f9b38b4f671418703823cc8992c617e273beb46a33412e58ead739af0439902ccce9a72dca29a5e50364d9398b63b45f8b71485c8c4a193c44e8a1da4bebca9a1790083cd93d2814e6a3a2df49b935e0b9ba0fd822c753076a6eb85727c7b45ba2ad460ef8959f167afd62f10c40f19b5e361f123d0363cbf9ccbcb9add7b1370df125541ec1ffeca2348f147827fed49d6b724bd4dac25ed41eeebddf7af9892e2a066756956876ffed1c62bb05e9d49020d07d2e2a38dbe312730e0d76c657c2b1024ff34babe45ed73074817d2cf9cd894cce5133122e2736d48bc73a8f6cf2f924386a5b8195b9202544cae08d313214ecfe5d6766386f007f7c6940c4eee596f849ba0ec98806c4b4c92638057c5f2622f014ef0087f0f28328bbf45782f0457fb57ba1701142d219eafc60e78ede9e958f9f68227ea39b449df2b3496b79e365b3c51690a51a93a9db7c75e772d31e41819dd989f4670c383a9859b39821329c631011e32b75d4324b39d8ee50bb8af656c120952fc3c7561595a095d93be12fe40d215a876882c78fb5a77cc6f6037c860b771b315d2667f385243a58d219dc7d47ef21cdc12e3d1f2cd820d8cc649321ae80182518ae5df0cd2bb870a79434c396247fec81dbf92696e43540090382257fd536ca45a7081d8582ee8def799450d67adf5c7adebae19ceff97400d532c4a66b6e223efbc1c169a02d826b5ec0f9d2287d80a0546d719ad6044ba3e2b146f4e6e5d6f2a687b8d5bf732f700ed795bdcc27162873aa331d5090b93c0ce8c9f6521aca2d59220724b56d5fbdb609b3b58f1705ea45005634ea0f4e706cca34a6736d5d61a68219c03797c75dc2752a8eeb5d0c7ae65fc4899a0c161ef1538d85b13288846e038364ac1b80bcca87819838c31798eb6e833b428d61862391cf28221744ca9aa654b706d54a189aaa1dfb9127b21a063e4d666b83ad711ca5669ebd65c5fa9812830fc75fc25bbd9b871461b6d685f449119ac6518f5c4f82faf4f70943bbb1084a4e0d72e1c337d4bc639957c0cef40cec21dc92cb3bc60c8f6d2d6d43f516f048e70fd79e2db75b3566ff8678ee5ea01ed41c27a6e0df35c470b70f7bd168419c9be8254e716393986b7e9407cd929410b9a10abd5fdb1cab2617fe6fb111dff1c3a5da25724c98e9516b05df83db7a2568c549a0ad59ff0be4b3f7707b06cd2e61aa4d4c6fe520b9f845c1fd710fcae7dc2524c5109e749385ca674c1a9a22eee5081b3281f125dc32b71e150b710607bfb9f8b502e5aeb2ab0c0a88aa20279463e6ef0a93fda5168553e255c9d77d0542d544772700b6130b30e804590f1bd908138c1540ac0c132ca9efcb5f1e0e48980b62a82a4b2dcb34b066fbfdfab029be83706d4716bcddfabd23c1884e7e0ec9e7fd6cdff68d4e89fa6a0f5b79d0fee553b43448d2c5f1841b471f2eba76c9b57e0beaf4c08a8aaee7690adbefa453e9592a4e2e3f5fdf13da0a32295ee7e857dcbb00fae3b3634dfb9d2d69a32930fe587fcb951d5b4713b1e3435c0712618c94e3bf3af958df4d1018b3025a0b512efbb97c27f9103e19327a115eb90a869bd2fc7f2477fd50db31a7016135cab109bb2909e6eb211f726b4ba37433f116f6f0ccf7dd696307b900b2e2a4206ad0aadb68960703ceacbb70bac0f0b1150e5ce887c57e31f7fc87e73bc057c83cd42e520e7e8276ca185a4fef6d7b5b7fc9f8fdf2de015d78e8ad48a68bb02c32e052911afb8efd89313265470e468d106e4c7d2f004f263239d99f234cde356fea6f0dd732849e118d4e5c05744a585a5d444fdd1b3b8f5e43c1fc10831ce5459fbc29b484755749e3266bbb4f241a1f19dbb70e1e391f7b8653a21b3f9b894c578353e4813d94abc80106da153763b9f8ffe933ba8233039121c1def7bd7e7f80c049551a37bc6ba8a1b1401c960d3ee82b790975c6fcb2ec96a953272f3c874fa5aa94b1400a0164c8a64613aef35208b22a7a9d242ac32cae71690fb207f347f67462e8a2fb9059aaebaf4644f51b6446a370f069e624ad74d8b941b7529c03fbf6d4697094ee5868601abf517febb04cf35c664b842b48d9f55bf4c974b8d007f8c444c37253bd30874ef1f8fa5cb3406ce9620c795bc23e0d8f0a4beb228a89ad852c07c06d130c34252c826ec7420c35aa83ddd0fd8daac6c1dbf06fa7fc3548838f1a73d8faffa9f675169f355840539630d7200f3108476faa5553ca342a9fc738558f1e6fd9b95f021d5dfa6181c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
