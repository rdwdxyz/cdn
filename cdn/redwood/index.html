<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02356b5d18062f8c186642470ec67a44d7b303a7b1d74275ae30d73e6cddada1e1235bdb920c8ca70f9241a4d4087b34815ef8036cb703b18d60de1ddddbf04182edfe548bfaec3719243af9b3e0cd233033ac3c71938ff60c12fb44370c1493f7299b2a429990bd544601b854b104604e19f66765c1ccfe387b00d2605520475ce82926c9a4c437a28492522004edf1d97577bd43e4bebc3552f4441646dc4e4d0ae4b7f5dfdac8b5c4c7d82e145c107aa399976e41dbddb5191e8d440ce9683cf796393641cbf3d1d699ce79163e8fe8738bcdb707550a822acc8709572e77c92342baa83f6c69eb262c66adc7751ff39962e0ebda7a9ab7697a2ec6de93d0c407213e557189784c2e2d1ecc46ce8b33ba1797af2fb8c3648e89b171a916f79d47325b6e573185342b4ad9efe9d2369be67520bb5e76429069dfac11f7db5d3206a65739f2cb2c03897a91d38f4fcf1f4d31088657829ffcb8ada829bd024836ecf566e7e0e67ae3e2a4d506e6f86185382fe2ca62ea36c44023ebda981576fa9b2d3157451b427bebedc9cf7a11e5302ef7a2ab924808671c8e2420c5848665a29204501284b4e9d8764b67a4f10bdfdf9a5773d031adcbcafab90ac0144b0c1bf95eca7e50061f8390aec7324ab04e09700281f4be8c547fb3d3eebed08b856fb61a88b1d533bda2c19b99a36b4102893282fa13e35d1b4f900f6c291e7c4eb82b05802f75f71b197c9841c9df1a68d5bc2a004c3e9e7095de8ce85ddda1533d27ab817899e3acfca88c14da42f3d114d8b737a303ce9652338ba4480d0368c75db8f06aa0b6c35fa76e57627cceb74b8bc489d11cce26945bf26e0bbf6f9547d73cb921e9d0b02a0bcfeaa4351aacb71c9aaacceaff8d7cd853358de6ad5b21e085ccc62cd1bc5a7a0a52aee1f10d8aa5e4e9cb7169fc190e809f97823f25c95911b455fbe29ee85e8a4be56422e6b9139872c9c2922f3c50d017360197f6564e339b16b5deeb680bebf2053383146325a9f653891e3caa847d322f109c62bd7286d7123c1c7cb5c7431037cbcd892179e3bf81c73535cc806e13173d384d6e3355694edbde52bfbfb13276796194279aacba43fdf9a3318eceef496320b9507753ec57121fcc5292a6ca646584d28d7fca869446f392ac8d45f88801070ee94a57f52d9087d5e116df7d01d9fa66c4a87f18c7fb0eeaabc7cd550e25e97e15944dcc2ab8becec733d8f815b8d30383639d8bb315ca631ad5e0e76468f992b259bdc3cae7e396009a570bcb4ba8f10203d9905a113baffa15064efb74c4e63bdc88b49e73c31f42c07ea676dd511572de63193e8ee641954664a5075cef0672e7950c31bf0033f5373c32526e3fe2a1b26ae370c4e535d8de6ee3a637e81fced41f8bb982afffd9406552d4a0eaf57d40a34fb83846c0ec37bfd933bc17e8237f08a524ea58d106a2a4ca38c8d6d955bebb04e31ffe81d4c28f2486868a223163440ca17713ca868b2431c4fad97f5499ed18d09e015aea9f6ce127c3876426c907397378229cdd58702336f06632e74cc9273e70199f242ae416fb342a3819ca51877a729cd39dbae27a555df27bbf10ec1612943f24e0f0a526a39bae35deaa42c3e51ee260f20c3f45eb9a3c37de064453cbd43a6a5df8a0e2f7efab9dd965c8dff750d5d650b9b55393af0e7778db9aba6614f765a76844201869755b4f79a895b96ebb0e4314ee4793005b698f2abbaaf307e3ded04573078a54e3f8bb2260f05d0994d96ea2473cc16ee788fcce71436a3c883c8dee40c22e907add35060201dc0cb533f992157d84d26ece73a0b1de608985f27fd77571bda92a5bfe9a8d63c81b8e5162bb76038d4000c9302eba5a3fa7fd1d537095eb57802ba83d5b1ad5fd8ec87f6657f469e1aece46d19532a308f2ec780c06485dfc3b41ed9fda15f86975e0422403743aec4740d3c9644d72ba77cc7b3bead153c63d55b154acc9087119f9811273f7d76e3e842c5ee1f64668e9998d1bedb005239cc8dfd349f128d1e8f96e3e4fb4ae78d44e28fe6bb8ad4a13ba1e63130e5c4b7d64e119e78e429faf740ce6c520820ae303019e9c2988891ba33ef475730267a8d22fa316b90a3e97204b3812c55674c4702208c3d4805efc30c09377f100f4cc5825c26d0c95df81c0140f611569fd19083f8651485400cb24a7c096966ef4d5843469b07815ead498df4dc14ba690565a784bd965232a691928bb443ca1c833a5255e43a592dbcba0823fdd21e520bf3387d0ec347cdb3f15f7ef4698071eaaa7635684aefa6aea7d83dbb24dddb3e0dffcd7743d2144291ef49bef21fdb22b620423fd0ebcacf0364a27fd8f3d5dd03f3806424b050ef7dff19512bcdd1fc65e83e0f5658b4857de84762dadc1c27cd3eeb792a8136b4333b377e99b647b6ac036d55fe83ecef7581738ff69f73f7a3627f73369624b464d40e496beb86b5918b691177f042e090e2374306a37ef3a0b6c8945a01638500da32245ab5b53f5737215bbaae09d7859d23533fece3486eeb1619c4cae20a19b358e8c7f61f43f8a237234d44039f5f50133f91d9b29dc8139b5d42d4957556a43342086cf7b9583119add88485b7854a381ebbe5567e1955a71d5e9c50eaf11c052417caa12b6b28122b9caca0e8657a183150d8b4f9bb4e429a870d5fb6a2a9ed3d24e02e6097267e601e5b568d805cd1335e7653c6f4bdbb9e1d935778aef9cd1f664507c992577fa556529c64b694bea4d2a79a8e522ffe01d3ea0b6c6a5d581cefbdf50ca55bd533e3bfcac3b17a4f8b41d249376106105a3ec26daa63af2db4aeb7f3776336fe7bb16cfabb00b3a648da80e6ee53cceacb4865a0f846ab3bd3992063cdbaf00a4397cb307978f66d43e33ab71089279a9ec52cac49137e4c679c4ddc6713be52cbf0fddf74743d67d59091a09a0904f75ca69051d2088ffa70cbeab78b994ebdffdff93d6c873c7aa563c2fabad48adf1188149978bd00a5cd3918ffa04c302baaa5f4c015fcf2f16efa8796ac4679199669000e5b83975278736c6d1c475492ce194da681f38f004890a78ecd197c8e3ba7b1ab08415ae2d22ea29dd23aacc8ea1fdb919e8f73ec3a35722663e69fec870cbae093f4cec5ac37dfbc3e1e9b3812dff78f62800f15dfdc05902365abaf084708113edd0a64ff3bcb3646ad17049fc495801a61235585ff91bfd1e88146365d240fd8db210c83ac3a5121d1912d68495d225d753096e3eaea8211775736aef9cae75ab26cc0a08acc3c65fb68c283e4e14289158f36651e54fecdb20a8efc907853134fdea85362f480aa7533c3545ab504d426a13db2b082f1a6e11fec9a96a9bf1aee601d99894ec56e472687a5c87a6c2c46cc869da274db43dfce6bdacc80c512b07e1331238fc2b75d073bca815fb0047391c00b85f26dc8352f5af5716a0c93a6f49d52c1851d31dbc3b62da2fd92015d0279630160341e4ed0a4a2a6d90de8dfa3262511d6f6fb5a7028298806366c4e9dba1aec8cef4284567c6b0314b976318ce3334eeb647d30862f09844fe7d7e77cae2f7dc73c234877790c6dc6bfccc2685e42647554ebfef5e6aa06b156f51ea8b93f099c891c9ee6250ccedfa45aa52d984d1e1c42c917ebff7b66330659f35885f517ba9ca6ddb2dc8f8f6bf69886654214519606da7302398b013fab81e9d224e245ce0dab3cd98c211476ef2a5c892875197df4c27a35760f1fe65d930a9e111574ae4f778063bae0f88db5ffdd2233d3904d139e149a377dc0c53c68e89b93ba13deac93297dc019e9394284810f115adbb7cbe4a543831675c6d3fa019688718a2138deb180c8e9187defd37d05eaa9b0d83c0ab42ca1eee0de1bc5454d502d3c00fe2668ee2b6ac2dc1921ab1435284d0f093259f5831971ad42f9fd2a9fc11c63464244f534afb6591aab5e07dca18338b0806d7419f988f717d174639b2f746ab6dec26cbddd265ed8c295a37b3c83deafe81dc7cc876283180fd49cce92d430afc9c8493f94f678a797fc9b93047c6fd7187359e295a9fc0f47cc860a3a536c48d1682ecddfce93f63b7b717e56a6a489584a00386e74da618a02bf9d08994af3be5afb14630698af65ca673c445f1b3e74ade47a6b99f89ad54c126bc83ce9f222e40035662654cb19b79562c355dafd785dd922ee4301a1e30d3ca9a0ff4c7760ccb0b7c29fb2f650914c8c05f134679351bbdc0faf448a30367ff7830ce2655749044dafde2df45692a3dac488810d80024d8028478376312c4ea229a618fc2db56c0450abb82380e9927a5432ee926eb7bfd5664404258792f9d084a86436bd5939556860c528b4aa9ea31820f3a030720d6a011dcaaca9d84ffc436ac82a81350231c7ba4a17cfcb9c33a9adefa836b91fcbdeab17157bad6065b9a50468c47f44faa5fb9d34583f589ed97a70bac521b6a20419d851cf917ea50ba6157d1518f9159b8f272d061d5d10bcd455255cadd89611a27a91d76a6731ab5dc34a2d2d8a21cd912dcd83bcdd249f5266b67018b5183b719c94709651b0cb1139e88894ca6551b2fa328ca6eb7d5a0727f26846db3cc0472b767f277783141497d1af2def97db1f9048e7a1e4b91f6da72082c7dc7ae4727f7b17343f5f93394798562d08815fd17b83e970700f721c3331a0992c4b42f9559a3f7f0a739855abf147b21b276eff7cf37e413dc44279994cf932992d25765c14426f75d6232f6515a4154c9a83c0756eb5d3ed4b6ef523179e138cfb8fbfd9ea755c2c926be694c2d206813b767ba70f2c02c08c55e1e84c6bf49e288b2475f4f0ccaac73ba52198bab3ea95423778f7584c3087f8923b0ef210961629b43ccc7ea35a5f70e524e4ea6665482ad8b68f7ad05dce6013bbe13e2dbf9393244dcc57e68717b8fd03aae2a625bd57f819fdb4403f6af45b9261c700fad82634c8fb9ca5f1e53ffafed4dea6abfc6d88dab3e27663596d055b0fa7f3b79717760355c70a96ffbbe3141463d976c18d41221c5268ace9aacc50e3e1797a6fcb6d32d45b2f0f1e31aa26afeb9e0923e7e32924bf4d3e082621a2d07f8b512ce184f1809d8c1039b7f64ef87da40eafeb6951dc3fc8e1775cc702853a27ee0561be6797af37c7b2ba0e1542388f41cc45de2600f3315343e008fc69179c014b9137b7f23d948a28ac23cdbcccabfe5a3f2f6c74576350ea0008b5efaa3b24abcf707bf814a1a8bc3cce6e460cd8910a95b714c7f44063d6c0bf9d399d74a5d8c47fd852602ded3de20dc35e3d0279a2cbaf3bf040793865c9ff8b332843e5ebb7cf4164a6c9acaad334d32ed4e162798821cc7ec8cadb0b07e7e4d06e1bb4e7722e9e8b121989e83f5246d03f4f0f36a77bd1eccca66039b113087e2643b0fe8ede0c17bb82bb046b7f9e716cefaf50f94d189ede984277053d31f58ae1e8fde35bb6533b6ab0c56d54c3fdc8f560d330972f89f8409face5a45fdb6b646c99d082de614ea365dc89de29d5af8a9f8dc25b882df0e8eaba02831add0f1d084c84320a80969cc5d69da5d595cb6270c1d55980da0a6c450521536b0e3fe5a52022339cd5148d0a85164d500cfb306f49734610241ab253f439c7d0792c3ed5dfdefb29633e103626efbfdef16a9ac282873f2c10c4c0becf2590bc4b1cf7e79943b43a221ed79d91ac8bb0f9f37ae6143f5c5b74fff5e8f6c3edbc5e06fb4ffb0283cb9f272b465d1a98a963e2df3bb56cec68366d200b42dc54f609a42d69362766f9bac3c4aac8655f15eb0e5030150eb4f86813af895517640a3bbc15f004f482172c8f40c8b900a6c5c8389830531f33a8bc364d235457f05f5d9f085c5e64b548c9e4da2fc0d88c960610386b4546afbab29e77475789212da2dfa85d3fe7f1c0f6b971a049da2f5922e360fddf81850ac94c7eae0f996b3dfda0d738614b3eb905077b642093a26e515b5090b327820e4be1c65394308121bd3cb7e6357824230562fc62e2b529acb2fca157193fe021333ed9c7ef793e52672488718037c94f614f805f38f6bb45125eddd91a82b71828456b8f345b4224c7f9975f0345fb79173f4ab63be71893cd91d2abf7cfafbcae849a040a7fed0f0648ca2718216d013ac8de0eb3b5c0dd610033a4a60900691761f4ab1278a1aa9a95cd540a74ebd0ce82c536b16c7cc6032ab4390754a41575cdacb61134bb1c45f180c0eed68b711441060882701b72fd9be4a7b13503576917451f4af1258bbf8bb458e529bdb9eaafd651a88f84eba323be8584206d9b536572957ba4d82e522db70de07a63a8c7b9a8cdc553b0dd1c6c1c3082be8c838bb5d18b3f125bc1f8281f94ee6c7257dc5869f4da2f1288dbf512cfccda91607f1d042492c908c906be2cc7fda49dc7e1b65fdfd50d7db4ce8020d3a11772b5abce610e5d142b71622a603c1f8ee02aee415b7a086f14a5a1b94cbeef236e7c8a93cb0a3f27fd40b92edc78b580e93743c919fbf040c7ccc2e5170187c8b54a8016436f560a4d8e4b3ea0078d5aebbf1fec3fe00fdf196bbf93c07ce329d2943a995823d4c2e79fc143aa0bc50f2947678bec1f283f6bb8670a4c01db3ef2d88c1bd10a229831f917617129cd320a686aa1fa2942bd5962c4432759570f5fcac02f4a19f35b8e53686834925582db2e6e823f84ba994a03fd4325f983dcb851517e8ad28a95e60980c9c014eb9986e38c4b14c9e942e862b3d1a3fa6d8fe58cb28d8e64642539c705774bb4ea06cf4cf8d6893b625c9a576d41b89dada316da01d9ab6791b7404a3510fde59f3d25eb62e1433d884f054ac12e687243e985dd5c9fc6b328f562207c30e43e53cc882714d9b3ab054cafe8b0aa96d2e56320bfcca0120561bf57884e27961768f692545881618158564261cb7292fd11ce9c9893fa0b478ebf13389da8826cc901908fa31e7a07d5fbf46f38ecd7e7f0c2966ded78fcb97f6e43ed4e2156e99c012ae3e1fa3d2470f7c97600465f6f6b9a22d4bb71e463938a19a90b2cdd567e197cfb521e3382ce39649be5eb746ca15267e5d0ce0d0d712a4b65bbe644003ab5039287e933ffb7aeb0d4f4a278a62416510aaade91a512409008d5ca5d330ec8ad331f495479d350fcef53c3a7b7a8c458ad480ba1e78f2f2fcf91d8ecaf5e120d5a157984ab876e2b81cd331483353e1291b250f37d7168e6b945521713546392f96cb1c75b61a9fdd991cf6a0704173fe1b299da707a1d79d5dd1f10136c44ee05200776a8aa4a263556dd78ef7f62862d7503fd7355a6cb5b514c594d134a683a7a4f819952e63d26e50739804043eabfc7c3338cdb4cbdd05a92120b53a23efced7a650bfed83dbebb131c52c82ded73e4e47d54896ab7f31b62eba58dad632cb698822608765bdb25b4a5151b3ea607386a61c360a88c8430d2d424e3839cafac553b6605a6c2cef8f2d7268f3c5c606d427c54385b40172aabc9c4a8e2c45f7242c0322ae6ebd2b2aa1150910281c12beadd38060ac10a2ed1d02d987055ebf63f4a6007388272f62d39f965f46ebcd236a2bbe1cbebf806b9c956ba3769f60afe96b5f2fc17773969ed9e815a9fc62ea7c594772dc6fe7469c7a30fe539510fefe015fd21d6a1a30c056a08353816fa63e7607d955fdd5b0ce62589cd23c4ffee2427266126d5ea37ed145e51379715913721da24ff6452c541d6a5963f866b78fa576b84e6ed37bc97d8d7b521e81d248b94f03ef688806a1a11afc879dc4468e7ab904c54f367f7444cb188978acc98c31cd2f0437191c7ffad817440bc19b6854e3c0e5c0b17949583c5abe62e7ecb307992dc0021a4acaea81b3262ab706f1cce9471acba5156fdcbdc247b237900684e383fab0d9d894331e0daa1a12c22a286241f2db2267697c86ce1ac3910fb1f131679d60e290f214222bbfe6fd4edeec07212961ab61801977684248bbd7c9f95704a98f19e973f78734b74d889f0ba9ee07e29867462ffffd020bb357b4a96f190c1aa6560057ab134eb3ee5cfedca971f1931f1db36eed3c3e124f0f434480ddad39f6537615b6ada1e6a9962b0ad67775f109b0022d35c57a1b37528dbbfdd49d4d82f33e20ff044d17756bdab91d04703726010fe01c5201f26edd88a99cf3a0fbdc96845a297f1ccae7e38a41dc9a23e46a8a741a3cb145030a3e5b52d35a8dd2ca8215b1c6b95cdf4f01372670bfad3d921ab6801c5bf4f9b09118f909aa30254ffc660e2d6a6b95eee67a03d9cc37b9fe17994d64eb9c29a5b1006bc901b1f7bc0ad63fe74bd9578a45fcafa6936dfe57dcf109e4ce84b6d7a67a0ed66351a2dcb70797ac21450a2ea2f57d5431cd168ff99b487544e428843c0615a7428a228f1fe7ca649aafa34d6fa39a82f1862586798e8274e099e6c453302b1fbd133902426453baf17c8ac58c719fd271f74dfe50e2834c84ca5a226bd2bcf2ee867c99c79ab0f61e1f995f8cc1df2cb04a7f381da03dc77c5a9d3b0716d09f25f69b6ded559ec6a5de48821e088717c24597c68be72d17d48fd154698ebf1f84f8db945f785b44f612dc0ff469391d2298210e088d6b207d691d5e994d1e837692faecec0561f1cfb8adc2abd08c3f4e680750019e58aa6bcc37c9c377329180bedb1a2bb92a62a0fd81681bd6a0933261af3e515732342e78596e8c57ac17954204cf8cd0ec4a5c8b66ab69bcf5df175a53cfac56dc1da183a66d25a87af2283b8ed857fee3f59ba6bfdec843e5b47e3c11d23a88ed51d3d85c511066576c03d0b06bab41a943891ee182037e6e24b280ae2a6702b2233a9d23e13f2a7453a27775de2bbd1cc7d001213f8e0b4619912e2061d624809bdf57b41a1bbaef5952cd3676708946d9e6f590eaaa32ecf56e4288f09cc35ee7e8f01065aa8ed52959ee3f6a64f1e0720c1354c72f6ef8436a2e9be2872d4433ee4420518f249587490dbe215c14040a185f0cd4f9e8e2ebd86714d66fa077e87fa3bdb5c959edf352f711d8ebd67facba6a2a22db7267a7a5d75a9fa3d57b3de2386b24297d1bcacc1a9ae1cb3bb780bce702a3b8ca3ca46529e9fc01a5e02ecdaa45519225ec76418858a68036ec6a0f16aa8325528e5a707cececf3c80243dcbe22b4f3429a6dde0dab0207fb0aac869b4610d5223573e9986b60ccecc65d41ac08b1508a5b894c339467671574339cf7c940bb14e88b805e2acd3c0bf6275ebc49339660c0c490ca62beccc90a5942ea4bdb796589468be619c249893172b8c7918450ca4bc54515751d1df424d4311b0768a9401bace3f870f825739278f84858d0ae48a79f9d6446a0f043eb9ab52277e807f245a2847ed208083f85f41f5dad5cfa5ea85782418812053f93df18b0a312d32e2549910090bb92f757fb0be70dae114a6b935a212241a31f85e2e5143326ae8d006a629eb236d9e6539d24670c84161aea4645a4c2b517f11eb5be35e41264521767bb3b755b692e05d03d9ebda5d7cdd947c8bebeb6d4a80002354bbda0725d604a091fc99b8378b2259a0d52a5eada520be22a3b6919b52f492d3c18a3eb928417b9493064c573ef199f687c722d1574cdd5fc48d35823d7b19a8f5b8c80e96600124d0fa5393d77303b49c3cadb0aefaed4c8af74cb0d5945c08ccd6cdfd44b1c218f37c2628bb9f4378baf9bf656b49b857f52f961a47471e16070f600329399fddb72c35b22714a8bd047f4578d7739474054abfdc4e0eb4783893298269780bbfafc717cffd3d2933503e77197ff431eb812e20085b7609713513487fea6db5162e8c1bbd1ccba544bacf6bb45ae04ac7e5fb1d1a34f132c2fe22a2e8d9650b31efc1ac0c2c680ad9fadd168b719e2759d330152c7ecce57a8d3f1481c98ccd1eb03b3e050d467c9b368cafa6a594c0a9c38b2a234bdea7bbc1b3e5a4c147df8fd13334f8d689e0e16b461eec79686862b251a0a68655e4ba397ddc8c9097ca63b29fc673f09f7cf18707f5ea6d612ecf0a4cc8a4c65ed03b2f162d94bde82caf887a640b3da619f7a0c0600b1c1166793cc7e332bef15dd08bfa2cfb39c58437e89ea75badf512880c29d355c7b0ca41fb84a0e3cd49bba679f5cbfbe41ede0bc237013d05e6ff610d25a4732e98f0842861b2675e2b03e8b771b2e09ef8111015d78e59482ea194a435fe5e5307acd56f0460e795322225ff37326326a0dc1617e348ffdfd94e1b12828cd27e8ef45701987543f866f42d173b0c85545f92c5c2d58532f5e39186e967f587380bd5a9503de44007873ebd722f29b2f4497d5ee5d119c1907ec52f7ecdf08644dca448bff502717d35a9c6625166af2c9cde495bd8822900ecddb960dd09e6d369f67653a014f89a49e0eff4d4f285e82ec28f1dd2f84a06d8f240ce41c5d0316b224928214a303c81e707deb18a1de944168a374ccdf9355e198d6c8cdce47171e1d10d4ef9c44652861147b0a03e10749539531e51bfdfa7e6bc771c09b381449d510a4d48e3e17d099de81bfb5ae690423a9af957e0d47c859ebd356bde48f265e0915aeb5ba838328ca5c77a88ba509543a9f8cde7a4a6aa54e10167b4149aaeed2a839a79238d874026941c69a756d1beddb494da3543719a290dd3e8331bcbcc3555a6584abc652d5531d5d72708d39ccd811ddeabd3287a64583c3ffd2240180eab0c34a641ee078d6de43b09bcb8944f87c0f5cb47b00ef6ad9e03ecae4b9227991db0adec1ea57820a849bb02468635c29f3969eef2689ec8e214a3e5bcac116082f777305df35f9278ae5cd833626e72b5d3792d94e704f431f93a0dad4bfcc5c41386e9850acec03e887500462c27e0077821256dd3471ed3244df9a9486292b1da9299867934a6621a9713568003e0ae7897709c0d768edb35a63e41bc2d79323942b3f8f638ccd9d66ccf7eea96ed69c754b0393937a10a673303fc8c200809caf4553eda3db09a0dd90ea7f3bead865b71faf38510e7033b1de8cad1c5103e93a770024023dae5bd0e80546475bec173ef9a453179eac2a5235c90559e6e510d8ae541ce7593a4caa8f32d88d5056a84343ca4877ecf8629ef8212db33a528c7aa50b97637dd9ac168ccd56158385cced34df1300084956adad5a595254578cb4b05966ba5a82a90ccbb1a70e13688b403f22b6f0757f69b7a6ff6af670a05932d71a5ce336630da9f270b4bb4fcac2cc5e470d4c72b2398e42acb0e35f38254f35c99a8981dcb31cafea2e1f63a9b979c147cf03ee590c96df2488d916e7b30ce79efe0937c482bea91a73517f56af3abd40380c6223de7ee08d8f60c48d35fa9a8b4b575883c85ec9338a5272cc8fe57e1cf16bda515f917d66dc4f29787fb532c5ec318300660ea3c577bd31f4d7eda2b6327704b4963c63ca2a27156786d6cbe86d4e7461f25b29e6ccbd2772e80d405751a911bf20139249d3ad004a49f703cc73639d3809b07b4a7dbe0ad7715d73a60e6c2875afb168e20609325ad66864baa93b136925a566116264fc4b46f812759572b0f00122cba3e17d0c8be705aa423e32d8f45243b3fc67dfa47a4db2dfcea4063085c57d92237c756da481702a873eaf24da155f313375f4db4e3e16de797006db28bd3c800f53177c48617ec7cf6733572ccdca8f06819857a08f702ee945c7e17a0730cccbe44db2f6550033a74d96cd04167222a7c591cb1ad254d0013183886c91d30c8d575887615bdf138d9f2c46849985df362fee8e06ecb3476dc61df1f3cfa697d79966fb048f7f4a349629b45c4c181d8a57396b5b2360ccd8d4ee2fe84fdc0b1165881c41408a2aa188740dc69ea4a301bafa6b7b6cf964d2cf9deb1fd744ae9c6e3804c7fedddd663839218f6ca6a6aaec5d8565c4309237c2dbe9562924f3f5460f6f207ec56df1d3796a028b5d66f8b77cbae77fec822ffb593a0d822e58501b6c6e5c1c41608cb05106c4751b8ddc86b9ea3129340a10e5f6e481fa8753382567365fe7d33892eacbda586c1c97f2a6b7875c510de40bd817671dfa07b7cdd6efad1d3c4236770d2db98ccbc7dcebb638fb93c8c2988437a8bba6ae6a0666f48a8ad5f50aac6069feabd02becf6133d0da5b4e2dca4cb4fca819b4ca565f1879bb40a574b143adbe30b8de008fb19464e522dcd107b9d0c9f88f7d07b00f710a44e09a1454ef81fb6b1564b77bb1c7209abcd938d16a715d669956e54287ff5336436c992f476a24518694ad47cc357e50ffa67e30cb35a045e6bac40146fd4408f1ac6b511860dbbc0719e0ab8fbb001f3f6d3747abf533aeddb0fb9161c7c266920ddb4453df3f09138d0c4771bb3ab0934a2f33a381d70c8d24ecf4226741b73a8d12524e01c97c13c6acf7b7e13ef78991b21a516317858fb7b68125fee990c0b1de8bf393bcb0ef434d15c5ddd73fcdb8e23556c8b1b355e16affb086dedcbb9b922139268aab7416e344db3a13a28e2e2c41fa6cfc95902a80be6b1160e0257fa087da88431ab09f3435b16d900279d6e9802be3bd16eb59199253d1458e52ccf29ce0329235a45eb09927b7becea06abe7c3c1bbe31f0a8a1c94d33b6f022910c17cbfb4650156bb2a2711def14029fcf57d4f6f0b8d1d01e7dd2571218b7280da3e7876329666a2b7d0fc17f30286b2652a5d286f92e8e5d87b7697995932701dc426f864da0e7a1139c20aa08b10f53ee43bfba7d83d298e48b1c53c911fc8c6229cf98abda0550e2528c4995fc790d111f150b22c98604e92b68a3f12116f605148979b2d59805c3614eb402a2173edc06ec8453a83fb4d58cd1270f4f8605f627510f0ef5201c4c4483e6b01ac22cfcb188e5d43fbf6139f514243d2a726c1ad127072b6424fd620fd5c24788320b276c5264750e514f5fca39a375a3d8fdec93fc21ad40b941bcfa9a5f02f547edb9cfc7d30316e9b00a027a37f4add37711dcdf44958d106d5c8ea0924c39195539f0a3938f2394c17a367d136b09fdd2acf87ca7230c4cc26fb0bfb681b03c6ed19f51b25b2bcb2ad6491652523cdd7b08b6983f103ec71e7ebedd2be5a73b830993c1c122fe668aa776a2424f3c97256c67af640662a74ad7864cc4510b9271e4e3126ce79bf7048ef4f3bae048ca5a19483834a0b7b8b9a32663e56726a75924a20f00773d42d3342d7714e8ce81a87e1fd2cffddda25978dd17628b0d692aade7b4e2dd3f1986a9e7c923a22c47e4e88425c06c61b8e614fe4201cda8ade93a9f81d40178bd472dc800ae14218370612faad6626d9658a7fd3eeb44c9eb1301bd4e15ebb54bc52c355059ec00c305843dc5b063a5f2e5652b41ae8f326b40a326d7b755a440fcdab54ae8d23c48187d0faee36fcefa41380b89e955bac0b860acfa09ce7e672d3ff3c01e6c65a2909667227411b6a64b18459c388244740372d079fe1731ce7d997a8b208424eb3c06f4b1f11feae642890583c0ddf9aae86ef8f2cec41b93b276a83cbc5858e145dceae504498ff98217ed6800b3d548e3d7a813a77b1eefc8a520dc4846731a0ff446a97f2f829dfcf45521f02d7d7351fbb5e878603722eb2df747688be405daf2a9c1acc6271326c7444a78c063f20668ee5034ef614a5ad28a21f29fd484c5b784b19329ede3e8386f85f93ac86ebc834dd0b97c5525ab0cb34818cc815e8ab95e5de36ceab685517a7b32633d6a739f9fbfaffd52b2def306a63025cb09955027a6ab87ce6eb95446b40806a965fb75a5428011eacb90209796c825076603f63eaf5505fb7b5517a37e228002b93169e249f45b800fac4d25775379a727e38702be726a12d548587bc62a31963d0c22e6c7ee660355b2b026657944d9c25d26e8d8239914f15fc5e5404f63357e7289eebec263cb9a8c98358b587c2bf692ab4b8ec6fd61968cfa27f0cf48a874ce126d934533dcfc2bb42e2388212c1376580e1c83f85907fc6e03c9003ca61f8fcc1cec818c26d972c9cd3bdad7760c33dc52e4ce6002175a6beb35dabfe8e37a26732c827a8f860b69c3917ac430697dc56644c8704d59e70cc3bd7daa11cf02eb314520c07c591224a64dd41ad8578ab64b2377781e616fb928da836c8a980867d27bb5ba8ced4b32ca074b0d0f3f93fc16b690146c829dd43d13000592c5143a63fa765d2d1ac77bf5e6a72f68508746b07dc1806c247df81f8a7cba28dc8ea12c78cc1b5b2ab9e85d13ede17caafe372eceefd2d6a59ddf66a732b218668637ae561adbfa31ea4273422b83a2e54e802843f88281d3b6f9b68f112eb59a20a315a01989e4e6534db39f071ec94fe9525ea862fd3d4361fb428268be44d9d528ae6d332abe7907436d968b6baf9bcd4e0ea8fe3282366c3f700ae1546db086ac09e35506baa0bf7ec8479eaaedae139aea3a640d78807a80c2acf0edec7176364eea2bb04ba8fdd290d5807caca5c0a8aa495073148608e90d93dfc3a19f1268cbc0107c3abc1a0a8f257c1d4e34adf4ac3d346977362170d2962d08baeef823db524645e53e8ca93bd99bad3ded63b3e731b8325716bda634775ba50e1a85af048db7be836a797f07923e4396b839dca7e08c896d1951276d3676f71195e106cfcae38f936c3bb86f999da604a4b3fedb3a2807d9440674b6abc4688941e7031e9155405faff07637554df0a250e6ebd27139db4cc12de7260bac58e505c3418786456b3e3e4080ae2702cc8f1bec2dd6fdce85230a29b57e6bc3b4a66aceb722ce9550671dd4b8412cdd47cea31ddc9d43a2f0c65f5bf29595f0e04433e062b78043e4a9405625d921a1f1858a0015b41d7b20f5b1507e5467fc440a7a2576a7676ca170be0a6e62f8147e47c4063a96af18fee810a9cdb98ca3f0ad8ed0d30a5555d44143e6c8b92ddf08b13aeab465ce84c092b61882ca5a332673e688e523a9b26d302ffc71b17444b6663b3ead55bae9ee11ab7b0d47d05347d1a547bc3315474e365a92d921bb3ccca7e94e4086eb0447b1ec1071c34d0d9ef520b61b2ec0878ea14f7fdced159a016763e3ffb62a63a3a5d03acb0d62fad2309a5bb1f64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
