<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fbac1cf0c5089a15c6c7352977b320574b082190d01e4b00d9e9cbdacb8706625f976aa9ba4fd511ddc2b8801bb536e5afef645bdc8920c28fea6659297501e761a9a39fff2903d0a1fedfed962963e8420366d8d55a8277417356f7219f7dc9820d5d3d552acaadd6f011c2528c41aa3cb7ee60d8ae4abf21729a4d1d45fd24c9fdb49f583e5a97a06c2ab3bd3a97664318850a51d85947f4f1ed44c358504e65f1fe37ade9a1489e60c0d0ea755ddab8e55b4b1f9eca5abf3a4e1cea416afaa3d1cc0007ca39b2580f81067ec057fb100562c69b0bc0892041970dd3ac61b44429d0f71a758a426420362a626c1ed79cefb44e72fa9a7d80728cae0f76ee02563da5a124c716622baf6c5b4d6655e0a74ec6824ffad428b0ac1fd28f069c677477924803e2419fe613ca625fdd08238b619eed5e83a490f645cb2adc32b2309e1b4916056eeebcc660db205cfb19e3738bd8be008f3b6e0ab0fd83e09489f90da00fba2e37b74d103d82d3263159ecbed56a80b1938ed06ce34ef5e892287cf8b80941df1b8603ad958060e6596f2f2621fb1b449b1b16910a853ea8cb2bb96c294995102778524a50598dd08b4b06b18fb6ce9977383ed369514737b1447282138bc555b869b85fe9da3298c992f5936c8c28e04d32d9b210f8da6754934cb98f3b351786b643cad2ccb020773401f6e2c48f1ba05bf868ac3480043ab54b8930466d00f76ab0c50bd59281510c28f9a324785d661833c80d3bb4b8ec59bb3daf75e332f80bfefb0419be17a72e2e070b33e96c5a9b3570db3b14e7c8f8d9b217fe7bd49ad9dc8831eb79ea82a7994dc42a60f34940fb03e6d129709283c865ec8d6ab8b8dd1e9c3b8f3c7dcf440e75e272abef02ba41e9d633df07dbcf3cc39f8ce7ce22e14409aa07ddb22d824678b65d64ddf3880aab123395908d0484d175d63dbd96dad63dcd26e52a24da0379b00d3e027d501e26409a5d0004b886707d3faaf4978a12afe3671aeaa4042bf4aaea9a1d403a242335801ddf4af61c366c518d1d34eaab566801548a830208dd6611986ae398b8fd3d8897d19691425f61414acb453fc42cd25579bf337b83446a2d5844188dbe69ca109715ab0024910492aa824762e8782e4570cdc7e11c70473cc374c331bbc3c1753f01027275b7eb4640979f489a8d7c0d06771f42bc88d600b755c81e1e4ed77761db8dd993731028f84c127cae7f7407592865bfedc5f7a2b998ff49a5187f5ffb8748060c6985597f5aa6fe007aa9af9676b2efe2148d0d997f768a75a464ed3d3e631c389b8150747fa830a9eb0b1e88419383c9e0958b159ebeba3bdc5441bcbf439ef34910aa69dc99de6c0e57908a8463ed42bb116722b5c523f8d300c16a1966028e2eb7627911578dace54ce3272738827652f6acd62fb94ecfb1c45c5f5bd902a0c43c63571c834f6d248bab47f172634be53ea5fcfcf33076e6572d0ac5d741652ce00e585cf5c1e55adcc25357d7927a88e1c8e4fc298b60eafd331e90732566f6bde00c7c2de4128f4706079347f1ec73a0058cc0685db7067fd8b1d41c1aaeaf89c49e0ab97b073654c1773d52c90285f2a35694b278e213061509d0a9d15770f31ce7804a59da4495490a1a54c5007f56dbe4bd7aea2bb8989951f1e9d3fed9d0c9b5e56b7498883130c82c4ea0121c5e4e8c4e505f7b48513a61029511af9a31586b0e6aab088ae6a4dc02311bcc7eab8184262b31cd18166413b2a18d106467caab3c5dc73b9c2941ee99ddcaa5716a004468e610c5839e22986e51ee6c301dbdda98bc93ddfd13011e5cf90ee014e87910339244bebd0e169639053d182e17d2aba35b694a2521a5e421b11c332864e6afc62c95548da17a9d1db90756172179c80560a987b629527d27a3bf6b587a33c696672eac66b5e4919656d84203dc2a2607d6af6109cc260b884bb92392d2fdaa2f9b8e775d3b25ec259e15483046b8732e91f4ce24729eff9c1e1fef83cb36c015ccfb4d387b08c9aad8126d10df2079507e3477ec4ebe37671d0a11472aae092d2c5b9cc1837a3e18d6d9fb90d1070bcc5d9ec2c178833c957de6901817b989711e84199b7a3c8f986b80d44c4c484d66d0ac41e6b3e9c3831d1b8f447471f1d3cc352a7949ac594921142963f1e838d24b3e741afcbb8efa1a6079550c3fb949e33cef9ff7e3d53bda0097b3ca59f7e82f0e800f26f244731c5ed789eceb3b7871cc6b090104488b1fb6ea7646fdd4b9ff316d765d362e9392cd2004430bd6dc391fb69cc1b69334ef7d3bec37f090958ddef3c7cd065d7faadb62addda99bbf69c347d6e968223a7c6b5a19cc2efdca8c1e5a21331ad1c9ded4e029e9badda497fc6049ac1f83d0e4f40f8c9efc645731dc79340b8c33b1b860498a1062a1e2ced9673013013a2c62b0c307fb0723075a6204001473b7b198c9b4c4d4264110788d103dcd621f911eacd697a13aaa6dc31ffbd5c78315a8c93634745ce55e6f847fe4a1b2b391d82f3792552bb096913d1e6edb22f9d5680ebe3114357de39002ffab88af5f4c5bec0b8abd1d801f9b6a1b22d95932d6244bc70d24bd22bfac77d9a178ffad21e2992f5900fe658c030984973e9480d52382d6f967d799415359206a0edaeb82b13ed2b7e11efdb39f0e68f5e66eb71e0777fe58dc2d55ecf22f109888ee9807b202972f53a72b120443f5495fc400de7c9a3291151ad097f77c2b9da29198ab845d36ddf5d84fe16b59e28ee65e88496fe98029c2546119ce402a9164c64f010aceff82a552f9c36a39cf1bb148339c33f06e41db732c009e900e5b412f8c4cb0c27dcb75ec9192fb3878a1b5b367670576385393af34eb9f1d0db25bffc9141c8027ab1edf55652a0ac27cfdcf818a8853d876791d8579bcbfa90fb02f203c8d5cb762f0510c98d7f352e6f998441aa329cd755bfd7aeb7743aad6ecc68e4e85a3c93d2c6da928f8af96443a2fc9748383f495e0eb368abdd1693b7a44d6473edc22d47a16e80d0c887cc27009f3371ae2846eb7afd627fbbff8502fc829e68a8698a693ca5ce9b2fe8291b0ec18acfedf0bb069f8495c0ad17e77419ec3a5cf5680e9185313c0d6429c3c70d6548fd1892746f9bd9da088a340473087dc8da3d1b69b9a54f8c677c62a265c427f1ef5292e6d7df248e32677aae2a4559c85a411b7a1bf23cbc3fe696cd9612b1107c4c2e4df55e106bb431def909aacbc4d4866d3278d037702e2ebd96997c64953677b52f60cc8a0f36659ad72a91aaa468830d06610f10dc3d1cb4f4a96f8ccdb5cc4008af7a6a2ed82df63199e7247eca1c8b416785be762abaea3bb577965cc0d9e190f6d76868552672af37159a40f44ca0610e4ff7a1c83584c6db8bb67b77d483ad1e613e7c914860cfe34220b3d0551c357e57e7714a5a76de7333253e6867d126691f74aecdca0bccdda0feb9a6194384371eb3f94dd3852cee819b4f7f638037b652912792d5a5268b78ba4b721ef132b511d436dcc7ef7cf2ccd5d32917413a6cd1aa1a5cc272d5c3880f69b9e4e2b95f48930f684e6d66d5b4b558990548f1a7b3b3ebf064d9b8afb7fbad824d66766dd74ed33e6c0d14b31822385858629cdd47e53ee9f028d326aae6fc283d65a0dc4d26812906ba3b7592473ac1a3df13926883be9e8ea63b8efe75965f3d0cde16fa4341f12d27ddab1f774efda5d3df9b46d865ecac3b08a1a3722200fc0d929a91da8d2d60c0cc3bf5875914430eb26af354f8321b1f94f6902989720559e423dc7996e7980bb324b3f78b0e4ad2426523aa54cd16aa22b9ee2090fc1a71cf779d7144fa600159d922ee0b6d468b81b4946c5fc65557f673dc40fedee534803af1b076d3f37c4a7a13aee6117e70f6086c31169863dff22c9bc43e702b7b043b501e6a91ced4083371373ceae16887af8476f2a5992088ada271141be81721e4b9b52f66e199b9dbace54d74a9373d4383d9941ec8863d3f7351be99671678bcc07a7e995f2a1ad858c8f7a755bd46a17f2ddf2bcbd92764e756f00eabcb9eefb67520449a7fcda3b0779261a3de45d049161ff5d7cac4d86d64e2096acabfb4b5007d73283562241dee4015d38a04e4fe5742f63eb5c78634797ca3d088f9a5aaa998d93e5d96fd439200f4c589dd20cb98a571f68df29fbcc784aa8318fafb7b0edc6d41f9861247d74ef78b1c039fcaa4b33c205a70cc2d98b50341703b8f7983ac6a1e22a4e62799f92610a32131bb3f0ad5f0ec4eb65c43938c7b6dd02b750e967ba101880dc8a465e21191623a3704ea7410fe2177d61314f63ab0053c02e141a9b3f89a04e38fdb8b151ce0ae973a0f753eca96e78f6295a5ea128a4b510d92aef43648aad669b5b3281ff459e921a3b2194077fa44c815913125afd1a09c469aeb1e6f334a13996f72fd32915339d002b72275339b2e43d4687b69caad849cc448f1a5d8c47ab14105eccedb208a87168b8813a6cca20fa80e1bb79313685153ce3344a116772effdb00f1a93ce7cbb3774cd8378a0b12cbabc1f29ac39c5d913459481c24bf75595181a73743a0fd11103f8299373e1d9d3cca3275bddc85e01a8189073a525f49058461e43f6dc9a422cceef6ba2972c940aeb7a1a50819a6612ba755c5720b835e97d40393f49e9fc33573d77d172bcc72f67699e63555939f01e43f8572f1b22d61d47e26962d566ef1143e5403c31b4216aadefc3ae60f78355d0508b891521a598cd260d6e2f9fd0d65bce9accd0c13b60c2cefc7da232e2ad897a0d51e45df407cd4380352b0ec83299d0dda392a36ce4c3887a55f4a79833d33a529bb8725f587a398ec25681091f149da03f3ed291ad6349673eaea563710bf223152e1cadf1fcd2d325621df6b16dab75366deb74cd41c8aac1fcfd2c640209cdb6379a673cebdcdeb01a6c11402db8561a5641243f0391db819ce8b167e37a6f3d6bfcb11d2cf96d078c615ab44863d1fb8b020c791ab1f68f7c798d5c8fb9c1f3aa5a44b0f0fe88f3964c79c80dbf570e3dbcde0c14e6fa27fec7ba01fdce00125c1331674dbc9fa8af84467569f2e4c31e2f80e33e54d7baf66338484cfce2d400e1eb8829b1925a7a61a07945e3112373512ecb27e6e72c8253f9d419131b0721e0e52ddb69d9ad6d3659fafbeaa951031cb831f39300d9aa8aa54dbfeba5b006682c1f1c5357f988e0fb0200a26b1725e586279e072845fc232fdc5caa59f8f5d48f6295e172143fb97da38c98d5248eec00005b65be52f099c1a9acc7ae23212753469f3dfde4a2a81e50a0a7d65ebf236f08eb00fc724f812c0e1e2e5fc7f94b67bf09870000bbfafb05129a726d507351e9977bb1487a0b8847e33c7580176abe35abf3e9b4116c9bdcc6d91ed4d6b841363ad2efffa80331456f5331ec56dbb857f92ef30811ad7d996eb57a63edcf6d858a15bc3f7b3555985c1a46a4b72b6b4e70178f8447b8e00983fd093403862fc88669434196698b8f12f3d89d08e51b39a1bfe2773a99d61e37160eb7c57be5de4b19c8a58cc49124ce2bc69d87cb67caf4ec0395c06ada77c8910a12c2e775d58143667c2954e7c65f23d073346d7a02281a46466804bc7c56db4107198a3b6144d65fcd735663f3bf3d91396ad630c53524437482791a5566ba308e13942fef5fff884e0db332bf67d1c9419a6f18516d1997e5de125ad6ebb30ae9fc49237c7834ff694dce81db3846308426902bc34be0102ad361b592b9548ddc6c9916414fd9453fbe9ef8f24cf46cc1c952ca5e32b2d8f6010c3b2583fc052b1abe5cd2f577f59d68ab8f0f9a1422220326a69f11904dbd63183264f5ad546633fe303d9d5de1a4fdcf750b6823bb7717a45e935573ce043f27b953b80e39860b3cedbf15a1c7a1acf77688cd55ce2cee43b3af65e7d7e5403ce433bc337a7c5161b2cf968472596fcedd5c78609582ffc8dd9281c2a5f0a24c378aa110fbfdcfb7c75ff639f83824a188fe1dcf60e97facc5bc88599876bc2f275cd910544876a5b9f26a7488730e1700fe33f21532c30d8a8e2df671cd9167c5e4fe47c71a45b067873c7dc435fbd4516bcc7f22bf6b82437167d0ef489d653f9fa8c39d891ef1b0748075df7585c427758ee0cafb94e7ad26e3bfea26e8ea096ee0c735f12646fb8b10819f30c0467f3c26ef290701dd61e198d2b26b15907b7c3653b42fca43d0b2b2b967b2dc388d72d05fa4927726efd31f9f1733ada9338b4cbb72378bf4bba02513878bfe0206b59c66f2273be6e0b498b9b3f56f23e02ae1d64519c794e75a16bc3e32471d8b525cdf0232e391e2e062df670c54ca233d253d1235ca986b369644848f3c2c2be45d60f8c79c40b03922ebb4815482d31eff6b5018487f8537b8d7d85fcd3afd905ce59cbe6c94d94d945e51289b74362bc7693aa34f9ce25868cfcc20c71733d7624b73a9a11117f4803886683ad65b7c171f50f68184d16cde927f8012e1c3dba38e75897f73f4058106fd1b12b6c7e86c4c2b715d942341c2e659b86148a384020f44e90001d510c3b9b1b79e4a79cd2cfc9ff369af19bcf94df726ead5b22fd9f0877637953cdaf6974808934ffbb8c2521d3c3f03ea0eda5cf4625604e178f00df11afa670cacb605ba83f188c77ae63a699bfed174d6570ff38ab8f15d1b08aedc73f5099f329a8f72b543f77747411feffee3c0fafb91327027429b0dbfea96cf52039f97981caeb0e6ecd3d8c936b1a63f8b0cbde1914c776e9f4ab6b0781716fffb028c15abe144e81d6613d410a5966630f2597bfb956f3dc3e0c7cdc6c07ef231868750d14f65f42023bdbddcd78f8fd7aa3b3c51c8b346e294a9a65f2b8c34f107a025c8bce31ead6a0916fcc242dd3c7e347cab7499f4867f3db78532ece4f5ab33e4744e772f8b9de09a6b40c517ad9c74bafef5a315d9eb811a6507ffe46d8337547abdacfccb88bcc33ab0bf1927e5b485f125064ebe5025f6b989b874b5aa044e258b4bd9e4d2745935ac6dc244a6bfc9a605b0c1fa4cf8ac2e0916602902bae7071675d1c875d5efbe519ecebb2483b4db0b086a3b23442b964d22822bd1971abfa867c20d72300fd8936aad30eba170b4046d47774ccd14bbc692e0a8a2d67f951bb1bb716dd24b903b491228b8902b88add22614ce67a6ddffc99a4928bb3955c293926ecd418fc0e3ff8e0a0a92e0470708cfb81e074345ac398a6207163d032cd05d1a4a144244e33ad48b3e30f224236215632da3c6115072562d78b23fbaa060ebc8631b29f2eea01781b41b491c12335c1df957d41ec124ce656381bb61e2fd09e3ac7b2af22b472e38777ea0b78ac4d8b65da8420abcafa415ec5607c8ef2f37f5ba33c952664b4c5e194bb35dbe18c6a6c493c6d32c3d927a0e06b4ce158785208ac37d4238173ff2b050eec1a3b962a0ad02f936acacc3b1b6e4c56031261e5b5e893822d0d7c74a4e58e2ec8d97eaf00794e697b446951bb9a8c80a6157a25d822e82048bdb6e98193fc742f9ce8885aec2101f4f738742eb2e98544d7f2ff5a432b5c4a53e0b058287473520accdbf35725bb0f9ebeb8c428c2006f7a3a8bf31b1c323ecae726fb22c28ab175f7570261605c80817ca6271906a1c00f92034dcdc2a34898c4e29bd2730e0b14ef28a9fe5df675f82914337cd44db0e428099403db00fcf5c124f28df6d4a8e7ca8c4b199afcdb9df009c9adc64b90e76336b646a3015067dec06c3105bac01912c15ede84b85738e258c316f21f4491b38d9f9766492fd884c4c7a3799f224a180a81de69caae7fc60adcea21b867f6ae4381d771627b74fad790e0fa2111b70e4bf804ed49ee001a94e13ea1f835c2a3c272011630fe5a973106328cf2b325829ff957162a79829708b9f339230f13e24886c3037a37bd329e74d0085853f40ef3dd1f592eb9a108103604b866e55f7e7fb8d5425c0a8fcab0d98c6c86c1d00f00f6ce9243cffda53c82e59084fa9b53f4bcd36e23cfe4ef5b933279b0ed279cdb830a0112d00b348841893fbcaecb5a1962efe662668d0cf9377ce4986d90825f16d5744355ea9da7993deceff8465eb00b63a6fe9ff0be5f5716f5f352870d2a8cdc9581801e52c99b6b019983d7f7331afdc273da6011d514419f86976feb339f5c74354f0ebf7644b4ee2ca0f5c8f8259624f3ba0d71718f8f07e68fe9e7011826aa18eae9dd6678c9bd40723b80b96cec6ce5594071876ce048a870b309e4b6a1cd112f667a88cfa8e6e8bd470aa00bd43f2b4714533f4e2ffe917d47fcf0a69e437f2d94420bcb2cb6d449f8f5aa73df2250578ad7d7470a3a5bba62aae653e8bb36027077b6e6cd14a58ba81f0ed4414a885b78899ddbf012671af1b75df99c994f427102545c6d82fcb7432b948610a731ae043ed1db97a4b8c41c2231c75787941047c3017a10967a90258ed6b0a9ceb1d54ebbfc35ee24c65b53591f586b77cad2a75140b6acf63c0a0ccb97233106517013954fcf08cf3b4c5910119cce8b7de8fb30682eb1015bb35a533c627c8cadfe3dfdf89de401c3bc1ae3a2cbee21d13fef9d95667f7a282ef4ee78386a8ba27812ca3d1ff2317f4059c7f8f3c45e092cd3ebd9e26ad69c158e68068aadf03d9abe597f224e373fe20a23b3f05c40c45508d1366f8fc6717a98cc30eb1837676cfbbca3780ad4199c8c54974dd1cd69ae2e1865936f98358ffcdc52c21d42a13a619c3aff69d411a4904140af494b03b239803c2c7b4561b78a3730d2925c0b5673949b9e9223a5deeadf8257f6888a09b1a05fbe01bb379048bbaf81e2a506fde904420a3b765e79a9112a7fb4f137f49e0dc43cf74b08fe94adc27299fa42ac281a3767b9420458b62d324589a2c3054be6daeddf6e699334771470a49a9dcb2c9f3453d2ba0732e71fde0cf36a167b888cfae2720278b577ae039912be09a75633326b7d07816ab2a82a537019240ab6cb921d23adce2131975afda1180d3840e19faea22939c0f7eb4dde05cbc6d2efee76b1d533b98257b0cffb226bea234cd1104a31369fffcd44d4f7be76957e4c9950ff67c28fbbbe68fb99039d23b5f70a901399dd7edeb432e48d458adff533f37cd16af17653155df509c5a1c6f0ccd9fee232a1cf372182d684e2fa95b3a655f14a83b7f8b4565a075ef9e488837c5f7ec59ffe69b7f652b478c61c249bda58740653ee23495bbc8483a584d00f660060a698c460b269f2904c8a44de04ce6e45c950c1c2fe3210d7da21d93fcfc40b17c8402b3e8736ca5fb71e1dd6f877272546e22c169cbfca32b8d59e2f64bf16470b1837136edd1af8cd796b10af997f4636b07236cb149619dc7a6b49371f8d86876d917a2be16cda6e65df1e0a6f3a0e7febb48e25f36c609884a2662b3a8dfa8964096a99cb2f65ad9dc18180c6ce9ba0a178db59f95cc97d5a1f7e5fb58f1058de52855052c35de304b63251519a94282a63195758393ce7a56a4b64457a2a7923c67254f3a05c77b3c9e662508947bebd3fcca94bbc8684c37abc5c54fc8812888f82bf4b5b18df6efffe80325631bb1ab2fec53e23e249c468cb1622500ff606d5c9fb8dc9e49b5a7d0e2d7517303cf968f070f6e5e39445db441b70227fb7911f3f42c38ff40f4e245b418878631359fc3bff72dbeecca4db9aa7ba994bb0d816b1e6b080422fe0ddeb29a88386f935bace79cbb319948bc6d8dc42e0dd16596bf71889eeb7a5329b32900940fbd3c48e7964dae0e2697ea6edefaf36d1dfca4f0156af809075808f382d3f28ac996bb75af64bac2aec47a819176734288a98be5372bf73b9ae5744cbcea204b5264b479099fe615b77b844fcaf005289533e471996bda7a249507240b7298987f8b3d97513fafcfe69e2aebba37fc3d6a5f518f12b6fb6955a62f86390dfcebbf4208378c19426b8f1b1a3686d302c1ddbde25b4eada51988059c32360b4aa43a772ca67de3c9524f7c439db3709a57da2df8266df73269088ee493a214a1fece1b3a6b20a023ca32843241842d18e31af2e53cc9153f86133ce536acba3b764501438c34eb593b646c04f50bc6d63ff5e68e8d1210a8d47c8c5856e1f28b25f99073018b8a6453e8930b62c57077fb5de18bfa3be2c12b9c1ae676af0a0ec53131761bdc55cc1b36ed97d036e93d12e2df127d6e8d9c7cfdec019ad9749a183d2c27f524d19bf6bedf0e1a46c89e068f0a9851d067f6a1b26b6a7d7cf40e723746cffa47021ee9248fb1e317852470a22f9c79a7b73b149d95229cb2d39c3f8df29effe1a08713f1957506e03b068073676e193bed2c771b56a24441ed3e70900ce46a718124b10dd0f8720fc3fff29343e1be91922431be7c5385de1ca3e98ae28f96cb0d355f54f8e37e222fd00be974acd390bfe8b56e6fcff8a9aec3db6a624bb9f5221ff61f0d20197e9f48ce97e76a1020ecdc39e71d5e70fe31070439ce30b3063af15aa66ff03d85038c36f13920bdb898bb51130687c55c900e68846717e3f042be8b6503a8f100d91e433e5c315e4599d2cb4fa1b7beb1bfbced398e87adb85895e9ddd8ce2fa4e4aa506d2de99c9ebcee9e9fc065cb212510104b3eaba4a3116e4e5bd9e63c80d3609be7a38e064f4dc5c68f56bee0a7f0f8c99c813b29f3b392c6cce1cb801ff08e206b2e27bf587e3ae4647baaff78a35b54d2af58abd8fdcc3a438075c2c935d15c69ed0e9d3640ec91615fe61ea3f861e115bf424e20603e059df473e87a2cecaf685c3406ce776ab247fb5065cd6fa5b4b209a4e888dc6e76c70f72aa02473554523c20ae2998e8a80d4d88da486a95ad0e4584f772b9e2133fb3ef250911cbef173849b9cbf1b17090c3f003e5ad2d4093b669d54aa58c9a8335c7caa39ee16523e1317a1cb1ae094de7d2394f6648af8516d8297f3e9655b9254a8c7c9d215527373bf50a795aca433ce75a8a508a7b2bd60879f904560919825ba4d5416b1495fc313cd994d73903afe2e4f7643c4519906a9ef23716723415351ed7f0a9773745645564fb2cfb673d450983ce51136cdc2d0ded4921581126eb4e9a3dd0ee659de26cb4eb265404556c00a06d3dcc9c1b94cc6e26cb20c6e83bdb5eb505ef35b6dc385bc3d12b1e0a87ee65e92a71a7497677b7688a5875f520e2999e33f38d0699a0abdcae0c0f6539c4f16bdf4e973538f4214195d035853ea20b9e7e34d1399e1b9701003e7addaa21f49661b349863a95817a1f1d1856c5127a2dc6fd5eba3015fa31813e48cde1e325233eac75b25f29eb310dae2ef66ae327b1c57df85f51c79576e774afd256eb5b350a1b712a3517b88a8b00dad2c389b7bfd2f8eb23a02ba8d8e916c4afdaa956ca0a6c46c60df38c856b207a0f94eec5a10fef5b63d67cee8e4f5a859bbcc33c9c48b4970e629016ac9f6354a041af673e963b36e2764830db9f76de1662f160d9a5c51736f806a075d447d292be31f2f650eb06d9412a647afee43190b43fc3a537dc6bf0667286eada854341f9bdbd41526970d58bfbfca8970e4cf95ef05b02e328c9890f823b177fd583c9ad962dd9e8534c3dcb4aff655feff65f65fd921048da7ab50c610d0124132c66f92054afc9dcfd0923e45051bc832e90be9370c42d686b005d9ba47191db5c7d0a09b2371a09e2f88aaba79e394b4a05600b75752bdd98caec8198a905e5c521bdd49c2d102154f9575fdd754d6a2620d3b4ec648a2f5db436597f55fda4f70716f87adc9a669d5f7ef62978434ae07fa4c7f1e20110bb27afecaa04f204829666f6d93a4a875a89aacfaabb24dc70b48813f69736cf539eaa801d0cc18ac48ab09c6b8b10f6a58c38874e528e3e93f92f8c8f255efdc011d38a69aa0c2115cf7fd4303e58a568814b7e82871fbbeb818c5becb83eb60d15b47ac7deaf403f6781bc3769f2b03f033ca01aebc6a3f9b9cf70a45f492508e2b37c6d0569ef947dcfab4b07f73f3749350a150f4c2837d18baeac3696df8894f989fb2c598e816d4bef527e4b4c86bc2f2a24d7ac18581c72bbe4962a576814b9e569a2fea1f46c3b3daed5a59b1453c3ee45096fb3a7470233feb4cfb98d2c0971e8ca40f8b90d5a816859a02d380534acf0d5192ab8c433babcb2badf322c11ed655a7f5bbc35db70a07ce54adb746889dae8cddcca4743dd16beb2ae7ddced32a8141c11fd3b1d375e62c673abc556ca269926e51d89d3a579afb55a32a066df5e7c8851daac8ce3967bcb2365059d3face452bce9cb63ad1d603a92ad272073fd83e44c5e039614ac7a36a8532574837c0ca8d72e8d2daaa77059c8480ece06f7060381fa7dd4f8ab878a860fb45d5944bb7226ae442403e55ef30b9aa8a1e37314a21f41269d806af7d99bfbb1e8eecf38c7a7030207013aaffe3f7293256a9f4247ef0fe9cf8b19791673bbbbad6df4c0cb870447e15c54b1e0ec0d7af88e5f4b5eb9827db0224f96a4a44659f87a58d5df42ddba550669c06430cb0ea320c7247d78b3fc0dc68ca3132ababff97b1d424522cd3cbc8fbe1ba1fb1002f1cb0eacf82bf7306fcb0c7e49c997f1302d48b6e987df996c1451213b43a78d832268105ca6f1a80c44bdc2d8fb45b1ecbf8bfb21d2a7177dcdc9709056bd7565ce9d4e5c48b1dc098b5235b6b700a138aee831b243b1a4a41ccdcf90cc0e98c756ac5a015a441d8fc2145dbaa12f4d7424fce7a07103680665a09a500d694cbca817a9c74f5e27a83ddc4e233028dcec0a46f524e8e8e0b8125a305f1ea0ed5221ea8b7ee7e207459e6862798e74d99b1810a4dfd06e237272d017ba830c947bb78203fd3f81d4d00fd673a64a2973d510c6f13c608bda739b9984f9854e9818e4800cb69938be3eaf8256a475ac77cf11699a1a7dac6d4df83f6982505f984de34f7b73e22d88559e8c13e7ae62edaada30ce9c06882d3d7728d7c52588ee6531e64d4f9e3b28121cdb47832a5de4abe19b1e26be60b8dec18b0f90b5af0defffc3c85b82ce090733cca6a565b7f17500ea0db7d46a0417bd1b3615ced84c3c008c86b0a25dfe862d773e2321fc830ca82bf0b14d3067393287d7ef3cc7a9ebf04ba9d0fe4029aa75252c8c6184b5b363c71e43cdbcf652dc6f7ab850ab3d778d2e72eeeea70bca98439c83dbf2871ebe837f7c30c5224fb336417a8c7d3c9b27ca1453d27650fbc83aff515303caf3a659bf31ce6bfaf48d67a2113891cee8def2d089f75c5c5973cfa28fea959d857a0e24c8a93b520f682caada5276795342cb18fc50f01b213daf6f18c24fee8850b5a0a15ad15634e0daa91983a530cd30cfee1efe6da6682d4458d128725a208427eccc0630659548a78b238b2588ac202bf7a68ff1e4b5a2a9ca0b79fe59ce895cb04d4cbaee19e87179caba46678eff179b635e2363b68edd46cfdc1134201cb209a8d35795d9f75945a59654910533bab488df980a8f19aa777d8ba9f345dff18b7d4e164b4f8c00760336b48ecbb5f71da035f6438e508877f3c1c726bbc426ca729774f6604911f8712807d7514f948c0d8437b9ac9e0697f35bf45823c1ecbfdef77050139976915d36d0ba3ca221797d0a3839ed91ed2789ad30702f301725a74e7b599c03aaae6b29b3bb50a7780450c81627e6ed5af4a03e5a2ae7639b4d6e72ec0bba90fb6090bc212c2f28406325d992608577260f016e9a47dc85751f0425bacf08a5787c1b6471cd29514d26123bf9ed6486e4965c370438ffecf5d52b47848d15ab1feab7f1eb0e46b822fbd9e4cdbfe2dd950d622c4f34aaadc57917fe2efac4840c9701b2441096364f92b60401a2ac9496021bbc07236224cb59ea59719926ef2a1118c4d7f67cb2a1397eed006c712425c9fc0e9df165826b1abbd5ac4133d8f4c09a88a372925bcf658dc1a50cd97faed4400836944ea6a69a3da2229627ce2537f73c515669af90933d0ae085c81789aebafa98190f51f89475dc5244c4f13fd62c9014688de54a619f8945891cb19283ea7718b074865f9d61afdd0e83349dcd53ae139cf164fe82abfc958b7c2289698bbd375e26086b183c8795c644864168a892b2b04797db4b2737c546170d4ebbfc59a13d863751c1b5d083ce3f23812a5ea78dba5d779902853a27c0b01554e2a70f65c05a797a5118827137a0d8f5865e673814bdc1f9fdf7029804b08822b96950eeab302f262ced81a521ea11e34e4460ec2113b84ed4912886e52f0de40c1795baf5039927198104fbe979fcfbc644861418f344bda5e7cd880d1195f452e8c5d41974df28e1300047b44dc774ad3a4e4655b67fcd99eba7f10b32821f58973011cd5b811d197194594810b145f9ac75c1db783f4298469af350b449cb37f55ee3922acc91757189e899711e014bc1431a32df2df4085beacc4f6c97936536d507bd10d4fa96520573c2b1523ad4bf862558b51d240a7c72ddccb84e0a1f68d4d49afc42a527300e8f28baef27d84b1691026994ddf26a4d0598f30114ac09747f431f7b1f0f440bb1dfe99d1affa14af9b7038ad5f06bb7f9ae014b662548475471239ff9429bc7f436fcf78f827c09a9fdae17113077ab6a7fe3e8eb972fc963ccfc128aa0a1747a28555aee1e7c762bd9772f278b2b5b2a39121ab1980d99792f842b4b78b5268f42046500a4351e3a0b4f70e964b93d04474dd482ce9338c429e322bba1b239d611d0752175549d8bd8b6c2f20654b25933de4d92dbea4cca3ba0dc5a2da8144108334ae5cbcd915b9788e672a670d9ef81e8b2604f35a6bab47de31b2df41e1aadefd3ced1cbe0a441c5eac6c6aaf91f6b3a26acbe264812f0265e30c0eabf53df13fda71f3a3f0c3a99cc150a2f0fac1ee02d3634b8f7d48c3a43b37a7ccf6f98251c2d39a8cbdd2fbbd27aa0651245efdf4fb6bb59529ebae23e4a7915ecb9f746b13fa0cbf10ec6d99cc2832f8fb9c9d962232ef3047c9aca5d5958419578de80c8c7d617a61be02a575d2409ddd00bc750c71f8cb5416bb1acdf9cc2240ad85cb0024c53dbdf209e84a34e4e05bbe675fc7efa5f6ede544697baaefa4c4ad45131408725299b4529e4bae2afd14748ab53a101d2a70cce69fceeebcde2f3c11c72bfbaf1955d642dd40324c184be4ef965a0e7e63793d067cbdb8d51e6279db9e2af7a9116834dc14356990ab9c4508cd7157f9d7e20737425569cb407079e16991a6cba401863eefb4a74ff30e56e861484ad0698bec74d80dea14f503d0fa57cc44fe44bec01c13ef200ac22f3a908494d39fb67eea5723975514b77cd92b8522696245ec43db502b813f0700d68d91473972ee506718d8dbee8365ecc22e0d5675e8cd2e30f2f2cdc028e869c3f361a92b90787548b5c0c24af686e7eafa87750217738d308673965b1220bd6692aae297a4445feaaddd8c4d7674e09cc25d39c61aef48f732df087afaef46653c5208108e9eb9dbd6e6a06e5824abe01cb4101905715866b7bd872e74a82f3a0f74d0af0f1d36bc013a213b3d57ca39b19c66a89009d794369f0c1285d95878e7d5addea9296ecd5ba67d34c899c27e955f71c2e3c1a120aa9b85a8f7fded0ff38362dc469c15a12d6af500b315283c1599f04f46995f9c8dd9dea0d38d3af7d8cca76c4ef372eee45c345564aed5a022d4311c6412d56f07eded6ae7cbb6bebfc19719accd966b78541091288a9eb75aa1da6d24dd684cc3b205abeb6afbe47d4f7c1d5e416fdc1d701ecff80bc983e248ecdc9a619bba872aa38fbd10506236208fc1d97d6f893aa35ecdc3ace6a7a2f446b3e530a15b12c97cc7e3d824e0ae1fe9157b295b80baca040c5baabdec23b80ace00007d59c46bb95050099746087411b091e5163c3324606de3f4bb2d09cdd0d2a0177ed38f5d6f33382e6258e87e9852429d4fd3bf63cbb726a5a7dc3cff8903a3ec1593d9e805a6551f3d5ff4c8c0fe72574a9938d3a434da1668db796e4451abcc121dc367503d60e9bbcce9dd1f56050ce91ce5745ca50b8f0de640f4fed2095dc2891d19edc9a5b1cf572300470e951fa5dad8a95db89941184f22941d3403a54fca0e15ea69eff488aab51a5f3fb061a6775c54908327b43ad4ed9fa79f7d245f435bcf486cfb6a61a7c52ce55fc1089c5918c2b7f2877eaf8667291fb965fdb30467df9af98a05b1ea3000002a504c1c363a0e44c496fb1bf9a3f9dd2971ae959dc0221ba997fd0bb7e5dc48b8790d6f5ca5a49c2600062d654cdf6782f357fc056917b5f5fb35783b80a131d13158596cab72846156cb6a39721727297be089b035d16803940a486790b22999651c4f8e36d498ec4ca9088626301c7fafb713c17b6d5c3b969ba6bf5949a6fdd8aa590481eb04939366e2abda63c954238f97dbfc642c101c72013d9defbbcc5233e951efea2447dc5c74644a9255592451f5472bea64aa237284828d0443b1a6689c39e4297a6f16f886c1110ba38bebb5b95f5277b514dd6427e848c4aac4fc83d7522110327b7b2ad61120261b54532ea5722ff7222a90ad7cd87824def8b83e7bc8d8473691d14bec3bb07a175f715acb04a30ffd254424b99a2975bd785ac7f14fbcaafcf19c02c9b578891c84e1d2bbc90ab3c2ef83e32163dbeb9699062f64a944e83a40f15f4cac219dfedbac20e7f2ae69ca62518e2b925cf9403560f45e18806d0537101f0ebb4c8f94d86b174c2c9a1688cffc8c03d182237652ad9f16f89fb81db4c8848cb94d3521017b26929fe417b5f8117ca3b8607042bf8905f8c737f2370070ebba74cb2e1f4d324aff84680b1ece4097ecce643fa541be6225c87c91e5c84fafbb2212e9d17010e10c31358211085ff7c054115fb5b3b27810ced969f1a9d8d377f5f5ded229188734d9352d57a25ca665a56d2dd0b9a924a5ef1490ae1ee4fbe2e6e12ac1d2a48fbb649ea1a15cf38170254a4986a4cb694138bef127d94103baba6b76b1f334eb3158cc562fe8ba5cfa29120994912a3412408cf85fa0ef263b69195c9a47c61e2a2c777b9e7965a8ac8c07bb1f680448e133c85d5eee04d39201507525d0220dad0727a35c75f2ae4c5279e26c4bf8a2187c90951c8bce25fb60371fb196f1d301dd1e3877cc8aa747654e904687a26369213df36e50a3d0a7a0366cc48fe21b6a99480f0cca48faefb6a9cb019f0364c401444b49ef58b219e9d4a9930ff63a71d1c2ae29d95ad8513021eb3bd90770dc1ae0d6fdc02594b8bce3f029beeadafb34054abc2f0ac4b4df03080e88d5643271b4e867869e84fc61a34296e679f2097cd8c5ca1220ed6ebef323d4a3e68d50626c4920fce50937619111670634c9b113ec9733ee41333a1f548aed6bb07e5f95310b67fcf3ea8a5fa4abead711bcf22933585ab3c40732ef3e9ded71b35a179f0ce77a863a6c2e7dce696dcbe3940c03b8b9af20b5686511ee58b1eb3dced54a94e7b6863dc617e90b6aecf053a533151222cf148ecc166fb1cb36a8b06fa9c25be463d09ea24ced1bf8ab7ca1e29746a5429e34837fe5d34e2fe21fc3c50efc755cf292eee95ea50f91930dca0efcf45fb02be4cba121b2e0afe576adae6b70c2ae856906d919a80d9f50f0fd1d2f5849aaa72769b31982efd30a47bd9d9b08d5b5a7a0da2030110e6692d5e1993c7e9915fa1c1f85f2b235fabbb8ead023f80f9faf1f18513a9511dfc9db095eb8861b7d00586b6ce5873fa51e1c8ba0002fb1f9360979fe52794997b5a811d6821385b90831ed0950c97f24668f4f531a0b498ed1a817bab49733b11b1bfc30833135ce22029780dde4967db15577c0924a36eb46753822855126d12f13d032be68b77124266821d56a7749cee74ba10850c4137f27ad83ce7950e19a11305a854c030cbf8aa2857aeecb1ce1d23a9d50ab09df79ad84156621efa70fc90fd25ea44d16874826ee9876f43c2947d6324c47b00f53","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
