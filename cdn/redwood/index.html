<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72dcd9de47ad304e2922322dd34f9b6a183228b57540cee46c461f8942e14a94cc8fbfadd0e27e5a1cdc805a63280f7c0f90e454e8a0d5fc5a4b4d24f01d0673ddc9cdd5b3863975f13e6a81bba65f70ab4335517cdf8935be4e22d8ba6d9ddf3732195d36b2a82cd2662aa19f70e5cb61974cdf58e2af322f90eef4ad5559d6c280c5e29439e4135f019b695bbb0b9e938533fbba1066d7dfbd7cc140447a60c8ec5259bd3968e37746a16558f204e1dc774ad15fa626a7f3b6c56cd6c744a9fd09c1ab419d99801b3bcdc2a95cc3d311bdade8befab3de5ec456d6a7c8359c0855c44affb4c5659fb5a72a591c66734bbbf08d6417f0e10ba673526ddfd7c391faebb401527763b1811327286daf73be68514461c0c3cf1dfef26960877dcce9ad1612f2f72daa05e3410f13abbcd6000d2ae78a8887c67a09b7883b6418285204547753e85adb2bd6678bfb89c458f566b61cb085501082a9196d6d1f58693b82cdb272263ab5ff9a801ac0f8d6ea8b1b637e820e5af7b93acc8971449bbe300b7dcfdbb6de5a798d88e94df3a6d9bfc6b26bb0c878f348a2a3170d25ae55bdce96771c1371a133fe6b308ea924987e70512a7624a8f5346e2558436b230680c38cf79ce44411e2d4c729833bd96c9e1c62728c104ac1271e24ab98e034b2a25d6245f04cf5e567021df7d5f7150f15db9c3c11aae3b840ea56bdb62b32a8850b73a3c9f94fc16699c820a931ff3f6c58cd649f82a5021e6d7d58d642713a2cc24f33cb466ee962b8bd5fbf23554e01bbb4930febd632a731c41952efd4c5704527ad3188c0e67e84b679396f8c806e12005cbc143174a6202bb380fd384973929cd69a47eeecaff8296431766cb24717ec5cd93fe4b543e27623fd2b46002567a7c189289c314e7bfaae572c66a75e626ef9635b8d990f2620d07429f38ef14ed136d0ca5874a4c5ec4437cf247e2598d6baf0b4c596f803a8994502efc66ae16d6701ec0f8517eab12f7258444aedc7ca2e1e5b9e19fb294eac71a3dc1881308e4b9445bcbc474d3d2f8575731d7850f6acfc2a9111b2bc95aa09176a410ba6e713634cab29d18be0ba74bc8d19971da78567f53548d2c31a7798a596a7cd39e48b1af479ca3c05fce6c6a4682ad67a001fb258c4cbcfc575ee5e218bebc76c5f42944de8b2fecca8ea9fbc9c52b6111bbd899beb8334a9c704b6d949ecb10e1d2ca591b75c1c5afe954f5c2204c826c34aadd8a74eaf51920a30cded9ca145538e811bfbf80df9c176dde77345b8a90acc269dbfc50aa536a268b21976d023ae6804ff272ec8b8b58f8222981200667ecb36ba4a8bcaa546565f9e07b234c1fa786915e051b1a007b6946cb2686087a0050d3023c31f5f1129d06b28e739c0452d965b77e6aa09f98c715d0868571e77863e4e9440ae550b8f849e7473a5047feb7f18d4382095a5aaefa8a491c07e1f6bd4b128b9b67898e321000661012b59172650c2036aea5a6950fe084f0c850a8078594c662b98613699e8932ec51c211eac19341e3322899c243d32ce635f5b9a51f76603ac5336006a3690c4792dd8fc7d5d8ffc9343f3b27de5e93ccbfdf4f381fbcba9bb5eb38888eb4ffe6a7c5dc17ecdd25d7e548272656e73285c86fd3ae0a6988775033eaaee2c598b88bcc7c1f28fbefd83b28ea3ac1f2779e6649d680e75b2bcd14c49b7e0f86fbbc0ef3b22b4136b3dc57cc9c6bcb2030ea18024203bef3ba7fa185a13c92fa4ccc3ec883ae19606174186f3213f1a183f11ed358067afcdb0a6b9d21f2f9fba59625cffdb945b8735a09d10434f5896d46416719327e1995a3d147e07f5591b47ad89b3768809495ae567696e467d26b41c750567b113fd6fe7f5617dd8cf09d9c7c205147b4da569088ea5b362ccc0743a778627735d5b97176cc65ed3fba8642dfe46bfe6db78f6a1c7514b9ffd7d021bb92719e59f128634ba27bac64c0c58fdf20794725c0b437a9fa2fc652ee2d5a0bfc746a04697ac4ad276d1ee977bb629e818bc6faa9cbf408ba421955c9e19351a0818bb445d813ab33edfd106515af9c74697a6294d5ad23c5b29bbce96d16b98a16c0e74074bb76c673d9030e0324eff675afd25e89ef2cf4808cbedf5f4f8a9b34ecf3862361fab573e170130ddde500d085889d683aec149d4abfa8dd9708a022f52f9200796aba027628d40047b3b9964466609aa124781f4f0c3b81ad91ad2632bc4b52864f47f45b4a72e5fefa927407b5412c0896df5e7d1525544e08b1310a6012c55fe12d3aae939ca259b75bb527b4bfb26238a2d8d3757625c57512654aa1003cc3fe4cd7dd9ad38945d317c739aa8fd7e563ce4571fd71dec523af9656bab33a223ef03dcadb02389583360ab4ab6299aef988a8d1fc0c70f7c8dd55195c65e094886d809859e18949ac8e560415eb859a66eadb07f87c504cf10c6892b7d30044ef313c8813bff879bb87df7caa094d6dccec79c55f42e459cf9ed3d9b3ba964a200bf2ec010dfb2a9fcc8b09d89b693d5fa7619f79afc8224aa313f41e6310534978551f9cf2bcad831752fa6ed1764d051bec87f887f83d26ab42286fff229256ae12b9907fad0cbbf66b3916e188044a5e28e4774b3aba91dd18ddef7e4f156632bb499268596f9537812345fa115f0dcf55c1ebf41704ab6c22e45f9b6ed83f231ee82d9385759ca60a23fc074e1d10f24e96da2b9c1c12d64b04154b4a9629e700911f97b9ba6cfc0810bb8fd89d18cf68dd34dfea756463dc6bfb9fb4d50d6635687697492384e136531efc746c7a64bbe3650d9f8038f58909d3f341312680854b6c42906563b97a91082fa30aa4e570818f640493e23093863daf2aa4ea6f7b54964bbe87eb8318baec2423788776110aef4cbe6b00c2ca502ecb02e8d296251d7931c4c0b44b0429ea6ebcd12ee7e959bdcc10ac6857e70a703764629aa4329240c8bf26a1bd88557e28150c6d38716d4745fcdf17e99912d9f54bde03169e788707bf184d72c92de3eef33e818ccdb51c4bf1ece8fec93f985b1404ce86046097c23b5d6a096b458f256e852f6bc5eb65505f3eed22efa450a11500065a24804a58eef966108522057c513a94ddc68e0fc2618e739178bf7f615c9df7576473e8da14c0a4c080b1a121af0c3f73bb8b3f774584e53a2b8e1e1d141bbec39b577963ebbd387c63243a24eaeca79e47edd913ca196667be0889d3c5c5b305530ab21069675cf7d4124a46f8a9a373a1562dd6728ce091367abfa84ff04ff802b6ad3d5a3fc4569fbd1b8e09c4378128cfc1f142740e40456888a2af1469874f036988661d0024d5aca691bc110241708ab17b9d2f4e94c1f0ddf02d56feca479edfb52fecc3ec238b93868acac2452e0cde2a5a812293481e712056d8e3fdbb21f2c9b663ee6056aa75010d5db69ae477b8581fe77a576cb72557b7c658064be9187ab63186d34ec21fb3466ebbd45d793f45f1e3b160d883621c6866185d5037512605f15bc81729786b93c9f2f3d7e08b446c047b0951c776ab5261d14cc027946dff4bc7fdad56d6917698a1fc014037771f0e39e12d5d14d4be69bd8b3869fd33c6edfabe76254581f7a97836f49d424de73e58d442bbebb917659e3f9c562e3cadcc247b0e9cb9110f692c6b36858f1d35929f13315cfdfae6fa4ed9a14bcf95f023a295db2d82b4bc4ca301c9b001e3bf83070bc58d4d129ecd985cdb9c6d6b1585969a38c089da81d1bfc9e52e2e54790d4a6a1a0dc3a99dde94252835374c291489f4f85cb33f592a20a64f4230fed0da058f46549cadd2baba9fc373a56811eadd97b3a07f172d2a68db0e0bc4de4b55e433d56adb8a404a1219a2eab42eea52fe544063d3d0a2108b66548dea2847ca7555b29548121efecb6cead37d4b46d9e9c28355c61cc61536122d43b9c6bed160764d71bc0fe1dfbb70f736dee0cecaf7696ca67d0c8080c9034e4703518338a38c9eb3652e6589b24a07bebb5ddc178c7d1355316c87f3ec09d8cfe7f4d62057360b8cadb99fbf4facb43f9ad842dcaa929e432e73187bba0b539dcec645b1af7e2462a447f4e552af52a497560e757c3e984a16af4992f3c579171fed1a499fd4acdf6907276ba5b2f9a70ebdd6bfcfa2e65db040fb73fdac07bc92a6e14e03f73a584219214186f19d4154848c1c9af33bac2cebf37b3358070dbd6fc888fb942cb872da8a86ed9d755cd2bfb7a2582a3d44758f662747ced9898d194c5ad0c0cda58c2d1bcc01b9e8d15409255fd158feed21697f3035b4b93702a383badf15ff65dbcd3492cf27f867171242ad87e774ba1f8134ecdc9816389f6b7681df318932d239e87d277f9cea6ab2dc973fd8ee4d61a1bde2fe58d8d9ff48fd93afa17e861dbce3380cb3e137f510f48c95c3ddc1824fc8a02acd61e7aa48b45849d6c9252aa4bba2f644fdcd7bf1e0afad8660c5776027132b3d2e1862c2a81d990898788fcce67af14da28bec945d50a70c629dc05df9643f837a40c72f9a0525a43cc83835f21bcb781d74f78674ba049325db0c510ece605fd8ded6d6c22e3438326368079afbc7741b38c146997b6431095d791344b64472f58d0066a5c5b4c3d38c86fb17c8255f1e8287db5383146e813f814ad45f73c44a0e2e311e473b0ae9d711a6a5c7820b9f787ce1f3ca707309c37e4de186fb592535084f33447bc5f335a0a9ec4aa479208cf7bbe7c5cb6d13783a5852c2b6974eb0da469c02311d3dda89b330363425d43f7cc2556ec562d7d35e66e4eac03aec29a8abbc4fb2da5ef2ab752dbd111d8dae2151c3befbf48949cdc5ab7df8abe1e383cfb885f8c2f5bda19c15259ca2fdc3a1fafbd09b9b2420cf61f6c2ac996efc348900fbf06713624e59ee56f8b6db1fad72d437804a3c9079e987481625b35a3595999d648ec9b2e1bd0ce50a9eb6fe260b0ac3708599c23266ede8e3dfc5dfa9fb9aaf2b491054ea889757d70b85604345acc6408b3c9c3aeb42bc165aa67efe447740023de1699458abc3190e59e2bea2566ce5d578586864c77ddc9215af247b2a89967586f442cebe3c583fb573a0a1e9fe18f51d714f803d10eda6a9099b404fe00456a801aeba420275deba25532ffb28c00981df9c9f3bd5960db607d2fdd07c8d5c52e363c628f1a8756c9faadfd6366486100fd9f043f70fe2681aa0884eaed161e571e7966dc83feef1a95c26e813b6c32a32f63ab12ba9b0d7ea2987b68421aa6c0fac9e477ff2063c0abcd2e67e66559e6f41fb8acf9a709ce53ed903ca3a7f5010f0c5301f9f7f6f73fa21e22818e3934fe0026492bd3f789658d2d6bb811669d6484da4553e5431d650b50eb32574e5c6c97f34fe864f8fd96fccba61e7133c949c46cb490dccb0b4166bbb25d1595058d460442797a65f725168e62e96f4659fc473d68d3025c35f04643996db38baddd1978f16200c313273351bbc9df1732d580ee4751cade1490120a85044798c39de18da269388d940f008c9d6128706194cd3c56db8fb6cd042c6523cf1b601ed59c4fe76485cb806c6ffc823009ff9577256068a3e05ea72b966076713a43e7490d1d6fe2367c425a760f1cb072c8dbe81fddcf6e3645bc49f3ba2a772321ee54d4e00c3438951e5bc2debd25ea8844f18b9b0d00d176e85f17a049ebffdb7bd1790d4f3e9cf455857402d5af78b901ff91ced06540b1f1476401063d8fe1d4e1d9b4e1cad906aa5b72d43b1d5115fc4b298c7549a9e6d7e6cc8cb122e8dd0f7311f26f86ea38e947eda3d477674c2faab66e6959a4804bada4b8553743e958652d97483b60ba18e5032101eb0aad02c18d7ea93fc64f726f1ac3ded0d6eaac97426796c146833afb21703c5c7b96cb5d56b382369147eef5a2c1e44020106106b264e5cd66fffbff4579f3bbd1029616d155265c3e50970a6fcec6177b1812d1c3b16e410d244d96441e39a00f2003cd435fd97362669866212bc482d36daa7a19f921691c2effcb5707f4324452f49bf41e973f79cc6027d85e59a2c5304b16c69d79b15ef601a8b305d557320a0eb987a87d6773ed4bbd572798d8c753bdbcabad7ad29f15a2df91773bd95d6b203a95fff8a95d6a57cfb5d8ccabb43d0d819695974a2ae8b274fcb05e421f60f8e87d4be73b528a2209b3bdcb527789fabf0e7f3443b6e2ac7a42dc806664d24bd0a2b6daffb943d198a9940ac42e39477a83e8dd18f0c957ce90a85c988ccaf1c1303ce3b36fd672b9916d5d315e1db33f81c69f05ae1580f827c54393d46773f94df9fe7af25276f7c321727633d6cdc08d159dc92e090b0474992387572ebb11514458926ebb4e0c1d235d78ab001de8c0f89bcad8896b51e39fb60e83f9568523c116a294190233df9703f3c03828f5b921a38132ec421f4c085a3cb6b5ffdf98e82b8df06bc135e99582af8dac78caa75875806d1a3673c4251f07dcbb5df170f8d3ce97728fcbb12de015116c5159b26305c08a871b9a009b6838b057b7dc269622b7b0b203e99ab23f489120ba71f8c1fd8d4fee7ca8b905b008f4bab3eea3c017f738691581a7837501e5d5c3c5f9c9fcf328310b633ec3042abb261746aef313e04bfd6edb459b09078f4f67ac5992230d197b03d6c3f822feb66c0c2f5a91a5990eaf22a2c10ef83e2c5b7864ec3797c30567a8032fb686b87738d4dc171a03a5520005ea1e1bf2bd35008d06e8984724df7546b6cf8ea823b5d5f39b9108729f25fffd765db81c78691ad0bf9029579bf53507ace1038a3eeaba9825d0647f8e98fb19f8c9a52e5e41635c77f7956c2def1940bb587834baf4397fb15826a2e4d89ac9759ab2a7b93c571e4cea74e22ff7355918d180c4e7d1dcb5b1f51902f28306e80e0a6531085393932aa1a46fc96bd89f94994fabfa0e541cb9a54f2e0f9dda4ffb33e8be9b9e1f55ca453f595b6425e5510d660399f609fe8e4f959ce04ef1af7acdcbb0fadbb39299f25b7705dfc8cb119ca1ddb2e99373859ca3134d573b6004c853e49aa95f84c5fdf242b334dd1815b20f3cf57d2200fb96160b515a25e2face716be19bd0894c96093daff7c47a2caced51a8e3f0409c1b4ebf76e7392314ac9194ffb9f558a43753a52d89afa3c042ef3a854c4cb7424c7f56a17133155adc2920fc4ddb9acdbc49df7af7cf76ccb7513568a0b77dee93bf5799dad7b73425fad33fc4e7b8c967b674fabd1a02f2e9dcb98603c2ccf6a9392814db50dc9ff53e3851eeee1fa3adace169b646fc3f19e8cdd3b4fbe02770c5ea70427c9fd4b2ad8189e1a38d33b049cb7e0131521cf44871b4d90965cd7513dcce16563249e111fe45d23d7df4e03313cdceb96cac8710b3f7ad75bec9ba74bb24efb4d5ea876f727d22cdfd85ee97f8cd471758f85f518cf68111574fa076e3ba704a72715b1b63ab0986bb3defb485e4459439b89bfab56bd89f6b18ac3249c0e798731f4e8cae61ab407de721e03101e4fedbf1bfb1b13af0d9d750f088101f21817fc70922cde93b054f77c62e80d2e937c6bf1d6e4c2f05c6cec30b81b2c48dcdd82843f276974cea25a34bd9066359228750ea4402f5bbf1b33750a68ca3be2dea2c55f7873e0eeb618578ce6cb1d3a6a79fd60a16fddffdb2264a4f3bddd8b65e159cb8d46e7ee83c3212dc61edd0d02095a001f67285986827244c75b8383826eab52a5bba9288d73ec08a6fe74226b9efd0812fba4d87fc046c92d235c35757423f8039eb7760bf0a63059a4615168a5d60b9c0de2e8450380d237ab605247a9a7e8d01c5cb55e3feb339aff3855b9c9969bdad9ba202e105ad173722b14ef815b649df99efc50532b14cbe995364a33eb29945903dac15762703e3d45617a0366c529689fbfaae0385353b8739402d75479b89a8dde665a95ce6986e8c12e67f6bf562be57e416c05fca240bc8090be53ff6b72c9b73f545e0bddee0bbc3479d5ac57735978a9a485a0ca71ff974862640a90b1e9146ea6082d649bf3d1984f379ebddce22910c7061441130093c8b6b5acb27eef2539edb5b57f651245f2ef658c2bd410a59d2d8448a0963a83873b9919e070068d59dcadaf715f07985981e76dc46024604a430eb3f1bff364df1a8cebacc75a8c46a5e1423d134a38560156e1af62423049be08bc959ae909ed3d408e01aaee6824a0f27144af5773dc6ed9a4e9284a00eccc655dab3e649d5e6346073aa78249dfe7ce8917cc27126686a8b3919ab18b9af97184d27da0db076af52a7f581651af172b1bb72b551045c64fb523dd856b7174149dfcc195223fcbb9b5cf8dc5e468a7817f5de59e537d46d2cd259cd8008962364c34595d985b8ce65148892bd91763a505c86cdd518e2e52fbec541d948f399b9de417a7680bc31a15d0f0dcddefd72348adbfb006da3537e270958c87c43c8e956c72297ff61d07eb6f4258682600a325371793cd15cc0ddbd8e7e861a6ec4414d688b9c4293de4ee0966df66c80b789c8cbb1d05d8e45eaec2a35330ce8b89b052378132a06a2b4e0a0e5e7e0c55c3e34cd56e611896d11db1d0c8b893d88377ffb027a94b3eb2cdef7c6cbce8a4e450920fb2f63ff25286ff26bd23f8a047bd98f10c2cd308360ab19843b233811e9eeae8c939dd46ea21dba21d5e1f543f29704a330be5db290dcad7d128a786530b0ff2a1e1d1543c6a7c35c6f0485e46114d6a9f1fdda74f238bfc8cda238a491d9291a7646dbfb0a2cc690472695d28ef9f87aa63799f41a5b5c9abf447b50e401875c115485a52de211a2393cd3b8b03e8a1835a258ae9ec7ffb8d65e734f9230a851895cedf826e025e76cdedb5e05aa6f0a4b4735c58fb77f062c0a1b185621bcb33768119b51686911b6a8055dcf668573de6cd387617e2a50493b0922027fb932c2b0add1f039dec94b505be14aaf6d54d596b56754337d057ed0f62bfc136672a2ce13e3b1ac3d2991033b3145feba65083fdf8f34aeac31a102d1a96777b3c398e048b733f06854e912870e276a0cc0cb6709c3a43f118ce555e45c9752b89f0e65ce297cd439fbe02c1669d4d8ae28e66451954007334f151dea001c1568c1cbd9e81c8d065d194f291f918c2daa11d6cbf53340d199ecb6a8940509a4cd1063504d524dfbb2f2dc1ece831728e6335078110c73dfaf5f04a2e604c7a9946ce17180fbd16ae324be5dea61ddb99040ddf7512e716b6141f0f58c1f2cf4c855ffefb39c2834e45c5cac30d8362c8c65bb8300f5089cf0ede4e174ac15984896f730842fa4d89e44d874af38ad66eb8eec78dea4aa1a0df06aae0a7b18352464a37a474b23addaa14f9967fd7c7b50b545378fb5e8086a59add07899db051e36a25f9078752b0ae540083c586e9c93fc783bfa74ff56e6745efdff88c1412f8e2d63513fec70a2b1a2b2df9ff47e71a9f84cd433eda73d5118bfc1519e61f5a3c31d8041c44ed46819d7fa3838d265469a9250fcf3b3667369955d96767f785d9e6de5b12a784badc444aa77d2140f4f84406e44f21cf8a96beae37d988aba9c09589960da65796ab610b19a6bb486e761162bcb53cd0304c87a986c2b4d5cf4e77fdc7d58c14527e444de716d5ec246b503ed5ec4d64f2528f7cd8adce3e0bf0ea9299b3ac275ec3cb3d8cde5fc7688cc36df62e0e90bced82e774ede2aa305c742ad41a802c12dd1d072b7eae2f71290c20919d24a548295bb057c97786123cee9a0886d1062ebaffdd6f498a6618220787e5e8a9771fe0d83567047f7970f570349cc31a7199b2b85a0a999813d55eae616ad51936c6304989f52f31bcdc6e031fb166bfe4a636b85c8b5b996e2e2695fdac43ba1295eaeda06ec8a1a4cb866a9cd7fe145860991bf40e264d7597ba465831ae7b150bfb60a0f5bb32884454337d2985f313f5e3c6f2fce46456657945c2b7e6c1a13cb19c7789af496fcb4636f33d0a1668ba5b4ece7be627dd84341e07c1d203c27d7f2db9e26ce6258ecbb136627b9b5d6bedc3ff86df59aaa5be034aac75cfa8262c76ef2b2f71d3173a92586239bad990f53c1d19cf9a29bf73760e98340c36d45eefaa4ea4dcf4c8c915f3e26c7d14bb0f760488019935cd1bf171c80ba0067438962282e10797536d0f4efecfee904590d52b0ff11e8790b4aedb2164880c66e213480a47afdbeb3b4ea45acde209fa2af8c0676696409090522c865048e8be97590b7a757384e16a2c3036124ece62c6167b23e895aa9b5ad1516679b322306a89a6bfc409ff1e07cdfef154f25487a40eef82e3f40e99fe5451353439ae74f4a905d60ebe7a2f49730632bf0319ca14af60c902742ccc5d3233b9d917a227a6597d8e21ed66e3a2e4d0100753d4846732bb87491a2260a12356b628478f7eb5f9c880f2b40df26a7e5bcc6fa5659502c735a01c50dd5246cf491eca93ecd7f72c2e6cb6260b3b4d4c6c1ad8eb0d89495fde00b90b739557bcc75f0ae681943aa6e4f8bc31cdb47a66a6adb5142bd826fc948d485dc0ec503331df24243f729c451e420765473f8a4a8099e1012492ba3ad85a961801916adca3d31b30a5e4fe51e288c6adf48e4767c88856f87fe0e3ff21e51166d1d9b49f4c90e22c147c1eec997617dadbfebc6efa9b85327ad867e32cf181da36c6af5bb2d20685234241191ae26ee8e68273ec9169bb9db29d9839f9f1117edfe7ead7dc926c54e98fdef2a6bf3602ea67900b2d6055341c4abb59204754bab50eb67019621c52b435170d7892ceb9cbf37956496518c03e3a43dc5ae1ea3dff56fd591d2fc4b60fef3c24563ab79fae5cc70fee54a500e25bcdae6f28d7af64bcf49ec0d84a97b16f9d79230fddd34c88abf73e2a19580813b415a21ae5a2597263083ba84f9728c9609beb4986dc2edc26e6ceb6d3e1392a37bbc7977926d01cd93e85f160b0d30ca893d708d62796dfee46540f13b0811dac018510b6d354f19cf5db8d2925f9b13fd580a0312522673dbe614562f0744bcafa99854ddbd28b9caa112f241eba1fe569536eedd0c2941afc5f9a01f5ae11d24bb9a766a68b682ab20e5cf3e2fbead1921c4f9a8165d2cdcd713209d798ecbddafe5d3bbbbf41522b77c0e6b177448ff2194c5ee5723ded92668af18e289695eb15b4706fa3c9ff697f1a261539d9dda35aa0edc07242f2890cddeada6cd5fad63d6154f27297be466ac46091f3a2b1759d6a8b7d7ae68ee5a41cac2123e009af20c86fac14ff784086210f9e22271d2c10395d60d2187e467d65dae23b2212a44767a6f5c4baedc4b4c1b0904b648081ffc88183dd5e4a17c555178d148995e18a5dc2024dae69628f41f28bf7db81b09f6bb990ee4961f56379eaaea30d45ae920ce52c21735092c47fa2b1dc2601ef350c5a5b53dc0d714bf25722b842b329373e58d3aeeacb26c53bdb188345cd44bbc1dab9b781c0ba2120bad101af22e6dc27c5420de9eba8c205246bd2099304828ebe356d31e2e7aadd803e3f8dae30117c46666981ec0a1373fbebe264f23c2bcabd4dcdec8c27cfcc9c0543c34c126ad3e7c761ca7af57586270686fc9876f7ae083c05e8a7767e2c538d122043b2f998b624c1dae4d0b79b95072691c7eda1d0bbdfa65ede89356e36a10e61767c04e3e90d04c5ab9f6ae51ca535e388715f3fb489102e2df148fd9839ba0800193a5f981bf7ab04693d63d7ec068e4715a55608a17cc7c040328757868580a09f9dc37ab037f960e61b6ccc02578afd947805bd100b1398cef30a14888f57602de7b222856dd5298193d0ba05d30c044c0a67fabf11a33708e9f7687d4fe7e41dc6f50dbbbbd0229d3f9f7f87a26ec8c4cb9776c04e99fb26882aba5a8e3d45dd6afd3b010d28d232ff954347f702418d690abf39bc862e3e1cd0bacf4ec2f0a0956bff5e948eeebe493725fd9f18f23c854118b0474238233ff8520f77eef22e89ee77b90374113212e5b38a29cfbfa352bcad92b2c58c595087d8229fcd8cd0de5339cf231a1bad349abf79787291c8b4a77d93627ee5185a579e390ba24fde7f29d54c817ea3c0560862322461dd4e96a3b66586ba3973e5fe13f7a9e685dd871223be6b30564f61030753a548927dd7cdae39eedc2cb64b15f17f260891cafe51d85f1f80c4294b5e4993827d31bd5fd2e2b3938c6580785a70e38a98b5d3b0f7c2ba03a665bc6897400abb10954a072f26700ec1ca3fd265999e7b7478aabf9cc7eb6efb62ac2edfc0ae010067e4a44e4ec25aa1326a299dae5dda7c9a0e6671d12fa9806fd12ee47c68bedae378436fd5823007590d59a53e3749a3532fd0ed396fa45dd53bb2688df57626b4b14fcb598be7c5077f608ac439f8aaaae5f80f6d0a8bb68614cf657469fe817910d11c03fef42150f6e800f061b0e0165dfb3874c9a6202eeef4154a758977d0952c836dc65404d5193bb4caaf29f6e0c0ead7bc47d34aa9aa4da057b976ed806277cb08e5a7cf348072cf03695bf3dd3420bcec859a0874a794709255f041aad2258e88c1bb3ee6bbe017ed6fc3c3a93b1629408cf72696cf47a577a122f1cc27423083fed34bfbe52841a05d409b56066f79db791b1a5cfbaaa6fe74145abd8c9f3d82a83dc4ea970e89040cc3ac22be0946f91e5bde79f3bb4446fb7acab95e0f8472100297e217f66e4494b598af741257ebd8ad72569ab98f979177db776df241b3f63d8515b2b272098005c2cdf7d2a16f328760030d4ff6f16bb922854e019305ef8bdb4541fcf691e04bcff1ba5fce9e9ec713ff86a13c446d6d75fa97928175f09aef12aefeee685ab04cd8c75b6264ad0f461421db2a6bedea962d2f36b43f2094a76a238073266542cb2b8d8db9498a2889377acbea82a04b2dddaa106742366935823aecdfa4b4a3ef9580376490b1de956405ee1ff75467e5040cb7ace453641f7b32e12d22c82e59c3140c2d2ede113cb3ce3d5e42db8ff00759be98d9361fdb3845bd0b4ca2cfd7d0997023ba7eb29f45ab40808eb051cbb978136c6ada54c5450e323f4f11e99fd4f8a45baeb66aa0846072f1e87491a04cb72b84fdf126bbf9d670e8b6eb386c47917d2a2f94dd8b4de783f9c871d72d581bf90a31e29d535cec2dbca28723b5812c1b25f44ee97ffa1c9f2a27bfaf1994a0097c50243adc9033a6036638eb7808fbc4d732774ef9096b796ca64a7e3596e58258e57bbb5e0b4df57517ee25fc84bdd2428fba0aaf3f442a0ff8c44a8cf610845bfff337146f9b5126590bfbaa807c568d519f52f6ff9f332c91cbcbdd08087c644e10c2f9803a8818520acc2807fbe0a5f9e0254e349846373d988554ef2595833ef27b81dcc5c02b4f435659a2b511035110fa0638a4c59042682a8360c28c29e804a048348a0670594f4afca30535c4d8c5e92b8bce9e83a730eb2a85fceb6b67ac3ee0ae93f0fb68039be8bbedcad1c51abb38e4670416e7c3eaddec5d34530d96e696d8953b6bc59a0a0557852a84a9ef088cb0c479a39d2af0c0fb461eaf8f5aa26d2f5d4d693c589e30b7f4baed03b0c80528b36ff69ee5eeefb22dd21799fd27b3d72d156fa0c4deb944de9d8a09f0bec4d0b3f923ce4000fb7fa41894f0bab3d370ff7e818c94c262f5e468393c97552536c11cac2915ba768c11690ce35fb86a59e6a0093d48254751fff5fd7fe3505bfc4aba212222f432af13d2e557c8ade2b4c6cc49bb4133dd071d3381cab8acb79118f09b41b80795a6404c351f8685bb238662fa0ba62a405225f51d91e9d8cf3f5a64e8d6842ae09976a7228473256d3a949e0cdd3695829a71383e90522c3680d31452076fed07aad5253f0910175ffb56fa0f84e610bfa4b7597785eb155b20f6ab04aa9030c0017d68b521f4ad94eafecfc8146c49303ac8c5d2880e4a26d56ede65ac974a963bb9c0037a09b379a4eb9f2de769efeb9e1331166b627853fd4ab612c196f5971a648708d4defd56bee73decafcae2cf2f204c89cf71ff894982f29526b6ee2dcbdf51881eb218dbb3d21cce6baa8513aa3429b7a88b9c53292ebac4686609ba3190db877ff0867488c2bfc4b8485d0b64435c31894a68467f2cb9191304932769b0611bb5cd5f5d901123eb58f7ebd55b55ece3f85a42b4f6d5b35dc5842cefd7c563a96e9de72afeb66049cf4a52943e9733a552650151db5675a5c7f343482f2542743c70d90a4a80a3ed543be625745d82c74758abb79c2c3e1dca5c69721b8712d965eaa710f85123c2758adf458b5374e3927cbd65c332dd4958b693fcfab643e240b5b4f390483fc4d116fd0224b0cb841347fca85cc1e05e9eaf6f7afa0fec97011642ba75fb8c5155fc687aa76a66e0aa740852dcaed37414818fe5a580c55adb6079c619cef5b9094e3a5ff39f8e51f787af0016614e4ba7432fe6d39c41ddd640a5bffbc37f1e1712da96bb16f52f7b710316747ce1da33066c06a689bdc56cd33f12575e2db8dfa80cc5fadf3f1bf2895b4d3b86f2c2372ce594a0d7010bf56bc27b3b1ebbcfe69fbd2dd0352e258356567365d73ec91c3ddb971931e2ab0c59ade3f5566fb7bb73dffb81c5a99d86eacb4c71758c7325ed2256341361f58b9a3de30e5688dcc2a6e7233b7cd721e2d363fe76be65ba15b23490cdd141fa587b9be69331f74b268c14ac6e64d3fb33dc0b807ecf35745421c87f4993bf7d32c57c00c4b94e91a1a233cedb7214e4b5b42fab751dede05d9983d970a60e4dd09f414299350978ef00cfc3820c89ec3cf17267b7d7ef4553ab2e097013664da2bd7191bd2e6f18ba33c102f5f2effee39dd3d05f0b8e129befab008cdfbb94f4cf51764f9003c6f3fc4f4abf20bc45a2a501a657124fe01a0de4f4677d717742f50869bed00dc427354a2087724bb7a38b955049384e97166053fd24d20b02b59ae021f5a4ff716ab4ff4df5f3240afa461ff8989a0fc97ce5f48a099e293d5e087983a28073724165d2d3f0a7924eb480b51e79a5607e58c48c21e1d90bb913414c0e5043c5232b1b3915b9fffb794db85687160e78ad8a30e9bb230b2d35fd5b6f678d15336d80f77688868e619c9c9d4b4448f7575f85b84ad0417e2584bdfe72716646b5e283e9656eb04cb384a7b211b29bf6e95e56ae02ba23be1e79aa9ba9d1f382582e4272c079117b8d4aa6ac315e573ee9988da6b5d190fa537ba96ab932f70c7486aed42d4ea05dfce3428efcc47e6cb0ce488d5edac25ffdf6d0adc09d21f0a668fb89cc6089ad525265226a001230542acba220828c344f7e78ed5ae8f0a66aa8fb9727085150a30e639ca63574c2feaf31cc6b835c678a65347418747e266eae6dcfd1c7e664da2be2d5bca8a2e2c9a88e5fb167b7b4478a370db4caeee09681ec0f97c0da92a4f7d4b7bb326f43923ed778173473bfb218cec1e4c1c495f891182fc446416c11aef8118ff095b60f0dc46e96fb5bd37b107fe17a9191d026fc76ff2bb84118aa24c6a3846742b9852921efd840a5aff04cf2076fd60caec5a3c9b96d875a284378d0c5232a5fdc15bf242103b833df84ec9224ed2931dda87ac5898dd42f16c3e544269d72f94da63370345d2bba6ffe35b01bfdbc1dae2fd1aab7bce2c72bdcd9cf2b41c9654e8016d916fbed067c5cb94bcfe347e34a0f21d708a8a8eee11df033c04bd757c855e781c751e8595be1515062b5b3d6b6415700d45c26132d70a9fccfa419864965b5e19d5ae37d257cc24b72fd373ca80f3468ab76ef91bf7da8ea09c86fa120e824b4aeda50bb7295679d8387d82428869d282530a72e22d8d59b1ea060efb26c3353405cbaca9287fb8499fd95f2a7a879723ba213c5fd07edc8cb8f91b36d9afa226afba53d3bedefa8bb895d3c0bfa6c9d01997afa64cebed641fd84e6e6fc3900cdf2efe2147ac2c86e19505f8a62d45765d08216b86c938e70d24391409d7bf31d153638bbcbba1463f21de93dd055456af25d3abd8cea52c2ae1993cef08e3560526e587a5eed80e13395cef693734c0f36ce293b8aa52a80eb2549598dd5523425cad4bd9ef7876f73167343271522d2ed6884cdca00fbc53e971646b6559d69a1e249b67f40e5c22264c768f724968c289099ce67b1e40391dc7321adc323d182f81ba67612816ce36c2f10b4e75e2e8defa0b09ab8cc1d7ea435f12b7a4801bdc117b2a2e8b43a141f4e3762237797d1732ba5ab4edeb2ce930c778bfb0c57e8e1d5d3c71bcd98bd5c804a4db4c3bd3a093b0c86c5fcde9593ebd2feee6fbd2fc3bbcb33ef35759325aedf65b5fef44c37f0bb89c03f51665dc1ea42b4ee678d20a8b472b7a70a5960f79a0780a95d6b55689b637c53e48b2ac4418d511b3001696e49566b8ac2126976484165540ce35e7febd48f05b804e0c0b72a693c6e50e618df0b8cdbc30acb415763d652a4f5ba6fe6bd13ee81c6b294d8dddad73c74371552be3293c57d04c020c839cf0a4869bbdeec0b4f86f5826b5d0502e51d578638e93e23b8c920fc74c500da02704edaab2b6d5b22cb8b4cd344507209422ef0e94ee77ad1632bb9e2d372ee0c7f1047aaf205eafe31907a3ce81a428cc640592294b4d019341718e1fa0dbd37def513e21e4d94fe5ba3715557dc755977e3a2bb093f799c6c3c7c9a9eeb172a2d48440eddf7e93389d1d7be8d65e6f00f612679f555acbe8f50e6c9f1c7860e3a487b3c765b3b4f8869bd1c3fc51988925efb91a3d74be770d6bef375b6f96fc737be85187430bcba2e880b07ed1c35702c01fe102efee01d7142f7bac0e719055d6eb17c3f3a3c4af07fdf23855e2022ab88428b2ce9c95395c2aa36406addf055a26efbcf7e28ea6478a85baa25d2b7ca1c155daa966c356f595890e5cc6305b2740ca097814d541eae80e81eae6a42c19efa86362b305cfdd463bb068205eace63fc70068917e933185bf815f854086aa5a272ae50158ec406a416e3679f63af06310a9da0833bbc8654fe278bf5206e0184d48082ade7fc4a0f6ea8246fec889c44cd01e4c0beea51bb62cc02e093fbcd5cccfca6fc4ff56252b7a5de10eac0722a9e8d095e1b11785f510904e11431e1115d3870d35853e832713e7bf92a40b3166a656b8a32367879c15611b8876cdfdb39b03b10f69683e250e42f5bc8b9ec57df13557ad9052f3073f4598c806a8bf16904d7e795063c7da7501ee237a3a5cb8c3af502ace680200e6109e8cce72db1e5544c2f4b3ba35720a05cd85771b398df79517818dd9826593cb81a1bcfaf6fe1dc0c377ec8f8b85144016ab5aebf0c62c4ee231f42215fbc5fb056913bd958905c724d60da4322d8ea4752cc620e8fe9213287aa7fec8c8a6b8288267deed4935d8145993d4a447bd91c5b864d085086c13e631882481c3f51c7e9fcb1e222ab17a8c0f296072f98724bf5fd24d0a91238eb653133be05aa449f19cf15b934aeeebcd41691c63154ea74dd4ed582a75696fe045c002c486fe0652e82d4cacdd911cdab462efcecc66383aafd4cfe8fe0c7235f7493d960c4e3ec4a3b797d985a2f127c36326480fab084637e44bd63ce344c678a779c491ee8e1f920c216155f6eb05ef9ef5f52e1bed2361abe0f5823490d60ba88a13547398fd1211d238d8c99ec7c5d5247a5a2b23b0e9152ef333a55ea085f4199d548b9be75aaa1d19cee087da7ef270612af6eda2b6ae5473f5ce5e020fad67e675a8e52a020edd52ea984f95c05cb7a246d050fb75451317917fe5113c42553edad1426c3e2a0aadd11b791a81aa98f61281e20d7ef4fc2916d5e784f84da046c09247290c146ab6426abd05bdf713c9412fb90dd3e4ff3cd7a28ce9bd14641051142a7aef9511aeac281742d5e1bf5fc4e5fd5c77f4b8837f3bf12e730a2efb8730a96b3a1a1691487f54ee77fb73fe6d271fd2301b7237ee422237546d57a53e9554489cc752c54681a51a5c34c006d238c9c5da764a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
