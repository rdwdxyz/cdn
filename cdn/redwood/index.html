<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8c645072e7cca7502b975ca4ca4346b1367027a10fb7825e31a1427c8d5b932ff4f0c48d0c8bc446bf7154bdfb998e67e86c68d72babece311cb5f38e912be2a9f85927ab6bb86ce6a95fb458d6ae3081ebe67223a080b69a200db2b6b4498b7048ddb0f23352325fdc575f88bb8f9523b1a6f3fa2e336accce6d48fe3ae09ef27a1446b7be5c115108193c77d78909681bc280e91d0218ecddc80a873b0526231210e77f5b3ff5c690fe90d8fb7c80283c742940f85722307e2d4c2c257b00186b0cdd89b7c5eb8dd1a1a6c2eb42b730a7281358f658ad113e5b40486a52b7a7b7368295ce8290835f6905a6aa30328769696a0824d4dc95c2bbde3896b612376b7b997abd73cc940347ed8e29822f09bab90a87ca89a931b7c10c294c7640197497ff221419196db12d3fad21a7b07b378afa2113b4cc0f890c8afeafb4f6d1617650bd15397505fbf8ae3d04d9b06383edd9ac391e3e3e3e9fb5e775c2591313bd20219a0bcbfefccc4633ed642c492eed7f8cb7d807a0569b47c47e301088d44664ccb868810651fb890986bb98892ed5822239a13f4e82d0f83b538b2bab2196d49abab25edaafc93f9dabacc80e11a873b17803c2d1d1eb92d2a4f268eb99092e372bde75f59bc3dba695e67a16cde534a1cff9d6860ebf8660c3f0a5fbf3c11f2fbc6c4fe7a8114f86bcad0c4fd8f215cbe015df6c38595ca7e839e43bbaa5ef2dce866fdbd9662407b77f282867d7539cb32b55f70e97ab576795853ce038ccd2d57c07eef963b0b4446b8a9e11c19245784a59fe2757dcefdd1e26ff935bee2418eb7e63b82be05fea7fd256fac37dbde8c20816ca9163a31dfe883e7f4070a5feba1db111a2cdc88024688e7c48367c59089a069423ad9bd120eb3dc6e41f659fead3fd60a5a269506abf9b986c75a77b5acbc2bca638f7e0bd14e6af32b3e1533a51ee382d05faecce1c6c56ef3a464f7127c12b7a73243a0ecf8984ffec864f42c352787485ad0d64acd4eec4c2d23b2c1136fe0b19406ea70008a230f178bb346a3b09dd78ca49838adfacfe6fce8175e0568b82dece693f84493c594838dc7087f71425bdb00b3fcb02258373576d1e511536bc414eaf3787949312c0273add9e8e8c86849ee107485d793cedeeab2e499f5368ec2c9949501309024e5401d5c0766db249fe72a15f56a890b7ae28ca9762fc29cc39fc80c6436068c5530c00267996b222ef1c90b90f3396d861222a6e9aa9e8225dcf02bd119dd71e084b1b868ea2ba01d4a26a3836b8d676d42f782d7c4ae8eb8115a8d64415b845990d16e6b9e474334f844e75ec7ce3c3b8db6330d632670c31717f59ec7b60eed314e65c682f9d18594a35c5d92dcd291082a4d252b0f6e67797cf4a5c6bc87b421a94522c747600cf8c667a7b3b91711adb25e99b53342f0a3338156744cd9bd48107e421c3fe87c7eb9596040c7e1a4e7abe4862b14a4b6f2909c692f439c2d637c69c40ac23c41cd90394cbf61dc917ca1c4242cef81a9044b4f7e4296299001af9f7ad22214c482124294aed7c4dc00abbf9bce23569b220506fb08325eb24b3dd4ef0fb90ebe1341027dbe43e4b058fc7f04daf2b3b5646129b8eeeff668db3839324f4a0c65813aab23ad9d9b65709d0042bc41894b0a93a43aa00fe14427ab15f6a295146479dd4b1089967f8b0e0c4e848f1670e6868450b7cf6b1614522b405940d018955ea9d10f7885b90d457fa052cb6d5c808bea3e85c195feded5a20f7517c1beb024cbfcae1b8d7244eb0e135be155b6a0f6a20478ac5efb26abcec8de89212f931b619e067a0e914414f0bbbc6bfb9cf6a93a3102fdddef8b02bb086ff70a248d9fef8ef6257924fb2178e5b60a667058055a2d0e56b080756cb2a8bb3acede9894f27cc17f2ecae2c090b503a0f214c7149ccb9a7c4b3d336355ff03148413c8d4dc2e51727c970dff913b8d820c96de9ff5c036712afd1e0817d7e730a83aaefeca9fc55d9488a1e7ae163a45be740c51b271623c70683bea83adc3d11abb6442a47ef76a1844323b7a8f0156f706356552c554350af1ca68defc49e1ae15ecc8b376d3b297b1588ec63ebc1a47b7c7ef0032974f04fecb6074781c4a0eb87b7143b90095756bf20c25abab33ceaa0056b660dd2db1fe55909fc905d524ae2237878c1a27132c72fbe4d563559e26191cce86cc145a08d273851b55dfe2e17502de90adf156932705ca1db4322929ba916de4df840afc1a3bca320adcbf6439452285832d402c80b77f35aea4fa376f8a7d4bdd8c426ad233970e363fb18865af10fa63939a058623313abb8e7e7f9e3e4929c79013f4450fc080ff27175698f26ddbf3b1914b0fcfcd23d669e3ba3fde25b71bdf7742f494bc96391a0baad4b6b1948b23e4997251fb3b09b4f3316d7935549edfe1f4a85c93b0f4572955da738482ae94fae21af802556788683795b02a51616067b72c6e59a42820e90b008649da9dcbdbd6b24c76bb1d9cd7fe0a26e75a60e9265b02338c2d90af8d6fd86e177ce991e45c0b228b92c8ca9ba9ca55ed96d3c6ea8534b0db590f14ec18d8b8680a3d8c3449505f84b17bc6c5aec95dd57572c0093f20afb30a5b146a7f3281b77727d8b9eccb2ba59514be83ab21969f619a7d678a45474fcaa8088c62b122359fdd02bb9d403bb21337236bc7d0bbda8bd831a74d6cf890c5e3bf20ccdefd01f2bd42c549cf092ad0a514df9696ac21151a2421c98a1a6ba088a0b178f19dcee12e26264d459263cab7fe9a4c141b5dd423245cdf3cc9847506ef61c47f16ae9a28b64c8e33ceeec3447b14f869a42799c6be1cb4be392ced930db5260aa07b170171da2316ef590b3612fdaa91793b912cfec7715b06a0745415f3cb8884d3af426179f205fff99fa508302a1797570821ad039c2f5d9946244302cb0201830905ecdfeb819864dadd6cdbe0b5f94910b1765a8e035283356ee11283061a04c1ae38e705976b4ee64a806e9bfddc4f0a4dfe04d0a34b331e426ab61ac9b8ad539f6490cb0fa9cd8b5317af3c94c1473c4d571b34f1cb0d0ed5cb99ce4afceadaf669fd9c5d8d8ef0c495bf8b56881b88d47433f2979b1dd382692cb5cc6528dfcbc0166ab7946603ba8e7045b569cc9bb590f6473f95b5f5e6a5d40947d1b40a2b81b51b7c1cab0f01d29c433b799116d4923d6f4695b86a85cb337fb83d7507ab0469be8a80db0bacdf62e2c69d9739b80ccc4ac076f90be10b4750f0dbd4e61ad4e2080022d8c1601234440bc905bf56a4cdbba61ae9a61d20f714e3050d437e1c511728066ebb1dbff996343c62fa269fe91b8a407bddec2ce9287305182596d456363042e0a39d81b2df14f68a8563dd2d92125af1d40031c30e26bc4e399f7d2693b00582844f12607788ef71ebcdeae836b0fc24b83e3b4a46ca2c534520c1c46ac98e099575eb3d6b3c5b90e9008fc3de839c542991a77148f57b388c5c345c60c8c3bea25598f0df74e7fdce808c5f2fc92ad3b680a934fd01b221714fa2705a42ee5b792c197388def3bade1666436d2cdcd6006a3127f01c3ba88ce6f5045336610ad291cc544b3762e70ae3a8072189b4662c2478951ab826212a1a27d66d66a82daf3f02794f9fc8dc3f56e03968a217420d5d13173128eb7d3b3e0076a6ec3b02ca985a7ac38d27a52e3ef5abf9df8a68da9a9c4811b545594c10dbdfa9761739a7e7f1a8bf28357d624a719f28120272fd35beb81899065b0cb27e4b4aa6a64f7b6f063623f1ae470791459b13c72f860cf15cb8f09b0c894235bc89e838ba0a020616a39ecba8a8882c7e58320af5e02317b968aa34a4bff10957460a07ce040a4ef3a2234934cd138f79ad211e05fbfdc23c9fc13dddfbcf912537930fea17acbdba626103afe60503d34d656ce0a349f93c581f9d8f2eb8037c935a682dec01b277b1b502c6629ffb842da63a1983baf3428ac05a19128919ce707c516752e12a10a710373f32087e0ef7fa7dea53c46db1ce990b13cb97d34c6a180aea40d93a9639862c9905005bee153f4b1af687eb52c3af5d2d59751279ee9952d45cf4aefa9c428c8de03791276d470566c2690920da42ca5b318747133394340de20b295f30de12314de914b3a15b331adab134ebeb355e34cb3acb44f28a2ed3d2e20a138a43c7be2a2d34be962bda88af61ecedc495f084dae81ebf04b4edd9e2c2a0d0d13d1f9604d7d4cdfadd6ab9965372463ef2f1510e532035f40fbfd1ac11c25f745922a39e8225264daee4696656c1c78cb60c0d322502285fc6da070a1c1de096cc546f9c7569e90db337673e52cf569b85b330849ea6405e7b6fd890554ed42c80750e19617f4f78646f9d1e7dbc7abd287381b3e544a1dd2c3c861d6a80e9da50c4d26e94fc680cbf256038460afa193d01ee58e9c3898d9d6d99e6558b57c3a08fa7ffe9fc27423fd4c45e55320143defb136711daff6162a225e84875a434ad5df9718bb8063e0d14406128930917db43898ef4c5e3c4457037b7b9b87e9c8df3267758237ef03e52a37552d9d39f1ad5005fe1da71ca0df0de1e1eefcf5f90aad999145d353dfca57bee9177a7f67f77703770d2d400e41ebcc049a294031169674f648056f850848b6018bd6f83c77999f5e014509d8d388fd76f7311850f6dcd7f233cc2009192279b1e3d05d3cf3bc4f52363d57d4946cafb301c119bbcef2b885930092d69f64abc5da3cf8a0bd97a80ff8400af00600a6df9585d24d923f0ecfd79ff2a5709e97d34738679b3ae3bacbc845f14dab5835f629270f580f944bc457cc6e1b86dc31758df1955b088645caaaebb73f8965123bdff50c4ac8417d5e4cdb66f843538ee9cbebdf355a70ec222ec62878438930ed6b3da040f2556647c3d8bf705768a530446e1a03d9af889792ab677985e4c80dfe76b41d3b1b56bfbcfeb357ebddcdb9fe93be1cc1c57cd73d7719f5eac86140e632b35cdc635897e2c139cec7305ea0d970a962579dd69227013f684b60a84a67c46760e520d0547cdc756635aff22c5466c4d750423318e2fee84a84cc8a4a78290dbccae4a0d327f8587329bb6f00c2c2dbbf312bfcd135eb892507c13c84dab1432155310aa575b67a4924f2a2669e6acf417b91b27abcc744bf5859ea91e625d02bacdce78549191eb38c8c0d233dd6a0edf85c9555274af16a52e4e0e404f9bcb1b02f459fafa9834d5ee4e8f58e7a3a0a8e29753fa42863acb69c66f12ba0d6c73bac9b6a2dc7bedb488253220d583266b469967ae6fae49eaa570cb13d39cfa3fe409255d552bc3c717a457a18bb4a909f3dd9d67cf46e7e4b0c9b9d67b0d236e9bca0bb5ca37861a02e31c9ed96b26a7f7c23d74917076cafa4f467a4e2c02fe895b3a0af674bba23f6f2081dc0a67838ea1e5ad3d411f1001f66aeb72993cc5c6f8e53bbb16f96bf6159cf75016129e668e44f62ff9e935ab606baff97402d0c7b744b5e5dac5d06785a594b6fcbb218eefb719a07a402fceac82c6963d898b1fea851298f1d5beaa7ad9da6980948537f9df80a690058fedfb6897eae18b13a9e63c0f289c2f910806a776b5b825033b4fd0339adc1afedae7c08037716f41c0fe5b1c135be2a3e93bf1171d619ce9f0251f978f7cea1984389c43cbb96ebf50acea205b54cd092c7a1daa9fcf3af673b184d91df54315e240e25f2e218376f785dbe664a79198d6b299433524715419aa52d8b6b21f65cab2967f8e30c9fa6d3ad455db45cecd1ad369b99f285dd7d47f44dcc71a3321377901f10c6eca97962f82f0030b5d5c076f9f5747bfeccc24bd80ca02d951030d5c7cb65fdf2a34378d32f19ee20ef0a5ac1bf689ebb8eda0fbe21046708ec3064dc5c499bcbd1b94b7c7391299a4c60ba13c2e967ed3751be6a683015c8a993e351b6dcbcce2accff8f08af6611e05c4ef40746f87fb4afde5251bb7b1f94fde7fc88f7509737446042177e9f5f423fd67d1e27706efad5d6096890baaa9687b4b85dcfff08d968003201f10817c7cb7f48843114b5dfe85ddc3c2700e68850ee5eb6bed8e003c5354a688287ac5bb44ee732c12ac47b797d206e781d6e4ead22c4091edf86cba369952631c73ffaebf97d2199b38baf953b24ff09ffcf9c326d19547e0e312b4a65a302e30f779a4c82c4917d1f91352196f878131b94cdde01abbd6928e82dbe04ace251d84264803f7f95e35eca1eb0f14ad37641268d50e31d811bdb63ba23be2c351da45ed650feebc48cab41fe927f1000268b7b8ddf8d7dd43a2c7b37ceeb2f28f7857a5970edaa8e6830f890e462daf7e37105b96813846fc7cb3f49e756b76bcf6ad8e6571aba96d7eba034b29587e62fcdbdd7795ca94deebcc3ee785c03e997e43cba4df3c55b7644884cca6565250529cafb4dcc7b993dcc1ada9c5c2a29bd21fdefee03b5af9fc016573ab136c8ff36f23752587957cf6d39e66bb1a4d71d6bece6af1b7ff6fd43cdf4abcd27e492c56f663a1f6a953016d06c0eca6f2a4be435cbde298fdaab3780429f681ee45a3907c7742f8ce52533cb45ae588e9c47ccd80a66ef920b2d694b0c0583f89ea73538b392c257c3a484b762be0ec749a1ec55fa716001dc51d7a6d60f5edfd570dac75b4c6dd0ba31050a66039eb38a5f8753d083e25a5c8cc3d7b88dea9b9ffd8f78f4950a65d4aaca8a9701b564245fe645e8c9ce30149b8c660ea756a6fef714d8d27b1dec6b7e7a38c95e44393a8c913bf9a6554bdebd0bbdb206ca1a378a09894f88c24f3cec49a9ebfccaccac23cd86de9558afe43fc13bfe58cdaf6046103cf0d2fa42b11409511d049d3d977bc2d12df45c99cfff39f4638183a41e5375d3e7e255094e56276da925829904e671e1a0b327f88af4c3ec73c527181786d12a486f91da9513e5775b8be39727b1da9ab346c06e44a285e1dedad1ac03fc8e5715aa89f69db45580f3a80c193e4ce15a0c92a5518169cee58b0b1b437265da2cdd6d66fd02d364630984b508e7a48c79388f06a69711da2796749a01d368999726875d7065a00955ce6cba86d54aceb356ae9f12fe92b243b30497897f8ccbded4b2f29ddc00d8842d02d7decc94e5244df5c2397f3ce2aa6791f7148d40b4f8f65396ec9653cddbc0abb4bfc9cb5523f41fd3db06210ae3a64baa4c672ca273f68c5f6066e434f7ab62626efd257c0633b28d45880ec1433c59ba63850431fadc462f8886b1a6f027014afb165fd8597fe367b34faa5d53bce2bb8709baa3cf1857f53f55c6ab3695bdfebf2e61b417ee16fdf31706f0d084a626fca59586ee3407ff79c57d2d5a70c39493a726ff64683d17b6cc563516fe3f4c48b883c87d9bf6cbff6fe82cbf939ac6994c8a7c68e32bca908e8fc4c14faa373dc7fbbd40d09e0908d5a45aeef195b1aa57b49e000e441de23b0f2d36df9fd818f7be4d19698026455e65304e4a0f87e575f4c8393728f675d31d5e94f0788b24f6b6f4ec238b3e789d20200da792683346b82f31eadacdabe084c526e3d7cd2d9b6f23451af62acc2415f5b5148a6becf84120e8f75da2a027320f0b5ebb708809646b62bcb55525810f40f02e5243458f5fa36bf9165b2d4fdc5be0d5b1911293a639d0516e6dab267c52607bfbfe78ab8fe4cb247de3aa42ded0d3f30eadbae674c3c5e14f89e61ba0dc9adef93068d398050676305bb5b47e3990bd77b1fadc923887782d08e0e434c89853b8a259bddfde6583a219a1c8c38da3e2c627e83d39113e7ee804f47d0fdbc63ab4a5244ef1f514cd161bd2f80cc271b8ff8afa2ace7f62f994ced4ae45586da075bfa8c05134e05df355997f686925c997f0674a4860cba94a883394589022565e11a6ebaacb7692fed9c27d6ef6cde61a41dc04ad56f97c64ae2464096be9a67de1230d2cb2bb7665005fe8d474971f71778acdd104970af05be423aa7090b29c1533d7cc285ac2d7f61aa1cf60b48210fca442295936e09e23e9007f910601b03c138726dc0b0b014531750ffab6217c0709e32c52973e828b68a1c2c968d565304a68db52af90d37fb9143fb17ebf9496ff404a9a95a42cffc16ad65b288d820ba131e0c7b6225e2ca7e473c412ec0a780a7cd372b0f65d000882c6fb7d7be953c1465b8978d16cff130f583f202d4a10c2b7113087ba5bd408ff3d4a1963df183fde1312f05faa7bd34a258463220f354edd9a93ac2a5bc8dc9bb2fc5cea57da438da3d198d9ba6de4a5222c689aeb0ee04470037cf0f6aa9ed325f4e260c6c7402333c3ab54a32935376474f312a7c961387b1c897ebbcb1b20456ac1b63e86c37b4c9b4d17590f2a6f300a385bfac10817d40cbbf65ff4f3104a4037b53bdafca19f1dde15bd84f416badd7eef08fa8841e8703aa2cd65b7c4717e6cb58dbe5868dd667699052be889c9c4fd640e52fd57c8de97bcd46d3d2b09f08936b11a7ffcd13024cd460c523ae4dabdf328e4a7b6cb2851f993603fb6aa8e8f819c74ed3d31fba3acacfaf2180385c06dfb7a0e59682f6247b0b58b0ab97a8ed2bb23d970d3059e17e8d9991828db85acf2edfcd9ee23dc6491eef810ccf0724f47141c4f73e73fa5f07db76db8d01f8e5924554b8ca792764cffb1d8ef7b5b6621e7f933fe168e375e68548e2bb685928b402e6c41147d286a6dbe863ea858a0a5b29ab601dfa2c7d7de93ce4b40369ad84602594f64a5d35a4b89a595539253dfbcd76b214447b9053960f414e7dfdc910a8571e2b5f345e310ea6d36d8ba873d6a764eb8b22d30abe1ea91afe6da7277799d99bd20afc2ffdbd764c972d95e5b870fa29ded4b0a668016fb90a1f98e805ea38ea5b23bc7660211d082b990100c17726a26b977322605426978ac7763ae9d3f203c1e28683f359886409c0d59866760ec6f59b2ee357daf20771bba397b2bdfeda328abaa63591e835cd57e92a1634e2ae879e8904e31a633bff71e007a295fd3811ece648a06a5afb2cc9bf51873d48e08e85fbc20f404240ccec9eb0cb71b6b01445d6f0bdff3842cab5347b88b9e56c0bb11a7c9468942db32d8c9d0c33167dd21c74a47d4acba4bc5e3564f562b8155b541d220835693fbcee8748c9c21135c375d06cc01e3881d7d2f9bee7463a8222373edce7685c64da946e95d9f1b9bb5de9a2813c332832461b19b03611615a96d48f9c954441897b0a834445b926351b2e71cfc915eef1af1ac6d240c870e597ab900f3bdf989261f0c87be2be7ecb4a1d8e72983a3ff4596b56b4015d5284827c3a68c1daacecf6d451a60c200be0cbe34f8c2ef9278e3f39a4f829a8f2140dbc8b48deec951bb1c2df0f402de7a1e0a45b238a09216df25372f71c272e60ed645a54ad944f3e02acdaf457a4eb209f4e1eff22b4ca1f618db5b0899cdfab448716cc0468f39c932e6e5677aadba94c30696d9385871d715e057d8d15ff2e3ffda69dbd6d2b78d9f3fec29f85ad92521f5859c167ba5477328a8b52496ffaa6760bff126d012443a49f22af2b2d31c687524b895fb96ead638b4456d3da6c56d8afd334b7e01d58eb7afc6bf68bb2ed3e2c83c4c89e2cd45f58b2aa5479447f8436f87e9b67921f8c711013765a4a668ae034e2100dd2effae4aade49caad4fb41346f044b3b1dbca742e490329cedcafc3e7e8e0264c8e537ef3940ac23e50b2e46bdac730cff41248e139d86a41ffabaa39a3b6a326e45e21bcab54e904088829f0e585c75e3e3c73dae1ea87768bde5c84584b17b2c2ef9bb6a0944c4e3c44fe09bbe810650145b1514bdfb5fd8675177fb348d5975f17addd860c9f0af09f6c47675d889ae3c96371d6b32e9c5f3a9f92120cb427bb0771149acdf6b358ce021d6220c5d2dfac8f08ec4ceb73593cb33151a00738d5e07f27c004b2539058803feb46988cb84001e72c7fff17b935590debca7ae6f391d31c399c9357bb791c54f1930c1b1cb128f3c4e657cc7a1345801fc0ca5278275e770a5465c8c501a45d2be20a79405919c642fd8acb58572eeaa05fe112acaecbfe0e654080b2387aeffc0bef87b2fa1c4f1c6072cabf2728abb7aa593abeff13900510fdf43e8b1dd8417d3a33b0d90af7a070279616b5432706c7e649fe2afef5f21473a4b3d5f21bae5cd3d52e87ece8376f83b8bcecb54c2be6a68ea53a9055776734639272d5d57be010b5c831c85d1482a15389b54b8d84a6f0d97232b30d13fb58c81462de3a281b7e4d46da7ef126e3397bbf744fb4c9aa7c8206c90bb0c15c436af39cd3da34c54686b16f4f43e377216515455f80e23b904108e0cb0173ebc91620f683407c1cd903df8194192215301722a4f50d3510f32b602b89e8455f17c7dae684960bfafee95008679b4e2138081c4723f5a907740ca3674834c995cdb7dfe2429d6ff2e7d562bcdd348635a48b069596a06989f7a08daa909b9f52bb76a23bd3ea3f30347eaec95cf0eec85d70ce71c4c1365318e83e9a1ddae51a7334e0850542ec01edfd64c70c81129e00aa9222a43e83cb1d60252ad629585fc17f4ade26022ae78b2cc4012786828cc7d742fc7a8b875f9d502d2a8a7a3c28bf38277b524cea2fe18a7691ef0e2b0c9928b7e0af3444ee2eac532dd022fb194f8509b5b83e185d91dcf2f466628024cfcb1427f3260eace73408e77a49a32c274d908dffab5b236f72c493f4ea382c884b077e9cfbe5d10e4df440d24ae95bb3ea70408bdb49402c039e0afe4367eba9c65645f830b5468acc8e036520a4efaecf35d6e61cede28e3516e06f504f2379ca5fb599df1d57474f9b81fc754f7a4aea42a0066a40098048e6a33299985801c99c407844409334f72ae49e53ddba98d40a4523387f441cda7620494b8de876dba8286b52b4167d5843cec6da5af849ab9033c2d448c892ceb64da6822011009bc8620c224c953098dc8d9ad25ed4a3e5695a2663e23655bdbcf8053b902a38bd311c6f2b5c3664f4bbb894820845ad07f67020aa0aa374f0ca14033fa803d68175ed77cac77c0b122a364243f6b210abcdeaa1b7233943073a82ee0c828a4125e37a0e5b0e6b29bd1d6342d99a360a5f0bb2429cfdad328addf6d2d62c69eb0c552acf6281ffb2437daf44816da7977e41cfdc4ccbb9841cb767e6829f766456779e6999ed0b7481a0c8f8d394c3c94d56128e229cc8e3716f46b3ee7ad8f085e5933137d4ba315a6b5ea148dd6cae25bd5ccefcd6daf05d8eb7c8f49734fca862a7fcf1fcb14e127fbe7ea5e17402ed18da6b1c1b1bae5419aa3f066aef8cb73c12609cae75ea2fc4e676ca951cbb5e48e03fe2845a132a8ea81fb621c5f1e4346ce6ad7c9574778648112a54af2462dd99962375714b67eff6d90b310df1ec64694dd02b0885e72f90ee50afa639a0127b4afa834990ba18e6d2a1d60d936a395cc0d1c94b90dc780041a29a026abaf306cf84545df5bad7c91a38fb6917ce69b435c8887ec2ae673ab9be7a434c3ad257a728a6996de62ba098e9b2317e1ee9c5c6f770f7645fbda12d98ae3e8ae7b03ed490ca2535f8c1a1f2049d35481f22913e9b3440f0f85aa8bfb3ab5b658e07edff59f445f621b1f7aa2f83549d69dc12c8423b43f6f98cc83d4e61b4fc1e42c2ab1f8cbe1dd91ee59cca2477b6e374f06d91bc0c322af4f1fd9ad8b139d3af8cd6c201fcf562aa4c3ac902d5c89d9e1a579e35d6c1d3e3b52664f29eb9f7a84a8ae6f6c40d94d5d6e4d33729d3f768ea0721e0a81202b52c6b81e86c26102f83df25e82a09073acec32d20c73bfe716e86afa929ae0b399a956d08aaf55c13672dd10c14b3c231da51a9f7c5e2501f5b34ff0bd39f10562e1a140fc261eaef2818628cb5e6a7bbb3f21974b01fd71ef9c95e3a56256b886a4aaa9d32494c213aa452a03d94ca051dec1ac15ca16245c33fdd181168cd317e5c111d89e7ac5fa25323fe302f947cffbc42c70b6f23e87e3c0e415119864b7fe616572573eb84210b205cf863b7282677b2d273f3a82e3909a2358fd019e6fb2c5b22be1883bb41cbe45a183decee6a878ecd3166d8f0659a13c68de0399de91083308b207b177a79eb1f5001499ae42507d4616eb2da02adc423499939d71d62c0b691c51aa9796e727ac0d5692e4c0e1ab5ba611988a327a186203264ea9028898573ecccd87cbefd6a7723db1baab7ea19ab66ff997c15de39f105aadc952f7f1560c8a011d623f36b43e256366d87bdd9c41bf566b8b0a06f93b5b8dfec85a0235abf7a2b2544e230bcb50bc658796d50eb8670f562152b1444875f849ae814f8a1085e5bda854433db34e26f1f5c6c41baaee89f0d5b845d847f560721618dd62632bfa61bc4a8c4b2b4266e4ebf4ff9ef9dfc2448752f3bda0710b7339b6db3e02980aa04ac37f87df8519b7f4ea7e7bbe0106d20e31453e9190f1469092473a413e70803fe668a9145342a1cbfb2bf2f1b314e33114ca7b1ca1968fb7cd0f3eddccbbed4652869e84efe99f2d5af1148f69e421d84b735e32da87cb1c4770701d37ea2e17389cccc7188bfae024556ad93d84e1867b15e1cc4bf6238a1e1742e0334e3f5d9a8d8543e0dadbabea72e22e7abda8334a7460347554cd391c98ca1014c799485ede5406dbd223286a4eac04d5506f111bcd945ba9d8fa9ab07ceea7cbee7a252e9064f9f959e3fc6915d7c57ef9210a0e0e30af48819668a6cfee76489ad9f7e57a30fe63b82d6e465846e6dc0bdd51561b53f624830465959fa4acf77d04171235041d648f590faf75919a66264df76a2503ddf1cb83610c71939563b44c3abaef4a5c9a0d89e392b83d39a0b0a99c2238f5be19c8be1ff4835060190e079d70e120c50628e2e8d66fe3b1f372f7a4b8624e61aee33956d47b7dc6483b3500f351f4b327c5bf4e5070ac0de6b1c1d2224df15690b69f04fabc5cdc87b3def1ce0048044757fd786236b3906af8b0ed86f80356b5cd971d5562179087e406579d2f5cd3e946050570b352e26ebcafe800d4d2d6c6b4d7a1177347ce3e18e5094d50d6fd2c8901bec6daeb178cc94a3beacf5cc92b7ec2092cda106c620381beb112fdbea1bc6e4aad0ec4c9922557b898553200df486713e50c268ebe379ca9e3b09550b17f5b22489670f541eaa775f8d6526785b9b7a27899f77de8fdccc542b50c0886238458d9b2257f831d5ea8d5ed9263eb6ce94cf667bd521e5ef32161704981039796aee15d99aca20e52c9316e2019e778d8e0e7f07be3e17d24a597f49e940e749603014422c6493a69e4dfb2f29e58cd088d9db6295cd4cb23b69b7777fc4e149b10aab3055986acbf920cf6a08b58a690c314b28565fdc7c3a91ea4dfb05887b788e13592078c437f926629c20c7f9d1ec9e8b6c93278aaf5432ddb61b37100e03af22a354ca9d7bd5cb368d84a7c1076c05fc44130e235963c16d7a1df75769ee99c7b5bc7abefd5e6f5b251068c244816a61c16eebd172e70701d060f332780c66e64ec93fe05c4ac9f998e885595c5f701c01ee7ce3072751e6186e42b2d77aa28b6bacef7ed315e8e3a43db60545730a87f9d198c1e134a6b54adf2738bbf81e83ba73f485d8af4a99400c17564fee2066ce0bdd68351082a25901b57dc1a50275515ec7d0dc54a5968b1a545a86ad76e5852ee800d0d74a68a335dfea45e013ca9fdd3880f8a258f470ddc4f3cbb143184eb5d981ffec1af10d14ad45254b08f333f548211d2c2e48ecc7ab653cc3c43a64cc58dc085a7672a2247b02ab2737dfecdf30b59d6e71b3450381928cb29230242280f50cc2c551d58c345d77487d507067d4bfbf53add213cecf56ece32ad9d2a8ff0207ffae35aa56724838b5659d5c79d9fffc127d698b55dce8eb0a581fe40b0901e828f1494ad0dcfe3e8ac1a2f81224220586e88b4f74395b92ecceb814d17986803aec0f34e98bcfb735746407c36ec29395e0d8081ce1dc4a8400657e3990fc59522fb5756c271ab87ca66258534b4da05c68fa368f636aa6ae5ce5e4a876833e573e7f5bd56270e945804c5503f603a1287cc17d4cf951b134e02911d43cbbd757b860bcabd24bcb925a8e68244be07a4c766191f28507188b0c93a8f9d6f6fa8f981eb405a4bd427745eaad08465ceedf4e13d9316ffc96aee887930859b5f055b6dbce24cd3db39d59f0920139863658d29ae9c00d4c522b6e3cdf821d0e24d15029ffa5756be0c6ee7423e620f12ffee90756cb02b163a4d3b7f84302142714bf67c562444d35c127561f5c77b1c8b37b7d111a64f9365d2dea058788db16fb48b69e3579cea4623e4af8a49f7b31bd984e1b4abdd83f2ac3baa375f13d9136af043449f17f4f84e36b871c29454f8a041ffe469f1d65bae0efea880af82f9ef2200f91bedf83afa1cd4d872d9a216b0d0123ce6966f3f2a702adb29a607502b5d9a79c07c41f9570e48052329552a4e09fdd5ecb4bad9cd6e162ae7c78e1469d11b93ad894187ebcd02b8790d380623ba39dd2bb43809d1293722eb43eccdb718e0ec41f7efba0fb7b74d73cd7481baa7f6b8cef1f87dad23a36099a07a18633600d69ac10f928c08121a04664f7244f55f315536aac21f1ce07ad180afaf85baa9a8ece4762bad68a9b634702cc87fe6fd25bedaed94831621bbb551e2124babd60288fa2fec8575e2b508840dedbcb8a790b58aa3e9d3e8d5aebb3ad42bb51415da39d7d601190ac27c05a7a3695964d96adb4770ec94be03c5f9a29aa1283ce30a98a499d0d9369360c95fb1397032c04e18126cea060b81e8ddda7d3c0f03a32faaf59c3c46b87214ce0ec22d4232f0b9d3cb9e15419f420bb53566fba4f7d08ee3b20cb667c072e4ca0d7f2200cc1a6417ddaf18ba9f7ef86509bd206b552aea0783894ba40963126e489d4a61274ca774077c76b87941ad5df88c1a8bdb3851fcfc465ed02ad95820b7745218fae0b495502f7d38a1fc0edd7e59cc3d1aa08702efff07d9a81a3d4964dba5748ff4ed2b5c1efeb73be67ee842a4baa6f8343e874d58effc5bddfc09ab85cc84a3cf4359384c8c0277759bcc0541c925153e1154368f888daa7cf909cb24803cd49a62e369bcbbb5452daedbb1786d7142db3c2e4920dd005a4d199216409e2e467f35624cf2f76936504756557ff1076eb10ae6fb19d4539fa1bb5e30b71fc673d95f5fbbf320bd823fe3e5c1c848a246bfbad79f6c6faeed50c49ee9168fcd8e5870e636353258c335d0ab0e35a4d5764b735fce2254c87277deca40089dac5cb8a6c2f077d7e1e7bc49f199595f6d2f6691e839d2ef529b34e3abd21496241b6018d87793d8b5fb4f84c25ad7003aab60ca49c15fc2b2a4cfe2c1e8a202b3020ee878f57d32b69ae2fbae9fae6ba6e855823a698090a6190c22030d9d503fe9de6fb299a94596b88dab561fb4ae1e3ff0e1567b29ed432207b30e909fdb7f4ff8100cd910fd2f54a836cd592786311a9a116e0acc46883c21bc75d1eaf2faf70b62cd8a4d36ded87d40072e41fa4c50050fe3351bc410f0bac157cc5fe7162304aba846f9ee14a45f16cce5fc855d0ddf9d09a8bbd6250695004a167252458d37dd79169793c3dd2dc23785da94330fda1425c240e89ffef5adf573ea95f3362ba54ad7fc3cbf2107c4e95dbd3d15ee6448856eae3b813f386762f4483270f69b235961ecd5357d94220d4b4e6b6a92879940315edcd64e97bf31bb9065d70d5c517ec20d4b9e14c74342df5270ad47594789bae4b47df46f62491ca1ab86fe7eb14ce3165341f0f43495d1b1eba80cf5b1fd13490137a4e63e80a68833a791c49722b0405865c7754c5aa4de1c771ff9be9396168888fc9fec7d2f2f4e74e84767ed68d2665a197b7e8e6777efa71ead6ca7ae2258a74c918e104b5b1ed536f40d38995ce1c3e1f72a5db90cf4bf9207d4d2cee2012519e29cedfce5d0dcde532a45916128018b6147bd92e9c9f5d2eab41c551bb1437226f516000d7b8a3f61634f19406f3d5d3af1ca16d0209925a7c9f920fd967841ba26524ff38b59e58599a34ab26d29d8bba20a2b68011b996d3656a448a1b216b8f6dca4d19a9025d8cc366fa9c3c5fdc71f5d7929c775de4830983286798a2d9f4dfd36b5082c3c6add3427b658e73af7b4aec7808daf1b325160bcedda4f7b48b3767b191f274158b488e703ccdc34a8c363607d7099d7060959474f095b3ac4d3f472c9e3a066e085ceb7acd1812f29efbaa66e3414e335f0342184249497f9b769cba3c9ce58ad9c662cb6395a737217a1457a7de387d59dd78ed7f661aff0fcee324cdcedf0d8b424d2183f95559ed8e701144740c2798d55ec4444ffdbe24ee7dd892944c64bfd3bc725684a7b353ec938567ed013ef1071687dcf9fc0bf53dc50fb64a2a184c59f7d75b6de8b0b5c4cbe204e9a66bc20d3e7d4b51f02291256794a0988c916bf1439a002383499dc39bbef421a24e5d228f66b437bd6db0e9f7e0b6de0ac17f17b6ab54e5d4c8a730518accd62344443a1e48e46490eee6efefd4ef7ecbfc5517c6fd62eb02e0ca4cb769c4007f6fbe2f577842e06268166306c6d4276a62db036d1c563276f0f2a5ebba9caf51b49189bedff1bfac4a1dc421e9f788317dc3d9337a38566761db76972e539a7d8f363d1c80592984c13387f122b68b53d1952971f2d5b6d8c7dcaf3f38714d42e97aac823912cd56d622fe686ae3362ca6520aa6ae4144fa4c468fa170aaf27e723cd59e4a3039b18760c8d7a01496f9b8a9c7f1101cce483bc3669476f02df389e8c8cdcc1653bc060ee388204890aa50bd32ee47f1997561635a8bf683da3c77cd602be4d3d1500945a611baa2a312f56b694634c3e6f73e4ee1e7ab81159abe17def80fd3b2aab00c0b2ab5255fa0a7f2e456f942bafa8ac51d8a9c5844b28b85d2afd7f8806f5b0772921f722a7ff3595d526da1bdc71e9c537a62000e7cc90e5a01f47513ddb79c79c900365ecb06b6af249faa75403bbb4e2817eb9fe3e379e94d83dde46f515a04db02319a0388f38edc52398166b3e6e367470ff5eb2f9a89ee3bc4846640641912339f756f2ded0dfd3ce5f58e620b951fce63ab6c3cb68fd9621bb782b00409264a6ad0edd375ecae60562efd984c1ed1f03079f093f62e34f9436dc94e27bc647d0815f8a024a8ec47109c6391468cea4f1ab983134ed7c0f712bace92eeae977d44a46c25299f38e268c6ec396089e2ae86616fa23b2d0e4cbf0b4523daf1355c5fec2380d0d08dc68ebec4f6f14335a4b347611c6ddae337a79d0a5a7e25d010bd00330850c8d6ddadd0313b483f1db93a7c79daaa8b74bec0046378db8c416c5864d35ce2d580a2a94e925990f4abf4f6c6729453ae7db934c49748bfdaa33864b11d76506c86e93befdc6ea5d2d18192859b7e0a3ee1151e8f7b8e756a27dfc689e3dbb10c66ad6528e91d60eea1c3c9cb822143b4ee7fb07100034a1476c7ebbf23b6abfe032d8266da1967889c8e66a8e904021c690a08616019579bfd11a5ea372581473f30e64260b4e2abc958be9769f31a75c5c563dde57b860f4b196c349d497304409c9ca1ee677a5ad95aeaaa825a11a1b6f34ed2be91f931be2f591be756bb140ce691f4b22ea60974fa7af62a763d383c364b85c7057ec07ec6c7c0363151794dc6b882b03b62dcc4f5a62a4b02299ab022496658e817a547546fb8c9f8b7fdb7ef0e13550c4f4d38eb03f6fc7998cbeb8b9df1f4aae419e7b48b0f6747899c4b26908aec78505ff41862042dee2bdbcbc6859388db545817ed48a23368c04e0b05fd1b8902e35d01d132a020e23b222d95624299fbcf6204fede4d8728e346d61c1badef50b6f032f9aa548bd3094e23cd809f1472cc8b9ca7682011a27bdc32beaabd933704a49aaf629f6dac65d02042925ff918e6127c5191083b0b908cc8ca2c63baf04390075dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
