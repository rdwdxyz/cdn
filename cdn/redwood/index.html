<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b9aaa272563aab0b40ee972914bca8fc1994427dd709d45814f70ff0f5691530955866a658034fdd6d1dbc45095a5a0533582a49854d6a20807a7fb183bad9da95cb749f70b1011dabf60f9c424bd34d785fc6828259e5f2ee9b844719779362d881baaf2f122a38acc864d969b193c99784568ce32a0b4859c6c3e796133652694262012c814d5f7a954647eed827857df412bef19aa049b62529dc542e17856f7c48d386e30db3581778f18d789575042d1bdc0f6b0f016066928c8928dd7c9055821b338f70635184e55c95b780fefbaa6936e1f260ddec2730f65fd781aa9ea47633cc3adeccfc98ae67f90b59cd4ec9cc0b24beb5af691e07eddf984d903f99815c24b4c919723c0b5381d6b7d1523baa642426ec3b38e711a46a9b5d296a027a53f3ab02b0f746fab7a4e9860c277e105bdd5e5eb674b4e112223addcedf0f32231080527dd1449634ad1ce25dd7d391367242d834ee318b80f5d1ac4b52cd110ffeeae54562608d3dc36a51d2d7fa97e09436cf7f8ea2160346b986258bfe931e9b147d48bc50f255054ce94fa177f9e5163d4268d4c84bc4db36627657f238a5c116b08111e5a276957ac64de61cb3d0e892ca93ed270abd0bc1ec7eccc91d4da43b75147b48469d333afdfbd8acc354d59ba2fc0bb655aff77e44bbe592a2988c2efccf55b1e34961c7935859a999d999b4b600c99dcc2101b36a2503ff045a00eccf4355d750cf7f9fe5e200ceb573cd33fbef07c35682e37cfc75d73ddde19da03a306a52dbee7c8d0150d4379188332ec48bf328a67f4d2ab976f5415c88fb9b744e255aec12c070924cd895b8a8335e06bc8d91917ba3585425d436491d1b909a9abfb028622a9d8698a6f9309149ce19e75913072ae01cde2c6cb0926b8ffc5364ace4b981573398728acb47309e420238565f668f844b1c8f08c45adc666afb43af8fe337fe90f3ec43291c2f099d62cdb230b2395d03597f818653201aec101506f26cab7cfc72e797ba5b0293e2bdc674c7096d57b29fdcaff38b4039d8be97f3b987fa345c920ed61aae955333630edfb26aa84508275049c630aebeeb8ae3c1bfa971faac9824dc5e5f5b4f5b61629625c5ca9d0e9ed42a789433facf55b283ba8b1ce1197a874c242f8998001cfd12e2f370e822562ef1eb8e8d03cef446deb5802f066cb88925597faef1f66e2735a7fe8d52f55dab22cf31720d67a922a10a51ebcb8d5bb56ad81705ed4ed5a07449de4fb960cda43d0009f359150b99371dd5fbb9a4e8cda33bd2855ab4e7dc0ee5359301650834dfe06c6cdca15979018b062aff587b8986f98d945b22a3614cfb8f5a20db34dfdb153d2d62305e16cdacdd4b08d6843cdb7bb97d795cd247a1af61e5b1ff897d65072a99be8ca926d943df802ded2e1a035a3595ad200e43871af7aa61db3820ca1bb08434754d90cb8062abd7ee89f884dbab460b61b76d4cabd40c75687e1ba0b6ed85c72909d77c228b7a1cd138078f130f3aa56b577f3362ce15d9202111d4250dd1fee5f5130f929ca4a37525ba866cbb30b883b8fa677312b03a456702e1dab922cc887917850462825abee79c16507a48f3b6a9a02197db6283757e36149c4cc58bd2394795a0950890a3f0d035ce9c89ab2b79277e12040aadf0cb6561c7fb6c39f6ccfb5e69a8a5dd5f9612ed166e1d73fa08285c73acd50a5be1c192b64ee568166891965b8503c44abc44a69e1b9eccdfa29e70e1c4aa87431bbc756f4b64d1e104861e8e41e4fc6e5175b482a6121adc8904b7ddc74c4351060d1165e4056df1e3b9fc43595a5170e5f4557ca6a7318b81dc28a8635e428782e25b8e293122e437d3300c960641393c5f441a3ab4b180795961e89ee5d001091c8192d1c7f4c84670a60910941d123ffc7a82b7b1e9d8efb8e299b61a7c57c1c59fcc3fbee76fa5019db2bb79b48b7d7d4d8d4356267a12227dacceb57b061b763743bdb39ca96eddc24af5ed1ba7ea894837f36aa27d824c5b6577454fafbb9759f4917624249c324fe13ff83e39810e99233a466c786a1a7e74ae550c4b5523410940afbca44d9cf0585da426db01269743d924477866106bfb78bc91432832962b58be82ec01348fda7b87120deadc45dd0861630502748591540a11ed83952957394d256f2d6581c3346b3c12847ddf1db0802ee6327aaf33798b0db874d184e9d7e5025fdd9ba7d050a450ce483788dcde557df67273898c06216229e84666d7159dd8211d724d701ab9706d2110eb6f35c2c2281a5c18cafa72c0bcc47408aca45f51c3d4a0e9245fb73272335265c142181807f045a8147c2f6767c042f98418a8a6964e935dc99ccb4d8c98c699cc0c5c1e7619e6d0049c3974baf3c2720308dcf39406907efee7a470f6f9730ad073a218bbb2dc1d9e396745a96a07fc0a6eaf770778aab73789eb1eec6df7c7e7f2e8e2e3d1aaff3cf2cc1c0d3e841b72de84e701f692e154a4b0cdb701e1107ad94c450654ca7427a9b28571bfb0c97308199e58729d56a5106d61d0e2594686d39000b89521f146c51ae5946c28b96d11ea66de029073d8d07432ebaaf1ec0c248999e09628891495a933c651619d5d12f7cd5812361673438877409349d0a73c4b0dc672428dfce2b6ca28892527f7ba399b6d4cf0650d16c938bd9446f3203b08e0f125769f85d8323a8c20d48df05204fbeba678a52b0c4c540e1bf0151bfd7d6bfc3019068fbf4644cc8d685f5fee8fa077785ab8b03b6dde349a1c958f2bdd2e21c0d486a489abac795cd57798a60b1a24d6eda3e48a4e6838c771943fa49aa1098bd8a84a074830cf8f22d12e15a0aa7da2a2119bcc37a1c5ecd778c81af2a3100f0f4fcddb3a5884d7f75674ca1c7cb98775a8b05e5d4ceeaafb297be64dbff5b05cfdd46eaa29a28fda13122b739dcf61a6ab58fddfe35fb44ccae379b3852b0fd22e8b4b03dc742373b523e15f5170742bedf0fb102fdaf5f165c8ae99cfe093e8aae6f7ced414c1522281f8c773cdc05bbaffcc6a83e36d4888f50e964b2e2f6aa2e18d37a7c08a32994d55b4774184a155297aba42962349e02860a5166567587a1b397bf9748c86cf27b9eb8697feedff314e1085bf865866e9e209b01756890cd2c3ec17736aa9064c8a718450d56f5c3aee8185edf7e302f6f0e3373ba5197ea6bdb6c9ea2ea379c41b96ff32c1956bf9e9885bb4187f32a62214388649831fb7d9d593d14a58c8eeab496717231d0ad25a040887714cb6646ce7e0c0456c47231f74fd1cfd7e7c25e39970f7100df454a95cc119f97af52051f3e96e5eafe7bba234ad83589f1581ef34cfd0241c60f93a805ad53d1e56d3a82d02a0289f2187bd36442106146780579e51996727fa1cc482a880b6ecafde69a7b25ff72c43620df8d2ba1b43fa9631712ac22fac82203107e3a8cb2afbd40064282314d19c21e9fb913104efc875269b863e91e286eab00e17bbd073f2f8b2323400c9de71d09cfc13ec32f38b7bac4d3cc5eccd164b49d2142f42b2936fff6c5e35b908ce5879eeee593ea8d2de7a06c422be3ffad199e68cd1b79a8854706a864d8b6a498b10e472b869106dcca19758047a64257f4e2477fdff68d245147410a3e6da7ce7bef2e2ffc0f90fa86a13e36f665340eac764871ef939a59122361f96ea7ad3cb79840837e202be8e7486b5446494a3813aac362bfa13e7655cd953bec30d5f8685f0f36d40631a402ea5788b0e18366004d718ca4d83c7124fc99acc30b2ebc2811fe683e34df3bbc0de1bb187712e491c5af7429ceba7132a7bd129a6e9e418477c0cac2bf7cd7b1863eef2cfe70e65d5d7d9ff56e122adb7acc5823ec83daff8194c79dc29b51832a8950e37a48224f05dfa6a672be74ee12078e4f54be53ed63b5b60a44c39385e72ea57216b0118d06bb2656781fc3cda9b96479ed1a974577a2aaa6b5e04930f63d646826b4b7949005aa87b5aff7ae12de4903d86166bc37fadc6626d5d445156a573b20f655f2caeeb76e69a15a6afb9b8b86e2ec27c6acadd859f7508dbe2dfb1e63e740595e57d9c59511e35cec0082067eb7dba599a2a378bc69d43a8475455bd4632befccaf016d1269ac8ff7523ba32231530d11584edc8f69c3b0447267c81bb0777c51fa8c25f208dc0a1f0fd59f753c676b09a9d71e6a27583d1237118a3705cae132e56051f338a27c32bb2731c9bd3934be9acf5688a4afa9b1cff26089083eef5274cd786232d00d5ad6769fe29b78bc066e6b483e921b302e341b2606f10cdea303738e0b4f34189081cd86ab8d1f973a273f4ada28ef3437506668c32e139a078ad08b5aea0d5829f8bb4bf594e87940fcefb55d7060b3cf00ff26ac06d6e597786cf9251ead94916b9350c4882446968dff53ca81834c6b078b48768dd2847d4147ea7842111e6c97d4ef284fd6e384a15a4d9f89f3fccbc6fe415ff8f520ae301577d9f331430f5ccd1e480b6ed8b950da3e033e956ab0399b208ad50a7eab8c8e6ec913469c36e922fa3c18133b09664eaa2f8f5787bede3de296470c583708324cbe454cf686a2dbdd13b8bbd2d2af11b18ff27c685996b72aa13869a7c65537459f8e3e14a2247549323b3b9e64781401b9e01db2be0f390ed778fcc255a07ce014a85fa9dafb0ae97baf51d803ed933c50f60ddcb3ff492d71073fcdc3e5d7b3cd23e047db736644a2ae689e5690dc249a94b0d881e415c1fb625b2f60cdbdff623e0821de9c998d91bb056bcfba03d848f756c02366385df3ae1e541b7547aadc08264ae958b1309e14abd04bdf034e3c131afbe50c9adcc579e579646145eca81a0bdd50135b9549c392b5c0bf2110d02127c30a4505a96515547cd24ce123706b88ac17dc7fffe576102d8da0bfd09fe99ac773ea0fd9448dae0e72941fe450c4d404c9fdf3e26922d6aea41b651ca9e43d7070d2437a9e127eaebd5a49f822c799972233457cf3b04eeff25ffa9095a930b9a0ba7290f6360cfc4f51f27b2cad4861492d634a0f208fe44706e1c021c37feb163d9bab7d68a1fb334a7c5ee5eda19b25d2773c61047d1b6876a8428f0ab0283e1f973ecf099557368b24527d86fdd2fa45772f96389eb1a36e24a4db35f9fb48cd677f2e15844633d91d5e9f979b498dda2901205f12e6bc1d92e064b69ec5ab1e8c3fef426b7ad16dbfd922c3d38b0652631d33d0cfb21bb8274cac22c453560736a321e28628aca48849e380fce0d0776a7697e960a2b0a9801ff94eba3432f1db2d99df0a246f135827defe167871de9eabdf1548055eb7bd0e85cd616c15d8c3a9b17561c21206eb0a94b067fb51d6cdf69eea056f55f86eaea1d4b9e452b5d71a6648c4163d408d2c419a39ecf8d41efc91552014cf84307f973295fd7f275e08caea650e682a2f7c4bf1e3cfda7cad694a79d3ccd072b8ff238e08aa2be4b51ace2782c44a28a31a36baef2733bdab5e8b67d71f8bb437d407095e526aefb01ba73db7034e169e96e17c75d9bb2e5eb2c0e1533d761d4a2222f5c20722e2354df9640d37b6b065aede34e7f75e585f693627a82ee1465566065d2f8860b737b538a3cb94d7306f9e2507ac627e11066b6b465a2cef4776750782bb5f073fc200050b8aae69192f852478171594c4b855e704bfa13aec08385dc89bbbe7547e4e363ed25f01a2d7384a3274ba310dd7889195a1eb991aa5454f8070208e988b4f32dc74dc188cf3b8069fda15abcd556c449bf893e6e01668f0e4bf9dfa7a569e6ed2de9ed0c77024e3358bbf07721b7059f3629769f2df250bb17a5b97ca64520f339e8d05865c1d33a9df3ba435f6e86ffaeb60a1ab8919e0f7a42354c391fb4b0a6d43a4821120bccf58aa0040f709c9f3b64cfbad27a7d99caab54f84b6921b8381b2e8b835b1b2890a2a4444b8a1123cccb46faa299dea3853b6a4038bfecd34f60a451f4036916811e61f937a5c82efbc495b087f66563547902c597c7a6e4b919392aa0c969950786bc27060a62373d8fb934c4049ab5196e26566f58d9dd4c6e3cf0b0da259e669ab87936539c56a8d04d6563c2615a96b6f3c3a39ae4feb78e048bba8d91d80298dce3051dd35392a073c11e4f48f844f663772abb08173045638537b5bde19d6e5a3edaf6168aedde4959d4c6d37bbfb42f556619cfa2d0d444af36721cebbf14e352bf0920c540145234faac4b53e3457b4b331a00aadb02fc23edb0a8eb6d300de5a890a896bec50dd216cdd839d85818059ac8a19b1e61f1480ece63947aaaf571952773520af2854109e13a48a9681c91b6a3268d93ef56b6eaac21acf5c7e4a3e243ac824d4fd9530384b5bfb5278fb8a6bb7f57d67eb8cfd5c2ecea0ecb0df3aedc56322924369607116a45c30ef6e5ddac174078a34e6560ce12a5a29160ab8dd5183ab5d10749f3473cfc29a615e0e756157cf345f80adaba906fe254f77e9d74e6740ebef8c152eb5766984a2939dddb619e8a9ba0a4ed337e28f71c6ab0b9f01297076be95bd020e634b95fc14eecf67748b1cca7cd413065d42bcdbd06898e871d9b288ee315d55b6af64c51bd81fc96b1f5852c073b2cafca02630c639f91a2d0cf67fbd9d2d2e4de12dc5451ad545c4a5d4a21231354b24c787aefe360427fbf182af044135d4daf539b5325d3b3b34210fe8ed44f0397e940e4c9bfe04aea139ceff578c2b6f0f71d6fa1f45fced53a2a9ed2c27835e8be34cea9498acc2af8460d2e160dac9aa924279c149ba6efc2a9a4c5dd2b150dd2dfc5aa92ab9a4976ab2988aa53a68d237c43c8496de0337fd16ca5a2a5850b5fe74c8d4c6bdd4ec80b16918df022dd9e0b423d563fe7c92f7a5734b74ba80c15f3111fd96fa0152fd81d1a51f2dc4d893939caf5ba073e30b09a72ff52e3077688dc16bae945739d197fb4075703da41ac1b55318bbf4a97a2fe9c2a86328b3fa808398ba9d45c207a826d8e28e0239db6457308961b75099cde062d9ce2fe98ddaa2be442274ffcd924626ae5d98e1af3505cfacdd046cf00484d5ff539014dc271c453cbe4148d45be2c169ada8b047996184460d1bc73136ef3e0b25892bc3d3db87a4d25998652d112e89efff32ab288057914d089a6add6494a859c5a0def37c1c1c2a5e1de17a35c1402aaff0dc58ba0b94fe98dcce7b6a83511bbb07332d0fd6a1e9f6c560aab0b8505a73c881259be88adf5888d7d3c7218df550f682dcac29bafac8994477ccf91c0e0b906fd16ceb5c6956977cf693c559ed1cda9430707d105fb295fbee7dc25d37d831b30881cec26e31400015ca1b63d35e026be797c8a9f8bfd6309ff885a1bb1dada0722b31e13c4e72c1f7fdd61f3a4b6d140c9797659577eb42552bb2af86f8bd03cf73d7a95a9ca8c54d62acc56efbd68edbedede2a2ac9f02f0ced5f4df76b83566148a22f5b2b3e6e4b47853db94feb88f90f6d74900daa67f326bd84f5e9adf5cd20b1b65a155fa833b3198708e608778145da3fdaccfe28964d14110e74d7ede724ed907db106ea93d87952cff9e0ef62982ea67894b4e7eff05cbd07fae7ae1521fc5297eaa3f9bf75ebc514c093ee387727ac939ace9a09660bf49702dbf75adbdbc7c9c803c85736ad14afbf78c8650e8eb1f0ecdd4d47b5402c270ac874f5d233baa94deddc71848dd7ea2294b60437cc785f58c3bd8a2fe4c59d091c03b24c9ffed6e354f0059197589616f5ed713b876aa39f8d72256f44e475a4e9ce76c0dc1e9875c1813b4788150b7e8c91b3700cc261c969902d646550f383b6b72af8e73b670d3bf140b068d2b2dc718b3b798bb180224f988e6f70b646298c1d401e3de486d2d9db01953528f90fe9f4991bcdc7d03e94e07fba1eb24e237f0d9ec6a1f11b7fd1eb3dc595a5bb32cd98b3a750ec677e7c15a07135e012c4608ba1098a97fa1639b2a3d6d9a63663413087609dad0ec078af227eace313e14e7e23a628dd723061e044b148ff39cb15d0f620cd60b60d7049141d8a7cf4c171f2aa7b9f3995bf58ba9f8dfe54278d17d83ed62788d9e855d64c41d2b25843721fb31664ab9ffcffa66e57939202a2049839bd55cd24a705a7d671f1b60d5bda602e30d8c5f4d0e392942c7bb27f91b3ae73997c5f7e8ecd31e964fa5bcf50b4d80c3e9173216748f2367c6e8bf5d464e11a9154a76c9896d2491aee071132a2f965a4c403b45dfbfc2d98502a866131b15109f473044cdf76a1519407fa4e75d338b5b6c366abbafea81010993ba7f633ef3952af72e9bc4da8b497e424dacfc927c981ed68404a72648f436ece24e7348f06172bb4538ea821ab6e377ef39b6f2c04998b7dc1e4ba583816768e01342ea9b5573ef6a733c0212ce66eb1399f977291a45b386937158b2e7da3b069e06ad31525ba2cdaf4932ec8d5045db79dee9479fb2e536bcdb8b711d8b06431254e5d5accc42a3c24a724324a762b112d858198c97610a042c786e8b292da5128386e0b62fb6a51321b79bc50fad0530a49642f183a7773f0dc4d1895e28e0b645ca1f310aa5d027fb646f80168f9d59a5f6edd7b5a3a29100b7e76f90da6e283ce3ce07bf5fa645321883a9833960ce61030f798fa7ffe91d6fc3e943f8b3fbcbb395754c2693c2a3f9b4c38edcefd3b30cf8c8d098e5ca96769003eabb4595795f5915615df6269050363fa941b2704f73435b807f49a03e118218a48b083a4fd02ce7fc181fbbdd26b2ef18a634f837b073c2a71776d84887add809e74594857a5361763f63e60ac902a33bb6f3d13b8e78c3f9f10d70e58a535792d3e44debf67a2eb8d44efda95d2416ae9f031a49463d547cbe9434c31827ed1d7f80f862689e7f341a564dd125b0c729761213ea26d3cfc95194f36489d11298b36782e44d0dc804c0eb57e3105dfb9154f388213e3db79a0064cf29dad8b622805481fee48fd3e70b836e2d52b4af1188a19c7110b27e055531694219626101a48725aed1360b333e45b77dd623602d2f5e197438e20ccdcd9756c829e0b03f170d1ac8c9f52b05c17a3f44f7f15d6c6adc0f5831837d3a5c0f9a779e6664970e9b213777dc88abe21ab5417714bdf353ad807bcf1fabb06b8603ce77b7b69b639e2e3d18ed514b91cc0c940060cffc48927f050aa870494393c863e8064015b4c0a5a1e3c2af4dea76bd85e7a23947351a11061f0ce11832de5de5b3610149fca9da3538ce0e1f6297fe412ece08a74f8066bc96dda197b07ca9e7041f4c903d98e54bc5c0e6d190a78f15112c4a01948c946addefc0607b6a82f6f60b0789a7b3e06cdd23978d8e7aba64382aa26140e1868c011f0b51194b8a9f5133206e881045f423747c64fcce2fdb40af425963790870a813c541e28ad7a0cefaecabb3188431e66537476f78c085932a7ca8472f4c062192a05df0cc6f4bbf8a3835d69923a2c01963e75c0297e96b83eba20030b22d28ad1569eeca0db69d285362c63c4a3169c878d23a727de17d8cfd73714e51e6a60c5fc56a6052bee6685092b0b8c1110a14239fa2322a33c0f46272f4f15c782d6d94d3eb1e6c828e207865ab7b35f452e61387fae410f5a48c213d9c71649e9872dfeaa2007adec2323f7b979125303ec1ef656772f319cffe7e49e88cacef7bbf0b00eb766920c11747e9573b752d5166317452158ec4c88693e0fd4567ab68bb456fdd046daaf3ff99ea9ffd546cc46f1fa94ec6b9aa8b4d1475a1ad00ad2a182f85ca518a1c19c8c459918a5e1260a5f929091879a520afdd757ebe77656d8b7c32da15d262e71394e2d5679f74874f23c122ebf1e5a672dfaa585b5953f47f1e7030e3f513caec42fb34b984f92de32dde1378773f697cf33ffc6090e31497cbd00526ce69453592ad49e74868a1ca9487a2aefa8698ab750f881dcd647f09ce755d99f5f192e878cdf588d7fd92bddf4f008e9f580c41a42553207a9d4c514d31adff7f457938c6030bb4927e11a41fe9cc9ae044471d15578a15f317b20ad411f27ac3630f342c50916ab25451531f5ff1f37fce99ca0f9676c935fa233b81558dc5bcd3612f86c80a480f24b2ca04553524f78096daba2924f4f77f38fb64e51b0ccb1814bfa12525971156a0082f50d438bcb4471665276b1bf5de04b09ac2ada48416c7321847e00671dd3bb10767e3a68b285c0307076948bd0eef3624b0dea99c2db02473b5cbe6fd7f28ba77e6fcff3a7cc84b9d66b4f937dac86be8650aa52452d014f5d23f323da70c827b8f3137f08335bbb5e92c8fafdd48c114e719bdf1ad169c98b9992bc358da580c02bb15a6e719edb67c7c3b4edaf3c9243786693c7fa35505337832a47e0f37b25582e15c9e824dd091e58fbfdc179ee83b26a5ade026406c2c68a6ddd8204c3587d12088421b88ce8410e11c4cfa294408d69f1b97f123ad48878990addc98ca1d998f46922d3b0557be598755f5ad4fb6fb69c5a6dad5318aee97df99d029ff57aefb434f5ee3bcb9731657bd7f629e72b595f345b66f85961ecb57a0b24134fea790dece735c958baa346ef9bc37ff7f0c49f9325932ac99bc8828bde9bfc4681ad4248df990d5b19f86a89f870a6213a6b4db67c40eb1777cf7d9494e8ef6e0c1a039409b9a6ee13dffeb5628c62bc17e9d229546ede90357e3ca0272cd59ddd60fbeee767c9c664f35235ec5de203c250429e8c652932595fce90d7e04333b4499da9e8ee4e68b389d68729bf807497b89d52081b73211d8ce2fafd6c11a34fdf91685e211c0f02fabc5ad6ceba7a3a682a2821c3fd63d72e22a4b186461dca68ab4b051c043ae6c89fb9e3488e77320d1eced67fffc2adff75cc42fec93cd36426f287910ae669219d4e7a112083ca760693592785b562f87276e8fa47a8416fc5adda9c16ccebd8e681488eb66d49b5daf1490fe2bd5c37daa0eb8452384395a6177742eb46b3ed70c45761dad4d0e89cba14d6430647a5d5709b07dac65c0690ba9f2e7bf9e6c77907b0fa6b7e5d3d5bdbd71d8d14d32fe8ce7132fbb1384abd4d3e80f2f7cb6147bfb14667c88daece024a11972c27f943e1c2341f5b55ca2cfdd2eef9d48784e76980ad1ca881e1ee9273fa34be55f12835f778534083d70c14322614910954affc9a16bd119850ebc59865775f2a7a3a7acd4fe1c032249756f424362ac7511553d02116906b521f5ca4c753a822a9c7cfeed2c1ff35a6beca437eebc359bcb2056ace421a3805c3b98a626185e2ba303517d9b31b6089793c25af7fe6b62be2032575421eabb900d2bb2a6c7e77b3b170f3e372122ed8332ef097d2681e4be7caa8085b39b9c42f61d68dc0dd46a04962ed9bc60691a5b6c32040e0ed2f0a16044423a0bbb4ba689b06caf4cfc48ebe6a592dcedfc4f58e6e202e6c4a6a2785c8d26c57aaac7af6b41109d17a1f9efa88e31805c4b5c2b79701303c573b51943b5bd7d629d51161b91e31cdf63d0ff8691644dda761e97d468f3175b004b45964eb3012521b740f91d007bfb2fc70b3d1799d7d90da74eff7059ea19e58fe9cd9c576cac9e5a252add30464eb9bac916f182bea929d4f42b52306b2a07330a95e6e3c593cccffeefda0292685a83837118d74a2ce119f2f78e6e9bfb42ef4814a2e0d8ef7b9866af918de5bd8fc1f0ca72ca22a8128f3a6b4fe29470de510df9ec9296c50b18b2c5175dd5213c46494cc888f495e2a082cc9267437c3cc579bf1399f72a89e00431a3757788fd00fc4a0a0dde22eb74aaca73d038d17efd6438f0b4f4bcbfaead8555d8746e03fb9c409cd8c364ca02e9fdf987d3cbdfb33179f3272e6582dc8246d3ad6a85e397d08f697033869c0dc7295ba2da3d539f78ae9a9ad6beb6fe633c3282f10b2b3941796a7c5d0d79314f4cb3997e32b4c72ad7ef3871dd683fbdc78cd16821bfce3aa8bb7007b13f53d1bbf636ec2c90d67655bbb4922913bc78ef84cd5ee3da8330abfdd0fcc280698c2aca746bb547596275be828e1c93413826a382fc55597c91a627ecb4ddea5431f3589b9373b73dc1f147737eab8fbdd0bfde54260dece19ee63aba550b43e433ecf83a7b731325bfd17c12890627dd1086b487f74d6cc818ccfa0df1ae8e4bd70d09b03feb73f318f7452bb38a4055d3b242b6015bf77e88d36565a3c121e157cba7e64df97accca5eeaae2be17b26050141c8fca10a04f89f2e8aefae6a04e44b2035c54764ea6e5b8bec4f7ce2efd7d333197893fb8f4f644343ec4a16768024d04b338b63c4115e2f1526c5aa53c8ee33c8722c40968ede51eb55816a2142113be631e62579acf0071abc4bac485a9691b022052dab4cb15b244142d5b38f316edf2c5b785513ff2c301fcf307a13d1d65453b7858fe18ea7c931014a62f6ef718a4868cdb53216ab3edac362a01376a2391a22ce507541e44f550abb510ac477b80fac723dcd8438d36c17529656d42e40e6df0318a6cd2410a635c1f4e5eaa3662bb4997f8a7f63a27397568ecb243e91b326c63974edb248ea1ca58241d0efc6dc3a8cd1c2668b3b7848cee4daae051ec53e650f2c410e32bb1304df1d829d9a12514108c5709cca39d0712a4b23202eea74f376896efd5fe736c6b24099784f525a5a0ea7b6042849781850ec2586f91cfc3808f8bf69163a1fd669eea88e288872876fc503c6212a49aa1df193904b5dd7625bfab2f60b209793a1ecd17cf04395733d017cc575322ecdd72d05f4185c0b0c31c4ba046364d06d519941ba279df4da0f9eb698e85cdbaa214cb76d3531ccb0c7afcf555ba0e706cd89a3f4c66c8ca43d97e1f8198044109f7df9b0b84577f29b31c73f005f2bbd97f9ae0e680810e3d89057635d3b406ae5c469dda2f56352d8dff18368841c4e4e2aaded77006f7923b7eaaa302e8cd3e048936683f54fde06d8184cac44f11a7c897f04373cac06030a8523066bb819652799e51e5fa8609fec36e08e064dced1d666802e551091d9ebd1abfa77da8d1dec3151b697014dc899d3dccea3999821fcd36adabff65232c4f7bbf22b768b6258d1d9689ff3a81b6cd7503a4ea3fef8d53bfa199e221ff8df172b03846baa3bdaec33df7c450f20cb83ebabf05a592b994f9db2c8390dbbd6c013ff7ed9e7338d761b48bfa0882e87efc2d73e272b9449a0a52b8e7f228d7ce52f6c7f2a0b033b21ad33d6b45b83039cf000fe7fd38b379b885c4ca8d984f0414dc9448be15f4e3b22aa594cd8de3472578889eb5b58820d7f5f783e1d517cd9ddc2d554d3e10ad12b384818cb894e954675196014ca8404ac1584aa260276c6362f60c962be2aa1059787ddd70d75b82f0ba322d1a55d952d08ab831a52a03d1ed1e87a2cdbba74db359435734796c37708cc0f57b49fa10832cfce855134af05740f7792bb5a132853bce2c261a10effa0ec5e5fe443b40805a9b1710ff2040c324254038bc8d319e977ca99851e49992bb9f8e1d52a514cb0cf787db31b5662f293986f7a909660b4276692c2be87f8c76e1be0cbed5099c42b35401c5b18b87d8b201c92ec0d61b1c41c243a77c1c04b5ede5ab35852f2da8e2b1c2cd8fdf87e22d291e22f0369de50eab9faaa1a449eb6b2b5864111d63e83f3b27d692be55b4b7558965ad5f159af44a3edf6602dd4c680935128cb01ace6813c51fc849c1cd994478d7de95e02bd88bf0a0ed2668656a10eb01b7002e50a94f4b3db7fc0d8489399b863856cdd24bfe0571cbd01e7c46c106f3823a6d031f23bf5a02db5d68138ebfc2aa50e6dd74e151a735d6d7e77ed24cd9b34a5ad6ea195fb0fa660672da15ca52e3fdfedf653ca3a88624fbf6d627ed66da521b3b97a950e5ded4b98253316a27448c6b15eb9475ac76ec9cfdcd3677f60616cc1ab1beec12f8bb16747bf829b804bade0b69be8a74f142dac7fccb59b7f0cadb4ab483aff545b8a6169c426851246d4266852cc8b5bca693875d6c3df98605d88f9f50324da398a583ea60acec40b456ffab9417929ada77a49ff3994f86f873ba14efb569c1c214100da8debd97200c7aebe980d0c5fed829007d94e54830db58d4c7d11986df3d34e3aa495b9c4dfe6f48ef232f6f388fea1d5f00796347e80df1f8ef7fbcf3c5185c050d581f900fd91f304d550d4e5c49475c409c12bead65031a217ff171406744d3c2a5c0ab355c29229edb180ad0c9b32756e99e36799ea4f0238daa588069d944667933a9c25b7077bcca10a770fe20a72dbc3be0c579d6d8c660c08399b879958ef121dd9727d2c5fb4db36c238c1132772aecdee7efb648ad424035e760c368ef4440629a789df6f0ca043cab8118abc0440b0972d42b47c25b9b10fba0b7cba302b1c6868a0d1313881d96bb997d84d6f9744bbbeae04e43405826b52d055ef6a16f7c970511834e0af4ed89314b2e73d5b7a8de873c6460b7c900fd7ca1fa4a78f344fa4c4578fef084c21de9e2e8d4370d3de9004b7709aefa6da0f318d18b88dd4ded123b456f358e03176fb445166799a10ce43e9e799246849eafaa16343712ac9e3c6b684bdc15da7a48e8e808b13fc9eac6cab10212e2056e0e89248eba3c58c2b87e7a23ec53215d3b2c7d84284f6d86c716b8802d3946c33dd05785f9684874bbd4ab3a89424bf1f631f9f8512d3e4b0be510340955355d9405a5500b6e8f63105a44c49882b5b406f292f7bf99653db6e2d17135602c64ee6408082f76284898dee6efd305b2e6161184c40f8715e8b1838d2b8f80265546692f6066b6c2a4f113caf3e0b487fe8e606305d1f6d370bea53e735b60dc31fbca4b0546bd529d622f0c7b159f4635fb9b1b989334dae95c5a9b290cbdc0534ce25223d2d0999b510268bcc9362eedca72e3528543af934f9eb61e1466e349e5474966c2a4a715ccd2e7de6d3b579160be16e6be280d69c834fe34d2a1b2fa92be4b1d921b132f8d00cb4431a6f2eef3aa4119d2940a4fbaaac02337aa6b057c9f5312a2666ac4b684e594ed38c96e3c4452d81bd6994622bb4ece8598faff47d9e64e8091258c2cefdf8f260fba74d090f23fc31b1f5085457a8311fd79484785328ea06e78bbc54ead50734017a3934881521bfc7667c204b1520dc389a7268e88d40864cbac5fcb6a75878d9d95630720e106ccfb8975f2b5934a452111d7f8ec1fc4055d5c8c54be81e32ad5eba71b9afb7e6cb2f9933a86975a584cb90e0fdb908bd55fd2a2f2f05969b09da806f815b10c3f1764a8449391581dadae42e03cafb2eb65e9a9205b8ae786ddfc249035026310b0b6675098861a9f3502aef5f51c5069c89d6bdbc93753a38dca65e0910b46ac21e708d9625d214a69044cc314efa0558162a26e144e1a0f040e8713f72145d27743f36f252b3112117850520fd10a1dfdb3489f05912fcbe452c24333c2ecf15ff7a62b90d6a716cba8af098c049337909b6e6773996212cc4301bb49153f1633d88ae90753d304c9ea2c81df965e829157cffe7434b156fc19f83c624f906faf1fda7d63ca7d3337f7756da4e02fe34897f2a366d12058e30e7f74035bd1ee9d73d0a975b6026bf03d02de5bd60cdb392749c0d8f28a85c969991de92b8eb28346a980e2b02523f59403ec8047b51b93b6473a9c4cf38a9fc08b8b17d5ac4a5aef5bd6f3188eb441b1621ea7d38b7763e4da9fa7f078c8855dfb8cc6d1d812181141bd45bb8b3ee8fef4708ddaa8b78e18490d560605bd0f93bf79e4ff0f9cb2fb4c312dcb075d630b60f832152f256487406ca10cef6d443ef359613fc3fa26efb81c260cae2300a0da7e60af0feedf4c01c2014f8dda5871364262e816cc39dbb439c97fddcee476e49e8a19c92023e1e8287e7abfc5d8c839a55599ede24a3fff69234770d6f3ded2fdba8674cdb7cbef6d8405168728444b371508898ae0740b5b5f747963e623ad59fab0f7d54e033e68250e68ed52b68da9ae43007b4871cded9d753d0c498ad037b8646a6a79a864c755d825eed7724fcdd0a50cd40f25597136ab1cfca4ecb16fd7187a87db215933dac0839f700f5dcc6b296c67d180a4dbe2a110e0bb7ed57c00dc3d781c6cdd91d5882456afbc91c6afc2320504698c4dda0c625f325f98e383c05b00640da4aa44c3705284cf5ca9d643eb385542d1e8466ca3e2f5239a71ffb5938aaa735e69ef75502ddce2f0fc1716578a9b40c3ea3dca25db8949c7f1e00480bbeb49f3e319e9eea3c47196f6bd1d189bea86ca584af80879da6e64ce5f9cbd1fd23b1f5da7f339904e36571ed4193d8dfe089787c678aea99f7e2770aedabd63eb675c7ef0b81c3791b83be6f1f11eb3d0479c06fda47a40c57234faf613bb4cc7cb8fc21dfcca64264fd88ab578f5f1a8f5f1b6e7e76c3340f22a56be5eacead458988b1ec0ef91fed8f5dd5a62db499816d32e05d52f052ed32f01bc03885c449d5333ff9649115262ad2f3df9f7bd2dab69da8f98ca81407fab570be412bd8e4f5c973f74ffec585ba187b06dfbacfa3056b4ba9b6e010cec05b7788856ff1cab61a3290f7fad1406c13c24926290e917fef4875c5e16f0fa5d445cafe2510ca634eef20f55937f1c112170f2e08a463506985f8520cc34a5f19085eac838418c41499393ce9a295ff8447bb4e0e5083327b3f7e9a961da7b2a8c2a19b6e512b38e287cf56ce57e608b00620de596641ada51608d618c7b27f8df72d6158b571e3eb588b8a03a25bee42ec00e2b684a5eeb68453dbcf217755997757e014ca622255d2f610146822ae9c6242e1035b390cc179f4a60078a10b9d753b92419458407230f36068fc56a8c4dd8da5ab6f41780d45d467db5fd986c7296cf57eb7e73b4f5e771f4463a7676cb97d57914c239d28ed4942e6ae448820f2f808e47bba58a072288dd65a505cccc802fb51a749f82f96f49a5ba445531dfd022d0ce658e7d7d90569f620363d91920bb67f9e0f4584c4beeab471ff3e7a6c7c4443eaa7057ea22154323c34ae3de07d415789295a431f7b2a04ddd5d880536bcf5e591f31fc8882a879a47862d9bb911ba25988f4c8ac3f446cf62c0d2bfe64d056f6478823db1ceb5c05e16f4d2d99c603626b5b91aca3919014663c85659605bc41e1afc48f3152f4f0d1b76a48f88bb06cf628704617d1c280e4f6ba532e651428901da0a9cf7cbee4d2c8ab94f4ea996b238a535a160b9d6dcff649f522f1d7a29b6f1173161ad9875a13c2ff43b3790e10787de9af67579264e24c37e12daa17f136f9a8d3621f094699866f5263455e0c3474eb9b133352def2c43c5875f330e665bee3ea419053bdad34c2602b4d78c61027e35813eb1c2d4b9ced8715583db4e6b8efbfdc0f46283770769f8bd0c7eaf568f3327af3cc6200d82cb8de82fa78853d92aa220652241ac96b9256a7eefd0fca3a38ff075523e7e394e1d4954948b59e40ef9ee47465e511d9f8d68ee2f7bccddf795cd7fde0a7928aed5eca70468ffa1223bd55e655abe87047425f0b43ebf1c29601cee67e20fe42649040f228ef28c3faefc2c9a734ef2914dd56870ea8fd203792bae54e82a505cb2319d14ca06e9e98512a7e2a511e5881f27be1ba8bf8d2d421a8200f22638a1b7e90d2297f75ab67d71eea92fd37f9af53e97892649b15d268ac224f63eb0d652ae13be003f64a68ecb31e53e8370518f697359d80697bad2167df4ef65f57b2e6750088094a608996d166db0df1565938af18e0113d1045ab9ad1741d44277f475676ee2eb3876151ec0db9177529b7b915de4a427ffeeedb8737be5a3ea28fc8997edea960cf4c136492529f62e0007caa746a32b8be7a03bc2d009a952c30fe2916e261730d8bfbc84c7c5f28547e9e63c1b4ce9bb272abf738aaa9f59d5fc24f8db2378258c4344771cf5b6f28f9755887f6affae9bfc84f1952c979c54c06792b6297fc40971136d29cdc1777db46290a47f3bf6aa1e478e784","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
