<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87d6a5c274ba356b4a079a07a7f176040c93462eda070157311ffdd807efe54fcaf8c0ed0f23980ccd6e650b21abca8b791af36978e9d08e7302007c55b1f75374835d7516201dc5b2df61e195c272abe4d7aadf1e288ba4190e315e40f483b5d8ad339b7c1477a90dc2fb7d27af81205ccbcec3deedfecb91a9f93b759f4dcc115aecf0d5ac4eede7a1e0648661f23fa8ff074a20f74f897498a2fa14a45f002a5aa36d4262ddc67d2a3492408d6caa9dbd4f53dbb7b33c620e1e2efe56a1f16966d54173ebbd580fa615dde5c726adf4a5012f986b8a80dc7edb497a282d3041bbabfcbf7a0e64fcc85ac209c03da92f471d364d6f467f1de28af8a5770958fc9e6e772e770a32eee3c3356da8a1a697f6cb49437520606611212fc095e8aabf0e35882e4332ae4115f9ddd6fbd15c61f93d4cdf97b97b9e52c81a7742b15c79f4091f0259871a75a803f4031780add628a7c56ef92ca2d1e45234c50be84972117ae78c1a23a9b3b80ac1ccdee7ecac53a2b61000a638472c6868c5c61f968830be163a82f8a792a85bb346c7df9f64c5da7296758b0bcac6fe675e9c18e3b71b2cc415987e576b825ccc01c2a5e8c6ec310b652a99c4504b5ce1551128a5fe5b54ba844025dd1a683c47f66b6559c0cdb3b4a81b80ffbe573f10772dedff91c1114343ddc9ebaa55dfc484a76c3b4281cf72da501d2a4d902d8ba33f8ec26a3f541fd8f59c47adc263db7a6df4e8f5c67140d039c55bde642a15384509821ac6e68b9ade5d211cedeaaed6bfc5aa1bb3f53842fbd94af98b6f657ef17954e3049d213f779e8ed6acb8b65485704fec630ccfa852d3f9457e17174451ebf0755fdcffbd8b1ea9ed7ea17ba16a14fbd8848ec1c7d9b9ad3d69f0b3c0feafb22f7e092392434996dd10eb6e30bdd59ddc55af37a8e7bbb0fafaff36cb3695f46af52eee5180645daf68a5facc706c8d8544b953f536eaa446ed5f958f2c130f77ec614529d872914235bf821a2742cb02829fe90bcec948721b0b02530707d1a91fdbc160433af360e9458bbb39284b3e201a38009e872ea0751841abea2e2815268c138f598ae68a4a45c2c90f31e540e725c073bd51d8c341bc50ee09025d94f48cf943b578f7c8deee3a0575a584efd3d54c2327358e2957816dba450cad9251e13893ce795340c244a456c3cfa52a929a16edc6df66f19959669a4f09c38296d997d80c50dca2e85431681b7125b551e631c09394916436b1430cfd6ccbb531df98ba5c70fa700fe0904c230f71d7949afd5b1a090f258106d50b8e6704ff083c89feaa0571836402cbf4860976bc76059411abb920814e93fb271ca8a94591d4587c171653fde9084a896f6c4082425d2f176fe1fbe92592b752f65bac969e5ead956781f1b4ce57809a8ded1279a6b91adc5fc4d3ffc6b6125b7fa437e9d99db9e7730ea65633f6cc2a04968f84c3c4caef1babcbeaec35dee0972e111ea67719857a38cf823ef9647c1fa883be751bfa9a508d15ba28f87cfb4c9536cc0de2951d553ce72fd2045efb3d909bbb8f32ae20e91f4ac27ce7842d65e5bb4387d2e855f224930ea0b90247a51f986fa8897df972cd0bd0b8171e8d723c5f81e0907d6a31decdd6cc44ad080971b6c2cbff548f65fb212f6d7350666b1746fb532a474524820bcc35904d23e9027d1411fc4593de67653b8e4b289607570e97af1df51729443224b8edf808b889f49636db4ce59b170582e9b85bcc2768a11bd70c0989d2db011a4fca91650bcebc449c70d73d10695e0112204fadffc4880cf69bbbf00bd7537ea5b58ea9996ff6c7039e2f90fbb1cf2fc8c1fac9fc84a4802470f7ce79f28972874cd7fcb7deffe09e696ed1f60ed924b5cb5690f181c09c7d5f3519ee8ff3e14d5f5e47190a045aa316860d4fc93ffd84d8ee99549bb67c71cd2a19be090e063cb5518d9d67aca39e02da9d549ed6c0000c3c577743de78edc3ebbf61550d17b4761a4c98a4d25fca3255fb7d48bf6c8fb78d7974da6b5a12cef0aec55820bc0f036c29449807d1ea30dc24e5d3c3c91c2c7ef49806ea3ae94614ac1e1a81837c772545ac6315b4a57ff725168db2314898043359227dd5c3e7feb54a5a84e6a27d3b0184246bc71688b187197037f30892407762eb3018affa69fe116bfad30afa54a4ec24363eca2254099e928f468c58b0f1d4c9e87c283dc55d21120b7c1d6b731811a915b9a1ffaae16273803a41a66d0a49d40c20fc7f2ee8c2e9fb2869a4cc47ab1d91b2408dfabf7c2c38cca873e51d7e8443644ba2ec911ad9db40ffffe4291b765c82b01f0297a694bc9924871bab950a6e33ac7d8069d6e9964dc9de541034be92f802bc2f61db01e4f9303976481570f4de2b7bddcc6130c40193f29dbc700d9c53cf256760395099d913b37970d4d58ab98cf2cdb57c406f59276a79aff1f11f1c41802dbc3eda44692b4b345f9368db2487a83b843f46558c35832b79eaec1a3788721439d9c06670c305bd41fcd2b3d9806fde52fe0ddb277d2409f55a57529b2c124f176732c1241ed6eb40c341e2549ce4e046997629fdc20559aeedbc4ca4957abcc54c574d83aa950d2b39c5762fda9a405a1922a9a0125db3846e8919244b44f1ccbfd3db60a8c8ea3f5d4b315faebf087d6c3748709003b705c43c101abd7e36eaeeacb61cce48f71a6c7a4b943a2c49bacc42079778b3b474b0fd53470a78eaf4d1766f105eb5fbe3bb54daac20f6224408cff0b6bba51d214070cdd71ff7a96325dd00cdc480bc5ad455250e00895f4a2b21b4aa67fc1a2b0cfa1eb8730b64cb0dc83a6b72ab844d455a3a4538721ba6674620d7ad23477276d6506e5ecbd18cf9d49dbdc38739501f0f4315e17c66c85a7ed8d1d01cbd2571a5fbd907e229a28f1cea69ed9972b461087b3d2653c5ee691386b5b4d4f3fc37fb9f9dc967f25478934a3eff818da36ab3c6d825d00247c6edd1be117e7275802517ebf10d1f1951dc010ad863ce233fe51a9969ea9dd10bb3b43af1b531a7aa29c2a8ed4bde8ccaa5fb9b0a4278e17e7c13710aa5512055f97b9b86583f76baf5cdf2a2edee92ca5190feb2f15c7b5038d2dda04c221ad0625695cbcd49f92cb82c39f1ab246a6fae161907994341d3b4c506eda1cabdf3181532bb93fb0378c43276937a3fdc1198f60ba86cb7d4fc416e42e5e295fd75fbba36c7ea773d116ab3ddb87dc0d0c88080db8b42f0e1976a3d72aea763d6ba40319c0d08c53d566299bf6844c4a505ffe42dddcbd1eea62939b77dd4995bf231c5127f2f51bf08dbb21f7942867fb56b1a40bc89be7710776ad64ec877ae30bb0e9295dbe2166bfa122a2b45f203fab335f5b8383d0a6d006dbcc8ef2455ff4aef37028e1c8fda9e93b8975b2db08808604a016b2882c7216a77874255c75e52557ae23e564a38a504db69425342dbf44693b2686c74b593c4a83e97d43ac41e756623945e9333ffcb3c7361808e3049f5f1a9aa702b57dc8b61a38ae5f76206b926461788bca2339376c306555995817867d61739ea4d74e7eb0c42b1a3c95326949b8862e9a06e2031706d3e5d6106219db467bcc798eecac404152030a2154abb6276c693c45406f8bc98cac5afde05141add2253b22df0dd27d6caca222a982fff18143ca47885c5b7b1b06f43be7aa746633d14fd2368b68382b321726626112329ba1ef9969b861e5fbb03f119c54794b771e684ee2c4f90b780e0e7a3bee67b91d54079cef8497d36426eba88a39c46ac895f08cca1a409c04dd902425bc944622937b7ce90cbfd6c409fd66db95c136067677ece432c8b19621a6d09b91cd1de7b6e406a85217cede9eda79f1a8d461c1af7baff005e4dec0e281e508734c1b05df2f3dded796e46126aa1901b34b9675efe3a75d32a2386a5080b4d5fe48269caaddaf4e5ffda137ccbf3d8b5a09fda31e09c7ec98fac653d7f890a2533a84537e14478b93efb0b846c647f0e1ccfbf5911c29ee23bcb23dd0b6a190e5948f2432860e388a956eb9b824b70f850c241461bb79f139e4b70391609d01af194be19e01c2b728fbc19c7beca0e85c9a5335bcbd583057b29d79c81706a1c1987649deb345095e133624134698d983308a46a953a3790560bd05cbe7509ce6b4d78b6378b4f2eb744db79eceda5e7aa861a00b7eb2dcf548526e8c2be170f5cf925136910b48d3b65ceb803527fc4e55c5ef76190542537e679c2ae4889b3c7c65b775d51fb29ff653fab074a2e1b13894520fab86512a4234ff76e98ebe2d00fb479e8bb012665c64ebd9f29bf19c9e5639151511f3f3ac04540acc74d4a7388d61141e95e2e8765946388637aba74a276f24efa97b027f3a584b1087cace688917b90f0270a3d599a7c745cc6bd9c7c94bdb98106979ca7f662f252cde70548231c7c4dbb013e1b1bdbd1895dbbef582b9564b1b806964a44bdbc532e3384be21b096aeda8746790df74a4c0fb708c32b005d5e1eb7dd64d7fdde91e6efd1bbbc5359cdaec8d829d3d017de53e168a3140ab12d1734cb3d28fbad442b88991d5691d68288ff3c3615789cd2181fadea447fac3b27b1795148856527c5ac1262c3181e191a2a1c841cb4cefd03e479a0e37107f831638c052a43487b1042d31e6bd6e6e66dfd1e0140d5f5624313dcd0ad67e11e000c2880b88f532700a8c766ee0c114c7626e5c7de8faef8ecabeb51480c1fda86d9e65c3cf440aaa05884bf848a1e2efc0a9e5361f904663f8069d65a5434016602f23d5790b1b4499bb2bd1fd4f62bcbc2551eb758d2bffc482a1429d365328efb3c47225bab97f640391587978d1e9b4660c3af978a3f68e41ad70a7327189001b68c1a33c990da55b6e97c19dfe7cb700771564f1a8a97be1746872da4a92893d3e8dcf0993a7330c557146bc5754611e3f5ca011f4f94781a29faad3d552367a4966c918c7ddb3800f669cce5ec0652a3fb7298382808929e22b73eb5d6cd9180acb52ab7570f208299de971c01dec8153f9be0588f45ff3372745b5f44033ddd9eda764fefb6302419221aed806a984f627f05ff4f5aa1ae2786e748d6e0b34c0dcb205a47131f3e63fc0465e05c2ff329283e5b90912ed5bd3ee7fbf3609b800baa406b5eff177e0d390ebd68287bfa828fc3e8984ddec9ede91a5fd4bbd9379c6497f4f040cc519fb7df7e2ca1d286773474d9230f24efa97d6bf6fee5293ab7e3508c8f913ac30c8f177aab74c2861b00d0cdcad32f62466357cea311d1cbadfd6286de53f4bebcbe8aa168ee667900bfb088710549d8cd9ccbb013b66bd401e9ec0efc83943d300bf3f98c64ca7b34d77e8e05c98c0ca3ea3bb4bc70d51ea0d7c322c18270fc5d5e845369e296dad303ca933325f5a38d25dc24fe0e6bd04418376bbaaf486917409c7b8225ab2027f86f0e3233d86ae4003ce9adea50b6a026dc0971d1142ec3922b2ccae2076c42be72f227e22053fb53564416d800ac248fa6df6ba7a90b8bbdf6ba7276f15ee1463fbfcbbe51ad4396065f93df9655fbd8561ca5ac1916102bfb0b7a048fd3c41f4f60012db34da96ed5cd97c2fa335d31c18c67b661c2fca98cc6bca3572b0f2387a2d7b4153e81e289595ab804f7ccd69f8d9da1991494640238d4f238befb99db1bae5e5fec18d6b4fcc41d9b4aa7f47ca33fefaf12bcfc435635d5a93b68eb77ef85b821e3e32e7c81e3b429287d3dd021490f8d00876e86cca7cc19438e2f1fc1710224735d3bc2626d4f7fab3f9a7f900d87665314e9537e74462da4aea113b08a6009e0308a5d363fdf5c4f1a4a6d2076e9152b8b37d6a3a776266f86a31768f02590cae18d0ebdd6afe14ff01fe9cda831b262b0db9eea1ec36baa0b2e78382d17413a73d8066a64cb4d7a8f49b5dd72106ec51458169f226d31d3d8f5382f283274e4dce134f05b06fe2a706fe2d0cb5f9a30b05f4db6bc849ab5059ed2b7f3ba771a63199bb6cab511df312768da1c9f8a81ab300221224251fc43c33e9284cff309c3e1ea55ecab12f2235f6cfcacc8c2ff0cefddf47b949c210bee79c63d58300ba8247b9b6e50f7deae3ff34d38c42dffd85ec5e6a314fa3927e4ea750d404dbc735d390001006c1f89267f707e370fd565a71246625d57cf26c7701f70381b788507cb909e38b13fe8b448343b4e98dfb8fc7809fbbdbf077ec75f0b850004310f1a75bdfea3d013b256dde9b7c148aba9b38efdc102e4cf96704e6eeb16e52ab98d0346843c290fa3e61cd808f4389bc6cf4b7c54ffd7b95b8d442462c73910b82fbe5d03d42ae460abedf5273799e423516c9ed053ab2bd3f60d0039f83339939ac1910cc3db608d041e0e2cfc7d37cb4aab6093b38acb5c9d67cc4de91313748ff31e827b1a0236b3cbcb845dd9e5839509da51637677eb5d88bd6d541b5806d3a1109cb7fd70a5b8aaed43c7288cf593b3af5205fe579e834a10447225f5ea6470fa43ee377104ee9129a26360ff88ba3b0136b0cad1167627a245299cade88b4218a84ccf6407bc16dd2a59590acab354d47a9ecce270a2be1253cc87f4555d1c7947db6924ab2072287056753cda99b137755bfde9a1f7392d848e4ea4893626fe6c9e752c1d80529a1e8b915859d7b5563af562149309d5d4b549382a097f60dd2d004e6b4641eff304e74560193259103e8591597323256e415bef681e7569e9e74832600f91785861b6c729d3e4893f28a212ef9b67dfa3a526c51496c3689e7b27323790be6976a88ecef82f57feaca44c3717952798d002fec45da5629db0827e4ae52f520895e9460c24e98f3bb8b352072d759c039e1dfb4b959b0fc497827d1b026d3ae5f193f0c212f086c71688c8ebaec0c2b254ad2da8685e718e0ca9aee23f3cb99f8ca7bf2ba988f40dbe008d54d8b139f8e7e22c0f5d0d7a2d0b0bbbcff46d8ab7b2680363aa35e4103c9bf37e34c60a9acea8f927e5f39291767ae3cd11b8446828db090aaa2fd1cc4fd6d21c51dee740d8599246c533530a5e4d1b50d51b1800553480ba3e3238ff2cf91d40e415b8b2cba13ff6bec74f987287a65c06dc614749f1dd675e5ba66d3f71f9f6c41fffde2c18dea951b335ffdb3fe591159b35e027672d2a944d4ce60ab7d3f171c80f0ee728833c155d5019f669d08c6edb3e5053a8c879bd8998bedf040ec5357d81017abedb5ed0b5c2e66511001ae38aea5778eed801227e5267b485c9ebac5e7ae0327ce2d0e7f175d1979c1d6a246b650c498a2bcd0742d62fa00506d2514f7086fff6a1813452fcac7821d911340c0c035bdc868f32367e92c4ccf00e155cf3d1f04f21a9dee438cf2d2c576d885de14ca00bc0d6a21e197d845aa7344584b2664d8d20781fb7d469c180d50f27581c24025bfae043fec2be2d68f490b65083c0d820bf6c35e0c6cf98acaad99e7bb24ff565f932d3e607d91b5a03ce3ac8f01b39461ed101366f44ac05878ef16005a11f314fe5e58fb29ede46d242cb79e4831f5459468844ea5b2722c7421c68d487bc89fcf2038c71745d48b4086617b1af1c1f3e834dfb4b684fa3fd6c3587dfba0f567a4e4286081aff4c2c66edbace93d352fcd96a6381faeb7776ce4192ce014d9b1c7cc9b43d6ec8b12736d0524c555a384055e950bc6ea9fb36e3b915449384f486dbd9f92ff4788ca40314bce78bc6405d903fcd8d2c9964a27ad72b18be88f620315ced0038f4ac45f6b18ee0bb49c0e13d244fe9e3063294d6742e48ec7c01f7f1b3493fb5631d00f3ea18d23d1236a59f746727f257cd913b48acb8bdcee8985864f7e971941a94b3b65a8ab4ddbdaf182f604a67c03449b20732ffc5db5ff896a6aaff6eba435bbcc5c7cdde39625d020bc71011aab073e5fcf913f038a2adb595aa05e674f154969de75a453d6e6448703bcb311f9c72a2b52619d58765e3451a0db425f40dfd5621f4ba1ba5d0282786020e3d5e67e8165b06f47d165edd3b2bfcd9c1b2c2d4762fb373289669b5d84c1b4e48bc229a7dc39850808724272a09c7da140d268cd6c61afebb5c9fd7edc450de0a5eab239e806c1104f5d2f393086eddeae2aadf2703947f943692ebaa7493015415f8b108269dd8073da064f1d39bb83b990926af0b642026a2a003509ed0b419e6f897d6ab05c736e7dcfed93046c3552fb48e0aa90159175cb4b013f599939ac87529f1cce05ad7328b63c90c3f30f992db8313522b6e4d927acb5ccc88ece57917f8a41591961feb44598185ef2c93c43ba1de64f396c23e33b6fd1950174cd722b5bd5ff192e09c9cce03ab5fd733f53eabdde333184d1582c818a85dabd7c00fcaeadc850b0802d57d46f8f5747d75ac18d30db30c2e11b0688b710782461038fa390de7df59d81b4f5992eb201c0ec9d3c7d803a1f2ec29e21227cb14bcfbb8ab68a70c29390ec8cae9021793241bbf02f56bb914245cd87701f221cf85d68b7522202b69c65c5696c36bc7491cab290744d79049b7093d480e9aaa2b5ed38377b7f8ee7437084a9a936a3d6b59de2bb4dd125808e3d842a45907499560478501172acdda97368b3b439bd105fb5e7485cd6f064cda63fdad5ce660b3f7a80d8e4c6e99bfe0bcb728fc21ac775336a19df782861f675474d535fef3372db47c472ad2954ea9b95d06cd244a8ec66aafcbbb13bea7e5e63af6a141361eb96fc7124df52fbe60121aede058719f0bdcc2659f5105874744d800f0b6d3161d0c50275ab441d739c479be250852b31641b0ea1a74ab6651284d64ad4366c4e82d8e4f7141de1e0baa20a74a4e6f87977779551e8edfa5dcaca9e3876b25f8ea8a8d45c062169d7c63604a8d48260cc4078ef1b1e523bbcffc0ae46304de1f14d882b9b4de164e1cbbe50e782deaf5f9fdd634122fddf58875bb6136bcf2ade9aab82bc616ffcff6001b21ad3426c54db4416772a4ac27f05f7410dc7084de49fae1efbc5f884a4536f1d5e7c979dceb55955eab679dcf4124d96cfa4323804d3eb6cd87771b98d6851daf6ba4898a9a1057a5b6bd5f7dc076b6169eda943b29e431e084577ae286ace91323775c765c92f8a2d32c511bd5b7946c16301c240f69fc360fd2dd604f9ee0f51aee7a8651e0e4b69cbf790457aa9372133aeeaeb5467f4f7cad206bcb10f32ab1006fd2945e5eac4f02826fb1433ef9d05240b56ec4cc52c06a13be79de7fd27324fc60e81831e9caa7edbde46765718bbc6759539f06ca76d2d6adc80a43962ec5018f49e70e0cc27bfa6c746c89587727b4f64e17ac92b1b538aba797d01e624cf5464e3929d7190883fc5bfb231cfc1e4d407b984e6d481f9dfd1d49188c938005fae6537c8a1eb350ea86a96063aac9ba36384a3caff3c9362d0c442230e9b80fbe82bdbc0a00c6b20d2be59db3bcfde6cf64ce1822ef082987e0f77e093ba0581886b18803fbc2c629fb6f1acc02eaf2585ac588ac65af9f99da4fa1ccf54e5cb1bbe2d20c9bbf3e233d130c9e1402afd7d6a6c891544b152c87a0e90575b675480a8a6e0680988fb68e96188a81e2d90e09c358daf03d1b098685d41d95fb93e85aecb0a6976251652fe02c8b22a96080a0bf4a47043e1428c504415ef1246492b7a878667ccd2ae8358b5886b475a2f739d8d6ec7a313248bf6cd017f42a4822a421a2d70c9af275f44b228f90cbaf76b2706ce1a169d6b74d6abd92a29940db25f208f9d8ea7bae1308d86756bfa4605c716a14f2caa18835ce3ffa42eaf0af68b1d8a05230c83ed1f0a73e8ffed5b3ce88c7e472cf45703d82c9b695a90aca04f3aef26c0d04d816f31ee81813ff4852944e30a23d73211495576865d356591c657bc0db61778737b6a2074d12256512ef6cf36d8a5ceb21758c003002b88011331a06c178c6b0f87fa75db094a89de07e3c32bb56ff7f1ce944e354431d534e9acfc11c9c783e97f34e520972dda9a635cbaefb2af86fcdd48cf3f7942157d59ceef7441fb95b3c175d498a499ce8edba4451b5de82580afd175c9f23e7d1ea74c8be4ed3d74673f02b5ee42e96629c7b75557786a8ea2acffb20bf9448e03322d3bb75d1cce8c25fbf764b2cc4b19ccc5dd463f21c917cda7dc03e3025a1e26480f40b2eb16321dcd88a2c103aa7029d826b924087a0813835eff935fc23bb007d914022414a48db01f25cf84fde4fe687ccf039ac14be63c4ab6b7318e74b0234287e46e7eb6229a1ba6ae39bcf48705f964f850cce1accc7da486b22c422790749aa4bea4df54e5054010c4106365e52268968cc1bd0344dc54c32f4f893752151896b4a63da4a588c263ae984cfa647dbca8cd7ec009b300c996e84d39812dcc950ca5a2aef9a45b9077967eb6397d14ca7c45cb5653f2fe009943a60671d0e18f5078d29cf8deb85f5e48b519d7294b3c0e6c0a14c644d695d0a06f974c3c6dd7592df793bb063e6b5a8fbb9f9199f92e69339c954c0367301f5ed8e703a9fff84b3e13463c1127ec25b44dfecb589c7f8c01132e214c4ad92c22ac5fe8846d44d66cdbebaa3bebf0454a68fc146ef19d9d33d46e77c0844bbef1e109b56f50f489ed2f22f0362b279170bc019326aaf3166e92507d8d9942be80351b359b002bd92c6a7c40fb61308667a003ceb4e31794c3a6200d6ceb4850918120e674c27705f571c291766415c4ede7d583df3bdf2c9172b3b1ece528b1fb34aa2ed89b3bf78fd4451fb21548e2e376929a72b1069a08491f9e59c9a4f5c8566e18fcb1118fa8aa5a958c55beb3202bec0c8e71f2f2e290acd0648d3079d16d84b8dfefc5f89c62c275aa3f204eb0d3a1aebb20592aed1de4246f4a658ee0799761c33c54c58b1fbd50e75fff4c3efdc8a7ec2b462c7940ebe146aed5ac5a460ce2e832351cd1c792a716ae10b4af9b8911b8dee9d4a314e716bb8ed6a846896417fe48e012639df07df793049d4611d7ac23c7ba70e5cd2d48cf66eee2fb25aff7de28871f6142eaf44d9ddb37f6ebf082a04cfb4ffd2fc9bb114fa3db5a2647732a1ba5ee9a7595b24a1c03bf406efc76c923bc1994c51417243230f9ae94083afa66e30cc594cb64b995425b77283fc41ca56837fc8388dd542af74fc50cf54957fec4d776c14234651a8a11ad50a4f71800a644466aaa9037aa6b64140ff2520aa23a7f8b897fc4e3dbf53cf92ccc3ef27255a2a530a25e5793187a050185e5249739d15faadcbbdb73082b5741cc17f1f51cd3a7dc7810956b2e12c48a3e42c860548516d5423d29a992c2038f0b8b9c44237d4eb29f1091a6b3e539c1a72a970275a9122bb4b0d0ad9401adaa8220a2a30bc22639f3b0992992254bfdcc8c20b8d81ce2b448713204a41cf74015118c86a26fca5ac03277cc627c658753656dc712a1d80dd4ff799bb28ac47ebe0663c82ea57b16e154fc4c37a9f64e1409a86f3471cd20d8ed41f640486b7ffd2742f669d79a9350b99ec1664700d1c930ca5ca9229e85b028882d4904b865ca01ca655c718dedce758858f7c94d138ee0edb2b7b41a3356876ed146af715bfeef421c3f8bdd85d1049edfa5fb56f46582012a6b25375052a421364b4a1f571715f8c38c28431c4ee00b401ca52292fdd92137713d131b9ebc79c87577d2942e1e951b15b1cc74ab1ce54547cced7049a7f72c1cff0fd279e23a393c075ff553ae128545af7907e7931b873c81d59cf45a1555cad2a8859a9eb451c9b9315dd1e14db87397bfd853710eb09e57a48dead19143a91f68bc9d257c7606ce1b6971e121a50ac519ca34cc4ee033ae861d9beff88a2615d4d115cc1b73f87fc12188a5e83459dfdce0889d4af04bd873ffd9ecbb49bd51e9c869a122c18f833286ce447d569c909562cdc3649ea8eba562be2d014b0411f05a9a23f9632c69e3e2f409304b1b2df41b1b07254221187ecf4e4bbb8725e3d845f4d44623f05d6e92670862c878baebe18ad1202a7bf06bac2c49cf5d8480af7bc331469996f2879e79e5a7ab6ef314e6d002f898f2d0c7b2d8ac2dd4c979691444aa09123840516f47208d959b09e7a241d54001248e6d120e614eafd65c0bebf2e4250359051472e369ad0397f8106e9b7c8b235ac597c5bc84741751820fe184636a5ec7960dab78cb7be8bcf66c66cbebc39969500ae50534d2736219e743eb4be53f34947d74949dc6ba5598a215806748dfc2d46328c9425c9a6842dbd11e7a1e72d53344a6163224ec6535c88cfc6e5d52618f18e5b825b25143033c86dabc85b0c0a49fbc09b4d1d4edeaeb511637a553ce9a1185c0c2e08b9579c75c16dba930bc9b509f7396553a06563c2760dff9f44fca7240af248f1839e8f99e517720e0bed46c76e608e6ef9fa28650dfbf4876b57fc28ab66ffbbbdc3acb94f6c78ff15e059658ea55c465e30503244bb5e0c4f2493b239171439d8d16ff1122d82ba1e8a1ab860a2cd352b3160d1ccfd8338333705e575ceb2089cc62f9a282486d1472f7159d74fb985a2d018ab6a8e20c05a400138a0e77f54c89d0c03031f1c3555e514792907d583ad52a5c36f9be5447c1bb8c6cb5b65d1d96729c88227f3d249ee6c0eb6e57b109ea74fb266739ccb7e7e40319511228873261b6c06d577fe73f4bfbb0914586b2c09de4ada1f577d021b05048e2f1064e2022ea0dee90dbd1c31fff3c1c2cfd1f2ebbe38bad2c3e139df1183568c3603d822b205d846b6aa939510c40173bcb5d1b0a0834d4f309524c5fa754e2bf87726d3629955cf196b3bf3310ed4149ca3ef1afff7895207d9fbf5bc14ee3ba7d2e2ba6e6b76a4de836f1c3609dab75c345d476fe3856248ba85b8d89143a0cf2a2e99e5d33085d6710994d99af44fc81c85f2bb2dd83b7350d95e3a480548af136ab3e7a55712ec23e6495c93d180d969c1e694c3b46484a19174cb9bdf4f227633a42076a34d769f6a342bdfeb0f2cfdb2836bb4a0f52702bf38f4846a22c44eb2c4d3ddeb3fa45ef2ac595380d7403a46c119e6d032da5e089dafa5d6fa3020ce67b8a6c94252a3a52bc95e4cf1b6c3423fc6f3a3140309d97d4f15a4fe28fb89b50666597c779da42c5a39ff6f15428113c8f8d0818c1acadc2d654ede85b9c427230bd43bf015a5ec99b4174f6e439903cca611724b4c01e64836237e614470b128c3a56083b29a7b2bc2fda203e9fab1a02e538124b9e990e0a3c3ff78a7666dbb01c151e85f092c8847e2dfd0f80dd1bc684ed3da51c4738039bf3d4ce41b885f062ac9fc28df0238b1fb691eed84ad6ecdd61417cc3ae4d63a51149298cdb6bc1e9a3d40cb3d9d7bc248aa9d20e2f2c2b79b54f9d502bc0878827af22ed6adb84a17b9cf87f49d300f585d925e3714c57db08821168d799e25b51a2ffadaa9290f1ae34a4d57fab267c3cceeceb4b9b8fa9336bea9b1c192f55dbc9ad4c8811b60a898381f93d3d0f641ec8c433a90a12085da4c2e546c96612d21bcbf1f5cad4409ade79e1b68d6900046cb4488cf95d8ba221be6f89bbd747e8dba10dc26c607b87ae18ffdef6fc02d6550f00c9a211b7026856f38521314612bb190daad5e674292d8fa7a1569828b4c0b720488a9667d570e5facc6be5c05defd198dc6d4ba5ca872827df402b2b62e14f2cdad446f1a3dd767c7f2ce109a252bdfaffb4323ed46f1673e1bd18878d7814904f0545895a70654c9fb7fef6ca6d58e74ed4903b822a4773e12466226f07f5ce52dce0abed4a8368034e5f71443e6048a7b2b92073e3a1c890da0b8e836e684980b9166de80db8088237c964cb369304f2005fa401e4c69c041656a2fdcb85e41a1a40af35af069a1a10c9074ca26db6dbbc6ebc6eb8207a9d811c2b9bc5fc05500ac19be2124be59bc8ed9656922efa2b8444f4365a25436955056b9a8c701789dfe3f1a662830bdcf75f63fed2dd4e43b17ce01ba24959b378a2252d4d4011147fa9996c279baeb64d07bc834fd5372e7e6690429d63f1bfaee861607430ba096444fc92edfa3e19dfd5f71cdf18e9d2516d978fbf06d67bc10e6fb041ce196bd57c85b22716e2d999d62ba610c88b785f2e097b768bb170f0c404dd7d06168c5274ceb6f675693afad8ed768108ada0bfdb2a30bd233a49ae9a147f27a138abb8f76c8e88a10e9d225e26b19208cc853b18efdafb2994e974825f3b2c22cd45a6ed955983fb9d347c2dbdd3ea74ce55b5f5c69234ad1e8a73cb063bbc3693a75055db3ffeaf6f7e9985f55a507c68c1191aee81905f6a1356b24ee68af974c6c192ed7dc8ab9394fba2c4ae4e3a3a6ef49a461ed1c0df87a2c57b4d56b38880848326d63ff08ba6a914fb520f5c5996625f30e33816babaa6c47b313b59f5875d54a5205aa023b0d57e53c4e8cff2bc1677b891270a3eed4f2c39fd43b95879aae7fbd785b94a33a5e45f7387affcb01a8a59b5954eb03a0d1767aa1cf090b9c7041b65fcdc6e311b0f721006351d06682f0404ddfc12e4bb4b84c07484e8950feda350c7eb0138942e62726a420bcdda3e9476517be6a19d368589caca97dadcee1f8a8cc66fb421fc85bfb0412ef4ce8fe257cca4b6d4c35ab4b9db4d2049553dd61dfb218a77f21eb6fb908c1532c8044da73d644c550db61fef930644f1c70b9e1fb4496b19dce11cae7a00f4239b0a74fb748ce8d0fc8213f2656ad614938860365870570f28df0eab9b0d0dfa72b079e470c885cfb887c65d26d10ed20abe094f544e2800df227c3570da5a569ee6f6561462794c720199cc9a08b1d96c313ff8b9fe8f1fef84b330d955470cb95ba8f38679be0eb1e132cb93d393625e0225f8c8a6d8915e188fc8daeb30417a5cfff0fb793803d05c932aebb26b81df3bceb5cdc0d4d8429494fcf74c8e80ebfefc53e1cdd50117a1b7be324075490ce81ed16bc549ec9e8e5210d6d1a6d295b030da3f8dfda9f7b9e634bab5f5ab3f7737c82373f82230873a4e0462b9ad1ca1824762ac2f00ba2ba0e135ebce7df0d29ae2c5d37d0962a282d1ff03d19bc59935dc1a47e91d81c19cbcd8ed765b4e470672bb7da2a7a04842181bb92d123cb4771e7f99caab264cc34da984aa6e96fe5f29bb681d7a441958c51a08e4202975579e8ef58a5c311b162acf1ee08a5fa474b8167a3955e0e82656b8b057b65f2e19f3f9f648c9aad26394fe817bcf9991908f4c78027f36dc082df54c857fe01cd702e7e26f8dac1934da9b705832482cec8a4a1d274a6837f1f99633bd7b7b4ff00c6185fc5aa4d695ef3b8ca7cf877e016951c4411bcba264fd2dbaa0ebfd95ddfa6258423e023a14419c0b65d8a7e59c1b46d3460bed0b305ad24e455ca4c7a1193cc82c6b20e5181c7fc2e445b39673df5abf9783df497fa38105d30b61fc6b3047eb341faf0914615c2792742ad8231bbdeee03c48b400951e200df631e2c371030a7aa8b0ca4f934a686c42cd809905416e07c7849f2ef1a5c7486dd47d38f8a41e791288823d5dc1756f6d0712580120e63e8ceb56f1ca2dfbe2dcb675dc8446d565670f8aff53b360e4276e0bb32ff70135a0667c8f45000a9c99ae47fcbff445ace1c591db2709464aa931596142eff7afaedb480f86e422d91fad661285dbdc584ca70f2fdddadd3963efb4bbd7aea87e976d4e350bf9b2461e4f8316f22029c7efceab04adc5b66ea622795bd2255c030b7aa229053cae805e83a1c04acf391a2b50f6f636dc96086a128d02c292e6885e711d6506eb6cfbf3c89a19b03d2d23945baf29bceb6188f60d372ee609ab459e2898ee7d8aa948e07224186c42222c296a5bf48af20975e6c7224f5fe2f5d501fded209535f9055321c52c89c6601e2b2aea056e0bd62bb13701c8c9af2bd5f0fed4c9d8aa75b6cffb5c86cd163be8dde004d545db6c5aaec9841cbdc8b1bb40719db2d3efafffafba282264013e333ae1e04cca91c9226494debcb4a5acb13535c09d98f84b5e39f29928573221b9e620ab19051d1272ee9613529c5414b7381bf93468211d57e5b63c62a548adbc0243f1465819d2053f11bbe9efa438f444d832bd83bd9e84db175e9e2e8ca633cf4409732846b0b432372a7a7812f27ed1941ae3dd49665bb3baed6c51e9853667fd65c95a92c31ea5c712a3be90399adb18cae4ef1ca1630aaf0dc0de509273424a1868963efdd08f5bda3b2a66c547db60d249c64ce181b099bf1e4fed13382a8eb3a629f36662f6b5cb345ab5221b0579557376a51a4e4b1030b41ac4085d298fbf4e3ebf59c8f3e0f3f3e17a853719a81869331060dd9ac2ba4196017136368451261672a208de6d5d367023a582420e340ee6c0b7d45309a7cc58f901e27db43cb024accbf4a6680eb97d3e3174fe3cc0c6f71f2cbe0af2fc22c724fdee8a9812ccf6795e80d471eafc19c064ceff6d0f14e15c5f784f85d3e33becf0dca81c9812dd6e52f38bb16167b91d2bbd96e64100e81fec885838726b1bc0fdd70251441e281d2144e9b9400dbb177ce49011ab015a3be700771b92caa19980a9d2d49c004a543a1ff09c2752e4747b4439f4e714ff25ca9b09a82deb2ce6d59135f6c245578773374361bd613df8d218abfb3f4af377d1a4ec9037d302975947fa10e083738e5bf9076d76a522751085d07cee7ac6fef89e33e2353b485311224924ca136fcc0d304b4477264717d20edf854f2689430a7de4c0934e0384f66492d6bf90aceaa44958363f88d7fe3da0868f9405ba7f0348ef8a9d235b71d22fb6721de1d306ae92dbafd8c59d78c14f1ad9fbf843f28ef625254c62959f95554af093ad167190ebbf4faf201b24a566e5f3dc07ebe20ac9e53c568ba42edcd38c0aaadd8f72f9b8a31f22ad09d8b6259f86397ed8963d0e0af1060002d83ce25e0b499b44eda7ef213ae34c778f51a937056202cd3851fa74e9aca7719b7cab87434f352b33eb7dcfd3355445db6ab10e0344acaf7097cf99388d1b66517009d5d31fa3fb059783ddef770279f347fe4704e582b127f18f9823dba699cde41e2f5b9998df22d8be128e2f4ccc4c20a36317640b65e6c7ed5cfdc48950c8c6aad551078f8456d5346355ffec2d3b23eb435646bb5b48e0978a9369598d55e15c2ad0df96ce58303144adf76a5135866e444eaf7cb334c79d865478b3fe98828b738e16ed0eaa5e8970bb19ef26746f826bd6fd57a5f00bd120f4278595074ae076af7566a34e1d26a369fcdd159a3065a04a19f57e9962571b4f26da78644ab6dd47448c3e251b566a3bc30e5f2f1488e9c0bf040e31601e4936a8670874897b157822e6b2a9ab42cdb2cc319b5a56634638c7544879c6942eb88d2b24eb0a5b7e8a2d5fedc4650ad329a38a7c7f3d3ea7a5c8376aea829d5cc9839b1aa306cfeda577ae35d4f03321f8d9bea870750d633e987e03bca0e6d1c48692a2a9a444e0ccf95f6bb83b32cec3d9717d2d00a3fdad185ca972f16855ee9b4acded963fc52aabc9c63bde035cb407e0e372c0cbb415ac0d42663c59850382ab551d2cc08fc6c60e7f2afa4a05de350c5a5a697301883cd37d9ffe042dc7a062b82a9a32c24bda5891b8648e4fc176adb3a5bd4fee4bdb287d181321d04baee086b352e0bafbf7197f4c314a8920ab4810d672b26e156019e786f7f51c3f57e1ea448e6b54899abac72db775f2f9d68ab627886db7a69a9ec8d021cada8b589fe781374cc31f3e4f3d5e389f3140a0c41c31916432df9ac7abfdf6a333f567240aa272548f9e7285b25d6739f91a75922656445b6c1d1e472d21834a49a7d11536db2d569708c79beb7c2941b44af048525f92abbf6893ba8f97fabe93a51e33337437503885495834fd01c0a64b888f261f499b6af13ebf3bbfb70d63f0d0147ac8268f062b5bb7e1dcf49c9e29ae04f070d848cb9bb73b93bd7c6e21efbe8d4b390506c21362e6b953e463a40de19d3b53a2aedc20f3543bbf32915b8b4fcb8a05d9982aa5361f93f9d2922ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
