<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"beea6f4940569218b36d3f7a22cbd505490c5824dcc81b15e54b32fbfe43b478a48b97d60522bf0adf70e80dc17b47fb37cb707501de53f3e236c61e93f6f791187096ba718a43484fbe3fbf419a4b8797baa99d43d718d31c58c6194023999a63edb4465784b35bf58681918655e5ff58dabeae90ed765a6d28e3403ca7b78d941eda6f44105eabdd783c26cfdf6e2641363fea5390d40ea53dcabe4dc95920c003c8af9d9a9403377d675c358f2c5d9562d293f1ef95d6a531e7f2a285ac00dc5760608f3524c70b3590fe2988851117d013e4520c6c2d44cf1f03195a1be7ad3824d159ce8bcd6b1f3b81dd705378296fa6eadb8b5acf9b9a2677c43fa4a05cd8172b8e7c4623baafa9f2adef6e1132c3b68b2c2e1468b580512c815ab6ba204e6cfbb78a3676efa2dce2a268bc5a8590b388f45921c1c4774f5b23d9889a75fc3230cd79df7a92bdd2d230af1e27bbc79d634c0e48a8dfbf3e09f9aa39a1c53ed526aa726b8bddca90c6e7624e172ea20eda1539cb4d81415ed793ccadf1470adefe495abac9d07409fb64756bccfa9b5b861972e2175cdd9736753cf48f5f69797e782e324fd25dba301eed72b1719df552b150f73b420d80917d9a1e525808a49e671366a82ac905ade91c36e7a71c385d24f3266dd2c4260551ec18dca2edbb76fe8c9b4468e908ca3a493ffb5a9192dfe491afbd351581a761d290c996672332a8435b62e01cc46269bc1285b33b94bef227bf4ce2dbbbada47de2c47045100b0fddb0c5a863a9208acae349fe397586416bab085094e8fb9fd157acf721bd2a56981e375e72ed5f16a44823e3af64578b12b3192dfe6a66c8da23d638d0aa8773665968cf98c6e2da8c6508224b983451431fde184ca568725dd8344f60c5e5ab19a722ad06803e5e82c10682615535cd795c841796a379818e64a81eb759ecfb54074a38778dc50c7a2bb772d284ae59d533ffe01a8a232ed048981cd9fe933bf898acdb19b8933f257bffe52be886b54ed0abb93d2c9f8e2903d9b1c045e33ff95805d3ff502a61b71a011f1856f8b14933d48a3e66a34ff781b598c63f90d7b3652ab9a05176d489a08ae38aea20bb30df8202e4087b22bdb6634edc9d05f36c524c917a16aed261b6d5e90523113a1458da30db8df51ffcae9fac22a6c7bb5db5619d152fed3ec02bb273c9317061600ae127204aba93126c22784368e459998dd68426aea0b9fb8985b5f2bac15665fc3fca690a5646fb079141ad5a24ed621703c56605502fb11ab703ea99c78f0f222e502407e34f33c79906f29fd4c5872df69890a9e753cd9340e7e8238dda888302372e0ae79a5873c9ff0f729030c47f025cd9aaa2655c0d2689f5f748ae4cfc1700c4413a89d54a37cfe6952fb09f78bef7c134544cd96d08f668e349a2d848b34a6104383eab6044b7acceb02d3eff6c5fddcc7664ab0b2ba7369690a6f0069034d9d3aca4a9cef9981c571c4bdd180c12f4080bddbcf0b3a285198490d653a4b6f49d23d6faed1cfaca9c925f5ad78e98d44943304e72aabb83e835fe2871aa6697712d286c3c82cc559974838065cbb04ca17822ca5751ad587c37ee222774d80788ae18fec2d920b6db59144c9f377d0e59f1395b8fbf240eb9c8ada39a3a6a9f7af5aa14ba71f24d41433ca49809ab3d8cceb4cc5241cdca2323c311dd33f68b305b47aa949ce36cba2c96335ba6243c446b52081ceb6826e34685764ac67180696c1890d389dd474f6effc881a1c5b5533d4fbf153b21305538f2d28996e802a07a593677cab705272961cc13b42d296d41698dd533368b4fcbcbcbe1c22c27841c6ee40db17f568d80903fcf3c5bf95637672267f53277d1a34e6b6ed662b93653882357c59226d9f4a6e437f6ba2c1de14322b025c792ae9d0811746366c85d889d7b9b873c44dcea5f3095189cd1c24510e833d2d8b7488d0a19a56943dc886046147a6d26c9a16ca256d3ec75979d7e31ca6ad99d95ed8ccc7c7820ba2aaacb407eb6f398c6386bccc18b5f00502ef9728e0f136457271292f496f0473095739a762b7add52bca9ecddfc2fa1883ae1c446bf3bceb22288d3fdd0d877e77d114e3aab9e5d981408cfb087ad7eaf3c7dace2fdd8804020b62037c116a61dd72a306ab6d3c21af9f8d2daa8850c740f84de065aa6f82e69ea328f3fb7f5d356d6508069a464f054a463c8cbf1b1096399fd46071a33a4fb07dff0c25efc780db32d0349bfa7b5b47fb0725b819b8a2331f0ea37aa004aa84724089d6385dc35ab0c7e44b1651b98032ff837b7f4f86ca945897f69c68189a06cbb338e9d395699c570ac636d0b9b0334059a428ea6b493b936a9373a19e7d60fe28cc3906e23a540b959722e81d927dea2eb12f001592c1b91d0de8ec2438cccca098da024be2b54f66ef81c58efaff7fa17db4f876389b98a27aeab640f8297a14db3fcf2547c325c557b27735bb8df16f98f00d687a9c7a85deb3b674c6d26624a6ceea8bc497dadf3f1ab66ca0b977bd716ce7aafa67fef2cf025f8f9a92162468458f71f40bcfb6909431e5e5f5123d6340dd689eac115bc4de86df96d47bc636751bced8a3200b1456bb547c3455ce596e2252b68049e50ecacf6ad5b88206a5f46b91f14d1d6f13b9bed4b418f8aab7b72600f628c45f32d7efc9676f0fb0750e3ed1121d8367121ae879735cf630230ea0d0472818bd587c1e2c9331cfc33d9652c3da7546c6b1bfc40ffdd8aeb89c2ff61388a8408bc691b6366a0ce54be2f3c9e3e0068249ef9ef02a35050dbe0a5ba496273d2adaaeb01fd0acda428a4ea8788686874ec37da73e5ad6b77a67089dc8c6641380ec4bb251167ebaeccb68022818f296bc8d53e80fd4dd638b2d3cf36a218a20bded5330ebe1370cdd3aaddddebc05c0a4f4cf606e092e6d1db0917830540b681c8bc98c587ec785df6157b8c46a44f6a16f9919a450b67140e33f21fb50bef9ec0e6f12d49ee2e40b594c715d2c0772940dd70092f6883a8f1ec4d02a6d1f13dcbdd20a796781cac92a672dc3b90d006f836f4217624a43d0436c7a80e65f676bd824590104888f66a7ca6aaa74dd2a7c3e4268e56355991b509ff4d18966656ebc476f2ff8a0b8b170728de3b41dd40ad7a6d78c05f3d23ac162d282b3df2bb7ce100a9719c6f2f8e255c020832dc6151adec4d5830acd84e24fe09d362c6aef873549410d83aae0a5ca7c298f7c4fd562ffb608d22810289790d3d669a3bd56ac48c8a0f9588f5b9d0256ac4654abc41f5786abfcb9c876f4eb01e4ce070a7cd33d75e02861efd7871f2013d4660bc7f67e0bfe1b3718671326ffbffaa5888db71c60724c759bd3747829a393cb960ed0c7ec425d64f4b067c1f573ad0490cc577fad028289a7d300222aeb8fe7aaf9e64f6c2e66e510bd183979acb78d521ba11a7829bac60306e5f6fb648619a6e40b91143aff31e1a3dc9bb0d7e40a0c93a80605450b173bb4d19ba6bb6fa294bea77c6eef9975338e368a9682dc4a9cddd86e9569e3df6e5841022ec1699063dc59681fd8640951d72a479ff74987c676107915701b78c04c10b3aadddfb27ab552e6afa6006431435765f8cacbd1e2b9a8bd455f68dcc801612fc9149257f09929b323edefa3137ea12b4bc23a8d3b794f9117e4d25fd4d9a0e087c8b662f4d04101202689a6db493d7cd1f104ffad4ae507adf94c3cfa9ea854de0cc9edaef9a3022620f7012da5cd06a80e6378bbb90225053b15c8aaeffb0569f1db9d397facb35aefa85aca63068cad79567687aebf27cebd655a9f142acf3eebb43b752e87cc46a7078d13bc2195695f9921f4c8d7c31eeb051cf79386c74dc10ac0886551c55e41be7b6b9160afc558eb9ae560b53dc6b1039fe5df758f7fda29a7456124b17c5a5ee6f7d84b7c5c70119c155cfe305ed6943e1328b3ae6adca72c6a14b907c8ae4fe0bd15d455b2d6edb3d0d19cc83a903516bfe2c8cab52097f82ba072ebd4515d4cb0f2f3c6f40203039252de5417273d2600b8d5ffa572b9b02dfbdaa0fa483ff194d1b806c164a81ff74f81d3e296c7b55822046bed62fec7e9a0dc49796c7ed67b0c9024571e406363ea34a237ce1d3c93971a9d47643dab56776aa726b6213820d25cb6f989a44984dc413df992ad740e763e0bd6fd09ee6ab5de1a82fe2d5a72d99bcedc0137f1fe1b581969a4eb1522a246bc2d12c710c7130c5b2becc94d64bc0342b5cde5bbf55cd49228a81b144e61e490a788ea09c82326d57948630a77c1748da673485fa94dda581776ecdd040b6c503d99ae266f0ce540c273143ec72ae788c3b3d415d611928e1f77c757ecbaaccaa8a63edb54bbcf54ea0161018b4e54e17309236b160c490bb9c27761340bb56095946f44a994d4837cfd3f5a68e72d07bc004006a7446988b503880c6aba252161ec95a0df5b9bb1d36214481fa348c37275a63c40f75782434c4119b3065bd6bd81c2dc1ba6f47cbb0b0477ee55e5749dee580cb8f54944d93e4534426e3ee2a48f2fc77e1e47faeabc86f18d6498aa5178d215ea03c165c6fd84e7c375f9b8a4353c19b5845e26d245f3b00086d9a34bbdf088a5c9974b66a27424dde25991203078a722c1aec9ee14ecdadde2956630333a016f3ceacfc35f60fbded4be7b01798f78186c1397ac15ef6dde81b4ad9cd219e60811bf3ca75abdaa338426d152d832d849c3b1148c37df5112897a5ad79697466be3a08f9d247a5c73ee50dfb5426a04cb42f122654c59f9bea4c8acf8e390ab08076b036faa1c3dfcd2726a949437efaf93ed86b72a964a96dd7e6963865300deee4702096d1dfea32c91799844afa3e2a2efb489420add1b847ea207f2a4c0b4a6d40e47cc1e0e2551ebf1ae16c6cec7ad5b48ad6085fc1796ea63573c0cff3f76a48112bbab5c414b9d412ed6c76ae1118c4f53147bd4a125f390d87ecf5f5da92c51d1b4f7c27a18720e186556115d3c6326ae31545fd23a236b83d144158a37d5fce6d26804967b308fe33d79cb01562377f16db3f33bc18b8db91e746a96d273971024bb6446da6f71c367ce3a43be24f48f5b1f9b28807798a95c8986f904cf00d6b8e95ada4b6fa9a526638ce89d98549bf8151b4bf94aa4b23df309daf7ee53ee7e07f82e7d15751fa56f1446f377a3dfbff878af8719a6ddbcc180520d89a96ac0f924bfe9e7140eab31612398b2df321e8e26259ac2313282523bd9491929a696c388caa9b9cc782c669429f88d5e5db3c7eb2e5f133d0734a2da624152d0cd3b4b6fc898801832ed26231270ddbe56db246d8d2a47fa5aca797246c8e2018e34c5e5dea140cf7ddc2c7751131e5dda37e8bd194d2b1a5ba6717a813a02b94c1ef55ecae8bf4417a3171c4aeb00b1a58e3dbc28ccac37b9981554165e2acd750e5a158f6a71c79fbb81831db8957e8613f7044f9d4bc28a25e0c1b90168cfba7f6219ba91f95ea92a3d5c1922041622fe8c2f3beb9108eaacdd63724f445aaa624e4d4b8ad25efd1a2656151bd0b051a74d6a174fe005d0900358a951a1aa9b30790f217620cbc2f70132eb445ec18b3461f53c859a7caa30e173409a3ee4675b4d61d42574ac75939a38d1c6cef775cf3d7321d7ca7586061deb7317519dfbad22e0373c0ce8bc58a7bf536ba69e3a2ade019b909ef69a4c363da643c83ce2d4f4daa7c08d00696e17ad0bd9532b95eb085550b0d5b63e390abfa28a8f1aa5becfb6d4b3299f9986b75d01993d34cf474452ffdb97eddccc126308fddce9c52dc477f1a0bfa36fa77db8b989b8f7f120bd58a419f880a370b3dfbb0ed8899c180287ea3f66ffbcca72bbc52a11fb3db81d2c421e4974e29588455fbfcc716ffe95ac24661b6acd600d62a3fe498497b37529ede9613866a31cd0c9b9b622557b95f1f04c6be7d15b217154ce4fc46ea91252d20d27964d2910b3d140365d3ecd79cc25f04fc0d7b58175f2e83c4431ba4bac8b166895af09fe30b2cc1e07bdf743cb5de53c1843abca8831670e23067bf1476598d6af3dd07f40d6162c4c07fb872f760e97eccacee0a561ac5fb0facc99901850c22cb070fe6d235dd7612d7125ba39fb27a79d02b498853aea2aa9d32e3d2ee84157f34cd1814b8b036d6a900b41c8876c0444e7f5807b67fb45a314e5365d5ae6e3fd3f0ab5f7dbeecc049a333610c3f2f9520432caf4dad6eec4f0dcc27a1c0aa60d57c60682e05af7d4ea04b31043350f63569622394bd8589091e2acac12c84469bf508a559036ac6f77d3b0169a22e0039632362b855557159c1d59184b4aa50667164e51f43b472c0c94140ab7a0df9f786ce416ba715d8a0ddc3be3c5fb65179833a233b999b5652678b71fca1b56681b2f477d110c9bf9cd0f9e0fe8e2013a47c34adf469419de5b11ecb61a89a98b38cc0dcc2505fb0c89bd113abc92c65d36d10eb17fd8217e54eec34d4c32dbae8b4f414721f3ee4a37d0b043428e79adfc9581587695d20497278af50a3bd2a6e742829de2f4a22175f75d49ce468feb3d271ea70aa82dc284b4526f89bea5ee4b75cc48ddea027f642b0bb72fbc26cf08a0481ee818f71d64087e23f596c69f80650f133d56c008abfccfdcac9aeb290387e9042557d4224f1024a2c870f9bc97e705c6ffd01c6e15714acc8214095931d1ee8ff62ab87a0c11c6f00704177b4c6d154adce21272fa649ef48ff36b411b7bb05b8eb01e2e0d3223cc852e93ea3611d3d735edc4214182307f946646f155e3a03545dd288b022a0eefb64197eceb4da79bb747c1253806414da54f4762b2094e52d23b87d7171d2aa87d1004d35132272199851462ee8a2af0e9929120e77d31b499d7e06d8fffbb0143b6f9bc67761bcf0f530ce6d42b53f7ea8cad016d7ab0ffdc3298b6c3b0fe391c783a25778e5b0e095f4064ce00d5a8d75eed51bd5f054baa3d26e41d73a581a4843657e79501493e619678eb790d7068ae2cda3c6e6c44c5daf8dc59e580263da889ea160a96d439f307b5517ea713680abd0e9aa3e5cca0f52aa8fd3c6f93d08aa817f29f5c9c02d0cb3e659539b8940a9b685dc810b7b2af7ab51a7295f21c9697eaf10afd5b0a0ef304031e754cccfc004a765a4e6d36319bda58edfc39a69edc14738b0bb821a779f3162b40450b6af7cfb285392f0e47c2b44bf5bdcb1a00d2b7e697b5553b9a472d74d74df88b6a054b93df8d49b253efe696c040d5a84426aca6e9c7d28e8f2add79fc5028fa1830d89e61d934fbc4e652115b892c89de833d1c107f63e33167fa75d60c67eab0512339ef16c96cb8c3f937352d3e3e12a48a238b17785a1b7e51c7fd76e7ee06ed3277bf011414f0e83efa9397747a6d5026c946305b7b5e9a3050258d4e1a9674760e4a4dd818f2970c942c80f4ed9271000630955e25434849f5caebb7bc0ebd9df2301f2f6129ad4540cb8f07d934084cc4a67ce7bd7b5616a258b547faafa9a513c9844d0fb21c8c9fe4040033437c282c1cac2d092c1315eeec9aeec688dd45ad698d1e69835461d88144a13227e6b301f4b6d853d821def82a17fa8e8cfb6ce90914602a520a12f4ca835763514ed51ba7248f27ea6e2a8af08e897d1f208812785ed97600ba1f06cf81319cfc287875a2253809e0b1975bd7f206647dbd5efe61c54bd26fb167893f6c0de9475fcc6ea21b7af013b100b8e9b984a5cffe2c84483f27a020f132beeb89f29be0ccc2a57c07615558eede84a9f36f72b071ebec62e8d18edf99241c68961224f2c4be8bb6075db60082d94b41c263d508dc2185fe920e596a13b0da68c3a13b0095219792bb1e046605fd7712e588e0c9275e500d962ae831903ac970325f95d9622daf273985ba1c49b75eb79b6fdc26b7396d8ddbbea522111509c875a3f7324908a11ea189e48d42b95656dbf64d3207f2a7154c0c1c85fc31571ae36d6905e67e81ccc07c1a432a7ff63e68a586c2a6b02b1a177e3bf561fc326f68cc6248a008d2562028331db039bbb2ee5b5a894ab28d9771b326c2b3b5c3438c5f08e8905f0ce46f57d9c5ffb0d227a6ce40f0de14338cb068cd5bd68e12c985f2a5984e1be8e7e00cb3d82336f4ddea28cb23552bf3eae4b72be48c18e7f169e4154d379b88cf0a15d8081e205e97e91870d7ccc645e67b843a66f5a12a0f0d77e1f9c109ea947ee90212fc1a3dc2aac3954c581f76dd255c90ab320458fba7717029cf6b090428ef9e101dde32c43d3e96b2314bc9bd759f1e375b3f2ad75331f3cd078a8b6a3b3f735458e526ec7020a0f63817b3a576d76b27b36570c592235c87ce4e0aac70cdf7c752015c95843d95ade1978dc946f2f92abe5ac0deac2e4531d9dc3fb6a3866568a9517782f0905152714021c8cf24269ae2ac135a1be63d07790f55612aad4f2b30028c543ea915ce585fa3b35d196f913cf1c0fdc52f1ad2b78fa654d3d21ba6346829d2622f8935ee784a4c61e16ba3a9099a49102701e95c9c04efed088323395c962188524e1ce810a63abf2cb40da12de6a03c794ab94f5d384e838174348950786ecfbe498fba14875c6d468562340ca6a8f8d215bc07ebce27d45e74012c89418efbbd6c7268c35922272da362e1911d9764c381bd16a2c4ebe3c233a937f78ee176fe3aab4551e7d520fb80fff9cc1fe97315f0d73aaf64462dd067002d1759a93f452e0e1f7a017293fa9037f15a85d9b3901e25bcd391d7f6f747f53585061cf5f1cdd34d6ce4c0abf47e885a1bd216a3d691ddf9d4d0bbab6ee47180e88cd422bd3cc4347e34a6c301438e2185e70d6dde6560a613a1e1f9848536d20f6e475b841893b764dbac394292a63bb4a5fed929d0da58920e2a03c373e526d1e34b8e97768b63f45b72eb66031c24cf337c0ec3a4a9a60b6ddb9e3c4acfa5e2e6d1b4e2e420d3b2439d6ee41c2364b0d04affa21035a19aeec1d5f187c22d5d33a65399920a5f0e5ce0b1c2ad74a0dcc249f88e623dfdb3d09b649154171a4c5660abdbe0e2f02a4d99f40b632bb9dcbb032c61c9230f4c28ef13d81e352118e95fffd6fcab28480aa5e9a6c735a6e7be5ec138880887e8042c7c4faf4a15691433f558eeeee548bfcedcd445127f8acd100149172a0a8ce3c3a149906a4f8a045736de2e1a9264a562cc9df7a3b727fa2dac43fa39c69eecb4e653671cc12f676f465cf79965bbaf1cbcf1ce3a1319c9bd5237cf437ba31354a8fe153202462d16c158abcc99822098ed5e4d873ab5579ee6b55989e0e016779990459ff29cea48af932900ad4b05e7435c67053f9bae4f82ba99532001ee98261782d7b95bf1bb904ce4ccd7ebfaca0cc41bf0f38b337ee036bd7cf1df44888a2732965a7ed97b9ba395087587ea210273c2ac9e60aa65fff2d747f49e711a378db36e82539a87223c3da6a340347882068bedd697259f0a3d5a047cc303eff8a8f28cd4392b3ad836288f3e2da47aa570debe39114c18ddad98a843735a1e307c723f8097713f20dcf91bfc7413d0cfb921720f0f32527108ca9bc78365b806133b6bad6b480b497e7d26fb3fe880deadf395567109cbf80acefe6fb2e71a86402f4fa149735db89eeb6dfe0511fc48a3fbf70f08989cded6e5b275b5e3f28dd83a1592a1c1d7be9a351da05dc1af53a2c099b5132319f94f16daf09848d0b994769d8a0f65581457063d8f09423552f8bca7595805b31ad71e3f5195fc057c23bc2e0b23a6894db9a03043f943232fd9a470f815831661012340b77b12a2a57fc5b26c93b173486d716f6a42a673d2b8b33d9e23b45cf71eefaac707f38c7fc36dfa0531a601ea69e343d358342a9f94537f15e24d34afbbf60821763dbc4a4ee7ec7c1a5acb3830720c8fe78bfb456fde417a1471369661a97aa407e9584f870b6060f7c7440d1fb08c086881f958bfe948d042c59dfde187fc1eb06dc5bf8d15d08f43bfb7fc7bfadcf223a87d2aaaa3674c56475b7b4ed246011a72f0786cfb52f6e96bb5e85aec18b0d73363ae8e4fadf36f48ea24ff4fef0c9defafbeee5da07523e39ce161a49f2b7a5b559300199d2aacc09f5b11bba070c935df7e4f2e09569bde83e22162eda09e26659693dbbc94244293960097203577c07e9bc22a78aa43fdb358117232239747bc17cc87a0ef55f3b9d00acac0d8b3bbf1004c44f29c884c57866d2104a979b4e0ceb4966ac03a157acf2db17bab8362421a771297fcf9f43c059c380240063ceabe336924e399189afa3e75f8f81aa64420e8ff944e81a62386ad199fe413988a8199f6e2ed0c18e383cd19465d4f510ec1a0715cca0665c0e0a8562dd9f57e1c1557729456dd650e762c6eb7cc4c4ca869242b7dd0f807f2515b176f2cad933bc0772d673572d9f53d89131adcd3785df50a7c97a3a1aa4ba6a004182e9b41d82b392e27e2e47d42b1605eccefd60610812ae8241344b9588b713fcc6c20e5d830be2f6efb7fe5955f9a546dba8a403327b7b8d937637b0f874f3c9cdfe9e5b9058f2d7a55d3e9a22428427c61d518606716213af17bbed6724f8c58e2542c681b31fee746eec4156f8c923fb519c010a7943ea6ec802af9a3325d1e423b0364853dffd93483ee77750cd2f01126ecfd6326328fe770817658710f963680e7cba0f2a9364f452448d2f5a9a65d92c5e2fc14dba1c76bd60060ac2206f861d5239f2fe486a5d11d89df8772a52d5ca58e300d400cfa6c8f38b04aeacd56bb113c8f8b794fed2f4bcc7db0d10d152d9a61f8a542d1b04eef722a531fbf0537bcfb49fcc0ac8e794248038d6a32303a3eb8f3b7b2a8a5d1ae0568d1ddfcad5d6be80f851788c15c270ffb112fa96df13296c0ef66f988feb6f3189fbcdab718cd9cfba1de054ab96eab9465f75a2a39e98fc0ae4f8dd9de4852b4928a6fa85c18a683925b1f9ed20abd47b3b76929fdea14a02c88a2adac1784ce0f8c0945a333627fc39e024c5bb95d413eefc49f80b69132afc6586e788a926f3201ba61d8998f1d56a8de0bde962247699c810323adb4712369ea73b3654e9a1ea08620e3110089f11ce1d1f597d6eedbedbbb6d75d8fe12d4d0e671b7782ddefe3218d322b721e72144209a4008d639a694d7a4e50b45e21c6a315ffd0ad0dc519f94a93e3e4fa619ee2e3b69d22b0a9aa5f6cae02eb929f53be0c00c5416ba754e8cb7fb4d3cf10b2be544c0aa944d679e8ce8346f7fcd73e5731c7b8e3f70ae67476c57f331b979be39503b472aac83e84fec25aed87a60285e17712419839f9094770b9157d67759c4daee7e92cef6cd81b16948ecb4e9d9f763a91aff4fa881ff4b160a104edcb47ba3e798e651267eb24aafef1e2276b6c1a592022fdc033293d6188e0e950789253030115c84208a3ea6b556ca9fd44e26573fba89100a672b609cb658772158ab79ec7fead4e5511b342bcc168fdd89ad3f317ca36b093eb491f3d426ed393a8571561f8533a3245a13f8a13c4a4e7edefdf27e2f3699c3593bbe038bae87f37edea2e40319280e68c303e7fafe1cd623f66cf32a5fd88a9019c7772804ed75e550d87ee7535f3f79a18bb0d623d7a9db02f0c40fd1e32cfbc98083800b90819546b45c2475977c671a56b9897a0537e30d5109012355d53c3b768abb12087f2640021709522b40b58b2a7f508aa85672227f43188c4c0b016ebe68ea9a09aa7a99c3c5d4b717330ed2d6da235084704caf55b9e75008a7d93b5391fd02b4109ca467fafebe0194fcd1b1c61b3eebe7c195dfa04bc706ef09443235e6d1df54d965917daab72b917b26f78d5681f1dc82e7b9ea932c5bf6d3a47028fb4f94cfe8a206f4b1852ced5ffd1187bec1822400d4499a6a4c564da20b49277b969d2509743cf7812315900849fde1c483643ec5fd52b3085792c7d7a230613198b83c8752d00e7227d050429a96c40d0eb62accc2ba5b2a1a234f23543ac0c09189dbff1e09aafc09246ab19b9f814ccb1f97a2e247221563375a4d9b14c2e9a7f749d662363166396612ab2dc32bb9e583cfcc154c187b357eb4f630fdda9a26993069b1086a218117530c8a53559aa489eb8e6f746fcf763f355112fbe345cbd1a16312229403d75dd02d97266e1a2e55e36b73cb273c7661621c85cc57033ba6fb967c2feb42cb24694744b30471df3416565daf53e34e98eb7f4c3f7fe511f443d19c979b4ccd3df9119280ceeb0b302327e7de4e1fb29397dde5d0571406e2c24aa407f999fd66c7015518cc008b175b386694e88381b63b1b5444a1dc7d88e948299d3a9b39152643ccb5b93910190900ed973c46f3ccdeb83a4d305fde49676951e5f0d8c4b7e692c8ac77dd53d3f24c1c58deba3e4ce042d2419a1e4d29cc7fab867a78e4ae0c2509297f0cc6673f42425d287ce049c9fed71057a39741cf0432bc847662c6a0b8e422447ecd5fb4fc0ee44f4b6263cdd6a662adef4c72561b123d65cb3b7363e21925d3a8ce9d75f21fdda9abe8bc4b41f27fbf2006d410bc0378e5151ac7d1256f637ef395a2f6311f9d25d30f0d6b9648c8688b782f527fc3875e922838f4482b7c9e9e42ee4aeee3fbaa75a0e95f770cf78c958c7fa4303f431e85b90ea528330452634cfc7076b022bb0ebc2e974efd605e34a000e75a2e614e4a0b1788cb803ff784cf725d8ee7276f8968cfa0a3e4a1c81baa028c15fc5e5ee9d94c650a0dc44165c4a2929b86d90b592ce3e25867cbf6ec7ce2fc6c21104bce180e99deedbe885b5021026301da6835314fccd668b428e3cc707652c7ea568914abe3daa5c3113079df9abd5f748b5b8007849098fa18bf19b75558abffc3bcccd84a1ec5361c091e9dc798258218f93fe8c75a2ab11a2c8fdbfa81579f28b6427887f91344772fb3fc10d4e3d807096596d833aff7fb606bff5abf72e762afcc1e21c546b42ad5bfa1c03bd0ff8c68e4174807d0e1b426aeeea29141e17732c3a10f3e74da17f3cc29e052d6b9a96fb4d6385f861c6970eba2946265cc6cf2f3d3c388df6ad60ac448572a98478cb0c8ca470c9fc5e25801a27e5c09352229cbe5e41715281c2447787f7d81bd500e7f7c15d4df41bf755c593395d2790d0c0557e7699b0397ce671bf776255e421fec81e4f76b625c7f70af31e53aa0250e112ddd4198339ef90e97a78557c617ce996089ddb0d40ca0090b3b3ac0cfd4146b9191164e81d0695669bdf18f445b34967253d36b86d9e4a9329b28c7c30915d206774b2bb302c4ae647d3bc4030971060e42a0a55f3ea210ba9df69ec89f9b22bdff672a7f15aa06df3ffe7ff3a532b1332c3fee1205f88d5eaa02a0a4d36387cc052d8a7bcee5b2c41899b7eef83f0d6345aa88c32a958419198ec63cd2c6385be4e5ef50306c806d552e49ccede5a2c49542f23790b4b64a1e1cde2aac7124b41476963956ce12002a88c88f11f2682ae27914480b937ec7584f96f4289d0552c1a6a44196f3ec246367e519c5422bcdf86ad54578a6617b16b15041844d5a9d700e922adc5643f9488deccd67294398f91d8b254d07abdaa5dfd5708bc1153ae774f7dba499724c559bd9b4a4f69f51ef5ca4335730a6f6277faf53e587e9488e3fc35ee03b571c2d1235141a2264b0b84ebc1bb7b3448a6034ed356f86dff3622447e8823a8e87f61746b54343f9e0a101c6bc5886f639b57c3811199ece1b2174c7f7704a453803a7609d6c13507790466405955c2dc6545214e5b2d6927d9ef78bfcfa933e427b214e3b40f9e136f05491401f7aeafbc8737e6dfe59bf0a902e2d0283d0372ab9f236f04a0ddf7306ae318a413e0a21d7b98b03172924e09dfa73e905fff2e7dea73e6c668d447d3a5ec6242328362c35614d712ae85b11c1419855a246d4797a80426a9060fea3c9b0cacd204158f357081f18bfaf3f0b7bb9a97552f5fa6a72d0a0b12ec4719433c777489de4591634bf98433f8768308bc6813f60d91863b7481de41252edbd01d03383ca61b7c0b90bab75e5a56681be6c5316b46e75f66c63a72cc3481282991ed1e847db4172e9faef6942a609e7a9b50c6d01e3f8db2681021b21ef6983b4faf15693372ccdf974a4d9e5e92265f931883d844b009e37ccb83f5fe6050baca291ffc8ac197b63f37b000a656d99f293cc94cd09e6753c8131d659233065b88cfbe24cc1b10cebbe1e3606b6cdf3917e16e66321ed9cb814490da9da65115190e9b6892de9f5cf2e76741178b9bd910b36172ff2a8757dd2fb05575ecc1c74a3952afac9be8a1dfd6d1e6aa2ff419da39ca850e329c75b6ff5295813dcd40758a37f23fb4101e49428f85d284147e825d4cdb111e720e757fbd19219691bd7f6a97e6bd96d368e969d626fe1ecc7dda1dfef4036fea49211029b6eaf563550d6010aeb585ee0dae053b56f3b8d051bab667295311714b268f2cf97ecdeb0ff0962b445dc639bc9dc8c77c5244b64fd598e7d0ec5513d6bce465b9d0bb10a86ab37e25516b2ca775ec138516e14fef048c661f1c53e4be0ce799d4d967c26388e12ebf814bb383ec23e78fce0d6a6675c42e1af05ab7e3595554f5017af3f2645a7b60de1fef40d3f3247123b0ef17649ecb492a2614fcbb35487ebd48466711e9d7f98e205e189b8abfe85c44bf308fea0605b35331ec27bd0e0eb4662ee435881c84af8fb34a58c291fcc99befae45ad71690da53a02c82b0392fa5ea4d15678953a0984ebd149eb540e33235441f97133da55420cd7d62cb3ec85474e81f4f1bcf495e233143244f299874a3afd88bf31a3dadfd732f9a0c4de97c79210f5bf412dab61b2c8aa4af55ee89ac2776ce6126070ea9b8c1364b31d8cd69611e479984c7b5ec33f1a58eb69e8d86f91bce1f904f06cfc3914699eb5cca1255838fd7a5b4cd0ca091260c28fe9b51206a09c7c45e831245eb6288821a4b9bd7d260b91353b09f600b0f341c274c19b16e0779a51056a5d4f294d0829881b60abfc6357cdd7252cb2807f59b3c371a82c7c355f47feff850819aea96eb8f97ff712d8162d37904c7f4d300","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
