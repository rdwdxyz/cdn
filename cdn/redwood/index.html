<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96e3a5c1270abd6ee84fc72b345e6812fcb55ec5182835f7135252425023d122a0a6ff96a71d9e67ca99864127475d3bf8cfc21fa6ea4bcc4617dee90c5cd150ff00ede5659ea8e71c25e3f69125e19d0651e5d99394b5c389e8dcea9e2dbf842c5ff167f6435b2acd7b3dd6c8a2e2200014f08ece1295aea69833b0f4cf644ba0091db44cd1d0e982ec9b436b88ea4bb4d901b44754d749066ce9a7ca0df94110273109aca24798c2cf3a2bb13fb7411c0d4f91160f21842e8ffd6010a7d3015f197968eb4e313a28f8778a13767f1cf2e694f6d1bf210019188b98d9af607c062f095c1fb0d388ee6c9369911b29714e6f76f56ffa2b259ee9554a6a4ecd227f08523c7fde9a1f0bcbf6035e22bdc573345afd4cd541a8e71d6b492ceb14df0a7118d323f6aba80f6b2d76bdcde2041f241fde50e6001094e00776c6bef4a7494f5504447ce1229383d867511e35e18729ec208c11ecbabcabd4420d63ae9024aa89f4aba7e545fa3a6907c22344170908e8abe7108653b8cd207212f73917bbed11ca0129b489328e4d4d6302eef1b6f53fe48d091682801e3ba27d91ad0f71c3bcd2287642b8a75f68fc9f2128a78e01e591ceed8d6970aa7a9983835feb3e77649bebdeff665fecb567c8aa917cd9423755ff6f92edc2e6336e05ec469f16714813679957a6c01eaa462a69bf0021b96a23b1a481b71a48e06ea7f57dba75990f8b55c57caeb4c87e0f7a702876219282944228941ddee74a2e5f76e6bb4398ef7425046b18043054b0542539785a3cb4361a70a7601fa2bd22e1f5997806f032e10408caea855416cf17ad690b78df4789992267791693f8a177cbf5711e5a8eeee189dde5554c52d664719e16f52a4baa99991f6f23c2f82afa6d39b0fb031fb74a7e5ecce9312f24155c14a380480c4151a2b90e4dc957123bef98d6ad5ca793a973e20f304880e187ba7878542547ee32fa8667b2bc5c90ab115de1c0bbebcd40300b0bb0d662ba956237da9c3d4003f5ae9ae430ca11825b726b00092bd4b74e06c88fa7e4a8a9fda6cda8bbcf2a388bf83715d103d635966accd49fcd7e9c5d155008c1020e1670fe86a3841e9792dc5ee11ed43629857dca91bd2a12543fcf67e6c972d114026d93c8426e432a5b6b8c2565559b1b8dfb178ed562510f5a21cab31755f1afa4a3642409c955c2e0bed9df5b802864cd9b9f5c4da93b7f147b14e13c142335f4156641cd5b02fc152b417c3201e3aea5914139f687934f1ceafb85c8197db6dd0ab43df3b2aedd19faedf385fb60cc0496631bb27c937159df1c3fa8954eb8bbd3fee0847c25f4dc4f7fa79746b5ee172ab50b99246dde7f6fc67a31ea065783da6329277a366a9e3800b18ef7543228f17a56cb29bf5139dc21a223fa54a8367c7c4c7fdc7ff4db8863b624dc9c00db51018f41590913268e7c6629ecb7e9a6ab6286a2b47a1fcb861024cbc3e2db58cc87e255ea719162085a3d8de65c122300ae1acdd16635a3be00a8411cb9be6b56e701d0f869cd38801d116aacd550505233b400b4c3190e6cd7f6c4c96308e4927325d176fd2b2f85ebc9b6429940c73b0e5d84414a84949c95b0a26173ea44e09657a546cde55866830bf5f3796000b8a4d4f5810ef58e7ecb1a0e8ce0869ef1c6acb8434ee3314c8eb49979fe750d078b44e23537b766e1ea838f427f92e3942a7c95c062a3efe5ae61c5640e65f066b2f5975aa727f154de09f79431708aeeeccd559cbfacaea86740c84cd71727ff03f33efb69b823e64dfd884bd8dcc47e00aa92e97b9c5f48cf3e8ea3c38c58595c1192f413032c475d7ae8ff5ce8d12d0fbf21eb788b2b811d67e457331c6a1f96c28a664f2e9102377959e0cba709ccd1701af1d7b170ced4262112ba0d0a51d2a74a657ea07ee0f7e57a010e4101377f56df4abcfae99f064ade7fe3b200e4d9566afbda99d244a4504b85d5d1cada90860e6625a92b18293fe7dff98262687922f026a593eecb72ba0f0f13f6b1239d5aebfcebf384d8d92a3a0f3190792d4512a777e4b09de64e859cbe82887ece269b3bee5933d07c4eda1fe9574124814825da6ca33f07e5ec857430fc1206c438130ddb8998ca4faeefbacda083e4b80c7d571e543fac94a56be7befe966b497c33d6c70a9e544f213f361aaf9550ef1573232a888e0e764c9264b12862a4055775abb5c5acbe57f97c42fb7e2f3cfc447ce3814c717462237ebde5353aea32f99aaf4ee4de160bda339d5a6d8080b75b1d55259dda5ac1b1113a371789aacfcf96123ccd3129d16a07622907e00625961a140e0c5defe84d0aa048e4294b1592999005978b8f659771552bb81d4272fd275012cfb6fa51215c5f606f2621e4fd651e5fb1e12abe1a2c753dac644c0c9f450d4af99a6deb977d51d55a604f4593a01302040cdcaca0c5a0486ed42acf7a2ed6a502a4150d2ef17e6259ef2f9c08b03aa74e0df5fb758ace342f12496a8ec2ec160db4d640c0771da5a4af76d73071ac57f45718fc0b37448a0fe9e720edb52135535ad67669576eeaca0504b1c3c7ceafc05edb925a3b89e9b1595b371761c1c9526fdc14abb9f6a3912fad8d3152aae9e0b2575071fe0a8b8e48fa24ddbfb2d73cf916cd6bd2dec3cbfd6af12d3639b21108462d2095bee9a43cc4b91f1c0390525b99900319e8a9d7569e0934383c95c1ec0d937895b0b0d78ce256e121f5931b94fe3b5764d5c3715056b187b9039f8e2227455e928d974d2035904ab41e14a2dfd4b5bf1972ca67ba670906b51d8993d4261a9db9b9efd7873179842fb809dda9dbc93b949589a4751414f16fceb3c923b4a1585729e7896817ed3b7d351c68cb28db0e45c455a78ce3177448b18372471edc8cc266c3dbc62412832a740f381dfdd60ab0a0647e4caa90e456dde380f0e9d4acb23b92b443208ac39ba584a7912cebf0160bf5de9a76e4bd6b38fad9176f9c3319b414d54cfa50a219de4357a2c3fb820074a8741eb7eac7888fece6ea1631751a495f2a186901b05efcf9fff38cb1054563018e556ffef2e7fe56b9e4414c1e7bb27f0cfe1d19a2542a30874dd926d2c7cb0d93afbdc7cf4d0d1a0dea107e435462a1bd7be06db1bb6b4f1910279f0b7f79ae544c3576e14d9f63b9ef4645118bf53e94f59850c8013d7ba486ae92beedcf1a30de7b36a117292e7307a236c18ec9e131d85b0d7f7ce3bf1000d1c30e6bdd9541ab9c680569082a1ff4ae7918eb20dc4f0348c8756dc7ee0d873d97cbf2a1e05bf58af93f7fc86fe0af961295fc471c20f6d5c44d003d2d5c1901a3f2f69f98b63f2876598da1dba226bc915aeae1eec1bc65784c1f7ba35fa384f8d97a616efdc9163bef61773c574763ed0735ca961bfa4565a1a677b84edef0f999ccc7975d80019cc3276e4eb1f11a582311f3b24be461143ff212dec87f06b0450e3fdc756fb95db287015df5fb20f2dede9eb2dabde691792f4bef2dcb04d0d9645f15cf7a1c608e4a949d5480d60896aabe2fec9ba6817bfbc5d2c1c0c89674d596fddb77562645ebc4d228f8822bac50272488ea1892e8ddc6f6bf6b9c5103d20a6f54629ed3935880c4c77ce315ff538d2c2b777bbf1c238a8395462b6d3ba4e83b727d3cfd6886e8d10d2af232fb494f16a8ecd798a3b880a6eeb28b76e3334f8fdc8ddf43ddd83286fe552796d04dd8782b3ce803e0209693205fe2a4a35b0bbd4fe2834f290add59d98db7c3f51da92155ae3fba7008e08199dfacbe5d34a58427ce231caaac7e2cbf02b2daf3abf5c52238239500b61985a8038f04063a474bc191286cf940b10da78dee71feceb51ea2d6cae16a2b39ef96889d276813c5adba0b5378fff1a1b8266c2ea5422aa0a06ac1885d754530058df45e0a84b53b6614a5c65ac02cf0b71127800d246ac8328db6c906bfda0b88ea3e65124f9a119ab00468f61ce185abc01e8daf14a8b8f0c017cb54dea9d49d31d690c67dc98ea78435431d8b31e5e672205791a17e786f527fea41fe05479a1f5ac95a6826c98eb0e6696a97abc9b6a74ee9533be1bbe52485fb381236ae768ac7ea15392464a052866c748b0ae1b40de632ef4019e17f5b17c13abb61bdefdd6874529124d3a4b3e3a5af5296997d441cf884c7ccd36f53646f597a79459c1eadf3ac684a8563117c586c24d763753962571ddedd69da8aa58b2af1966f3e02ff56f6a00bc12b9e900cb24690ba103ca2357eb6b685da910588a0203d9d23c4fad47f08660d2a3751a6a050f7241b357a0217de3447e1243784779f6dcef2cdd87cef79ff7ddb7a0c5c09be76d0ec8bde4bddec33ddefbba467f3b7d3a99fd83bd64528c0069ba0e716685f18ae3f56dfde38ecf8c23fa6a7e41455906f52ab9c95ec3b649066057062d8a3f0f09145b513161ec82185d6ed2554b9653158cec20ac7e943fa920d7be7bb250bb51cb12b3ad53fa104e62af378ecd8c8b3ca0dcb2ff40c49c4f6a3d37772283aeea61bcc763a99cc48f04e5d7ab7b5d2d2317938d2bd4ded7108dfed1f39db59aa64d473bb673ff21c775bf87d8711092165699526a26aa382ece520859bd659f35e81fd6a482ea92c11ad7603a0f708f5052a3d4e16c545e0646eb133050dfa6b26ca640c2347a4d7e3a92c4b5040aeb1d2fe87c59d34929045769a8eb13b5996dbb5b02ce48322689d0e5d298e22b46af475a06c8ee591d9aea45960d8a082c8c471afff632c42c7bff00a4b4adb551d9ab1f800023ac62bebaf62e4ad91c6dbf4532b1260d0d3488623bf3bbf83b7ad330cd022a52e894eed82574b1011177ff5c50c183f1a5128335a89f02722054765614c7c2b9621434944dc7d06f6fa456d7fee455fcd920f3af8ef008652cb7527d8ec37f7bc5fec5ee4fb5824b645cf3c423b2061a54a7af056b6319df717eba2e041ff685628bd66dea19c60bcf0e6306125e935ba8028364c0d4f808c021f392a9b4a50427dad5a5584b19c5b6ca3eb162e2e8e99e5c41fea87393a20ff31b1c5d796f38278f1cc226b37d6968c151f4f574fdd2149559f3432b38a15a186a9fe12c6227141cc9a6153bb467bc3fc5c880a4352106462fa5651c8a72e191196050ca216b3bdb45d4ded8f288b15448bd6747168becfac56a80f50da87aab7620e9f598df6d0f2d8f2fabfcd7f7ee62d744f697ff41f00a9984a72416b6f35032d70321437b7905676c7b22c70a2a49d69932b9a8937756856f189383e721102c97417ab96769118a1089a10ef0277d8a2be89ea5097c5b659eca566c3fdfa62f832809cd0e9f5b5e50db9d94460d4cf29c15ca109e4d670d46b4a75118b497894ad6e998d19f34e1b0d53fe1b75c59646d610aa70b304bec53894fc5dce79b5d10986eb79be3670cbfa4dde951be6e64a9f6654f030355476d4ea73c770a2b16c4edf2e0166bfdc53110d948866a3b9a5dfcb6cc1d2307292fa18e0a9b208b017c4a6d188dfe650e8ec43cb3a5f7bf550ca27fd193730d46ed6545892144ffc1626d65a4cecb83ee304578608934f8d529bd31ab49eef1d7bc05771a900290e34abef65e34c613e2a01977b9ff8d69d4bcd804f79e50e48631b30d7956de47fa64fa8a865cea80ee74262456005fefb153a9ecc43f7af42e81a1b17cc4427b6158da00f2504a27d2d2fdd7b8362c8915eda89b517f32805fbec4c33e0e50402df091a9c8cdb93e01a23cf6f7d8ade5788d8a93ecd817f5a604e01f90b7b90b443b7365eee0d68517885cb025139f24f86ae3880f935feda73a32ec529921436c70b8b26bef80c5af655f974c28189a0d2e5498df3f1f3e654cbee9f880488ce7fbf20523e270bf54a8e7e23ce8e107e2f2082c9b9c2e367bf1de751a92ce09edb75414d057a86f96bf0b6d8a2923cc4f4dfcab22d184b08394b44751fa94e5153bbb6e0b93fba4f5e49aa44295b52bdbb2dcfb603e2dcbb66498045cb9bf3aa9267c0468148061eb88516c6b6b76f3b66dcf959b70468763a8ebd0cd580adef3cd8ccc7a7e6e241171beb3b3c67625ee807363474d6c4c2b05946ad075deff6bffd7197c95dc79d35a2abb2cc9096e2dbe575df0b68294eeff20f671dea45efe7dd9e9a8f0fb025131dd7e3c2555c95de022f88e4ac6540fa3934634de491a69098f7506fa7d7dff493a864f3b418b912796750773a3bd0c754c5d51506b5d3d664be938e95fefe16477cd8a18c4758e8762c2ebd71a9a707d1c2c67cd8379e4e69269386d6e29ba1a20c0a0f98bb352086c6b6dd9d78b7bca9aac0e76165bd872ecd1f0d0bd69292e61ca25e4919cff1b01afe6f8cfe30d80a077629bb6f4e3051df1886e69ad25c0bb31ee83a05f65f79e81eb3c7e8d4d030130e0110eb835a7276137bf6b7fea71072767f5db90c3faf9abcaab5dd2e7ac4470af63ef2acd6c40c7cb1e42afe0863dae2440698177b47ad5f37469eae2f96577444926aa6082f01b995e73731c8a1d0d0ce1ebbb49de628f68bf4da0e31c421a0e5ad83afb8165db7c9a3bf8d092e4d610a4ef2c3277951664a6ebc8e3d538a1814b35c252593ca43f0ab431b6632863251b6213fa0b6f10621420dfc421bdc86e8b587d7368fdfac9012718e6b8974baadf14a609f2e8d5999f8e375b0b2bc8b81730086eb009f761cd86f930575a08e84e1afa85204edad1ca50bb44e29400ab79dfa3c0b0a57b55019754f3779a00e016567aff4dc2091631cf523d5b70b44da9add7fa316bc2c887c6d9fc6d4880ef1434946ee6bdf3982f11b0f75d9bbf9b128904a1fb77eab3bc014028a8648cfb36858407fce791fbc2f46222d4fb8859d514d1662b2642cff6c99ed488c5af971ec3d6efc4e2e99d79d79ded98cd819b2004faff60384624faa3eff412e9db10bdba6fcae475e7b7fb3ec8418c6fa5370d802d60915cfd23bc5490427bb94075714983c7ea770503f3f3332ae0e55651929c01689d9692a25df46176244e27648e8a83d982fbdfd2aff831e65f8e6172b72ade1c6d71acb80641a03ecd0811fee0b2862e47516abed112a4e539eea44b3b88b6d7d8d0853804c1d11895c2255b85ffd5e8d2927dcb1d54e5c73a968cdacf368a26fef0b6b6fc4f7911bcbb0d11dda97fd06345a076ab9bcda4efe9da029560b591a6ca8a8443086d4dc2dd5d9e2477892deb059ce33088f8b85d36747f59e9074ecd06cc5e3ae7991b5f0b131c96abd3ed103c35b18a0b572c7e1863fdcd004d654a7380ca0bba0d706fc8330a65c82ea5e7212319e4d948973037a689a1c7af6bffaa8d71fe8be5ce21c721c9dc5760d775c69baf49ecb706aede41b3542f96287dfbe83833e6fcae37f6018c6029330424a264d45379c994710d3e48b829af85619d9a2b4b10c5ba0e8f9255872acc1a9630e9337af046c45c282deb1b46b76ed200a3478209115061ac65bbc66aa97e05f359cd32fe520c95e7b13fe0eb4f548801962538cee125a5929dfb77f4ed3ca4d4ff9e566f223afb13b5f4ae2480d3bc6d67f73059d29c9976ad0a1b16b2ed4ad6d1b413b1b2c8b2834c7b0245d47eb64b0e5dcf84ae0b3859c820904d80016e97bf1d3cdfa8da9a55fbfc6e9aa9600218ef1a6d99f6fd13679246eaf65445a0daa28d999e63207a633cc6fccff5d2399c42af3c17326eb7b53c7a8d35c94679ccd3dbf19a304fe22c9337e2f5f1ed4dbaffb6d77481a43674029715f2b102b8788e2f669e73034af662279151db667898e1713453371b3fcf297d798606e2de2a9bf034a3c053e1a1d0de4bf71c79943959140b5906bdc7f35341d8cd123a82320731b8018f82b9eb313a573f233732e60110237c1ec1850e5a06ca17e4c99810c23afebc16ab6dff34a714e73c77b51a758d3511bb27849623765f236f69d78c925ca2ac29e718028ec1722d0797cf249d0114f94f70add742b9d944d3f4295d5a68a7d1630e40dd2e56e2b71a83b64ba52c46da4d0253ec8eb0fa906a2298a3fe23d7d862a164853252511ce0d771cb26d9ac7ea2cacd7de015578a7caf966135b02a2fdcfc860280ec88ccc1d670b5023590d2b969c59a4685a2daac17876ad301d9c98c4f632d1af55547992b8af2fe213800797be3db293a79c7a521b11d57052fd21ee2727c5e090f8bc29a6da15338edf88c0db82eb8e29de84533a936e51234c5e7d1b73199525bbcac4e0d42ab56424a33da9037d333714af146d4b131e82bebc1f08d98064430f7e42ae43dcc43e43e0d1f8f33933b5e765a32611b4e9b7966a67631cd6cab4fdeedc21cc5f56803abdecd0b22b9d6231eb718743af536459d4928f95fdb0f19e5e169fef6b4aa19856d6de4fdf7cb3f3e8d32d44d692b1ab749aa5c0dd3d100674045d30c72f9bdbe0c4eb8339dc6f4908b4499b404adef6432239001c68c541283f5a98c09b9e3550909312ed70783b329877b8a0829a64022aa5435461c3a4ee696ef274f6ca2b49a6020d0c6ec84636a689ff84aebdbd9079a3bee17887d11abac8741eb00729016e68284686c89906b320081478e7de199ba51e2ed6ec3c8c3f316e1c11cb3dfd6a768b1ccf8ea6d7f748283de8c968036198eed4e52b74c38d7221f4bd12691117076ba1852a26d853532ab7a3f3d81bb4497412d3ee65ad1ce82832513b93d013e1a538ca68328fefc6ae0a3826fd5ef878fa852c67bd6e953d4fb82cb3b81d846b652d3b474b76e09722c803422b4c1e5d117a5546f540bf5baa8a2799d4d219d0af24a1dbd76316af5cbc252fc463dc8d19a4e7e2d89341b751c1950d1093f2dc6b6a3aef2583a6b450317cb9cd784b6313206c11c0aa38b6128ebeca939dcfc38bb6572642031607137ea3fef7a8dc48a755bb75936d242c4f63097bfd999c95a59b256fa48e0df772a4ab554e67546232765637a524f1cb17a93fccbc86a07b2364a7c9a42f12a3aa8e947870e574c7d28557eeeeced42bc134a443d94f6dd230408978e2fc9318ef20a9506471e423055d6858f958638e6d16258fb34f3c4aed2858ed7a929ad7e2beddb055520ff4fdbc0172c2362f312a28d61acad39e261d3b40f3d70c252071f7e959baa0a22685982d209b65d5f2821d5212a5282a5b52a3b969fe9143956565ba8670eae476d8e5469d9ae32e7452da8914e20e9463c5846008a77a0534e2fa6b55baa4b41af900311c36fbbed105daf0882f62606644bc4725ce6d18bfd771104cdcda66a838754e2d125535cfa3fb3dbabbb3dfdd0c5db806bc12dd9c12512f0d3f6d210743054714eeae1fa2252d628fdd8dda93a5f259e3cd6b5999e87881b516641e8b60daa51762b4671b83a8780962ecf78709ff7049338866fbe8c36591e6f07e4a8667d66510721ad5f75b2a7bcb606283a6f76489f9eca3c6efb2704c8d3683013840a274363e7504a3534c330bdf5da80f110abfda83efaca3e0c811058e9b3a618b9305e0f838e1349bf39a171bfa7237f073f96bb4dc07c64708f0d9eb97422fab4bdb791b7961f61b480997d2838702141cfdca7db576b09ea3b36226dcca2ad6a63756fafba75e3189a6f2c813f211d48b0622b6aed9f580d103a111305e2a1ffbe846ce7e8168648894ec82defc66539edc6b901e079324d05abd7855becd7a90f3588b2733300552640c4ae9c9b303d9e82648b619007d771b0f4dde3de4d5fd7cff64e0a1d99a55accb73e90c13e2f80d81b36e6f1289be972f4f81612e8dd47058d0e4f586e7955358b806c3e0d0b51936ff80458bc60c49ba88f7985cd29cdfd3ab1cb07b4a1648cb52b48b5d27b719b65aba47cbdeec3a98604fe9037b590feb8b44b26a1f7773d1577726b185f4e2c0e5d36d2ad30913e6da136ed324b97c6b2b8db0594ae758501614a2a825a8cdec453a4b32b40d6ca1f546c0b3f746a3f2342fa5ccb1b6ac7c4c583f3481556c8a124dc01814e74f3e9d55bceeee72256e8470f592833f4d26c58a0fb3530da876c38b9e2b9137ea47648fb292a048119be6158a2332de10deb36c7ae1a3f76e8f42160675c59ead496d9d96f85e0f55415a4ec0a3b730d85d0245b8f89e0cf56b9bb6f8e8dd87b2b3b1290b700a5687140b7558fe32d2bd3a4e9ef19831179c6e3231a58e6a8578f24cb0abdd075a56c787ccc5bff5d33297c4350e0048ffbcbbafd8d966e6adde70b5a37b01750d3eb64c622295dea4e7f4f0308772d8e52a3653591ac900b840dddce60e3a22e888c0a77df2de2bbab9feb98f79ca7e01dd6705977737a9d1288ae6ec9ec3973554395250afc5bc52d0c3a851dc7779d2983d37cdf8f6f065c392282e75e910453812ca533357889986f415c29f81c6099bce7f4ab50af251758b39492e0bdea20631fd8c1409cd8b2b08df60b3064b54c52f2ed83f036e1502d45ed96310d28cfa3590d50a39b8f2ac3c27221b2934cbfc101e1052d0a39fa95176118ff525ded92507a6847484667b40a648fa2dfec0e092df474b093597eaa1d51f62c30c823701199eafe929406cbb7f43b2142a9d3c7a2de023ceaee1990c768ef41df8ecdcd62131f7b14fb98159fee0c58fe3ccc15b843463d9fe26a3952b10190d75a64221e5d9c09ee4415e466c2ab75026c640eff727de082e253ad65538c2f70fd25df2edab71d917eecd2eb711014480da12d8acf17822843016c61f09c4e42a14ab500fb2d9690c3c1f2bea4dbe894fd3cfd57366e0dd93213296da4a0078eea1a431e4ba7b1bf26e8c4566fb7e1b83ee942da047e019c9f03e927270ca8efc36ff6de9909f801bb4ae9dd9d43d75092139a1028cb5c7b2d5a28c3880bf560b8d6bfa1554da9d429e7b9433629ed4df0b0ef49f05dfd84059d48eef96ad4c2e2e7b9191d18a743f3f5b82526578b8be14255c58964fd3246767dfb48b61168d987cc1f85f0ef9e55a9796a1426f99162f6838ac692e67aad225c44e8f35881c5a88fd3d11c297009bb00d51442338e73b1f5c4b052c24cb378c4812955dc582519ec3e5524861c6a11e63a394ed7ecc69b0e65ac12e43adf27ecd63ceb8e3db0378652ffc9ef844ff1db11eb2eb6d9d4614e59b8bb37df5134f0109a462b506624442b83aff7bdedfcbac1ebf3657b471688f94eca9e31af7135fa6eda58d3977cfe8769fd9073d19d0f898aab83ffda505c927dda8ea0610ba513a7e968d7bca97d7984fa1f3edee219ee119877dfe406746aef2f451fc8f592440a65bbb00bc55fdbcbed8f83295b440cb2c3139a74d54f26d61f876e738f035e62c98c88aba4ddac63306b6f67eaf63beb161450552966cf3fbc172473f4cfb7b58c75d7e427d74c4dbb503b0e8e38291686e7bcf2449e113609f0bfb8f8e95bff2efa47554ef4328b5b8ba23735ceeb3bb3bd416da1025da995ec4e679129faa111902de245c077ce68bd715bef666c2b071280cd0b79d9b46f672d4b1406714f5460ba418d0f71b18981c39aeeafb0bfbe9a837c768b30fe3c532f6d94bd36c17db4f2e8f8bc86fa21ce0611c53ed86346182365137c57f1c5e61c36c0d942f700ca3b10d266101610124de12e2df855f5c482d2f21083fa270aa09838ad293305d1d7661fa85dd39dab53f9a102d1afdde5fbf0a5b152685801cc47a42803bcae55855b9fe53043278c558fb86818f5ee470bb4d5e9bfcacbfd034784935bd17bdf3d535ef9665fa904bb472cd98ab6edc5ff7f1fe91022e53442c0dcaebd6280c7712b91d97ec590e92024753db9838d0fbd85720bc847f513f9340ebef83a1dc9ac28e0bf514436781b97d123b130a8f2c1349096d0a84c24aba9bc5596cc6187a807be32be4b335f0387c6f4e9aaa8cb3b7b5a3640be0ff1020c47ca09b1950f56f94e1295e59c8137447292632c2697081f8357d24d3265370417f6e10e4c6024f2266af8fb0a2ce0db147b7de40ce725915bdeb837d9609f0fe5c55599fac65f06e33047d9661e3376f8cf76fed3c6ccf5347d5e5ecd86c2b933ba99d3a871ab137113ab3c26eb991c157dc9c506a3eb074f6835b6ca1b456bd91490346eefdf6d2b976b459bf1012693c7e9edd2ec6d4063e2ededf35b2f9b835490b9bdca2dcf782f4bcf47508a9d981e99625dc9de421cde6fbcccb15751f2b8f994e7d0ac9475b7aa6d7f9c22bd23ff10b36d4ef8942114b222e4d851765007a027e8eb3154f7d7c80ca5780d5710c55b1b0d761cfb5b442ae67fd84513f524bd7e1ef65c0d1ec3ae77a2227fd1af26e748ddb1639e7b53de0a16ef10d3c3c8524ca4d1a3746b7927add27fd68ab54a81fe22981ad0a14f119f18cfccc3be8512d68cbad1fe66cb02f143e4d29fc81f59616f8dedb41972a45d1db8407fa322c2edd7475daa227a968c793509616750fb5aad880a2a6206b80e35b0441113ac06ef45533e9fe3694bea11da4ae0d64fcbbb970581b5280ea51848bd3ce202052ff6aa2a4d6f63773b3a92157e25695e6adbb938878d7501fdc3f217cb05e301b10dce1d1d6757f58709b346140a6756b4a84486315b04d6e18be6c33b3fe5c36ec131081d9b548fc76284e015d66686cc367df67972ee3ce44ba9ee3efbd1bfbba2faf1af7cc1e11dfe6f656d2f2773e7bb8376d95c18bbc427193ab48cc4eef0c12316264d908bc787587767793d0f0aa50e329388bd4d2c25626bc25770cd366cd25a9cd02fafd44dde8d7ebdce7f5f5235b1babec58830b6bd67a560187f3abadc6791afed7c6cb27fbbea64cdd397128b002ae46f3f29615477078e95611c7e61b0cac33205beba467d5bc2d70a4b199a665be3cfed45db1717acdc30490e2f22e7c40270d600fbeb1c8d6085f8767b9a153d301498e5ee01010575ab2c5aee901339f165861f2d9d49fd6d563eadc013e37c8f87c4f9b5b261088d92e0764f6ef6ec824ac5083a33d3a9690ed583276603e22df8cd7b9885ba118e01a3324eae5a769651b3c518ce3e4d94ff1b077c5e0e2ed60dcccee015e654c7e1a1c86956b3d81373bf347479755e00ea7e4ac81c5a2f3858ab81887e07830585f1c3e03ca200e7b75c7979704b2c14b08f9708927f014570243a2c4a31b6c2ee4e016f0de43274d5958fdbe6a859d64477a592a56a8e7e4eda9c9518e5444d1aff24aef383bf9e6a142b11f36996375339d89399874dbca51063c93fec80ad78f43fe00d885ba3c93c576564595da5b3b2bd0b11a36e3980382526ccbfb83fd9785d6421984bead9e1e6e2de5c110bede777849a28dd441a908db3562f5c3e813177de6b6a29a6e841a59ee58a4fbfdd6a81c65df4e2eb92108e6e81be37e384c9bbce8387a45df8b4cc32ea626b2c88ac36897a3c1623959587d1216be4ba3abb26b3d4df163fee6862ed7ef5e59cc881c3902b388659899a2dca2e48b51a35c6f7259d7bdd23d47dc7ca82a225a78bb4a54edab2139f5dae85c6071a0b28052da9278a7fb45d2c378df965aa9c49a7efe7bc47c5618cb12afb4608ccaa0aae2033680bddaff4fdc70f64cde6384f7aa3b27dbeaf95c39a6321020105dcd821264424044925245d337944a779203eb71bc85b80cb071469b03e1d7253bcf3f2c68d8f352757b2e36553ac9a402a0b506078df45a5d3d645b93f36b99fbc6338ff812b8decc6ae1451093008b14b3c7b99155e71e5bf8b8d7e3b33298eb2b78da3f6afb3a6476222f369fc318a8ca1f6630310df344656264e210cdc0ff3806ad748ebbfa5d8964557e7e39753de38359f51d61a3c91f8fd585ad70d6a33b56322fa83117b4f9c8d9a88d4a0bf109390da09d2f8543132879682c74020c4e2b8c3fc4c08514e1ae8c49961bcaf2809c1f100d25d84a13675f1bdccc7f0d784d19a8c335a218381c2211af15097f417f7423a527a7d78748c976fe315b274cc746ebd597dc26e7f4e1db2b62ebf8f8c0f75d7921ca773c236e1089d17e3c4b11381e7e1d63c63650b603b339df88da4ec2c71e6c2f588930b543d35266699033578bc7738e8db620d180235764b83b440754166df85569793a7b42093847ff090b135e7be37fd8c7d123c86391dde38b32e9467e9addc60696d8a2174b79123ce425a597f1890802b092717c584638bf1fbe482d2940664c35b6bda8c51eb104ca6f9af9f513a827d9190aa8f9c5b8a69909be4dcea082fd0ad6948abdfa84891bd6b46811a3a84536f0d1ca68dd51e13da3ef300f253d624273c9dae6379d1d5cbaa8683c88814ab6cd542b0c30540bffea6e7410a3e9bbe41cf500959aa77a0aeca2ea94d38331e27b2206c618221ca03bd3788c9643a54980cbc23d3a26a0bea6a010738191f137e6dfeb600d3923170b671d805c1e120ec0f1c2ddae778f9746668e3d8751b8e279ac5cf81ae93178c5db83f1e1e0c5fb137c4ac92274c360dc8d0ec90dabbd6186892b155bf408551416cfdc4fb0c1207e9d0bb35b925798f3f74d41b5961f18042f1fa7e92b0d6b4419cc5ad1ab6038ea1a7cbc0f665acb8ee09723e317dfeb123d381a78252391193bcd656071c7d5305d5e2cb759b108e9ebbb5b0294c8b1c81d0f0ff8885a93f6606344e4d2fef84b49ce9e2c555d7d3211c045d888b0e508ea868f56d926b1b9c6145289e5caa64e420cf410511088d5dffa5df324a4cb80539e47e39437371ed03585533c4c9ec400dfe632baaa846b71256e74f192e18981ad9bbc3d8c6e03b8c0800bf7484143805a4efb93229f3ec9c73ed9894e2a311a1f4fa14a5dd39a81972ca8ae9529041b95a73fa066b04fdfb261e6dea93d29313642101a426c66de51ff1e8b424528f445afce09c9a3f91f73a051f793b699d4427c4609da490fc8fc6830da6c5d3d802e5898ed8b4558bd671d56e331b87013d8a62f7bb22f4fbfe09842fa8a1f09d5d4f104fb1bd99571583d84a7534e695c7c2ab75c00bf532f945caddb5e0b6dcb5c1508d0488e8056fd96b52eea4d2ce13a21ed68f7b38b39e5a409ecb0b68cf08c782564faa3d363f289d8cf482ad7771bdc3d844c2aa7f3b4126e954570a19713f5c196e5de840fef97a0f423ef6ad3221a465a1f276b026b98e3c96e5fd3a8da1833a763fd76236c114a5b31cb042d92dc79d77e046504f87a5c32e65d2460487d876b9dde05284929dad103fb8382a325b6b30a4815bcc7bf0bded32b3b02fa499a588d24faa4c85290d73f08f434b7f54b51b4d71687be84ea68fb81d3a6652ebd2d72b22e1d46360e8c243702278247b4074dc8f7addd0c66c82c5fdaa671df61e8bec2f209db6e6b159f826b58dd5683fba5b14953e0a49634fd23244a9ee823096fc5156067bd6572794ac10d999724269da6a18baf4ab109fa5fac52a6e68815324840b6f9aec7fe6db5b209d49e7469c29e1a99472d70f4a3c324d2cf10bed581f0008e1793bcfdeaeea3102a933254f1863d20ec5f95068673b4d08108a84a970c242a4834b2835a6cbde1933bd2a0dac7114d71336dfdbb9f485594f0992b4097ff4a5ff223a2e174d1916205679ae34837eb9cc7c0e32f751a032687baf2453f0402c5b2707163cc08ec6cdefcf94928a691a03790791a8944d535a74c181ea78b71cff3c141ee11c5c3fa576f4e3d03e8cf8e3c5ad348a848569def1b99753f79b192430eb96a566078ec1307d1b5b83343c809cf60097101e5ff0a2be1dd6caae7c153467a1f6850f2f12e74f9e6007cede5f4af70caaf1e790485d7bb38b6a48637783f2654fc5baebbb6d9c63e34b2140a48f0c11cb10df4e4ff9f4706ede074612879db0248c1bedd5f7b643d30b9b5cf4cdaec84a1fb167a3bd967065e19b36fdc67120a6cd448b347a86fd9cd0a54ee73682efcd65418a71047bc74669bc29abc083480d22d56bc38fb7beb1cb13f0edf60a9b150fe7b2fc28b6699028dff1e34e975f1e51a3ebdcc4d435240e87f35bb41c41a20f61ee6729fe19d60084d687a17d88af324ede599695d51789eaef71fa64f36211255eeeae0f2b7bf25ae2ed36f3027f0f7dc256c4c08ebf56b4d080e20f3969808e939777b4823d40ed5e1c266c12f75776c553c749bab52460c2eb14cede1d718d2bba1f354a813a23f8793dc13de9dda0e63deee7f9a47d6c47b750320d271789dcde8fe38457e76ced37e7e35fbb4be359712c0921db967fa1619f66f31552a4fdca64b7e84fb06c400733eb113f428f4cfe518ed496c41e5dc164ffd1f5c149a6be7c4bd879e1273b16b51fd2f5f7b262debc41c528e0ed72ccbb94a1752a2f841828a9e5128ac31db0fe7d00280d420702c4e655e94e19e005a36c050a9221a543fb8a0edd71242fe94aa219e96404a37094677d689bb007f691681e42e36b0b704dcc95d31e4aa9a96dc28befd391e11bdb7ac68c6f6e7158ca3d673a8c322af238008da92c8b8495918fe6ea0a851238eeb5d5d50774437f70bc0666df2fd69d10ee80c5bc8bd36e6dc97f4a1e9be6f689e3d2bd9f16f78d62e55cff55e1ee20accd38878edf94aa179eabacea1a5e3ac45c52c5a1a13018bee9c98f35c948a1dd9d9ed094679de13e8256f9583a15f2eff9fb7c0649dc09ebd90d41c2d82fc34f8b6be803ab7ccd67a84ba9d09cd5f11fe7d110168886dce067aafb4b6df82ea6ff76e8b3e3e7a7d82f0f827efb3dddc2a467498fe21319462b57aa5011f1755e35d60609e362bf030792e61affd93e0101b5b223ff5064359db9b8b5f893eaaa4f99abf7e7e070fe8d580612ad582dc4b7b6b09cb571a7de94e5ec54e17796e723ec5ffd88e3b430486cd7b3cd29101588c9e62232848235bf199662737d080403b7ac6f31bd40657e1d16972073616026f3ed7c934efa0b65c8ec50855577f9c257be62beac18d4f09bd5eb4fbcb4b25beed47dd35728bb6e2aacf5979710fd4ced3c0905388656cf1fd5aee55e4bae083849e432062196755e76f05b6c8d0743a6e7ee168fb54526ea8e54ab72b7c53fc1a9cc606d9e4d1d8dbbf4359a3e2863275f90c19645d6aec15b1a1837c12019e36190ad2163387e6e5c5a4a8df78ef957c86e56015eb389219c3f344f520f4194619911664552309991bce970c38c256a50ae40ae953b0ee92e05f9bc362fd377cdd5ca70c7cfa142f0e270c01e9233cfcd8ef18ad240a7f2c6da9eedc4dde3c0ce7bcfeb5030928fc1ee0a06196e25f9d8521c61ebc6319aed9d5cbaa1d92874338e3e63aba4ffc53cc8e7896c483b5bc71bf46bbd32356a76a5de13b451ae084fc6eb145a72099b66baedf1fa2ad1e7262350e0ea559a32ccb652241f114dbecd826cf2a06f1f3dc610148f49894f3064d18a2eb937176cb7c20d83ff6d5385c836970fd2db9c5fe698ac20b09fc84d64b4a1ea9e9ba724ff6a5747c8caf3906c9e025064dc0952c08740e6b7923bb05493602810f405dc60baa3c0bc487ae29b1e519a408da6151194e1e5a203285315cb29a82fc03b95ec2965ac834108e133347646d06d5564c06a1cc456825cfbf441382ca814094ecb0d53bcdac5f28d0ede152fbe8cdd0ea3e3870d9df2b89dd7a54ce98f64a5e5ed0437622f39ad8b625f5fb7d09ed2430530dd25420040fb12f06990361418c8c63f3c612921bf0f34f5237c72222f73856ef7e2bc6a6dc324a668b31f5674cdfcf336ac6f39e4478fdbb0b4869de12f08f06e9caea82f7e3e64a11beeb9c0c23bfe5ad6287979b05ac178e252e51d189ac51764747e93fd2879ee9011a15fc0bb4e1303eae6fd7888cf6c68144b8d709dcb533ee6a7adddcad36869154e1c725186ad978db8aea7237a82fb63b1e35ae0d828523570f35d1b850eb3e00f40b08e045a73b3e9ff224399e308db8e5caec8640e0ca9640ed942ac56e1437c28378ad33a4c0ac189022af953d069f5cc15352cf1b4b3decf74da812de39fb030d525eb337038ad84d90267ce25cf95f3554416ad78bf1d10ad80d8cc36dd41b0189f2c4a0a4f4d74f0be49d5dd01719bc105421fd9847478c8bce9383cbb906c4be1a6c3347ac32c2e99b05b063f7a1c135a026c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
