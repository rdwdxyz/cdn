<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4f9cee85c276a84beea0bea50658e82cee314d110bb56909c0222061fefdc2886394b14c46873647c227e3823494ab680d16132af785f45a00aa2951a876a06956eebbde2831a7049dda208f23d6317cf6aa036b5011ebf48028f67a63931c5c29c4d0cacb7a84918987e01fa6cf4384a3eee545d36cd3eed1d2ae29253878f632bce7c560cdf225c19b073465d103c104ee9e13756adb024976796d1fe3ad217c3cb4ae3cec11a68510fd2b8696c14cb27dad4be8c4a58db59ed1880b78a9439d3666e3b13894adf44bdb0f13ccbd95f917a0782327048ee6e928fbae72beb608614a8e662ede62887d082ef5f1f8121d7718ff44f4028288d4c5b6c9295234cc5a658ef745aaeb1694c15512843652792a5ec6d1aa3d4900e0556aa64bf026876cb7eb1a7ea0707c72603110e59a4e6a68d160a93ea7a4ab1e2cb9a1fdb36b9828153fda2de2e2e16db2a9cab5d94262a7b86760eb1b6f86814aad9d8430200bff97915feae2b4d35d18256bbb39dc4e415e0c69946f88e5fed55590183171e1dee844468e8c2d17acf108719b8e1010de1f4d34a3a873f713cf020849ae44f9dbab9eba9b49520b885e6878f533164df837947d2d6edc972e120dd44d3fa534ef233a0975eb6ab0a35ead0518b5b638b7464e024bb9114c0603937e608a620cd2f548ea5f65e4ce925617c0d48952b9173f9d74e80d75b4cf570ec8d401462210b8a9bf2e7a1eb6e9889fc6e9c3043192ebb465b00a15eb8aeb7b710693ddfdb11c0164acd3206245c1225b05283dab518d89977351df22fa8e0bc24fdfc9d56755e487b68b857ebaf2007fabad79f2fdd6f6aaa0b42424f0ad65aed3c754a391f44734e082ffc81a35a12562efec8b3a6da6d23c25cbb9b0a7b2488a1c2b1b1701b4f2f866387e202251d9b43c92f8c0f1d9ec249d5af63236dd570b4bf8c99aee7e960a183875c720419d755aa34248ab4d6c24ed983b11783e3578356f018cb4ee3dfe3d242cf08fb01785bb1e17bf7ed4d59ebb8a71b3739c8a783abd625c5a07c940d8df12f3010d2d0f692768b45b9731b02a3365acbd3a8f62eed80cedcb02df46f109ac2031d5270edfb09af7623aed2d1abfbe20137519f3e957cdcffc5d3d42e1506405cb9306e9d6afa56f49b18acb1e199b6096e65151a0a37880b9204e8c1c779bd8f6abdd616ac0a73dc48a004a09bbefeba1c7df2014728973707261ab07c8d06841b51bb5f8b952cb04717e0005b8c731e8282e23a28eb8b3364b6672ac8e3d2db01501cf8fb93d5db09cb4e5720ca4bc353404380d18348b08268f5f7a518e1a39cc47fef3cab3f8a7e5c18268f77b38a37a7296e39ac8ad8925272ab29b5f07a2555a8253762493e0f8c1629a63a1030ff2f03996ceabe5949b782e3acd502fb9ac49604f2a52e2b3ed14dd65a66234fa0e9387a5b7cd1f5d280243db61fb8233b2699db5855277a59b4e358d93d3f4ba55fee561d605d531bd642257e6a1cf0060c87d4b79c70e4dfa5e00b9818a2b04b4c5b1f415b01afd50aa2f8965d5539b639b6e0bf6773f7cd8c1225456d89e1d7e7d8fec85f3cf82d8a00ec0cc390c35179520d4ca96e96da8478ab770f3f58486e1a8982d47b80fb7b428005594c37888f94a1ab12fbbf7680a462eca9757bc304fe1b6563e69666ab4a9f573bff63f040bf5a09703131c8348b3f5a55fde6ec60571a52caa265ecd88781b90f6af71b25ca45c1f9e6b09aacfe7d2eacb40b69e2360611cad1f58bc2de7ae4f115d8847994058e2179be023d69bbe92928a8aca55ba25f0aad0d72d97d1bbf2acf1492c08c0fa97b756e61b13bf7ccdaadc063df2b432125f625dcbcfb17cf6f1738103ebd6f8a7d3879e77803dc2ea0e8c0cc7cdd371d57237eec38ee17947513962e36c01e1ef23ddc5bf5c684b963eb312d693976ba3ff7a0a60ce9d9757b22e6c08939283aaa164179210ab913c18a108fbfea94c2c9179f6b12e955d992777f0845e89170f163679552bc66786c9e23ae5a45dcce5fbd94a11da60a77ad6096af70d964182965204c90d053a9d054b6afb1d1b19ec7ce2412c5b210c35499cfd00440e8fda9a275bd2b900953d88e362536b30c7af4df13e2770439782e21a368d5e41c625794418d0b4889306d8c09676114cf9224d244439e0366785f88e0df2fb39de0cb0549e777d47d732ce18e963a553caf14a6316ce5889c67682bd64a486a418cff940ce5f4d4135638d140cb8c89581c48f7992928da32da27bdf7ad9cf9d88ffb53f3cffe757d17b1b6091a817d4316aa36500b7f592d0d102f78d86a4188bda0e6463e9158cc90acc092f106ce3cc3eeb371402dfb7801c8794e9c771bcbc25c16230442b4117c6bdde48796fcf0d42211cba79d1f6df1e9b1229c8bafdd6fc5f5f64fe833717986e7058be134916dc4be0347bfc5769a0a96467f1af163edee9f89389f2278ba82dd8ec51025c8e3ad77a4c01af7d2fbcbb70c36d8612d338c79f8f37c5271af3e99daf36155b087675ecef79fed2bf55ff7de3c4fac237cfb37897c5d8c454d1b4181a751d4d955b43085ddb4556a2a1db749328ac400a35c38c837894515cbdd465761fd56d15f83d03f46a9b26eab0abf2e242fb815e9771575fa1f2f39280e0513dd0c97c15ccb6427b342edd447721073abc2ef82b2b43faa6c4663d8a0acc19f9b00571d515e1881f5e24513372082c66bfd74cc21f4bd6e05c5c1d2eea462b86565e1493f2fbd8d9d99f466121e7e14ce9ac4aa10e2aa6fce7f917addc2a9f03febd1b7b9798ae0adf0e13eabf9035fb54941aab1e0947b09dfa9481aff2ae7cee794bb9d00e895135b88438378492251bd120db82b38a270363ee779df91bd757eb780c5174b3e7eefad78635f647347d0de6523dbcb7864739af148e2f25edce925f5aea71962276b2efe9d4312fc7c2147a6d2252d742e07b1ad0b05665c1b47a44dbc822dbdca0c5ed0398409d86cc9a56debca991074f44e496c31f272a4ac1a5104cb8c6d41e4ea606525f50e77a2716924a73571666a009acdd0e15b018f6218ff0ec93640d40259224b9c57385dc1b7d5d7d53b751cff2a1dab55c62f9584399534e64ee0a826f0f3241fe16a27a7fea2eda0793ee12fad07841dd5abe9e218ce00d856a4a0966c822701bbae08012fe9330a8d9158a5091243fbc78550f931fa680adf7161ba818d7b1664f1c45f7069941e533968b69db435c9989acf221622c29f03e7c0eb585f5fc7a7a92493491c92db1192e353e5c248142708d6e4471c4f7749c9820936e07b5017e97651c1d1f970a6124adba5073e0f5cb3dc723c1ae69d2f18bb4f5816cc5f5be04890af1f00ed97284d53af10b19c1c947deab44b1b0c03646089ebde7b4b5ed9792d515a7b363425bd66c90fb7a723ce87087e93afaae34b114090a9a1a3ea069f0498fca4fd616a41c5818457a5dceeaf2405818761b78f3bd9def548b1071c38407009e08dae8bcd310cb04c19b8ee2127b672535832baa2564bcd2094d5e0e8d098153c9122618ec09bd7f85e6e0c3b4e7a6436ba9f373afb959d0a180a5ea00a38d14bb93c8a1f2f770b93441010e92192f941f213a42f948821d0f491cf1f5a258594eaad5bd34fa40928d5033ff2aee71ff78cc844365b82c69c4b13554a66bee9a5d4e1e60b5cd4130c21d8b98d80d935f8ee69b586d09cc23d38aaefb7745191143c4542c0f19289f2407e3a78260a6a31736e20f298ae83a5912a535a564b187df0965d8c9433326c4659830cb2e1d7f4842e7454bac0aecda0699fe8f045f165015b23adeafe6501ea0b8eaab531b53301901e0165952371b7d4e7582cd936fa599d18d430d91572f0bbf3b77b40770baf972b19234403ed4b4c44aedf90e1d8f2f9de0003abc08d9c8498d82cfe7e484325e68d4412bb12c82501fd7a8bdfd729562fa57da33f0ade4fe07ff0345b5aeb99c31ee59d480c515c6bba3c51fd86e0a38dcce28d8d83e2118eaf083b1ccb1c07027e579ebe0611192c6fc3b70431c53f529f4f3763095697e502829f02beb073c9d3ceeaa4e13b106d14dd4c4ad7c5802d931bd6b74881110190032e8afe23ca5847385db164e9f7f0b5a5c880a42e1f16deeb4d89d3499c3ec70b113495d99604c810f18d838cffba52579ff8e81efbec8578092ce57dccb9e3537361ad38a132ec87bd41bc1a174600d53fcfdca9aeca88e529dab2833ff4b17fe881b7095b9471228484092aeeefc3dfb1d85dfa89ba15e851d3a0903ce5f11265a4abcab7a51b49d0f8ff7403030355c9c8b496d45d7de6e9310b2f29c907840a8cb86fb5fe3c87670f4efb90167f9affb1f862d2d1461e81df13819d813fdd93e6d8e625fbec316bdebcf3056385219841d67b89069d27847d1ceef16effea2345a6bf16c231a70128d70f75296950e0a43712937a52505ab83cf9b9a6206c548411fd39b600328c32dd5bcc2091d71653d55842c37af274f962d058438a1e6917595f770b219d2e3c9136f5c5ec6be7bd61cdbc3c268f5a3be32a0e196d7d30dcd9cb5b91c9fb50c803fe6d121545a9586ccdae77ca0e1d21194528fa41dc27f1bbb62026c45319eee9d2c3f45d7776f9399f8f4cfc8e8d86e66adac94b2d2344067927848a73f09ecd7f8349d806c54de6cb2b6a99c20cbe68c2d595f2a42e7b364eb100513722a286447cc9d35d66d353cf04d1ee0579272b4e4fd32671169596119574fe28ad23ea160ca68e213605acc6d6232a17c3567412e0828e3806c7ce7eece74f3f859702fd62078a1ae8f3455328d804099e38512f733bdf571c42539a747edcea223b7b9921be2eb45ee2261460859fa6bdbd65dc1e3d3b50670e74daf174085cf983220599506f6b0a2469d2773dc45af5429167793261e1835c52125afc226368c072f5dadb24e8859c7235178109730687906ee270de804dfda2164a4f53f69c52a4a64131eefbefa6afd762cdb8b407fd56346e2b13b954c0af4214d3560f618d4865e4e258dd93cdb9206955dba4c3d36043bb9366e9986337e692c70482147b6b1f71c6f749e4d9a6fe6cd7dd27f3761a62ef649b87f31ccd0ef4ea22d910725ddd1fabe06aaacac98a4ae4856109e89f35f470a27e5d2b51c310d3aa00cabe4a0e1b6268af7d8405d171bd4ca6afde18e98378b7956f3353e326148acb4e23bb51379f632a66a2080c5aaf262c8c24ac1aaeba77e9c7085f528bbfe906249a4b80a94068542ebd38a1748caf55d59d1db340fe66917836c8164602b66385d0fd2454cf991985746601312ad34b36f269ab29d7d8fb49541eb43e6bbf54ce7d192fcf149d94fa8d739cb82966b5a12264036f60c3da97daf25dfefad5d455459d9254780c9192c8a3829c6126da4097fb77695c2b9812c2be75e54feb82e948461baf507499bf633adcd0ec2c98d1d47043ddf3c4fa78f6b4cce2f6e670b0c48eba171d29269d5fd39bd01f65b090b4e6ef3c324571c8fb588441e3a955363f081661ffc81f18b9756b2c6f19dd3631b3e5e0f600aaca838d68dcf1928c03af7d579916b005d683ee7bbbf28bf7a4eedb3bdacbd85b44953a3bf7aa465d92896039048b7bfc46b6679542d16e14b774df5e68b3f92b3a44cda74734c8fa7d506df2f445ebb3230209851ba8e8994cb3b414c4bf87c61dcadcea336c1f0224c0a8d636822a262697609f4f2716af1365bd4064b892b8441d45727234439ed576cf56ec2cf60f8e5923a9be8f23d71deedfd0ac0767fda846373c7589a349e4261cbdfa846b0b2260d166ebd82a1b94e83522a7a4f951dbc7cceacacbffde04f4b18c960015a38d787eaeedf2fc7d7f76e1b91567cd3946662ce413b30bb9483e669c50e4c84343931772174d2d2c5d39ea2e67c2f77ffe4acfc219a25af9e12cb34e1ef71651943b6d5672c2ff89f36afab2a783c80877e3a569c93a0aee2e1d461be940014ec90ff048a6ddefe604bae88e46a389db3f0ee55532829f21b186eee32e4c45c24022ed48d222da32d7c3d37061bb6b1d6164b467536eadf6b27ab9046ed69de75b276eff4cde73ef26e11299c722e81b722b81c766c9ab80358dea8e0a68f8ed25d7a8d6dedd256c06728c3c190b6ba4599d50d96652d0aa0d810070c7c36f5d413ba7713fce3978f7e2aea9bfa9e11d2b729e0c44a313c4de11b0ff430d0a0d6fbf13aea4fc497cf15c1a21326f932297b9fb59f1399c4f0a62d634c767f5534c8bf85bf0ef07c0edb0377fe7a30f89ea864aa50dda7bde2af515ff4eb516264f0861d955f82a21a3e117faf6ebd3baca544bb43d5013d60204b76376207f81fa3ce7394fe25866eb85ce0de4f3646d2eaef072eec743c6ad6cf57eacd8be3ff05a3f1c1545e7869a3782310e75f237c6cee77d62d733c02a442ae0689b62b60102306d294be1f84b1030b88c6fe7c13b57e2b96dc15e7d6cb9d862f94817d300c78d6edb154ee9dbd70cde17f8eece787b8e4832989612b9268d397ce808f1d988c55980a6d6b59eb927366b869973946ac4668943a8d14c60eb9b635c0d44aee5060c01b9865a9f919df8fa1f7d360ac954e44b7c99ebed24fcb8301122efb10777a88dc6130abc8c49e97e848dcbf96e8ce56dbdec470f625e63376fd0e6a68a66a545f48e57e97a3e219d93f7c29678a0cc0bb3d5c7d278f61b8a86a62aa06d9144d7472ddfa2a5f45625bddbb6b683a42beefe49ac8937fd1cb54626daf56986a7b6c724ff88cbb8e478e8fe9c00e0670a655d7e8099d672ba6a445ccb246ccb85a87b13dd0e2f984e243e6f5c86b70bc5b7d7facbcf6f9ac9cde9120764bc9c4ce1392477473ad414314667145f21277b3c55829844fbae02bd8638f96c7f2dda9d0249d8eeeab30edb5c48f690db16f6006195476f39e666dd98be1b8a4102c1d183345198371469837054c2005101fdf826a39013853859d2ce7e4d46a96258b31bec3af194ee19e35b94df61dacc037f0e255a0912fab61b7063dd484243c1be25b276521b05790886c27cd5c389c07b2c70b32e031c73168043abada87950f5f8702622816100c185a0a9163e139adb12b4fe22770485bc4e9f9a479dfd181fb086fcf5c03f8a6de7e2e4482b2cf607ce881fcfb99cd7f2454648b4f232629bf2a3ceadd5e580dfef6243b6a2c8f068c8470dec42e17c0de2ecb607f86d92ff778e0dec183bb7ff26b6f1f2b5c799ee518346753a68871018689b2990df88fce7fba72f5f215c06d53ebd8cacd3f65f2643aab8e1c18ebca2c03936fc373ceeaaa499d8962d6f15a0714d5699736a1e908f07e8d496db94e42b45b98ffbfe42f74d0b3749057acd0b940a695c649929bcc0906113cb723cc6fb98e0e8f9d67e64ed35a2430fa5c652c1f001fd666fe296827dce94f9c49781f3b902d78d144aeda244a6084e446335711b8276e12751debae48ee44d1ceca28ae4147dd813bd86e39ecaec2cb07873deab60ef98c71b5aabd177bbff2196c444cca6ba27367a8570651015a0d1008c550a29dd6d77b974a8cd6d7c39d9d569ac1eaa278ee6427492e82fd4cb1a20e6db4df7c7d5a7884cd43be2835a2ff4af7d48d74ed713ecbf5d127b945cda5c69569fd888f5c5c6a5e9819657f15ed068741e9715f3366384156a697949c38a5f724db74de72e49ac3ec4eb176d46ca87f48115729cfd643d66aba7e48552acf9f70ccb4d85459499ab309d0fc182bba2a750d05f9433087bad3b464643be5e1ea9bbde09e36cd8b612dab720bf83e274ffe1f52234fb2e68d43b893c0206bd143f3a95390eff8798dc7c617ded7434b8972110cffcb8a5d732b3589aa9682cd7c660363cf7985d402302b2382b6db0df4cac327c1adebceefe2f7f4c8a331b3d49f4cd5656ff7e774944a03e167d7cbd229adccfa8422f82e1620e26b79f43c737854f5050e907db5a28e5bde9ea0cae5b6fb30277109ac8502191a87be447d855b1bfab70f2a59dcddba6e10484ca9511ec381632891bd28bd015c5102badf981b939ddc8068423741a87938cfcb305bd94f9d3097983f4710178d103278b5e5056ca559e162182b70edccbd9745645802f306bb187391628ff38f15829c3fc355a30016f09fc06c8dd718d4589b0de872835f527f6244896557be4b18167d9f2f3d0735d1f324c5288bb676059457c40cf587cea09bd2774b372b1ac75f8cd5423a74f9b9b11dda2eedbc0e520546105ca4574a54f2957b045dc199ff87d6cca5dc9ad5d4412d805aaf713e7ef3bd9efeee810b5fd7cfa681d74bd902b7620aa2206446bce8d82cc85b36deb09ecbcb0a1bb92d532c57e3a7b9aca53bad3e77bbd77e9307c1ebd2a6f7893e754036e2dcdb483531b9d8b5fce14cf8d6bb614014d6824930fb728c4cd24cc5a1539197b4f914e34ad34f18e6049d2e08f09773ef5fdd1ed0b2c1977d85b7dc3a760960417fbaa59515cbde5cf5a3506372d12557836d5e200e51f51564206f79cc396effe9e51cdc6f59531d87003e6c348df148174d33d4d7cc9bac93c53f3e502df80cb8705643078888ed995c83b353b139035450ebd3524927d1f6ece662724dc75a87694ff35ad95e2479f9864a81d98eefa370666db72ecac21f2febf89eed6fb93edb12c336599293797fa53b5b5929c304338c6d3fdaf87419686b045f5127594f8fc99f1326f3ccf7f20b8f6c995082d4b80063c833b1a1ce6cd7a9475460a55692bc887d3fa484c62af6aec73cbc853ffa72ad51d31b01df179398bc6242dd79e27c89adce49a3e1cc6917341c9aef48724515a3aa15798e17c19f52cc0a6e45fb801fbdcb384c2be5056b35dc5e0cf20988d87aec4207d20eee0d53d8ec45055adb5fcd37379a78b693c8e0fbf01eab99daba32ca6a63f3f7edef25ad07ccb5fdef7c238304ab3b0c56c668a9bbc486b4983206d991bf5c334527d4cfcd84411a3e6ae87cd931949b6c4cd23362bea3f5d19fc66e95bc64a83d5543908244bcf1986c44e3138d003b8924d1bca97e57dc6fcfe8b822a477c1d496d9e9a0102a7bb3abad2094f2fecd8325b20b8bcaeef36a61fb6cd1b6597f4b219f331b0e88affcdd2917a45d926e92fff7fe3aeb365ba702edae4625981b3e094c65ca88225737de8e6c240e1fc592b29e4e0068ea2a06358708f9b5a3076a07a9f835d8660e5ce3154a796b6d82426c4cde0b182e1b07a193a6e5c34ffa3382adc3a4e2cd3a251d131effa85f40402255620bceca2dd49bfa26e5af73fdb6a161d2965cd82f5dd0098a1365facf5e64f3959e944d07433805fde030e0ba82d8a8619652b6441ad0d62610b7ca46e6dfe84c58ae3ec6f862021050db35d9a04aac4b3eb824ae728ab9e7ce5ee0c1002e335a94232bff03a8609e73aa4a18c30b03f0f3ef69bc4e196c284e74050b973438b82af3cb954a70cce0422f589c9117a42d7858201fcc2b2b6d50e2e5e4dc59229bdf7c42b2dae8847ac39d42c4e987a67e8cbc8cbaeb40c874941af65a31fe81496d5a123e593131654e8948aa6f316ae3a190ee9d8a384bc76d81215a279af4efaac9fca4ddd11b87c6d163b667f4ff248c58dca03102c8cd91dc0f8dec930cd006a58da127cbd37419810b2c149bc1e060ebc67be3a67a5190bc9a3f1b3dfbb0b68d94168c6a71f73b523c95ef94a1ed182c4c7b62b6ef26c276a5a90644a0c22a1a469bce9afd4d8dc9168d64a7ac3eaadf657110dc192439f865cfba0dee6c520fa5096f12333c6facaf6bb4fb9740a37ebc29172c6c7ec7d6aea009b218a8938dc2758bb7cde26a38b856a8ad2c09a3c9eee7a2be31a5eeab59da12409f85f40aa1ff8762ee41d7d67f92b229f129f1ea9edf8c66120a0de51164fc61af1855a061c3b2e1995c137a4e02241e7f1d678d10350cac26e33934f090f5d787cced4ead89fb97bf3a6887a692f98aba258a4eabb11ab13c67cb22969126a875a3e659b6e4b21efdd30ce92e50aeeff58d30a4202b96e812ab16d5d3a6d7dbc692429675d078e11a2ae01ee3be719062a4954ced38893409b62c351bb5510eb68cec70de969c7eeebe2f85fdf11d7875cc08800f1f548130e3a02184adc4bdc85538daf8cc41149c0b16d0e2a98000a4198c9aa44ea997ec59b5f613fdefcad3fb30566548db29f214afdf0ad0af177944596218bbb68114695f0d4fa49ea837dc1ea4f0477cdf3c2960c8bc9155d42e7ec616afe379505aff837febc62e51cc2d51d6570d3b3f66482873921b7f7da52cc710fa2e5f26c0fe1d0850ce68f67c194ea189bbe68afddf0bb36c9cdc08d5e1f8eff058b14a24039b4c655c3b4af2696663a16b60c567f70141dc972abba8ee488f6e14cee115b94b0af370b6e90e449f3cceeea901a3431c2a2d9716a8ca4f1fa66c0265c7b80459209944b64e32a786100b3e7bce9dd1af40de64e4d03100033a0589c6cab9f5d24dfdfecbf191b5d5131f17de65a273663149bff83e951546cef5fed3a7f7d5c7a82e7c1223d9fbefeab654eb2c561fe287742d2bdee8aabe52d0166812990e59b4a4a246be0fad9a9bea42cebf47100c103a4fd4dd01137e8094702fb6287abe5284eacfdafe1c8aba695c1bc47a9d3c9c2c58c7e6b9835e9ff4b8af5ca8d1e721670fa6979d072c441768ba95d45201478cea73c5686327359c815dca42498ab1d0be2916a742db75424dbe61aafb6189b204500350def6a3a9dcd21a72ea33bd5e1258352a96bcb480f0103319e964b1e7816a1e4454ec79f2bfb67b49c18ffac19c3f72bf4d18bc1a1855a540e4419688921b0061a659d981b80c09011f361f473030afd461732584a15505a79f14bd24c16a0b0e051a8583d923cfa8cfc0362019b64aac272dd12e37013de807a6fd7d00b21a8bb7a166db79f3a9469146e9cc9f9dd09d2a778b5e83df411c8058f64d0fe903a80adf27fe073f75c11a301e483b0f5af85171d4c39368fc1998e613df5426e3fd43cdd76e37106e46b25cfe4bf1016756e7f4d0edb1494d598c7560fa9b1dda31cc232baef6a6c4fe8c8f1c93c4b65b6cf15fd7fa19f67f499e4096252da889e9975fa9ad3e02b55a4d894a1919a00e3afca27aa4d239a86f5b22253698a4a6263e7b8502ff7b92c02a8ee0f593212d30d927483d96f84c214d490f4c414c1edf83554babc4cd632302ab2a1bbdfbb36ff6f71ad70ca94b0feae1bf4897e89f2be223475d148b1da07793f2aadcd16121c45fc15eefadeff45a5837729dc49f9d354f0ae92adc469db3d853aae2632676a7689676f1099a2ad83f2301b3caff23582a92e09a5069e50dbfa2c3039efe4966eeb39f613e417eed3114c404b0d97e7d05a6380754874554d441a66628b2aef166ffa153b84b928637001e45b9eee3802034206bda219ffa35e8233e7fc1447e2ba97ea2bc61c01f5182b0c716c372a8865d167f0ad244a9a6eaca1a756b1eca1a9db3b476636cf5b09e1b1581abb8dda7e9f4d98452354246e49028cc2cfd0b2bd0dcb0ecfe2ce00d1d8b6eaf3b2972689148a9bc859e3f42db43353494332c93eb7ce04e97d393aa7c2be42ef6d163b51985a17692255b12537a62721c627ac86c7e1f6832a233b6fc8832c75bf8a81bfac450bdb5b05f878e9f14a2747a8e60694541a6ac63210dadf86e10f82b29ebe4f1c2d494d22d770cd7c229abd7c2814e7640333c35939a83ef0536be5dbccb6e656e43f3ccbc47b8a18f802f3ea9135008beacea8b739b46d512871ad541c987bcaeea7b679130f886e7d74686cda2331d959c1cdcc3125de96f43c1927379a38c341d907263c60acccff0d0f1e75fc2b06349b9f0f834499a8957103dec68aa780d9dbfd19ca186341fc9909bfbfcef0a01426044279ae60f5077f4e410d4965f99a54dfc03d77a666fce4fdfacb071029de45c62660dfe89248891d6c67da756bc2baf9c29540bfd42bc94ebce4cbc4c261694a3f91fba1dfbc93fb8a7796d1a3adaa81733bee3d24f10db5e54eb938ea7190f9d4247d97c07a45fa3b4e0b83880b7064335fc9b3bbfdbb53b62b3e747be2d6d57bd78d0cabadf97c802640345cbc068f6c324bc0c9fe055de1d30ad8c7c2496b1825ea393ca30771ac17239a6ae4de50f566af88a95104458db6b848ab242165a23e144255977125e264fcef2dd82818e34c75af56109ea54719b7a9a99b124d6054fed2277425fcbc13296be2a534306586c798e37c57f64a2d725e367fe67cbf67c1ece606c0b1c1efd38bfbf3f90d4792e41ec671646876261166b11b6b60ec1cca147da03506ff9b199052f5539d0b04cc79f906aadcc895c0fa948b56d7a9495da838910faffa7b99bae9fb71d48f8502cce9ea94dec9aaf6ba836e5d87032fe0ada764a650531e07545ebb4c3daf2666bd0f7b901e49f0095af5d3902fadc49aa34d940868178a8511017d5a2a3082a9c2da9219be18b122efb8a94ecb37b8a421ba537b8d6c839bd13b7db605bd536b0a24622fc907c632e1d22ed0c6d167eee369a1965be731c3d493ddcd1acb9af57e5456d41bfd95177ef87ef2b5f5ae8b156a322a5113ce82fe55b9ffa9a52ddb93fd806fea03b581e6c2715c5c30a5d0b963ca39749d1c1d323a0059055c0f471a8a4d38176291095100dcca71142e8a36ffc76ba0cb36567dbfa3fa710e75cdbab0dbcd026ed319f6bdf4bdc60d268b708eb659c208b37ac878976631b043a8fa93031800a347ce61e7cd4ddf6ca6a59401e94f6346fc9c572c85a86f9cab3a7130f965ab30579993f4b90bb5262d9439f5cd9cf2fe5326a3282709484222f049edba8dbaf67e88355070ced18117ffe5a79c2d2518d4268cecf1ce2a9e50e3c931b85ec39b8417ef2f915a76eed70e60ace9035d895eb20d404f36f04023d697b743f9b241621b4c18fbdfa8c7234e9e3164980307ee0f3e1d95f574ebef18008eb6825c9bd9d064f375eeb00f0655b0422e28da8087c043298859af7662409b9250f6de209869009807e967df73867ef8d3e47897f1239f47d645857aac9a37ef3a601364423eff2239edd5f2422e0796db14e8e731c9781669ac71710411c757e2a4f2e2429fb7de9017e65b2b9b1abffc54d9416cf7f7cd439a4bf57af8e0b35f80e534fb6e1ccfc9b9ff87866124a87fa4a689d3bfd84125678924e4d2118fdd57e90589aa1b45ec132ab0e5801f0c0d5b797ed69b487cd41fe2a5b665aed8e0838fe01690f46260c350b86acab06ea52ba932ef3ab00463297feb19d39c73e7e7627a438949948004a0e9660eb5bd84e759aea5d25081d089df5a861c212fc0686d84ba8e7b01081e0a874083120ddf288918b5aff7759911b37592c6af65648cb0b731171b091054a01fd629a8bf4eae1781bcd90873cbc9cdf10ff8f170a9ff93bfa3789906c056ff0dcf4f7983bcadee75869798ef1f3ac37ed6a31f5267d7220215b38eb40f12e1811953a6dcc959f99ab995712e9c865a278832bfd5ee6a1322aeb1cc3f755a4740f68037fc863fb38405aaa72f92c1de802494135df44e5cbb43f2a6617097f7298cc5d14f45c19755be8025bba994e3db93b54518e9efd5936207946b38cd10e0a3af4b90ec4145fdcbcda80c1a5f8a65d84071a661ba6162d8d5c05896b733644dda0441b0fdb826df9b1d6fe3f09a3e4e3722f386f5342c8c5de448f893b757df6cb3c86d4e536e68afcccd1536336aa307abf7dffa2e8d9fd2a3af7b1df0120ea9868f1b35c231b90ec84013cce12c48ea6e5cf7180906399205f7c387627f3e68ac6bdb12980de8be7eaecac26e3d5382f04d8f8e58d93112862bc23efb2b1a6d0650789bbf83a151b2785e25b250456c47858227331bd07649337c81124e81ec6052188e0174b8b6777bba92008b445b69b791a46ed26d59c781de393cbfd0acf7495271c969b90eaf3f1c9031117823dba320265efd43ef9cadc2340eb3445ba893a3cf1a643f3515093c0c708572adf5d804e9bce5edf87641beb1b83dae8d4dac1da6c3fef4e5350e4ecf291e293f0bf8f1211bedbfd3f2f7256dad383f04eee85940eb2c574bee776ad106f50ca18429d90e51f0d3fad44cf31b3d6456f52f022ac3459e416bb39ff081eceee6d062dba2cdcde2429eb82d94476e6eb224c3c28fb4a80e724a127d2f43f60e1c6ba794797e0b0640529f2bdd18a760a30320903318714cc4a6b020eef4192ca5c9def319b149a3d65aae0a3270f6bb835e4d9dce45493717d2116da3f69059100bdf6fff37a6c8750dadff0297abcc100f308c5a838a90aa0d3150afcb39513e947281c10f618d61d7f2666c8ede3525b5565cab01a210850dd05bbe33b8158257072de3a4e10a8200431891bc59f18bfe21289c0f18cb1e3ff78fe3553f300816e80ddb6986d59bed96b6c13b237ad79e146377de01d4178e51a7f08b4d1c39ec4d315f8d48ad4f1ffedb36c9ebe7e4a22f3a676c918c2b0cec9611bc2fc0ac19730961e88cad1e794cdb352c23c514a8f4783d2006ecb84c9e3798e71c08b1273198e980d8e1cbff8691db1f6624f25ea48aa85271efe0066dc698fa1903e057c6b2d52e3e8de104f310ad24f88645ef278d20f7e9b613b2153851f5bdf6f111dbd0d3460816f917ecfc75622919bb9f70cb9849c3e1ffa448360ce8aa6fe96002e6bfeba3dd22c5ffcad6e8299ed4c3875de63addad7cbfc88dfe8ea4facf9d0759166a68cd2d255f361f4c74440841d43085a12f91048efe7a7aa832bdbbadeebef3ac4eba7169c739081548e0283c3f2137dcd46f5f0b36905c79e616b5882769d9c7301ef8445be1a2700dbce2544765dc0eb68af40f0c0467a32d555e9222651b069c423461d086344b062f90e0ce84fc0be649d2c56339890153e1ead7b2bdb58aaeb16a004d92f87e7739e11999e0dc0010b3047204d8b0fcdf366a4b69690d0bcdb7e3c8b840b39f93086ee4181b4049c0fea43da03f70672f4d89b4f741ae36c135928e1fd798fe4cb5e8c9c433c934e702ab81ecc8627502a47c86e41e5ca44400b21675f4d4f0eaa340eb4598eb5ae5238fb94b66c406af0d74b2d20ebb2d30988bd0cee7948c3711c49a8ba43729ea087f2663644a5e6980172585d5ea06f38726a5e606facc9ba58c561c6b5987be0cd98f533bc7197e7793f9f60c6bb43f91528f03a6bb8d44e1548917d7294f09198e0ed9c965e30d102e40ca6f9cda8b7ac42cc377119e9ec6efb36acccde6be51811e2b59253c316b6f4d1d19b351f02b8c4e087e873d55048e96b0b6aa4ff78a660b243496d4500d5d1206ebac73a089176e9cb8604c29c73a1320781f39fe5b815ff5d3e319630d8a47a1609037a9d379e4d04cfac22551bbe77cee08cb0f442e1135b6be87c0bffefe13c23bd5c6bb521dcd2564ac045a3f5e7bc210a2797bd8fd6b1ea40d5b35685250d430a9566d91b2f66d87c3ec986386099dab5200afcb819752e7cebb6810aa05b851f3374cb719ca83a166e5494f53e63af3a274012a56390668aae57365d82130036211d37213294468fcd649792858aa5040a68fae3bdd90dee7527e196c7c6a2b1b68829f3d0980204bb5c576d9723bde1f5d3a635a511d3afb06d5eed93eaffe3bdfd9649f8b789759234974e93528516e2afd013636094f110cfc7403a725c9cecd3db0e8318295a70cb33ea0c70cfdbb45ed915437f9aa096cdd9e8f474d14c342d50ed05d59fd9b048c79dd680b4590b52bf6241ab322cdd3dbbfd1eaa94e71f2a426168339e325e469931d86b287d9c4a522154fcea6c53bea9d5d63843cbe8ed73b1e390c6bd6e7dc63b3d008edd5e2d21813e0d7323ae40bc0ba19bf1093d0a0ecc48b88b8e702a525afbfa2f15acd9283d0905c959557bba7b95d9bbee8daf008af47c8f3b695126ca03524a7f612555d002398319ead4baa0750221acca5410dcba7a3a93c2782d0c679d38c4f5f83912884694113c977413d6bab9e3936ee336b92dd46f033b3d190ac348b44f1d0b1f13d803c6eeb41fd4b30ea5cfeeaff84805836e4430d7cad25440cc777655cf961f5322ab0e41f6475b043a473d9672e82405ebee0d729ba346153cb71c3d8c67b78787f9a6374602ae6bc714571ba8d1f2d29d283b901cbf6b8f6bc98cf9da7f3dab5d086b8e22f26827f40c67b26fb127f165d69f8f1386bb655e825222327d3a4e7060a0478186e501e236185f10d6b7891cf702a0d511fd3f07bebd33860788983d8ba171a794264ffc4e82a7337d923f66cf2eff510fab5d99417153f9ec8dfea3ea1604d74c441c96c9c00334b7711278fc3feab7a8521cbd75e3d5d9764b4f0ac845d416883531439853c410edda9444948da0bdedff306c2f5803fc6d351e1719961dcce9c6537bd2413f6cb24ab557763053f725bb0f3ec9245d4fbe5acbfe65bb9949f25ce9fb467272a3c5d8bc3a36330424e0498b4a532368d5a1945c90519030137bfc63bd745b2b1700b199f69f70da615219bed2ed6abf55421e5b12d950e75b7f50af88a8a1319efe2b12c26c60b9551a9141928e65d7e02d79c7371a86d1215254270ea0093ebecf73f1bb83f26d045d03d2a4763a9dd7a4b877eaff13de2624ce8089c4ae57d29e834e9e4a8f33f00e179060c652ee23d29f5a2908ff8474fcfa08ca51dd0f9abd19f777c6a89719dbcfc64f4412d197ec394f013c336ef4dda71a1e5e4c36b8241be1f70824100fb6a5c5c50f191d6f270b47658c6c644b694e8228a37f48c647e35682a112cf3ec57b4c43e741d094d5d37214beb144dd2cd95ab3bb9672165271b33adc07e8f9f5eced1b4c59d4f91da46365661545128f38fcea6f86d09af20084bda317099a1959514d856ed04c159d1299e47c4090e561a3ce76138ff9605b1b05894c652c556e5c6033ccfb252f6f4ba65b65c94f13320adc04331424325c850f079ab569092c3043d368375be0c37f0985562cf841bcf63834f9e08b17690162a750af95130280176ac6da658ee50f0fa5fa6e1f988c3d8ad39befdf048b0d479bf14225df1a55653753017f131c03319518d882cca6e9fdf91e179d8c2b33cd603ba16fe436f0600224001c0ca724374784b6ffe59aa88e956e2d7a6349ad957dcd10030e44553a0609ed746e8cd5d31ea2ee74ca00c70d3b3ca1b0412f7d1708cc665a1b6a91edf7d5eba9a41e64559b2e78ee42630173afb1b1eab30deee2a78c71e83fc997d328ee154472beb2a707f38e6c7b2d9dfefeb3fdce51144896559cb25c9bc86600ead6a6112eb7982b14c335bf0817f4ae81b8b65c38a9a0cde1d24e6af5ea97d664ef6aff02b51bc80451566a5046c5d6c20b1c9000005a475afdbd6a41b37877c7421d76f0dc159498c7810f6f5a53602ff8cf8901d82b42fa66c20325986ff48eaf5d6b417f1e2fb7df694ff9712e4721c865589b901350a4d99d69639685bf8db38fa5ff324f64f04ffee18f07d56eb5e012182e1e079de76adc8ad9b2786c8cdcb44087a14cedbefb76fe4380d5e01854f0c696441f502e942db1f4e81c463ea9dca8be310e4351301ac5bef5ce7dcdee84637f6807be5556f6dcc96f60987157e40de4ec67dc5feebcfa05d1c529263c348bc2f1d780e1bed4536a56419d1e7a4c8a93ae7bbe90f013666483c91e5d1caf658ded68fcd613374081fce64d942e3699e827abf3c7f910febec60d25aef8898ad51f4f7af46baf7e97755c20146db98e8496c8d4e733c39275fa112b22890ef5bd6ece39a707a3fc22dda6b94bb91f764edcf0bfdb84adc09d78f64bd48cb9d04d6f4847a243238bafa753e428607bc34e354b1b26e8296f1161be0f6813128b7f6347261fa47ffaafe5d209acbee15cdf07e651f79e70b95e3f7a82be76a046b01f7353fcb814297cb44fffa8e5490613bf8fb8c225f3673097f32484c6b35cf1d46fe03daae8ff5ad34bef87ca0ac57a0e6e2a57710b817d9a5a8a42523530f7a2fed63","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
