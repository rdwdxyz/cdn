<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ff0566d7369fc1475232ad792d7b4997cb9a6a0ea58952da8302b8424c23d89e6d1dbdb8e22fbe6607b65ea5a93a4101d8f4c0070b6d610341323ae664263db86c315fe31c6398affb5e634e8ee3b0af019f8385eae39e0708abcb526ec3c66594bb3383a4da4ab205d2002b0c96848a19256fc767821d6e2a9146e2575c2e6f54a21f6e56563be41cd0c460459132c4c401126eb2539a51697f4ca345629e51a578bbf9732988976a7ab7ac9b3bd516a1f55f4ad1a599f2ac37bd7a1f191e38a5627334d619f42ed98936d35e2c225a684f4e7c8a80f030e6437eda8f7af74c2fa19b5bd2b80e53ad530e5e1155136b39f61086fc9b5e58a4814dd414c39ebd589f71db361fad4416184c2e7ab2bf10b6e9c4702c80c4bfa19b8d91534bca845e67c9b9f8c103568ea1d6876f688f79c3a27e85d23e73a2f8fe0dac2ca5ab160bbf4b4250159a7cf4bf77275d8c74ddd98051b2307b6ac6bd50bd60a0c3c25680e4bc5916dad3f1d0b61442841c0ca436f4a89bfd70f0004d92b1112526bf7a344264f125d81b84e823d64da85fb4b4297b6df1a66dae1ffedc933fa0560782c0b986d4026491be7fbd71a1dd873ad40ed88f587938c3fedc738d0e8f93723c26d5dcbc9e4c92596e6982f1c6c2e36614c3b781470135a27d6b5372cdddc1858aec8faf156ca821666fcdd84464c55915641ec64e5d28ce8cad11850149ae507aa2e28632728a2beb9f7d219b29225005eaa436a3c882570c2b9dadff4c2b7ba5fe183cd2e00d27b32d7eca5217c4e092cf087b92cbc01a343ef81aaef8dec5fce72a403d0bd31321ea4b7ed8e5e1036fefc69a16b73de3282187529335f096f326c44cfb7c019bed8fce3420013048660fa61e3d80b6236c148ba007083b826b25ac89d96c604f8f65dfa653ee4e972444940e4da7037ba6b4209b5ac942bda339a5ca7e663998337f039064f76544d0f12a9cb62e57fa969f26dfed72b57b5af2c1b91ce0a5a1205a1ba6fb26a50ad1f485e75bd528b35422920bd9e828a02a90c656ca7e8ea9753fc0b89a4036afcf4d639b00f6e2f024a48e65718444fcae627328d32eb42a1d7a370dd053956a4c5574f65f6b507fe399ea9a8c069afd2194033c752e7d616e6da94a5806013fc225086931b35c2830b1ef9b0c19f0a853376445fc86724581ab9177678c6a430f6d2aa3a79025befc1ecfc0af929bc0fd6e7cbea4e2b076a60f4d0fb84497455436ca1de3cdf93a6b0bc57c72c51ccd3acd5b6fd4b94b429fecccff446794696b3098aa30143507c51ba0fcb6a107d262b7467738ec7369c8acaf1d72875c250cfd21ac2e5864410fe7c76826e73d4c32de863de52d06c277b326c80bf1f461948f57883df26ae9f78ffa12f065cd6bf22baa74cf2bc71ae072bcd142a2f791e6425920d3cc68667cf653002b2c6978716574f593714cedeb35e4334c42f16a7f902c0e36c000e78db294637e97b15af8945249069e79328804f5ec2da72f9fc596285603dfe357e80ad27930f7effaf0092d6828c8437d5a26d372c82816a5c22560c75a65a9156d5dce26de7fbd2d427ef71e159d40c553caf6db624a6c3936a9a15a0826553834a248f023ea627649966062e82835627fa9e32b8cc87f8141d97ff794abc6cd79fae334b7c79db7060a27aca6201430b39a814108c8488e683a1f6029dabfcbd2413426a4c1548472c46d768891bb5efb18705f42fc5a240d2ccbd7a8978432464994ccdf91e68cb18824f9f25fc8bdfd474febf413afeeac8098db48fd9650c29373bc3870134055073b0d9136834519654b72840d5f8e26fbe944cb153fc9c4be2e99a251996cef97f5a72f2ef781a89ce76ecd41070eb29f58c9133488edfb8730401c8090fd6a23310ab8a60e001150105579c2369164550cd9746a4432baea819b4605e25bb56a9549c42d7a87c74454b26b8c59d1dd4fc346a2821c927c6c17a3f75bd7a29ac47b76d47ea95234f60a4d835ea27c2fc8314198b1cf0e85abd2d7751a68c4b97e366c67cb1ed1853f9c3dbb333ea931c4564fbe99b75fecf3b0ee68563eaac01977a84d82c188177ace7b2da277d47c5642a6162c56a0f311a9495d61cae3a4fb51dd86274752df4c2038e03b7ca01296e5dcdd0a9a845e3ade384eeb02671be1152d96d2d9c91ff9bdcd93c2b96054757fab3873f4af2e11abdec229b0b5bc0c9d5367c78929b5f17aebba8afb1ee5f61f11248d58fac9def6e315f52148fcc07904826cd53ed26be3a6d769c6b521d4a39e3d91a79d76c72b656a85fe4a84ffa349dae42ffd6f04a7a3e0c6acef5a79ed80880429623a6a83724443a745b4c71e6447329aecc115b8429ff6e9dd6fb7aae52e547e10a72e0683160d74afb3f5d2dd4fb690624e5c6796d081f90a21308eee002707ceed75034c0dde75f0315f1e7a872267c235916c9b27ca7500d3d381c3897b091ea63cd7eb09f12a7a4c98f375cbc8552537b43a2aace82a1abdc85e00f8cba706b4556a4dbfd1dda5f4edd3181d8e12e7067beaf4f3a40bf0cad4218cd6213df1c445df20233761c010626d9f437eae344b862748e26b14a7b7bd7110e04b2891f70cec0756c363a05f9ae715332a945fc656a0de4f1d467dc037f55b59d3cd147e91eedb9666d5b33ab95a8da405d6db7f03007b66d321622ea6a5d55a5fbcc1756deff3bd2c1034404c73aee9cd117c2743e389b4a8ef8af0bde5690751a1d0f300c5210d0f5f796115c9decb16fc213ae725cc6d1e7885bb375006d1fd955fa3bdb61fd932cb9bc9a0b0f67f8b7cda8c85b9bdfbfb7b9d066748f813917c0493e9b1f6faca955dae626a30b996ede2db30918f30471ca22f1156dbc4793b68af8cd8d60d2af15816f876fc6952fe64ae28cf0757ec8a78711da1fee62134bf42d7e8ae307152c8cb6a51bdab1a3e5ba157e953a108f793ae6ebf34210f9b57c7cbe94a3464b15992d0893401843f97800de09ed07b9badca7239a2c175924aab1455cd66873ee0b38d303aa593046cf41246366a755fbc9ac7782f6516f1396db609b9faa69e8df17c79ef61544d5e4a0858e429ffd76a4fa47261349b563fe625be1afa4116d9a05c38322b9731eccf20d63d5e8cb6068148859de8179472ab5f29578c3884c6e5924d25ffc022b8823bac2313a3b827243dda0cf3a38e08a963b615c9ea426d8f2a4f462319471c012ca3c2e074023035537289e82701e80d06ab00443f686f0ac6aee85dfe521899254f2035707495d3332911b90d9eb52501c357da505ef3589ba73006372bdb13fdc507cc7edd742d3ee65adbaba6461e865cbe4c87fc400f0a632cd70ee6111c98783d4b6f63306f262cdc54e9d2c62c35a8d04506bc0cf84e54cb3949130cb4a6374835a37e572ebd7f3f1e99518bcb296e9b60f2b4c7e88e6446b3178aad0c529925442c6e995eac459ca65583379d268921a7d3cf303522c9af919e1199ca5061b9fb06bdcb1b0c6f62431eb5bdcbd386153a5cc27dca22cf904e309a8719815f21619d95746ea78fdbf040a53e1d77b71f9257b504859f4a71fb225edcc5a712f62d42d6277bc38a7b0ab197f89ca25e0095537bb7eb23f3ebca2bfd3d7da1ab441e02f21cacaea15b958733d03c6bb1c33566d9714aaa7a3c56c9aaa59e934981d798027d898823a6ddb4bee13560abf912f15b8bb0bb40be8979f628a54bdb2eee681bd9255fe3e167654db93f4fb511ddf6d4bfc909621de69e2d8a996d9665e55476040a5f69f79c5b48eca26751c9fff0a28e72acb226159f0a727f69f118aaa549cd2fc13e2829ac24c09c5324b4fb2747b7dd6928f73fcb50769bf5732fd45c2043b38c9b9f687483933fc9349193484c47cd094c2f6b2484dc7a5d0a3eea9555af07bd60802482194b776532f4a96089006d6cb0805c92cd564a2b248d24c4e3253422d7c4ba08a7836893ceee3ba756122b856843e7707d4fa145d409cef58739563e3cfff910b566fee62751af00ad795fbcec8d1f2a088b3bf83746a237255de1093f5766d37ad54e36740598057de18e9d90cdeb72b5a61f69307c90b50dd877efc01299138b2a30471eb7db6803664a46a75e565373575c7251ee7a61e72f836a9a3cf85420f10aaf20d677ffb973b320664f792a7310410c95b1e7fc696a0c00185f1dae7ed6cad88e7330f609899847c557e6a19d2a1f601de93d9220e1ed074689915938535e5d1ede648a6d6e17281831997b164ed21c2c1997822b7c799f6cd9b6ec8e70d273e7e3fe838ccd2eed95af105d806094c1223bbb1259b82828cc3ce94ce74e0fb34d88b8b50916a3742f1f6b549464faa4eb9cbc92ba9188d0e7457262a62ac5e99ad0afceda05738597d99bf0d59b20a0ae7e75115425c98de4162f4ee44a11b63369cee77a40bc091d5df60b4cd37280997f89be5dae1a3ddd1798f3cfe8c7e6b840f1386f544cb96dc0323732e3a7e787057a13e619777fb9379aa9cdaadf7820910c4b93b89005a965f5a48c213f4f639ca0947cede2ca55c633d8454a5036fce584dc1698f36e242b4daf54999171d2eed39243b62fc4635a4bfd4b069c3473177546507f3103813977e297fd33a02e405da7335177b1a3a3fc8a5461b72c181b9e93e7b01ec36cd1ab3fcf5aea8c8ed3cad33b55a673492b9f1267bf8314df5a58cc9de62cc7ebd09aa75ec433d05ed2ad4c243c22737497fbe8c11175e4c7f8de3bb132de3b6bbcfd6be1a4c5550327b55789e193354f48042302aa2fb1760b5652a2c53069f1180ecae7468c1edc9b836f8ae15ed82a0b8242eddbeef2c66af14321c324f4e3aa9ce21fa0d0f039ad64f4a4e06daa46248ddcf2856dc9fb1e1cc65e25da6ac9e3128b9986b289b9de636fe25c2c89d7d05ada2f9461c912b59485c8622a88746af43b97f1a790c1834ba4ca7d11b80ae13deaf68a43bf8d3bfbe2de9770656fff0d9b56d74a41befb81be79dab5ad8d5e71561ea0af71b525baadc9bff79a896747fddbf9040b0dfbed53de7bf385b60cc29f9f068c1437949a9bccb9ad6810bb4470cac804ee517f0573d86a5139bb1745f633e702d02994ab6bbeb2221cc0b08be65598bf0901511e6be0d5b813f7bb3835ee5cfd7aee61545183caebc69c09107db54d3279759316ffedaa647dbe3c3b7268bb481bc5bcf98802eefd66b82c1b4c910637afb5c023bfaa6af32fd3025980a6bd87db55125794cd0dbd0b6afc91d4865de2ae0f8f0bb2177f45381587f894e4f4b0a6bdafd00f7656176b07561274059c5acb8c411082eb198a191fc501b72df12d8c1dc1444a84987c21f6a0f96159b20c1441c0992e7529293754e36edb95832e5e8970b6d5ef5da6a1a2afbbb1581ff4d010fc1602dd4ab2a36a7e79e84204953b71c64c290b8fd7e1b77fa678adba1433d3290c400ab5e4cd870955be219a2e605db40a1bef5a3141044e31fb033920d9c98ca91d00115b51538103c704e9bfa2b7ba075984238f49c195a39e5ff688a9b70e394108356a745d948cbe711113f07907c4a47737fca74719d19eece399d4c3ce3001a81472cf6318b2e9f5f02ad4dc8cec977fd206791b4dc07b069ced1f508988ce9ebd56631f781e1a76931b04cffe916f9c41f5da8d07b149697a9e2b73613d3e3932fa58e77f541c03bc1a462896e87dce10bce332dc18c324f5a97089db587c69193f8685c376d2b84a864a2ae31c4e53d5db22b68f63dcaa12cb99488fee7fdd5b4db71cc5cf65c675b1ad1268fe8385352024f84043edfac8334a3d15f6c242306ce923c09d79102841c887dc4155ed64bb09f142a3e7553deb2eab57b54ac25f2910880838a3512ba0d9e03964e631befbc71296a276c3a7e22efb975248fa4639c03e3e9b5a4f1386b981da55f7178eff35c3b1643de86f7bcf423d938555012e3e620780f09e0bbd88419051fd3251f24a5929c9b0fb9ce0f2e487c6f68e2ec575e8db480b01ceedd0de8af8c6ee548144fb4d3e47acb5ab223e72baaa3bca13b09893c2746b27ba58165e9bfd55f3e5fd5982778a2ca874fbe0cef51bdbe5673f6b5a2969b90456bf02a777efacfb28ddaf31bf1805abf1ddab2091e4c22a54e401d8831f218bf2754ee73ac3f720416de0c3a1c84b689440774eb7e795d77e3f69ab59ced52e232813f0881ff4f88f187e53433e37c950ae30394b31fcb106d6ddf94bfb3d8cb4beff32c49be238b1a84469501b4daeaf4835a72ddf48eebd6c5e59132e01692268d79d8e33f0bc6bd6fe960a0e19e5dd96a7ce8fc3bac68f04d79bb43a8d38c8a2fc86334f0b21f78967c596aed0c2b28a9f4a3c31429feb5da1faac0bfe14a62c65df28e5a9a2d33e1e41aa029429da1bcb513108f6a7dafaa639285d972363f7dbb4b48d4ac6c742b9efc3801561a8805a1eae61c404cc425dec603e50fc3bd537dd0e6ce489b4bf16883f7840a88daaa388a84a4740551e85a2d04136b7535bd97eed802b165eee07788676b03566b0d3577f24487a0bcc8db8296137056b1b3f1bf0bfcdb8946390c491882fa9cc7d36a53fff8829cba947c95b7dc1dfe070d8c3430074cd4efab20531ad2bf5df0f16a9058c0474b62303ec8fcba0d4c52a1dcfab80b5f345afe9fb5b59bb46eacfccf6bea70b560fbed79d5f324f24ca8c5e88517adef09054dbbe412f14ceb789dcb596cbc3e458a01f0d822a841ee967472957270e656485f9318f4b5fb7f8092d8513f9d868e7e85c4ce06c20d593690a7902ebc4303da0fa0bd70aac33bb3a7f6f6cac4a335d5134829d88f31fe98b875559ba81d639a5847deecb9aa23471e7eb30454b7f80a909107c5edb1fadd8fcd584228abbd21a68df13d3760b3db7a8069a7bb9e643c657696fad8c00be2e9e65c6ce5ecb0e6fd882a69f645afe4f98359863e03420215b5cf6b547f3192df097350b53a288763c50309a642a7b77bf6a29a668e7f7ea2543c9716d33d4298c266f7d5d98ad12ff379adb8051c49327309f4e120b9d5b8256162ab0991dbe74f65a71bce5b9dedb9505ab20f05e9530801053cf2280fc6c6d02cd7c12fe24e5cb350651f2d32a773cc847802abecb06c54445be1ad66b44554ed1b11a441a0b31a6f91f7852f5ff2abca31f3f0301daf3add0d3865f92d8ae8599c9444c0afb3f1b697dd1f11c70253f567e4b3cd61e99530aa7045b3c5f43f6ad20fbcf9b8a1c2ac7e91b66642880fa72c20af15321810a90a3f0d7c1c25910e683551d8931fdce1017446d4da8714d1a9c17af1ef674a7783c6ff1175950d5687738945c17bbe8197f63b734a63dd52ff0f3a38867058ce8a570d73af98039f67c51fe84b1d8da54e0b150bdc73ff18c9c0981feef35aee41f44b0eae866f578935ae49f6ac56daa46d66e638b339ebea6d8af32fd0e51bca9dc3607cf049ef316f11f2c684c25f039439c94133b0198411f66c8e6336b6f68d4fdd3dd6fa1d6d31300027c95effa8501099667089de402473e0ac97d6f79ddd06e0efb92dd745fef0da82e8f9ebe5a033a3ab587947a7540f56ac9455c42efe0aebdf13da7247d6bb1580fb06e27ceda2616da1736efbcdd968f6495786a931d2b86d477a3e44456b4344016fba065759cbb8c5a62cffec97a3a35501aa0079086a157dc632f1a92c0a44551ff4d1afbc9e125c625e6fb865d86bc416f1f6be08ba342a901117c29630e594e69afcae1dcb96a7e0f69ee494b952e76fba959608dfc818cf0b82e5d5b16cd9a734ffff2ef44c3eb5a273169b014f6215f6f01c3f2d9c20412c4a33699f5cc5e8de5bc10fbca4eae96ec34d84cb73dc0e0f6570661941c0b1f002b07bed8cff79863497c81e0a7170835e069cfc9efcfb99a890a49dbb899070fe3082ac1c3eb6286625790e7e39481d59148ee7e880a5fa2b32b7fe836eee41aff7b15b04d65ca43d129227e55e6214ddd219c985cad6a81651b9bb5a36a10df241160d96f973a83f4b8920212b0f754599d1056616075d3278e4881a363ee87f7ef6696b827428f7309a67f795a33b68edd0319633a4e74dcb6aa160d50bf560a211449e83d44a6e448300f860a37a52708e206c9d8a37328b8a39a1ad27c556bb12d782ed4b0b4c2f5cfb2ece8f6f0965aaacbe6558eaa6bcc7747a0f061ea55d1c00b37ea0ff241727a8d1b09cea6190636ff71923198e2a6960c2f353545e827e5c647c9a41c24bbdcb6f2032ace53b972bc68bcaac9027a62328ce9946999c584fcbae271f85c76d15d19718923fb0ea819813a55dbe9575f7b8dc8a782cdda864b8f284f451e5fae78307351934f6974071345574fd1c59c5f2a91e98b1b3421470b5150553d69b71587dfdff2eb2f97e26c5b09f8dd940030eaf54736809d3d2557be5cda7a4c736c72a4f4f2800b92173c49a527613acf6988eddff50e4c4e74487620175df18a54f2114b232ec04deae1bbc558eb1ae5400d60fee20b85c1d9c177ed557dae936299b1b4d1e01043a9766ebeb2a7fac96fb1de5d58f2d4e8e35ef348521b80537bfa0b74eada893e2f46bc19021c7c79f46934df0fec7b539918bfb2d01c7f1639a5bf59b223f818ddae3a3e1009f33fbffec627a304453be8d4656f7138cea58b919b4ec8ead7423c98384d7e1a4cf665f15e6088884751c6a51ba2309365924db75624c97387c9d2810f4db2b45f776b516312d4e68902c2304441674efd74339405b3fae03d2b994c2333f940fe27b3f6b069219280cd773de1870c9111cf58e391deab44d3d5f27fe4bae72119ca9fd0d99bbe960da847f8c14b158c97c24f221ef687838eaddbb4e82215a6859441d4269b7e719c3a7c57b937a8f1736dcdfcb7d8eba78b593ea75e442999c412b4a42a98822f1c83687795bf7ec8619a2e0a8f5ddf128a2682ea4320f6b9e033875bb2f6d20514f73224af834d38bf65e936e4b9ff9b1fc7f329b60761f031069bb6f32935ec0518d673b4c9c5d4cbb1e9279b667c7c01a38ed9e09ad18b03f239f282aa18b65f05150fe3e18f231d294b8d949537763e322266b815392377fd25433c7fad7b7a1e3e560ba1408a92a7643fb776f861b68d258cd5758cf214e45566fad1458a40983b354503e0915d023a6e292f320cca9dacc3209f1dfa9b69396496436dc0061b09f23af5e42162d2067dc71081cc61b70e910b320fb3615c79c21f19b188d47d5f20841d857fe884a857ba1fe95a5d6b6a908205ea0815d271016799d7ed046a683bb02681aa3382f17aca00e12db5f1b09314573be89aba5c5233df8b41d353703965b46bedb35745411edcc91f2889a38562b82b69d85522c4f31f3dfa505b86b4dddc8a59825179e34f892e71a5e30219fbe49dd8fc0e76b56e17e32c367e61aced5798a50072fbf0601006a9ae9fb2e90f3fc35b778c5b4c262180dc5b11252fa97804498c003e7005ff1c44b45a52152c3fee1dd9a2f72b1eb1db85ca2ad6c670413d609f49e082dac236a6ecb45cd24d3715d13a2563c553197b54383883bd9d72cac2ecb6fd712943e073421184795b789e45b7fd22d20b493735a04c86c0323923a4a6a8f5a78fd700943a0e8294cfe04c1057b8417969b9b34bb380558c56f1742188ac7a1ce72f1ca413eca3bb4cf31de85c083e3de94adcc96f2370dfab14b39472d18dd0022ae20d544ae9fe6b22dd3d67cc488b8dd544397c61bc758f5627bc21f0799ee955694aca5b4b01b2812cb4131fa51c785dcbd1b9c446f44b702629e80a2fb4a0e7edfd63c3874fc1d8b009587ba524910f0142edc1aa72b2077a2619c11288ea44cc8246d5225b94e7f0ee0666935b6705aaa292b723ca455c848669045458002f8533d38b7e86c4439791d569bddc2827325fffec424d8b7be6e11a6f184889aa1ae5fc93f30ed9aae8063529a4c6df2a1c728f6b3262dfaf5cb0009d6ab2e4dc138ca7ec0e01c9a792c26eca3528c85cd94926af3ccba449a90ae216ea5433a99ca53f1f11f5fbb3090c7d4b5fccc9417ed0c2643ffaf3e563afa3db3e551ffa4b4466c60fb5030c741b8bfb9eb503e4934988589b8a05aa5d4694bb5a8a272ff24c7e3d1023b8d7aa157c0bcebe4e62245ac0af2ec28b08660accdf93cccbf321f1f67da3427e5370f28953119e4bae0c377bd85eee173d9550effa0ac55db9fec27926d58a61b6069d235e9eabc93803e652fa7d23f8f2efc955fff3a5f7f73422bc83883a78c575c13cd5741c6c2d8902bf2be253764a29086dccdebd5eb0c2bf25c5296c9f809c7ae3ed81b43e95ecf1ee3e4cf744b3651e78ec8e03815df0ba55f0d883549e49980ce9a691d615d63e9d4a9f98b073dbf93665ff758216938d5a2e9d9c7a734d57c8f5d1a3a5c0343bb33ded751760382012e7f06ce32ece2760135aaf027f2768f75b12931a56be066406a6c37a4395743fde63cebfdb60ac430ddbdc83e79ecd1ee126db22a4607463ad98cc55684267ec8a1a93f120202ff86d3d26483511cabec413e4ab776f1e0f82c989a38d70dad377ed02bd8e80ef2dce5da3e42a42996a80d33a6cc4285078f3da155eee87650dd6999a31d9d29f063efd90c65c702a64852aeca817e617e6b029afba4929fc42de6462bbe7ff909e27a576beac92333cddef5571468ff57eef9e844a0b18f50d5af35fab51245cf837a74029774400866eace9565d5d7a59efeeb23d399bc94a447362ca0ce3b9f7f641eb9c06b66a771040ce496a32b9dba6626478c0c0baae2f6d0ac242bd007578dc892e9270c3807d96e8788a337c8fa8e8e55a2f0f65ab541dc007c65e853162ebcd9d05a054c4f3eba00d8332b46434d95331b594af49d221bf698495b80bf64e88bf094d18ba68e8f4604823dd967366e2956c624c692bd28650a1aaa0c367877773a93f38a30fea3582151c38b90cd30872a03f322166aa5be841720bc71d34ffe0dc8bf7f99598efe98aa9fd60c688426509cb4b9dae8b7bad9ec99ede0509906549968201ce02ef79ae7f8688dd22ed07f6d93c605e9b9dac3e247019d8bc4ee72a8cbb65325e11b1c0cea5b0794187092f44a9994a642901dfbe95ecdf3431c8135ed7b8844b2aa06c225f7b86d4dd742930852b2b018f8952e651cb7561b1fe2e2811b70fb03223add7e3e1fab7e22d9d7a463d3db08f484e6f2311e72532de05077de5d2f5dedb3d3a4c7e11df640dc1acf00fa8435b7dcf7ce9492b29fd0390fcaf35a045a3a308d7d1233a0ac52cff3035bd759ceaa79d7021b982e04606d97ea36881fed637903df56d7e8029c19e720a763f72907c09ae0d2bc5a2c52cfa7c77e78221ad729e4a9721abcfcd0b662e5698f1d5b16ffc1646581446484f5d695a58550575887d887bc6214a9f233c4889c1b58bca24ae4d3ff994949bafb237a0a991ec23b5786abca316cac41b4deb6a863822456acc008324888539ff33ee3286915ed52d84fad8b2fc01fa7b73b712c357bb93cdae9c13719e48fd737107ec6c50be137f7e5df683f9518e63fe5ed37718e6ae45f8525d75b4b65ac9495173c9bd0d1149c4793ee2837d50665499503807ea0de3e31af40356a7fb3579f1f91f5b8f9878a76ce6e9ff24c0d99cd1d6cd43ac13dddf5bc1ec854d33629e02bb6ac200569d469caff0e6e185a20b77ef3f4d1e9665f1604aed54ede3eb9b65e174ea42fbd6807158c6b3b69cdc3aa4838392e88bc72281769d4158c86df81be3daac6b270e1ca211856dcfcf20218064dbbe2be7fdbc3453317b333e75fefae5679712ce27f5f8db64a204b09175fc26fbffade6e60de1af7893eec3fa2f846a5fc2d51a2f1f73b0bd6e6605684829de4be04ed33f41431d17b596a9f79c2e38ab2e3e21106138676a5f0e5ddad671f86226533b72a88ae74f803b7c322fe7e70f4b02ad0a291c79bf5cbf5c901a0b807de3582ce09c12d89ce9df281e4da12dd84ff1d10656fd24a568a401f449873e63008d9526a18c6a06b47724ae937d0752ed7769a81569f16e849e7316598d60128b2cbc4848f24cdba17e1bbe0c79731bc8aad0f1e67f047fb58e6103aca6338b23082d2a9c83a331e43641a67d23432b294874c10d2669b6c11834ff44b9a83cfe714e6899d41048aa29d2b03c2e85a42d5101ade085491167c958822d2ce7b2d750fc7d48c6db8144c989606bd0c69c7e539bdc23d974db2858de478fb7befe80fb6d6775e30aec5d0b51228f6b26d5c99476c373ac4e51e7b266baeeeb6e5e3a893b0ac1db92bfdff60c83a3388619213eb184b93e8cb953d5c2445fbbba443d871bb1799f6089b5decbb5221ab236ca28d90af827f3ee4c4ee942b6551309c68eb0434b72101e7e7c18180c24b04e5202818aae8b606c0e72fef1904204c1691e3162cb1319c3804425db46020bc67448b97837b0809cc9eb6c4a53174463f4018329611b0dbf340b4b60cfa696cfbf4090e2a7eeb64e12437b43e0fee06ac12463df0cd702eb357ee2da642b3b96630aceac27e3961650c740621682848bd876acf24230ad797793ea5ef36baff0c34a856f1d0bf55b66e59bd87a24ccf20cf8175229320b066b9ecc8ea1d728ab668274b2f39a07c6dedf5013e9c6668636b97c0aadbc033150c9c1055f713d089de436249acceff4559e00be51909a284f34ae67e1706924996abcea26e33fa12bb954a8309cc1f2df3b4952208a1c74c25d3027eb52e957feee05e743af12d557eec819dacc1a906ce7596d266e3781798a88e41e66188ec88a92ec1639c1737b6a5bdd500ffdcaea4ecc53098a5c750f93366553d1aa9d5ef4fdb4d3952953fc5f54ec23aa293a5f57f846922f60e9b80e0835cc63f97a19181c88253a80a95e407fd71ce5a40409804d0db25f3a84d9d23f8987a4a5b1bc82573f51d30c3c9c93ec8e9400af4409130143d3e878b091b33f33e381733c796cd1cb673feb4934ca1277685899516d485526f80dc78a22b52b5a04faeb0b5fc204b3de117cf113dcbb4c606da5ee440f732f16807ef7a624203f20f7a748f13d5e4ad8cbea6194aa8b04349eabc2aa1780bac1c04b91db9ad670ade3298e68dee774d0b496b4b133630ec4c9811effb7a86c0213e8266c54c8a9d57ae865e819afacb5f9bf499625dc31e2f67950cf7166756ef2be854f37448c67c85b09a2a272a0d78bf755802f3ffd760e64b2bb8a12bcf2f63465b6629423197a9786dc9dc20bf950df2038a1da6499d576f0f8e42231bc805ec85882aa24b962d70f8f78c811799da4e6d38edb3204b7274889d0d4de199a2020c4e3b1a93c9c4f8126230ebc6928fedeaf1b5721290ea7ddff75298d77c163b97843ce64e5aea486083eac85aac3100f22b0369d808ac4cdb40f4bfd36d03a9a6949cc398ae97b7cc6e88dea88bda7b886bfaf8c4415559bf0b88c7a34f056d24b3aa6ef106448d1c6b5241c56f1e1e89894a5a002f54eaf0fcd630a871972812a4de78c9c4f6a7b73f60c69c38bf9c519bd9d7292100711fb154575fbb47f0b2f9f3a52022804439a2d2063be93c5771ca3726f9935030d5db58b3eeda61d2568c808a113653f830b63574b5c5f0175ee68fc6cef350eba22f572e7e692919c461d0ea14afbbdbc8b98b2ac5c1a5cbfa3ca2b07ee8f096e6242d212714ae92ef3764f55b75e0bf34f89919f2d8f0d2bb97ff0e1915055388b19c98ee95b094c824a731a5d4da617d30eab7914e3d32fab571b11c0b1a17cb1c5621fb2063ba32f3771f994d132cd2ddd15814437fb5410d79f7d78a318e6cd0d9f2e92e69209612823c5418d14c5b8570df9c68508174e45f61806b6d3ad4d8e9a612035f93bcf82f65f19c8caeada0937dbd02b12919fe8a434a678347c7a41bc6c91ad653566b04caac3e6dd444bb290099ed293be6122389bb94e5c17c92f3373e17b9c3d4e253fee59f678943e56356a2540c5a58e8cf8e84115dab243f8e05d813b2596d70b8ff162574ea63676186bae3ad59de97fed5369a959b325320665209c9ea4aa2ce0b356f5a86e0023b57661d5920e5d86c7174988cf0ce2783fd9fd70aadcc8088c95229f7591441afc63fdce468f404d89d40d3cd8c0403696aba5e5c6596dd38c2a055d2200a4d92a0ab43aa6534d81663eb4747c4de1478b6ee0aef0adddad7cb6973c34146719f9786c9a9ca3ff18a47730de30afaa98773cd26070d3398433a907ba0d321fd2f86eb83b7eccdc9185cbf267e513b73facc9e7e1dad07728efe744c19c23ee21140b61005a9ed693f0d10639f80eff2a07560ae1abbbf7e351bb6265b60c31ba24a53fac971f44241a429b55b8e58fb16ea537d6e3f4e7a1961a0f930616db914c75773c84706b892dea19e16fa20b63d5de6d656ea52730e5139fa8e7f28af65ca6cb9358d32526312be17aebf96f6e92c580a080d6f7f9586af5090e7a646320411f4a3cdb1780f4a9fdf381bdc01784ff47f51c2b4b901b7f189ae44d3198aff8ffa7347b70775cb0cb70a210523f05aa54a22c99ad7656b8b07717ee9ad6d31f3f3697a0846cb9472cd1b962b139cf6147ddab671b546484616c002a2d5c4921963025635445187ec3fb5acd6d969364f847cec2537d8483ca2d1af06d913a5644ff7427cc413d1943611e112ab9ce607b91b9c97ed56d9170556e5ac95b77162dad9aede6a68302b09088522b75eeeb91061c72e7f65dbf916cfb6b568b19e262f315bc24167d59bd2ffd12d18bcbfaf93f3d9400208a961573d80e3dc8745d05ba8df488c2c850622e00e29a854d91edf6338bbef59688fc4c68d3a28a0fc456a33710a571830eec3e38180907e3162af9e5fa92618f85e57839322ef7be3c863c879d03af0f2e2681f2926cbcb9713dabc0387eb4b04e7bf27cfed7bd1479588799d85b92de93d79de946d29e40fd28ce98924526f5a5c409b40a3e663737c72613df2eba2ce728d4df33d53622c928dea278ed46ef30c8cc496a9ef0c34f4ebacd50c581268506bb163f78c7a22b1ac1d7e5e800163bc3717682464609b67c64a7cdbe08ee48b4670ea6f756940c33c063dbfb5960c4fa4fd691a74211f2606e8fa18a4c68f6d7b70d56d661148bdd8f70d75250ffe5acff1d211bd4cbd825bebe1f7f7771c3e32b2b863bd48dc63a4dc030368aca17c346fedae22c733d2dcc28e41b31f54db4e54f59b009aaa8fa91aa63bb84b0589cc63c7509181a2626db56ea3bf309b2fff424fc484781bc5fd7a6ce9eb50837717f67bbf8474550441bb28ae6b3aaeaeb91a9d81f1601662ac7b76c3ecdb79822356f76c5b2ea04338929973edbad725d060041200c34753cc2943591f46f84cbdaee64583cc30d2cc08eeb894d9b55b18da2e75407fd36da213ffba72658b13d5a47594a40480d2a968ef85a746e4fc0e285c3260ec4ead4dc5bcc5403c9f5af53b933f4f9d6334acc771851797ea4cdcb894b4a1c33969205b03ca3ae358e85d8ed369da2ec1146fd4ae5a3c314aa177f1cdb69fa787bde18110eb26a99b2074a4684cc3ae73a8973c9faa16324de512ad455da6839dd1a109f01aa2f558d1e7fec5149c43d84688f52448bf2544cf632e3da7ec35ba35c861df833ac2b4a4a4dc1f9a75ce434c34ce3ecaa6a49b9a31f16a362486d18370c1e02567cc31b13ef7d711282fe84015c90926054652db0488a54480e6eaca7b1c906d5e16fc59e9a6477a1bed7f634234349eff4fec92d680b80ce1fad34fad4dd92a79b380aa287bd4c5ad7b50f6a37040ecd8a55d1355170498bbc86c1c0257f65a529796eba646edf691b8b9fad71e23c1f21d4069cd7e9dba213850c8368b2498577b496a67c5c4bdf36ccb965cd16cad34d17eea156169d8166ee5556cba9df479728dd8f422041a504a096a3b65b4a354df7af646b098ed38b04e060349aeb63c6aee0e95c8b065aa3e2b168bc87e12d1f6029079765fc3066be86fa3edeef8dd49c28a1691a8307ad7e89895cca89be1954e3f52bcdf18324875720283ec942d038c6f9431e4e0f52295c0a04180263f29a05a584219119644c7a03f652494d165bc462d17d9c7c1425f85ca31826cfbffd2dcf11fafb19624e2df5e50283452b00c345fef29b96646db7707d8542e79186730938d06f40e94db5d08b338fae2f704ab571271aef2c6b430a350c818ddc1314ed9eb601d44f55ddf9872e1fce5b6d6351c6e960bd7bc6ab37418a84edba35598311af48f5877fa5c5c7025a3e234702bc41aaf0a3449309d342985f7a7b1105265177db9052c66b82269ca92661ec38bba7af00449e853750a48ad2884d2e8c8fa3b6886b0ee6bc3773a38080c6c76f897672b94640b4c29f509a8e331e1ec8b48844bdb7f6b0874d5b46e9d0d5db40acf71c14cfe8876919b780333b1b8734a56e7a683d4a6398e53bd34da5ff7f6ff5cdc8a150f254eed76a77beb7303c0f2edb400dde4a33906d41d0a8400ddee50bf2794b3fb4b13caf3e0364f5b51acb753dc925df992c32d7231f3fd682887c7cf54acfcc8ef64fc3625a2e98f64b0a1f23584c5e5e5fcf8d7ed53129c75eaba1676ce9e9c196525b8b03b84f03007cb03c94d311b410b2290d67c30939fdda067e905d454a93f22153b8a8e7db3fc243c1675e774de90ebbf05debc45ab30472111bb48bdd7682db68cc8cb1570af00a94f8d25683f5edfac050ee44b1edc2c8e1f5b6b2c22819b393439d3124807927f2ed0dc9a649c011d8327a086c2624671bba4185ef93bae22acbe1d48496332668cc04e86ec28de605f813a55263e58d9ecfa5e74985a7b2ffb2d9dfa5db9fde82de58e530da9ac64e87be2f4030641c99cb2218537f77b6a4b123cdd1426d93423a14dc43ca6bcb45f20379cfc25054ad11eaae55614b3cc4db05beae8ce12df73cc20677a800f55d637d96471df9dd2db5f570748c559732548fffe9c3b102c079b6f4a35764a912f5fb7a2f5d0dac748d0026a4ec647c0f1643c2146dedce282164ea71d44d22bf69332f915b49e457e06f80c520ccd4f9cca3bbe2550e234309d0089e032efba2c3d8f8f4de8691400a8aa739fb81d02538f2d2d5d916209fb1f7532f288fb46e917e0ad77bfde569dca5440182cb2b83cec5e9723d3b506bbf088967557b3d06602e6847f4b373952e4560a598312b436de350dbdac75ad85bd7357a9dabfeb62fecee6ab2fc2697be9539684171f473cb4ff49f4c05a952e70c8ecfbf5c8844ec9f98f75530a3dd7764a9e1985d48b9b77cbca0984f4119d6734e283b3c7081a0020b26b93194a29cf33f9ee5fb6238aaa4358a5ce4d2db0b51659d42c339e0a8f7ed03d955a76209d570ad49d20d477e32be0ede4733c3aab2ec957d3de379e37b210eb98396d02b557155a73e544cc51319fe2da7d6e8196ddbbe2ea8907e1e6247ebba84a1919b555166d7ac93482195b2db4216e23e0b0919b4a71294d7c42d35ce10eca355f9dccadd8d0257ec3f6e2d9eb0346474ad6ced6808b5af333a386e49acede4f685ad70d9447c4c459941ef7113626c9caa333c7226e0a10d354fc60cc39bf7d432dd8cbf5e900eab37928664bb21444aa1d7f9ec591d20f5fd850528a41cf7a27450f1b1c993d49e5ade6818aff3540ce263468231ec056950a6de2b8077581a26d2d4b97a36a9605b88b1c167248f7c92e28f866eace2b00addb3d474cca97241034f8bf60f91af3fad651f0105887428068ec09b25e1102c3864058f53fcbb439ac72c9fe409897e619becc00af3b0203e1f150865ed45ebd21e28c9b110cffbb78a49d1b2852e1702e4faf44ea275afe38585f03a94f6b567ff57cd9d2cb6b6be7dc4b2f5e6380208efe9a84aae9b43e318ac0978ac6bc2e891bb3fe0a07cb396b6a67d1601cb04a3a6e62db86469a5dcd8381f46619b9d7e794e9c115a501487a077c33200dc94a8879d5c5772c348de3de80a4a5d0d9217ae3a75c967b0aed42078d42e8d594e26caeefa35e0840849d2f2d27c3953748","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
