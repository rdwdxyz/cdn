<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54b94169ee9b84c8995a7a70441606138a8200ba74daa738edc76d7621fbce3234b2b07d1bcecbb4e94ce431a6832ec0fe48372e8f98f1cef6233479de933229ad9d06540374a5d8ca5c766d5d987bd2db65b75ac46410312bfa9ac74515792b6c4bb4be777bd1c7f706e16536120655ffe1b7ee21845fa6bdd571eb937aa34b5c6f73e09fe0b71505457cf2aa98a9e26ec5464d4b17db303e6fef4eee13412cce2662e2ed5be5fd4c5f072e16bc2725bd83c001e6bec06b67163e5f37fed650bfbda4f70c79808984964f5cce20b21c1057ee4aca2c7204fdfba00eea5ba00202000246da6163794769421873aa4b533338e3491cfb0bca0902c915a65d8ca4dbd6a28d4c11f24dd6f4fc0028263fc8ffd84836bd5fed6b0813955956d91aa9bc00f9c07e49bdaae8622d1dd7a26a27800084568bbd0cd7add857d4eccc6bb304ea4d0f918069d4acb484b99f344df826dd5c93b37177a5611abb557c9473214c158e11c435c9947d90da77cafad31ecd6fb845cacece1c511182579aa7473abf952a52ecd8d60f2fd150a8a46129eabf66e8823a0acbaf71715a1d5cd79a79729025e5410b8c2dc9945fb6b3582c14117e1bd85d9cb2355fd8b1df21bbce867dff4b26b57540598030579f85ad63d317c003413b858880b2a7a1726e98e31e57076c7b9799e90a3be1aac94a39c53d827c1b96a0d72b4f4cc697949495ed08643d1b0e4c9860f91355201920118f69756167b6849ff0a2aa96ecace2de1019860401740fa864e64c0455c45a45d30f8a66e9e8fbeaaaf286e4a9a2c6cafd4f75215e6fa6246414e7af8358a00d5a849202501be8ea74c4d4e6388190ab3cbacf5ffd486a66af64b8dda8a0ea2853ef95897270ca55a239194858aa13c7f7bc24c90e4eb47996ec3fe6af8b2bfeb1c6eb3de813f9194025d9d15989a6eef2372816c19a711e7c84af6173a9228946cb7e25000641965be20802806300a3f562cb0848a75907fe7d2a812d3f6dd0f76c7ad07d54f57acad2db3664810c91b6a20fd3ea6415f8e065aa3cce551c7614a3736a020bfc479233711c309c61e8166b34c8ecac83da1627f61c879c33c72d5a01eb03fbce46c7f9cb1c0f661bb3dea7217aaf423e9106c03c70a22bf947911428b1bfe486376022eacf86191461f3b35b8669449976ed803059e2dc07a55bb259bddcb17978fbc0ba0da5e19873a309e38b9fdb68abebeffc60801e091611b82d5f6417148a1dcc41caf8ac8fb7c2a2deeebb8af64f07b4e1f4fe71dcd7053a9acd2032be293ad2e6a07529e9ca872e948b2b568b394eb1f209a820b4f5d1cb96af467109e5a94549daba7523d311b4d346533c9ecd8cbeb60983ab2f11f53d42cd1c806642d13394871cb98279a98d2fa406e8767afa8debde6381f6115f925e4f29015bdc433ee63e11a2e20c4c8653a9c20ac6d3b7d3818516729fa54c12cc3c585ad1f74d74fc2893b08ffa43afd01f24dfbd192b734139bccd38da07cd3141d7f91d98962da8a2eb5aad5d43654d7f4f6c54261129a9d3d89c85d093f51190e6d6f6c679e72a9bac8ba9c38b51a10bd97a7ed13955b9deaa7ff0fc7e6c5e1271c9b0d315477185be244c6e2be37d212314b11463a209d39c5ea4df435d23049089916cf24c0b5990abdc7272c6faa7155befe59c03b5a2e549deda7b0774e734d87d6c2fcd20d624141d2f8029f3e198e19aff8d4d52309031fe4dfbe7b84db11e0e1bddf46078681395df29385789d58c599233ab92cc5185537f7c53c6a87f3dcb6a57c0682045953bc683f790de436c53fe6c6cf9854e135a284863f994d29a1c5cac26a039f2049c83a0ca98a667dc1a90f0ea246875dde12bb15a54241d5873f8c9faff1e89ae2d2628ba477ec1b6fef120323ab9af63b016b0bdd6da67b892cd702f6c5f4ec2f3586968aee6eaf6d5fc3aea18ea5d1d5a77bd687a5ad0d3d9eb63d465f64add6535cbbf20bfc8977584c2fa2e2ad59ef698e21b33d6be5b67e65150f96aaec24ac8856c69c9bee2c15102f0ec2f3da570fed75e6da1547fc28cc9416a3d204113057716fa154a5aed24c4e064788afdbb1c55b0a4364bae8617cd582cad17487a09ed23232e8b26bc0d28c65495716ded9955ada8143c4e5e5ee2f01d9142532b1fc38a82abd027fda1d383716004ef46dca53dc235b43075b300fae9f5a49b940c820939a284349539c505a38e95d268d03e6736a383980354335d8906eee81bee1bd7255c6d45061735d9e9c683db6db4bab81a89f443e6827882e4eac6f262356690fe5b42f1c61087943d47ce50baa6a9ab3a4b44ec112fe2c69fcc6364513c9d65c2c173206264100ed100045fa9cbe100eaa77ecff79a988316a5264bf543484a25fe170a620277797f66ff65de5e469d84e7633da31ebab75c023b109b4a71221373cfd57872a2064a2057fece7261ca8d953ddb411a2cc2737f249d201db9fd9ab9ca05271d319de9bea7c2a303cb7c53b5f50795181f088eeea467065c2151e436f631a0c244912aba4f4aeec12e95b55d3b91d74544ab80962d618da56b8ab5fc4c59a61f4e236d341efb15e43336df92dc8ae3eaba4f88fb2d52913ca3ee4d5debedc852f59cf6c76f967afd7d039f0c6ab217279825b88f3028f96565bdf6d002a1cc1ce067e46c9ec0d462add461c9a385eedc5415069ca9732ae800625e51f27739e5a43b57004e6adc7394def177039498517c564c6d71278c355bec5e15fb3c2e6e35c7e9dc673b6e41e34bbdeca2066270bcd9ed01c76e59dc811bc4a4c8e3a5b8fe1bebd146ba6aac144ee2d4225aefb7d101db0f8de5f8b2db2b87f81027b114d54271788a0ff9f584315daa1842e793d70c1d9e4a82dd479271d223a5448aac5b6499e5f6a78421519a3ae607ad85de5cbbd018f03b6acc33e840067d7f0ab1331b58ffe344e6b4f43e3abca7d805156f30e736e83f02483b5a72d6911af44dae29f2bc5eea6943cbed8951d4e837dba42b55f9cf3c9d1b7f4465796f9023d82b4b3a202bcab571432176b89ba73292a7ef1492b9b4aa71ee3cdb6cbfe792d741bd7b891e088bfa7f58f9bd097de624cead99b7ad90f0634d38aed9f0e3fd59ca5a94e4861414dc6c6fe2508db2744afed2bd494a243fe8ee5359b3209538dcaffff5506ec23ebdd4822c1f5cfc8b11972f04064382e3476cb96f7061a7d44aea054a9e25092f57d82d52a0499082ea14fa6ae5684fd7f052903078057623941e48d2b5207a61bd727fc8d12633ebc2f72d91e805cd30bfd1e8c5f5e8fbcc261e6ed0ff3f0025674b7f0666329e7535b1901447be2ddb5aaf0b26759db65fd6a46a2411f57b6b543073ca6b4c051e2395d65eb96f614e5e28619b61c8e603dde5964304d6786ca618ff49ef5711c3ec3fc3bb452f0b67a2b0017e25f6aed549065e3da680b6cc872daba905e5fd47268bf1427bbd1bf8ad04df4ccd0840a5156e819ea15ef255d57743a40f70f6ec03877ecd2561bedaac960ce8b29080cf33df39f20c19f976c1f21e6e636cae3fa6ccc3d0fe46e8f398d827983b5dd0993ba46cd0a3e3cd4418ff854af4d0649904ea062f9b353ea4a493eda026df6b517eedabd1833b7f7e8336febab4700ef92cc38760a99fad41c49aaf9bbae24f921bc8c3946cab1ce2bcb5150ab82ad1a8a58e3d0561f0642001a0d7204b700310195a9ee34b62609bbc193ab0175c758be9ee1c0071236bc5302258e99cb6a3405a88c92ad1c6146f137775e68542acd21a2707a74d7844ca8bcbe0093bff7ddedf219dfb8fc4f450c9f1de7e6e0dc67584d4025d29878892551f73f8727e7cd40f973f07782367fda91b342e1c33e178341abf22daa73ba1e2f3154cc3ead1006c220848d1648e5409265a867d445b8312553f41d9f50b981eea3f5e4987b0e9bb3afc19a0797c33c005f04d5101d61ef9026dc35f3c58bda363b5b26efcafe519e2eccb7dc2ba4213f1be997ffabca3274afe4a297f5c6730126e653fd08743f9b3eab3847902ea4a37725fe96205997899789d923faf43591368ac6ff505ca927764ba4e60a62c076cae9e3afd87101f52be266aefdf0dd23d3d6b199304ff5f49dba76d7005de93bd697c29403b8dcc2a82a62bfc7995e447faccc70f999e5a46b2a3b58eeb517b6200d7504268fbad94d4528f37100da73184e28f14ad37b69c1c4ad00f4dd8f63e9501be0f36ba20b4d62d5eb970b974398b7e1182fa0ed5aeec9623a086ed6c9ce887ff814fc928919ac476f91d65002c9685de1b311dd78c029a1497dc63b7aaef4c6d7c9648072ed654aca4b02ee50758e021894ddd5418f904bb43449884a31970bdbbe41f6665b430c9645ff94bedef7f585530ab0cb2d2875fc5527a95f761b6a0b794c8316835a62b355e252b6e006205187d9b8e7ae0ce035c55bc56e79d7c389625ef040ea9ff6b413c9494bae0816b7e3a16530e41001340ae2e890565689e054116eeb86e38b7245f65587ec28afc924958e991e23d2862bc066891fec19f0a6b0c052e0707c3bb7439918592936deeb06585aaf2bc7f6347a8a4d31db2278c2c59500321b0c0fe34ca2f933c337bcf50f2676039bf2591c1565e4c7c560b33830afae06778a8c7d543a3dd84b60b3be326091336750c10ec3d39636f2f10b55e02102f50c48f6b47818329dd5a1d3cf6033c2beb8dbd2e8d04add3c7daedce4e44285722a10e8b69c4990b1912355f3b7216f67c8168275bd9c58b84f1ea0aef7bc2f3c4ba17442aeed9ecd91e8dc459038caa0f67c284449bc8b6ea538e98b47d2fe986f8fe340915d604825592e177dcae3ca46fcb6ca30327d60844a2f17a6aa7bc304f94cbfa8b583868688db638ac39b8d885fd36ff11462e1c3a0afaf68c900a1cc3cc95c8e8e6162be7a04e372e05e557361f40aa9d0b7cd8634cc17d523cb2d572db97ff1ae0282b539f088de8be53f12344089abc503e391b089416fadbafb1ec5b22c8a2829bde95f98d8eba0c85143bb7b59990e591559ebd7425ab9da05586140fa692f688de952d1a1aa4a2f43e286f1804e4fa27cb3d7d8c530afa52496db619b355959329e18646f5a9b554ca32a3ed0d0ee5f570542f651f24e10adffe479ea76c947b68cba0452182206448714b4796c749ea09204c08ae8a0e1eb5e41af8a6f15bdc51ea0020f55885ba6074d00754bd3a477bf6baca150c68cd766dbe44c5e122299a259bcf83f2251cd6a344be08d48e32c61b79a93f519a47fe1754ab86781fe546ac17405d5a3e8db149f62329f32e3884a21d526b0c0491f0a4479026fcb58299a77c2613f0278015ebf80195f1c5eb3c21fcf0587dcc3412a28c02b8acd0cbbd10332e3ecd5a239eff4ac1e82e5898e4b19bc6fab4cd87ab8a133a09fd8e24f70006464bf4082e18f06cbeea21a7009aef074fbc706ff10ce1cb3a1672586b40a238a766d2cbb2f4c2a4761121d2b1d2ff21a87e8b2851624566a4a8a4df125b60861ab0cf7045f9fbef690416c6ea5716b2e09f129f01031feec0066b877dcf38fc42746d523a5f06500a0ceb45a7812728535519542d08a1c69f4bd3f50bbf1407ab9f730c09fce94aafaa0d1f5dddd440cacc34a711c191d6f3917b07864ce831d139e6024864415b69f61007de672e6d4bd66653c608346c5225a483e46d96a260ffe5f2adfb44ff725234131b6c68ed06d273d047cdf33dcad7ede8004854f8da4e1a53a31972defb5ea2b2cde4204197f302341794801f44ecf2f2b403bd631815a4251615de1dc3d9ff15dd09709a22bd279b137bd5b786e193e94ede8a1567b25f6e9b3a5ce0a37302ef8d3227827f79333e6665eb8204713d24d037b50cffb257b451ad8f448125b8f019003e6f706aeef2f94b4a55e14de33450511779f07e73f53eb7e9063a794c4ef90c04a27d82fcde66338de8e52ff8a63e3dc95ec399f109f1ca94d0aa290480d0d9cbe26e7918f7d4f156055a33377882efd4afab0ce9f6f05396e9310b3e97d317684f60f25c937f734c7c2bbe1df774620734fe11aac456468f7fa5bf8828d4964bfbdbd68015603ff82fa885a8822186d438055d8c55557d8e532d4dd43cbe0a83bcb9506d311c0d506ece156ecf60615c58b8bd864ba3256980a7af19fe2aeb0a18b17256c0c7a269fdd84fbc02aa97102baf7ed543a212f920349b81e728345c000544396a351f83fbad8aebbb5e7410e71779f94f2149a08252f1ff418c0070c21b9a2737416ff9632f94f88d1e5f07a232fcced6489d7a953f90ea88764a5520ade7abddd6383ae1c3e3179abd8a4dcbfc7e6a09488d09e1facb38f06fb0cb807e622a2125bb8255d4ef40b97aa81c44fe564b23d5fc3b6bdd406ebe10ba077cfe870a9bace8a666f454a96a5e9b4a0f95dbf4afac68a75ba598236fab029ace0e3b9159ad4b7e95b9d31306da98d336a8d64d1f0f8a505bccb6f9da6c8544e355fb7cd1b7aba1f0b4fec8403b29a2f7e0d9a46b6fc5161491f75c44ca84893af351e96378ae88b4e94f58ed159346ef5e1f1106360c3b97073fb5a77e7603fa5227e8271c30aa66a434c70808e2948fb46c539935718fda39c36c0423f9aa27d8c2103196562955b8eb61627bd9cb97c288c9db876a34b7176311891541ff65f449049eec5c2624ca08fa9675437f15461c6852c4e9d1d2cd51a6d2126f1eef54197924c97cfb133efe83658e4a2274732b364b22df37a91d87a1218893509bb558a4c1bee2fb44f55a2cdcd7db3a9c015565ee0ff385dfd0f1ee9c2523075016f928f8833c3b6df1a99f00cc2758f3804f0828fae728af6ac3874b0467614a3207ca7b55e30541f50995070657b7c484074310f81bfe4d718bc185ffcd4d392eeea9b024647d0c1d056e196ae9a0f0f0d039a85a506cb438c4b30acf41c19b52c8d8d71667d4e9817e8b9cf382ff1a03c19ab70656bb0977f616c75223668145036fcc7ee0dc50c799d9425ef45f48c00dc065c2304f57a45f4e19d30c2b321e46654bb01453a59c9f2c68007764ec670a928367a2d3ae1f2f0c287f3f2cfad8cf18b1c9ef5a47b707bfb8d8c911b31212e561a5380104db8b00ec6621de1b3edf537346dc7098354705961f7d65223f2d69ae3ac8512d0a85d0e9a76419875ff4bb2c18db3a0f7cc3dd6a02dadfaa935d53904f70bcb378989ab8d0d8db3be11164690f74b0413935daa1449a2929e91ede797c7899bad73d822920421e96afbfc15d9bf28e5b74dcdeeb4499d452604ef9d67cbb17f018ce226d872660b98c22aaa43bb2b43177ccb6ce654cf4d0a01b42463392a6ce1ebd265a3d3776eb5aa69495c2fbc04da70229352e8a7cc1cc2473c9b95bc972b7c1a05f465bf66d8cbaa6fe5a18f93f3466c325211c5d693603862c5ccb1f4e4233162ed9a99f47a3f975333b27daa4c5c7a7d55e3165507d1e05dca6e0033a39082d22d2c55011b343b1cffb8ec39ba07b8ea3929fac141e46489cee2b21a97f73a4b72fafc230d41cd3e5f296e85dc0fc493bdee722b4cf1e87b4678fbf7e6d6d92f3c8c6bac80249e0f1d3702b4f4afd596297390be518e1b3ea8ae34f00afa18e10341269933c9b8c03ccbe02a6afc812ac114d662b9334b3403dcd490ca5de974b11c84b8a060f39a1fe4a9f44152b1f60dff35b999886f39ee561e0802e1ea802ceab69a4f90bb78d3257ed132b3cf7e35ac1304f6fd3c97fd5c30033adea97bb3bc629f87fafad9f0ee228f578c426328f8850be179f163565cc3a1a004bdcac2043741a58fbde12ba418737b5505e3c5ef318676bf4d3222383cc89c0c280f75982c3e04619299ac9fe29d9d7f50375db9bbacf25360b7c6d2b30d51fdc7b007117d3a7898a85f511a8535df86306c9f4fda2b4b2954add4293d6e4f2cf066379e18332b2f3f9bf5edfe25761465c523ee809a4424289dc70e33349abd4a7f32424cc354e5392bc172a1abf47073dff0231ce95e8bae411fe74d62ebeafa073a3be1d7910aa5d8cab0e310de46b3df933e7bf1df008fa5bbe13471c89384e8e4922e5bcf9a92f993cfbced41d2250a7253cc8641f8ba315c6d6ad5bf42fd05ef228d54867a66266bcc8afcb00a71875231fdec6c03a57772e4b6c23d4b9c4a05b1dbde816e2eb7f9db171d6f5ed438f8901213f449fabe9faa6b8db3c1d8f1b7ccfc1b3f69a07d676c9e459d214408a4535513b628b1221279c7bc84d27f00a1e60851efe190dd8462c0e1a5ce9d64df6d1f4d59a0d0b2440f85e3071bcf5549bd45659b6b7a5dd2d50ae1f729d132a0981cd4bb96d4f099a63137bdbb76f6b0c55736b7da40a3083c191435368c861c958e6fb6ee512a7d403cda29713933049f27e404c1565a0116d320c08c45b8542d1b60a9e117868fdac66ee4da51f70675a3b077379bfce6328501b43adc52193a9176a3b3a8ccbd9ce6e9d4e6eeaee9915b2158d7d86e313a9560fd132f9c233b81394397a2814f0252c8f99168afcdc93804e159e3a670dd81f1014fc747c6c6f96ea6da1b9176a9e4fdb9079b3bf8f53e783bf2431f0674097934e90e19aff877d9a4c681a27fea5fbb6ca14e03a4793af3a92f122f214cbfccf2bf018c951db5d27f25cf7e42f4a7c7066151b7fcfdd9d841e976afbb7905ed6eadc24faf7e60be06c2d8deb56481a9c3cf283d3c9ca6d18c9c5f718ae057c5c5b4735303610f08d5be086e0942571081531e8b783536e8528de78c14a96fcb5e9394f37c97a1809134bbe1f1edbd346a34837617fc6c1a349c06ebeb26702f89603f6dbf30249c9f4a71ebc3bdf73e0c87292d0a16e6a1144137ac49bbd649e77ce51f93fcc830cce95fcb851d154df3927c8e162493c7979f6ec7439118e2138c546a5d166041a51729aa4cc973763b1b1ad459db104728f033f443b7933565a7dbdaa8e81747531943466310c98547f9d3d5909a879fcb13389fdcb6448a4c25b8bb68074c4390467969aa61e15a61b9616cbe59fdb89ca75578936c3f8d27e3b87b23a2cb53057677fff834f42bf2b0de4bd97c471c36129f4eaae714d4fe0674705222cbaee7005ea849ea726e01cfb8082cb7e25032c6fd1f61522f204204302be89eaff4e7b61b8b7ae13f36c5df7e7222006786493ebbac0067238789750993716bdc33f0412c44c9ab882f5195fc3cd7b229175bc587b9a7aa3153a199b58026445b645d1102f4ee8efd90330ea50b2bf1fdad14d305da4917ca9c0174ab8e1103ca2ecb490249b58e504d74452bec2a8716d1ad9d9acca1898f9e172ba2251d686eb26cbff4e8fecd98fa5e5572f2beb0ef88f779dde3348bb451f2445c6a5b74e699991069b7ca88f61f0dd1753dc465e7128ff5896589d56bb43e08725d2a56b39a8d3bd391ba72a3209799150c22b573981fa27a1d625fbf0740feb4f765be4c57396c8af9ebe3e12874dade3ef5c3b3b966ddeebfd0672efa422df68b5b0028cf926c93749ceb8fbaddd9c2c2f36cae0132a17d5fbd462bd50a0a6cb72441dbb57e42f1049d0bc738025ce4504db4fd2ed3139862d185d2100a3c26ce2bdece1487e0a0782c9ddb821b2a8fd15138f427edab2f8c359d6c2453d1003527081d2837a9589025bc8395aebf03cf98ad00ef7170e1f0a5942f6e9117dce0171adbddd18ca63a93184addbb621ffd943f106c76a541011b78dad4bfa81ab0fc9f881ec729a40cde7507bba1b13ed1579d91c92d449e1af57ff7304b43f94f51fa258645509a31686c9a6a00ddb998937ab67891a0f7e0ccd3c11134ece008767336a10c5a75362bf0146a2ede0d76b856821c25ebf4ef37297500a3e8eae057b989c1f4ed208f295ebf6f66a6247eb039b0671164f7a18ad94913fabb4ad7c3ad13072d28ea86dbea7775fe0e21309b8f1532c83aaaf7d4fb552145e14388d80fd2c6f920d01e83746db7e16f06ff093842c55d0b55a237e0c8254c1eb34a5b40e72976e743a57e2b02094ccf7fffa9f1ec2291e728d0c03c29e794122b15210639d1aaaf449a3bc6cddf23a4345fce9733795eb74463a3efd3be8afc966354e2925ae9264d8619899c0e0abe7edee0b4cadd671c52df479e8f457c1f9528fee71e817ad0d5a4480d454a9cb2927dc50053d7fd905041e816bbf2cf8b50ddf53f9b1e1410fff8415c30488c5c55a7c9512d5a7af02b29eff124baebdca004b73298771363c470744ecebfbcaa61b6eeabd5c93beb191379d30538a5048fab05b1ceb890ce7779bd99edaf2c5d97de3f93b4dd923278bc723bc41c6e03cdb308ae276250e8fb199010ef4e9094431adc8ea8290e947117cf132415b9c7eef19196f80194be9f340a17577851ece98748f7bd87b3fc80c3e587a37af6679776be7e979866a4a053e1a3f4831b53b002d70ff73f30f7a492ee60128308622c585c73da8da10485bca0c59fee14147395a18059ad1b3eee67d1d7053928be45d06f6b119c8b8371e8792310cb2c6a38f9eebd483d01e33532ee157d75ef7823e2c84a73c8dfde158bfb31779549d5923d6f9d9f40f0ec1794133eca3bf9a57f23fa69cec93ffaf6aba51570a950d2c913b640a7a58a57fef34a7943370098448bff1e1fb11646c28d4904b69021430671cc958d37dbb1c96d67cb06dfa3b64bee3f84433041d1c5c6b68f457eb42e724caf24aa16ccc897adb85a787846841ccdb4d6ade6b432424ba9bf10e94146a2d2ae65dd33861896de783d8382ad552e137f28950d5e2b768f069f406ba5e378f75bda0ab18f3f1dd95e5ba106e7f0699b063ef717df6df8a53b526e220464675cd97c474912a1de995aefd0fbab54c8a254804fc2743fa5218be247c442b88619ba97ad057f5280f242cfbfec282616610154fec05b19738c9e1b99bb4093ebfe4c5c51798ff2e83578ddaf6f1444396ad48499c7ba9254c25b292de37c1d1471c79aa3b33b1690c16e3d16899f686a33ad9ccb8924aec1548dd88ce24a6b2b7b3e39b618159caedbfab281ed9ebf99ea21b1ae8fdce6a7c520b038f51c378071a9b5f3842f4808a7cca019e4aa816c4fa37b921d8421da64c346d651c8cf8bcb4bc59a2ad9f6f1e467505d3b7204b9ddb60ee00010b6cf252be70d522c957df6fa9f10b0571408943744c2b57d1e8837196e42294877ba3bdc6d3f110cb3ea6a83917bcf149f9d6a50878bbce046634fc9ae776aecd5d0860f5075247732e544fdf93c1f19e0dc005d3182d4e46f330fa274fcceb971abd321c38f157a30b8e18601eca67f97db4e300de31d432ad2127f73796ef860d79f86d10da9b3e64fea4def67f1e7bbae7ee953d3c84062db65d3e77c60178f3087e33dfd5872db20f6878089354b1049dc9f3b90a79e03b8af7a6aed4d1f920849e4aaccc5e341b72746511b7879f5cb62db6839d25a7de02ae8d8bacd4e868bb72085e6db8c5903e4ff13165bffd278221df4ba3a50894e744327f10545ff92ebc427a2f6deb6ac2566340349e5979e8c3d94bb6a6592fd085df67d09e1981a2b00ccaa843ff98139ededb6c3870a76980b367da5b63328fda88c9076fb069fed4247bc911fd3e08a12763e378842a4284f1cee230a47479bd68f39b5229f818ac734c984384c149d6a674e41c020127160558172d251fe1508517d4502d8bbf1bb1def574ef93e2cd140dfdd9cae4ed24980882e9fcb366c47c2ff180e910d42e7cc1be7d40e1d0af3dbc9c75ff2be139230bc8bf62f2ba8f71de2aff6128778895f5d536c262100e7e670d7b924c06384d80bb3a402881fa9534d2b8da4f2ead0023455e71a6d170a73d40dd9b251dcd3ae29c2cb99e4a15f01eda5b5d7272a28025c4a5d57915e0daca109a5b3deb815a064754190cafdeca00d437a79d6bee778e294e33cf5d5597b59e60b27853c99f9f89160fe03dadec69bc853f44195e0be60aaadf8576374c0ed8b2e1d87f1b393f05ead14fac31dc5afe7dd7e40e6f797d44b0cd95b2823155e5a4f1a94427cf3eaa7d6717c2694d544559c5078141dc5a4b6244d505c81c0b733b63022c0d26b58b2198573a252fcacc95f24adabc569b03ce5e2f515eb58f7a18942e43d7d73f8002633f7c57456021e0f8a4d6fe77dbeb502a133cd06c8d991340ec7b66fa3e3287da6672e4da9ef1140530a128356f7d595ec930040d071a49b02b9de78020296b4b2df81d1ad21637c67d0341489889c44bc592a315c3393d2ac52458c1e61fbc7067def68612a65442baf00ed2da2c44c91b8e771878df829404da413e43d0f4d3e40495b0782d9d930c28d5d7f5b38d6a0d9787c89db0dfbbe022917d98a282e95753f27e40750ae1571d93ebbe6de36edce22d715173064f027a5e357e2c64c5e13114f01aec3218a90b4ddaab0928c6c7197a962cc70be6b3dd6c89971a33880929273dd4d9740e8007918472016f980e75bac522aee66c67843aef1b32ffb532721387fa2c39f82b1f199d5e1f867da3fd3619cd1440f849649c6bcda68bb6e360c32018db22177ae32738f33d4bbf462bbd18170518a4d9d3016398e59392e8396beba003e8e016408b0fa853f46c085ddccdf0decf62b4f0406c3cac5a31fcc30c9b8431d5ca8bf87ce71413e55fff3c4b744b7ab90117924ae01373da8a28deb669b719b0a2e0d0013e2af61841333730d41e3993387804968567f55b6f80929d7167022e2de7ddef21c34894ef556808b83456121f05620f706a8a2826b6ea7ea80ee8f5b77d28b33d6ee42669e2277ab951fc8608eab698aa8a7f75c6cee7226643478a36f8537a934858c9931a35a6471fdaac7dd981dd4694c3ebbd9bc578a8f540d08469f13d6aec362c0892b460cb752612f976a2f4a4aea55331b4e262d6f6304c8d46914c9fa10a343d2b156350ad722fb1bc0fd13c79c08b9373b491022400b951868cc30ccf2d42a5c03205eb25eebcce9faecd5a3b7dad9d72056d3423c7fcdbd976216d9d622c9cf532b9f7e6f8a9201ba3e4317ea89cd205c9890bb38a9003d10f6bf7e52ac4f48ba4bb906878cf304b60c1ad6399ee25bbed59e6a6bd81db8c4819e3e67aa6bf088b68b29bf1b108e252232c34d796aab9b704036d5a383d4c31c4966ab257b4db238c7b2ffaa7d48694cd03fc8461dcac8a3a96fb95785c1b0d9f3432ae69085d12c737377ed890e6703a5d24276912cf42d5a3f970087e848b8ff36e01628fe761f9020c8631fc4ed8c3313f8568bbdf7656d9e9bba3e89201b47d26b01eca6f0ea230ca6c90170dee3f6c4fb11cf93eda3b5025ae31504a0c2ca1005fc51bd65dcd0c0d2ca91f954694233b02580b6715d302bfea06f4f995b2e28c0f793ea5899502a525b42594da82aa9d7272fa38585890bc74ece1bc6fafad8043705d9cf84145f703dde8c773c04e3776b7099de7cb0292380b8580a5494d7cf4b04d8423113a4c9368f251199b685d068de914637a5582bcf667e79581ff3b5803320ed0f3fdd7271ef575ef8fa53db247ac62f03ae2d2519349b9bed83c5f45e22c8180df23b1c2c1ac6a17a8010e2618365cf98fd665b4303e854d841ad6e6a2b636da9ee9aa31b716156d85bae7556e817ba0069d20db96bcdd56dbfd4242a4f23a426aa180250976a8d6311050d11c5941446125d37da82629495721ff57bda43cef4e8cda23a8e2d810917409d7fd36ad34c9e4d9f9475dc884f80122b8758601d2179887be1aaa492f0da41b15be653a8cc8ba7dabc01b3d6981c28edcacf6a5dbdf9597adaf7f82d42a186f38158ae342d32a333a7c6aa3f9db6a711580c7da677f64bbdb2deea76eddb1156d1cbc5bec3eb6bfb00d5ed25d8b7d32df286629f47f50c4cae114299f9a9ce4319b4846cf988b171dc49ba29cfa740d618f731e5ac5cd758345328fe3e04ec3f636a6fd8d30119e66d62cdcf8b06dbe0b864baf703fcf4efec4b62c70e4a4d88763b7a8a362026ea4056c82cb3b6e1a6d35c515fc2db55df8301e885eef59fa6f72544a1f5251f353d0b12c750f83dc720aff4c161821111d93be24c189f221f04aafc6bfa514a0cfe0d46a1f295cd8abb47476845ce86c4af98ec8408b35f37b02cab4b90586a44e7ebba0216ea8d5c97e7e711d853ab1552bf8120ad2adb0abd1e334b6f3772719a8d97ec2d7e4aaf974a01c3b9a68942957022746c83b6836c86f0d2814764065a0f31dbe6afabf0400cd9f435163f26867f080ef5519625f0a24652c04a41d03111d9cf9a1fae8a6a4865bc4e79e5907c8ceb1caaa0a955cbd9204a4f6d6e5513bdd4505d859fbd6a069fb5a08d1a77f12a95377ae72bed82e35486344875461db2faac3683f062b7951c5394ad3ddb3ea09f877ea7c8cc8bcc5050b4af558db09d372d179a7c13ff35134576d582192f017ce5e3a73f98295ea803a9cc0e26e52e0250dcf51a34160fd9193b303976a094bf0ef92b1f0f892a0c01986719e0855de97396bbe249bf2953fdff5db4d61f5bdab500853dc8cd75e3083208f3661c8bdbbbb94ec4e1840a52e436f79993e62fe9904f35e8fa0a824e021d7ca6d290c6e424769be4e2d61dde899e3575a66eba3f44b847702a36a06709b46019bb45fa30d5069e1de1b9b2d6d1b754f8696af3272d3acaa28527eab9c16d53bbae3c7d96ab63851371c9c4ed94a37daf6da7ceaacc421627e299903f559161cd4753f66bed974285c630c57cfb7e8f03e9f4dd161e8283a26cfa5559849425cadd7dcc13f4488e6371acc3cc8da8ab8ffd01c4cea4f359352ba10f661572c096f2e9a5a934f23c70f87c3a4dbc76f5e48afa02f93abe6b93d9202571bd70aea998a343662e7db9b84689ff1153b6cf73adc9285b2536809db5f572e55e92bd58d9fc21163389c68aa439561cfa5457970266b57102705e8341da144ae26bb6f9c79a7f1ddf682200931c991b444207c55cd4b22fc522fe3189b65b6ff97eef6b02644ba93b4df275e4ce708581ac9a8005e6a76b64bd15771da5043466f8604ec19e11ab9b720b027d9a03dbee61df6836e27cb1c2405ae0c998c54438f51a1f5afffbcd00e669f47ff590f9a38f76f28c141458f1ac08ba18ea27543d832ed617f5ebe96482bac3c495041f7d49992845d31b368b2da88c580caa83e5a4171e81305cb3c83ffd807edbd3e1f350800e7cbd9f31e461ca05e04094bf6aa2b400234556c188037e0d55218cf10d909078f5e1d4ddef6f8ea99a84e36b488b983f7b7324ff02203a856ccd96f6a0c8cc2554d4982f3caa4007d716f865f8ab84064922215a4d5b41f0345a09bbec61022d9ab03eb4102067a8954dab6fc0bb1fcef33339488f5313baf6a3ae9172f5f4d64e3ca9500d58736106c62da354accc44ec3709b2cbed4856446b35503969cfa3934f9148e07b4c93e48fd758ce41ecbdc29461d87d0779685e74e4b75e01d03b26e97d080a00540f7543475cc532c9ac5114e72a728aed8534a4af60d8781428c99cf093685dd6aa8a27c2c5ccf55308c5a37e7a07e5839e7422db429c983cd11be43dcd5b70df70dbf51b6d750ba021fd19e20609bb53bcf7828076e9f289b4ef519cb7f5042ce735ebf5675cbbbf76b3279d85e1c555d1fa1cc6d879e283b214c07add774871f031fcde3c6048c50289175c685a1f8f396a80dc68072f9298a49ece6fd77250ccc7290d030734a5267fd358a43e3cb55630f47676a4cbed58793c4a92be9431b48e533fa8182b4cb2be8fb29ce62b06512a9eb542ed03dcbecbe965dbc4c497728508f3632878ca103576c23efb19e09c04df7184212c33ba894d6efba32e81644d6d8f67e20248355c51a7f8e91c329cfa65dc5307b06951e5d18827ed5e2789e63f0a878517e6330663f0c59075dee9b878b3b0683e0150a5fdc662700ccea067067c8996c2eec3fc63d9d4136ffb1a97dedcb0b131661639b58b59fe859952b7b121b1cf62babcec12ef54eb617cab856e86d125c4c8b20645a18332e96ce866893ce952b4d6c74c82f5d8c33a425598f06ae4b308485f32f2fd6eb7c56df31a8e7869c8af55cebd714cef18d14cefe1707b0bf25d6f54cc9525b0c9225cbc1b5b4081988ceff1376f2ed400aa8561a9777f5801482872c053bef189209f061315c13381f7debc586c332b01e3417b84d5d0d8036c439a06e3131f8283a90c24ce8dfaaa3990525757550ff7400b5bff00aa83989cf7cad2f5c5426942eb3f6f33ff5493e681850c98c58c5a10c5f1b0a706c72fcc542f91f743b9877ff3a0a1de3e3f3ec5a91e0724718ed1ce04f65068aff8e32ed7883cafa2e266b6b6287b58c686ca9a19493f3efcdc1caca7a8fe1cee621167638b0d726a7145df9a2266f71aa945525a6eba01c3eefad9bce426a990680659a430eb9283acafc61fc85364d27aff4173c7516c45811061c88fe7c650f789aea1218bd0829fd4a2041e3ac1afa2f2c47ff02a2e2cfcda1b67491a63ecbbbde151e172bca9405fd6612c83a24189e765eb1339afbf92311a165493e5e402c5d5c7d779b2f59a66b2bb8fdb4a020c0207e2ffe6b4a36a3eeb2f14152a4fc754539a9837b005c9fe266f43bed5aed4c8049dc3e3f3b120fcecbe36ad46888bb6b902987517ef3448ebbe4351eb2ac6ebbf95b8141936d1f8369ab2e93d8148ae80ffc7ab2ed2eb027c67d9246d24e7ca346ea1f9d049f4b66b8379e0921683fc22b6ec88a8ffa346e6a08530e844d1e9db43ad31070648eba480829fd5944a9c51d8c5a15de394da1af75586a6808067007779f373d453840e61da4a8b8a589b8ec62d353109f039df018e26f9650d4f86ee69ab7268b2904ddc6b5d4e2615690ce453a343ffbf81061f32a60ebb4aeb7a5381239f3ba8f0b84a8dafadb2c705771621e291f7275881a1e0aebcff5281365653893a0cb2b6ed7934a781bae22eb7401edce3255594b01b9948a1e251e1e257598237e71d9f4659adccdb398f6c3c4f7a77a0fb565ef9f6a4d3e39be8094aaa4f96ef5df7161d9181f2bda06a6269f0748fe9de70c80b7bb3e7e292e5f76b961a3a7629308fbe0cd36d23a1aa1dd4bd4f0197784d2b30cd4b0758bfd1033a074a56e90c87eaccc6709462eef6c5aed5e338746f1c9bf99c48bc587bd0389b4d706704fedf87075904b758aaf7e7ad01675ad1c708f7711c8109a6ab79c97490fe2ef4690a63a1d70553bba068000c15d5862b41619b8b6914430dfb7d83737bc86d51f865e28539e13361ca5697c087cc7ea394c8b842b86aea121575412ab45fbe859f356684e63f9a086979a0896cae46f6aee62302ddfab3c47e9e467a121155e5247a21ef49f335303b12fd42e4b9b3bf3ad8af7ffb58873449aba8853817284efdcaa7fb27824b54a2418bda8d8c28d77374603b2338983a2192c326f4ea15291c1cf3b80bd40400bd330939bd0bfe9acc0039b055506a01726ee8ecc944aaafc5623a36e541f1fba5569475911c29d2bb74e921edfc44a9c4b986ecfa61096d68d4e821e1b9d4931afea384e02b73fe1803b5ca3f6e8b938daf2ba6cebd53809a1b43cf2259bdf9d1f850f0d017d2fc21fa907b0a2b3ed7edf90c99b4bdbb5df5ec6086890f12721d304cae30cca7dc24dc55560fdc8d909fb92d5480e3f442a027b518da8ae35afc6fa42d1edfe71b79eb8e739b40e3e351ae1228caa4e71c648128acff0862c5b2711d4f8493640e979a1cdfad0835a90a4dbb5fb52be856e0aa9b93f860941cd5a1ad16a669f5affd2b2ec61669a791f0133cbc7538b8dc57f0a86cc109f0e8432f491c7185cd834536bc3b04dae5d8796de00f11ceaf1065c90f93275dcd87a60bfff0684da14a869d29272076c05e06efcaef49329aef2cd6a3f294478082d056ea8b3cee27828e79c5033f2d7cfa4788a5971636b6c1f69b7822185af65fda7117551c437d3c4923060f6e40c19e4c1a71280ad954d2cce93ab0f01fd4c46e7ce5559a2da5d77122b004990ad32e3a77e9a9a4828","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
