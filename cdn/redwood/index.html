<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c61f4269d74d84838626a569f33363c436097b06a62bda420c115f5257c57016041c1da5df7be861a273166ac5c2e3709eced2c51f93edbb03e709bc63860b7bb86bb1460d13308b59546f2643b74c4194783a6e82e53d9d7b810729c5c8721d9f0b6bd4a37efcd90af04c436f81206c34f81a3e01bb1aba737ba211ccc70fb36aeb99ded7c5f044c7dbd948109e23797da1b45ab61f5c0200b70a19492cfeeabb217986e770039bd78a25d01ac62944c4a0caeca6bda52ff51e54eeb894518b7d9514ef048285b308f26bbf8c44dd428421122b72be6a635c3beb0270e3b004548b394812d942484863e6a075c32d46714466910e989b45deefc2e3e9853abe43f1e30db27df8da428852b1896ca383c8100f3f201baf82055716cae385e3bfba350914c67ac0031a31ea0a357e55ee73ab5e63df95500135298f19a0d00e08ce35a1583defd42ffde654f59740c3210226c5cbd3a827e622971403c0da5fdcdc8509f5130dd285c001f7379b4618c9bb5155fa2d0ae690a0bba7462f05488782903d321ab2aed397b4bbd7e3ffd4c30583ed052318ed2654fc49084a4bf66f8d8424fe36b0990ed65e2b66b45521ba20b40b6b3232156a94052c2689e7d625afd6a97b9932c391d2cdaa2bcf16a33198e5bf7d788c3237ede42a10aa3ba7a01ca11b93f72f1455dcfed41db88f6a797d1e774474e14fcd7d3be556f9c36237a38a3b26be25483fc4c74db95375127ddd305f9576eb13413b8630a5bfa288ddcf09e816bf73869e5d1f2be41364a4fa7e7492addf65e3558b4fd999615685f14e275342200d5eeedb3d805f06be7f6dcacc86452d45ead687ea4cc9ea07ce19062f28b64ded0763131baa924ccb06f95e61dc23fc502c17e6fcbc3585936a31941f86fcddb5ac3e8f6b09ea72ef03bdeb84201d33872557ff06fe76c32229e930f1498d653a066434fb20d0ee2a2cc1c678a35259a5c4d4dc4ecccbccabecb17c113866f774b4ae433991b6030f4f8bac8d2078513de3720eff866ae92f82878061caa31ff1b56e154ca562c781f056cee190c5af7032f0cd24e85de53be284cfde70c091cdef41d1631c28268c6003e42d5d66a963946865f360720e7e866beb8efd7797aaf7049652da219d00988829406614e302e835a7c11844d0b6c4d977927cafeb6feb521f0856e8ca1db942d85c75d429ef7958ffab98f996e96e29ae21005953c08dbf0f040ae8e431af1acab47ffdba16996345ad0f06c21573c03a5d3009f301acce26e71caccdff28b8fd483269d37238030ff075a038270cab02dffcee82074411aae94c8dd6a4bfdcfb17cfe973fda4fa8e2f2c47b15393e32c52650a06ff1e4a46663cb9654ae59030a0e0ddafcdde1e24866f33b3fe54aeb5489093cb38892d3add7cfd7a7d57d957e7f09c3b7f3c82653c118082f3fc6a46e4b1f7e6a0c9ffc92aebfb0a0db5ae2cee86dccaeca017ed68d91656110c7bf1e0f2cb1bc2b0b5ad61080cec0806eb7248cc12109a1764c9e21a1ef830118fec4d97c5995cd120852b866f0a9216070a5717cc63bff97388105f78b6f34d3b2b9227bddc8eb92e8247c83b9383209dc49ec8221c9462a20cb0df43243ac6c8fc8669cbb95e066a2f70ef4b54151a5a0e651a270d292fc693094b5c10cc1b727c5315dccac64f3f8b525fa7a59f1e419916168771ea06f257fef49ec3211cf1ff90edcb840f3fddde84cff5c29b11af61575b3f8af25402532ebf6201eea7dfb6feb6beee3f1455dd1eb3cb9a46d753c23d1f803bc7f806861986703d7070dd80ba53b64156f742418c6977f2983cd0ba321ea2ad2bca74e6d9207b4bd47002ec19b98f1816e31ef57fcde0cd373a04c7b5409a195312ca3d45acdb2ca3c002b122d580c1331c208118756a5a3e9a7be3e931f4b4e9194f7f373cc787d5aa42cc0c699dd70236c65cdf67e85f976a135a6cc1b6b311909fa517d14580d33faa780354e7ae9bda0df55eb2a9a5b7ce0ecb1754bd6470ea434410106c8abcf6ac74bc841182e391174e63db2b4163a740f1b8e7b625d66d950d083639014926281bd77672dac86feedb09f8063e1fcec5eb5bdd4cb69afd82b46455711bc56cef0f2788429fd16e60d1f75355ac2f8c7b3ccd0de2fb7e60a4f453038d449df2f860f35e294e987efd610fd38b7e56b676cc4b883a13513ba768dd185e99c4f996b64d80e449d8667dd06c1932a40f77295014f7085c6fae0b7af27cc7e6bff0269b01e2080f9f31c557138aa2aa0d388bb22cb472272c2d5e67393d2d240695a7704d9a02f62028231ce74633d32497707757b0512c92a9c06a1d97f778b89255bf13f9b49e0dd0a2d7d66cec0e57a7c93c7b019bb3f26f22c22e0a4a8c9849210cb9996cf59f4703876d4a981429e153f284e052ea8edb32e0ea84abb738ab033f1d6296f6d337b6f3fb0d13ff353b8c2f9bf80a64311c8acc02b01688d6ac77029bd08581166dcbc9ee70554d58c78f3058352ad4a19502683899df813b0746cc8a4e4d4b0912f5820b150be57488294d0cd5cb30e595a3704fb0aae4a8fd8454e73e9719ca404dedb34e01a545489e7408cde0c69b6a98c1e8147338fc9239625d0f43a9e714b6ed31dd81e5d59b49ed1f9b8fa3281de52e38def00d5e4c1dd180968ca4436b1b5f15be58f316f446925d3e7e931b4dafc82680f87254f88eabf76b2f52aa240377e11812515e27e45e2287986fca352dc1a3e30cb0c79dcd6a557b76b7e7650853b5b199f7c38a487ce989e3416c4f4a119d92a2eaea0cb2be086ad2bbe970e66adbd6ec9382333a7cb0c81e1232ef1e06160f3a3a4b68a946792e42d414909034533de5214508be9a7bd8bdf3e0197f6485e68d16fe51efaeab26b7c824ad218b41095d1902bebdc8daaf6288898614490fdd1df322338fefd3a242e4f044e346ee8a4ecd957b14e99ba8a7f423157b1bd386d82d9a5391aed41e146cc4f69268d5f71bc13bc224f1d5b195265a3fd7202531c3ee7eb00bd8440bebd0a711d98788bf44c4180e940c5f7ff6ee61417d150557c5c025a0beefee7b6efcdf5789995eb2f5e8f45e7faffe85bc0c8c596387b32fef687a7a6d4267d708cb5011503926224a9b8ddfdb03df9953b1d3de1e71e5c41ca3b818b2970abe1f906134e642d52ac31a7481313668c93bfd888849289f4de1843470b72a9c30c3f2dbd9b0a69448a436975c17f031c0325107226512a710c15bc884fa28d7dac3a525add52878664d6312f62328d95b7a82339daac07ec6b5bfd2f6c7c74de91de6a496c225228d442dc97bddb44228ee9ab08b693869159625eacf1669d531c80bacdb92738333bf66003aa867a76851343cb62f023159ae9f245fd1a86fe682d5b50413c0589898799c3017ad59685a494a7cb2d79652f7a282119a8a9a6bbfbe21d5f9de9502ee8a0285ae211b049c7e318e3489049cb9e292ff96fd0c6e75978282548e3ad1a37a0e6703d3a08ab7dde14d0e1519f0445f84de030545722ae098f8fe463cd40632ee8d39105a321964635d2f3f4c7f50fd5c06ce501cf19bd4c81cb254c3dd582cf4c678dec1d2271e67ffeba5c33a0fa7c0140c83243c1f8087b0b589efa9b106dc1c01e0e00140c17524a7947fb791b8bb5ce47a20163b2760e0cf8a80129b2bfba87c40d9de09a7f5595cb510d8c2e39fe497ce98e8e9ad7aad7bd43820c0a83d4922edb762c6fbcb1572b44da235596bc0026013c6465e54e2a2be18f759ea5d24785bde907c6d54877087b0c87b8640fe520a9fddddab161072b22cf4dad30b7675757cb7e534fe77248f399cff9092c9418dfad8afcfa3a3be3f4524cccc16961d08e323671c8cf6c64c8bfd4f4d0a9605e76ce60cf9f7b897150eaf3dc4360eec7c7bc5c0adb3ef33613791a82e37d29f320ee24c7e48801117425e8521bc94799882d003068ef03c33c52fbc7109bb7ad09a533a04f4637e3ee06f5353c8d5459beee8af753f3eb6d263422503e89efa16b4ce4f057818009775db5a9318653f107e822d0990760c5b578e5063403b555048489195f4a0b54e6359126110f29fb6ddc68b556df8df1b6028ab8cd241a017465d173cd8431eaf4d64d286c489d54672c144ac9b34d21b58821d5a38021ca91129837560e78ae6db0e7d620a46b9076199cc19f98bfc4e36b0aa029c3665bd3e6186a8c34c919dbabfed00424e7471348eb2a6f7765872efa08d7af0b74bc642adb202986c7af8dec7793addbca3608639794d1b6e8857052ae189a906e54b26e6041bf73b2e7843dd73f86ee0573b982d844a8dc869dfc96a56f289803f7bb6a04730c7f32946d9f46a77330d082f60f5af3f3c6cb992b2cbdd9cbd1fe8a95d73a8f2eba2a79e0e9fcffe929779059de99f2283617afac2139a282b55c9ad9f5b63bdc7a739ad810d4cfc2256b8d2be86347c3c5c8905f26302c8734d00b4dc7f5aabeda3249286093de872d9aab663947afa195df04917f28aa0a62a57edfce352bfc8aed9ea9c41c9bd87a5c0261347226b2a6b92e264cc6769477a99a5b6b802713e6652c8b6736b6f51d42ffc13b593be9228bcea1cef3a035e5acb7a8ab3af34d33146f6e01fdff5782bebfeb3db1c5c246d07dba48a6a0a801960588a032d1036354d2a70ff2016af47f82466d5c170cfc287aa57d41aa227a9320adf335d2f28348bac3044b7d14b9346f06d7430b01a364b3670e025619a060b3ac2e37bb474023d1d59b2436bdd9adc940515f893b91eba8f9fdae4a5e343c0999a2466b45ce24e15deda9b5809d560674105be000b5480281e4dfb22a2a51b802b57752b2804a7ff0b0db3ad37c1768ec1b948cf5691cae161acd7d875d861b2d809f02ec5a4cc3bdf809718d744ff993e665e65a0c62976e2fb3a74d119790b6d78effa350e5dbb7f36b5d4ab14696036dd57899f0065e975e2d77afe61c27900454e8117cac1fce28df602f594e7c51445877ddb7fb201c57e45e9a3aed6a4832d5a57a42c15e22c13c08ba6e2344562f5b33ed455dd6a769adc174429e28e130d4f3fe2418f9b077f72216d777a08d2cd1df26e945c3571cc9ba772f37562999848c4d542443401508570460ac6a979b6612cd62d75f52b365d82db20eec740285d39e9bfcbac1fe7d195ccc0082fae1dade3438faaa6339b9683fc065594f2cbcd913e372d8ed333dc8ed3282a7d7d557b2731038492e6f3f23f96257de74f7db0b4189ce9ad3cb55fdc71bfc23822a26733b2405f45fa27b7b4a370ac965daa4554756d29971f6990e51a4c4581a7f874dc75a3262093ff83c4d5e4c57de04b6946b533273e1952973610b9f4b47a6ebf333f16488c0e57e3326cb5a7e1941965e138ef23a2fe1fd9c8e58e5f09e70d365cddf63930641ce31c7fdd8bb8a0a1958a78406655553e6483fdb42991ef0f54dfe61ab945f01521e06f2b8c2ba8e95b4de154dce4a2f767700558575911b112a10f6176e155061af227f8d34265c7f0cb54d6f3925b6e862b3a9428c6fd977aa96b577f40dfa0b3c8562fa978475ff565925f4d191237815e816f3dd7157f040f377476c2e17dacf7ca15756fceb469a8dd745d33d14cebe4a8f641d9129e48e939408bcab60ae5698027d3b7d1c1ff48d2e61dd815bda1063d581a5860c695ad9d3d9970b88ab59f12cc72b179d63c8f7452b1550c4eea464e188ef9bb1f08082c6299f07c2f37f3eb18eb77ea82b40a73080bed59a1b71d24b7531895ddbebfd4670ff7556065e47e42ff66ac850c9ff19c2ee0a4238b7da7ee35ce8c9bfc449153212d55ddefb2823576ad12240f00e6d5f2025fc3e17478abb3fead6df8dd4fd6cf8b87610f11817119ce7224ee405bd0d55e4832e14c7a93e06e57c2fe58ae4d4b1a6fede8e543ac116b9c81495c33a4d82a40c7769686dbaffc994f5d07e4e78ba9853bddc2168b714e6d886c4e5ee203897806e3f0f294925c54428529b7079998a0e932e93f2066d89f1b684091302ec33c3ca994ddf7e01e05c815a5a4ce2f00edf53b24a0bf95cc11b4e639b1384d3c4a73ee660c150cff7e4b362ab7d92b52641a6fee8a05142f36ed249e818aaecd6f4ca65defe4265b19d61093d60fa4e9e56abdc6dee0d2f870e9bdf0369a625200e0fb0f1fbdd4a2ad4ae6cbcf193ab6e9971a9b1ca814da76827430ffedc606dbfe35c67cef928a9320acc21dd8f414048d16c626e36343ff359e432de26289bb55a61d79f00fcbd5319f2a3c8a6b5cb4cd933fa810a9bccde7487a01cd16f9755d0ed6218ac452d38c3ec7b06ca8c180f96c2638a97a25c143d5f838ede39efa53254816b9e12ab1f5e5b968ba02be447bc381244dbe2a6efe16706b407c70b3ceea3388e180482e4ac6e4bc52afcf2a37e0f2b14db80556c810035a2a238048994781c3424ae0446762d2ca8ec07d57598eef8438790b9bfe36b22e57c76f8d5134c6bb67f09d85dfa9be15283c7f40fb134bc7b51150a97d36ba9b076659001028320e1de6b7ce4f20be59e9cf3d0753d886ce6345e1ca08a7727d32c04334ab7e6744d2f9e19d6f682152937b712f586b7bb21c74342d94f91459d4c159636d7a06fa83b3fbb24e3e67df3af85ebabe083c35bf19d9d060a71f6848ee9e19ad76430483e697a1692143fe2c366810197051e60b609bcf35914a9f7bf4c5e04341eeecfa4d5c2465130c9a88d2c923a8822305a257704a520f9f6bef3f90e5db7abac9533d2193e9f0af64195db5fa63f0a3934c41a9b377099cf5ef79e40bb6592a4ff7c4b472325aa691731d613c6c0844da516fba6e55218cd5b268861d3eac409bb57eb2d73773269c10b951d655d0274ce57b02eafe0cf23b8299d8ba1cf477635c0cef3789c18fc62888237078684af03638a34aa900ac918137ae8b0e3a21156a6643b647e476877310a059abda1623041265fe92519025962a5f4bd0c7a88501a2e094089750ea6c66ab8f296c75d95253a120de0e086d6aad29f0c81a0acd34c462db7e83a869fe6682a2a61ea34bfed94e4a2c7383fc552cd04fb7e1e83450e37b68eb7d0fb507f41ca7db3999a9f2c841a9a4fbe8938c461d89fc1e2b4025afcbd0f10623db3b38938c18738f388d3e1fd2688ad54efd59c261d8542bb2136a8b8be6215fb2df531272a32ed93df53210809947cae8b0d3a0bf8be7f7c4855575ea53d673d4ca0a8a075e636296ea3e027142aed6117e8c03fca754650907501ca19c296b688bec556a2378bf7e87e79d1b711412285003b366d5eea676d14d1589d46c132b39d4342feb89703b6d36f1d40808402b3aeee15f9c2f036d4050d77c3a571f2d1a16b9abdcad461d403febe8f8c9c548026b4fdbcfd961c8095563d7d9c04b4deeead62bd6f2b4220a7070b7e23cc07f6847a29b8c4de2aaa147ba29f5a855186e6a14168bb7697b152af308fa9c1013bc2ea6b15c4383f6981c2ceb3b14eb5ae5b6107991cf04c570b5f935df25902c1306a91c78b91e584192a69b756dcc9219add36a51107476e28e4f3646b0f36dd59a631803c945d91c08a51f70077fb405f32baed9478ed05bf4f9e38f7995196b314d1746b28b9a227604e50cecd22193ee760c6ba04b3ec04a567ceb2d4f3b401fd9350bc880096b9f2ac80083fca7f1c9ef7d26b440beef45f7d0221fb92d474e5ff8261995011b400db6a988e089de8cde085610cc1e45fc6bf88c7b111e330d0a5dd2ed5d4a07465d9c33e2b546fca2e90ebcb586ab72e3484625d5e8f5f9fd8cd78d381fd3ff95777e0fd704467f8c5a2db1dd6675274379c08a9239b1310a9ad6c62a81cb701fce79f3e8a245bc292dce18dfa20dfe0fa5f114c1be6cfc7ba6e38bb1982ed3c2dda7755b306b1ca7f17d7f19be7b49c00863c2a9eb929f80fb39ca742ee586693e8bce6601197a058aa41c90541e215ee52fc04ccbfd38187b088c1e72a4f1712b68de7c2d4c3b161216a80de9c133cf61af07fb9f4ca9ecc6c1139fd4d989c1652708090c4414319b928f811f2d0486286f387a0d4e1908633d8b07745fe8e698584db4509ad0a177d2f938ff05459627b7c4fa598ce12a953e44f8eed56469eabde1a2a974bd994296b3ed73ef2394c4dbbeffae8cebecdda98585d4b350967107ada0c9fc2805c4b4e249cb0a8b3fe9e8975a722ac729ac3213fc1d01f77daeb98d76c041df3d47041198cba1795d38930f0ef2c2b8a9392164ccdd83feb2823bf35fbfe30e70c2f9ea1722b03abb5c29d345ee7cc28c000f2d9d5eefa3f0adc5d25c5c9cbad00c4ca6407897b6052390a92d924be6b286695ef932fa3dbcab45892edbe93fb9e039068d11734db6e59b278049766555b2d0f4f9770c77985e908e5c4b9532efa89518a9f5a9aab78986f97b8710b72c580d8861b4b3a28450ab6847ff936366eb9422fe28ff0d35953453d4253c8c8b1a7d751c561a39529e1a382490bf267214c2c2bb22c6cc90d886aef35c687ccb113d67a089b1c788e932a50bb297748e812e2722f1929ef2f3ec8830bd98faed92c8565cc443aaebc6162d950ae2a7c0c8ee77f4699e9fd2dcf39e84f74f8986dfab8bd96acf2a86c427d85c10a1972e3fdc0d9504c5a0eff4aa57154eaa0f3d271a71147ab20c6c41f842f417cd755bf5f0c30686a984436f21f43be62748df3bbba1afbdb78ad0daacc34dc5105440dbc258709494f75a97b1fc13c6fcfa6f85834ee54ae684cdfc45332edfbb758de1e68200a3190b7626a883230ee6815c2466752d794b62133ba00096cc8ca12afb664c17048345a52573f988f50fd3c9b5de9ced148b36bebc9ca14a37bd6c3d066e1d65908eb4eca7610b3dda43805db6fcaf92e3f3d3e2536071acdb9b94f716a88f06e2e5efec8cf96488a5e9fda4e39e26cca9fbb839f1115843b4dcd38c00041806428b1c2640261e13154b1d7d98493d3dfb53dc11b7ce107b5a315312b0f0324ebd74e62c4f183e03d058c0c7996e9308d8f46c48a25a445cb0467b8640f25977f2473d595dd1ce393fe02d849d10a41b431796ad96e54320282ea3730c71080ce1dd77dbebec0319b2a9f2d7aeaf255c68dc24a088959be8ed53cab9ffd61e86cb750609b9a1cbec0b7ef97b72bee6e138d95f9202f4598c665272b56e09a0ab2c767b9d1e73f2250f3a7b8df9d6ed38c275787b1b1910b3ee9b7d70a3f10da33b16e2666f0d601b21e4839422c57904ba62281d3c3582dcfae40e5feb1a956c7592c32927dfe23294ee6cf8b2d4b7641c392b97d42ca4150870a220acbe583c12b623458845437ac5f6b682e0b0de6f9045dfe8b304c37a31722fcc2523211e62d2e4eeba9d4f57ddf94767c382cca784eec6a2844532678e9542f57cb3f79266c487b9a61a2546ff839e974b827b591a1692b8eb58e63e83c7991344cf9e7ebc3bf8bfb55e806038a25f00b882e49b379883c0a51c39cafd64f14d12a10125ac1ce8de48da0692415891573259f69af99370d9b349ac3d314bb09c4ddbfb90d3dab0f43db0142289108d8a2483e516d9c1136db29eb238932d2df9798f13b72c50006415eba48b2269d7a958a83bded739a59575f1f8c285010848518cf1cd8a4b53887c082e55d8a86336a66cd4e78d5158f55f11d43c5f2c4d52b8e935bf55b7bcdea0d022ec414b248bec292e174aed5ab5ec76af978021dd1f1d5169bce92e71e71dff53b2ecd7c4eac0f394d9ee7d4cd0b20a618b2013bf3dc45c944e703d931004a16fd0b6c63b3c0ccd504f9bdd56c4349645e2065a0e1c2c61dc9f989be88f3914bd913d197c80e884535240c05add425cab784ef8de7682eb78a231ad3c2af5e05f97d5dbbc1d86a0a17617a3a7f70a6c3d5b52b2e0b045d41066f75759f2002884ba8f0f3776fcbe4bdab05029196fe92ac71f3392c73fca53f28521521e3a6ab68504f2a7af989ddf66aa4101b5c90b43dfe4a68e0d3338cf45ab435d5a66a09fb77e896a68102395e9827f5ef41108276457e54af62de4d5fa1d53d2720df927825153f52c7bd909e9182c03023118966328b38c8585e8d87d36b9154bec689c62f4fb29d726473f1106628dafa54829c7b05047391cda2e129c879d0fe691331d2f5028d67eb660dd8a2f11a6ecad9d564cec82977138674ba4dae1eb19b95c98c6abbfe9542a02bb52a8c22f2991f6385bd3c9fefd266ec1903d74e37d5d48df1c1eda4f7d522412e4a31e2f72fd8689a7c8138b962ed07fa1f4cb64487c27d780ebc660eae22c269fee392613998539dd941799985f13cd70a8cdc961abd0229cf881686230305687d68282f8c308c49fec1d7da429671553bb76f19dfb1d6c507292ebd73d7400745888f832e45ba755a2cab203b50e3f418ae4533ec4b48fd708f743eee4a11d94abcfa2b29c907ded2bfb3c87922ab75a1c272315afe10cbee79800b0eb631e438e6677d39af25a5b04bc6f1cb869c8c5e4190ab2795bc6dc2679cb99edf8e73f1a93743390b13fd0016acc610dae36b8d36e90c3087d924468f93778bd47339b2d3d8bbdd56387a1db174da3a5c2241a701897088bd5de5b8b3c16c28f097451a204abacd43986552dee75e85581e3b81d36dfa22d9701af378c92609dd077a4cb0ad6ab1727fe58013211eb793bae473f644b6c01ab404aed87facc69ff0cedadc8566cacbd4da954b2b049f200a17d82fce656eb88ac7ed57579b204c41ce90f5d4bb7ea70fc85a3a1e91335d8c28c0bfe97bb8e7f28a30286dec5a07dc943173abd4d6df8437ffa57bd450e549c58c58241997dfb2c7687ed7d2306f462b071f52427d55d10b3341632ea6e5ebe1ec9689fdffd6466bf27dba812d94671175d6706485ae1faba56e4bb297f543dba9aaab358be34f98737340a89577652ac3f6374eafad442fc20cbb9c0391a6f8f912680571f092668ea6bcef005c458da1c2272e7f14bdfd7663f775551acb5c1c8b53f45a11e0a58eb93158906ebed30f0d12f70e5e805f52403a1d91d8bd542aff5b31a3f04380010d1ae261c2c117aaff625c7f980eb89cc28564ce6242a5832f6ffd8740bdd7b347becb61f3cc3ea6720266bb1840499d22aa86e98690da2f596569946602e78d4a17ea40eba6d7b2658b54d90759d98f1f5887e40b694ecd6986d05d36ea18c1cde989643f9a8782beef9f1ee0c6d9ec80d3e634ee7527bfc526a97fbab131d6c581dbd82f194a0699a6b566aca2b2c124dbcdce57e57ec4f7f194fe22e4eae310f565984356421e775b5e50be09292dbe5704c9cf887277d23d38621888653b5f25ce4ed3507288fd26f453ab8bc3819c860e2c579c33201aaf7c33205d7c9dac2066e12cb501cbeeb448d9a95478e644601e0a6f064a37ff05749f819844683a1b8b6057afea8e9ba9824fcba9300461c85eac6bb136de66e262ad0fe82b4740878abbbd97fbc059b82d7b8de91fa0cb091b23c9502987cdcfb3f77ce13922a4fcdf645c537e6cdd9cff6334bd848d63eb9eb6161ae9d1481edc3c614fe7951c8aa65da276b1c4909603e83574e13c83b80fa2f557e94ded8c8c9037bf6e903629b7f216e88060503a6aa804127734283b8aac3cca143141944a31ec00cc197e7442d83a50bc416279d14e66e6262bdca00213ea16f82e230e2da0f6709f0353e2b10aa05d86ee33686e2e7832601297ab05acf0524c2331707840b073b61689806cec5d6d827fb151bb8193d04e963fcf2884406e241a01a5bccdc44856c42c07430bb6f8220f46b445399d9dc4e078afd49ffb596dff0c3a77b50d9ddf60861444cca1f9eea1a71f4e787675987d22cbdf11aabdd13c3bd7b1f0b92edf3d1ad16511884e4192a243583c9d891b1a10db9537e6c202db8253ae4dbc87c28080bfc4df48abb2802926f88b38c51c69164e29ad7ee692dd7b8cc4eb356c0a57f9d9985dd00d31263c39df836eace3c4cd67c319a259f32487221bcdf9d13106099bc13bf53c33ac47e63d706d3f4c5cc545e1d9e000d823bd1f90663e90d70cab98fce70897e2b9146be16c0d1e488ffd8388854543d1dfc421af4666338f179f47d5a849efd7a1e1e4082daad33f1605d83686c427bc6f950d7fb5d59585a670177e70c99c69dcd8bc1cc847c2192208e5d60dd8488c06e2aeb57bfa52022ac8af33394b8c4e49301b4fddfd81b63b5e3b3f1a7f5aa698dc6414b458bdee2b79f20f5e5b45fd4cf007e20799f4971e97d17e5b300ef4c59f54def963e1834f61502afdf317666d4d42b42501a08cb45986b741dd058a5502d76ca5b523c5f65065171a819db5a6d2d36b0f2ceccaee54acb549e1033b3c76f99daae986428eaa15f608ff496375d487e5d4a2e3c5cbaa3db6e3fbeefdd7d54650fe1c50c3d8ab01e8a54def3ce5e343c798fd6cd570ee2d73ca46863a38b70bed68dbb87235be0fb1589d39a4d0e033ccd3efb9cc8f3256e46788721967b4c0ac4a5919c54de3c5a41730a7e5b95929139b872c2da07efac81f9f84c4907934bdf9102e1a73fe262924a1696f7350e434a58ea2a38b92e4e2d0d42f71641d6c56a4c2b77192fb01539a42114dd3a26c390a18ed700f5d50ba51561fab3ca9be25bff243f2945aa73c4120430a278356ac5887842f71bd6b7870b906a408efa727f01d01a9ea76db37f1de9e112389b8aaa71ba8045b4cd2ed5505565456cff4cb08d9b68b0f1e521db8545e5d2dcc40ac693aac7b93b4fc73415519c9aa1f039b2efdd553dc092ecf54b56aebc9f935a75058e2575bea39f63ef26110ea199344a1f646956136ddf266f74e216504638d5a683f9094e6716e0a34e15cb9882cb919bbcb4b200c01f4d77089d1b119c1a820c25413df1f28583738fa58619eb4a7dd7675cae6c2e2b7180d4805d93b6faa785454f088f8939e7e76d8fa329b4b44d5398e91ef643a6a69475ec1f7985f625e6de3daca6028f54c46802c1c6206e316d45d746f65970ea20714ccba334a583957f1cf46e9e80424b639a63f553ac304405d663afb41adec307f68e73afba8b73b8d0e66b35ae7a3ba1e781b82b4afc51176a9abeab72433835f618a1091638dd95324ba9cc03e1ad1ca6efde13eb6439d7a64bd9d1bc6a5383a68e0f79a9d5c581f102564b073ceb35286ce6118b924c54ad1cfd4c65991b8886b425d3509a6430279b0020d76a7909b4ce15267e970e1ba9946ab8f145eb4dbd07fe6284a93b136487c679b34e0ce08f092116d9a8d7680957ea1f055f7d7a5677a7a1ebde241fd31b0b2444320436f577845a4f291626e0eac04dbf29dfd6b5a4d23d20a46cecc848d970030ab8aa6eaecc61d4d883dbe90a5d58f90fd7e7a4a4a53fcd144501a702ddadae97e88bad1722dc7a7b1dca562e7912a7583d50d10e281fdb03861abce8b1f0a0448a3d4374a3aca1b12ce065cfc649b945fd9f2769b11ff8822a8aa00c1242ec7ce7113ba42c6676abc52233adcf02db1f1d4a640a6ff6e4c8c509990286921650882ece6bb15262bacf46f96fad394945c95f63ef0a396af9e6ec8afb8e713c7a7d98711083ef608882af34dc3aace436047e8a50aaf9deb43bd4f7975dae31251eede7f003b332d465e32928600e8f01fd74214d7543bec0f502b9d6996a06e8e91770a15277362fcfbaf35d99434dd0e409a5abd16148f5fe013ae7c7aa28d4e7ae771d565ee918ff02599858bf2e17540f8374b93e17b213ca46bd795746867de0b92e9cf2d1b3c1956544a6f4ad22cab7fea230b2fb8f7cbd4ea0370fe73c2713054602dd6d443fd9e9a10b91c2ae8a219307ab99c859368abf0e27c386319f0bf9fc4a4cbf8cc08abe2b2f1317765db0a1c8483eec28a0cfcb2ec0dad4780e6f2f1eb61a8d1c321ed6898841c8df6ea269405dfe6438e70b12c323682ccec26847519358cba4580f2218eb35338383b6f8e849c1397ba914e9305bfe765f24576ac904aacf9790e99e7209c9d82e0b1bdf22a656054a9fd0c5a52c41cca64c89888cda440f19ae63163619b0f2fb9eb0eb0dfe96bc3b58f89dfdedb1e0ee6a656bec1599075157018cd421e5c29388e498707a22348863db443b66df9134f55ffc8f3d3d6cb431464dc756a01d0bae55f752ec267c3ad9180de1a9cd83ee0cccb06638c7f97a83803130897af6c700f39e26cd40ef1ca39115563b7ec5eb731d9bd56dbf0bf70d73950128edf05b055d3be1e3ca6759052511fafe682e2370af7eeca5d5c775049d2b5b2ba0f1150be63c652e24838b17e4da0b37f233359b3bf40777da34107a3495c680ad25f1c420e69f49404f738d1a3c20e22e8dea32f20de37aa7d2afdad842ad57be48670c1564685a57043f303d2748c92b09c24d0c0ef08fc32f05cdb10cd86af08346869a943c343f08f030c4f1edfb773087965b9c846ae2a3ceffe52abec68daa0e90898a70dc1ade9cdf5359f88095459ba7a2fb694fc244d4458b7ef92e90c3c3f8cce292107584a59936fd3b56912b8359f1993bd17799dfa61f0869dbae295d6419024da6493b1641d682c1f047c4611b65e47036c5bf1d631c293fd1383f04145b02b0f81ad9fd0b626f7ef8c510283b80f4f4116da302686702845cf475cff93991c4e71e74321875b33902c67842963ec5664e85061e5f710eb4566d78cfa062ee8ee982b5fedd4e2cda4a5f417dbcaf8f5c9d7d708530a0ca32b720d85f28edb54803acffde1365aefb8d374a0a400282a89ad796aea99ff113d5a3d55f7cac5cefdc32ccdd8f5aefbe34dcaf08afc544e5822f85ea7a4d6f30534cd29731276d796eddf1ec9d4f42c74b14e2006728242b290fd3a4b362b6272ebcdaae63b62c827711222552cc6333a3a0eb4b85e1affe9b699d345fe35a4a1ace3cd49b450dc42c276f31c83a82099cccd8db9d7a9c334ab175486e5ea837ee1a6a7c24d46d990c08cb8aa3889d9cd05c930d536f72acfe322570aeffab05b9a22d7d61610540674bdab0d175f5728a32aeb81da7f8c5bddbeef26184fbe71d90919a377b1d87cac6afee54398e3aa47ff7b86668d135079eb48476fedf990fe193b62e70f31c6edfe72cf37120e88b8a1a1fd821be09f978da7d8d4fb820345571a48ad34d7664b5e7c75e29d69bfede23056c0786d0a7170b31432e959cdefa53db18395202a4b12dc9407a4e18d189cbf470f6ec15c2f1454447629c27b9ac13152439b9397eadf93683822a2daa696ff6f243386511970c4f3c637a02d4fcca37c2738d6efa6e89ed701aa027ebc4a42bd97e620ce200b61d4f52b93eaf7c01325cc8700b539a0d6c0d5f65d3301bfcede1ba26cb3371a94045b307c8efad7d947e6daadfd829b33fdec03a54a940834f413b312ad24b1f27318a01bd3dc462fc35f80dcf2a922cac8e11668026a0ebaaf3a16df62261fe05e88376ee6be3b92b24f5126de8b5eaf48bf72d535bd6c4638f162dc7b7c3115f825afaa9698e87a527605115d90beabff23d166380d3b3f5fbb92bb6485f1a2ae5e02f7b988e0bb2915b4fa95b55d376a8a1945ab47d3c716acbc6174938e1a1e6e5de5a8d7925dc64bea3b8976f3a6c44a03a397b381ea4b7c4b867e75ea1eead5e84da4bde95f8af77afd2ca5753929b93708cf1b232bad05e38ed3f968164a0a75a270f6308d228c2437a8725f67cf653ccb7ed0ef82a42b94487383e0cbbc717286c6e7e714a481c3a0a15a1a3ccf4eee81362588d357f4d5de78e4b88ae00cb49e5b9050813595d595516c4b71fe0a1b2c37996f3bc02ba87a0bd81f1f4d474c539e85ff7c81a63d7fe0beb75de2fa6c4079dc0fdc7260a5a0c9aafef00fa04f1a2128d5f7d0c55be2df9b4a67cc6a04cb67ac2509f0be2b1c36cc1b43128780a240d588077b32704be5e3d9a3939913a39f8ac4faf55b334fa8189f831ae620c2baeea3fd401a2597c9303e6c0751ca4e365b375774a5ed6ccd012b327b60ca0123a93547e26a0280f0e18daaed67fb96c38a3a185087214113140415dfc34f3611143874d7e22fd12b5109b5d16281e04b300139343feda8c307307d6e75d3c6ebda122b401f514a876398fa471d83f028173a98a8d405eac94e056c5ee8170184f9cb5528460aeb2e4469b4219c1070aff872417f2cd115da77762e4da795f9bba91d06fa54b1082396c9097401091832ca1ec745fd19d2a98f666e4e0f34d027da2b82d3c4b2cc905c188fd05e215bcc37c9f82d6e96e4b1bff2a31f82228df7439776072756a1519329da32f41d65dab7e11c5f672781b6a7a543fe01ddab28beeb2dc4e46617a11b0bc11f5c0f3d8563c2a44b86d80c144a289fc1f03f17a861b468f572e1a461aa02bd45320a2512455069998b31fc3a0e870205c8f1836e242d92592bf6e981a72e2166c8f4f49f6b50fca05f7a65f2e68c5f0fbc366342cc5f672ca72dc3812c85b126c6b7a827ee2439857c9f50ec8691684b4e13df7348974dc4428245c2c30ff74ba35b3c00a49e373f6a98e04cd55daa1b1591bea1041cf858643c49704b51cd6ac17c730ff5b24db0c3ad19e6cb9270d6d959e6a20cdeb75e1d349237ab3b0c784fbcfe3be88d5b2d25253dec1cca8c7e7c140d1ab81bc9b4aed51ef8b04d94066007f93b8527a48991da65545761b78f9981abda0db464e99f7ca2aa7b0e1a3a71fc434e49e5639ce1695a89b25c25a60a6aa53ee6c1eea704c437b52aa5cf7993bec62d7acea48869dfca9dad6f5a8598778ac7f4c4fac61ecdaac78e65cd4515d3693e54a2faf468d42746ded3a0521ed7a30d70f785c66d35d6fa55dc77fd2aea0c8d88091fe7fcffaf063224c7cd4337b8accac92dd0c5a47f6ab78580dfe3eb6a7e66e3280cde3454b37996e437aa2605fd6f128889c65a003ab92e6e4da854f07644bf6724b87ed3a07346c4758109f3ac2103798113b09c15e88dcdb7643d8be4eb95cb6bbb0896de16c3e9c490443e9268bd09c872625db27f3de5afc7130e424cc9b80ddcc6f2d1f8a40841fc50069fce66ecda14e53d23365474adfb8bbdf5c1e90c8facb39af86b41564409d9452cec89408fd209f6710656eb79228ce7ec55b955aa168ea5c3c8613b456ca19d566d00084c26bae296c7f8f40b0bfbf02ecceee21ccd0583c01d68164a9dab458c8bda024151277d8c5b853fdd4066edb1fb605ebe5da33005f5797c37ed9ed7440487e5e8bd4a33a8235a0fab5d49643b728c2e0d39c543659d5fb90ec35b28e124e3421c52e8548946cd52fee03a8e01fc0afc2edc6bb018ee9534b8df34a0757e25e5365db53819644155f7a9d78e2d3abd248422dc53029c119595d974714130af484a04bc1593058ea49ff978c6e54fef459288af56099bd9fa17a4ce453eb7bac2ae2450b27b75885dcb35f063169577af59f2924196a41cb5b89286eaa3b881da4564a93d56b58c1a1d71fc1d1c3d7756552537a6c1fe06299495e85d6afc737767ebbd2153730e1fece8f01adf3ba3607b6a8c44e40ab5193d0c6ab7b3ca4c186c57731078c9015a6d5c4d1deb7879ee1a88e85eeebc91eb737924c6ab61b368345369b13013f08185ac9385842499bcb045da95c3dc2a9d7eac78564f5ef18def3cbdff5852600c0cabbe0c806226c478efa8602c3973f736189cd94b1a40bcdb7e882ceff333a17af098c49a98de82e8f25d97421ae89c7a8ff25684dbd1eb2f6cca505c02b05d971eab067a27d20647ba93f00dbd340771423210ab7488a0c2c488597a4d540ec296d85ac2eaacb557e4fff73b55c10cae948862cdb7e8716647607d3e48fdaca73512d8dc765b6fc5d0489dc62db3f7bf0cc7d7c25adc2f774911135fcdddbb2602826245e9e063814242d152c6ad82fea901b55db1cbb482feacb9d8a74f5cfdc30b707524856dc4eaa394c6c93520b51abf9527f05f9dc47a6676c5e567b6e3429602bfd7438eaa4b8e7e83a2e245770351fc04b5bbfeed149d600e60a0ad415b02166bd0b456d866003b1742b4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
