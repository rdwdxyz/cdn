<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f54b14ce8daf7e37a0a63bafb2bd4849e32a65c861c42c64f2f8fe080f9dbc874d8073e38e9e2be0598be8561429f64dac228c2e5b7e12f9dea5894f3051a30a7b268225eae0b2e1d8341a0a6f2303952f22659fdfe37269e05ed0ad2893790cc1f232b07661f618046c9df71bfe1fb8419af8fe1fbf14bf6deb11e9fa52654257193ad615e65e6d43ce7699c0fa773d617ab3b3b5242e4c73c663314c665f84a0cee40ae6727e6268c0c882bd21b5dc14d2bfd47237829a01b1e50d3b68cfe72082340a67295ca5ff8631796421a052ae7410e032801e9b7e069ca8c984b78fb9a0d9c97cd5eac51ca953398ca91c4d0e206a66394aa2a4ebb067af81d621ff7699682398c75c0f844f38836ab2fab98ce56493f9447f9426196de171931952e6f74883e2aae771b7abac976556bc74571eca99ba705c5bb1194128332080af10343e446b467cbbf130c204906c6eca728f3e0c81640383fe114a1e3e07d6834064d8bdcfe53dd4d8d87c8f1c6139017b86c9ad3791fb3336a10a9e8c868797aee8ba7039be1b47665f1523e7bf93a5394d63ea5f073f3abed45074e441b133732ac5f57a94389d6bbd72f6b1b3f722588418a0e2360c1253e6417dc7cef93e85c4cabcebe899cdfc152a848449872f797372fccedff87a94fbf0915fa2fcc77a6e74a1cf8a8b4d5991295eac4251b285bed6e87b8de84029e05e2eb8914ad43ebeff702cf781d67a8f72202c42691dbd6ef022492e29174b872e22f6c022ee67880ee47067b25ee74a88a282d697538238fadc699ebc1f705e8c2f30d4b46f33bdfc8473175cb423763f80d76194a84d0b01c34470773222cac530fe5aeb606985a1fa1e0ba361d7c450caae2861b0df85287ae2e028d567e856b55d5d263ce9586c1eed84087a140f1b697bc22309310313ad3057b125d05a46e6767bd2efe708ad7e8e2e125be4a2df872666cc9534f1291146b878c321d77a625382e89de4e59840e9edd66d5ddf6a32c44993a5e8752f4feab4f89c0acabcdb1e7f8da56e134cc3840f977e32a245a7cd92f92a6bc400745956ac7a0dc563a3dbda3bf499fb082fd9728c037271c954104f4aee5046d2abecafab76e65b589ec00a91c778e4b163e08e369a40bfcd760b7cec1cafd2e0237bb69993207b0c57bc2fc155e4c31403ffd12a1b384452a1372098141ff98c643ee9dd7f106e1690cd9cbdfc484961a61f65ef5ec5c593095cd97ff889c3b83fe6d8d757b053c98a1d8fb27f3e6947d4a042701ab94a86bf5aad80954f32096bc80d5e27526174f979287592d2b7e4acda636a6da5d66e376470b12718b6128891deaa02ff73e32653a580d51622ba17fb2c0e95e326605c2ec5dc793dd923edc860d15e6dd91b432308e79efdefd21dd1ab54b12371508b784b365dc62849d043fd951e734937e8a024ee4930685edfdc7dcae4d57987d730fcd0022d74b1b705c4d4bfef1741b9d7691e7954ca8d0f93d5b07f6ee3515ef732bf3a2aba751868a1cae5cdca2066ddfe393391b48b4c6f95009a154117ef7d59e977898ade9d836f8fcc814014b406fea106a40b689195a2ac9f837bc888569ff2f3c6feac9c153597c0bf4495add69496485d8fc747315bd94547129bd4a9c27edad60e3c0b3e3644e14e8e3b4d923a322f544b72542183057f45c2e73e50e5583459dcec48e2b12ab15745a3088026f2e4198ca0096d11bc96218c9d93a2bfeb495e49aed11bf59480204d7b2027ac7111743786dea2144e6bb86db45d340bb1732ad90e674c7a6bbe7533e3335ac949f296a2016d19497add24760cbee3c319175c78cff3e7f013bd1709527d38bb3c03375bf7439d369cf7b62962fe44f60bac8b23e4538153ff8fc79912dade23c0454f03596d2424295b00de6cad3943badb6bc98727f746ca0712d69a75603e08746ab15aa6932ca47ad91e903915f27748c60768209cd2966e61cd54acc72e044d17daeb3badad5286b70cef7a7447ee8199186bb30aaa86622aec32b55d4e06dfb771cf0d43a154c1759148bd0396abf7a31300a7d6a6feff9357eaa8f36d1647e5c1d5416c750caafb9c6977f3aa83c161be19a594c27eef967c950b68964dff5cbd6098a01456b7374acf54f65b9a18f57265f4168406fd9ad387238e3d5406be8bf6cc122b75e48e84beb3987f02e4020eca542e4e61252e7ffd45f93fdeb67eb5712f62fc80ae4b84606c85f10c41b4c33654fc167065a2be00f2b042750f4d60e8ae853a580cb249dbc31ee9bf30b4212b22eb30a60dd51cfd4a2134e2ed6b3fe77c5f29604aa518be2d22c2a8b3780f44b6e073638c3868338d4739294d624cd3ec21d9d84bb004c1372d5d51271b8a20cd69e15ee30ed412cc79257f009ce85d71423a52290e463416eb28dbed2637db69f3b36463faed4a3409017dff5ef254c4f54279a2382e924ddb2b5ebc83e9ad11e3474d80f9a4356fab57dba23d0d9d6e75c859727804213a1aef3927a6133cf8e6602cf3a01173e9ac40011b038d7379a5f3489b9511624e0505832f84aed49b54fafac7762036a3d4e18dddfd06a0981fca9c454bd88dc440a6faf2f9ae19af391f2edb0f6303717cb35661bf9edf65d218b878fd8277c279781e95e1ef83ffc2cafbb35f5443eeb9a2051b45717ecfa6544ad4ae3c5064a5eb2ef88b8aef48cca9735d9e360b2a659df3a62a6069e681fabfc3890a2fb37b99d66e0f03925e5f51ac8f817872e1d7972929c8fcac52339ab03f9e76abbfaf3e58d3e50e4b847d1477640aa3f3881e830f120e6b659f0fbdae09c59547e0ce0cef97db3a5c9f82dd4fbedc2587171e7b1e7e30a274dee2d47295d22c1072c8a21155f493ac89ffb40dff035b1846e886edd41c9197e58da0493dc2fa2ffe87cae3cf2dab6540551ea01e1c11d113390da8b456956479fdcb8c555091be9c76a52731664e34c61f2c31173e37f3339bbd3d5d1624fc5432b4d959df187be3abcd8a03943e80c65cd42ef5c0bf2676b496633fb0beeae346d3324141f63c18748f6f809fc585c41d7d385fd5cb251372ccf02fc3e3fb3641ad02d9f8caebed9a99cdece3eeac08429ec14db8696fd3b750b32a820fdd377f2a03c0d44e9da3577aaa48014af2629132d092e9be692494bb0e52301ecfcd772368706e15822eb3fac6acaa1ff1dc8e3a07d3962e94e85dd2933236010fde95ac52c77958e002a6421a47d38d99f2f7248e04cbc74bfe6dfd2d0bcd1c5fd64bf2bfeac97fd419fba9d84ad73f3ba527e87cc111a9d8e8b462766cc2a7d5b521726fbac626f65c65316f625527f87fbaccb1036c9eca09acae848f7ac28e3c938493a76ae836a75ffb99a772f4b778854319483a26f7336220e6e7e421368e1c9d6dc985b92cc94a47ba6a80c46be1bc8c40c471257571ec8c0fcf447edde4c65524d3220871fb2bcb64dd6132d71c46f60a8493b386deff938b368c0080e48585a7fc9e2b0135abb7fd39a44c2ba2906a357be25811f2aee095be667e57147acf1bf2c46221ca2276c12943e0b2574f588c07f4cf47d41885fcdb06d23cf989ed4826b7fe70b2ca7874175edc923588587b8b55be6c9a23a176ca4a319efb576829a6538a614a458de04f35683ba7ef4c68c1ccebe00f123ba79c75bd564674672c89ea3178a07f4606de60fa0bb98dd1287a402f652deb56a3cb55f3b778fbb64ab23fd447f060124b1cd76ed8e53e81d44e3fb5254c8e34766b447c7ece4d87575e5d42c9775a50c1f68fcc62418aa448b0db632c164dc4091a41d74bbca2921b66396e733e29a174e58f65553a336c400d4f34d3c0f4a2001807ee5324f5b9a0665027644b236d8abbbf5576638b6c7a437c06cd4ab8fec07ee44f4c910b4f7c2ea817991653cc39eac28c2a4304c5218bcf1c9fff2f39c6c94f0a1ec277ff8f4b68c6bc47ab194e99528f20f484042af451535a983401a2e51bca19486f42869d6edcdd089c83deacfa32e475948323d88ef62eb2ce4d463990a4040155a02b26c3ea6a02eaae178c098fef3ead7046a67eb330a9cbe6651671282751b35f69b9faa0277dec35cbd8d44ff091523d1a124f571ec4a35407b230c123060412ae982e2e2315f949e69ae25fb9fa3006efb06b09d5670e56018970e5d0163415b803aa273465a1759edeef5858f17ed47c4188be39fab6946fb9afb4801f6225afedafabc0379051ebad970192981b0585f71a4d9e519626c2d70092b5285427cf0e6bfa3e732635acba364fd3cf6ceaf9edba7f5f1b8d704fd9f0b09de160439bf55bec0dfcf208a792b39686c51a4b6588f3150e3fe14b7b2796e8cf5825602c07b5f60f93bd8c0e9aef298aa0ae0c32837a8f8b75766a0d910c76a68bafd67d94324cad4b2d0bcc7a409fd8974b95fadcc0928a1d8cb456f87df607b3dd2e07f331a9d4f1135a2d9434fd033dda3d7fba731464941acd3e69f361e388450d62b231af8d49dd90d9f373291d4f0f3ab5bbca3a5f9225d2f0aa9ea499bc2b001b58ab2379bee4599218219f0b5eb9aea649cf14755691658dfd065fefdcd9723b857d1578c4ff6fac90c3b1c02a830f9587d2f1a9f4d556e219dc55d38aa1cf00ba6d6e9d2f97a586d068d1e6fc95e727390741a132e9e6082cdcfa0ca0ceaf8d82de38d88bde3a324bd44752049dfaddc30e07f8fd94c5b7dea4f86a86ccbf26967df530d00bf6e931d0a607d8281b3d0d72762790f98421c92ec8d61a6dffad609bd89bec9cdcb2dd0a9d91e4da87d77f726fb00e70a08e5fcf0fffa215f1960e9eaa6b0a4fef8368d49d7bac946439ee36ba7603e457bd63deb1a58f03aa99fddf2f8af159beefed3c9890d429e0f89d9f2120e9b690cd3c0962c562ea9805b8a147922b2e70858a70d7cda83d8737433785052bab2b9f57f7a655edeb3abcaad217844521077ba69415bb61f79eb1df32318626a1e9474c23317d37e40fdcacb48cbb1191d51129183eae5e39cc5933a957864130656320f5711895cbcc6c1467ea1dc0018911edb61c3d74064dfe41aeafec1f46fa084efaa982e51d2559e3c897f8b96c987a9d1cfc9456f474a40ad942211be8511b62a2d8911dd7b8d50c7b1c678bf03aacfc603b57454b1fa4ad3bdcd7a8fee2d3364e10c3c9a79d6fb158d61be01f5b2aecf3f538f8449cd43b97cfb7b54f68683f7c43b8239d61157091816025b9b5ffb5763c674e3dcd9c4da4c1ad1ffd391abfdc03f123c328df8e84d58ff60c3e05ced299cc2104334c70b2d00be8182c215a91561cd2215d142eb01647095f39c90e948de25073e9d70d88e31d8d5cc5a9a3f55854b24de97be090df6ea44d2c904a7b587a1e079614798e22ccae1cc8a622fb584143c4e4d355330143542eb759b4ae97426cc1386226088b068a10a1c7fa60f667403a42805306f31fcc88af703c5e15e9062ad1757e5797721464980825b4a771a73b685f92306416efa285797f1d21eef2935338ecfbee1f4f032c73b7b7305dddc6151af6cab7683ebd338127a6490cc1cab039638c39655b75a4aa00850755e10ecd9dea5559ef3173b990bc22dea672f8a29b90a3dc7e8be627156975f02dc916d777b5066bc6f783610d8fa120655a3515b8b7c9a7afd311ff1ea576fc49bffb354e21270d8a170b64e2ab1762f9d75cd31b4ddc4a83c9525cbecfec896293462de06f94e849d40123fec5e1d52472b03d59e3319ff41c7dd4552ba431e33f90bb5c4557491a8a12d20594d25f4ceb110dcc44d426dad382c34053697d32ba366f3adde1005650e55fcbd83bfb3882c4954552fe82028298467492fe3f8082dfa0f2d4677b63d74e99b6176e2397b5c25309c05e5ce33717624aca27ed82ec8f862345e66a90d2c00d866570295654d6f639467751ffed5bcee7fd6734cd64d1a145c70c4683e76e1d93b861256cf80516fa474534da50bc6444768bea2c40fe120acaa6358b4baababf3794d2e7bc4ebcfaed3263f8d0ecee4afca2936c3429c98eb18560a52afcc200f2781e6ddc7b6181958e0db0ce26d0c32f20eb7a72c2add6d5a33eafc9f065c229ed6330ab252bb5f2c587423afad462197b65cfec52b8541d3343c1bb6df0e5a5ef1d9730a0dd62e8826fca211e5e6b8f410f466ab5db1ce21d4c1b3f7e16c124266d16f92c30fe10aa27488d0fd13e3eb7ed5efcc0bd264c92edc915fc4f5fbab6e9587f6b9524bd46dec5a8a44f31ecbb9b31c5913d206f3b6c788b8f095336e2226f75b4aded2635256c1d0fd4bc2d70979745cc22c450add2ebc0fe9c8fbc6b6fde6ad1d02ea10a413338db95a7219250217d05915450cd07facfd2440e16dcc679dfb7e3a82e482f71b7bee1aab73e34aadc2f5717a6f7f24c8c7769145fe78d3bdb16fd3a1c2835b0ed7377cf934b37168ae50f2d111f545e2aa071f56008674834fa0129cc0837c2c72737619a2fe7ace75b8761d8b6be43fc0fe14b1d7f4021de1e9aabc68419a4865c5be062980e3bee47d2e6bc0de3f101052caf4828ecc061e13b0e2a5f74860915db8c8a3e1ac00932078998eec5b2ac9d7b1d28d7b5af5d9bf9152eb0a67b9cb3842a897ae5820e857d5b214d40002eddd636510b52615c175419ea032c09f836c964a39aa0141a2756e99b319601e22f8bc98215eee074811f847f0f3c6bdc38dc751875192e734896d9a4124a86b30e9685da3fcf9e7a971cadf438f2917565e7e1a01552491c0b4f85e14dcc492f8b8b498028f967e9d4949fd75808fc1db23f5399b4d26a3ca2f0b1b699213ea3780943b079eb6de02dd094262d08ace79c1b3541b84e1e65671acd913ceb05e14ebcc5d29d4851790d3f5a9f0b294d77e69e24b2b7bbf0c6c47d30a6c33831de9b32490e3b4c054acb226f1b9c9163c406cf5a188599d102ff1fff371f70fca12b4eede596161168cd00f71a7a5b1916249ff6f8c1f996556075d80ffbccd9323067f9b75cc1d1d779fd20848071d486cf4ca0296f59e62c70f37390520bbb2ca293760a200ef2ae413e3a8d64735a232b8e2a794082bc20bd1f5553b8251c8eeab0db7bab43bd5a2f1a52cfdc7e094718d22b97beec8f653f2a6290c592df93cfce6caf2669d9eca9cfe0ddfa8078a5d868eeba1b0d10105bef835e77f82110b6ac12a82d1a411c4cf923b53e8683c170cb23ed8438a403a110cbf05717ee2c4d29d624e9c03d088b9dbcab18dad20fa1d884935598b54afe99b63722a9ab9cbd555348a03a3ca5210057266a51373ac522354d7b795384f90540c2f2e5a46c669ea7a6bd5e8c31a713bb10616041a3093b46c330d1b9d55f83175e95384ec48a0dc90ddc9c3469893dbb9c08ff8f1854f74e2f02e1656e2202a95c900f8b722030ef2bc353adba25bddffcf322679b4123061b25c659d3b8f70f5a05a2afa80e558591c7e679cccc6a3d70735238b6c5603110082d7d522fd807339d331399f8ef5f430205a2f040d4d8c91c68445d267305a0e13907d53393570bc5549eb8342e872fdd340c9e0782819a0a20cb8285b34d2da494131f19fd2de73f4f0aff77420fb7c84a4b741527114becdd7efb8ff62f6fd968864eeb37fe9bebe43958dadd5bf83735d3bf79ce623fbad53528e2bb954cf424f67e0f9770851564a95cace4c529bd76fedcf8adc14fd3d13c8a0bcb4103750b585deff6f66f40971d779aaaab82764be88b6116fdb47de2e382b07f05b1de5b9fb4d71b758c987b32ffb1eb4885ac2d8317dabac110ff584f5ab93e4e11703e53b9ce25cc6455d5e181a5c181007b9e7b5f9d9872216ac3cebac56864a85a1284620b5374a7aad13122010da2985579fb3c38000aca853736c2f2eb7405066237a7efeca12952cd626e1210627d9dfc89b796243dc2fe599bee56d4b9890e7084a35e8ab4917d390cdc6f53345735bb061679f245666aa0d23dbc0565497141b997267081ce907eee2fb76028e83c0006e50f886d31663112e8b7517da1a813d29aef08305463141e6610d6c1b2f22a5c419315e178bd6690246d769feb2a59c81b5ffdbec7a2c4c30c09d00691806a5c76a79612d3aae547f9d1d9ac94f4f14ebdea124ea0fd0d2c7872b18e7a6c8d054c8ea0b4df8aa823a8e58d8a2fd3bc063537ab36f4a286b5873278677d912041d7001d25ab97ac219459b63dfa1d09e8065aba01444dae77a90cf08462e315bab2348e96cea5b9e288f63490bb3931b9c7c3960a57f83c86077a9aed2db6d129f13c689a52a4a42ca45e0e73a99a5460542734b20753312974cde30543acef0210a7d54707ee7cd3f9826d172e3c6bc674f2acaac3863da47f95da16b79a7ced2dcc4c3f5581327b80bcd44f5629f5958466e99e09d0bf5b58b132b50369d68c96fdfc7260587bc73d52c75823970c45fa41549008a1950db1e5e04c7cf787313527d42cf692fdbc4acde16877d2d5d1020bce5aa61aec4a1a6da8d3888225db97f9a91e4ba3d4974224fa685b7b92b9f59833e19f145c21e5797c5448e80e46c9796ec59fd3585d2dc737732bca29f2461289cab5c8cd345b628c062cec1e0c8f5fe2f3b67eb1cef44f08508994d06cedeef5cc4c6767afef4c99c74f435eb82dde1ec394b107e38f4d756098ea234905a3437d912acaa8646215c3e06fc32d4928deab56725af782f42240ba56e2ca49017511f727d440e7e7f01affc97a9f555f4547daf3fe65600fc7ddcf796bbb9e217a93f2c34aac31a0625fad2950d12c3fe3f40ec209c008591ec5da2abe891296b3618f3fbdbd12e64fb08c36822a3072d9bdb52bcf72c1766a6a7f72b1417f36c5def1b03847d6b3d1119d74957b749e621b4ea9520931793311e9699c0ec5447fab33544db687b7b71fd0e0617b8dea6d5d0b7e85b9a2b93f40b2d8a0058dc1694a81d33ca7174632ba8e849d7fb053b6da5b0bb23de32a2758bb0f47da4e2743fbc4ab56055f7444da356979c31978bed4eeb79e4b08859a260afbbf3a92e2020a7424a11feeffff3179acb3bc173d311c95873f717ee46f9e841f9216bd1a40d6f280debd51c1a061e7e7c28d5f20f6f02d465ec222796c2d190416119531202fc389f27abfb0a854ac000fbbdc2e7782f51478048496e440fc973a15bfada7e34e65718df1ae21bf792f22d82ce54570eee856d7d3b6db239e92e78e12a4af1f8bc2022474bd8bdd7165d25506e75ac6833b8084e7c2329c6d7da053abf061ea223df97e1914c12d5a5a80699fc0a028228bcc8899c8f53356dfce94f41ddaaf8ae44fa17d495033ae4e09a81210fb50f1f74bba6e4689c4d086e142e4890b1327918a51e286325c59dddf1d0ee769f064103a5773cf27ab05c5a93425ae97c19046e15121265d811d7ff42527e4675d7583fc553fe7fc649564cb78b14b896c15b79b9b2540d3a5780d8fe2719882d94a3052cd81dc3aa9277ed2f23eef399e7fd5886ff9356b91bd03d762e05c420c675a209ff80bbaf9b63e2f43621531e4a04bd458c1d2a7ede6336b9bc1dc247d3639f0ea7373b45d758519b7adc4a7b1316e13a49ec00f9f7b415dfd76c33d61937f526a95626f35e487d027f20e4e1db8b0bb0f87bad3ed65106fa2a94f8ee8b50c198855373595acf930bed7bfc1902d6abde05204a5a3a45f7b7718f0f61547bc53914d02619ef7e9dee58468c2a7fef277d4d481ff74b2fb52685266283a672ab5b9016fcb94f51f7ced2e3698251f03deca177ddfc0b4d82351314e664baac027dbf608429a675b6579db02e097bf7f3950c80006b42461a1c1c1b76b062042b6d4587ae7a5c2748b1249a2f44e81932fc0c6be41e011d205a6d6f703f050fea9cb6e951bafee9d4f5731b00a7d22ea6d0d33c57d6c86f72f897f1d7057ee431330b6e6e0d051d7cdf27b2f6c793818578baeac7b2d0982447acedb69c93b91bc2f0f1ec9232b74d7e76c589cf7850fd55602352fc932779b15ac82b2dc6affeec2f87ea67797b7f14b318ebe78b2fd7a32a5fa71e58614b31705f7f6ac30dd47e8478add063e0df02a938b617c420a56b2b2da65bf6cd234d0c75637f54beffca0c1faa3e8c912cde65a0f578c894965ee9f08879780a002cbb767b3ddec4934c3aa73f9d2688c56e51ac5c26b820a1d57ed8a9fae9bc5846c69b06cb80fd2004a4ea36e2d6ba00c0a27276cead9fd103029a5c2ab2f0e85688bf7b9956a006e8ab408a40e136f666703520a2d067a723a85cf345a4f0c6ea28200eebf625d8be21cb91d1a0832d528320340732ed12a9a3455175c3d61201e803778360f4a089b86acd73844f030d85b4eb365462c93dc2ae295ce021b1c6fc7e189975b46ba65c8965843a84ed9049df06a77c26cd7001014e5c6ca8a06f5a93c05a6c2b2510464f0ced568f87b6a76e58a25cfe171c314c71571f895e9fbced0198753adfcb84a45059aa55822a206c2684adbca2fb888b40ac69664fdd5b268c56d84650445107e9af2ba928df41c6ef41b777a5d0832691d81c80987d51ec8222db46b5c55ce29cddebe80bef861fe8736cabe27c0a3e1b8709e1148d6f1ee4bdf7dcbb624e3301b51cc1f27fb0d2876fe5f58e01b523f74e316756d58ec7d1300c179bcc4fc334d21177f1cb46fbc591befd60621c7f079c9388910bc25085c660a7b4728497d1505e0f9280c80a1ab2f6c12a35f4e59c16d447352c4a07184863ce46b7690a13a0302da61b12f882dd70b6aba38a70f15c5a4ed47a76fa1c4e0fceef29901875698613ea5845aeeb8d6aa70f7526f67c0127a3bb4e330d0154799f7c34c0de7db93e61f686e70d1a8408138275569c05e182302368ab5a3ea20310204a9cf1bfae9ccd1b56daab902ec61008929dd6fe05252218d4c3e18a0c50eef501921d6cb9ffd19f231a317fe4beccc7cd93f9a899537fbf0bc7c09ae550bee68d955a75370b3e941eb96fbcbd6ea9877921b46ec1b1392be88901814b9fc3357c1d60ca0689b04b5c55899bb87047d5d72626202492b2c1fe65fd0beec886ca3b8cd4345217b8d097415e6f0d8295c50a7b40a1f814e5a69e94c76b9788cd9e17ad2dde08d6f687a6567a65ddb52c19269c7d45d2266c4471026196d3af4aab3596b40133cd583daabc2cf11658448dc5ad466e4b180b89eabd2ec1b82256e2f01adccbc519d923e081d5f391246a01c6929ef20979726899625fa3921ed98b7aa568d08672a3026f7f24a65d199b397e6a07e3722d5ccd5795078f9f659eea8e0d8624de88e4665f8c036db46a48c257aa224aec04a329f59832bccb0c5ac9f977b805d63805b1ba09e4ff7be4c30cdeaf7713ae7279ff97b9f6f4192a78d87b7075aa59913cbab14eef548f7074204df18d43d50b3117a4dec75bb3200db172998f966b2137a38b54f0cfb36b454246937e0ae9a6d231e0f5e051ec25cab37410b75c970991f03a2908204c31f66c0a4fc15ccd89978b13400e552e4d497c9fc0d78097eb69e298e474e35194ba386bd788cad71451e00f59c0058375391fe8bfa599628b202200bbc1c0d3d9fd3edf423ba159a50a159269aa69ed043fe44468d4b21fe909dae5c6f12e59cce68939418c81f686ecb5c6f82b6d7aeedd6beb6bca345acafe3083e9522d3847e62a586283c94f8a0784dd9e7c8b63d8e832fe2bb019f2f9dfd76da048b92d7f80b1d3ea347282134a6e713808783400a51673a01124fedc4e65efbd9392de785f158cdab26097405c7ef5f402ddf92a279922b8b39385ef4f97ef1905c88e902d72b197f0cc77cc56afb0145800bbeff9525088a62425c7658ac47f1912a6f53d64ca758f3adb7a7c809c37f6c10dcc789081837d34593ab149095e4d755c16449178d9ce09a4650abc7db27542dabbc0f9c74de84ef79946976a7205b9ac8dc964ca02f5cb2b1e8386691ecb1ca9a46a421ff33e9da71b3d03f193fdfd60750e0a7a6525d747724c260160b5a56e15d0742b089e0fd895a620b07d565fa43f3dfafd41185aa719a5278652d8a3af2125bc54bf93bdaa5e51bc8879af0ac86ac0f74d261e74a98fd810152424df74912b008bc8ff46786c81c7b372c8a7c7bceb758b74dffcf250f71fb3b272cd3e22c1a17ac18dcef124ccf41a056222b58ee7901fa2c09ebfead2ea67987a07b54f818619afe4bcfc65a485165bd2a9aa2a16c942c8c2b68ba8d367207aa306b74d1d674ce5fdf95c7a18b7b40f7e6dca0b078c83aff47d49ae99f8b7cb86c91f092ae802b8718a2d0fa1efa782a5e65c919be76a4a3f188974ecf3e35f3d7f3d6b40223620597442f7240ee88a78337f5fe0e46743002af0b800718120f5b0058255dc0a05e9f14c7870ebba9b525992db79a5ca56291ce268c8ab773ce92509a883053e53eb02b8bf9cdf6d037dcaa1c9a0aec63647e1b2ff883a225519ac98e228455c7b0acb286c1610cdf7c37db1becb4a637287e23fcd1dab505962116b9edc68a8d8d9517d2b1348fbd9fbb9e925078e9c626240d01e3f167b8a0f0b1a502b7bfe67c6fa97abe1496f57161510293689547b863917d3ddc9b987fdc5a25889db736c2f688e74e4a13e4294563a061b5bc39e58d467fb7e6131894b5d0e1d5093cc9f9e8992f40c954675dac6dc557dfc18c327aabe469275647fbcf8aedc303dcf5a24cc9aa1d6a1aebde3f555aca802fc15c174707f2939fd1797bb6543880f901a9e832ffaa6d7f13c1ea62ca2a02860559ccfee8caaeabe24eb07529e07d0b518764fcd01576cd52d7a358b3fa29b2812430c08cc990dd8f5b292b4d066a7ba41d93ba39f68ed9dae6b9ce7bd3a2e2a948f0cfbac47fd5dbcb7f4ab183a92391d4ea6e688d953b2c9a5feebe8edf7dcd92ffeaa38969777ecf67172cb95482bf12eec2da226dc044e7a0f3f8c3e6a9e2d3794ca416e26191686016f56a1a9e1aafd213a96fe598268c9ef2fabead016afbe762c7eda9c445770da6e8a318b03350477d605cee5f6b680d0bf108dcb1888ef4443891dd33ff55a0aa3c7ab5096eb91f2ba7a8dd14bc5f68f44e0fd434595a3ec47c2a09d01ca52f7ea71fa415ea7c69417be295d1d7c8e632e2938dcc19e80ddb1ba4129b6fc92b0f42e3513b6299e13a04ad3b1cabf4a685e31600b85bd29af58891cfcf455772d374ea7638341b6639c261b1ebc22b3203f85d905db38a14f8af3bad421100dfcbfc6cf1e16512f2f0574805992553f17707d74d1dde3bf6f313c330f4050cf6cb9e8fc1a10687d89abbcbb63a9192b77912d4abdc23901d0a500e417792f1ce93b3560a2ed2bbfa58b49eee396df677b85c72593f326e76d72e072b1dc11fef0dfb1e7aa6e4bea076c15370b28e01ff9441e5006dc28a49e15f37ec75baab485a4a41424f329a2915d5f424d425802e022238edac2ebe0974cdb11d2bb73de39b8afca3d8c3ef3d2a613340259283c2144a89c04352943964f02164df7d98c0dac2084047c44266844d36872a14773cae6bd7259c6cb804162dd0c32d018096d3b1cd53000fbf1a4a1974c11f03a291c0d4a9e6d3c06094e26e90a4df4480cde79702451739afc473b6832846308882f1e6c132af291af999c75916f3ed5fda5bc362b6d62605caef92ad93c3a72ec9a3b39bf3af1944081c43d676683dc0e917c41920a67355c2cc2dbfb09b4d910251cc7a882481f3c48530440e80840d643104a8987aa7ba26fffc485572bb0792fbbfaebf578e54f9e36357cddaa6ad08109be6c53c09ab366cd23dad88567cba051c48bbe782fcd951a2815138f6d9a16493462740f3f093b2bef3d2d470b3ec94ffb10a0796c2d6627a02305d8b59409093c81ba53603bd3f948f36472d12c5328f1170c555c92619de29c7897db458359342c2f2a166a7d6f541bac98cb25e0e0acaf015c38f6cd91ce63258d5708be4011f679ff493d66d6a5145568f9bc54dc07753af16b68f9d0440d40af79698d236deac934df5da0af420bed1c7c6277568deb80167c7d82ee9aade22fbe1bb6156ccb84549ec138ca8de8db56b6decede29f0b15b9cbab89f139727ab2e4d70e82ed87960c934bbf65f114193c18e56ef6de816b8f1b0f6ef32c36e49d4f688bc4443dc1f791ec006f50848b7bd0a413dd44b642ad19e79deab14952525be8024fa6427c0ac0320d93d77e2a481885fcf32dd3718fee8b276c877f50db824699437ef17929a50c55846451644ed8f7c0571491c9cee8be02c04b670fedbff5b4f909bad447392395f097f3d6c5febedbdd7fcb8f509e4a496353734624fe1d4772aa2170c6fa55563337cf185125f1bc6af99df6f9d35244fa70a15d4825c7740bdf64b81804884d7b948ef45f05b12eb6cca66d02f6331f602cd593f4f316e4024170debc518a379e23e9e55b08e34367005f2d93557e2bbfddb932b595c134e59a6a4cd5e387e0443f4768d6b397d3d9a65b4e46f2feef3693593ac9f8d70a99c458456018fbdd551dc85b33a295c25637e7a8b6f738def40d3d08da0108b2e4f1fa7c541d1b8f8f0088d84375c63a4c5047a5a2c7a74912aa81b18ac2f25170896cb0ba1bef92924e330b9ca40d38a4f0f468a4cdd4d02f14532bf58f53d6ef1885be464fcd85980e809d9f8c69ada22f4b0134ff2ca72bcd42b89aa767c6fc869a6b443a179b5e3df617883be4964d60b79f84354854c66a5b888eb0059425de84f47b32e62a6311d96a009e9d2a607ed6cd7240099ccf7dfbc839727c06644872b7a9980f8c2de27c460778f2b406345600995d7dacbb163ccef1b41ff0709a7dae0b34c89ffd6ea6971f0feb6dfc5b930b9cef3fa5f2c88ddb27bfbb7c3a0511dbd65584be8a304ff3491bb72b179e7337d45892bef73f47cda209ad8cdcebc93b7c28223d296d1a44edeaf59ff1ee7d8b1b4cc0d97ba0b7ce49c3961a09e355e374eb9d7c4156620ad9ef39d48f689eb78105abb14aa77f0535e870fc5c92ca6e34e8ae65da72cf4b20b7e43b4069a8b0102fd69cb0f1e23d782fe5a021716a5ddf92b46c7211d29c0d715bc9b6a3900c00acbcb039618bcab52731c8c88ea41cfe58f8ed7820a47c7698d8613e985440674f1cfc5d0d9662e7386f2cbbdb4c27c22eecee32dc4f4f777e499def69be177cd03b856b4bdf171d8113d6763094b4f03618026a9cb2fcc4b232a5d9c191265e658e994ed29864ff796e4ec003583fb29b7919dc760c6bded98161dded299c40952289cbfbd12759fac90f0b0a5fdca3afa23eaa73c55a0efd12e2f551a88c74aa912d3c7d61a751460f169da2d291fe3e2c617369c66db16b5bcbf406fb3af1c7ad9780718342b08d095370914ed7cdcff7f9a6e26e9c68636eec2c5ef25412200dcd203c18f22f03bd072092ae1eb6707a98230e00da44f8dc8e0cc6d1bae7fa3410e91135751cb333dfe67236cb7e708289700106e415522f1a41cf2cf427c303adc6ffca03572cfc8256de0b024a68516582af3fe5e11531f5d8b299a563dfb1873998b0aab8fb22b8ff5a2a845faf44cea13dc22960aa5149222a9eea11748f371fc6bdfbe8a7e1bfa3c865b2f08ac68d7b34d0ded784a248b14abccc2a8ed619f1a7679907805cc0939346a7886f42dca515eb68c698d8a790de3ab34ba8eddc8a8bfbe6f4fb5bf411d9e655523a0bbcf94f7a080ccd20e2b24119e9fa5593d9324e715efd7ab846158822cfbf4f94d2e49d23e8c8a49b1df74bba7a3a94769dc7c56457a44d8bbb28594240e7f22d6dffefc858d8a91407cc18bd1fe28b8df11fd878587de35094bd3df2f5cffd5e759a4f708afaa38b74a52540336781ecdf7d820515c3c1b283eaed90d6d4edef3d8dc248940749a0c1287c158640d00879cbe8461aa0a030a4b5faabbc27f1b9a6fdeba5606815ac365c1ba3d60a295fd7133ffe87f677f7d0e1791209ce85dfb64c645089afbedd646329b30381ce18f8d4a881262c9de80bb60ad3572758335e98420a8eb92bf5f137ff67fa5d685aa721e7cab4879233748a7b54cc0610c2780cfac0f854e252cbe35fe690e6ffb963422749f8cd5046d291cafb96cdf91f5c0360f236c230da2a01ffe0a5839c6360ea4fe18cc29395df20cef15baec092f7c5b9b9553666728ee41cd2465c657116285fbac7b47e4edd3e14b5a6d1e6d5c657e995c1cd73deec65504c7b6c655230203809935273f6963fa9a5fdf7ab7c92e43e17d95dc63a3e21b9d2ec184491515907fec308d321a9382edbd8219142c47201a136b3df0bbc5962515469743e00ea272123e6bc1e00f142a18d0c682353bcd444993d87f8501155424ddbdef6744b435d4a6639ffb338a871436f43bd50af898082f89e383a1114b7ff95ca64900049c331e2c0a299c59a4d41b91f1abcd671b52931be54da69902940757753cd72d94f54c435ecaab20299e86dff7550bd84b1782c32a8f575feb4123f96d1a236f16443a05d94b2abf55ed60cb7d2745d6a7841acc9af42e4d883adf1423fbd27ec0601287e421232af019aad35612a27ea978be47f1527f49913a5c909189e5a61feca7b41a5d69a95fa096b2c57ab8d2830d7709341164021b8824634498090c8e41138bc8b370c838094944517a19930063dd9928cbc2904b9ffe3ec615d081e754934e0c7b91adca7d863a6d6f242ebd27e8064a2bdcfa2eaa9d6cfade131984d28111605850413724698399b5e34fb086a2c4e93d8f684b37a92080a387e9c34d9518d7c4b994f12bbcb2946ef26eca84b3b2cc6110b0dab8aacefed7f38d147d5cf323bc951c1a08baa33b40a69170fca76ac04316c8b17e65d34c918458c075e2f703fe96dbe2977fb9e2fad277837953944c8d236a3c7420eb8efc54f767ba9dee847534e6faacad507d463f6ac4feb0b5418b6d898e1b85bbc9e0ef9dadbe2ad05ec94aa3ed37997abeb362ecc17b2188944047f127997150def1b20cbbc9bac43230418ee2b091f2de59c42e6e0d1db7c3d04d436e99883986485d5e196a8945135d73a99918c769518a1e775699fe9f1e150e0448bb2c2aeff13e124f10b60b13fe10800ec63109a5ab1320bad3a7862075a9d49618f652908619d3c053eb4f0d85a5fa43d2f3d8f09d3adbf4a1c542cb92750b007a292c3b7b52cb9e4963d575d47f7204486dbe27f3542ac8130fb8f507570cf4b737d4107806e60a194837a5fac7bd29602a0979c3a1f24f2bfd29eaf4ff4014989700d0375d99c1cecb0c4aadbfc7a8f88872b35b58bbecfdee7628c65a191e02e6fc1f31e2e4b3f03d889715a115dc2003dc3979d63b3d17e0f7c48d40da7155e38cca1524693b8644d7ae621ae50bc23e8fdc8d948076d01f86898e2d206ac76c527fd09469283c94c6ac16b7e548d2b885905b70649c05b231de455e63f05107557d8fdcc92011a62b25c9947979ee15ffed43936a34fa3fcf5d77f117850f0c17073940fd9a086df393fbcc268f647f8b7463ae7e1aa0a1693162bdeb2e2b38390dfa67335d043dc2b3e6c6ee8c2738399bbea7184bfb32ccc3c960ce866da4901252e778020bd0d9fcef75d2c06b6cc4277082fbf2157deb11a67252d8ce728722224e74b30648dbb545c367ad87f798a9615eac9a8327ce8fe24d560930d287f2c434717f88a0b67e1b963540ec908f63ea43ec7145f3b52aa0b0dc319603f4772d7a70df306cb22d58919700ac7b1253ea9eed8b668601aaec75c987bb7fc05c05c91c95ab488c490a2fedbff976a41b690fa932c02aac3ca1b78c67c583a724595804a2df12a08350111abfd8b0ddd9bd94be03bc58e18961ac8cf83bb5034e601033dc75f341934f44a9c90ee77f34b65a978c1a741eb21a4c63ea8ebd9f9b80a33a1cefd24600153ac94727725932163e7baeff808801c6d9713ca12f7b35fff988ec840442ada43d77aed29c4915e826d53e8337f9d03a3fecee7441e62819a7b04f63b0bec5254c44ae456f76f56af40955e10e1c0ad5946d935736fcf40d8de16cb701630f37a166af51db1855208174c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
