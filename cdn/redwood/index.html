<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"000672415e1fc68a20d1c250003212fbf705af5459f6fe492dadc32540b187133f4a56808c1f0584ccf6e64ffc2daf3ea0e232b3a90f0726f19b4defb64a047182419422b5928151bd20ec3831b468d8f098ab602c473f0c37643ead0bdb05538432a534cf1acedaf09d89d32b776ab65da149f632ef1a66b81b724e34c213dbdb023ce848b04e8857f796055a2584cf31ebb6ffccf1877dcbfa8aba61bb0f0a67e7c6ed9148bd2ca12bcb0a4eb258db68d936e26ef9ab82e1a069ea55308c956acef894361ee42fcc2a4a3f6280af94bfa5bba5924e49f467507a82b231963cf6d29dc13552b91044f2e2e3cec2af1233fea899a0cdbf18eae9fb69164c931e9c6adcd2ea954ca11eabe3bb1c972b180914e393d8280bc48539abcc588a49bc8f56ee8851b0cea6585bb780fbe924fa7bdd1c0ac6bb120ac6d958b020863b735b67bea845aa3eb966ff2d5f591203bb878d31bd4c0d9bd346f656c5dc3666ff4a7d4d358cb580de3fd28b50fb0379c6b9995ad8c7eddeef66a75367cac064b749b5c59b85fff37e9960c6ddaab917148d1c88b159bb50d2d9a4940e59395b0aabce59d010a443e65f52ad219b163f26f66cfd36259ef945c17f60319bc648bff1401e91f2442dc762ee07fb28e30c7e171e66115a41a8e86917cbf62ac15935bf4a8c6c57003d8ced46597c1b47905caafa6048649a60c9aea1d8695f1495c4ac50ac34ef556ba0dc49e659ad044d656a227f2fd91dc2bf3dbf2e57bd40527754a151d407c641a5a510cabc1636f183b35c8b8ba6b3311c9f4892a7561d54a8c7a49112140049ddacccdf44182dc33f3136790fe266c2b8618c397024e6f2bde6fd4f05069c7f36015ead160a9226af24495ec166a995caf2781efa04f068a6da2df4da96a53117e18526a812dafdc6fe52ebcb3a77eabdeb8a83f991bccf84e11881d39e3c30c06684a1da9721086712f287f50a3e4734b43a318e3cfdb4eeed8e0312a4ef07a98ce82b361ad5755e25f17815eaf8181a6a02bc7b07162e810d55495fc9574101c0c9c8b50ef246f0b4f5eb2be8c3b3f61b94862f20696ddd4847871fed719081aef03ca1476bfa0bfe2a0ba335addc41cf910b3df08f474afe061fceebaaaa0c7ed2447154f3cf0adcf625d69a20c3589c89247c00443cfa62f7f72ba979539f33856291dda5797d5804bb63c05b591c12a645eafcba46e74f52f0e6efee568e32eabf98c60ecc7488b6478e982f9426bae01960040bc3a71fc83c82710c15eed7595052bf28f3e568ca11d336fc0be65c037f31da94112a6f9da8642aefe0b3d02f8e76d91dbfb793d246dc85a88d7fd8bc3fb23f97cd09ddf583091a8f1f6953377a14069fff2628ceaf691bcbbb8debe602b14fc62dd2ef9fdb81cef1a90885d79814720bd5723cf9b6e1802e5c5ce8928791ef36fc59d153119a04fd777d3cbadd77b673081d2435160554b31ffab48f7bbe5e1267b8fee848d4b456e37e78be2870462c8be715f7d7aa6e21075279dbf8a10e3aa4bda38fa71aa025b47a76ec42ce12c9f1a3c9923858aa7aa8e7671374e263d8c4a924baf779cd9fc62e0b644d4c9efa389d9cf93b8309daf7a669df9667436b870b18143fbeb60cb05dcd6926d8d4838c99276d97cc3d1aa4c146cda997af97fc1a41529e0ee9a57b80ddf2468d783a31250b8af07a08c1e1493747343eab4b95cb44bfbdeb6c3da1aa4e76de59a001ed2fd5b0bcbb0056cdf988bfd682941a5d7694778a629e3f878cc3b5b3e21b4a6b3a3996f1abe59e2f2bc57c6490aa4952a58b45ab79950e3ee3fcb3b3f9cd63ec2fbbbac30faa2b8bdea31368e82440cdb2a98501f1a51ac3d6462fe63e8e1a2d2fcfdfb6040a265c4d49cca1fc30fe1619d2371a32ccff55aec2069491f2daa1831dd11a805b1cd9180c8003d91eefc945f28822316309b2721158b3640e1bfff92879d32207271ea8be9df25205dff7fcd7f5c39144d73b9e8f4c8034f6b5906d204398c3007ed3cfae657a4d5341393a550cbd3dcca2d6222cdbe41c6eff0d831f2491c5d59024fb6c813ef02b53e1510ebf82a8730ea3896aea06a31fc2182e7297225fb9ce2de23418d734cb51bf6cc5961a8a9c44078b0008709aaf3fd95944586bb5cab0d88d0838c42d113a24ec9bba4d765d089f3d2801c8516ffe15c3de36eb7788e5f507da09575b26db74329657d35e635b3300e00a6fe6678e01b05d3753b72458ef58b75d265591804d8525031cb451330ed7a34da042b2a6f07e02f7d2a6392203c7c7cbf42b55939c12313ff389b399bb3f2edfe71ba70c468af3ce944e0a782cb104ec305aa1e560e0e838b72efbc7b64a27a9f8cdcedfd5c8e6236b70a1f7008b5bf67b90e7681097ebb0929b98d672c6c7180aa4d15cc388e995e98ec92c6ca65ba63fb05772e36dd66798c9375fa03442617d86f40ede9364bfe9ae10891e79c5887e5b376d30326d242dfe879e2478e87adb36fccbb2187837825e23c6cabb72d43a806e5ba490e1e82833990ddbe13095cc05732968973b442c4996fa8e98d9159ebc6b58b469535e5dae033b270320263194afd8881bee516476e315cd57a4b3d01dad1f7228b5b6bc7005f25bb87f48831156d893ecdfdc83aad8921f0682a40eadf83c91b9cc369be8d1a9608faf5249c4b3fce254e15ab3ebe7acd9d76f24da9985af39c0d711a950c6189b0fa96abe0f4c95fcba4b11b24a81e6a796806a39d53285fb86c8b62b83696a25a2d30718d2954a5f22a26280dfd78e4d433256e55ce3ba03527edd8a0faf26354622c2029a07d535cf9e21d4b4b1be996303592ba9b3c15852bf8b44156ed83b8fce77df0eb6385108efdcd136d60db3673b738204b02e07270b3211a1a2a0f7797937c41fe61bb24adcf4e29a05456d31fcb5a7371d5cbc701aad462f9e2741b26ec87e1fe03434700345c0b771b417f48dc9f9d6f988a2fcc116c40223e47ca186b091f6676afb8d6ef30e119cfcfcfb1f49809a308803c477b6f89b14d8ee814f434e96388825c35f6a7c57d8c42283d437f4a0628f24449f50aa59812a7f9378bd08d201bea358d25ce76e032b098de41e5cf63be3ad8b7123b690596aaf67f5bf1d090a777d642a7766127afd654f943d792a5928625c564ceeb38255c3034ef5bfaf44da5d5c10ebe699d16f1e16c6008ee3a499830e5eee501fad7795b45630915e1bab897a553183a5a176c5ed2f3e4f5e37ddbf8852564957d06a4b9942b6697c95cfef3c05a0a4f77a5a30186301fe5a21bac9978593de777c2dd0371c47efca721580ad3afa8fe374cbed71f7b8170f2ad204de87728e4a0b1a7824c51e53e46241e10be77d22e711ab2fe5b1f602d565d49d6b545966baec9e7e2c1bbba6e3ebf47e3c2a6a2e44b777dde8165fdd7b89cd2bbc4f42653f1c2097fae8a4334dc9f76ebc9eef06de3e3eb6fd6dcf154a7615491ef50a99395fe6bce94de9607b118118e56bf221458186f92ccb26b85e26fe8a21e07ce9aa65a5623b7bc7755428676f92595e27129a2b505ddbd9dbb976e9de5ea2bc99cf67def95edebc30a68f92277e89d77a139194286ea5124d7a7424ff4f108f3dd71a721d7d7a7c0eaf3641c033e8333f60181f63d89f7371086ec62f889eb6727f911abd662c43adfb2bbfbc651e61d034ce6db174b7057bcfdedae09d6fd8eaa896a67dea6692b0a1da498f7e846d961347879b1c3a875cee4b3ab116c3494a590fb5303cf91d4841c0eb9410888f1de664d4501ed924da23b23753a7508a7c2f57292ba7341ed37dd5120c94c43797dc50a8d853749683fe43397b461d3db7d2632858acc2fbdfbacd734abae86e4716ba46f771cd5f6425a119d384767544b9a87d5f6355f1e1455d8dca6585efb3de1efdb79121ad0c7dc8ca001cfe08f43ceb77cf19cb46dac96957003bc1a621dc8cf8b24f5886ef2c1b69f535e7f0a287160279b536ef186935696f5d320ef89326e17e20533dd68ae53a05b93529d2c6a3fca22eb50b0c6f9ec4c3bffadc5ab33a6aeb08c21948f264b8c26c9972ae86ff9992a9d05040254a20c49d5472dc32c6fabe55c0ab5392fd760f1410049fe271f50a3f1025d1a6d632e789a559ab543355f85082552f8c6667ae9af26dc4e08b60c2f071e3470e7fb70729d53492c6255a0ff2d72cdf2555bf81baebd7a0474a42ba1451c89872e6bba5189a6cae5e445c28f03a0f48cccc1e3f77d41eb83a23f8ef9fd5d1302f6db8170a23573a2b4111fef27385f6763e0ba16a44101015c5c7ba22f665d8bfda941cc8fdb7d9475f3dedb3e676e993edd1e32bb5abba9e71f6cd502b14d2314b7398f678a62b75951b1e88ea5417e86d087d42b9fa9c727985b8490894879b5bc3e9f0b87ae8d13c4a0d017406755d4f596489166424d417d2d736ee1e829bc7a84b3a90c819f183b6368b1c63195cbc83a261e3984437e14201360e590d4a4129ccd1027946e334bf0e0fe152e13a82dacec78ad9776a2deffa3e9e1e3ada0ec4866075f76693e6475a7841aa5abe73ce0c9c4661d77de66f5f25c05d63bd724a30b0918404e5f3fa86b71779c57519c1a52fd2cf60825ee30e56b1f8b78d5ef13fca96a98344b98735c961f155004be2ba4468e7526129627ede861cf87db8e25550b05fbb1ee8cd40f06e62aed5b1c1e1f39e1d4f38d6e18e0c98415fa2ddf96f1563e4985456d69344ad044bc86d88a2f64c749678efa150b3f2099689fc2ea5aacc7a31ab7b034ed96bb38e6a5c8c141bb23d28c8c25540ad5732c46a78840be40e9d4557d845861ecd10fe6edbf181ebaf51767f37f3694e96f5fc7e16944dd70f59bc1b22d7da438113f89499cc0f3813eac746d7a51e71f41d3b780214fe55fb5d8aa9559c1ac47409e1b76d64f5ffb36d11fad582f666ad8c06eeff36916ff1d173fb0a7b10a17b3b32f54967ce2f1da0c08c43e0d6b1a51f588f84f0f07489822bcf0cc325622c58ac3a8b8b752bde8f9f32b515ac03b7c8534ca296fc0b337ac4cca8f5d1f9bf4244ecad6ef5e8342f68583777876c97c43bac24c72a3d0e0d02ae2d6635e2cdcbd2639f36eb8a50798fa0ea71b2a14ac640230acf2fb6c01aac6cd33edb6da7b43a02c95964fe71370a9d1d7b35367f47cd08dc0c17bdcdd1225d71a7c1f98a67531bf0b842cc0bf2bd44788a18bd4455e7ce2e9dea48fbd95c3c6223ae979a1688624765566daf19754a83a64a26f17ba256dc950ec01c0e765876ea9145de97a0f5353724ec023858932288e26a832d78145b66d422cefe4f89e4f66a006d5c39e470cc4a2dd44bb1d765203bdba4685de21d1e20fa9245c66ebe1ee2bfc5fa4bec1be400e392a0aee168d481eae6e7f2cf9b6b067b9f92c4bb9cf47afeec196cba210bb82e8741a941ce16e6bfdfd74e2d679655834dad5ef213df8255b7c2bf0653292b96793c62d69acc2cb8d936435787b025817f3f5136618703ac9def7e3ea832dc4dea0cf390e50b6e4e85ca484e727ffbcd41b1448864863ee2bdeb64d02d532b366313a3778ca5de273d45f3a58129f122d86be3922fd90f35b7887ff9c52c2ad35abfc4f90961d30963cf47154bd6e71d5e9c7a7508f8e67bcdb5d1640a789d2d6c4aa81b19fd4d60a645483cb79205f465fa4b537d1beb9fc232c103a21dc354dd47a24ef12a60ce19b8a3fc670d52c8364d59d1f06024ccc3190321979b6950cb14253c7792a9916ba940cd78a826606bc56a7e5df6819c5fe7aa6daee2fdcd60b89c93351bdc7c29db8e186cf1805d6ef07bf6da137963a3f997da85f7371f991c866d278a969c62a7464df682db60374e93650d93fbb73c4d51c61f33b413140db32b1347cdc6f5a4e72c8607795a5c7f365b277f27ae935d26c8190af558c7ab8858ac4581a7bb020bbff52c17fb8d4336532e5b0ff51dc2a26d154bf7e47be76625aebc9e02104417fded8ffbee58c6824697719174783f640f684203994fe6fdd846cbb88ccf1c3433ec1bff01596fea23729b9dd70471ec53448f313d8cc7bb80a86b61f80fac50fd6036dd722dd881bd9291b928295ce0b30413dcff1c25bde5a8e9b98dfc2981b9740dac5a5a4e9677e5411d5c1798cf8aa358c3c574cc253255eefe0a288b89f569ec54f202a2aa8a5d51abca6c39a5dec1fdbcd3b75118c9b8e11f9775707c93fbabbc584638a987d32238437b7df388a210cba77248d5ba49dba844a4684a83cec03f81059f4beeb3e68ef5f1b83066fd73c452dd9d2e455eb87cad782cc89e2faffa6c64303d0de200613f087e2f187433dd671721559917ac10e649bfb4b6d63a79f9fbe186e590de481e43d11c27a1f6107038ea0897758b1ba7043ba1dfce4cc9e5d5415c8e0ecfe76e46f75e11f4bd562d73287e84d036e2d65e55fa209374fd3417e0b130d17e498a595054512bf8e726865bc4448d8605fb8589aa1759f4e15eef17450901eac38ca5afa588810b80ec8966163d56d845ed4bc63bcf49236dd5f06a0ad2e62b551a98f0bedf02a64c47164e1d4c1fc365171ac27ddb2b09df9ddfb088dfa9e097caa63a7853836060925f9c1ce5de3e49f60dad9d9ebe949da6eecd26a4518f150170441b5cb608bd0317fe1a85aaf6c3067d6df903d0582c02fc5374ef40573e4ba3961beee4ff551ef76906ed60b61d3da5eef88f1462bac96b97a89ece5dc8216233bf558213f7f9861bd8a3ba042ce0932a107c1fd5b1e4da983ebc28b2f48055c74040a672782553db998949ec7f89cec2eaf6481ca408f19f8322b171fc0c0e703e748e256fa865869caa4ab11d36f435b04546e2fbed7ee651093f580c736fc98563afa9164398c59c9feeafb92d661176193f6c402ce551c1eedca849e399e7069e7179da4ac1c8f9f9e9893f97e08995260a9fd8eb2d75495a0b426218d37cb6e5547326dd9f9a9e62fd423de1f8f5c31a4a5ceff4c008c3bbd0349471a69f58ac31add11ea4e07f31907abec0d562590a7ba4c5f0c77d5a2e9036de5080b89feca80fa17d4e34e4acbca922ce62d1e68cee42a713f1fd61fa8d56968759f4c61befebc40f17db08f69f32653be6bd7ef20ed152bb338cfe4a1497821a3e40878cc8b4797e0dc7f0f5e0a3f295471bfc9769b1abf49607781bdeb6a5edebbfa76a572fdabdd3d8b736dadf726913629a5553b5924eee0febdd8449e4b6611b99c7ca5a31f0c25b4bae3ae2339f3da5598d12a2c7b83a0f0bda71a4d6995a4f93a9c46e6166dd39bbbe2f8a2fc78069113a64b8e3c74826652b9256d98374427e982cec4f57b5fe8930718848960865a9ca8d4b48cf42d31c2c63fcf407a2802e2f8995b15868b1418e19f05618483c28ee665838451f3bc9388381a194a28a21e6b5360ad8e0651f9b6807c511ca44de3f7d4cb7f155265ffa60495de903592fc89a3f778782d625fbf0e50e58a5f307b8f7284cd94562769f0213bd5eb50e7bac46e2db31796f7ae96cc10679a5e6f090075a0150a466a05dbfe1a244ba0a2e0ffea20ff2044ba2f79f4569949ed3fa3d571636b161bd3ee9b8038a2791dfb3d7fafe8667ee16a28536b115af747155319217f298b03af7470dc830f474c619207f7eb6f50ab93260afe8cbeda03f2137a8d4892308a7b7742115ada6f6734c21529db5e633f2467432eb8280f12824ca72fc7f8a5f068cda29ff7f8123f534684a0c4df0e2bd9e9661ff468619261adf37939f5061c7d80b7bc2b13d48d8037005cf4098f7c730ff5e65a1b7274fc09886b4d7083b2457e7f788febf17b3c84bbdf4cd5e202aa09678177c563a503c0125644d1e37c64640295b552d1a7e348170e5d577a90d1fbe82019cfd02f7d3a89b26b32b2ddcc16df7780669e45b82ac435c7064cd1f3eb327d29de6c5bfecb40b29433df6664576f90cf8047a1992c75adc5558b72b335abf11b3af492bec9d36e767b33c53b93f1299473ec04bd02c90bbdfa78e1392a4ef3ad09ee9983f197a005abac0957343b9534b4923b034d79c16d11cd494e293aad7702d7d69f62890ceace4b49f669e2ed2703020678e6cd200c8d628f3ce89e56b75f10ff8a1dd89cc092f9d7c44700d403a4dd644d52c92d6f6612dba4eff5df7e36f945f9376a69ccb25a13805f6ed30e22b9ea328e6ae7f31b067aa44355e23aee73878b64a9053bee06e76c5773ab7416a69ea0c878dd52b22a2f87253368a583c2a60abd34a5f7da529a1746f40938fbb5d4ac51d5dfea4e592fd4ad594dca1ceb392aa411646ff37e98d58afa4fe70b9c60a6b1c056ebadea9ac3cc6bcdeb97768ad9b177018590297c636ca7060a1295434ba182609a187278c77fcb25eeaa0e823de58230e504e72ea22ce83cf640d0252fd904775c0e8398e815aaf1b510fb2021879f27aee2faad74ad2d148f8395617888f22a54f348b14f469cd76de2f6f19c42be4e3867994136e02663b74e6359fd99f22e231af5764a540e03ad00b10d865879c25b5b4911823603c5fbf6a32c862a5888e81eec6170a42feffd632ce781576c7ec6501bc662dfe6dbd7d08eb6725d4a28a581905472d383855b92a68ad2cb0810b118b79823eead4e73ee866cc42a04a07630f22249de1f46a4464ad60261cfa9e52fdbe0b0f5c99b21e14def1a67b8e74bea3388f841d85dfa06b219ce37791ad897d06f7b26d811f5e70037fc650e746c589e80b63f8440eacdc795cdc9add52cad230a721e27204ab8c7d2597fab98aa702020a078ddee04084e75a561a5bdabc08e77a009af2367dffc86e1713ec535a1bb4cbf5ce2973ed8964e8635ab7b89bb5ea15f462c414cc2ee886da758b873795acfeff6097c3a6f5fbfd8a1eeaab2ce8e6bea81b8f36af5a3b89b536e700b1c9ae9c9cdb3ead6f215df83ca05ea2f5ea03bc48dac4bad900c771242b70ba8ff1ed8d7b9b7964f5631973add705344e65a6f0b837e3f67ff38f86eb30d24f0f2a0f5bcde1cfdf69182c17a4555d41e79278dae415c2143fce52aed775dd665a5415c8539d2e97a6aee584da24fc7e7839b39593fc9536cec36623900b0c92059f5c9646a6f8477993bb1feaf6967d4816ea848141d47c1ace386e3cd5409c13d2843caf934295eb468a8889c4eb31f312061a87985a962ac2d60902f3b5f174b1c998e08a86548a6712dfe7e02f5d5aed66e62c3ca1d744fa78b00a53f7da008d0fce9a0166cbae3546d5bec6a7143aa956c2359d0d4dbd2ec50de06a8545c383df7948b1c7a0737d3e9ff743a54ea358d4830a64947ae34ff5cb61929162525a2bf8cc01ede821d3007c0114ca99e07e28b77c06f469a0216fc481fbec13714c83f0f713606f44bc66579f93f0cd4d932889510a6724d57b6ec6c99a603b603aeaf597ff42a37d9125a6820eda59e0df23c57d5fc3f96c011e9602ad74fa875e7f9da91d57f03d8266a1ca01e9c033a43a7831accf4d2c51ffe823614c3e72b01e6127b5ec87edadd3c5b3516e9528d7ffaebc1cd79e3cd99d2d7a0653007c92fe0d6eb4cc85ebbc78e3f2a5d9225af1755810b7d5c76eecf509ad6b105e6dc1a29fe2bd3dbfe73e44119856c0b69bda794de9fa190e58847572e318d655a414a63a2316555b8e62f66c7a5ed2f962c3d3f4d7f145d945c65829448d9c6aaadeca64fbedf29b4a86f73f02485eff7809eef8073f1e1b28eccac6ef08d71e70a4dc44e16406cfe9fdb3fbd8cbfddcd4e5cd772d6a752188d6c765ee3b8c1081727e85e95a9169e29951d69f5e7e64c76bc308282e2e8a3ecf3799f4a7eded995e743c04ca5f4568d721b393ed2b12a4f96efb59de1e27a61bde6ec19feec07141cd477039bd1bbbd2fcf9311aa33f1a93f01bc90d255268443a04c42a44b4b842523c9527fb4934a7f9cd78624efc3323b357ecc2b45697ccc2297a522a203cf9346bf60e4eafda542ac1b93556810aad95e70f5e46c88ab23af351273a2ed746a6fb3623fba52a6d48c5cca98bc78734e8e5e1697790fa356565f9ca7f182bcc7f9b9a1610d83a668e67761bfd073cbed578758bf9a6d8398ad1fd5f37d389f8b5ea3a06b2bd363910b548905df9d99473ea9b14cddfe2e6abbb333c644d0c74b74042e493363134c263dd4cf1e46bf513954b214fabebbd7073f7e8a65167ebf9bb70864146ddd111680d832fc00c0bad7d7f4c5feae0d73965c1cfe7e70d6c90b8348b46948884e5d46adc9169b910808355ed59310d5915eaa6834b92e5c1b399e2eaaa23d969621cfb00074a1e8877479c8cbda70bad60d5c04c5d5e94b507b66f23ab3eff0843f9224947522402b749e57310d01b5552ebf90ee8cdb82c9898e162bd5d78c981231bed5aa73dce36b1898e3c618136d793a93cd1353f078e16a1904289cdbdc2b93a0c83bbaf941f83360b25a2ea2d06857890afce57b374b67d142aa5207b55f2f82e270c6f1fae07fecac1c937672ca65d741ed98e2fcf6c9515411ba5b150ba610e6fb23b149584b1cd16f3f8a03eb004ce99f9630e3f9ac3265fe25d969eb6a17081192c1d95eb3f01eecd4de3486f8be3c0cb3b2dc625a9a0b3b325379859557589b5860f1f97e6f86ac5a34c099ffe2eae9e54f9bb714e77dafc017532082ec80db8067cc49f701f54ddcfc7dc678550a9edf16152d9c5ad2f4e8238b36e91ee5965dd30703b22be4d3b32e07556651c8925f453521e1bd72371a03b8637402549114c5a5d66ea0339328607cc1e6a797b41182387113be2582e8a65c32038c6527c7db07501871f9253ef96b9982a71e235d58f91c383a2bb7aeee84ada4ef59c55806d27b91ded820795bc2e8efabdec50a9b76eeb2d954cdfbdad9a86a30fc99f7463bdcd1cf9c09db8e12c086374e4290afe3273e2dda2b4875a48fa6dd14b5ec1363683003e83491d04e9b53b4fc31caa9f68bf4320dbdc093770f2a8e87a2aea24febe4e99f3b046907eae14c0f20a54be1c22bb18a5b92b5d05c5ed92d6eea4a371e26e3b2eaf6253aae328908405d8fd30fc143819b82e82b698bfbc3164fd7c43d90a8f6539496fd685148289d62a57393b10d0c142b1c3072ee6e5f18929da445c8de4b815fe4f05dd9be677561f8d163691cd67aeb986bc7b2400211f1e4b6d13184e85e09548a0251056579cf8e06bb14638aa16a5d05aaf42387258758c23d6d2c7b4ac68141d8ae7ce6b704b590733592567a5c1974c08afaff32096c7b16f192a736db9769df1ea2b3800de2dd0aafd99d8cc172fa8c6dfd20e7dccf6a382d8995972219f4b600c3518a9aee76ef43ecfead5e647514b196366354b42bbf988479bb6642d3bc6fa205d53271fd8d7d94d85e9e83a4242e44cf167aef61e8ff3f359e686dbdd2a581d42bbb68175aca69cfe1a30dd0c9c145528b6054d907a915c299f6f22b3959bcb4bd0c584a0fdf4d88d0fbe4b80c5801705ec9a14727ad05f9742945c09404229ec7a385ae39f71d85d0d7754ebc0892e869db83b85e94290ffb3374a50622b47a4c85cee293521b1724a3ccd0b2a98f90c5e5f254712bede11e3222849aebd135b96df5eba509718f45544d23a387b16794e9a4cba95a21f4a323a9ed6c9b7b92e1dc9bef5f0f6356f17025d18ea3a1c4f8300ebbd81ce33fc40b642ec03d9d7d5930049a7ea88a7215f3810795c61aa603378081dc457eaef70613d8edb9d2344032f0582b5fbd8c7de344c171c2d3cb849fa6b976414dfe2862e3d1b557073f0bba9f193ec55fed79452c3f67ac191d5ae49a251a22041228e107a15f4bc2a78bde8a5de0827c378fdeb782295b83dbc161442f755f367321a29c9d2c07c4eaff53800f3a620a49204b3fd7c8c7fac27ed488c1c35781e71311e10a913e24e1a6847db09e73a39930237124d4fc049b345fd8fb4abad3f3620c272e1f45b1530c7e04a4aa3973bf557a6f7e5b885bb2ebbdf8c5088f860bd48654aae0033b23578aaaee7aa52acbe19177a98ba7605a23e510a348e57398452fafe88ea2c750e291fc49bb054526d544dcb95d4b07acab87252b10cc1328a46b4908091454921335187f61e8d92e46de13755798d63367f3c477b374aed087c8833b0a3cc2f1a469b77098ef12f7419e2941b5f4e2c40615bf8fbc7d921b334d6a2599c12c127bb0da37dc45e6926a1aa34d52fa9207d16e57fad6e6c755b5b2dada5d30b9d6d7ac26066a0cb4574f047304cfe00b61c3522a4ae6359be87e9c3c3a355b14cca24c619f7b5883db5029de205ae70ac05409934d685bb0a2be292197c5969e6a81460f315db4812ffc8d5c2782289218c583da2e13c57742a06eca80bc4c6ce01a348930e74a5ec9bcc84689d44b072cbe5fae26cc55db91849187967434c5513d95a35b10602996f9326938cbbf96671f8448f8da332b6bb76721f778f3d7457fef33875c08cc51543bc2daab408bc3e4516cf8d3f48f4a7f2f39b04c4808fd404fe6b6ab041380e71dcaf51e1900ea073ba24cd17d01d3b37bc7f658538dd51cf529cac884a1254d48e4a120b11e78ab228eefea78f7a42242211a82853c4b7eebaa1885ef0f1ffd949dcfa99fc7d585788beb49f8429591b8684de00842b4a535e7b21c2632dd0b5e23a787028a9dabf9cd7d1ea8fb32a41aa8cf3f55ed37a9cf6ad6c8c1338fdfd7820b28b14d3fdf1eca711eea6c71a350f95900da7d80fa0f1cc7fdf7336febfe51f62c52ca2d4a53da1769f3e4558e41d48b1cbbfb9a4b22b0bb3deb4834158d57d9116132a1c4075b6a966da2d94dc04c2b5bcf95aa74bdc8ba9907ff5f71385583333b3f9b4ea1fb96fd2776f3cd90189165439e4f592865b091cb200ee14c9fde53cb8112dd7f4bc41a36848b775fbcf215f35d14840e914afb5f857d1d5acb5aae14150e72eb8d2a09b52476df04163e22ef50d5e50e8aca6f1759864496e44fc00aaeac8e775187bf57c4b814400e43e9477b97848a3dd1d68e24fdcf0ba5ade9b4150524a854206dd5178a45d92d8020cf51c3dee2cecd2f591f124a71b83c820307699fed85c2a60925ab238885fdd1a2a5d444a8e592a9fb28b3b5ccb88db31c8c7c37960e09496934577725e80d9601d785cee6291a56aa7e24744f23432c787062ecdfa82ae90b00641097fa2c2ccce23d7054d14412f1e995f95a9f2d3d2e7ec4589afa4c1cbd24fee3ed85d9577f9869d656c7f8bda2e8027b63cb9625c2a686725a655bf91d21222a237cdb77d41eb5ae7bbf411a29d45ec4d9578f967f3eeb689b60d7ea985f4ccf3c2c5eef398a5a7686c35854d07987ffc72879ea08c090ba391bcf0790cfaf60ddd1064f9c5f8751bc8dd0daf94a5017c1334d5ff4cfc894ac1c45f367ce53b3545d33339747333f7e2da50e6a447f446004a36f25121c44ba6337f6d0c33b9d43c43f098bfa2a0bc4c02487caa90f0ab434d0bbd7c6ff4096bdcce670bc0b90d1056aefaae45b6217bb695f93544b9f28b547f7b5977b833b4315b4fd42719934d8f984264ee52117967864786a0e9a1162a82be194a52c0633835b9f7e3f6feb8d7678741fd713b9d6886310b638e7510c64cd84cf2a0cdc3f76e638dcd43db5efe6d0a9029721059d4c6a7b10c57fd45f08b128901080f62dee02bc5083fc2e040a2d5d46ddfeef12cb4b0a9874fec85a5de0634edcbc00d34648895ebea61c8a07ef01bf7b256a77d8d3187303b4c563effcedecd9f2d7a0e51263fb8b57c197d716ada3aa181a8912099cdbd5c5826901d47a363428824f772fdd229783640673d9c6fc37323767d3e2d66db96388a0995db3b3ca921f2a57995fd417d301cd092d14bf41fbf8486729ff81bb35d8a72a654c3a8573baec1b36c8e2c29b553f77438002c6b4635268c32d13b85866e95c89b325ef37246bafc5213a4137148e7420c3748638bcc53cecdac966cf4075795f0449681a1866a0858b06125f9f4057bae9a017ed3b84963375d1f985401b0d67e1fd932802f8a18fdcfcd6b65d8fb03ee460ffdf50a6f02d9ff207a93a8ed0231bb5b7316b6ef7ff321de6b7a1a236b3208d2602ef9495a0dad503c12098ae4fc0a7f8db4c664e9e076161e7146a07e7a07e79cd9084f0d02e2fb1445975187d58fc903be7a7513a62c4683acff28eb8a90eb46c590bc1daf0952286afb50f145a42b4f339ce01458d5d7a8bc904e78f881c38a5891deb352f890fa1aac451406f66a07d0e85e388df0da1e6610a67cd3a3884f09420c874f5287282fc27bdffac10f87b66c9a91451b502a411ac2f2a8095bc3c116792734b5f57ea91e1bd21a6f8ffd22f3ab24004ebb93e2b1915a68924f981ed057defbc51141d7fbf96911edb3e39a37db61822c96f9cc7f725a9a0ebd5bd8c2d8b339a8818cab45a1e12fbb50c4b3392ce07d923db877ad013ecf1004a9432439ddf2b3367f120440b7154a8de5495c65d97e69492b6abddf57ca5c1e7b215ba23cd481295cdde060ebadb189dc9f8c6691d9486d2c207d2bed8a217914e5e5fdee6f89ba8b1d4abd639f21ab2866ced10baa26d99d790bcd9da14842ef592298898ad360e60e1e6d58066f1489112939c3942acf22351c5999eac844504d58fce2cb05086e59553c07d3d1133e49b0e643adc56d32481598a0b29a1d525215daaaaf8eff3811c24a469034410d8d8dad40f4ce290ed350f7690fe7110ecad6c97e25a8045416ef07745084b8c9363d9f9689f63acf05679da0fb226d730e4c0069e1dc1a8ea2e1fbe52506496432ffa187fe330c0487e89d10cfecf038797b6686eacba0c9a12c161103579e929dca83c338a49b5b677cbf29109ecad00962b288a61b6d00490427fc71674181d5f43306e5d53a44dfee57897fd94594de1c46531dd3dff091aabb8bdc139e47daf2c0f8512feb1f05d73588501d31210012e829b9be7b4743a72ad794d9ec8b10137146fb9aaaea41769fee3ea04f4b527630d60706ad0269e5507c6b78fff272f6d662cd5763f0a080649f3ad6470bb4cf603983be7a5f2ad35bb77684e675c28c3f38ce014e3fbded17fe547edd5595cfc8ab82d272129b9590fc9f0cbece9973c629a4fde36a44806d0d516a1cff5a7b5e5d138fc11c25ca10d365006c0a1c99f67739c32a99420d03a956dcd9de83b3784bb82b156786224610d8a9d75db40a121b6c6233b004b8b23c6c098d817c2cc11ee102473a804bc2b839314663dc40fd5801c7521266fde55254ab1d6636773d00a007af59a6a038a2c27e677785e288503b3930264e35b82f9b0a4b7e4b834de22044c65204656285c5c1b95921b7d8b9eef38ab646fbbab1ede06ceaa3c3ba187b24340fbf541c808171398f8ef2a4f6458af5301a4b3276664f9797bb74f221d6b925399b6f48d1d242b0b6babb98494f2c1858690457a3930741c99f7c6c514aeefaef65ce93415320fe8772f4b3f454214efdc12a193ee1a957812089dde3bca5a0e6a8fb6070d5f60747ddaddb2016248d37698bb361deac9f97ae6ef634476e3ea8fcab10fad9f59b884928833230c53ee20f61b46561853543391ac71f453a46ae2a6a3b2ab0e9377518305db5a6565ce430c348ba3d4695d0eddfbb356586eb66c337771a3e3cb3f5d55eca602315a868fcea711ec781aede3125c8a8e0314e013a7ae3a0e3495fda20275d2ebee767620b49581c932fb91391bcd927d2c3f5e22c183f818b04184399fc85329b517ff44651e80fbd6852760b1f755e8284f6d061f78299fe79f0b220365dcf14a1c3c70721f56a19a12308eab23c3c87aeffd9fcf657d2f44bfe8405429dd9023eb4ac02156ef2793ab753d278d565f0367ccc1509d60cf0bf59b552ab7355632edc7593694567df258c41a706863fb8417fc202f0ef37e4a831c4858f00d2b480938c64d6b4561139714870de82de4977240efae4b506d63f0902bfc7dfd1bd8f51fff354ed5dbaafbf16112bb936e96cddf28a9a516464e6156f263b1df7db536cdbbb0fc7102ee1ce78976269c3536abc122112f3ee368b6f37e5d77c00dbcfc5a24d0d5009de0d6d42ffe47d71354ea61d2e15835f1c8a2af1c07ea93551b7faa7b59b411d01b4ad083ffac565ef536df3ba1a2b6e0e1bbd54c0ac9ecbf1c1e859247f4c1e46bb01526f5b4ed8ff0ab70e0a4037adc9b23a7bbebafdb891de7cb194a7ba06471cd9375cde044528eb03ac584d082bb0b8c24dd77860207273afe1dcaaa91b0b831b3374ddd43423f6c0347163fa6a701cd070eb893b27961fac812f7dcb6f980f03ff8bf6f19afaa5b42e7a259d7defef9f88cf01812f0ba77b9fc0b916620d9cdba57440acff96bde54279d72e47512235058487d16b96295bc60e97d31464722a18059fa01ee7ce68a9d73eab40aba21c6c956d649256756c51fb611d0a2c0916d2240abe1fe0a4d4134605581979b9a4867696e4d5ee995091d60c8323c063ba834448d2ef1f0d82f60016a2dc56538a298f497ceba1c247c492eedad9859816aa7224b93fd34f062ce1d179003928809d590419ad990dc6f44d1b4eceb1747cfa35e82165a63ad1c84d3772a05d192caa79e86d43ac657f677ac0492c801ee6bf120c37c869ac7aaef25d68ac153da2e22ebd796b1dc13c8f552e2e666b8c2510e6e17f569373f3423795ec104efe14ac8775ece37bc5e5491354d8e46a5fbfa5038c8efdcecba9e62142b26b22672e709bef0042c5b206cbb9880063808d95a3afb0acdb99307c37e5f41d3feecb3ad21456b0794b15ba627d11733e7c8ae5b019c8d8a9a97bbad7f0e1ed93b20b605c84bf2c7f157fd0daac2ef0cb9ffb84107846e9cd30b62eac163485879462c115cf3aeb9e2055c6d2fe6251ccb04008123593c834555b9a1b3c95e981bdbdbb77b1eb2ec72c9866c8a033bc429628cdbd854b9e233c723be63137f6c6ceb8dfd57027f01141b6130d8956ebd5a4ce4ed1e268e46899611d0b4d7b4a1501b2b444206eb6992d4a4db666cbcb780d2ccd605e449595a5b472b9a2bed246feae120831f7c8de542a528d030cbbc15e1b39d1faeb24e51a200c8f79724f7bc9c6054f254137b8ee38ecf7119898254a6d888594bb06c99950ca4aa3ba8e80486d36d8c2454fe780f3df6571c2f06867cd6fb5ff610841877fa5f09dfcbe7122d1dee9b17b54dac74f7d298157f32b195b7205a20ce47e1293f2103a7092e83814879c1f6987e1ec72a9cd2d50ce2e7fd24158b0d7cc28ddf4df251c9430e50cbe445f6dcd9f4fa2ed902438a2b41ea16e529c78c76889fc234169681066a02f6c1ad90f67e0d1a826fb12adfa43add39984e4622b90c38f5311524c397312a94d67a1306fb4f73d6d89034803c1307e649f88b66aa806f0d85c10e4abe4d57e19c4a4703212e96e7aad12f4e4fa632f6d9f6741e31fe273dbeac23f2b42832223c2379c4df447c2149dc47e9ce2e33583b3e9ff292260bf26d4fdb610b5c397096e1c8b7bdae312bc994dfa4d2fd03ccb66d13e7f7eaad08110060083ba427e70f88c0d488e184032514cf089a602e97295d6f9aa672b4f6a31a0cdd4c8dac645990687b6e794744d7c1253ef950047d13f12a25c585b5916f4f0c32724de185adff4d6dd6a1eed3762ee18ac2873d38e6a97e85191a3a7c40cca9195ba83844d82995ea622af89a35cce99dfe7c58ac0cbc2b8c06c1f8a6030a37c9f30fa418f0804ff00fe8bb261d7f517ac1d4374d667d45598c3d33a242df3a5bed521cd11da7a8318514176a9affc4299d4276a11e5df71154793c760ef4218555148d879511f57b84b81e94afd763c11a841aa8601dfce23117befa9adca8680ff4a9ca583fae9a8d8257bdc0f53a8dc7a698426d2c37fa82ffa1ab9e49e77d5ead5c18a378a92125dffb27469faa66b90cbc1e7382dc3e2831a0db4d84d56153b79967fdba0bfe5af665fce9dc3519b70a44f004d638b15b914c0895c758e9999c7743769f704d274b5431e47f5412f0b3cdcc81c8ef59843","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
