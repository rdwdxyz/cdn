<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22f7f774d2d46355a33fc154ecc1861f202454376ffb38ac0064750f4c2fca5c40f2e11b92c51b0010a241ada7082c6aa094fbab14ae63fb1e65429528b628b560bd1f60b555b01f3eee6e07af2c2cc10c98d8734a4f2aa4f40d3c622dca24709743b8ad346665867970471de186d8980bd91e6e5d343da0f05686823eea4d1629e9327709f54861ccc974bc9ad8322999e29d10145cb85e155d331cc6b5f6167802df5c186b551eed0bfb19b87ee871123147236e1cbd5289ba384e8fd75d18090806a4b968b583fd0e10fdf2c0702d3d349e12333cb7a123e8d89fddcee75961927982f67eda06034de7d86c10f3fbc6a4e70fdda150abda31ff1985345d81b82cea44a3a8b295e2463ff9756bc503ecea7fc88564b047d3f5baf384d78e1f2b0b2270921c75ee999e21f43b606a48a27cd6981e75f7ef12c46bfa0f953080e16cc705c8acca6058b547a267917b1dea5fecfe95e790be018035f39b3d79996f3ef5eff2d0817716d137ac8abb7e2450a611a2801f474bf9876f525b1cb9b6d1d65ff9f827ad05fe526b3713db586c291fd3522c6c4ae2509f43d5001db8eb90af1192d1697ab691d0c17b83b1be022eba958db71fb7eabe2713e8175a21c7840686c40a58995bbda89ae43a4f69f3bbb8d40dd9e186d7a43d1058ea9bead63d4bdc8b96d89cd8ef6eb1993cb972810cd2da039fdbf8d7e30626b6dfadf2994fbf6f41998753dfbcef2883427eecaa0d9cf8af4aa79813bfe3ed0af7431f8d59ba08febd5e41cac277e30e3d1fc51bb648ccb17e1be9692300265967c7e13d6dc3ad226ee4cbd65170550878315d812ba4d44e7b7f4cd30453f0a7a54f7ae0be261083372f77d90c732420c414952174f9be26a2851bcbc7cf8507217413582eb992bc51a110794c09bd45844040cac65c7dfbf5630ba1583467cbf198a00f99e2d459e83d5cdb45fc11341f67ee558953431a412237b7334c5912955d61ae900521e15435cdce0e0c02e517f49d022ad03cd9d2d777685abe429627defb77f98bf30053be3907d2ff684478f3bd363cd2411461e4d44bd1dc53d347323e4762413523e846b7a8c8d98b855c2554d90adb435bbcd07042e59a3ebcc7ba81dd1e110c5860fa53150ab37754296a5441903bfac9c9a5469dd10dbb144554bc71d2cb41be080850d1e69cdee847489944d7fbfc52d562b3389fd74c5524a08e02a0f64acef8ebb82cc70929ccbf13232d080447e58a5282cf64a558224acbe5757f391dfabb554509156559cacceb6dd13e908ca4cf1526961493461ba4a45e7f94c0d66b82db359b87f01d76eea6de73dc7136b6a172d46c3be860a5c1a641765f918ec3d5de417263be25c0bc8337de7320b9ed5d8b3eb6e8efaab9cb82200219ee5834d9e88e2c5eb6a840fbda91a9c37fcd4bfd858d8d7e229e1487ec9fa0c469af03f2c88a9ef6780e5bdd24b9867f031247984d03dc66d2ab2047e0c0dbaa7ce07263bd8df32bb37037cad6d0bda8f1bf6a6d95f5f6a63af6f017b91cf9c57b8055b6c8da0e49d15d04c0642ef6632bcb6ddf121feece046f86188c9f131deea2dcd65a7aec3b5a0fb5f217f235863c214f0eee7323bec4221ee3ff758f33969f55fb5c395bc8a4abebd3adbbcda36442f299710d3e630452dc3292bfa7352b7a23e6f0dead5593c1ffbb2c6f999e32a3234f24a3a7fa36dd124623adb0e228198ea30d9a1b1abced72067243ba38ac260a0ffe0066905e7c5a357892e02dc6914760cda3b5a2603f3f57a0cbedba933f9677fafaba0e24c0b331c9e0a94dc0844d81c7c7fa0dd6541da2c1a86a44299fd0e57821f841ccc48b7440e2dd6a5e4ac03d88e080747d7ed90a85c74aae651497d8468f3d2d8d391b39475cb5930b7684dbf1777fc9b816e55290e90597a8419d2bfeca1160fb67f59284d30c542430c44c43919149e869a5fce99a4b29ea28ae520d666a174b484391ea0e862556cfb23f8d2d565f9759c46c167ed4c3316b1e1625642195845aa253230fa23971ab86f198b13b7fc992a625f5d6d90988d2f7a9a4eaf0af11bf3436a6638316276bb05ee6b976a729599fc955c5f6d2ce2426b3457082f9a6003e5e4b9431b5afa29638841973984c81baa93950cafa7d66bf71e1a74f47b6e69db334e2408af2571034468fe3b9ea90ec988539066200bf78c46b846ed9d0e6222fcee5acb66e0d6419c5cc40833b26e5203221698a7f9439a0496de9aa73b87f99a7fb9096b0d4d33bd2c45d38dee1e88e3260d806e69b6da268944901206c4c64316258769cd138b96252c174553cecfc94a928261322d2452871870f9fb19939700225f2bc1c53a2ddb8a9b4d4d2a0e5938bacc693c9829da44dc2eefe1b206e940f31710a4dd1f202ae0068129521533213a74e41a5ec05f1616c44972ec5487ece92c7171585180ed8a5460083df21244debffed574a8fb4a0096638a68644c637ad3f8649e5fb0f12f969ce51467d2fd595177474a590d00871910bb64c24d3187f674c1d6d27ef844705ef4a95d5ebac939c8398585c766f2c34ed60c29e752350bdacf02a5b5760df92a83877f6c6c198b8dd63ed943d18fd57d7335296219f771aeee156c59e8e16d80a2a92cfc4cff284b7870e0ae541b69c5f9449a42ffec52f96720de284cb83a3a43268c9776e6e9209ada6a536d515391ba0227bee3b9f7648feca469e01c76d5dbe370ffba48ba045affb92f354f819d8322c4e860b0b06222897d00c0c5025de8bd7f64507e3933c8fbe908afa87989b3bc3153943f7e1fa2cf665d1007636a03274f2a3908c293e5c81986e477dd93fe4a9f1732e89c7f752787953e6af84b53240fbcf2f847a77b8c29ff4f7bc03edfef50e5eb5d5623ed2a029f5af68448833240993928d193a4cf525412cff9becf2f49de5b53761c8ff0b26656982568bd7bdf7bf7ac19784a0084738d656c1a82a4fc55683f366a9e74f3890da11d31744f54014befc2b0fa2b97cbe52be1f066ee6d5643c0ab6dbeea7ba6a0337163d3fe557530164c4b72ffa877d56360302a192783951255bdc6832ab0614dff45f54bb4fddf3e0b2b7df2e28f674655ab333daf332bcfd10a0fbb17a9f8676f5887ca9a99f6a98f88ad07237ccdc7b2be15b07496ee0bce0bef4fa09f1082cdf2f0d4ff9fea5cbadb9f311ca6cca9848c0597220b1f4c3753156b8e5d58a1053b4e88afe1ccd34bed230ba917b656328b48e1caa9c6b9d10419a63ec49d62360c33fa5f872a9d4a248e891b77cb4e2f94019dfc8749f9ec6b20a074ed4f47ff6e643046d90702eeea38189beebd8e058f89fd434f4f45088e66606bee47e9da0798e9ec77e021804a9816a8ca48a44c12ff878f9f4f78d2a55720186a41a4c48446dd5d6918eed177ec1e5117e4a883706a12b5986d260bed69e3f030d426c7b5bdc7bb189e921c441db3dbd70fa07f420c9679b4ee47bd4a39f99d6a0da550093623cb9f36593cf4052c335e97bb6f3725a1cdb8e0c1d187c41365d0ea4bc3e7f2920d05ac02d0579b08a4558ac67e2d4fde0d06c99c9faa1a241a8717e9ab7b462b2a95a8335ec47a328c1e7d537c898bddcafa225585c37297e70012129e9de2d00d6b8f32c214774b5c3fe6efe80ba8d2758e5e5548dcbb6f25c4a10e9a2521a18309e1c2fa1972a3a311d3f4e309128d410041f287ea3ee31b90b789daf80d9b5fff423f334004e78bed1d0d7b5d5c5a22c2a12acc31b9465f10fdf4e85aa7950ac069a966aef0a65d1e67a1900170db1f91b6320e9c7841180c870fc3ebe6f48cf0a695f6ac309ad108088d6b3e74ab812f1495a5cb7006a4570b059301f86b3e04c2e741e4fdc6b8457cc5da59951ffda2405d8152825582f94e4e29b74b77b4f6eb5caf7edc0530d0f600807d10cac7ad97109730871b5a9b3251b3934291fcfd6a94804146d2fe3581f26249551c724193d4e7501cbdad0671cf12508e7ec8ae2d929c42b46f2b58468a544993d43e988c3c1eeb8af6035670739a62525a1190325a2598248aea8b6d8fd39411f8381b465b161c6c475a80c8bd076c70cbc679e17351985411355e7c3bfa9d3b9336c45ef158682c5ca1e88862c7372316b0cb2fd68b7da8f1e566d6ea55eb1e8246ab46420e4f67569354cf150e9fa52a6f5295caf05a3fdd172c7271a335a5bf461cc121f717769d5bbe12332c1e5fc2e5e435c36e3e0b23b7d2139f16cac7749c1e1000008222db658a2a1b3c784b95f898ca2e65d23342a5b2c3dc0b82ea3738f2a0f2d5b47fd5ac2e22c3f4149208c3e45cae5a55612729c5bb30cd39cd5e2113ee26043f44a5701d8bf7cdf2bb0fae6f407fe99021de388719628a83d6a329a8c9ead0cd916944b4a7a684863cceb46a9bc336d1fcd11d4faf1c062172af86ed3f21b28b508039371110b916312685f4945d24e84c0ec6557452b65c03f5bb00990a5c21ac862acc2e19942e8d8d421fa843f32372cb42ffc2b082bc23179be1750fe94bc9c61814ab2f4f702de95beecf29bdd8874f487ee5948dc7a2d9c266b4b6b8e65427521eb35e47169b524196f7fd4b2e69c66a4a7e57c626b152c5cc8bc222fabdf373317f106c7f2c3b7f4c79a142f00f3bdde11014ac9d996fb98511e602f40debd18f4ac7d4b554bbb5a982528b9a8b78b6a12855022aea1ff230d250110e1574c1c518a3b697cc9890599249bf6774455b31d937e3f1b079328fdf11130bbd10faf41ef83d2fd0daff80c6316c43e1fb0fd9475da9fb398cc6e2afa3326702c18665afe6b13144b290e130ccc9992b1c6f542e059d980cdb8f9233db600b255e39652bafac7cd64fb32c856bda3e6012f8b0aae1d396f6e1262975c6c6229e8cbd94b988899ab3c129450e4da4150e5ddcf37cbca7d399a80100faac1e41d6b13eb65c2beeccd9ea8d903cca5955b85338bae3fe780b8adc5db7845a68c22a0bf07a3cd6c8d9d73e2c1a0a7e0fba6f55c2b48a0268a91fabae88bebedc0dd78b38137186eda742cbdef963746c13135c3771eaf9bbe8ee60f830a035433829a4a6c1a93c2d0fa4af6fdb5be977f3e1e71b42ce7d913e01e6551295cd6d54a259fb4d95efc2c1ef93a7d63fe85b2914e57749ed2a843af687bdd533ac4b8c41637b5d2b5d4b7ff55d137b1aaecba8c57b953272707e2da1d8c7019078ced2c70e699110549b0cf8e03e092b1bbd991bacb03f6f6a750257c5abbd52b3c17235610774707a153e186467c7b3f5782bd8d656c1bb1bd83ca7e5304afb256fbb8d61341365c27336f4221f2a2fdddb16ea0058578ca333746f85508f5ab6ffa9c3a3f7638538b87a301362fd9f42dc2b1d7e1ae00fe84ff272e512f837463b38900521652133dcc15e3a6887e906b24f0c91951e958e1c3593b52bb7e5b80709b6b958a9fa1203c4f3f9ec78f12ac4c5a671ca07fdc8f078de53c59a82aa9813a15bbe6856bf85c4fd24a74c5accd5441e2f7681d0048bc0d8726acef0f7111aa1a3d139540b36667875a94f983ff6c55a4a3d4d382df596d58d48d1c4ea6865adc8a5e608626da496e762e75b04f9ff6d9caa0606403b2fa19e5f61855b598964de658e46649a87432d366b60dbc1620a0789c89a9ba589da4a1464d91a930f7454701c8cb3bbc3d664e758994b3e1483850af2afa287dae83c46c661c7f92f6720c67dbf43729bdb3cf62b767869451cac685a34ba8641ef2d45278f31dd1f4f9fa01992982c547bbee7dc8ccdcd0f9ca9c275629532132bd55788b4ddcb7ffbe1ccd240a20e6fcfcc4c329766c02ef22c642d24079ad67f3f5153cd46d9bfab7382acb179a4d50120112031e30e439bd31b8db1b0188d76debac0d80c51fbecaadfef07b3e2914c82ee875e0f09175fc1c5dc0611fe22c4dccc3f3cc77e7f596540b9e49951d71b74e5cae0e44a35d02366988c8bd6b024b81678d6940000ba81ebd7f0a5622be78e57bfe5f30cea7d43bf5edee76f3a948bc6489ec73804cd765d62507597aa10f7c3beed2888dbfe635801ebe0eb15c6eac50423aed5bd30094078c6090c6400ae6b0ff10638425dc7a59606096db37257d07cea5b824c3b6eaf9195976f180a0ad054d6b797b5aad76aa66ea5d74c5e0e213d71b0ba3edf5daebc6255efd323cf973032bee528e9800a3a26082f5f9da20ac5f02e2ea6d67f5a2c7311421a065d57a5693956567deacd2f416442d82a3db792880ed55fdc57733eb818d2452012c7ceeb1699f4182f990c41e85f75a7023ef3b729ffc94d814c57c0fb91c730eb43acc1619178732f182d6d8a58bb0ae784b61fdacaaaa423113caf318530b3c735ff67dea94126b40ffd5bf85e2ed5704148abe10bdc5d565821643fdbbef0380a94cba9bf6acd3d4feddb240b56d51e1a3907badd7a4f5f78bcad4b7406425c1deb6464f0c3d0f27d83715e89463c23dc76d3174d44df01446e1920ee00aa2583c750c64916d14ae11f69d2b5ca5893fb826416d1c32cc0a341d0eb50ddc0c4b867b6b01b52306da5cdf8b16efe55e46a318595462aa1942adba7cade7f5821c32c021ecbd30f3ccac2a9438601e02601da340cb5cae16f334070aa418d59b5a68ff71bf63766f2043f8c619e12fb909aa0348562f3b9b5de6549c42cf8f13084bd1b652083e4ccd7b6527d079eab00c764b91eba593fd23ebdd136a0dcc324f9b17e54e1df2fff043ddf4ec7e1c6001a8e1e8cc5a7f6114e9bd45dece2357053a67e896d5347b184e1f27d36c36bbdb01d947bc0b6178a4681655558cef5861a1d350458b5f33237ea8509c6abf0166ce68d460a54bcb65d9cfa301d07fd15721e7d705031a311ffb68fc66c4482e8899a8cbb02ded53fccb61e1e0843dba95faa59edc204527bb683cdd16e7e8268925c109ab3e80c65b9c400b33c2a54f4e8a3102aa6c3af3f52b67a12ea60b040480e22a2de8dd1f2164f01649203b7c63ebec074c0278fe85ce8544add7ee02904a235f120b13bd64a7f1005e3b07ad48361631430f6b8a12716662e80932455d5f09996db4870ec707c780855090cefb342db9cc3bc9dc9524edc4448fa5acfdccc4abdb9aa18916f804a673e0fe3ac49fa9c4ff4cbb9e863b48cf41e8b9446e23913c0a54dd111528c6d35772901615a26e72e10bf07f4b90579ea425df9ad46bb3a83ff06b64ae74457b87fb484b17b5d8ad656419ca9a0816d723b5fc3bf104bb16292b550f123b9359b9e8b10c138d692bb6d575cd82f203a6278dc876a6760c3f23402c6612335e77d72eff86a3d9b18df44ad8d89f413e86bbe0bdb8b55e9c52378f2b1213a25f8d42038f2423245891c4c73b5f2e931ffada8f14ccb97e0319914a82ebc109296c54a49bd756e42c477e4a6be52597fa81085deb8179f9ef09e967965be98d9cc5d497951befa991e1f99d3a71a4f7de36ef8d70ebd291513687823323bb9fdc7ed7bf2fc9f6b834c9b75504117c0dabfcfa2f894a10ebf5ffa6cf5dc1d2a060f9a8dfabb5e31e42a705ef33dfaa2a9dcbc7c26991ff420b39f718fc3306588c5e1cfe49587825525e82813462c9a35fd4417ab9c326c719c2620c8f6484a1fe0592d8ebd0fc4ed4e5e549a8d335f74a9ff4793b5b7e53866f5eac51e1aeca00cf86b84973ba0689942429ef1071c5d4b33f222680afc50fc461b4e215478070f67531c7d77057268534d3d54e12ef723b5e183132f87f6f057ccd8bfd81400171fb9eb6416cc20b71b56951ad9d585882e706ff5f3e303f5627ba73f7fbfb31b149457ffe43259c001d0ef20232ae62c4883849bc7041ee8d7d4bad627e17eab13a5af8e713ba4c6060a7aa0b8746b7c0c00586896040aa195789658f1df7bd83e5c32ae19d4aabb3dbe52cee52e88aa423b0140785152c6b0fa2bb0b2ca421b40c11941a6e75e85e8b69f8b12a3e7be1dc223a8c3a6ef125cc7793c1532f4ed6e8bbefcc11a466a23051691292d6ec0417b7b4920ee7d82f9a42a17f42fcc57ab52a4a93191d0951398efa7f5e4d103f4a8c424a0a6569097b253e205ed1deec76b1a0779c0a41e0ee1dfd66c8558dff0d9f453e70ac134d74da93ad17ee50d70d22af45ac05538b4d70d86b4136251abed639bd8a9de296ae8f2b8cb4c4357dca4fc03307af62f2e24f28543c5601614c8748cf95d9c70db89a0617290dff9cae6dbc20667591becf3f30a2d9b707d8b612a4b8dbe222811c2249e3cbd476b2fb6efdccdd3a7e57e8b3d8ae3054bdf566f672906a129e0cc9d506211eb699a08787498bbf173155c9bb8a1297f9501798b158869768fa45234c975d45196f4167ae0979068fd2e4dbbc73806925419329bdc705f95faa5b5f8407a3b9c6aedf6045a53c4fc6ec287e7924da4a64487f9fb9835e1633ff313404b92fed0d68b3ddeae5d0c57760f5d7e8654a0002260f8a54e8602740f44f51c59e61c55517df8b5facd90cf60bac814b50c0951c17b72d2462dd6f784c6b5c90a7f3c8f5dd2e339b98178c6e8ebec99a2c63e7bc69434c56af9df789ae7105254e59a25fcc563d99bbab266cc5f22f876894d23cde3103e404d935657bc607a16f8a601ccc766d198c2c774eb194d069576b7bc5e8b28975895b0ae337f539c8e75ec087e8369710348c7fafcec6712d38cf666aedaaf54f794699e6b14670ce637c571bdb42b97f3b9312e2497e1a02d99872bfd2f695e33d5cd1865970048b345a74b5196093933fa9677b6d3b66086ef485ae31691ae9014d117e438846ee5752803425f71ab72d6b47188114a8989da2a1d56150600e61a72b0bfa93549e664efa599067465aa1b7b9d832a540dc3fde09145f37d6913b6a1b0e8324b76b3d925d248581c8b1b7c185721d92e962392c5ad63330d26bcbce8d1e778837f86e1c9bec206c4017ccc9e6f12096d3ec217cc5285d06f5bf58bcd1042269ad18f9dfb27be44b0689e801d75f0ce6ab4f278c401058aa4627ba91b043e6fdf811911a1e61fd3975a90b172bb00a91bb1f162a56b957a3b6155244975cfc22ef8fa623d7c5d0547b3bb42ad475fe8154b1c33afa843265b20d0a9d0b7cb9ef8dcddd2bafc046b582dfd50381949c8211a04862d415e0e2d9f2b3591cffd17338838c4c844cbf80d18095510b4b5a456261856a38e754bd200b690f744f40d16446b2c577c9748951e87ea26bee6687d219e7962117658bd8d6639d9fa166e2d74b205f173c38eab38b662400d4513e7eefc6149652f32ab0525742dcd94a65d39530dce0479995a56ae26cf6eab36826fc651d0c7a6558f86c5151faa6245d6678cf1a976a8a36649561dee3de904109ac0e7288755ef1dd26a647b03b0a16fe119d1b378934022601d6fa755c1fee277295e720d01bd70cdfaf76ca1cef297e1c6fb6b5c7909f0d0f61ad8d3770dba52667d7781ac8c3ad27846895ece860ae8c20851af4de44a528e0ef31b16b1dbb86b1a4da9168e835f9fb537deb930df5eb5e82934238eff753ae3d2978a6aaf933ac2d574dbbe6ed729db26363a31be536e362c7389e14ed647be4a61b77291f0cd9df283d641e4f0b61a3bb624edba6ca8a3ab82cda0baecc4ca32bb2bd3ea6db6bf88a08cc9b69f631ac04f46d6db189d666c106a03a2b25888d954f663a1be251e74ab7c40e7f4e0c51487db8d5a68805a52f7bcfb5bc21fe5225cd413c0dd297bd501556ac3e6e6c052a1aa506a44dd75895a26fd6d465976bcf7f74c574e7c2a3d56fd5f41ac48eccdfe8987ff845f658fa8dc24c7d77a2b21dc2fa22b6358d284669862af18f6d1877f94e82d43b7d15d48e70b98f223e705322a4cb5268c1e9f471ac75a5a75197d6ae36c0df64da3da1248df31b6967acc3ee73488d47b082c2d19ab2636f493cc00157c0365cee8eb79af1e8cfe723f6cda60358c0751c428fb026d1f0088501e6122360a8b1d497e8684226864eaf5691fab5f7ad99bb44207d078ad8455482fc6486120bcdaa19327ae0ebd4949f45230a0a6a1798caacd275ab7e71e14e0c0ec526298c6aecc24d09e90114a0c931d649e88e0503f382a37b32ccf7a389b5c0cb2a7d47f52eb45fa1c7ae667f1fc01d61495f4c7a024678a269be2576316638ae30df91cabb85b2c4e7bb9fa0e391ae2b930f1fce817e01e2cb9c9d1987455655d830277ebed68873493123c21915f71bcc1d639460ea8e285712b2eab326c7a66e5f804265e08b7fe8d3d3ecb61366e812577aa43eb87776bd13fba10d42e8b2d63b48c7d9dc8e15c8fad025dcb08b2460e0acfc8783426bcbda92f72f0274f367b40fa10387be00f76a5ee8df341310c2691cb9e4b3e96b0da69eaa10794b8fe22e8566429eb12cefff42025ee24d759dccfb18462c4e8cd9bb4d7ff82da64a141d00030908a2e8f274eecadbf55d30aa8511f6de81df30494260f163dcdc3874b187c4b73dbaa31ac4bcbfd3ce0657072788d69d0e3d046790b238064e15fb3f47ac8e0b150cbda95fc14a0803aa274d08b0a2ec23778eb1ce4e55498ad7e24d0e2c19eb0386599bd0387de81f2bef39eb938df8c4167f9c27c4be555b3a148dce62c037e29f505bf036aee6e350c3a1a6c34f1cfc51a7212e824532d793b5afe9ba9d6f0d7a609e0bf66a82bb2829c279cabb62ad4b279d3f9b57900353f5b27f7c0a6263063957b8f9cbdf3efc57c851f6cd2e0e27f52c8a9c1c803aa144f1fd8efc78dedddd2f69b662dedaddbf69728614d14922738594d3486837e327a53b1feb567d8999dc5565f5709e5ab56aae948857e08601254484bb6db3aa7dd61e44b5d4b0e3185f673b9a470b09a4216d2bfefe9099f8a7c7233779ab646cee7e9a531b9dcd52e21ad1359a4e7e4b7def122e054f752e8060f8f97d218975ec579f669ecbbaf2fc9d5062bed8441257c3c850147312541a0fdc24ca02f24c516ee3805ceeed2a5ab67f0f13967e0a578ac42e2765bdb4cb9a5614cf8347e8c1a0c5d8b2f7f58a8c235a01fff99e7f960c7a73a185994ea5b0fe874e77d1aed1be45e6c9510c41fdf54923d55cd3e725c2114e3bb03719359afb470cb34f6d73139aacfe985460d06a2b4a1006ad1b256b7d43f5e8bff1456f809c2cb4a6aa68a1980241ae48a0f92a707d999216f45ad9c3e8d8036b2664d2833b42637c9486eb2f7a5602c4b2212ca1a2f4ba016ace1ff40734c7360f0766ce0f1e2eb6034582ed5f204a73b42bf4bc89fa0441fa4db0ba3df12c6c6a88489081899b08f8c0008bb90d264e1411a9d300423bf5dea015fe5603a8f3fe4077ae77fd237a7cd36289e7303756e9917f3499b230efc64923ff235009da46b663ebf3cb112bc7da9ac9c3d21146710f43c62eafc5943c9d51b8a60c47de6f31229fcd7ade1501f79358436c2fc86609ea9c2b530986f73337f7391ec9739fcd81c327c0206a741ac2f850ca4a42f5169d565770a6bf323919240593ef77d53b82514ded0295ad6a2b56b81e58163768232d6d8911b068e1a2bf7badae17386a15d9f220b32a6df363f53311ff8ae4946a574f573898207c4e4e70e227a8c273bf72beed87ed8e9e733f20635b81a5652c4ee696b61d84f25954b3a364afed7108bb2b27257f8f08704fb8d47b3a81a34b77cf400ecf2cf6b747e249458c55f3dd350997306baf26fcc5aceca605ff4440cf2be77e937e1e7460efe4fdfe33caf5a09d1e9f7a756e6a443cf007962e16cf4f2f845af304c12fb5296486a734aca5cbc54f22b78efa639fe6f9f592e69905a6dd2bb4497db262b1c5a840336e04e851da6fbc402d4f0fa2513d8bd7882734142176ea47ed0127a47dd15ed7bf5fc274c0437f98c47963ddc1088d536264c3b7186a1c0137a9b8ab0b444477f2714fe702bf9fb455c433ad257e510a34ae3305e1fae8c7f55be249bc695e977f9ba0e8cd1eeed7a6bf42b9c85340cb4d2334902c569ea4eb71a109140d5e74d6798cd2d05cfed116b881abb7d83904f11222c76f13914a58c04f05a2796f0170d560cb7cf0be4926d9e8ddc295986d256a6a5b1e806fbf7bb35d30212017e6b0e8f6eb5912d2fdd428624568020ea9cb367dbee17c2b89574385590122d912fc6b65d5a83a13145b59299fd6ec5e4962b3c17fa69f4849f472a18b89239bed994e303b08b78f06cd0fafc11b6cb57f59278835331f5fb64237fdeda6b0f48d45afe0d8106ce249037502ccd5aede2be110aa1b7945d4862e73863df5552861fcc6a0d07d4857685dc70a7dc0100764118fbac66e703d43ad51d16786f60edf448c7afd8b8b3f02bbd1496c57e97aa76fa474717411784348076e7ed43ad9672b64404b1976ac06cba3c51e99bf12a86fc5db173045bbc93851e17bd47ee9dc211a54522a0c4a3d00733104237ba68d74afde49083744f3a12207e33417d56a0485a4fa08e68b2ac72ff466b7b2f467268443281d7452410e179b8940efdc5a691e49497c9f1f2b1722dc013301b58062e4eb4478113c95496fd59232ce41b16cff10cd33d491501eb5afcb9fc2bcb50845e56a4dbe2173b4ea0acadad049ba2c644be19d10ac149aed13d784a7bec0dede4f5d27ef36708ecb421f34fa571201f1a76e100b029958c96bb0ea486240a9176d136c854804f3224bd3fd7fdc591ba398b40fad732e499e7f3c0a80da03a9010da8b52e6f44779ef446c1af1ddccd1423be518d5df906d243e801ba190fb2ca9eb003f99b028861295e7a01ca49e8efcebdeba78d0d598a3211193574e29454b4198e27c4625cde93beb4e8cf51e888b9c3ec3d309153bc8e0c380824c76755e6cd188ccd415ca9a511964a5f84b1d179b336b12334c1bc0bd8b646fe6936ed14907534e5ddef84748b405eef57757434ca9eeb68d7decbf96b80ed2bab40fc0cd30852f42595788d5019aca4ff731d1a49360ca38b09554c679cd6f592ebe2e4e69d7019813163e3c2d1710be3d41252828df117be74209571238897ac015ac4ed8a3645e31869fb3edd93a946df68652e818507c8cd20402504fdfdad08ffe6851a30341d8ae16bd153d54730067f05833f83163d9573d8b8507cde70eacad43dcdf1d3ed220a0da75b5d5ce1660eff53d0a02f878e50aa57e30dff8349356a9146906ab5a329c213d3e3025a9e9bef46fceaa5ed7cc5c7e901657c43bebf5cd408308464ad37773efa8bc6f98f9510184ec5f12f819542ddd199e12dac94bac58fc39cff292421d18b283699beca0a0d466dffb790decdea2fe5c4414b101c2b7a83bc0502a19875ba9095343e9125a4cb6e0ed9bc645c259d401ce891bebb498e83eb585198e49d19a1c0fc1a0e2fce438e906e137bd8523aeb1b9eec064d738325877aaafdff9da1a817320aab7bc9c3c8e3dbd8421e6f6ecb81c176c80ee29162b970c18b440d916b416291168df84261a6e48be6521ccae7490783ce35b4dbd9149f7cae68e4393f1228349e5753edd81e312eb8977c76862998ffa17d4916eaf6255d7475a59295f556341172691636dd1c9b4fda570b4341f4e06256151c4a090e015df91c3ffa9a1de01a0b6460849bfbfa972640e94dfe8ee133fbca859bf4c3ad804893b4662a36463894433bfa6f4a4f734bc7c4116cb8c35797e7f6670521bea96415f25f90d399530f5f34db56643d12b9bd4cd4fa837d9c726c1ca3f07e3ed3a543b7b375303eb46b582381f29dffa82eb01a42c06533429168afcb1fc227955b19f1df985a8a0279db74b10ed4c6f9e458421f0bac28b4fad71f1d7244f0baf402ab1e8fbaa346c5c1ce85ecac4329fd0fc8a9166fbcdeb0891289ba36c1b988c678e9f746d16a8a80d6fb524df011a5fe26d217c13d06ad85a0c0230249c2f358a9d34c8f9af5e4f127c316bba9a0a78017e2932dfc70b2e3bde74809a0b6e3a6a0b324fe3a1c98821ce21d76545a3cf43734eceb54d85d23f0b3334b6218c65ca7a6f94071e08a971625a9315b12d3492037129d541a6599d418ce66da52481362e086576c7e23cd6a73479b5e5949c1def5ecd7d92adec9bbbf4c69ccb01ecacbc7ace046432d4d273f34514c87a5c41e2d56f0e0da27247516c72c7aea69712e251bb2319f70d93d68a21628e9c412ac5de5eb7d99dcbd5c6d846dd602d2faec81b77fb405198f767cf27d96a86f1c04eeae14a328c06ef8b3c15b2f0b1ae2bb9a72b14cad4151565e99ea4a64ee69c605fd5087f5d5301d4fa6bd4dc89dac5b3dd6b06c0cd001993d74eb238c4741e1fdcce43a5b39aa35f2e01d180dfaffebba22645540ba08bd7f967f56e77bf250acb5521cbad3b08b782e996bae680a7ed7ec3a88a1c2b4542d46d3b025b1321df4c1d67d3eebabc81f2a069450fea66a73bb427a2b484a6d2b6b6772328c972892dbe866643e1ae38feaee9e9f6670a5be336eebcd09f51a78ccceb2c44027aff04ab5500a1364e3bdaba93728b939021709dc0deab71ccfe566a880a1edb3b3e4d74565a21fc70b46db834c8001d6e42f71d1fed4721a34f341d2768ef4a9dc380a691aa3fc0575ba38483fbc080836a86ff4d837d73e3bf02537f27399752753c230ef1910dbd710282f97995245e529a650ffe88b86d1bb0b70320102b876055b50af2954a52925772db0d808a98645598e9ce9c74cc94446926ea3722dfaef1192b1a7b7d779f0936bc8a93dc56cee7d7ce252564801f73c2383b7c5a70b2ea533f70a8f6fedce46e092bececbd01a82c0b0ebc739948fcab2c584b8996131e786887a7acd02dc8ada04040b343987f0980f36e5b8d679067f814f054f2afd724e3b78fee5393df3629601a9ccf81f445eee81f481e62e6fc65f6d30db3da80f9966dfcfe868c2e9e1aa863793063050bf728a1883ae4eadbaa2ac99acbbea04ae9ea0b4a7d4cccd4e1f41d9288a003d926fe5ae860ee1ba0d93412420cf2f38d8a9abeb42cbab65dd54f201b24251eb94d1f4ff67a4331c15ec45bfff1008403ff48f1cda4abbb5f9ed220e7a28e66daadd15ef0bd73fd62afa9ed6caf4c760fef94733e308733f7dfae3a323e2a251b66967ccb11c09f103424dc825cc6326f9a8f24f64a35d111cae0f1c631b2572f260e0c54fa2d1c828b6d833bb008f137b59ea7a3423843e856e623606580064d857d20571e4007d344de4ee469a49fe7b2604062485138255afcf42d80e7ad3d56f8125d34442ae9393f7b5986b16e4f6cfd103551b154f2935226b228f939c5f393df2543ba40dc34de3552e38287f1958c330a7d3cb207f5d097f206fccb52fd84f0542550747d3f57740eb831880701997356228c793dcd38224967eaecbc80f89771987c62caaf27fb21b69fb8c954ccbc978e8a0327d50a191f1f1e5f3f211d83a1cd4fbed9616eb2ab741ab1e7982659a7e894f4070588b54cd4c24f432b68770afe188a131727d1f2aa4c947e764327057855f4e58897ee7665714efe571cb59f30ec62711f9f6aa8cc643b05ca2635b986e40f476f55cf7680991a00787eb4be457f3b0d4892f37806425e7770849950bfda2eca04a5f1ecf17f44798316ef788bfbb35784b699f5367615add910509f34aba278a169fa4528bd21940597ae1f8ad68f244afa7001cf93fa0be3e8086d4d33717ce2e66d2d400bbec9fee989471d84ed72c0685818dd11c86c4a2baa87cbc758696e74b52f3ec78d48e0f59e6e2ce5ae15fc59f4ed9f36749fc9a40d9479409a9196f7ac1dc72fe12a73756dc12e6c048fbcf60d5c71d4c3d17d665193e35aef09198cdb43ffafc173c2ebc7d1b0356434ebf6a21d54b8a1bb9ca8762c45cca74311b66a346fd1587ae111c0f46e77c370e3ab606c2ae00185911d8840d5d85c7719de16a1bb58cdbbd115f69fdc107145a3bbbf401430d69e0b6f38a77cce744ef05530c34b19a80e8cb8c7d1b637d2f1ddead09dcde949cad11226e7b5dbc8f81635deccad10c69884549f00e5146e3dd1d9736775364da93648353b53b4e7f139dab69288b67b09e92af8eb10b639e58c4d7d9e751649e6e422140b1d1518d924d949d8f589cf47affbb8cb9c55d4c8606d85981243d2b508da3feba422cf2ea1cafdff1506e24b4fdd8def4abaab4f7aa2117b9728c3d5047cd14aaa05762753f97dd662e8e40f577149461ff22172376c2a7dfd4afff47ee501b05e2ada88a80997317cd43a5ae0b09535f623f229ea978037348c3d539a921d8ea82df1abf3c0fc5cdb2d516b89e02e8d972d99991fb6fbb31c5936aa48482fac30f36ab14fa388928660f46b8300ccbeabd6e972e44a79918d0a276ee36860b55fa40fa3d6ac103d2c2dda447661c287d9d5e655e40c92eadc6eebcb67c6d4408cdf26e8e91467c36c6de6382d115f929c39bfea193867342ab44846fcb246ee8a4a47f450e54bc92af3b6a0f678e5ec5f45c5249b18ef6e3c2b8d1f8dcc841c2ac0ad4bfa1a7c57e12de88418955c45248256b38d3fa18d27b40b517f202f9ffc21418a32e5425a49f22075f7817b1741b8c5407d7713ddcd06f114f3a8afca745e763c29cd9f87ed06b8ebd31fd128689f18b0f41df19bf14f9dea8c2fb5d6ee5245f3a0f46d781011dc0df88f5a63242dcede244ccb0f83e54c1e327fee5962e98839591a2cecfdbeffd7ee23abbb54deb7b0aa476753a1adde6a9fffea6a6c6fc8320a49a43a6f5a5cf874fdeac0f4f8921a026ff1aae48bc1fd14cb1040a7d30466e0e1f4df19b82bf92e92ce8d77ae38c9cb92f36916a6e0aa39075cb0f27ebf4e6edcd94d6833c5e2fb07fda9e2850d5fcc6031a2eb4a6d77173e5f49e5ec15c21dc6398b17df6ec0f39d6fee69f2a658ebaec29a95104eed3810075821d8a870d41c2217e638ceaadb49a517bcc5ce751a6848562a38d100961e657b6c8c2ea3c254f81c500c1f043e322f61c5649ee3e095f7553ac7c91cc78076b56058ddc3189054dc0ce6c69c63805c60ccf343651c47af31f977909991e0661ff55d7827ca5d6eee18a61d3b80f9a2761d59a7a78ae370143ab4504c77b81ef6103f244132680e964bfd8c5bf3cfa267a1cede7f367d4d276bba93a13d69fe3140f6728448cf886e32c39c58c1b0c6e5ecaf40094bddb9033b7807915b995cb7daa8819ec892e8dc0f6fb213c633a8a7ab38915c97aa2bf73100af8324dc3799dffe6cee56ec3fe1d78df08bae88c3b7aa7f306931a6f7de36ed74bf1ca59d7d7387ea9f3da1029f9a0f36cd732e72af05b7e3ed803a7efcba55797414ce504148a728d76b855d4d6243841b1f32d2c6aa68ac92664acbb1b4bed810ba1d7efe2112aa1ccde622d06e9217ed618b38a028bbb2c7baa1ce4780e4e9b9a6b6584a8806a094d5bd0e5c37b6331a32ae922dcb6e604145f68e1e86eeac81563d8c3a1df38d42cb3a7496239e50f8228e2b1b39c02209b879c87926be8f16aed0ee6c6d11575faa1be8c969df284dde83c5d9e66694ccf5b2274fb24e232978b9ba19522ec471f5b4c05cb28bcab4c28a95334ef193a8d4058bb21e1b2d476cef8fc5179332bc09da664b08f4f111f4c0a306cc121bd05245c9553b721c58f3e17fd1dde540f3bc9d572d4ffa1b5cf78ca5cad00b4b6db70e4254208c6c78543ad7fbb8dfb770755c30efee90971718002de252c2d69cfa25d2d678bca7de4e51cf57135da2ae98c6cf38dc6c4f7306f43a9ba5a9408382552b6c55e9d50c44d21a4d1952dfd8c9cc87a177127f610788533586bb427f8f4bedd9b9f7e15116999e2945ab0ed2a994a04243d7841db3d0699256aabf3d9596b88149277b044d3ef87f89050253eb5d03e9d6de7e85dda9b8568cbbf6f07a10cb2713bb55e6bf46906736472523c5c3f2740f3b840cddbb12070cbe7d6176a57857f4a30d6a3a4165cab4624390436a001631cae814dfebc95723686dd25d45dc530b602ab2091daa2b3c5d4686031d9258d8b851beef752bc0a96a3bc6a13199283c2d575780e06f058e36f505bf6a3fd1dc36224ef129ef2e54630b838a7a3cd43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
