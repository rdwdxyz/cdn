<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e4633b513ef1d63f6970deec14a22bb9434247be4c583e0ab435015e76ece2f1f854ac0cf1eb85c38836a4ced49afbd59fce6c662c0db8897a0ee101cfd2f0a25baf9fc6e84e8bbef47d36f6e65278c4031c6d358d504babf883dca00e39c97a4e4c5cc163abc66c3d899f49145a563756eba7312198d5f48ecc5b6fa94d8d50f81dd4c148964ebfb3fceee55adeb6f15ed9880c779bc5527929a6ce3d4553d4fb0eacbbd8a6d8106c5abe4ce1493eeefeee1471999e89a90008d5174744618663e25eb854b644e02301599e4fa3f30681f2c961bbcfd742627ca127bdf56ebc15c4da1a860fee9a20cf9825e1f57401a925933e11653a2a4117a7091d9f70f260e86dc2c4f51ad179a488150c2682f1ea5e296e10a7c18e013d7b64857001d3c142bc5ca595b861592ec46018dd5d4ab362a160e16b27a364409dfb3be107d52c4baf3cc742dd8575246481070ad90d14b6c080f8d84138695ee5fd7ffcfaef7d1c32d6323a0fef33398848eb5c7f7b6ffb3c75f508744abae91ed15cd26746b6aa9ef028688e628bbeaea9e23c5af5fdad03510c832584db481a21a71d2954a826a5e13eef273e5fdf69f3e39c4f210d5a33f8e3248c54843df02870f0fb8b04fd0c281e856baf9708252916ea87018e5a328ad840f5bbc2ab8817d2e8171dccdd083f3882611b2d66971746eeacadf9f5c167e2f9df2be5630ce2383fa45a86ec470fb7475d8caab45870a44e09c0ad4fd5dea611d52b85eacc77833633c2dce9bf597e5bbda4cd7aeedcf32fca638a5f5923ab6eabf35a1cbcc0e205e8acca215a92c3ad82defbaf33d1b2554ce3b0e0487e6312c219accdf460657408a4b206ff765e586ca0419cad8a310b83a3d41508e74c6900b5e994c840d10670f99669f78bcd804ca71fc1fad8e9dbead50229d8f7a39f7e801b0d60239d77572ddf708444c26dd1c2eaa58e2b07e2a74dad2ab2e66c975b77f7c58b79eb21b895a71ee62767dd250d6d776aa0797808e82505705a89715352298dad8562957b17958147165fa46e11b0f05be5a47b0e84430ee0d6a963048c29b8a05eb00dab4a2a6d11918cbfa454b19df8f3e851ade7c89861bbdb4edba0c81cdc5b044415c1e551402c7996c5f4071e5cc8b62ae33dee20ba338080f828b6267bacb23366e229aa1cee481ebd5aff56998f28bac1a8e11188a953037e093bfa5b4ec86469fc23a651f26cba24deb65a47a3fa14d61d89c7e0affe6775ebcb94d22a53b3ebb891cb92bc9da6667b529282f1bf1504c8fd397d86d1ed02bde7c619f00c1c5af247c4606f8f634c56f7bd591f8bafa3f45f5fa56af2429dd6245cfe0297f0df2adc099b4cb84f9422168ee2338ea1e3b598fc58dfe19eb98308638927f70ef03fb035eb815694ed8650efdd292df12d7821b8562e564fa71a306a2f9bd629de827ce6ab537401a840539c132d1853b0e318ff91edd0cf1b8ed2df75a82911369ac94cdced4b8e02a65d8addbeb742dfa2d027a3d0a7d760a39e37ac7e6c15a7a104c8987909fe8a526604bff85a1856af94ce945d5ab1bab44c28f4f4155f8d3a1fc3c6dc93d6d63703e620df2caea5db89a708b31942c55839e52049a62b04fb8d1d5d6bac56148665ea5f7f83f12702371a28013cddbf84f71850a8aa801edcc2ba2b112d4cfd886dd8a13d90886180f8af33f56963112f83d6b7dcbd4d8f55ddb2e913b22ce8767b5daef9187d8c148acf14d86ec076b30488585d9afde045e9c8ca97ad156b016c5d95e2a8e57287d8270444506fcecdd06ee898d34c6ae0aa146b670216a403af160a4e05c923c9283a2386a6e20c0e55d9f3a424053ae590f548cdbaf15736e38a0ec0b239781b2417e8572f11148bcef9e223b6a9bcc0c908bac6ee06027fbec8c05bdc7148ae0b77c8d1adbd15f1668160a604862e43bfa3298f31b0a9969ccb18e6baa49f2ea51a3aba12ae54ef67ddcbe58dc8351a61f400df9bfae713b09357170b41b4fc5b8ee894c35958c886f511fa9d1c93dc5cf5f5bc94627be0f8b86e38a05eeca4cb94e77ac4eefcae900a21253b86c76a52fcbc6d4d46ed4d9e2d8a752c2d1e245dda1e64049c0d3642b43d3f3230f74e8fe48c8b8f171023ba303597b620f2d79d43d7ed6755fa64506520744ec0fd3ab3814d4fb28ae51bcbfa008bca36f0cdc6148c9912dbfa07e5e4d47ca1ad1851e0a86dcd7cab0ab396a927577d9e99146058a2d484d7af1bd3303f2f516f4879aefed6799ff9b494d6fa6f7a9a831ced13e7f54e308935234fd034789e745fbdd56ff57701b198a96797134cea94a6bd3a0a60136866abeae865bedaa37ab8f24b8f1a96a31e060cc74face3649f974b630c24d63bcce40ba0275a727465c5661d1f489339d6024c9d8e5cef05cf3c40abf2838674ce42f1b9cacf3abd202b2db88caf84f79f7221d7dc96b57e9f2cde9b2f4a9afef10e58b20f327f09dfb75fcd2ebad8b10cb4aa8990b6760cc77ab47eddb50b255aba4612fe8576353e82f484e79fe19823359205379096ef9127d240cbc462bee9b2bd4991e1e11783a244f7f5e8ff1224b3c38ceef37bb496e9fff95a7d6a929476907f127cdf1231b901b88ad3524891e7b1d7c5c9175a97c9640308e5e4a573bcd46e6f1860ad37ca5a2b985fee703c438e30268a802c9e567aaf35e01d8306fce9b95a5a49a35ee17bd9f508cb7ae09f211ea993a77a8bc1b161526261b85b6cc8cfb4d4f49f9ad95a35e767c0b6994764d4ea3f0419b6481b2f827efd7d4d95a565d3b7b5d2e0d716e565e182acb4cb787bfd119595c23fecbc960a7fb69a42773aa5fac6edfca70124d5f56c436da334e949941a1080f1757502fa5674102c319bbdadffe20fa5baa34faa91a4cc5d02603ec6b393d0351f6067e7edc6a5c121d7866821f8ff716730c4c595b8947116ddb19ab818fc2e7026a9c3ae982d273a1c47f6b7e64aef8b3690ca79a88db5fd236269bc70dd9a805f581bdcc621811bbba8600834b87493bb30806a12f3de1139df38a26a8a94bc01473cb276f646bad96c824fb461e688b26db688a3ad1d6a289c983c9edeb34a4455ef65b06eff384a9fe69d6cb656e3404461799348c1fd42c230409ea5c8201f14d7a01c389a60821ad44eec9095decaf5fa7b658799bc220d2e720ffdf28b566905ddc918019905d726800323c888b1514f2e18dba9a46e067718f19518854d67c481a8444f6979477e687802a3e36ae960dbb22e3798d79fb919061cf46515c9d1f6e5b7977f47ca32892a50338b8d346b7df8337d48b9a653975f35cd7353fb00dcaf5bf61134a7ef91c39dc2a258d7f745435c174046db82f216dcf1b3fa4de9c6630ea845f03fe78c4d2667028510643263b3351e76c1b0a173d6508ec63c6c5b8db53a48c94b9354478024c8ac0aabc6b68fcb84e1109f786eed80e3d2c23c72334d1f32585092fb8c46810bbb1fb6240c237dbdbada3dcbc067ef630938000a6e1d1a555675889af024612c4a4b1816a4239a5575a5a9a65cc14ede29dcbc8308c3260969efc1028e197a68c0b5165f439c2a31e0a1ddda631406f885cec4cc3477163782bfdf24483a3db93a1753f5f41b0007918c85a186bfaf8d6bc540470c94673cb3a2344234f811778f2f99b5286e5a1afd462be9378b67fa125527345855a807eab84d57208877a4b8971bc789126c165e9de8794f6d9be191086b5a2857baf802932695012207b4e94201e31f6449f8bc451f1e27b5d00823b14610f146da50320a9ddb421edc642a6d29c856861a5d11d50293fbd2c189a1d7357b556c421a88fa20a7262b2e36afa6ce69c43feeb2a873abc9e0594f757f4c57a4d5cbf6c214e70dd0eced83a52bd2d8b91d54053b7300976714810008bb833c6155d98b77d65f7e50dbcb804e8c6b2b194977c9268ed31ef894270c30de7b75b2d996f5bc2c0f15f37128bec03c997fd01da9ceed331ad1a336657bf5e5fc9019253eda2b37b8a3f5a22810c8cc03d50eab96e9a799e043922f1b5dcb921226e279e5a96ab34f6f8c5ad273889ee0a911302819c556da1de1538ea6382951e397632e2bc1d861769deb9cf6415dbda0f3a2b5240045537e1e3817765c57fe784160bbcf525d52f83453d553e46e49080e2c8d8e5b549072bc7e73ee38fd6e42ba423b83abafc796f09d3f5b84a5d7d59da59b7f7a5520857ceeb08afce525459e6e2a9d63026f01bc9a68db6823c07d6cf1d80f9f418e18c27de7c3e056736af6f697031bae946df0675e821c4e6b6bb6a3ab3daa679c1a9d78578b44afd85e556f94596dbc4420182fa1df397764ab8c8c607cda312cba9a273d23f320e7c711cffe1db8fe4e5c488eb1f60935ab4e467d463d1d0e268e3ee6d6d4a8d8c606d4ca5d756fe22d47c6bb454d0a9b2c5d109b0c6c4025f9ea35362ff9efd8033445ba0d6ff9ab26bd17777bfc1fa80ea216816e8e2c37b8c850233c48359e368c31f370465856067a6f8642902049ec2cf66b17360083cdbd605c6d11f66a36e59a668ac9efc4317f6f6876f6b6ec619b3a27c9eddb34a495a93611b2cc771fc9c6025f87f36a98247b9a40c3a9d329e3426642d6c5219807935196a443a87a9ae88daa078c14a1373d31a7b8d0771081392fa8841d1e94cdf51f356e5c04c0ca8351ec88dc1da37670f06a4b77f678127e4db3bd41a7dabd30494be22522e9ba8d34e84f7d4f303dca5fc747f3d74fbb0a33d553f46b71c2a353f85f1b34a6e7f62bd3952e31aa59bb6990db16f43e6866fbe97c7522b7b993ea38f81107609c8a6d039b030ca595f4b9dce00b4ff4e5de7991fbf38cbd8c2538b1e385ef7ded3a4b43b7ab7eb9d32ab4ddf690d0f558e63745ac7c03069250703365b57d1b7589e5543994ac11aa1c52b00c8de184aded5a6f5ca5f128b3219b4257116a2578c6151648d3800038c415868eb401c3710fe53cdabca2d18bff0602b98d27e9dbfcf49d6e9739d2234d104adec8aaf33c99aedaa63035ef97b6786e7082c113fddf24d31a0100aa057805bdfc59cb7909c330d4da69e37df611b83f0361b49bd7b2c30f56d368f5cfd434ce23b59e91394381c422f87fd16b06621739072d5639d86c4f8f47a5b86d4397394faeca2b57a02e32223ff0061efa63c3552fb96644f624789e83d79fe8885318782473b3e7e6700fea2b5864bbb98469f33af219013b63faaca8222c2da2a968d515cdd9333ba787ecc3ca286e0c3176dcf8722448b0799c5068de19bb158eae737d8746b479cfb368386189822bcca217c642e9648a6ecc32fdef5d38c57f8f41978b6c89b857c58d9cbd7d87c0be55dc5cca565a157d2426a352e2e9bcf92f835018cfe84fe2cbcf4ea713d77c05e94a562965fd7403321bce401eaf2acdeb21e51bf507398184b4712f6e518bec0b93c49cfef28f256e55fc7cde7075a60aad89788d92962d67345bb22245dd2ed2123f9d8a784a3d61198d180687067f9d0cac4cf40d3d4eeb3e3d1e9bf6713444364507077e33db4e5de1f6f7664a30b4a26797498fc43c3fcc66ba308f0ce985600f80648f560b0a9236e80a3992277bfb7430b138ffa8c47938bde16b3c125e8ad107e87c3fd9c6bb7f2fb58e197a9970087e06ef820e33165a0ba211b9daf8ce2fbc69af17b10820f2cf6fde55392178bbf7c33d5fea0eb8c7751ff84eb106bc17d8ff9652c4e03b182ee844e9335a7de8a35475be6d109e1ecbfb62c987ef6345b15e354db723145f00dbd567174349d5d817e2ca0259f008a118316ddb839a03becec4e988f25d088ffa8295ca43d7fca2f555d11d2733f027812fff30dcd20b34508abffbfaab9664d98d3745dbd79faf5774ddad347b72a99a8a8d342c093aca9c9c861841647667434624706a1e4f7b62e1f3df9f0e86c98abdf30f0e30ff30b67a6c2619d5a8da0c2d52133baa3d3fdb1c5727c16e083aa8cfbbcbb25be2d757f9555a8fb5fe4039411ed0bf503ff94bf5b447776108ac2b7666988aa2c89fbec49128a1871291e7325791ea9dc0a9ee7c3d336e958c808eefd5ee28640bffce6de619d05a121ff09dbc07fc389bc36a37337f7a25591d0e0beb470a8d9df1018255b204637436fa24bc7b02d432cb4d53f551c7a5660ddf8c9ebd3f00dd0b9b581279142e9f856ab0576c163f6632dcb8b09254c6b661b20b0dff8faed483cd2be6c974f9bcf14005572449f535f72ea833800ba334477fc5089f0b511612060ac8a390cbeb5636bb14a8ba22d61f1ee8017e9236b3714aa4afdad5d820d973c55509166c9dfc4ccba25516b8a016d5138f26c3f93adbd064959ad16081d7e48a25acca50ce44c5aae70fa6cff553f9464df23b2ec9de3a4a1fc6d3d16559a01c6512234beb81919cd8cda543ae9510d13c74007b022f3be64787b04a49341895a2c5dfbbe274e5d978572c8a3ad3a8d76284fea666c7d78b62e8113d79322eb55c0fb3a11e6a6b329b534dc9728bc38a6915fc44a3531fa4f26860e90501be72ca3a0f6275f974c3ed0764ad67970ac20da7baa91859cc6c225567f9f0778c796f443b15fe5af6608f2f4564c07e7fac4a3d159547bcacd170f69760f3c800767673e1fc5980393cfab3dcb9a63ce6ee7679172371902f0fdb9833c9c11bdcb468326a414c57173dd5b98be01b5d7bd15aeb73dcdc752ad0b22a406e8b6432af2e9a7a5e69eb5d1f3852ecc21f287e4cf1613935161a2904b65bfe8883797e374102ee7a11bdd9bea079d1a141df42654cc0b0bcbd1d89bfd27ef471e3d8323768a27b2982b8207e6e299717f2c0dfa8440210d83849f30dcb473777279907e2f929e87bf3deee1aa3c015df072dca9923734ed5a060ddb93a114c30798b767b2560a9641e58d6aaf313facdae46d240ab6e788cb9fb56789d3e4a8dc7d2e0970ec8f68fab07379b3c9a70a255a121b419f4afd17e5d50a4836095f003a1caee749ab33b1ff9a5752246395a0575702e8fc76f8f54e6675ed2340460dfa9415184f235e3be4be89a61d50cc3d26c93b40992722cb3a1900f809809c482368d1b4dcdb4d7d9f76c0c711819497ff6b4eb896f736150b7db2ee9c19fb9c95cfa66cc6243b6c158d27f35b6aa6cf26d89e887a89fdc75069570d9071a9e1d2b393db1ff407cdc6c33f7b0b4501f52707f5c6024c0ebaf5a5d4434010d4dfe288e0aab5bd5a4b9a8bbc86e77706e839bf05568ec088bb32d9046fb4aa86babf55502f1aeaae843fa1419222522fe03d5cec066710559f5631ba41eae2b4a7a6e0a764c68fb0cdd00ce8bbf5a743c126df9ac2344522f1ec60d8d5af99c2e2ba18a082bf601fd22b737718f324ddc07b2d3e0c309ff137a08f1c667cc6b5e85b77dc86473842ada3b268ab8b18d91ec0fa426719bfcc34a0ec359c2034ebc3e514d0f972cfd277fa1f5158eedbda6d7ef72632521f4ba74429d9db28d0e87ad8e8dd1f6d40d460a8b30c5081dfb0874c7011eac2e32e6dd31deac51818c636ac36707cbf3503a2b3f14b0411bcd2c36ffe2036c49c4ca244c656b0d557425ec446c5034d3dbf04d83787a33da5c0956dfe06efe6e4b1f9a8a4a62d38279f1acfee9b07e2771f142765a33c41b0bf0abf886d69e9c6fc7183b7b84cdcfc85d1f746ce8e6143c63e56288438b09edfc73ff35064a45ff45a289b5bfef372e76849a68bae6fdc3a3cbb7ba0549353804b908ba95a094778e830f687e6a3bf30dc09f93bbea335d33be0eb4992d6e8e9fee288b4d05a8af690f22a26f057ee3bc6a825a1b0c5327334a59524422552de0bb218d01d11108449129ebbe6d6d514097541888411d1cbed2f974e0a0a849499a68b0d61a3df3084beb9e12f5000a74d908d109dd9aa2f05472ec989dce601ffa2ba9b7748dee1741e431cf2a374242cf17973ba0795389bb02fcffacb76f46e3cf51816e350f4cb560367e973d30a6a96e36b52489e92ac8acde13aef26ae7a7f4fb6d83e07a2f22364129ace2237fc4d66873c6c49b4d0859145b325043a50564b5f6ff302dd200372c08f2206de2efb5efce3c7c5bab227535291cf022d211408a829e734ea306a303663914108d5825e756e40f2a085e6f8cc399afe9e66991524e286a79121a30b58743b7adc64c2ac7b9db078593c6365caa7081874cb3725d86323783fe9ab3cc4c05247e0ee3ef62dd4c0f059cbcdffad9277905ea966678e3bd74b0a7f67d19a96a567204c3b95b4b4ffcafd968943c2fb3e4c063c3413702cafbe9d5a548be698965eb1cb60565897a1ee4887ed19c29f57661afd5cd38c2be09ff4da446b4a2c84ad8332a1292bce73e076b00a8cac2321647a213bcbcedea74465da9490153d400bea92039eb6803eda93f78a28f9cfb78999ab35dfeeb254e14d6f94c4f0a0dd25e4e2d54738d611c26138edfd0a23420e55a435266754e910d8bdf5d96847e72e3d1da13024d8b483db32ee27dda1d5bb41765a6b7e014aa1bd0728e791dc5b474ef3fcd808d2c154b09fc29b3ec5e899201546818e565713e9a250b347516ee941b6f04439e87e9a0fd2ef5e75cb870b1c0e0bd897b948692d0f2a3b17399856bea0827cd4dbddbdf8d3832fec3e8cf1e8424aa099f465a6551c87ed676143021dd65b9d36cb23f0253001a86dc5071c1b0a90ebaa3e56710eb67455e2eaa54e51530cdcd1a917accc791940f0e7023e787c2dee9fd896c4fdcc36363e545f14e3b62f64f943156a6895c6cd8c03bc26e95e9ec4986d66aaee1343f6c8c5a862d4ac15d1c878f78327bdc8924134849276cdfa990b1ad30ea9ac727969b3ecb18cfa894013839ec4deb5ed80a9c25e220f085b442cd0692493dcc8995aa0ed5a5374a0bc29914ccad9de366fa1cc214659f9813b34991784d3306de4cc78b377cbc68d623b5b3cee1eed43dc19d6700dfd88ca27624d6569403a282c796cc5119229e8bc54f83cd25d48d7caa38210844149f54361eff00c3464b8fe32fd88e90fc33e7d4c1ecd45634bc2c5b151954f61b886acfc173b8ceb13beb4fe3555fee1d9f1d41be0b5c9cb6351ff20723eb3ad4a8e44f72e232b22215089060d952dcda44e6f2304601dd50054af9982fad538f7df0bce0adae289fccc99cb370c82b95c1ee879bb5eb43823980d3ae904f86ec9d6b1de3b259350a4533c7b13b7e47a4527753ec9e8cec402c56b583c106cd9373b780f93146812c8ce6a431659724dd9ec78a66302029fac08341dc4c3ad0b7a204b82fd1f7f5e871e5648b9998cf8acdc0ea987f2bc24a62209821684d34f12384a2b5dc2d76d9285a632a67f8cebd7aa05eba577a0ff998494f3ce135a1dc25da65188091a50d8485bdb15d09d19444e2821c6cd1c94f048dd7cb5d67abfecfd55d271e790a3799a599f991ade0558b0b021b2244335a564f50975a10a6a91d297b4ef1debe29284ced339f11e05c51abe33734e5cf5ca6b3a7622dbae4b225ef5fa7fbb2bf7bf389f7e3b9f5ae0c96b48fa430bd5a924080be4c06e8a934de713dc88cbf1230f329794de0a5df5b63fcecdb2578c3b9c7054db5b7dd432aefcdbe8d54ee35ee45cfef4c70737a25ea8c0b72bbe75506b52f7488327de9bd2bf53087be62294ba7ed7b396c214d41f7caa6a50522cdaa308334d8e015839d16cb180b80018e049eba77773d7bdd04bc35b144455aaad1b54ee14e257d94fd082dad0f71a6171adccfb9c94ebc64a370b462fa59428a35c26f41d70e27090ee4cae957fb33b2cf58094ebcb342e99307f508aeec56b0693ecddfc9c07304ab75820d2db9c8253a9ec6b3f3e6b01cf774391f09ce4013e473eabf1b315f0e264f244713afcff837c94fc85214a2191873bf3a08f95872b0467cabedae9dddab614dbad20c4981b4943b9275dca4c16d9376337dd23ce45b7d6a2a34c9df1b3577bacc4e71c3052aea07bbf9cd30cbecc6fe6dafe503d0f34878a8fda5f8ef400d5b1758e46862f618900cf6fc6304e4c26406627aee21bdf181d9f4832554857334acbff7613139627281b3fb8451ad52ec5d0da783fcbaf8bcc1fcce9fdbf75604c41eb9c3d85dc1be0224b3a9e9be226920dbc3b17a671d7357bb39ff3376802da644481138e3bc2e80eb9d1789fb035ed28bff5829d7f8d72bfe497b7ff43e6cd7b0e81b8e1069d00e84153637914007b67015d605b46af893fe03391685b613faa39b31647bcab9122e97f1335f040f488e9ea936e59b03488c0736e576419892df15228703d984e24836c8a84b4d4a104d5e4f198ce588e25854d1719cec2e8a460a3d9ea473886a68bd90a3b64113946be4d39732b5b40b5fa17070ffd765c1187f04ffda3a5d60ab8513630f1d5fc71a486d5dc04dc18e7f27b6aec636dec4661b7e60c48fbd2a96afd95b94410db778ecaf727ec5594517c287c6868245620d21ed915af0ca6e01eb52af27344bc629aae08ba50542bb74da02082a12ccdeb51165421f68944453c96b709b49e72815f481ca47caaab5d5296b80adcc5d9817d908a9518665db5b860c642d76a17f25d3353e66a0244912367f923e86b6eb0241dfbe7ad4ffe45b4062a51d108df045462c01f186cdadc321ccba19a1ec37bd1c66fc5fff28c8db4356aa6d2c88f91847e9a04e33467605689543ecff0819e8ad49d5028ee9666b537ebc7e7f99066cda8041f8b4d86d62bd80da65ba4c65ac9170cf4c0cef5e5643ed0ce35e968d721d03c23d298f75a077fbc7a13fe1a8cb082731e3af23994f95faab4525422d45800520ec00b3312f1f4f4e12d18316ac549a86fb506fd604b19ceb8a9f9c9aa4985dbcf429ddd2fdcd93df06341a811f9b5bd8e6f3582659e55e9ebe7693d2c3cc0c4a536e56046486969906c7e837918f3df79beeec62715738475c5b535bb8ecb034f8cc938f3d1757fed1a428fcdd727033216c5bd24f8a7b2da067f427ca92fcb83de896525f98bf4d221f2a092d46fc4633c18735eba77762684a6dda232204abc56b915d059f9f2d0d4b7d22bdf99ec196e08d81e9dd0372608597640fdc72ba4f20b2c384fca7c61ad548ef9a5acd3f066d2452f85069b4eaafe0b3c4ae9362e054780c96fff4b0e7a1327059fea727e9b8dd7248707ede60407e611958ba2299b9fa68843fb4014f03f7760539e2cf02af72270a0affb7c1482ad4669d3e0d34e19a7308c0610e7f742d2016d26f2a04f10ee7569a985e847213d70a3f65d81fcb0fd1a011bedc9f1ede145502bb96050d0b911f59678a19d6dd5f5891979e95ba1080b53ec91db8a2879d9aebfd36fcf9a867dc0305f051b495996de3687ea2584e09b2a8a7e5fec00f40c9eace64a9abf511b697bccccebeee10931ba8e48a76d767c520204be67b952ae3c90bb1889c7fd4300a0030d07b04e71ba800f720e45c87dbb05a3f9db2cc02806de82e2fd4bf9198614bedcc994a8fae0d408f7e29d434d8d10924561ea9136128bf73c337d41812f3be7695ee902fc5741f09928af8e05cf7833cfd7629314c4757e87d9b3242d5f37fc262efe162ccc60da54910fb74aaa47a429681389cfa96844abc2bbed4c9252007aba3bd35c1ccbfba823fe25a9d4301b0617ff8cbff50f72cfd948eff02cd2d52c3b2ce6f238bafce6433f86c61cfdd964d80731c657dca294dbbb53a6cf144b42d3dc9f973a329bd5c7a62c067aae3387a34e153578729e688d28e43e5b8d5b4c624433c269e73389f6f8cab8d5de523a7ad3fd07f26e7d5b783d3117f428776d01296916a754e6187968aa58fd76839780c3dce77f8f925c720a06eca62028ccd0af3b3ceaaa1ef39896f0a890074cd2bb53319bff3dcb9fb814abc4e0730a9e28274c376acb8f7a04242b781ee97d6a8a251a7c04b1d59013e7fd942449fb2ff8e25884af7f4212e7ca3f302f1583c310cfce7a3771e2f7ca2e16e843ccd520ec05612d6b307f172ee517191c6cda2426224e53711e34158ad747f518af6b1a91487a0de5498330ef4223d01466a471ff5fa37d1783017260d32c3f9c577fe6cde5f0e519665196a89b830caf2ba44c44e6eb8ca876d9e472ff4947747255bc515025a4b58d595868e360befb1a8c38fb696665e6557ffbdc154bb70a436c9e93903a4579562f599afe1a78223310945b901c22aaaf3241ffb9c5f8ed41e3736136ad78ba34d6aa64483b7928d0f823e7652dcd269adb1ab7af361ec0b924c17e87c5d70bd333843f051c668c9be4514f69b883598e8ff57bc3b4682b2d63c17f4bd9d51dfa4e0ad4ec76ed604faa2cfb30f2f0a20b785c85f4c8616029d00295d440c331b870dcb119e8b74ca7d59c429ed92629252f4a9f9fd0192876aecc03d35592ccdc75c1cee67d58fa263eb8f67d8f3ec4ba49664506f73c91428cdcf7684cdff02ec36ba78ed270fa89c2d57950a013964200a7a9d8d4f46d28c641f2de6e45a4e11f0f6ce7300c1f952ebaa86540a10232dfb4cc16931beddda4b0df250f66b2eeff0531bdaae009b8fa96c0a4862182834ac8d015644efeaa0602f0aa28ac733da9b28d58115f621e71d6cb64f43834aa5e68a207462fd62c486b821c5906cfa5951cf9e5965a3081842a20de65c2c2d4e0e4053c4096b7c7a5265ee2f72ad92423313a9fec4b22e03733f2edf8de4ef1f313098ba51b685dff9aca45baab28e3c673bcb41df9207cb046cec9497b57003e0ab815b1ee6e3b908ccd9290009bf7a9e8b1c01fa4a8f4e4394b6678a376f0f604e07f0e1e872bbfbc6297b27834290826730e89b00c325176a9d83d3d86aeb93b140a5075aaf689b3ad489a404eb2f3a27be2a23ae3f0c2f4d1976385b365b4846b0fbbb191ef6fee01d403c82734ea552638e66eba8f6b05ad609e6a1fd008bf23a97498680bcc9bbdc86dcd096ef80f91129474092a83d83d51c5ac013c911f5f9b48677ed63d2e62fed3c145e9f5f4256ef61df6db0239711fd0b745f40f9465c2a769891230f03321949c52e775cdb69c94066487c11981a6d62c8aecdfa8bb87b895bacfef52b42e60a0c9f6b9a9ad352cb8030644f3bba15012e95561c767209580961f759a104294f2ddd05d610e37b518acda00cb046ca898ff3b2794478d3bb7913ceead5cc1832e0159bca41e468d4a462c26f65149fd0421595be8470677098ee48fe1552cef2f49e1665d19b32705812918e8dd461a8e7fcb1d242f95a997f8dc71d0dcc454b4d926962d81bc52086f62223436d0e10a786f318c998ddbe95029887aa40a4fd0c07adf49d6d94a6fd578ffe3db332a80786f7122f3624d0d8a8742f23db2dd7759256607bcf37121741478e5153e60e203453194c2f7d956f1a8437dd550321c9ddacf06a22b9c4117ea38048ba1bcde6c4f9da6e0b710f75d2ab09488e5fc54e7a4a508107586bf6d7bff2382df776bfcd403e4f2c102582e19a65fa53826dbe441e46a2350f2ed52822e98e5b8b2aac6945ff6c4b7438fd3a9a44a65ab58bfe34d0764d8ac83fe1689db6cf42e57ef5eaff2348195a6bca6dc7fe56bee3a1fca33a8b0e0335294afb5cc9eb9b5d0192e788156460ab0705698e2144b80d5a008c87b4ac13b385d620c8c79533ccf9837669b0d30679517e16bf3fd8d5a554257ee60d96790756b39f412add4077eb6f1e356451857fe8c3b9152f115b26d8ee6d0508d6198e1a6d006914a810eea01155d56352c88f813efe2717d6b1a88348ffbaa33e2727c4af1e5ea581ce938672caa66bfd76f6d4be0784a33c8a0283734f8b32fff66cb95f44521dd0b93dabc6c20ce804a680c87407ac376642a42a00eee7a2083cf7ee862a8232cb5810d323db1a9ab06425d15694fb574e722d80c4c5337aec217cc47198218ab5a7698b2818f9b967bade24108b28421e1722ea94621bc33b99d71d67e60402b2303ce2a44e3d21d73c2cf0891ab1a5ddef2e7602dfb24e4cec86f2d9789a42756633d602a1fdf69fe93e8df57bc452a0845998c374d993dd9db3c4f2ce0308e376dba90688328f1bec2be4d9991976f8bf184775c7f2d2487bc604c0f5112aebe073998aae330ac0f318acddc344ed40ac2382ed3dc8e77ae1ef0f6f3e3349ff7ab5f784b2abe68d828229477d23877bf82908993acc6ef62480cc41e2e0de62217ce923396c19c6c3f84d112e7baecf2ac8715702ed795c226902a2f705e9c17cdf5aaaab449718f10220e4438c817fe48aa3d76b4f4c6f56806716b9c63df2beecdba532ba28b5d58dcc8fa7859377efd2bd857027f6ec86591b604a0a41f06ee42e588cb2c6069d7649a8fd223a275aa84cb15c39b7e2c8528875324b5fb6d04d9102c0d29072e1f78919f9347f699ed1791424ae29c79e9c7163ca24fa990633f22cdf0087d273afa2ec78a403fb135f28c71a4d9e714ae04c45f94e0eb553409d0929f51400a511db400f609b86c963fddce5e02b244fe64b6d86065473a34fd1b95e515bd3991883e6ae27a3b164f546fcf45949617d321d143757556ff512b7d255b684b80f41f2392220a7546525ea1feed2efd011b1df0c173e4258a6f23c6d4b57bfeee1bdcef5a5be50ed12c0def033f01224fd16dd8f46a17f3d4093e0875c1b60f135876eeea99d5b3f146445eb77fbb1f78c8ec8ddb72709ca62d6b441a8861d9efd9f78c55bd0c57cc098110c85429148f91ca1d6374b8b86967d50501a1046268f28e4b4b6a3acbf1c8e940c42148e3d5aaef3079b923ef355aab7b4232f6c6c4b2f9b16c8c10c6161a46bc6cfe597305d11fc28a499d690c2cc7e0103dd1ec8ec303aa4cf92eaab6f4bb5d0ad556f24ef893868674c7e18f91c96e11036b1dabec0ab9e9bdf5b6ad719037f15bca4ff3c7ecd8ed9ade46dbde2287e79f13fa5d31f6a56a5e9354164d9af1ed1f7c006f9f5fe2f6d2ab8815621e093d9643bc5465655af3953cda8b8b6d930c115af55c758781bc6d3f2cfdbb9a011f3ccc7f0a26f650b8ed5fd4ab72fa32de74a353df03ae89fb0eaef312817f7bc206e2dbb0d5b6881d1f421bcb187ed4619a84af6bc913c1122dcf3c5eb476519ca06c5dd5dc29dfdecf269d4c0368c95d72baaa45b6d8bb26be67bddcafd373f73fff04248db17204256fbb4f7b82c5c51915a5ed1c7b956fc578f96759bd491f088d2da465585e07a8d7cd7d5369a4f34c97e1e1feaf8999d0b4f130de23572d487bf4e5ccdb7002ad7f136ea2ae6005d324bc461ecb4e8e66390356e73402b6625cb7368143cb658f3ad74ea898a5620dc8ea988687548cc62ea400aa8455e578c9080917b7e88626fe0691676333d41243263de82c436d92515a1171dd6c2d67a2e134b666bf8d3a10a72c3e14e32c94b90340acd8135a2be29a58a0d2483d713ebeb12941ffcbc2bf9168e0550721ae2a620dcb50f4f821247d920cf76136ff6e6f44970446c935dc25dd10118ebd533aa379df40889ec993cc97c5560529c71e6543bf5a5c447ae9136da6cca1c0366eb2ba6d71b103792adea0eac3d7e60f002564ca124ac6ff170e1ad954d43f9ef6a0e7adc4c341e573a479fa220d51bee6571e317b2bcabf9608cafbda0a7f2022a66409cac63c28ce074c6eb1604c1574f48ca5759457e28de250e4ecde9f1fe44aac0ed4bb9a5b34366882f0cc3dde41ebf99bde4e8a017b998dfca9c28b3fe636b7b15687477db36f12dc062e6d2c1da5af904760f4ccacaaa6125a7657e8c8c9645f6a78bf8094629f7a485cbfde70076e1497cd0b2aea9e05ef419535b5daad1e6e10cf22f7492e68aef1ba3a7fd4c0489f51906e132de6fb1c5a405dbb5111eed64e18c398d1e60c58470553c2e60003087f2819057cb0c7adf665cc2e045c38773fa32e50e896147020ffe2b27c607cab1abf5ca0e15db0160a1d18084401098f8b530307340259157b06929bf4f1bc58229f6ac97ca7e10ed0e3c8dadc07996372b0ea4f86dbcb2440d5266800698fea4eb93dec908e3908a3b86c13d5417cccbd494e2783dd85a3ec57922873d7030c864b6dd50100f6a502fde544a6687864e8f20d28472d31aa87b34d1a2968a7e21550d41c877ecb797290b1b2bf71449579982fcc0cc6f81fe50834d4af562317d85c9ab28c692169636ba5d9df378eeb4c0e5a0e8d95eda1b93099be6ead1c1ef429b694749b4388a5dfb60836e175e6370700e0309a5c6e85bca43f4a7df8e085612903f706d047a2573cc2ab6e7ac9f69186523e2aa808c70729922b18de62c430a02eb0b434c99a6501ce159eaeff1163f04a0bfe3e43d3b7cb9498ad77dd4b8961f61b9f63700ecbc81a305a80d423027067a3d7270f3fd6bd0b2a2d5c106db4beb0875c63152df65fd79c8f897add259640b5a8b8919a7866fb67fc9d01311005c1c92b141bf557aef6f3ad0d8453da6894acaca4d16ecea8edde52dec422bc2b15ba40e03d4f307333d8ae1ca2c1298542af62296db15f89a86f781d4343941926aa1de19f6dc584f10a8cdc27c833dfd91c647e26b63e8c37996a8ac04bd5302f5abb82582c7a7490f53a1ff15b0d850428b19a7afe767879112f4e7b71d37cebe0f3d0c8f85a1ca42beb312300de8a19b75df13c913f793e4114d1cb481bc8331078fe90feea7ac88485bfb2c1f6b26ad590edc62f6736069305ba0163c0b8c798fce86e172e78d444f920f8bb983139602a27d6d7f28af6d1dd087e9269b02d014f137d17b53c3d44031af303ca03080fb9fe9f300f9c33c7abb91a0624d35ed5b101abc8855321164328b5a5ad0590bef4c4bf8435a76b15cafbfba9940c730a1e208a126f4513a5dce569322bfb4d5f14bf15775497b1d0d2d89d729c7db0df45fa05e9606a77d772f5ce584e9352097d3592fca6642070de931e0a736d3e8ed551aeb4d67552eab39ca94bf8fdb6ce79771036951c24f279c7f40ad076c0c53bc1790fdb0033fe33d4544e3b34a78f95e9b6314308a059ff1a9d4013059263a5617f26d6e5f53777dbba9598b53760b222fca54a8a264fc1af9d9d4b32b47aeebaa15c00d0792d782ef1310f7689e4a6a9601f9d47b1ecb01fdf4702d1f91e19be85b8c0e74f2035433602cd3877d5e1247915d6e61402aaf9b47bdf7a773a70d37c8b84744ba4567765c598864dbf9b6dc220fa8eebc5a8f40bd3913f75472e1b2b35b79ea60aa54beb7641041c28cc3b37ef8776b238de175eb8d3af6a62bd768ae23efc797e940fe65a14d72aeda45dc7a1f88c138388bf79f0fa2bcb24bb4935605632397840d44cba3dcab0bd3f3beab8c9d94439cfd7bca64fa06477968fb6029f3d0fa43809ed2d3d4b395b103ac6654b18491911139aeb7c4908957fefc9e049016e1c886e879d78283d9d2f3aab14178c046242e277377a694e5c64a6406c6813e51b876eba9a5ecd5879eca193bd808f1ed274cf0b4eef3ab18160af348ae1575f0594e56ed92edf4a00a4291e89188473099a0ea26710542f3aa60299462f0f8bacae7bc1bb78962c0c7cf10b6c0da181eef15e31825b40c2373023bf40db344ff9bc82350f333d64aab351c808624f595909953fcf285e00c8ae15dc58443ba1f9d6362e0e82ff5f51bc2af3c6812446828de890bed241b2f9c2becdfd3d8dc2813d994b5ca039f83fb0921dd9ce398bf0c1ea5e43411be95d48f1f759d6540268b2a77acef4b4f321948601587f64fcea6346a60fb42d1ff9267243c9c0e290be23359592a8960d3e2fa0f8b70c6820dc77ba3166da51961b8cbf993cf9ec29a816d2c446d145acb24a13bcfb8df6cfb9f739a041f85e591d7550ab943be65763cdb04ac33fb201c623d30ffa9f7a460a5a248cf66471afd7f08e3111b808cc9e5cca35316b8187115ee596f03c1eae2aeba5e573c2360c020f4f291635273b41f9e9d315e753937e88fb30e57f3de9e5cba41c7733a60419ae2762a018f6e1f278f63577b84cb7d56c4db400ad515c27758e75e8b187e8c6fd1dd827817ddf1d0ca55b33f3b03753bac2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
