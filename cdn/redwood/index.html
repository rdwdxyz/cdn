<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a60819b86293013b5c038d3fc67292f11746d633dfa1c05c0eea23a39d8ada9f5e756478280fd3e345ffd72a3568e112eb4b30bb1c02d0a3fb273dff5ed1b374751231148df49217c5f504821bbba33291b444112c5df35b2457b754273c1442e8f3663aa3a7d979cf63269a4ddbb992a73870dc62e2d0e12b922afac95c5e256a8ea0ed2f7ab54e2263cf3d497919185d3c897705041e5465eef87595a841455b6c5291bcdb42aac811f72660705601ad19b5b23247efcaa5536a4fd6c3035623da84fd6ef6f1aadbce8515b82e6c0e150ee12ab8064e9f3fe28bad4c9d93f955161dafb39489ff7a2fc9123e3d434b1f28af2014f6db844d2a2fc3f7d6a41036cc58a2cad6e99bcbbd50775d812bf5327c5ba4e4aae79b19c0f5075d2f2877ff565a0ad7faf565be0803ee40fcc363bb90ba7a13067d1d654aecefab361dbd5fc0f12cb2d9efe713c1973e09b48bc3ba10e18054bd4e239d006c0d2f18aa59c43dc06d14b96f5ffe052052cc7fc5d86f4ad1979df93dad482e205ce7da28a044fd8f46abcabf355ee4e4b762941af5171430f8fe9c4d3c9586edc19958c4ea8fb94a0a9afdbf16227ead1064cc9e68a33d197179cf0429cc99beeeb3274a5b75b7b136b41307d1e59deb212f2c5c0c0bb733e69ceaf01684db0bb0fff0253d10c4a152f42bcb029dcb388d94c9ed527d33ebf772362e913516ec667926d4a987522646f5593eb671548ba19d7e4a32f7a6f76b4fe83069077eeb7284ac6facae1d6ac2f80949a617f8912dc39c66740b19690bc14ce1d115ee6f862ddecd6939a780964f71025fbf4a140cec865095c23645cdd5764ea85878e18733be4b88cd5a7d654ea4aa3f0f7d757ee9a2d79f0de57c0d65c1c66d954e4da4650abcfab42d342eafe34afd5380bebc65117aef96ab5a3c9ccd15e55c490a3e2c329db59f01e2950ed2004c402e550b89ddd74a08823f2e6f3267c87f0395c5796f05ce364a07cc8c1f859e3c228d2e91b20d68485ae971a7fb350a5c58d3208ab07a0da770f9622c81517dc76eb29ffba1f98f8279deb7243400f97be8d5fd8fa6c49d108c38cca70780f172f2a74b573133f11dd0c5509e22dd76c8427e63940a20bbf440a9581193b817c05429a6fe4828c9ae3ffa64028460ca2643030b627034b7cfe1ef90a06e6dab48d2da7985a8b14886ff04e0c98fedb99d2ddc8e32e41405b60d8526b1f3dd33598912a076061ad90dce1876f353b9a636c9994a964ab937dd557daa1944c1fe26ecf48239d4e5a23ca733dc44d2aa80bebe7d7fd5ce1a8f27abecee6e6366b344d69e7567467c8c311079c2ed2c94ae6f8f03eeba84b9aab205598f0a8926c3f7e319caa67f343a65fd0ea9805bca05b4bdff59c44f08fe355c09effbbe24a350987509118a9ea0e0a8ced5212582b2f1aa5e22e12971149e2a4865e4fd16d16093cb1371d3105096a43df20488a0587dcc9b5509822c2efe5bfed9cab63a96feb6f1b3a2a7f6062037d90ae7100e6979eaa8a9f584c190281e9372c33505407c9caf46052ee10f582d00409017e0f3492046f222f356c022e488a628942b0d514adc43fd35411934b2e38fa239a51a2b2c442c1d46ded3877b42dd08fcec9420c5b88cb11a057bbff9c40119bbcb3cd5183222a6eb5d362e30fba692f0659e9741a56a407730a825d6cb2a6820dd26205f9a5c83ab128eae2b45064505c56cbf5c96c67a2565cd38bf8975d4fa93153b7e396cf4909c891572109e730ebfc5df0a5edae75ae01e815e038cad0345aaad2e30ee8d62de99722f9572fe0983c778863b0beda21ac6902d5365c1caebbf7c6f5468ed80319d6e24e6f74b6b7a6512075581e25dff155d349bffd588aa8256cdcf639d4f2ca9d7532e9fd25e78d5024d567f11346a32bfa5d66a76ea76502ca92e10fb248d1566b2b5fd3af2127e75c8467fc95a0ac1ab205a3cec08d60ead2602d8e24fd99eacfbc31b451d79ceafe651d4d6267a3719e69d0e4e6f54b2c82dca7eb982781ceadc24bb476361d7992ead2d342cc55e17387ea35220453fc43efa093ddd2577190cc14f6165a0304858e24a4221d9911f9b4207a797ec0803e545541a8bbb59adba3fd83afb17f6572014e46d73954c7cf61d5ab0fcb64ed445a2e6e3eee6c20d2bda04076a546da749a6613dc601291690f03abd83e8dd0eda6bdf1a6a1613bbbfb85088090294bd3dfbf2333bce07f2491f99bd659469d12157c78366ad799aefffb4f40eab3cef1fc9b92d359e6c2945e21998d03eb91f2e8ad46f49a2946f71fd31acfcf9f4e5e438ea951b3871c23b1d343be1230eb08f89d4b7b486da1df55fc92555869f0b6135b49e36188271851a06a1a23337e97ee7cb6825bb1040cbfa9e422c0efaca106491e627c04ffb5df8d9a3bb58679cb396c348ebfd47534146c572c85d359d362c017e5b39d435f1a8b217f1ea8e4ba4307f169ae3040c7492d55cb250bb24f09cfa9de1849d62e3e316b0d63b422305959adfb98d3dcb65d5ceea1298087bbc96aa86bfe7f3128d877ed11fe285e28dda32c4e07ce35b4d810869840193f982acbc310cd8cbbe3658a2f7122a465aca7746e3e82527df5379efaa6dd31ee0c779cbe811cbe9abbdf6181a29435244736a0f4cb0d27dffa34c3bf2e7dc40e8d171c5b2414a1e797033dd454ff2cd16702296c170bc59f37bcb841e68f4add7cf9a45b68c950f7cc25e10d61c78e7237d30dae86bb757de6576f801b17c54e167e64bf4f11a1f37433dd9c017c02315b9ba3f1cb60d124e4ae26669729a4740030ae597e289fdef4827f0cae52ba445e9d1ceb8f070814ce24bff42eb379670b60fd87f4cf3602aefe88808e99a027d19e718d39b9569021e8a1a7761ad395f393a52ffa72d9ac2eb059455f952246ed5693b4c6f6cf66526fb67a6be4e01f75722c72037bc6266a6e9407911594afab1a79ee6854fb8e16b76851820078635d0b5f581135b819a3d9c58489aeaf0576bdb3389bef5563808d0ad3247f5b984af5b183be833757d5e14ec4ba5a7838ebe0767927668b9b081df8b6f9e0af37039309e00a02e47042378ca83baf814f0adfe7b1054826d3fb3c5f16188b1ed0d0baf472db3ff21a8624d8b37676a0588045192e42ad9e80d36ae92ac750794096f9c4fa1b66bb6851ea3cdcbc09a4a194ff84700212347e70126bd1351580adf3a6e9cf3c1cac574853fc594cc7e5fa6d911deeb0625d73c40cdb548521644f7f6668525e49493bbcf06ee6f3c50e293add5998f9df0fbd747d2f92179cd2ecbc216bf3a81ab37b8aa6f06d67ec220159fba5c6f9dc4c2767ce9ba40e4fa5e5bd83a10ba50ec937e5208e021090e7e5e068fcceef4058cf594c58624a7df483aae8544a83cf45fa72b75f66fdfd72c9f16de19073824858dab86248bc04674a49d3a865f2eeba567a0b0c71ed071b8e5c1b07b2bbd4717e667b635ec6f45ca5b1f442d2029b2f5c03b9fc919838d03a62c8c7ea5bce9ec69e751a906547fb4bae0cd4e1a8815b167e63ec75065f408e15dbc991b081d020c6f6bac33338a68f40412c4e52001a2d3ff9222b95af2495292f81af79b2725737328181962cd97e0c9f65796b2f4e17377286bb3494c54304d3c8040df860a00252ccd80b555ffb06288397efc845d343bf38e4fa9e230c8b9156593ff924a4f90ae43d938fa6455e6cc2da0cdbf078a0ddbfece67464d67c455a4c9182a0f4a26601a7dcb61b58096a46596626ceaa6be292025f6c88a5352393e2f04f55fdafa0922c029c2ac5390775253c27fb91ea2e8cee0ea2155da304127f3ed9a11e9052183058c856653b7a6e92c9c6db49a8bb85ce29cd8d233233bd718cd94206f2792a226be83aa6e5deb5f91871c5ddcfdd1ece804f27af051f97e80793c76203165e48e869fa28a67e8bb50022da34094576e2fd2414a9f6e3b544d8ed825ec7d43af0a8cd61c1c819e70a9bf0a439097529efa6883ba86009eed3feaf3b75d421a219a03d09cb67ff2aea0057fdbe7fe37ec6e81cbab20b0ba7f048a0db6b6f45000ec3e58b763ec837a75ffc2c481d6502efdf2bac1a8404b4987db5c462f6075851624ca7fc08ce0f16fe62e180c6c87a951da2bf4cee7f63b261da81f2f843b594ab2fe56c113b58c55266eb874e9c9a9c4587f78789a9412c3f76189e3eee7d3d5082b75a9457d3ed35e9f7b22e32d0c582ced4aa000414b8172ecca5efd6e8c12671c2dc22bc03b1151b04bc49ed334ce5e842a1f9fde5621d6602b301d433c1e2a3c214a0462dbaaea776ee1b2b3cd6a9120068ad03ef526249d2c312b72c7f9ac3ae8983a66aa4f861ac57a4410434273f590e19c328f304f070fb13037720119d425804fb5ec0e7a3125814f7192b289643f88fa90e613c4dc2ae79dbac99d167c4397f1c9a983e569ba62a0b49f237705364e47f319046982b34acbbcaa140243354a0b1848a5de97906472d812fbfa80d710ebcaf07b0528de5b299a0bdfb3748f06c2e71437319f399bed465ef9f746ae5c17c34679f34a969e8c93a78b3cd9ab9d3c89a8529f69ede7079228b70b2673f68105136f73095ba50be3e2e7cc12501d52ec29467f02f8f92a280d91ad6cebe57b24e469710162abfe63e0a204f37f690f712884062d451a8351f1b5d63a181d6bc5b92dbca01963e9197cfda8aaee094bf2965841550b2bfdba73c4cf8b1a1697e9acdac2b03d5c568e86a576f5381659ecffa19743901723098e698e34d86f4a139335adfb1bbede086a647123c3cabf2fe4fad98bbaf667fcb648f8d3a008079c6e5b7667cebe45fc8b4581411a5e5d56bb7d383b419b39cdf0f97fc38cfaf06af71dc0d3b38bb2b1f882ec98519fe6069c40a6f55a4c73e63b5ef73b85fcc550d76fadcb147bbd418abe8186425737dbbb8696136aceff33b29c1a31080910612c7d4c0494b94305fedaef154bd697174017bee12377a65528ed715e3c2dd4da3ac30cb19357c7ee917e8096b802b9a5d758ddcf2437905f748661c3bc364efaa30fcfac1489c0c89096e176a52cc3b0d7aaf596589eca1f5fb66ec0ec08c3d78cf24504ec7a5a62edd5116d43a6e96e1f7e8975767ff32baf82e29edb75dc4a423ac7980dae661bd25f4ace16d15925dfbcb31440383e53f44fc03169a6f724b7daf450582f453cfae0bd1f9333de3314b3a56414f772ae1dbd7d36cde0c4142bd984ad1cba321ec02ca2f7012f9ef40ff59d9dc9f01a0771e8bf856444d1ff12088615d247d7963f5d5a56620859aedd4a3b4a7646e347ad262b34f399093e8fa3b40ce6b7c47e29be856b41ba29c378d0e346efafb93635d04fbd96f9bac6e6da80dfc8686ea546bb33861bc538c3d6b6638f449fe9ec1bca7cf094e68a00f78b0ec5dd4481cc8e4bb5ec5438c094783a59d1b7aebd1335bc0ab40a0b44111db69c642189937d6864bd4350cfdb145f42e00562ae2ec59d74e32445f81e3b4a9664ec6ba67704ccce040f073f9e293efc8c2598cf5ee47cb0250f4ed0f7072696630fcd70bb8d13851133464ee20347e1b084b105ca9b6b2c732d6aeaed17ab932cb91e92d0e9310599b27b42bff9a45ed5d9dd260c53a4f24386fcb88820fb91e82397ac176441243d0ac54f1dedae664366be15ee6c9315c74f042ba98fbd1b455e88a7de1795ee595ddf030fa488b134717e1481a59957086c18e8d1f83701033f87cd337a462b96a1527d8b6f94d10a69aa63dc3f043c73425a7d2d4c398f3813b02b09ce8174fb8ed11877ffbcacd57d5acbdf4b781ae028f1db5ec21590ed3c094dc8aa2c4401ffd96826e9f187ca880f68efef48415c17baef381fdc9734e808681b2cfeff939a9782470f3056ec66b6eb7a2e8838e45d049eb000cbda25cd8ff8cabc8c02eca609734ddf868c00e8fd47819c26ae6df58adf2c334cd9f83c7d0da8913e995b3af3faa98e5c725505a75bad592661fcdefc916f553e53c45b75cf9639c24726a6cc1ff572fe5555412dbc7a036048c3bda269717474bd1cd41cea15591f2a40535d264cf8f357dbbcd3caf16fba0b6fa8bbdd32937f4a0935be419323b28ca1747cd29fcb62dcd9407a071340601baae95a5350c54fccdc4bfbda9593d261d1ea3f6ad840d5b7b8a096eb586917382f74ae6148493b951236cf88ae1f4d8e5a419c03e33ed794fb17845a431d485565c6857bbf0d6fe5e9c17f8e9234228e9043c14db52f1e18abcc227f68c294068c8f3f6a3bec6f78124d23bec864797d36d89adbbfe9466281a257f149c0c1ff95e119af84c59c87823f19be95c1cb9b6fc0b0e1fcb9c0467d78b75a7f5f49b3ca6b95d28937b116e5684c3d86c5b4c0fef2f08194677c32ba3339404286c4446629facc21d820bd3964041822384eda6b3365fd58abdc311d91caf17508c1875695069b8138892d39f8a135333f6275a5436ebc158534e785eac2e9304a1cb7f4d325020df4bf0009b3740e8ed2d24d2fdddbe418aae31434b8ed7291b212e8deffc7138faab660ba8ce3f3d66465c819ba44373345d449391dc24238e9e604d83b5c29e113c534554b688ca3cc58af8bde49eaf8bba23fd2eb3cc885607e7bc0d45da7b9eabc8c504884f883af1fc787865ce48f949a09bb9336019f3c9c2831d24c4153f77345ad9a4b1ac88e73746322b0c11bdb12a098fddafaa44573a1cd7503973b622d7dd2ebbac0ed7c90205a15c5ad25e63d1262b160a2da241de1a4140f1892a10e6bdf0fd5f1102ae3288068310950599a3d12426a57528e634159fe8a98f85fe6ed59de11ce566e34b01a64cdbde9788a8e57ba07b223be508c41414dd16fb7c0f9bf687b37a42ed624c55a847d9cb68a9690937f4f425c323ff85f5b79cb562fbe0569a556725d7034d47a10637b1cb8015f12fd1e342359a987eea56050f20ab81b082932d9f4f3694a5c6d8754c02eb03f33f2c31496426d48aaa35f33d84bb095144646c42092e8898a94ff6e0f7266e47d8f0f98d46aaf8333e379a697815a739b48c68696805e4d641b1203e28facd5faafce67b3a606804c5c2e5a4b107863909f3348e5b86c4ce33e97040e3b43c8d9d536f87b328efb72f7bb45e848159d9f132054e5d370dbe755daa0f717f049d93ae0bc4bf5a0617a827f6a68fe12620a0c65f666e8c7fd5a674699f6fe8081be6378b37a4d246ebd365ac7d84c550890298374e721d031a3836f435df6717a9353da55dc753acbce07412f19d55e4d1eade5b0e9d6de1815b3c1eeabf01dba44f96d5d93653c580612d3e5e55f2a323d0d189f6640102b47b2674b1436382e7d74a2f3bf38e1e484f8869eedcb2212adeb80ed371a44c5c33cb1e8ccf0e1daeb365ebe533f21f78e7a211c713049a7310f952e4af47e7d68092db293220107b17ee640e4bd63e5012a182a0587273a686150a7b83f5ad662185ab8a568b4b1c37cafc04f0c070c4f94935aa697494fbd4c7c83f600a37bf3f5b4b52d04c870ceeca25d654da8aa16b9d2e3164c91aad8198aac515456969e9942cfab7068b9df3d4daf612c4a29e9c9f2380972280e9c206eeff41ad767be2a2c79d34b877781d89dcb18193b3ddcd57791f4d14a54900fdc44d36372dadf6285151af4d6ed11552786caac469a50d25e2d2d5e0a9b9d41d2530d54b8c6bb6fa59f553886f4a4a8e88b490a2fb9c82b67a094452c5d6067444ceb00cdb22da5697c6b47d95775c535a3279fe991d90a4943806e7085ab1559c7fb4872f4da8b3e2169626c05cf5fa3ec5538a415f73a0ccff155be3289288a080b5238df3c50e7b910e9869f25d9cf5d2e45b8d2d596f8577d62b97c2c14aebb26f41d54e7b05549d04c243dfb618e9038facfdd8dd12a43cfca6d9fd5d881a8f1c2f9e55f70ab802607066381eca940ff8932020430a3dd351e4cfaad8c496ad99515b18df6c1fc6ef910d5724509ea54a763d935c8c468b4db139a48a092bbbcba47c3e6939b908758ef801115c9f720014d75eb4c7ecf533e810ebcc393f3d2102d7afda4a4fb9d390f5148186151fae348aea4358870068c6d8c3f10cb1380816fa332b8bd5cbb6e393fa38c18e20f9ce28cd53ad7e2fefa4a00a9939061a28ee8966190abb1958c5070e3e5ab45ea98a40d3757fe325dbdd39f632a5c2c7a5e71c3d75194d8152290ad6b7d81b50b43ac88076508c87ef6aaaaac6ad0d359530bf687054d5021f71adf5a5e70d49dfc805d138177d9268da396ff13fa4e156b8445b08856db5f4246d19866a020ec3a88d331bd1062869f29a1e6d413097cbb535166cb9b62ea93467aff7dd6cd2610c93e70b2c83516f3337f7973572436ee06db572d91fc384f573409cb088bfe7df071f94f8a030f7b7d7bd982829bf7a0530b7e24565b9410bbd3fb72d06158585e299e48f652259733cf0f4ae2c40038f9665f869f9156c11991039b09a470676070ea53753c20861c3555b5f84d67b9a971a237c90b861f9689a54b00e7e8b5fd266569246b776e8523c2effe56a5be1233a3967ea8c96688b097c99825e9df5bb4612a3700d293e0ceb6af617fe3b4217c680875bb7dff226ea61ae076a4a6befc3f0b7cdaec4d3df5810dace42782a04f5e5da6dc68e3e6cc22bcdb492e2a88fcf2bf785f98f7dc47b52cd799cdb77a5b5c136950969141b31c1f4935dcfce1ddfa6307f308c541b492c5162ced6eb40171d4a249a2caf28974cf2ae5845064dd6d4638a65ef3859f5923e727fecd1e9de979c250f02b26a8b7da9d8bb6b72cd11f49bd3b23c551daa90d8cca8996131216724f5977cc7b8d1a3896f642d5ab776d6df48a4391b71f4f4da26eb97434adc6859a27fc268e1931b832a8e91050f07e994464e4440375de4298296b04b01647526076df23918d9957f066be6a01b5ab09c05b3774db2c9adf9c719d9a127030a4b5ba5c85646712a2b2fef7eb2ead651d2e69f157b2e7e75bc4095ae086af57daa94cfc2714bec5a20d133cea6792bdf9f2bf4637feb433967c4e59d665446ac44a2b850baafc4234a16928b34775802ef7c801fd3cf504d2b2b6ae3dfa4ed04b6ae96080a4f0e8a5d90034f67613af99dff8347f07e93c0a7a9aaaa2daad24b2c67b69ef81353b822a3ff5a94d8e02cc4ce17d052029fda8fbc26587d825732c0616b50ce8fa7effac358f314225602bfaa055ae75e2de9707abaed3a761a5b6899f2de0b9435ff0ee64aa6738c1b1ec053fb77d65408fb08cf6a2fca48d2234434a669f969d568eef869d8f728f4206233fc11e728eca79fea7aec77ed9f0f37ca3c5e38da06fb4e7d4583198c16416d4a839c0e845057011bf6555a517ee77575b9f27092305286f6363f68aac5430364a9c946a8cc21a96b22242044b3f08cae30e2639362d1730c77a783b1a6abc28d57b0d4806727011e78e4e8958adc0f6ea56c22916906781304bb862022493288724b61dddc3941741cdeaf56967775e6b3e9fb1c9bd1112d615d9ae9883c7899f53797af845b8b7657b35bbc324dbbea4af2415dff5a0e47b1a8d70f1dca8aed7bd4846a1643d97ddd4ca1a642246f1684c6e848e5cab7d8d23c318e92b9fd6793022f766d8e4887af216d3304d1ad944960dc8ecf8081e89cc2a23a94d1d24ec31e8fa1eca996f06027a92ccf138b9f9f29abcb15f69ec428b1c18faeea18119023ced24576b7d845fb46cef88a2591dc99869f5857f2e3fbd77e172b1a3ed040c871caf929b372e83ffbf01e87244475969d6350d07ce194c40aa50f08ed6c33772a6a69024801391d60d7ee7914574f8789f4addd5c46e1016505fed751e9990764d886c9a6cacead83db7496de3d2c6cda19c5997523a032483e51ea908aaee076d5431c982695d8214beeebbbbef9e5552da456fc93b905671ef688ae9134210f7c6288b10ed79901b4779f426e1edd4794894d4c2452b635be3f658f299c2eae0bd8eadc3507d6824e893f6d3a2b0767d432fd66d5c18e902df62e8950817eddce9a3d27497a1d17f49cc32cba4c8d6bc9dab1ecf0ffd043ff54fd65fdb2787ef18e33d69cbcbe9acfe4812735254a3996a47bc41e3c1e5d43076267baf5bb6515b338582fc4813b53448add43462ce7d927a771697d72aeac7df8609056279408fbb7a16b84ef0dca68de3e3f2c4f5726d7d9664c822f732202ea964c29e4da89ae1cdc2bab2beec32c1c1835ee5c10c5a1226b43c94c900a85836c974da0cbedcdda9851add538077c345979d8f10ec618476a502a55f4ba397738acf2d055edbb7c531dc52c1ef3cc78cf0cd876bd65a2956085137d399239475697bfc38fca02012d05a965e911a3ce36594280f18bc51402d7d0afc04ee7a0bc9038c6643d2236882541a5cd7f549ec7ac8d23320c3800b5a203010f25efb0d74acd74f58b73910b08d0b1f03ba3a71f6a8c2052d43b3b05846fc62b8e77b28386b149618c581db14df3255fb8f4e31ec7a80d792536791e14ebce8b5840e4359f5b8a2f4e28afe0d073bc2c9a6c64d1cd6b04a8f8d59b75bb3bd61d2745850a1eee7e6f1e569b9b200fba3376b6036f09e30ae5657c6674fe584d580802b7f7e2ede53476f52cdc2f5b4429f1d6b59480a8a4a57017afb6b57bfbcb08ab4913eb9102118c5e322c241897b175cad5d98a984a04609314cf0b5d56c725316ac62e08c4c84beaa71dd700f0e2c4fb99033799642faa4980111af8eed25419b70edac2d1e103600e322ce7e75dde174b5d34e05c0e9ca974b31993050c8367bdef48fc2c2740140c7b6adc175350d6f825ffbb3d2ac0827bb342ed500b6797bf27f269d10401bd3eb839ed529c6dbf14aad3e04ffe84b9fa757f4ed836e0ed47bb9c33fbac6aa183856b4f8c38161bbc23401ba02b54ac324004947e2027af318d628757603c9d0fe8e261964351483fd0344b8240d2fa953e26adb4ab326c7d4982f1670a727f47f5437f77dd40ee79fc35c72952943337d725817a49678d7e93148d06459037f8aa6e41f4d9001d4624827ded6e1c9336668034a810e4515ebb840f4500eeabfaa2fdbca712d4968fe3d6631cce4628621fb34e1f9dca8cc46836f8d03ab64960abec96b7b2c9962dbc7c132ad320c564f32d6a374a05ecb4348ffaa042f9c1b1d618f357aceab4569b7ac3f0abf5c18c8fc8381c65987aa587879ebe8e70609f7fd2884a429bc6d312bc77503c32332d6429b81feff252e626214f1082820be424f90f5171e9cf94d590fe8b7d45b48389f015fdc5976dcb5ff5484212115562fa32309b41a6babeae2d1cae2c61c5a57ea0e775e81e06331c2946f9cf6997d1ed6cf7497e521f8f0565f6630d4c479e92372dbc817727d46f368b74e94e8e214f555a6640ebd155a262e7768e41dc72dd250556c314249df765dbfac5466db01a27eb0735d875347a196e12e86e8b6d92ca818041c6e40df5845851fe65a6e5bcccf18190121f047faf8ea660ddfad73200286efd5b1d13631a9e605586b447eb22b33d2003876a49fb05c2a44384f574fc325412b209e5566754a76b2104ffd9b83420131d557644f498adc7478d3b39fe42e427bff01d314fad857621cfbb772c38aba72774a6a668c64df21a9e48e75f6ff34cb00eb6cf53d7d77ee8c835fab1af917c03eb99e9aefa9cd4c3143614853e2275903e760d767c7d9c1a60a0a35db8363e2534a8affc8c0740a50350a1076940e12f895c65da293b64b7d6a0ee84e3a37607d1db319d1bea0379638d53b73126b58c9173ccbde96bed5b316907cc5fad21de5e4104d83b41ef65662420fcec909f0a08585fe3a1853d56d7b7a5eb4dcbbaaf7a94cba3dc8187f4d023af15e671aed9e57ea8144e987cfcae4c3f3da3a8a778abd9bb7c90b2dc9febfb84dbf2a11e4f551793cb3295f480422b28c1938fce350b47c3b962c60960989ef1527215208e9ba94205565384655fbcd69a7c8836e33368ce5bfa1ea14399ff76d88152fafac3041d62a2f2aaf99fbb0adaab2e7885f951b2679d9fb5a33396f833db2f38d751f7892e5bc9c6a7157e0e7ec0e5cf81e2397174c601a04fd732ece2502aa8be635d47aad9bf2d0948c2ddb3bc75290fdf7276588a22f070d490355ead853d1aa09d47492f0d03554f24a806ecb8e78ca6349fcf8a4589587b92c73eb4b31d4636c49e02c97e47473ac8d4ef5bacb5cf25ff7dd17aec2a80f8332caa119327a3207b1b739b508d9e28a13d93df080b08fbd6bc1d6d4378bc65ab2820d2c57dcedb3fda2fa7916207fc2321ea8e25dc4841f972f88dfc9ea571086b8d03cc81cf7d28dc2d9376214b5b3460c12b35bb15739f8e131fcf53dd43e17cd637aed3b9d205016dfb19e8c91264b6bb802a20fd4fcb452d7405a3a421692a78b34b312e785af0a2e6461c571a00c45d51582fa2d1e86ff6df156867deb912ce5c1e3af54b3876f830c207220d835fb9ba1779ae575d6ab766315dbd138538396f50344a1c0a5d0107acfba3777b5a8fc6fea09732ccf83e992c0674152004e4206323f04c764d9708130e8c79aa24ef80730c8e966068f827126fb189fda68bd47a5153a24a2bb5a31d1f8f6084052a01baef23db8cb3572704b6c2b266de3b6f06e41776dac56499ef9e8119ad71a8131234262897d8c76d3e427b57387e990d9cf54bb6011a9447b6a60d405af2b7673a7e90e8f7b93f243b385676c440aa925a85de246ea460a0b9399ecb7a0a2e1b2ee573844bd877328c12c98ed3b1b1379fe9f017101a6977b3ef2f35046a65131e9edd5b2a4d0b9a4645fc697073a584d2dbbaccecb75cd2095cacf102b90b512bcb6614de4feb0b1249034154aab98572c9a205757409647194277d5dafbaeb557842f85091d7ecb7695a3a7aaa561e8857771df7a0aa4bd0ffac857451ca340e615a8cc8d900e86f0049ddbaaebacb9f0cb9d3bcef99821df55cfebcb2c892ea295fefe5ad321a8f7c0a818143364ace683a66af5cc4881fbf7f275ca0d3418f3a9f6adf79496b2b406664143cde603d98df65b7f3f1c84ab2562e9b2f6babae6eebd46a03db77ca0398845f8180ac6cdef81e9742fc64e8e6689e366f84335ae180f7c0c6dbc9639377dc6f62f7fba414a88f6e714578e6688fd2292dc12a240c0af73ac776f2b229832b04cbc7c576a9752ae23edd6441aed0d132e0154a17a76cbe93ba9d55a74bbc47c50ef5f7d24d6eb275efe7bc28876f06f0dcd16f4e93d00e281c8ad8e3a2232dba461b38bb3f3300fee465c678397988bd413e235adcee121d13fa9adff00a1899b02c589099cb442d5b27a39f1147fea19137667173630d79787503928dcfbc4f791e2a0f73cb26b098ea3c1b5ccd979b04113bd94c1602dff1d2ca504266faab95b263510e66dc8346ba4d31026ac4b6f57f3ca392e4f6291de2bc0e90696b7cbe9e2d904bdb70e99a843ac1f5e82ea3f894594320989796ba0f32333dc6a5830a66f9e61b19adb96abc76e5da3f28db23132c6b41f5b60de06e5afe15cb3a0b9fb6df61c32cd23c5629b6f96d4cd8e4d6d6921dedaa32eec4283472acef0dc5b56d239fb40fda0e1d001d5e8327ebe6494dbf20e8838f04f8571ff36ea73c7b02b24a417ffd4ad273d24b515381d3f82cba0ff6430ffcff0a2eb58687a2cf42515618f93ea794527561cedfdf7e3a5f4ea994aff7eee094cf42e9bc04759f0cee6b9df2829d050d87760bdb1899e65bfdf6e257873cb128a214d546233b1acfd8eb75fc2ff337686110ceefb36ae97108a400c79ae3892600c1553ac508012f9477b75ae9ce8224e689d82036b467645512d766da05c7acda296c3febdf6d0f2e44e7e17ca06b8dce37a7ca758bbd902b3d474cb6cfe3c74338315e8f12651f04855065be6ff1c56828f1a4510844d0c9a32b3e06df26682d697c7119463005afd26bd7808540841d3020b21873fcdf5072c4bceb02d47fafc6ba45f885df359378aa2a14723c5a39ba6eaadced695d83d26cd7d110119ca4751dfc1cc80f8b9d98891844834cf22f316c3b3176ff5a5c30c7d2e2e919e937ce4c674f93cb5aeeeb08068be8d2950fe2f0502facd0efedf349d24c5e934651909417619667714bab6f4dbe482e0a73ba3ab5aa8908b8a7a5dcfd82057328ed60323824abb327cbdf2945c9d9ceb1b1e301210ba8dfbb907f07e5086da84736bbfb4534704eac62ae23959e8eeccf3fb79182bb6f6c6d3841ba8ee8029e6f733cf11203f350df1f53f11140caeabfbe3f3e257e0bb1a61f33ab1b0ce55973e6e26bfb3466c2aa6bbadffcc4e5ed468ea104b11e1bc7f93802b12d00c2ef6a5201be1f96e0edc595dbbdc4bec72590a08fca4804a395db6045ac1ba3331333c6b104ddd1e7c2bb830dfe69bec41965edac018d6db50667d169bbc2d47a5e78ef8b30f78506008f93a2eee19de3d91378f4a8490444904dfaea5dd1e72be9d4a1531a2e28e78e9a1b3ec67383d4cf3e50184668744bbcee4d9fcfb083448e48c5b32d7ec36a0d3ee36daa164eec4a7b0a6077a5bd56679edaea66e9bc6ddc62572d6ab414ee74f1c5770ef692e7b53f9dd4f18f16a4aca49a7b178321ef47304dcf51061a1b5b4e0eec997f26411df9a67a3e033d28c43b75ad9bc7b32f2b09554cbc1042befc026fc1a2f8590274625b0600130ba5e3c47c7481081208c7bc22e9a18fab4451205e10359ee9e5361b910667282bd7bdff0f98beda4203bac2bdcceb6deb5cb1d873bac3d691d0408579b39a566431f49f4947e3fccf85cd1a74fb4aefd605ace1aa4640e1a78d8b3fa67a9f5da52a272d43249b6cada7dd22a1008b57ed9d0d0716428246a26543ae42250ab94297536a3f4e95eb369429751d2ea2666f259c0f9d9782b424966e2e2c5ad3972670dc7e6c3de426ce784dbcabe37804d81d6e4851decde3f9b398eaca2a94ae4af09d99eb61e4c70e69e283b51302b5a1a11b1ec89f357d8893ddaf52ff0b4af2a05f55defc5522f4ead754a8dfa5f6317678140be9ad0d1ae5f548bf14d5cce090e2e7b00e03e9daf85a8cf6d28a84f68fc5a21b50b30f8eb67f2bd2d83bc5c29294bb305737fbf5f15772d467590f16d2e6417eac89076fbbf8c9170599a958c5329b67a3383b39a1e2c569c2ff3b548c7225e6a9ac756462ceb983f9a1f6a5b29242b525a1a4da2a9a87f28931b2f1a5d2ec202f7ce6943e1c00b9acfe3775f5de99cb1aded4ec24e1eb6bb651c0c562731bc1aca3ae8c503afac86d15005a0468fd681e22765c135622f2ce4af01521ae9ec24f89873e0836575aa64ed32acc5b469a2854594f6ffe7311fd100fe36afd5233f587ff64cee5f3b36d350cd400e1e91f98d6e503d5d7071a94e30c00f4b2d8eaec48b42583e4489fb868744b3cbdc487649e62d20c744c0dbed33b6cb40131e83ad9282d72f954a1991222a2ba792ba478af4fff301fc4ad63352474a9ff82fd16d6e1e8d698e6a73d3113851da55942220f8a1a80eae13d37f4cb8fea9982cd859798738a59e7d7f6f3b39a1fd89ab048715def0cab26819862b4930b23979d26b223349176047471050f8d25c5351b758e915aa42f6450c65c4f5337cd0517bf20a8f04813c685193839f10c17325c4816b55d3ae3601a8b539d39ab91b8fd66a27c77202f35f277088d5f4a7c137e6920581863acd5f0ccee5b9aecaccba4abc1fda1d158b649c0d9b83092b295c659b5216b9ad7c520ca627ff58174ebef2f14126ea995ff1b47c219ad9f2ddc41b60d4cf6cff935b8867f6b630306d4b2b2f5b209cc4900b5fb16c9ed6f6685306329cad3a68a34e8a403547c6eb84c80defb4357bb81dbcf99edbb1f628a144848d3627944b572f73743f7893bf1a1cd838a4395232591378a8c01d0397b5e8e9e5bbbbeb46104d944c66ff90ddba5be5e91df66c4f1858bd9f02d269a3336b3ea5c5d43278a6e2dc6f3ab9a659e670df6e2ef568e7aaae0638a7745abaf5cb40285ed87f4ba8ecf0668b4335729e2f27e422a497b12663c2c14ba980aeff1f0a91257dc5b214e89ffda5cfa929686bf4ca7d48b704487c1299d045da38008ea1dd7afb4e8abb92767a2869545f0305a105e44df36ddce441441bf884bc77e3742154d19a9aab3417d7af1b811709eb1518f49af18c67a5af3c378e5e7bced934cb6e6d7a7b50dacdf8215c4e53720cbbc438b11668a5bee26758e0e1b1458a602587c87d3ac7fb8c06615a5106edfef9f458b96b08ee75070de34d16a9931337825b67b4e959c66534d36902f1061a83fc15b250ee02d156dd8af64c060db90ee641b7c6d341ddc535386de897eddab8c85c3077486365ce433a2a0ddc0ccd1083098c554757a7e704e076d5e456affbe2d958801c496e5971fb644d616bfd7b18e1136029ada3a90bc61c988527c0272174e97db39e0573abf3e2d4ff1ae38ac41360949f7b4fcd79f2cd2a5628d48ec4545d970032d75211be50b57e2110d1354e35d71a128b26cc564c4693e3ee571af2d4708ff3a9320291666a5f30057b0de0ea4c1a151407dcd2b879bc4cba8756e534c1fbc1bd2a54a86abc8bd01ad2b8a402fe48ff8b2905c0ed92b4f2065da9c232762fe9a22ed845c9b0672e1742adecfc8b228f63828bada719cb69b06f3fba1593fc4a7c98e54b7b1e696605e55965dc3667fab5ce35541585ce83be459f4e58445d6a362b2de5fb0439665cd710ab731f10664d6dfd64bf31964fc22000ef5edb53de4cdd66003881cc183bb9e2c4e449fa624b7a73b6936844ab71839216b6ec33dce4f46dc586c96a70c8992a24c4aa83f9496a5a960d261059c2c269c9e97809bf92753175b6c6d5afed2c13a26c6220ea7858dd5c541f2f352dd16ee91f5cefa55a6aab762cbe0da4b73e444f9145300e4190cb4f5f397acaa93c8c82c62e811520b964b7fef03097c61752289176f3be129cec0eaf7e95b95c42221ced729d00762d196536f0a1541a9db1857f41a6db33481462ce0e3328fa2ca6ef72d4d82dacb523ef50064612f4100c18546eaa1560b09569db6ce9da8b24b66b103ace471fc0f62bbd5ddbdec4144faddf22465f2727a1e51d216ebebb465edc68d07ec9a9a4c309ecefc336726836059dfd69ec12e91a53f1fe0a57830cdaf1d05c7c833907736465e8b41ed31fed174ce5d430f19447e8964f9a74cccb44dad5b6ddfd34787b3278d153b626dcabe104b3adcd6a529019bec5e500dd21858c436cf70d79d4f6c2b84eb770c7bbd1b9b2241c0b068e6b523c48a092ce7d2fc79d4f3d600704a3903e5ceb641decd17fe34cdfff9de5bbb890db443e4a52e09d92a722dbec87eaaeeeebb77084bfeb53e79cc4f5d67b4b8837af22be6cfbea237c02bd4eded735782bc816caf19cd899b41f3e29a22098138ad8367d5be9dd7322633ab9be75d38fc79ec1f0a58238ae9741f482a6320215ade43f5252e011afa7ac145073ec35f7c95d20ce605ad0f45aff58a0dd1efe4f9609e11c6ede381e833913a871fb37c8d2ec839623f4fedef4d93ce8f5a88aa9003d552942d78046f2d70883f853b95f4da063f305d8259d8452ffdc09536a324e594cc046139f5f1758d7ebfb86467f8c603e6330b37f4d0d9e9fea77594a63f3e9fadbd234c6fca42871edc33dbce4097bc9c996c5038c29e2a58564c8dd5a53aa894d49dde72896b67c4ca556c9da45dd314f36c3fd3cfbd015723dc2111b4daaf75def9446854177f2a602d4095979cce5490c64392cd8c59c406314dd438720edf96d4e68cff19905fa4fbf1b1902a951e6df0bcebb22a7b50b5d2b874de8591f6dab71eafed29f3e1f3c626b480783ef3d7e0bec942ad1fc4227fae90cc9f31155970964324a82062ca648321979c3091c4ee07de01aa85937e3217c19db65dbf9f83a86c98d425bb6928ec3815b7a7d36d43a788901657991eedbf267378edf2da81a55d48fb74adb9f0280b044dd7e6d93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
