<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"146884f1bb6398676a20bd2dc719491d20f4e4dcc20c57c5e610656d7f4603f0075e334f065bc892f268d045ec1d2f9f136a30a3d3a0c210a51c23a6f6b991544055efb2fdef5985e3d3021326365c7ec8fbf28ec792e2f7f5bee2590536ed5a75eb2e58b21cd88debd74bd3c4e27c797033df96edd1cf38c711f1a0cddecba2bdc393baf3be874a7c6149c78bc25922b961ebda38458470ee6bd8839754bd419cf8f354662b81e9775bb60b57dff55fb39c1632b29b1d6ffa4cddbe012013f448176a63913a9166a105c3bf6706cf5c98e1e56217540ace77d99a5e4e8c6b0ffe5f141a42156aefe250f2b81c8ddc97f4dde3a5b8441f7fa839ce8c30d4232ecf80e5a49b1a2abf227d7ec8cb3c4d407ffa84ba960fdc1ed5837464f6347171bb70cb180a7c1eda5e468a6b841daa778335d818bf6dfe343ceb69e4e46f7fd15eaebdc71c1709258dc4e0265edb86dc6d0d55e12d776effbf4b2c4f62f12550c9afe28311106447004a35d6b8996bf5b44d61497a94e37d3a1232eed1070551291378c0bd22546fabc9116217eecef8489f95c59a3808f31420163090a19432470527700cf0909232e5c9d429e59ca7f27d8b20069418bbbb4d82e52c4a2d120bf1d34009661da0f473edbc01becf45a8e61cf45d40e0428c616c3cc5973f0d3226b40d45f0830cf0d011859848f6eb62fb0b32e9301c705eaecbcac4953a543424ad2c5fd1ba764136b5469bcacc08bf961b13746406223a8d728c1f0da19539344e95eec1133b6bd56faebd720389bfe397125348e567eae9ac1096a733674772081f926bd0ef92edf036a506510f4c4cacd5d5116787e138436297862e52b46eadb99cbf5da31f637608e7eb13a1f3826a630916a8d374c5f88240306b6172afba9114d9b6c2c11726e018e812086d5f30a0ce2765d5c30af4117510f048e752be4b907e2918e47621ea61fbce1f22f39a822e44b77f1187b4f218fc6a376050d12ca054215eb0499821a01fc615b779dd1abc95a1d2a45195387b1239166550454e96c3f1d3c8b4b2718b5aba3d77ba7ec832f5f80dc54a248bf8a92d25a487175bd593af3854d6a8e76fcb606a5ff5903ac47de582c5b9f87d2d181fbf66789173da0e94004fc42c3ee19cbd4af8bd35da4cb32c14dacb8251e9aa6789602202b5adf0393ea642f422eb29c0b2fed42d62f5fc9b4bd3b5028745ebdea5c5eb595710b9cdca4fd0e98f54a9bacd49760a498041d6b2aa5e756b24a02e6dd8043a756912092453228a325dd945ac88cc26062d1e2ee563a2165568026edef48d5ed6a5777837e6c484c1daf143cfcc78f498165c6a34a0d4eb5c7dd42d8858b6c5d939bb86e351ecd50917c5f60910aaccd9c77161eba4923e194f5055b01f7075bca16128baa3036dae93289dd28d37542218ac18c816da92c56cf966c81a448d7f5f4c70d6db012cf9203025bbce9c27ed837a865722dc330e2e52b7cb3b76cae717edd0ca40033edacf4cc6b94cf24cd1df599100c5c46e6fb6b2588814903deaae2465c38407c1ca243d84c039212345533adb637e209c20a9427f2dbe4d8e598da9aeb7fd4b59312285978db6cb828bb6f9c1ec99d5e33b05f8b93b3d59f300ce5da4d9cdf58475f4e45d7dab0fb704238a5cb9646fd3db9b75515af04a97163b0b00d1ca1686a5a17ed703e8ae6b8566296dc3c99c684a7cf7dd4cb17a96dd1c21d10ed806d71192385829ec8ede2be68293c558960537db620f8ac564f14753f18fd486c117bf307f81a8f9bfc9befba8610679a1dbed2a6ac3b0b46a7039c43d26d7ff66a6fbe82b42d0bce024747ab03afc3a65bfe4802fd756021e365e1e7ad12ee9f0ff5516a5d952fdf1f3a1eb9b1cdb60c71c0405263e31e01ef3b1e8eba7464e4afbf6da0cf88cce4451a965851f80fad7f82d0caaf1eab28c21cef627441505002c27a841b6856ec59914d94405e038f1c1a6c6b42b03a22576a68614367a98796635050fcfd41a0aaf3ac6689d9309ab8ef093b1657a65f062566b44efba9a08b906ae203e854430832e164751acf041343220388edff08b4cddfec59e23929771c039ac114fd3e4b8c059e2adb6df1a05fc018c15c9b0c41760d54b4200fec5d2327a3f49c5a51698931af81a7154fcc428963f734b0061122f42502de4be7f3109fade2585bf14be3bb302c94f9eb342517c50fc76c051a0ab1024c049c45e1fe8bda7994940a99ae772680eb0ee4eb05f22a0faac628f86cfa1adadee4e8555205d5bd8ffda1b2146b13b5afffcd3092ce9f1eadfb41cc2923d070550e7ecf449ee9b01db6f253fbb317001c38b12bfa1468809de1ef48e161db1b6953d31abbc93553032c2412c915ae03e04e1803ff902a1127d15c2d8e98a8262289649f7ef2123cc3c24332a065fc0bc9d8789453bd03e5921709abc5c2c509824df2ac202a2d2e7b58432a9ed45b3e6516d634ce8b938a90977e1f66ca18b8a0b70d36db848c3a2bac3870b599ec768bb5edc096701e98eb0b75d90a2731fec18438b0fb6e70eb84e87c4adff57b8c8e338fa6bb45ba21b973dc030f27c1e930776b6558ec2d5da5d350f43a5559bff948c40247f33bea4ca34192956c7f4d97ea8f7fcc1d2c1f3b7abe524c584939829c8de1329b69795115e04d4b9bc52b1506b04708efc29466950ed6dc6f3999c8643df52cc6a50fb526a43d0aa3c61a489f35f0ad596f0541a4c9e91dfeb6dc820477349f85c61be627aa228ce8042769dd1e38f6a0c8422849aa2a0cf994d472031fbeda68801d6e60cede00a816257b1930751ffaa747f95be93d810dbf538a8eb28278f6a62f9f6b80b9731552d8ac7253ce5cc2e145d14c7d43422a6c090fb408f593e4ae14b89b26d86b9013f9aae0efa6f7580fb588fa8b10697711803e0f385c9833881325e6798a8ee6550d12caa35e160b926a11bab819a8e65b0e004f0d6bdd1f9ba47ea7198f511f33da3b9c75af4d1f4194e059fbdb9d3e60280347de80b8eceaa89325a57622bdd4dab0b51ac36859f67e61e56515a37dcbc28bb4d3027073b031b787e0cf12d7140e018d4c6287ff960093d9eb7e88282a799467ace247afedda5ddd42b98b4665036d35dbd014a67cb2066ef43e3471b1d7ecf8a436e8e614c1b34dfe2a340918e9bc8f8021f99ef828b6152ab5979a4c5737374b03ecc6fe27346e426f4161f160b3121e8280c74cf04f539752971014cbed9ca44e013ff8c0159a7ef2aafa14d2a355e3e18a473fc4cf6a1d09c161d99fa80092b29ec26b03cea64036364fe8602458ffe18d4966b51994378337313fe2844e7a631e6302c39b0f8b650ffe4593dbd34bd4ca40451a0fc7e0bfac4ea2043869390c22458645771911e57acfa076215f5face3a68b691fdcdd4e5755dff1f9013ada8a0a426181192c9fb3c6e6764e96111bfc17c5cf8a731f9837775ba3d50483d11fb51198b1f1a60f729e370946bdfe323b3fd6cded928c77538e20b357d01d2070b5b941b853973323a7360e98d365acd765974a48ef8f6787085ec29a250ead12554e0e71cbf315a65bde46480fb9a6df28d7fd802efba2dc23bb4528d0a3c42574b45dbc2dcf5684a0f2d4764c14148cb51f1bd3a42c1260bd6826aa63e5072b812eca62857bd8bc2fbccbebe1b683a779ffa6c185f81357edbe6ad561916f13cd405cbb4b6a544bb40e243c7c317aaaabe5e449c8e701b128ab1dd996892d3a252de7b794d51ee8e8da62942b6c9d11d9718635f5534cd4010e35675f428605038ad69654626d0336fad3a20689a2ba3d0c4386f62ede5932b13c779ecab6a582e740d683e89985ffba0c157f4e8052200bbe4aacbf609eb891bde2a561bb94279af0ce8d912870ebb3f0b625b8a81a206ffdc62ebf07fd85cd38306d83fb903764a7291270c8b15d9d45f8edebd2c5636ec67f7eb10e8c8f1472d167f4fc6b25a0003278866ac2c58cc7f19165dbdac332a2d1b2b23d6c812c4f552267f4850a4c57263fa83ceef1a976dd28d852addff0a2a7104e3f5519c33d93cc0667c812b2795d5c261fb43e9ea3274f4739b85a4797149be0e5d453b0da6fccd45c22eedbdca30d8abad1405562c713700ef4179222cf73cf0c113744f730e9a300ec7e1308ca67034f5aa3d3534012f58b54a61628dd9c3d14af10c0b0cdfe189140c88905aa7ec64aeb3705f17680718d7fd98e2aea7733a312362dcf12870c117b831c24aac773fb31d419beda2b08035ea7655fcbc2d31eaa79a95f50375df648b765efb0abb76ba36edc2505e401855e836de2a3694fb4b0940bbe5b57a21237802642e45a202f1442878936697a981401df70862997627b8c8ed599f2f6aac23eaa6e0d23268a8eac7abb30af9dc54696541ae863e8d672316311e299e5779aa0ba0f4870eb5c761195307bc45ec54026f3f90d8fb33be91ae5c471df7e3e75644c5551a1207444269f936908e07fc9c766c09c0ed94ebd3b597d12f5634f9d6d9a1950a832176b8ecd5675c4e558a83e5276060d2ee6276adfdc28452ee8540c014d631f736afdb7fef9aa73db3a0a9506a14d706183d580a4dd0cb6f7e5f59e07571d267e346a5e8a25209914910ad7de2e431441450c2fb4c574e657a115e399f6c6e6a212868234c0f9513a57b65a53af3322890938c4047749def243bd7e4fa8b213ae368f270663ef672dc0e1161d156d3fd4538efe796517bcaa6b92a2b2d3aa71a81eddcd6faa5a9a97862cdfeffd17fe69198fcc7cd2c1a832072e67f8b93bac52600683242d681724ad8ad0e2a2bbc65d60be8f8592e4ae78c7565102cb9a03422a0a28ef4f261f7d58df9b5b8a627e01f009b425ffc268cd92c94857158532b0ba685a7d4f188607fe2735641bad38ac742890b2db56dee2ef7c27d2da6c6e0809004080a9960bc84c304084e6bb4c95ac6be1c12959d0811518ad48ec67517b814504d54915a6254001130bdf9fff224accb34203d5a765105f6bb115599fc90a96480a86f388511ebcfa8822d9fc73dd892f2c4c6c33ca6591ec62f37ab7c2f8baa0219eb856c7615bef5dcc03cae4792dc6384f378c4fa821ad6c3d169fe2c4f24eb26bf0cdb9e3815d460c023fbb16f23dd9f29fbd535ff28d6d73dc30630ef1131d85dbbb8c15e4d127401273dabcadd388c465ccfd2d442a85c2402be75a0e1a502f4f5084a0f3e2e29c0734d327490f4060faf558af3fd49c541d547af4dafae378eebc54645f42063cb2c0cbdf71fe5e2a90463f68554b89a8d3481cc9d9dc996c4457b8a59ca8728fe186804add7d504aed7cf62c26cd04a3886ac59f91062bd87e14dc2d51eab7726d38a1d1a2638c640a152100eb52135a36c27417709e2f63517c87bcb5b3c36ec6bc080d7affbec2a589e201e8d44b9b0e5c90f429962aadad4a879f1fa3c2f09a38569a81ba50bf0fa61829d49de28f56d334374b512ee0cdb5622dfe78ca8cc6b1a8db6352d10f83b59a05a8810f9671a5ae4b705726604964ac8882e925dc1a161305ba6da4d6754fea629cc69570185932cd77f7f44ab7459879908469c4f2038427d8c71412729a8369ad43f59ba1c265b8e8fc606e9252c009cfddc7371d437c7dcb0a5cc4fe35096ac040c4d5bd3d430e3a7c4a5cd2ff8ade5dbb6d540ca4ede9d75450ba32fbaff4fc1bd34c079c7a438eb8635c80b6f388189c12e2e737cfb259bdde0c3b8501681b15212d37dfdfe22b2bf796e487e5c0d2c9e61e4c58b7e4cd35ac66e6a788d3e51fcf572f07c21360155e9f77a561ce481205cfd779521693ae8e14a3164826cc65a7893ce4d76bf7478bdb9dba316c3ba674fd216811d67a88d4f500c5e059ca93430c35b10b72782bcd163a78a23f3ea39ea59d20b36e9590c36262a0d08d7fe2e42bb7f7dea387f838d2efa4e633b133e0ed7fbc9ffeb55efe5312f6c77b38278ccf8c949739adbb5d2ce22849bed2f80fd15105cb1e00c926e3bbce7851720e47376fa159819f23413a9dfdd2d305b11bca1f30bfcd9e3fe38f90cf783c551ff2f92dce0b897392651bfb72d5efbd192950496e09ff0f50753a8dc75ed648b6d5fe4818b2cda76f2e45138e652895cc808a83e12ea9b077e4524381b2da7fa5000f5d3bec1b851893bf89091514511c5de2dc39619fbce3102144d03baab49cd2a24cc7004a55fbc5975ee20883e41ba8bfdd8d8a2b2fe376a359b5759094ccba473ea819dbcfc32395eee12e0f7a11f445b1188fdf6d3b178c1ef7adb5815cedb6f130da86da3aac2076191603db38b946a44d1104c0adda079a3c1d275e180bf41f16c5d409bdd9566d66222d9c66c536817ecacadb55a612f03e656216c43b5b3bdb0f5ac433846a49fdce795e3a25c7807b89a49da82cff3fd43da0dea7393f6ec122dd617f6dc9e9ceb0df3bb43c5e0f2543f78992520f93bac8fe7641cfa62d38da38794f9fbee80fd548c6085da29528891efe4db522b827d9fdfa71ed941c45c0ca43ffa2ee58d7e259dd6f12dcef1240c2bd728afa6b8ba9c8ae158446927c1e865e0d29d7a7eebe4200cae8b6fd7812d014982664d5a0ad621042b0b8602a52a42e280085a0351bf5ab26dacb5ae75f2af8e2aa62a1584189c66a22f23ba4245a123ed38f8df542f5d1d68c79791c082dffddbde9c7bd278c9413f88a3b2a493642765600493c193a632f32bb8bcaab8f94504f55e0fd7e10908abb3c77b64e3edd5a3e94e0b9f53789786681e3fd9af2cb51411a8f62cb42fce07d9f222825df995c105f4a8364211c1bfd8faac95ee4f750a51d4da00d03ce8c657198c09d8351630d1212e4f1fd19eb59a062429bc3e2f6df0dc15bdc607b03596d7008d651c0854ad9f38bb174426399101dc7644b5c25b6d9428708fa41fb301c2c550c0140daab66843d43f348e80d051f86744ed1f4adaa9b24298d83f0f93f608a779c287cea97631cd0af86afe8b6f67ae570b628e57298d9eb5208ef117d92d52be4096ae50749c3efc6207ce4ea15a572051f43ca9d1fed49b442f0c33a577d4f378de84260dc02490086ae228608425b6ce5e7434490b7d2d148d6d47721714f9b1e707daa3d0b963fda18cd36de5062bd7732e87a9a9664dee131feb0d81afdd8b8f71bd40e570f2f4b8e1e450e40b260c13821d668242606f35dfc01adfe3886c407c8c906d59144ab0f94f5101493220c6e6f1bda41aa73db00778e21e7011c0107b6ae52dfd2779e4f64bce0ff69df3d6c05212df022b918fb128847c25162b1ab2424cfbae328ea6dcd8f78c6dc002947a4fd6537e853130ede7f0c0d247cba255361884cac64d53518e1efbd73f03fb7938a496dc8f176e75247921ed525a3079e94eb36e062580da19c1bc1cf44f921e9ecd493a64e6c2b2492c07d160ad1be21d15af412de595906f76ceff4e6103dc83359a9379edb3996c02ee8149d76ae34fd0e0079f1c274fb12069807b136befeb9b544461c3c512a6bbe14d6aff15375bbfc580bda22d83f4e6b1986a1c1d7cb8c0e2fdef8e1a99b9e6b4917343e46e61a1c421261fd931394bc2cf27b550f16452f7202e92171525a00259e32a50f3b58c63e32facfc97dfc20b8c167f7188eb8ec5f640d454310b9c810cfe13d01d2566305ece9c64e0684540544f4dd04492d19fb7b2d5de49ba64dd13887f9a0fb1109ffd145434f90ed0489f48578225d8567c2989b41e0fc41b6a25bacd8b6602687146aba8cdf35b3dba7904a45992da386eaf23d7a440fba9a0f645a6616e23eee6bc15196ffcc905385af63c67a1571a9e62e9665bdf90d4aa7d8abe0b06ec0f6db6486044b5d6cf6d273d5f8c9278979e92871fc7e76357f911e9fe42e87f63958d2eac73c3127a3918dd3107790fde5dc605d3b2a2a3bdf5db2a51c293a421765ada5eb5f81295afc45f407c2ec7f580bf091983298e358fcfe972a53c131eee271f702214946c29608b7d8740785861ffcbc2a2f991354240b2018856576e92d10582c090c0cc7e34ace9bc740b1986f5fefd40b777dd49d4c286a85c1e04bff0a85dbb204106d0009f86c77fd9902db57e571fb8b02d75ff2e7a4e129206d053edd823e3fcc4b11a0e50a993b058e111bf0b84d1582a59dd8a6d20a61409bd80fe784f3a90a024accbc6c6aabc870c81a326eda42117d89216ff5e0247ac31e446b0ebf996510af0f9b733d1bc8a6583cc05d8719c538901d9df7303cf14af135cfdc2b44802ccca0b8f90f71a6020886791be289bbd4ff286895421b9597d8c87e49974876e87c3ac2a35dca73e97ef17264301c7bc6f826240d559649c67359b7acdf49faa71bf543660646e9cf5e64a28bdf997f4a0a369a0d2587b5fd85106a9ab2bb6ec2f3b9a477c896cdab2a76c9d292497044879bd4218a2d75087440978d014348ee65fbe63927ce941805c362a29f8844651eaebb5257d91ae0b2507d7e5afc08e8c77f8cd5b01bc5a4d648433e68c7415d7b284299b92bb2db442b26e176a1e656ddb815ccc629afde603cb8e85a353dec7839f4a3882b95148bbc2cd44406a3f4bda4a680774a144a9de68693d1344722a3a49619d15ce580c027f7b42888bf505e968d1636c7597e836e6aa2cd040434b29c8f1cd94e982eb61e89a05f3dd043198c6f973b90961225f7cea428093378f39d3c666adc19ec5c7fc48cf4f736cb162403bbc23fe983ed3ed386e1c6fc098aa13289aebd50b7b32e4289b8a13252ca79fa4cd7999246df5051277dd4c343b702b9c2e66fb640feb8b412a07087c8191e32627e6ee5d1abcf67beb5f4b9ef726d0a4d7242f9b6b1a2fa19d3a4d8142634b49be6a3ea54cedcc46ef5163606c43edc5e0ddfe1069a0475f5943df7b68515a94313c9cdddc5548a9938195707fe92dd5e02d6a48776921b8af90dad5962d6418539bd9dd042317bffe8d251fcc6602f61057e002f7d889e0f306ecda7ba9d21f7e49997be3bffe767abf2f655bb3a18e55c323e74b988eed684609eefaee921ccd58f5dd1df500dd35da621a06327ae55ec4d5a6198b8e5a6f5c60816c22c3a1036e9128923c9b93b002496fbbc4581bc397629179090ff62d1028050a511eade1c508e16828b25cdaaa41628f20c795d66a322f511bf19d02b84cc0ca2cfc95a6daebc9c43b76298f202dfc1685e7fbe9ae7d88642dc1b7e3ab2168b28c915760d9b8b392d44615cd488dee50f2dcbed092bc9bc956d9c191ca7331ae1ec0230e337da1a101d3d12d868adcc9fbce83dd32eacab31d64d7bc4775d49e3d49c53034335faf473b9db22c85671fc8cabaf71bfac71a8d30e2b431677b4590341cc8df7784caad131b9b8284cea04386eeb6c16b7a458f5786a4a530a6114c3cb9168f6c93f9c37b4028fd9477d3618d06b842a657ce35d5837df1635c96c010438313259e7564a6a0f8c6436fd6e1350e6dc57f59a2e4dda646fce8eb4ac75ef9cb2b6264de187dac68f46bf8ba414b5cb62e1a6c40b10e7e9853ecdf31fc0b393ade8d7cf993e4fb418241bde25ade6f667ee678d0e6e16675f3e4a31bd35f2d6f6ed58b20813415db18433f4ba5e2504b1ca6c6f55939b7c4a80bdff1436a22c5c948b2989c19351038e49614e4059cb0a7caa4bfa23c9f51c9bad8b5fbbf3843c39740b591ae9b807953fddecb5e5d6199c84a55751e2aef8d34a2478786ad47172736bb711143336c81f3046f955cc5c6281e3ced0211daf163a6f72e4667f64f764ceabb38fe04f7a5402a49432b681af1308dbc8b5e009eedf5273723e7b441386e1f4641e374b5a61cbaeabb8555ce8dcd75a9c0c92b055635c968295e514f2eba75a3712558683eb2fae3db20f55b9d3de81e9e9ab8617c68a5a8e73eb075234def7f85c8f123b2500b04c545fc6d4592d452d94710ebacc5b7fd5ca7a86ff2b4f65f05e6e4f4851871a953dcd9e847ce25892d46ed3b90c8f888360306ffc89ff4fb139748fa39c327da3736b0a66fb8a222d0c41b93cf3a849b236d2a5e17cf2c66f97299613ab6bba0de8b748af2560b05c7a78893a4b509d13f115b3652f413bfcc372aa584d4f6235982284e77f82d5652727c198a05e8d2c9d440d912a6beb794239cf8ccab2cb1d01b07455adc21d608c7afe95ab64d4694d0b2cb334b366193cf171f182a9c23b7efc8e70d2ee4e3f69f3eaac9364cf23c96855c9037cb46ef6e244e26ae19a32d79e60d976375bceeb32172f1032f36b352297d32057a2baeaf1132bab7a402cab07e491592978df88da675e849e22e0312e2fdc227125cfdb17055b8641a65fd1cb606aef5dd62c333fdeb9a55ca0ee3e51e0cf3b07785a34600fe6975f154de0e404b40825ea48b8831296d1a17d2373d9212ee28153bbddd633f5cd43d5ccfa68c544943688a71b969027700418651c2e6d92df4f0bc58bc807ce53d543cb261d89319995709dec60c0a956be271d37de652923fe18aafcf8786aa3a272aa0ff58e0519e1e699188348266607b5d3563daf3c16554cf2e658fd8e1ae3dc141d01c05e295644e8a471d6b2e9ed7ad47640997e46e803b3a75a7bc12111d7194bcb8548bcc680dc50910f15037dfa39de7aa7d7abd47ed505164792311641cc4dac51604f801e3794e62786b4b86c7248c415f93145f145f93a3610af6cc9b5668df51fa0079e94bdbb579c8f5e45cb46e243c791a377971d5a3337d894e6e1e4a45a9ca145de3b633468c6c10ad37d792215eecc907fd80cfa7c7ddaa0c7f6fd70019ecf22fc61087d66da19b5e9a9b682171ed52b93c70c3e93cd6b956bf1960f0d1c40398b2b6c049f7ca8473a6c2ca147f21073e04d873d75bc3aff9b33376608054c3f68674f3de6d8bab682e7185a617bd72eafba027197f4f0e86ebed0d8c27b823ffbe33322571656fc94e1dc9f98817d36370287a7bbeddbf6851cdb4695d836c2a0849c6a2e0a483c907a28afed3a3d403eb6a9004288eefd6f156e7bb8372d51e249004a1cdfad1899720069b690b1f6ecdccb594f1c9fd5fad17e10926dcec8b369fcd615b854e218376207a736045e66e2cc7d46d1cff5d946bfeb02f3ebd3d16fa74cf18f633671f806e6bf4667613140d9c68e558783dc6996a1a0e40b992926685d73e61ba4ef1f5bd10a7eed929ea5ccb6eb2e305c89e0f38e35f617985fdf1a34d747f9835eae099fe50b52cae63e1053c49c97e5467a330c1a19cc66efe41abb2254ad28ecb10a9435941d4ba7c4da6eefc00bf423cad5696bafba46fede37e25a923659d2cf33b8916405185ecfd6db06163c2e12cd2e2eb13dd4f087726d319ab04ff38c7bf944134d7dea4af63f35f8501e9606db7741793a249eeb32fd4ed9d9f13ac45a773f7f45765d5fe4fc1a7be77774587766f5327e22546b05599d8593c70796966752f03bb81037d0bd6e94a11536dd07764c000033a19c5b565b4e6be974b1c9987574c93f47afbc657eb636bb85de8c3e3f57c01b7f3da9c08d46db8ffd1dc34eba928f057a1480d8ef3e0adef203e5e27d881f00a2994bdc1c25680a805d9904b1b9c29b2162b2f08d15477c0a3d7478ed66d524bf09ab14dd6d76bb971a864018e7c3c8ef763bc253b4380a864266bb2e53e2118b1270579a9b44148841542a152404fc58009de95ba58e273a605e652792e24bd6970de8f6863631b81b2161008a8d5a858a9de719c31f15c65c6d0b42500b486c1d7df473ee90c079856cff35348ea7040e86fa98b3239165f05ad299e443db41e8f2fcf03f344e7a42734ef2daab15bc2d656a648af57c98a1fc126af21c039dd257f59f28df2e253fc8aa88c4254c96981205b9249079bbf630a7436ef16e5afbd76c86fd03bffc2f3c52f2e006b08e9d07ac4f7d4c26cca19c8e377a7efdfd1f7959490fbef485398152c3399dd91c246eb902b093dc379be1047c784008a8878c0a6d3003a7d32e9ca88a349b54844ec627e48418751b6932de21706899f192099c055cf08eef8f6955a627cff2eadc480e1ef9286adad9644bd3b43737c77b5861401ecc043c26aaa61544cabcd99fb58b77f1445742c7e6b847d32a6603c187ce560d8817d0fedf4bf1d037595874353cb549edd018659917e01386b4e10c430341ef10537bcf0cef3576af123f4aa23fa43c7f5ccfa08c46e91c8d1aea5587a865b2a76c2d63b6751ed9f2fc67cfcc79db5922075d2f51e6faa2cdf7e21c1034928229272949d3e06fa9a7343cf4fad683ed49e15b8ac14e76d952627bd31b0855c4acc473ad3049dcc0d8df078963de737287d76820ba16e4cecb27413db5e5163757752ef3ed1083e5a374b5e417de0617f8e8a496404f727e027fe218774f42d9139bf919414cb6b7129a8ab5a8bec245907d4f2ec901dc9f7b9e9aae20d3b9cbd6a5134ba2552ca9c169b0106df2fa3028a6113b258cb6bd6b1e4416f0182aa45f4159f1fa26a84490762b70d23ac3dcdae441092c59657641eccadbf15ee35b6c9860c335717e8ac6cccc79f670f7ad61d020c27b70470a8bb4ee114f348522eb422641e39b95f4e2980d547c08be4fbfb7102ba8bcee2cd6238c1f758f4bbd54dc4c5d8da2540a580f64ac2bd5f1d44e2a2fb8073d53b9887f3541e57ffd29c16ac50fe63e0388906cd3feb99d1568f7a8e217673e2ff00255dd764640c9495d18f9cddcee7cb717ad8e24213a15fd2b9f7f0ba7309330a596e5c7acc4b78cbc40e7a645e3e511ecdae499e2db772350bfb216e26bb1d305c0dd55cc9be868503381de0b7b5dee1a0a72fe2f03799ff1cbc6ecd6ac7238309429cdb7e57ba02eeea1a5e55326d1075c25e59fb8e0ff95edde73c7f525525cf7804db24ca6284030a996bcf212cea7e0e261f105300bd7a625ec47dc59ba6b692030aedb5534139f935be257376a0b62d26990bcd24e4a2c7fa2cba7ece5532320a2d66762621f45bc42ca61f7d3f1e4ad79dfbf7f31ceea0de8fdbed1d5a427fcec2144ba84ea25ecebc082fa292a8849a3140463f12210582eccf581dd0b9fca2c7e2b15b70909d1b75bbd354f2c77de378f0aae53290aeaa1ae72b90570c854e009d46ae0b7dbc2022f174da3028c639b9a1f241dc69ab63263978424f1a807f5eb6713b23bf381077623e6ddf489e5c8b500f760626f65cc41cb4f8e95ea18caa5f2ed34e70838b909a7dbce07b2af67aa6da19c1fa584b698791d2fa42b482febbd0375cd8dcde3b5ef47cc01f5e96bf1989a602dc3f3815b40a2503d2f26f4188b39e0579b17675b4490bcc2915035257ef6e6e9205cf2936e2d3eda3ab607df5ff2c4097634c0b93dccf7476f8b09ddca2f6a165a3de30a05a306b8c3afcccde85a58ea7928a69f0f3fb65f64b374ea93c80d3a367dd59642f1a35f8c0108653e7afd0c480a1eeaeee51114e9376fba273a5fdac0b3dd9e9c9bd722f152506af161d44e2cc748d68c5fc01424497a272015d68368c286a8d90431f54c752bc57cf5171355b2973bdae387dbfb9eb4a31987f5ecfa73a49b6513dcd19cea656a3e2e5ad731e545c9566828a070e6304afcf7ae9389a39067325eca03c52d02e09ac624696e00647e3757820d0d3e6e8ec0a3e09c45231149b7ed6208bde31ae44617e1a21db020a934032e049f436c7e45775a3de8db7e7f91af5d829b1c0fcdc9ea5ab93ce01ff4b4ea247e18db5d22d1be98224a978f8d08395db0d352b22f87122e1a9e0104b7faebd9ae370beb0d7336137466d9e99cf77b5e398aff64420f9c6f950ff72656fa4b0e7a797729cea87c2c09576eca17b095de45d9771359053805de133a2aeabed35a02627c10bc72cf9c9b54cb914617708ffed7a735d73974fa15e1375fdc6251d5a0ff03b432b1173c81919377b4f61977bc29c70e21a614f0cfba1aeade44d4495656b110b6d4501307443a9246f2c2fde743dd04a9d88e80dd8511683384039890af78aab57c719171fd49f5a88c84e585610faabffd67f92e0186082bc7a6e0d4b9bb461f1c7b60b6e9317165ead26d01a9567da3fcf2a5ab103a31cfb6eeab48d44b0117356e0c73a66bf89f5cb6714fd06c67ea6f729e08bef6270018dd77ddfefb06825c549c6a4a388115ae8575d042f60491eb6cb55c1da771feeea3546bd45e6b4cf32debabbd85864a83cbfc9ac08dd48fefa93340ececbece3bcb5813ddd1acb7bdd2a3adb3068d4687e2259c6cd0225f4afceede2827088174ab2d91dafbc908fc5fd75baf9dfea94f860d784c61c6baa305df5ba7ce1927e3e0824c4b50f2ce19fa56c50b0325b9a9d371cad684dfe56491a5838c8d90f4194db9e8e5e5ba91207db4a09a47df11d4458413a0299bba3c95698a483b2010c1591932ab67023bbb392405cf7c93fd4d66e2be3f23bf26975d4f093d1ff6e2249894fc099da169ad03b1341fe2f64e5c77659895bffc276a4333357f38cd816571273ad0afb3bc302a526083025793d1dcbca178f9ae5738a8196c3f64472e9a80f4d8d6180a8a84d98ce5538dda4970eda324178939b0f19644b6b03b8d434df820edf789d69220c1e8cfdda8494aa16fc836dcc925be04da8ca8cd4c1d9c72b301603b4834cf4dcea51a630e36f4d4e227cbe97dac9769a9e7f7914c2cff0d737d6f7ce9c4130e4868840e97de621a5fba48f8d97995095db5c87bc9ef70a1f1f6be5de822e04e5a990844020ca1ed55fc08e1a2b7f4f79217eadeedc5f2c576a6f3713f7b053648c54ced257b7005d0350ffb3a50ef8791326dfae21934026f6b6cc69dab2661b3af94976f195c00b96cff7b0aa6e475f2af30427d2ffce2408669f076198619d0ecbedf0b96e36914a53a4361791e3805aa97ff3b9b290f2281b0f3965fccaa0b36bcfc5e35be59bcd42f618271528c655db48032ebeb166ce331e71c0b30f64ed2b4e7ad429049e794618968ae914261da68a06d98e829310203e4bf7aba376a079d4db7e51098c1b77f1cd1142fbbc238e66b52996184594100b7ac597c5ec2e6c94de336e4c34b2c5d3ce528c56de2102a003f8eb23cd9efcebcb1cc9c2e308ad60d9affefb054e3a44218d78c7cf39ef593ed3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
