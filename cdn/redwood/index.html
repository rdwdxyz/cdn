<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bda514e280601563ea04ab1569a216fa0d62d88f1db07a7056a8ff2d7929f6be185dca50e451f06f75baa9615e72a0f9f44ed8e1e7fb7633c1bad1046728072470e9182a6c4ef493d53fa439a81c93920896102af8c7f48e38de5a49bf9c2dab29b87afd29e8eea558233afb399281b0e7fb25e2297485b9f55c5a40ae3e6f5754eab5266ee2823904856ba17ba92d9a623f7b9f52664fe55dca5e4e958cad247a490521df65b9db22dd836abefb51a707dde0253edd16a87d074dd4f800894cf85fcd3d122b869ef5dec75ef779782bece8b272e93e8cf3aa27374512e4dcd868c712556bc573701a9109bccada26e009cf025ba8253cc0ccd164963fdafb8ce685bea382d946e33f995d6cf286d7bf3475e48b02ae282d7d8a6033ac01fae0048a6f35b86826ed7f59af2193649f1aa203b633360f0953c79958ac998a440155fea4dda3aeb8f4a6b50bc09abbadfff2e3549dd2c0acec2c3fc2f5e6d37c99faab68333521775af8752792ef92d9cb7b36d553be70a490fcaefc6584d7398b28e3f52cdcbcbb75aea6c3f9e457effc7d7ea6fa951abd304063f43f0361159ac7551f8be4c62461364afadfb9dc76803d202a3d36551782a2583dc6f2dbe1c488818dcb03063562bb56dff400bd3cf5c7576f18cc43fc15ac03564e13d5fafcd17ccc1325893d6cfa8dd2506271e1debf5bd1af1308aa5d35a9f8dc8566a40d6890936b5dd791360a9eda77a9fec5d1eaca4bd394aa8e821f2b63de4aba703572f87a25c80f19089482cbfc71675d3403d193738e3e0c6e0b566193bbf7335ebaaefa21bc82492889b72092e8c4abf669c77d0d4f607ed4ef82a55c6ffcff72972ccbeea120d2f533c384eca2c90650e735a0e49ef4fe57ca921a8056c10a71e3a9e1594d42d21bcd447f2ddd968186487459e14c3635e9fc27d585e0c00ba7ddb8792ecd1504cd85b0b8d87ab21ba4494fe387ec6ff95376cb76196a56f3c9fb97801043b5d3d3a1377e415247968d308c62792fae39369db9e5758358cda1653c24b6166e0678526b1d0395b5ec3ebf201feb9173ec5968a611e1dd1e16609e714ebd86b280bbdc548746d7eedb6b52ea3aab407406aebf269a7faf3281aadb8cdb947a1651cf831970c7ab981fdd29996b7d727d8e49160ecadae8d350bd0495ccafe63cd3727c6462566571dcde2f7160384279bf57a9e74b33031a00e1ca687fa0ba1a6cb64843f1ced19c46e7396e5545367f6f2d024f0c39ccdda6fc46d9dca20ec3bb5e49bd4b7fa4f00e03704b37ceecdb52d6f412ed3393816944183779edaa8329540c643dc045edd55a6aebefe9000ecce4c153814434b597bf1e0152218388e79ca32491ef16d951d6d6b6fbb1325b961d456fee18d8d0800e768270caf8d15f47cd9ff481f2c09e673f2959a5f75c73a898fa4c7457668ff8e2a623673ee395fd08e0647718224e21106185cdf02ce5050c77eb40bb84e12d1d357c9e7ce180e930861a945182d3e4278f1ce7fce19bdca785ea00f5a4178008f56d42ab49e4e13f2c905a832ef5c349973e6c0fea1014eee00d3bc549271e14351fe0001f112fb074698aa1f09086c461f0e756bc5a00a2e0f5b295dd933a11156992968fd5e169f3cdffc33a8697466c9ac3649d7e5f2ab9040eba29a55b0884ef5813fa2e302e577152ee61534efc6c9ab49d55aca00e54326db0f200d4cfa87e48e73d556a589920ceff90ca6a3dc2e2edd93785c59cf2f8c54458f9b98e23b268a0a91127ed0d3c4f3b30c276d68d676e8b9feab53ce23095e7a71baa44ede3303614b7afd55da3589cc9c877e508131e0fbd6f31ec10999f97ce6a857294d28b4d904f5a3f555a76aa025c37a22da6f37bab69d17f920c9d6ddd211136e177e591b737e105054a60c644535585e35d1ea9dc058659222ac3acce2ca1e84f91b2aad6fe30201a3d1b50454fe0a45a60d42490e88fa3ecd157cf66f6890e1875ca6e42b6729a185b97a7e8a492faf12a25d68dcb11ad062a90535748f7f1fe0cc561e12892eb58575730f2d6630cb6d2664550dfddab37030228e9a92fccf840bd85583ac92f73ca87247191bde8f36518b0fac69df28904d46b71ad58d045a4828456d99ec46a898a2879aceed99d8f6c893967bc3679c4c80f810d2059df8db58e547caaf435aff891087813dc562d885a6b46c54e371e2e580bf3e6bc063a164731b4438ede10c55926da38bac65c7b512c1c82ce42f38f6338ffd64121773fca4c6fefef28ca3fa96085f3f2e97774c2c5192fa1071ca54ef9c765f469e1f584a78af13b98a0e0104f768419a9232f9704edb87bb695bd7b5940d05b8137163eac831bac160a6ed3864fbdb6d0642dbf50878d661fc1d5fc716438fc40582342c771579cbc177af72e6909d2a379027704873e40b761a6721f5c3490a70f8a085b6696b9a4d42333811c55769a4146f4dd6a512b4fd328b9fc49b10b2a9d3b1f7fd7cdbc823020ecffa7d559f8d9fd6c7e9a88d48558d7365735b5e9a0d233f7363cd8d123c1c2913d004fc7483a820bb68bd11ba2df40b2470e5ae14d5ca07f68574723c59c182d6c7e98ebff7e56be3f01f2d1bbf408efa2400461787f9931933231ed68b1a034511340b75649c425a2bbd2408853f411b3cbe2d915baef89e75bca3370f3d61b50174444af9029dc149ec80ffcdcc3aa32eef07340173f2d43eaa667936928e162d05fc4567ad05655f86a5835030d973af71d213290065542b721bd2aaeeee5367debae1f93cb6b42557c279a69061198f2cb8a4e3565a68859dee8a51e6fe49906ae81060a9d67daf7e9b57cb3a1e26bc8ecd827d19ec0e2ae98c1a20a222f89f65be44a98b131356a38bf828de0224d7655c26fff500907c24287aeb3375368bcf3ffc0ec46931f90f36b0936eeb75771e7932dc3a68d6133d1d0ade8a39969c2554ceb0dd4719e3ec92d784d63f3fca00cbdb2a7a0289654092eff76c0f18a06ea43766c4060d15ac8671caffe7e9407d569a4fe31951b0f92d3ad42896abcc8ec7be305788517fa9dae0c869118a2d4f450ad0ecc39dc8a30ee3b80220c3ed7a882293ae58857042846b5490ca917911060cbd8f1fd69a8b54593b08ec9a9effcf49b0ee45d63c46af1d72fb0ae219e92b0cc8cb42582adffa0f2a238a7a881d9b84cdca39b10e744ec0dc0999e91a53156ac273f0cdc46ddb544eaf6519c3e3b33b35d40b897b8b6d14601b156fe0b000e29f489345336721ba82ec95c8f41e4546a423009607ac518228340ee69320a8a709029e61e0a35e33f2e320c2017b44e1ee451b38c7abb36d842dde81bef5541fe02a418271ebe22c6715357389c1ee6e205f64dd8e4b19daf635eebfcdea4ae8ac93c72e34ba7d2a31cda889f0b9036bf4e33563988b21676e3f57aee4c6640090aeaf5ebd05a7ccaf7db16c8d0d67cbf6ba155d182d2ea6036ce616796d18de9a77f58678df1efc3359ae5a3eac82f9d4de7a141aafacd51e275fb12d7b1094a78f45b3dc0cc5009f07599bd0b89598cdec7bf775a20817bc06cb17124fc9b12ece91ec5ff895bddb333a93a987a2469061063dffd70052e893cd69497aee62c954b1209efc5979768a1ab95ff6d3c1d657933fabeac2665f10b28831179453463bb8a4603d7b2d95599acc28eff98702e64e40ea0e0579a84b86fbf3bf6f3306d9ffc128977c5cf0a40796f0d5597cf2a14af9b14f92ecf72aaa249f5d707286f082e18b330f68b13c29e5cdcb977b5c5e562af95464631e4d3cb6958cfd3b51f293009389465b01ddbaa97b9a3475983a5aa1fa2cd2c1601cfc8b0ca1c67543e08bf744b9a1344bc368838ddcdab1d148539202eeaa19a7cf8744afdb0d836746ca93d511078f1d63edd15452e0af7bbdf3c85bbf3848b831e181293869fef5ab210e2a36db362d90678d4e49013dbec5c5235ec89d07fa1a7ff9fe8503fc4183f83ca7fe34fdbefd3ac385c4e5c5f55e70ec346f674ba70b78888758e9fc66a8b243d364a4b02eb6a288a667f9b2b8df1ccdf5eaa30782c8781bfee23fbadb77ca44ba1bbb17f2fe405b53de3c3b25652cbb608b67d76f0be69ac0a6e439e2a29d3ebc238139a5e80ae7217ce0d5117b33f85c138956a77f95ddae399166cee300a6bafe4777d5009afa58e156ffd5f367192c18c16589c17b58e228bac5b619de99b2ed3f01a0951aa72ebe963a3c8a914a782a3f2708fca51eb5f1091b5640b80786e5cb61e1dc9dc88f37038cf1807d65853d5e6c2490211b04de8a302c39f23439675e48afd538fb88b23c77532db40758b2247777e115e1e454a177504536d8a49fb85ce6eceb99434d13c383403dfe4938b778834d125ddb7d26c0a2e620c4609fd2e7e06b52916a286f50e6858ddedb1039f799b0a2ef98de470e165fac3ea438c29b325cd29525c55f5c65d0e81df329c90135075579b329f0c94016e6cde5a7c5d16ddbfafb236f78279c93ec7b5531a0deb2abf186969a212e442f898d03696bf685a18044330c0edf33c10bbe845f809c3f003bd7425c86f7783a024d3682c24b86e8e172d0c5f5c5d14458d0de381b87ff8709e3e3afda0b54d7e49dc9e651e22cf66f816b60636add9869f7901e27c842770deefd3f39d4460378f18acdd8369306660d322b5032b9529a5f83d8ccc9ab3a5b03fc2e2ebd1aaec35aaca77331b98fbc673208eae2a5ce93af2560eb195421a5d5b8ce460cbcc186d169fd481e0623bec9ce72209d819a44f7bddd9415630d22bc3d802ea0235daf4ed142d400af95bf00f6e290112b1e9009a3ec247b97e0d94363183a256da25fbefba29a2c08a98ab833cb9dd7cef47e3cadc413d32a09f2d597e1042f048cace3107ee219ae9e795e43e048cc6895ef17df4b40b7e735028b0bdf92b63ef670e9e898d82fa6e5e9c81c519323d9655b3ecc3e04ad86d1e35a73fbb82f088755cf834cab52262dd6464aff6933b18783086099b9d94697d93dc0031c29d31c35ea664fd5a39cdedbe6d637c5a855d89483cc522f1c487372e17d2ebbb4d315c534c88d7d34aa91cfa591a72b0931022be4879fefe4ed6d519c89fecd427cce7fec3f25294f8ee67fbfb9aa8ce57de4b71fe7a9e042e5ff400688dce8bdad7bcefa544103ad37a2ef5fbbe9c08f0104840ad8d5d81722a659bfa8bb3bbe7eecc13f37be31348485f3ac1bd3b4966005c651722277126f9647d0251cfa67e0595dd0a67e6fc70df008c063ca7ce6f615a41f56230e8637b2bf8ba677181b7a99aafa3ffc7b310bd645ee66b239b148a0901679596dd87de9e00c9613903630972ba9220a0f250076b59c09db8537cc43b4b69f6063e2d901a7804fd6bc34901e27848090bc3d645bae7942689fe6245946831471183152d749a98f3546e74738741e51c96f65738f8f14ae62eda8780d0f2408a31997e5045c0a0bce9daeeb24078f1c601c23845fd74c043976bb381feac93320c3ec9f9d19fa9fd7b28ad97f9b2f65576df4de0d089aec942947bb90bb4abda9d46765bc547adb017a37d3ec571f37b9098b574ab947c2da68feb4f02e0935fbe104691b13ce1ef4cdbd7b337b9bf45e3249fdbda4534ca016bebb31a19397591768ca8962fdb34ed6775115e9468208fddd5b19323ffb844f8abc95cd65b8f1f9004b57c6488c307e95fcb4e26328be595a97c08195a6eee525019e1bed4998bb6e2edb08776e596e1c698dd42ac05f9bfdfd212f29b5d2cc9932133496468d2b93e682cee0b8fe350fd8804d25883e69789b75c694d94912a0f66ec75b9e2ea23115734cff02fd326f6a136e139421d4fe8440c35d8813c0d2c2df7eb8ddf316e14692d7313dd6739ef26ec735473d49c0fcdbef0188ecd8a35f6f696324a230e40b336d5a0947ea46e1204ac2b6584bb61665c74f6c68c2ceb74bda9b1161ec7d78318a7aa6ce79103a735b57896090c71b196c00115d0dd83b42691163deaacc4c63746010c0a8d7f56bb7a00d4f9fcc7ef80cb7aad1a62b37509c5877ead79019aecfea7aeef9e679e248b77d275dcd1984120fc4fb48d6e6df5160726d3d1b06674d7236703675dce72a89cf64faa11864ecfe50f5969ac33b5ce1a802547456578a18215dcb8849b2c76954021e871baf52f7b637f508c07a947daaf477110aad71f24c8eb8ce3e8de714573e068bbcec9a62843aaa58406e1720614c5d81c77b6946c058d3555b01e6d9a25e225d76b49015c61a8ef4def399ea7c93663bac9c89029d54e894be05379d7b6420e280ded72b6c393651db2f8f1d4de0eb5207e4f35843c61980fb5d3197a4c19a671f070f6818497a23d7e59bee2107b5f75c257b57486c975e3e01c36c35853acc131a21e3416c037b426961269017ed61f8e32b1d477505f27bd191495f4e1b88bff2e0b0191c3186d9b466f46ca47d1389d9738ab590d9f107bdf316e926f7ec7c3634d7aacbd6d67634e2aecad997b0ec6ed8082bbadfbc3521669e888a20b477b77388290bc457ca51837c301e725dbd0bdb7b263ee701c95f0da3fffc11394b3ef4ac813cfbf86be3f58335739ead6322427f17f8769d95c6af267d8da44914fc66b7cc45ca150cb4cd744b91da1024fec136515515143b3e8d7e0a0e8e9d3de92e9299e60d5a8d8df886bb2cb2594dbfc2896540eeb81348bf8db26fdedaa00391c300ccc53791ed62f11f6e2560d8ce4c47d22ca6a3036aebf83a1c99dfcc042bec830a1d7735ad5b6f7824c021d095181299f50df2c6e84e269d1f62271599797366f4da25ff4ffd29d82de88bc435db42373c00cf0d81476d18372bd85e9711e280ebdc28306c3c0e44ec48dbd1e529e200389ea57252d34a68270e1bcce416c3090937b588111dca06600520edaa519d1b193bcdd2ce6e558d20465a1936c339246dda041d02fe76683d0fbbfd6d5e8aa6af9813ed34378fac4a641792088cd6823f9f37dfe53444667d69c8891b040b503761fb0aa6162fa345e44443c81f416b379134676a4c5d1dbf38111d585773cd50c908ee57c8c1e700ddf8e2ace94764e16525204baf561dff2a52f66e7393ff615b2ce5616a8c015d3df775782059b74b0266570f7c414ae48e2ead7dc78c17c3bd7938e7025b2b8aa5cd688162e76368c35f44147bbc9b752a30556a5101ffd1847cebbd362f54189bfb4fb0c6b43355055ee7b53e5a79b876e9ddef852605a20312c1d50e9c8d148ecf5ef0a63a19a26dfd47e233703f442d7fb404df99bde0467f8f495a03510dabc84610fac09f656b1a16c718a4ba20f67ceb977abd645083f9cc57ddc2058a358d1eefe5dc28124c48ab24bdbe01b0b72281c07b7e3ce46f5c28b851058ddd690601fe7eb8c864c37ce689b09b34d14b9296af8c1d8bb34f535b34cd13ad66b2faf963bf4073227e96573398128e3929c9f0e999cfadb0bf53d628ac38ccfc97af17b747a2d04dab4f94438326fdcb0a918a76a7a069d925ffdc8bc9d96efd919a98553facc45ee38f51a21612d01fe61706336eff8127414ae4f0935205bb330fa00eef74fdd035e4791fccd4dab5c64f83e37c5ad556572b7a17f659974742c0818fdb0776337e0bbe3d7572f6011026335e8d7e97b5c1cdeb6520fdd0ff3725cf84849aeed8608be077762d8b31f5afae85771ff751a10ef679587fb51e392eb1a661cca4a251a55a6ea81cf360ad70db8a1801438a1b00addb95c5e08df699a87583b386b5b6c7bdcf79ae601a2d0a4b96bf5a63bbcef01c7ad09c5815638a518d5839eaa3cc8a2b2a35f3407506755bbad4d050db4c7868ea97999bd348d3188aa9f3048e78d50af013ff56cd468235990b7a4a2b492cc4989dc076dacf534c03f41f4c1cfc8e48135f0203632695d3168a2c5f9531157f65e06503cfac19a2ec4d99231bea64ce6a1e3603425984e2112a3ac970c57c19ecbb14f70727d0e47c8a4942ecadc22fd834d7568565b4b23bfe1b3fd76fbb2338f6b2e13826a4487dbf846ac42eeccbe27f6026cd97a36b25842197be53b22afaa0a75e18fa9192cf014b4370462ec8296b5d9472f17806e8d2b3adaf17bd27372013995a94c4da3d57ee3f57d66a9f8cc0797883245d935b133b3b07860dd4d769814c7f3163e944dc3c5a398e87ca6d99a2632aed0bf0810d43f2b43287d94c70b93860f619113c1418624d384d4811a68cd07f79da1d75129f3c03c49eebe7c6d003f642100a314da8e983b26dacde540a90f80e0c0f5cd4275cd029d7eb55ed3b945c94ee3930118478543c41917d0bfe8e4c7eacc3ce93e2c7b271426ad2f3c61b44801be85687475afb77dcb264f881c9528fe267a75577624f106d2c77a66f6aeb0e90943e2f453a282c83e6be2aa1b0743b47177275c5c6e3012d2f6f16a37cba2c32d9e24d8cc3616ee16af1a53cd482d5345b080d2d0b186b98261532841e93c087fca62e32a7737e6f9fd928d829faedcae63dbd4d41b06f6127087eabbeeb3ee4870cc50a5248f23978aa94675c91f62a25b3e74a25286cae03f2da03ed3dc42f66f2fa38c519895c246e7fbac5f55ed45c00c008a4b445f04d771b32d1f9d382cda4e75e88aaceedc4c486d51f106908159980cb2f4f06b1d85cc1db10649567c574d0a1a5fb6d3a7f3c7e56dfcbded8ecc5e892a8c92f9537bc2268d527b44937d5b89c0cb979ce40685c2cdc71179db85af883a523c48b64e2418400eb1280923bca67841b59cd2f42dd665f5fd83e9374f2c0c1315daaeccb1c2cc3161e9a21c9ca3686d72149151108687f95a89a8f477e6e2ca2ab6c3c72d00efb626c99856f73d8af82516fb9b2eced823e14a6043d04618b38cd673ee28f7e3eb3c58e55cde5ddb615854cff4e8f07e7d802820505ccec4f4ddd006db140c5af8915c805326ae8e1cab6d363f6443bd6790bd3b4317f1b8bd8031f284d903e20dd514a36c483042737687208637cad71b0b0ef2bab59bb86304d31dc89d6f35b8aac89e248754ef9d6daa7fc4086a284179f7cef1edd2c8051c364135c8ee7f565c5675ffa0cca3e5104d85996279ebe2cc7549b432feb3b176a7417758a2200bd3883f7ee165e8671a384efb14bab36927f7c6724f9139a16efb078d86e38ca32dbd97c9cfe81d27fc2f1803f410ba545523e7006cf269c82d93e5b84c257e12228f9b74dd573746ef7d9e82fb5ebe28b5706bbc2936da2d5a361efdd761e4215b98340780013028cf4ba62477280934469b0ee0586cb1e8764827ee31e6291e4460f51c46e2f0fdec49a2a9610f3342bcd2add1d8f35aabf8b85f51dd634f9e633724918843a2d832ffacdd4c2d2e852b368462618b26aec465d8e37611ee3613ec3b054443641b001ecd556d0fdecfea9554aaa5fee94ff8e4d3bc4da90fbe1aac7605ba0b54914438156942af81fa0c2a52e0f15bbbf6099f55eba05420e008d1239abfa11e739323cf93ede717e918ed6f699ca306e2c7f954ab3408b75e901e0a4b7e27d2819d3fd0a804c1180225104576396590e17cbdc2e1de5f72259284a8ea56986fa68abfa2e22a30a4249a6c3cdd8fc32ccd19c74f8c13d992c5e66c4059d4bf7a7c21cebcd19104949761e5605a4ee8aa8951d425074de5f4d8c4ce4c2b31553e0f1f38a5a5aecdf711bae57f92c0341ceb249d620427faf9000ceea74fddc0438e4f3400bd5a3bd01231ad476ac3a24f8f21434604a0ab343fa1489900add70a665a53a6fe1cf5e3ccdbb1a4f5b0b3c742a4e87fc6dc119055073f5ebe1fdf8ae9b85cefb1af250bc867f53ec1045d98771d7da49bb642543ca0dcb7738b3970f558a202069055b0da9cd34cb865abf1a22046432b03ea6f4aec320fbddfbc49ff323fdf06203130fed256f32fe7c59668f305afeea77d8bce27664d1c1e00e32b76a1708436244c1de90823279ecf6c5f4930481cb937a60d9682739805686df0064c6cea6802757651e6f21a09b9fa24a6c30b23fcc7fdff4c42c485c817a98367a506bf69c80da36a1da8abd408b54058bede2711e438e71e5e8f583b2e7fe43f2b7e69b50857a1d16c20f3fe39aed04260059f58238e32e548611d51106021ee5686471720ac6b2f8dbc0b60de293949b281ee7904668737ad810c1347c13b4c5a3490cc21d24c5af2127ce8ac3952221dcf96601f69e411f87825a04d455df2e189a8d1471a6c9c81f4aee2bf05e04748d919e9174c4f6f1fd063adff9e1f8735f9a013ee64452a108d974b5f509ae1baaa608483dc961e0947b937ff7d62d37c4f3fa380c8b3b01b65fe8aebb2d009c53c523e84e83968ad7af0acaf4c1b9566bb6a0426f85767de5e210cfe8e1ab1dfb5ac29e287f9238aa4e356bb3333c1f2b4dc7091264dbbbff480ebbbc45986819b76dfb4abcf760d6f213295decd9def7c2dd50c101363e5e4310f155a03bfc36987a123f395cd9689d64073f3db7ff1ee9b0107d4f4d7fefc0e2b0b7e9fb0527bebc4adaf1f6d3f5b390d427634db06e10f377139c5e53d6962c5ccd8d61e63f40db2a05a1226dd69052e50c42eeb820d66f4458b1aaf9df2571dea317edfe7c9e2237b731e6b43c07895c53df3c38389bd19be9c902b3e5e363be80f10266fd2225c76ed8f120d4aaa7b5fc51f730de2903271cb587d99513e0122711a0bddeb7618e45867a8946f699a62273938ece10a50badb9b17d67b076137bce9acbb1e80b49056eebbef26abd59ed7f4837c61600357c2480d45b8718cce6ce469c7a4b5940db7acc3cc29de5d7c4756d4544803e0cbe67633714a241c52736e3b00c8b1c979446bcdcfd33d984e0292fbaae55c2295751fb49996337cb4840dccf2d016787375a9c4a54e573a43c2ee49dc0ca4e4835efd8bebeeb3501968af4dcf72d812e92a4d4018d855b914e5fe73daca23f183d48e8a416e823c874d02b1a5de36d7e51e2ad085a9f704b6c8082526c8d5e525c71385496163434d00fad34994ff315a2339718a5a7ef0f8c3394e84af70fbec3b20729b0f53c8d5c858690a58f52be52a7e40bfa3e636469d44a28da9528803a99fb55977223da04f0faf6a9c55cd99bceb3c39439e534a4954ab14327d77717ad2bb4018a3312a3557f84f5b35bba43cf25eb34265b9e5d9c6fc827c214e39f218f050421115d425ed6f3269f3e7f0d4b81bc5a32f80640380c99f60c409dfb5944a0ffc866b21ae0939c160efa9733d733987a061a63a5f2b0a91d2def958d8fb20b32b9a932698709c2b5765438f530b57258e858336b7a13eeb85d8440fca655bf5a5de6f61759a75b3fe27f1f8c1ba7417a29b9b3f588f41f76651cd6cbb86ec20c0d8ab62c56ab21560278f6802a123ac27368008fab075f30825c1d9f2cb0fdb2bffa3c3c8018683c4f91bb72cf9bce9b705fe7f3d212624995f41994f83e7eea5e8a40d0df1738fe7021fb2aaff17ccef46da9dcf5e244493f7e85e3c0525dc29eff25088d43d32ba510c12da2bc3fdb977a6e553cfc59e537177c7f8448b29b7a364f4d6479b21a7e2fc9c81d793d82eaf40641af3e8a1349e680b3e79b9c723e4be9726adcf3f60158705ca77e39ff7a1ce5cbca42d8b0b2f31760400c3c716c9211a60e4139528937e565ec85b5d1c850c96ef5b163b51b3dbe64f0d8fad9c79e4c809f9bb9c6f470b3cd8cbcf52122cfe8b65ee5d463663f86007765de8b5dd3e94ef86bbf9a89a454aff5ee47073e3af4bb28c5f3e9316de992d159cbf74d1a7403e227c9c3660f35729278f58cb0c568bae62e191b935cbed3f11713df56adeaf0c1e391c0f417b473b20ef39600809a50a3d9409accbadea3c2a674e423decab9a37a399946b8299ce386221ffd2f187c23e6b6590d3dbba586960e041ae67195f61bf8281431e2507cabd8e21ee8112af1de1128056600eee9c08be06e895f9205e9167cc0ef287a3dac9510add12092b907d67597eca83dc44be8678990c961eb168f7268f4892103b6f15fd7cb7452b3e2f348bbbbd0ba892d7e0d5c083b8aba5426ed76ff2255cd798323ccb1dea9393f3998a14c488ddd62ae45303cedd0fc7cfb24c566594b893034c014e01e7640e49a555cafcb689596ed0c11e5df014d8e5005d42eab96e3e35217fc7b2150c8c3323ecd287ec7da2f6abd7a476592e3c55a0e1a3906959322a7522324019c39cd24e3bc0fb86677b38b4eb31eded44d725180b87139509d76d3020074802858ca5a140a45a8df47cb0f44a74d0f71af65314d1d8cf07c907037c96ba39b49f943e4183c1135fd185ea96f18444bd41f5a3991995d64ffde1fee3125a7be96ac0ac295aac3158e2ef96d81351fb02fdb4177df3df6a39f4fc048740ee0551e799c77a6412f65b0ac8e67d4c1ec0fdf0e3c12f20655a2cbd75b62f8548f413a8e20dcd693ac5b41172422ee531e0fce5a328faff5095e5d956ec3f1749be44a0c30e62781bf7adfdb464fd4fb0cb69ddb0880f42e593680e2bc7384c842e1f6e193992d5c2df8b031b57a8ff6e1b10271c74dc1c0f4f4dac4c33c4cd97175b1c6bfdf1ad63c44927c2dec5f27577a4f0d8af51fd1de3fd467c56f08c15308b5e72c9e8359bf291dd7a7ca1aab9ab16f38627221976f88e3121340d7f28672d7a994498fc2eb8f5fbfeb3febf14de39579c2b1f0c522f07501e28dbd8217ea473268d8798a702822821b6a1bae1d7616f4bf89a046b3866ad87b45dc2a0ae82c5b310e459baf9ddf412b974ee447b5ab7fd939521cbf5c70fe06649b05ecf7ab238b568fba5e2a388b41a433cf355e94e0a1c466b1b7dcb2665c2114db30941c50381064d2f31afdbb2483a0c4ccdb7701c95d7df4b223d53d64726f5789c28e3d37cfbfd24026f0b231fad7c0cf16c226c364a569372d2419fa02e0df15921415850b47e54bac20d9f523851d28a5391266ca649782d306fcddf2b8530a40ce4274b7008fc6d347b4eedd1572b255c2cd7ad3ca1bf661b1737fe1155cb38593e6dd7657847309407b1576d4c3dc0107161d52879ddc55212202dad42377d09b1411c48f26055c051609d7d632c5883f649336452ff84f3b5f46358954c947cfe3df45c1109e04b2967e711ac2dfb1fbfc639d5b7fc472a970394a7c6f7fcce3d3af49a0617d0c69a4c9cbf4d2dd1371252fbeeed67517d47777a5847d188fdffa9d94f5dbdc99c1afa63ba73efc5ce8b6323baabffe757979fa1f97fe3ea4990cde3c1b0914d0d4bf85a6d631a5ba5a1317782b90bfed24637bd266dd824cb9393154ceffd32982a8ab99f3667aa2da8d8dfd1a542f5a5cac8b5f826489f73095d1d55f68954523f9a916b04730be8a5fc65c37a7c16454657d4f08f7a39e5b8873c52bea1c430f538af557eb44bda52cb2cc5471cf8b94f1ef964225d312de925fbea9f1ee42ff4e6e82002fd9476e2ad2602179b0e105c3b9ba33b97fa38b17a26fa0900b3a40f8123b8c9be50b552fa082d38a8297a916762b906ae5f73bec5709a172e30c08416d690a722641de564873cfab6ce94bc00bc57e87dba5f89f2e8bfd086c6beb2833dd7c3044b1f3d7b7f15118427f3b07e643393e56e34ccfce932512ea20fbcb1fd4234e45287f0dc29db1a49cba649d6869b78c7cc0004ffe382b42a2e33cbb883cde8f50d3a6a7e23a8303d1ed50211ace090f67afd26b492ea52c004ceb64d1c3f681319cf22da50f2b99ab7eb291404aa5a5757401dd44ca44daa418317c5c23cb0a5d44f75f974d69d8828a2c9fac6a5544202779910e7c44b854b7e870dee2b684513b70b94feb44635aeafb4ae7a148a97e3cf10faf7e86409c7462877cc4958587fce336a1317f4eb661839046d8fd47c4c002dc0a49ec1af46571d6756d320adf7647cd50fbcc1bf914ff7215440c8039e39c9c24fd5be302417010b12fe39718a4ecf2f4634ee287f2e0b0b23e0d2778068306959a4da536dd40ecd366220703c12bc39bb7925f53ceac94b7079b4f1f419b1b45e2127f451d721df7e367e2ee568795b146b46ece69c00f1e29e3dc1758cf7b02c753ecdda2a592d6ffbcf55d2560234f7f0f82976f44772d28ad1db90cd39c765382a6a44942f5d201cba9cd32c071619bb040fb1713544490bc51a25c883c28a5e8808be143affdb686d9e08dca2b7a277a3c5eba2e110a3a556173d79dd789cd391bcd8087ff531f39d5d121b10f369b38f0711ba077cf90666dfd5b71f27702bea4e5aefdcfcf4b57aa605919094daa701396a3fbe3aec39069adc8767712fac2354caf602bd65da50c821a6e1501dd34a71077b321c42950395bf8bc1275167d574b228d7535a5f47edf5a6c7a6fde12d86efe25ae3bad5572bdf7d43e033990f3e9a6a38dbc688f21e41f5c5100f729015b6b9028ea2fc154ce217f5b00a008ca4a556339c555aba50ac6d0477d275e2016843c03b4670acb4a97408a18f10648a7181087e0fdb033d54ef6446a3dac2c172d4ae89e1340d6be78741ad085f61c8fe9793ff560bacc7766fca93da73fc33959ab24e6e902454aed3dc4f17283765604751c843b4cc06d6e5c453f31036058b3e0d16ca7def0f5771e7a5a223def93d64c7e91bfd03fc3c52bb66028540fc00b36ab2cef93347ba001d3289c930669468f50527cfbe81e29ab45a260198f74f2efebca8dea7e067ae3f233e1b2ac53f3ade4f3ba5d278e5c192592b20849b337bb6546baff8a379ac24b89f523778c0965b06a72c2721115bce99a05c4e347d8e4931148d1a0ebd6112a87b59e756b687f4ff499ca5d381e894dc90709a82ab2f13d6eda340451833d18a8c015118f4de4d297d7330b8fd0d4a5731c3e3950af7108997d5a981db09f155a8e38aca32f43fc4676af6b022ae8f6616bad684ba15fe76fe2db312690df34fc338237d63557591b62f0cd58b24a2fa10a379929ad7ba40f97951359163c425c2c085ea184ccb8d6073933a53bfb2566842a0f9efb0f61c48d176911cadebcbbc8bb16fa92bd8fa4321e8adb1f8c9bf1ab41df102f2351613e168be3c6d6ac704af9ed8858858096c6415e33bf7a5573e3ee80f947527f80173216461a388fe2422d8abb1ff0219d720e6705b1c2636c1c58013671780ec26a06ba0c326773028dd57d1c8afe6a94b24112538733c27c47462390d4bc1a4e274181923e9816f00f62c7316330d1eff112367afc8d40704ad2cf0bc955b032ddc87358621ca2c983aa102da39fdc5d674a6eac2a7cbee776ade57fe1e6750cf10d7120fffcbc46fffb37cafa6948cafa186a972a3c77bee5c75b470868e40ef1c22c9248728ea583b33164ee0cacc622c2b11973f5848f27837a846ce578f9b682e5437870498b24e1359822929141e10fb62875344b521f12222920dd3538e76878e2d2a64ec69c7b276b7977042eaa331d1245572872cc63d02dc11fa0b139f4944dec425321ecb38a4feebd690ed9603310218599cd756d59c5274e1b1518ecc8eaf24cac418bf98584ffeffd58896fa5cebd4472be2652dd5ef61da902891a4621e0ee7b5a5064461915271a63f324fc36915369f3f36f603a1617260a1ea848ce432d08c93bd28393530b585bbe97e31cbd994b5cd643e91cc89a79ea36b5595a84d0eda02789daf8ae716a7874d3574c7f820cd9bf8d13078b446b44f4fe5a9784d9319ebe391067d97fe1fa7029d71003799a24ca717d0d2c3b112e5c3828bc609fe68fa4b8d649f79bfa9584420a5005e8c2694e082ecb360a1e5a12bd213fd769e4d79d398e5229dbea1c4655929b17a9164bc75d391f3942c48bec8bc0c3c214a104d00ae496b85fe8736a7ed974ab4ff689311e44526116a1fa64c424b6d8fd9a4600d7a89a4a66cacaf84a990eb4cc545706c4ef10c3d2159cf24f32194c377649b3ab9aacffd78f6717501f02dd46f5ddb48c062f5a88c5c4ba40a9eb7df6ef2cb888a31228e1f55e9888e4a03d65603dd5d53e2caebc38d0c2f8fc5af0e17062c07319c97433705e976df3e7d5706540e734fe9628fee47098d1fbdd090f41a4bba1f1099691ec56c1cd6f6e1fc10a56456a0e6b1ec428f3325cd7af98b0417d03f87f6720b25a01779a68b0f0589456a5bb4bd49c687a34398af5d6a6821a2d12cfd489283f7905207f05e1ad50217c631030f4081141d441881c7b60824453c4797d5918d541921aba612b826200b4470f992f856ea15b9743a767d7c295df80b48c72c0d22790311060bdbf23f25b4bf41e8567e565656e4692dcf8037d45de786d14fec1cc4d5a1e945640a5a9123d906e698c0ea6ad558a619b6070acd8e8083902ff5661768b445905a5261956de1395546a69b130a5fcf20642f8e29db4e89374b0df65e1c190b38b23b447528cfcd9c2ca772370bb6423e77abd28a968a54001a7e8601e1be57d487a3ee8ab1591c3a4ddc9bfb0c2229be4f77137474f4135e950aa269bd98956562c34453e3bb0e955cbad0957fa559e380823c03b303078b0d4893c871a051b43c4b0488a055b7df6cf61398f09db24ad5f8f299b709b3e6e20f8961a9363da203f46b9a1c89e9c8e35ae709363f9105488ade308c15c410678c21689cfed22b210af1f140a088bdc6860ae458d96d6b27946a7bf331960b64c4cb1869c6b7d17d87ad30c95d11d12005ea778eb2b151e2b70fab5766a4020593a3a7811b7d17a6370f476c15f6e6dfd70545873a94588729c0b1b26ed488b42b1c7ef33c67a645f8c3f4786538d6fcedc1799ea7525be3bf4c7ce96075241e097050bdc326ae76a32d4d30331768db457ead7930d815d95a35ef90c112d492756b58834a2e585541c7289d71bf6fb3e76acb12b544b5581f7e8a2a97006193d7a42d8f074aee4f3a2b10e1bca5defba005c427d114982623cc50eeb0eeab73605d3ebf6afb4779b6713ccd78be304cd1a16f4f75062369787c20e628397c53b6708517a21822bc598f14e55ffc7a6f70a256aafa0db2f764b5a9b64571c3cadd93376fcab1bcc29b9815a5f264d79d8e9f4544560eabc18d68898e497a7b63cd03d42b4383a08ed3db90f46af426065698a97aa5cacd290d64ff86e1224b4411cdfed03a8b29eaac1f464f520a850c5f003e29c4ee82841bbc73acc9a4f14f766484dc460e0771f176782437d11a30ae88db400615f5306c4e3644eb7d9f70235b5f502694126bdf0e6edc3efcef35c434e89b30e0df98a9cf8460c13f095ce25eb2809372bbea675c091e55ea01de22759344319d084262c7897cb19703cac3442383e7a88fe6a7f408c4255e9bdf648d23ffe49aad04827b55e6fca58af754cd605db1301f8aeb569733dfbef47cf5e55a5a61d40fb1fe0e3acc14e47c7f1791112f6d2e8ab510ee052c546a368fd241b5114b5184f75cdbf16cfab0d67c9720eee7298add8c3543a0de11d77549eb10d3d64b55684525455dfc74fdf1231c2fc5dd121731dfc423affe9895de8a082a65760becfe2a13f67a3c998aa84fcfb47ea78cd9af39d1f7a34d2c11f8a744940d0dd8b2fa851463abeb8ef217d553ffbcaf23a13570b99406d7aad647d883d8d19f51ed43295cfbda0631e44289be39d5d671a4f8e2162e5b107a967acd6d17a89d50c8adafb9dcde43ce7491cd4d93c3c846af20cdc1248c00798e5eb6207052a593b84f38bbaf3a977be017513d5c5524424782cc68898f8fe90a1f4b7c83c00337415091f1cc6a8c547440d3fc5adcb807934a7d112d89f57796fc0e64a68438c6581ddb095704dc3dc0eb678496e8a146b46c6d6bc68fa0fbf14e378a00687f77e0cc39ca0018f22061954c2fd3e80872919581ef5fe0522f5d934280e747e9f6e849b7e9cf73efb47e9b3568cea23f339ee47d5bcca1ac30df6638155771c35e556af2c0a138faf72d0f810e15535e9941372fd4bb0b21b505c5978b63672f50958351669f4116aa3f1b223bda32f1589d6280cc3dd04463557664921d2971f84e85e9dcd261eb8429f46428a05e1c8deefac38c4ca3cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
