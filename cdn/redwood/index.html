<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"350323261b9fef13c88ea8560c38b95b611e6457a750d90cfb31f2e03a09f7e6d59f4eafb4db2ba0c6c84d24a4801a05f4087e580ef4045dc689c1d66aec557777fc5a81f0395d5d17aeebdac6f6116cf912cbf3bd867a99818a6e862535c1eab6a9413b743742bbbc442d1ece6843af50c686ac48cf99113390b7de2bae52d2f2bd1b7c2c2e8317f16f0a3854103ab6123da306a4376f578daf8315faae7d792c508d788ad62ed3812ac47b99256cd5421d03df5d6a6c630db2ac76013977875d6a036c6f9e5434ed2db36ff0dc7b271459a1b070fd5ab41c5fd509858a9c85e51db5f0708edb41a849a9a4f4d76428940576d80d945097a3d544bf4ae407123eed98c3cc2c56a58827e4970da1d4738873dc9495ba3bdbaa99c534fa66e45bafabed2ab0799d3410faeb498ee07cade57609268a9e9ba149226882d762c3353881f6f0cb98ad1147c881520b7a4417d578b75268e69a7e130800b40eee823619eca837f718453b55bddeda6656b539491a4b197f0a4f31fbf61bb630376ee867db421bf86dc56a5f2a1604260bd09c286b2d80097c6645b4ae34e22f8a8e5e590567260f16515bb74b5bb2d5bca8eac35db0bcffc7aa2c31f1109ccc190b7ab17708740c64b9b65f7d627c867e3e525d7bd69b28ec3ff1cdca03a4ec16a88027dc5e4c3724e870b8b1cf1702c05e1baa2ae44da325e38035fd8790851cafaac4d883d72680310d5fee22d57975c0b410b398ee3415ce0c6bb58c5499c3188d79badab2b4d98530bc634a3f83115291e02e79c61995cfee31618537216ecc3f45eec8cb62b00c1a187b9cc0d1652c50f559b2c659ee2cfa416c68c8e259bf01a3c5b5d8e73738a03b951c4690f129bf4a38df08f1bb2604a4de72687f445d4a7ead52aacc396f37801909e37ca351bc98f37115b3b43876e4afd208ee33aa86981f11a5989beedbaa52b67d14b2505664f60f3c4037f8c7fbb2121bd7238648c6120ff59d51b03182ad04cc54257cf50fc930621eb0d5538a9adaefe09b6eba1817e07d6c28652a6ff595f3e39f01fe093ffced2176e35589fe71ce7de415d11f0e7e43ecf2d8fece4518157798929092e9d4721541e82d69da223f2a700779f255e31f5ed49044deff82470314f802d2db8bd46460da840f4b07e158055ec66644e25ada1c54709db6526c018162dcbe6acabf807c0edc0ed14bed2ff806418314822be8dfe0ce24b0186efb8827ea0ba828b574230912cb7a491acdf40abc71c16d20021ee53ea95eb9964afe2ac9a9dc7c6debe5ef7017e7ea4a19e20f82658e72239afbefc21b686efdbc6460e8ba76ec43d50cc13ee0a55aaab46db9e35a03bcb55e9cdbdf2ac843bc78476c17fbcd1b28ee17298fa2cc0b937737380b5360331b4aa3e308b54acaf4047a227cc72dd4440fd6d71777cce6ee3a4ce52cee0e5f338fce8f14d0a7f6784216cd926b5ca4dc72ed731a4a6b3f91435012f97cbaf778bceeecf861b9e6f56dd49e3a8f0dfa964ebdb566136a62e825e9d87c00a15d6db9e2b6dcaf1e2175d7de1adbb2f6aadc04d1289cf4392184c46a2071f8f534d0221c218164b83696aab67c5cb665363487e63634c00ebd4103947ce93e7d26c129fadffa3ef6cca6422e3ba3be63760e2e19e070489beff894a5b21730e1bc53d98aba418f12088f512d1ada0e3231c4dd654341d21390e33ec7d377b16f5d65a84b8137c223dc56d9817570a0909150697c4eef5a5c199b23187bf7491439a1859d5ac7b1265fa363ed0828efab4ba0b3a6d8b6d77243b5056633070d13dbac35c5957a135d21decf162afc4f6e2cbec371c3e13b6f54b864a32a6df60b56379e4140d89d803069222f8f2fe15e56c381c4592bdaf03cd1614ae5035d90772b08563a45d1f065c41dc802dbd2a04a4d8da8cef71fe3b12b6561a54916e533b4a3b501cbfeea0880479efa0fb75403a115654bc386c31246911d4d94a865723599098f394f1cce73c961a7407baef674cc5d1398c56f4a61a7ede4633eb31e9850b86cfc0d59b2a597a95db73efd2b4286394d41677d94dd1aa373a1da003965a6722d7e69affd9ec3a2072531b7eee55b347be54e89256d92f89a8828bd2cf1b4f65835278fbf38f8a010a5b429d6dd4dbaf3a231800d7193944629adbffeef58ad225307e84ac2a7498fbd70fcd2e736e3d71eb80f29082a3bff893ca76f7914129b7c4a49125ff30105243c6f773a047a6837e05b9a1202d580e29263b024467df96ed61c0f3ccdf2db941a84e85089deb67195bf61845f4f866f029672f78c43f078a1ea4b7a124a96bbeb59867893c1c794f23d2287ad42265f9ea556ff10b03f871d1c042827a6e608d9ac425da9f417381314b178391257b8f30629d1cb83c32ad9f2241d38e90d61ea762339917b5120b5b075c5f821e11675be82202020e2a873d00ed48ba11a88728b040afcbe4002449bd27a68b625d854f06b964c2f4ad66d8917fbbbf33ce1af780a185b63c08c20314e428b836b771ec70b8c41c9b9760e9d2c1ec25cfaa4e0d4d0f0d3344a844d42e0c703c00e1b396dc2e69edd64efb358c408b9d1bd6aad1f3cf7b1938f053d2a6c27ecd8b0c8d628f4ae353e0fc9e0c69d80c99302cdd8680bfd31ed22663d48650dc2b2deb909cc4bf00df635b517d7d6ea2d99a9f96156ab402e69a79437a99c3134ae5f13601c85aa340cff3e7f2abdfabdd19bca918e2641572bf5903b9de3cfada4e0b513569c4b686a03851ab432a9844c46ff0ca00caec62ddfa3e4b8ffabdafe414cb2f96aa1d3aba5e9a3227a44447076c391ce9664ce7556bd8af5ca101ab39ed7929c946d89b991f888b47b5dc5cad55cf7ebf63d1c9db8ec6874f165729c8270a541541f9114bef3c7d6abdb15c89fadecef7095a1081a55c9c411036a1a5baa40cc28283604b3704e48d0ab4b8d9110ecb28016528b8190c33cecca1ebc430359e6047886ed92df46cfede04cea30fa1d56aef04848f3bbb22f33b443bd5de30df579646735b7cc33744b5b92d7779833436ccc828933c3c6d0bd7d975a05a0758388ed4bb454bfab5c02d49672e09ba0949a0b5122bcc95c1f6176a854407fa93e7df46e8ad0ca33188c27bf48f027a6e64e4046f8a09544184168dd27c58673ae39d9c15bc836b1a7ba94e83d2c91f565c86daf3fe30065624806446ca438e55ee9c388867b8e030f76ef2cc6ef600dfeff66992160ad94109b7547816f82079be38ac38b0bff3e2d31a62fc258d268833e35e654009bc2136e2670aad710a23e435f3f55fb0e64423c98bcac4e0380dca9356d0cbc1f5e5a09f19343178602f2b5060d99d2b1e57f2d9407a09e1b443328a1811812272b134cc7dda6374007a21e0b2b7022218d8609c7602b38d2824476a5bace70343b3df1cd401fcbaf55f7c4e25e7516de1c89beb94a42f72a9e934b9c96578e75be74650a6cd4ca2cfcc46cb7251f6f5e2289d81b5cb38758ec27ded44cd457033c4a17b5a4b0d3fe36714e6187a2e1284c7621b705ef197428f27d9aff70ec93bbaa5dff46317c40356da53b61d355c7e1fca79d58b9e424741638b77bea7b8d433b0fd0e8d6826f9c444c1b59293a236fba5145658ad24b50e84dcd7da3e1d2e51502f46d25a644a901ca113a38400391e0d68df1da60cc41ca259e874e12ded49c6176f01e21149d42bfb7f9fa5056b8f79c8afed1d6e5b028c83e798960e0532b6c4e79e2c6055703a26f5a2be16317d06dcf001697cc37a2131091dc2c9ef615d85e77e9acc6be7658e2bc2ab074350df8b36adb7ba2637815436d69635e7b0edaebfcc587d0ca73986a18bec992995aa637c43b798ce3a88a4227eec035f2a4aa73a5ddaa39276334076c3f76eccd0f21183cd1d055f321bfd9ee67e275a8fc8957d9dbee50aad0f95b919aad51d9b1617c84b18a2372878a835ba7f6793e43b2eec7ecde1a20254a92858659edc6012ae4f0581bb864c17ae4cb61fa826688236122f1d954b4ca8226a5f1ad9d569183abdc7124474a41617bb1733ddeab75c671807b5c69c4c8d04696f221f8c57b5bdfa9ddc7dcf9bff15168f570e208af9d206a0eaf9acd5d6333ec53f6fb6c5e7fff1d88907e2c38ccb733cafd327782f5bfd992616345dee2f6ff937f835ab41b1734225683637a5eb839651783ccc55235572164d149091fccb3c4efdfc09dab8f6b8dc7cda645c3c542ecafcb644f1878a234746d1c4ea789e2201061790211f61ca76377517f0439596de63691dcec88b769e9392789143cbd20d070e0a5e4cc943d3a723de5b1fbb14d307fdab37a850691aaa5b602757b94b289e4053694c803677fa95cbf68e96d6c6ac1b73a70d82462a1b94c937dfbc53fad6e8c0cae1ef22cf6e63d2a5367c03bcc45c32e087325df4c44604b5542d3e89ca7026bcba79b9839bf47eb3443a6f4fee0b9d12cdf14e4ae43c44e23b1559af5130cd20793696a6f0219cb6f7703cab58dece4fc8fac784f0a3398604662d87bd422d4e9ae73da225e758e08d8ddf1a4485a724344ac2f8b94f98eadb259e6e50498114cd0e178de7dc9beedfe11d8e3dad56462492e43255944e0b1055c1197335ae4877a2c81d45875043b9c82a296a0ba95d09136be334d9ede03172d1d6e9a5fa8327c865c25fcb5c59fb13b6e4f3e0c97c1f50e37882af37f7d16352f2b8379dc77d0da41106c79cdb9334f4d3fcb62320129103286b2aea0522ea5752c4a87b340b1693a3b7f2215207f7b5016a358fad5b9affaa0a6cac1540764739f378e8ac26434948b60350363885b1e7d8c92dac301e8479e3e97a51e861af8f18517396d78646ada86fe180745208ef8f2cdd1d65f1556db32da0764f897949aebb0cef4031d9b4e14d99336ef47a51560f18b25941a47c834fd50fbcbceb3f8da0ccf57ad90d3024e62c5cab7abdc71042bae33f08ad88dbf2175f9657c69b1466af5d998860cd80a68b752cb1b8eb2528155ec82b4df97ba9dbadefc05d229f40cf1ce1d2e7fc0cfe5d59fab56761c3a19dd563d8c2f780aaf6c5f4033da882111e1355dbff7da36019782c3b4837345820f3479d5df69babed9192f5aafa8061cd37fcf5d011145f2bc40b92a2f7bfef13497a0dcd9bebcfc0949313097c3cb5f2ff26cac853ab9d5f4a4943bb7dba4ae959cb101e611b8c5c3ee06ec89eb0f3ec055a47d44c4966b7eb0c383b0407495377db0ab2b178ad008c5ee4e2b5dfe892f3af0af3fd5271bc2db88900e85f48228a8030821b071cf3d116d963663b1fe3b610b07f977a3f3c15cb7ddaad6217782d2cfd17bd5fac636949de5b500bb5a7b36368ae73b4ce65d9c39caa0348b35660bf4ba99b1b69f3fe754004c85c03793821ace8aa52f618263e5ada7b8246ca16b4d31d9de0e2ba31014cdca64a7435956e1c3216fe63d08dd7acdd337496edea3086a8c178d9b9948f502108c9a29a6e462c630d79d0ba3a7c52db6ecb08b397640e9c52bd66db1a01e254a0c3e1013b9aa29c0213a1caaadd63bffc59401b70233ae189299eb511bdbb483525f64de9df3ced98d65a2fd57cfca38395e35478a5d1f8b58c8d3420956de56c7ba46eb87220e11a896913fe9214e3fe3dfb920b47cafa1b57e9ad89034876d0c2644ed1830bf7050594c6a73c529bf96ded4971852f59cf3611e687250868b02816c43ee9b32da26a6120b7854562e2ccde9e4f78e5bbb78034c8f99eb7625198c4f381f74ab4547b061aec28b71d0c6ccf81ab3baf94085a19d2f954b0138aab64222e3ebc323f6d2dd5074a40be103bdc1615472bc83a68d35063f583c63ca2aca3a9f5a9b0b501e272accefadcfea9fe892633f4692d6232fe9eeceec2e075fabaf1e8584c785e0fd03ae296df04032761f1a9d54e1e68d6aea483b763b75a92fa7199ed378020856443c75ab71eec8aed5bb97bd203e5b4c25507d14571efbf4231c57b4a912fc021198ba547993da5a52058d216f82fc43aca1aa9e39c6a3323e2a250186ed2036067e5439e34b6a632dba42c00314841637897c555b259e438d1cc3cfde51dbe33b3b204c9d3aba2c41503dce615ce7642caa5f1edf9112b120fde3a350f040bc1d7fa904cbcd4e1f43f14673e7b1282790e68c188e038c8573d2653dfb903457a9868c0f92f44646263f7ae592b98cd54763fd1ce3fe72e29b51ddb73edad7218a97ffd644102a06d535c12a74f82d4be1c5ae1022b95345a3a90f24f2fc36f8618e7628a2f677bd02fbd75040b219caea59007b6f2b70cda9a8aaca7b04fcf0bd7597602147a3024fc2e88f0557a04bf7fa6524958f7d83e337d0236543e90f64dce76368443915130ceaf285686ddc2a3ebfac0cc8d44757d6658ad57d4374957f2846773cf8d5ead3d18ea99c28a1990bcfe2c5882a998da0af77717a9edbc36a366a74ad8bb9be9250d733f113ebffa53be978dcdfb88ef1e89d8b838bed68dfa1257bff62c6e1479979b4924a44af893c244188ce9ce41ae8e8fef8d1bada5493ba59409036e5307bc7af3e20600f80141014a1c79b0bb436d71a01d01a9aab39017470363900ae196077d11290be66ea61aab6bc701635d97afece883edceb4a1058222d947e40f50fc3d27577db8d27e0610f8d92f75cda6f79d2127ec4dbd7c11ecc7036fbbdc87b4179027902b2cd1bffe555f6ceabc6823e9320a236f25753b7c33adf0dd83714255bac96f4ed25c92532094266d845fa6a1c9178c719ccbf2e56e4380e114f8cb04001c638616375d9ca8d99ff839cbee91e3c45c6bb0b58927f27f612017bf06ab6e0df049502e39034f4ef4c5a9d1ead3c22675d3cae0d9693f2db4fef565a0b66b3dd71998329d3a4b5da6e41104cf7342a7173d812287eaeda31e0691aa7c5c7846d8708d916e1b08c0d11e2eebc2e9785d09bff74e2311af6c37eba8c237eeca4de996bfa3d7fb7d287fb26c6ac16f1bbf86ef0a6820144d9b17639782aa8e64c817d0aef3fb6725a437ad5c3674a2698747cae87d1fc7952f3f71d1f4c3239f03ea3e8a49cbbb104735df46c196fed63aa7e2dace7f1a170e47d07f4a4d8b1b9cd99fd9820e81e42479d1f62c63179538dfbc0bda98022db2144a4d125be5a5e52772e8413b8bb851bf453cc092e03f9e9aa91205b56a9c3940171c66ab9840eda32dbd207515160eb41376e70fe5ae1c390a0c786dc0c2e05122a3058abb0025d2fbe15a2a896ed3584e89e127b16f131cf7b2ac320a84610713dc34e964c86b26c887671ee752fe2e311a921d77cffbe31a2a7220f58e85b95f349ca4e68f1064a6c6d5c9281d538223aa0c45521536365b5c66c1ab2ae721f5ecc0fc034af0e592e5458786e87b301cc976a8fa272658057f15d801b2828d8fef419b35f2bd4416618fa49916226df3033c98566d6aacd33df9f096be6aaa7e95fdd6921f6deabba2425a83f037de156db0e06eef63b585588652ca278e29ae9a4606c1152aa7e7bb72597fbf202a631e0a30cc0d0cd264f460f87c3864cbfb0675fb4aa82e13ff06450c236c6b8154a81109e91cd8c0834bc2183d822a7dcf7ae44f5c361e56d24db2382b263e7099a0de75e69f82a92d3088c2bf98356512aa96e591d7c088365f208e88be098f99666ae38ce28efdec22ea1c6eb2f5532997df7064234698e88197d52d0a217421ca97157ad5e6cea37268076dcf4f418d7ed60251c921f2f355b30bbaa1b42cd3dfd980dbe9476fac538d3f1e24328826912ebebf5e3f2872ce4cf3a6a390f9e333dea5fb21666e4c08f883657973a7e34f8e7dec61bc83dc25059d62b2a460c7530c0a66bb1d46c6b3a06665cf813330b1698bdb13817e058fc7eb44c7b56ff33c6f20a5a5df4d5e7adc90f941e6b47f844e9ec2d00b85c279665b804a3d8de8b8d10d4197cb7f0e23e3d18a694590257dbee721bdcd3cdb84f416c98a55ea62a4726404003e194375579f5e091159af50323f94ec6007f13c0c0b60c074c1066bbfc8e9c6a9274dee33039543fa7dafa5ebbf7f7f9d104b2cd5b39cc2bf5e74f3f82095dc33c5d9d36a54c619c78e0e2bec788e883354f777d5b55cfc460788f9ad571d19017b0ca0f98b19ee2e74bde0b4995dfa6bd302a71fd7ba53ec410b9da646fb7c273481165c8badc824eddf33a0ca4ff22869c8dfedd63a82c69ec4dbcbc63160d0a99c142d1d9252f7e9cbf20fb8f91a62733f949875645e48da29885374a567954f80adbb24cbc3bc5a57d9175d47e2a43d97ca96ed911a8c98cadd717b71ec6f12d0f7744d1bceb05c056a6859763524be9a138b58e078525b9f7ddeb6a57e29bb6707da604c3e2fba99c09f375cbe2d814ffeeb7b58acc4f9e488cf38bba0c06f8ad9cb3114cd28744519b2979522299640e9e949c853b2f261d7fbadbed8ca982a3202f16e77c28ad31cf01affba6507d2f0d1dd7b5db0321acca01ab80ab145f94535447c2c2014c4d9f60d4af9eb7035e1963e9f9cfb34b27a768c074806adc99484bb4fe8d72cd4ce35f705e25f378e8ff32458e456814a64148140a5e05eeee821e1e1cb42586483e4b704efe6ab0cda6b264fef3112a385c84e7b0105d7010d2ed24e19914d2ade25e68ff2c3cd3a3ea41a959f6add683afe64eab23e2776ddf0300001e69e40659f28fb9249260fe84591fc2117b2da657dd6862a774ab443370de8feb9bbf1fcebbf665368cf55ee6c765146e5bedf659db04219bbba4d59caae92c6df7df1da59d7a4bc47e436f2fcc0d948a43684d13186b0ef88af85388603d77d7dd2978a244a3dba280037c5105a84674780f70677405ae860e7e3b5769eae2520cbc0cc153ba72b04d376ded2ec95b3e0098aa867093b192a145aea4047f025a68f12492e6e51eecc18aa7ab514f5d9c10f30a772f709bca7849f5d328b1f5dd58aba5448debb3b1e0b0bcd456f8a7134ef2210929da36a6dd56c9c4d6edfe76edd82e0a0e060afff2c7094ead3323c7b3f4b0eaaf4a5268ff5e4d6e8c241b43a20b6edd6c47486bf56794daa8e1307046c9359f084be2b04dee22f20d62f2b7fb3ed17a9faed7a8cbda3beedf29e5c0698bef04bd2501828d3523d4d0172631354ca64d0728926cd38a429e21e97be17f80f83671661c4a3b61a2418925ab618e115d630237d14074f2e1314384ecf89d291b2f3c0b00ff2504bbbe4229d0b69405ae83584982db73d708c7b47a2a841d8a0f617137abb72772bf81c67e98e9eb26f6d53c3902d387b95acc897c5a5c2cfb43625764a8cbfa87abb159d44b166f5ab6b81ab6adf4167af5a584ac68bea6e2b1ab9134a15f4a982500572308256c804ab9abd6832a6934efbb2f84c19c8cb68d682461f6130875bc3f43cad98d5f73313e8652d1deaf42a23a01f5301ab434bdbb72a1062562ca097c335e9dc34ffc03e5bb3c255a9f9aa37c717e1103a00d2eb4bf462a7ba21357aab6092dd95e6be9f3e2790c6e8357e6c5db8781d6e3c616f01c3f2c2ba8c8b235266bd7fef8a441dca26bf52ab75fbb23544cbe20a8dfefeae6f772f2b904fb95073eb6c28bf1e136f57d3a8e804991271d01f79debc30ed54c3b1352956899671117e2a9d20e91c80296a842fd27cdc99e1b7a34d5c145ee902958ff7d35bddf541c99c274029c292765cb82b36d1c111386c69101f35c450b2174dee999f18d38dd1cbe5849264635cc1cc18001f0b103700d4f3ea535ef7f2827a5ed9d05b50d125d6e7c60abb82b2bde37b9daf97e2013f267e402d340e28594c0ba1f15e5fa3e4cbfc84112ea2d1e38c9784f528d9e304116d453cb6e56a029878776391d4a7a72bae82c9107c1912e3c422357ecf331dd89db72a0b2c637474a79c13a4a50dce28a63b3d435f597f6e8506fb56ad89dcb37227c72a8d9970ab04f1100449f00a470814be4b2a56d2474daa30454f6eb47e7ada48cbc02a26ca7e55fbcae28b3b2a56d445039e00ea140503632272c00d660ce01dfe274e74f3a480498c769d4a7a42493e2420510c2d597162164ca62ddf2120264f8c287c0e3e92447a98a8b79f33023d08dc76c46a9e711eecf2128fd196b1c9c30588a1b15f109a77fbac56f1ccf905202b87675c2c791479424d4712c7589384d191a2becf8d25461395623dce1bf0c2f259fea022c583cd0065d134b92fb219fe0e8614fca9a922c0b07f9a2a88707415d181448c04dd179e2bfc1b1403f3cce5220a4f7ac9abf956b1a9fa3e168563ed2fc7a9b8da96c05b782282de375fa0d3d5ecc87417252fc36df72dc61d04455b4d39e9f57bc366adfc071ad36e72c235e4dab840e883ab9e641897a91cb00a81fcde8a6c6ab671e641880f86c13dc55975c2607ab1f39b21e6909e05ab9a717bae2de8148f53624d8a5d01ee672ef5072e6aa6b5315860c43f7ea03255010dbfc4571975f88c59b454552afb589d953c4e9fcaecfedff2a7cfab7e7dc278f39a73761d42ac5a6f1241e5bca22bb1f10384cb45afd1bb17506c449cf6bbe29e50c4197230472231d9044ac88ef1bdd59551731fe51fedd9a17ec64890e3834435af451130164adfca7c6f6a6df540442be4ded736a899e0d2d6f842380da3cda90facb07725040985ab80a7b96d9982609a4e1b72b33cbb32e8da90d7b977f33b764c1514e4d4b251f452142263e3cb5f0ee3ed1ba0046acd11991f1b4a0e19c13de425410668a21b3f9f4ca657bcd6f08a031f1f9fdb9517af1863651798eb54303038cc7b3ab94cec342fc8a55e6dc40fb3d612eecbf86bb2f6ef594d4c94a72958d27b9d3e0019fbf007a41d9dab93e320e865b56b93c66b0dfc7f543b2815339d9a8b14e1abf81afae2dfdeed74a8dd732793e35941726fe1b5ad16fd845a9738b40222eb4447b05619b10dc803d41838e4186cb97024c10c09c547b6363d418572e3e4050dca7b7e7ba759265dabe7d9b58afe75922cca03f3d969c84ea6b86356ca233cca8d14ce4bc783dfc11d82546e475d4450c80c3b486c2c5d7676ffb00bfe5a0ed7c9235dc44dd40e960ac4776ac2372e8caf26c0a284550dcd78282343e4f0d3bb3f6330ad21eb41350071448d8a994124093da6376b6450b9a0b6b549405c15f1eeff3f6cd4b07ae0eb763d0e7c2751802bad6b2412e68773ede1336fde27aa1941ffdcfd869830da5b789534f1b7a555a1bc53a9073c3a8f1fbded94c959be5ef3475d8b617d1a5f1d3c72acbc9458725f44e76d4f10bac772df711260e01fcae5d92c40eda97d07fa0c0ba20f35e54c0356787d7632963a3f1df12d9a1751c7d0bdaafe583f81b0eff365e80a67b7b8b714abe344cc7f35ddb7e3278fad65edaa592a5c4e2122d423e032727b436b0f16153940191d3b002d7a550134f108f86865d22f5376900bbd3cc65d3f6ffaebee698936ec67a586e7ccb7d4c2bf99626ea8fd3f0bede3641e478fac934d3b87cd2fb3e807be5ac3a2578400d9fb745c462093f1ac22da7cbdceedca3c4db3261a755a9a6af7452cacb523dafebe329a46969cd9bb101d96836fe3ea07accac48efdba52813698b2af4d7600eff0220b0751160600c6742bf0bc3dc2bcb54462cd7b082c8183f094d79f6d46124d2a5753343a4c0623241a08599d8af7e0e592c01c227d03895c7b1e7b37080ae84ba57358e585ebc37c3d2b87e9576f831e10fe01a09bda2b0247c7751173c1871869eb1db29a9b48e18879ae091fcfd1e7809242b2f7ce877c9da43fc3e71217f99302bd1b9c6e0a5696c7a152868673bb97169c7ee8832e0efad127856bfe7187356fcac0cce88a692f713000c5e827bf9abc79c8923f1d6c5a3bbd36a5509c47b5404023391e8de41082584a6288a792ae488422101848e1b2ce734019efef1013df0bc83a16da928e8efc7cba6af658209496cd8da6ec281f98d693f94f04521ce945a81d0cd0f701136682ec8a6b95119924d45b884eb82a8e1af7b1242ef7b72170d7f7bafedfd4520814265fe13bc32fe14f17166b28ab52b3070d31b4100413328dcefaaaaf4c37783d58ed5c4620a517266aaf0cea78dac3d4b6c7c9f29776687483e1e9ea99c3324a8a02b8052a2786c043b1ee3c834fb9ef6749c223903337c26eb20e90f6ec2db0eda0c7b3bf5a7fe96f19c7fc767d5fdd2f83d7a0da2ddb9d494db9d154817e3667fbee0f997470277ddae279ea3270b786179ba9d60ebc7f56a7d90e1386e10b8b91e7adb25e5d79e629ffea5ee39174bf7ffa0b274217d02e6b0dc73589445044ed37e16aabf49388c66f502566e2d37cdc3c29bf5b288261ca50f471f5834ef5904f9d07444c3235a3aac16fc41f709bb18021a91c43eb906d8d69986c3c7f3f900bc645f92ff2459838ae9d8723066692a902cbc9b00f383f4498ed1e8ac41f5eb015a6b85d0c96027836b451485e25906fef2132f4ecec281d7f128019be93889d87bbc0c68f46966db3375473f9bd3ecf70e59cac863969c5c50e8313ba0d457d5fec04201d194284b33394b3b8718ca2139bcd5cf9f021c98bee9ac13fd034bb2f291a17cd425784d92a8f967e6b4b69d9b9b2d33c45c69533f9a1dc660999ff60df7d66e79f27cf7e076d38043ecbc6ce386fc6846235a48db78176f595894f6be44bb6cb1e30e02d313c95fde2784a3c924b233557e048cee40f04b5280027ce766eee7f6024658e7b5e72bcec5eb406378a74a78b523e84fe749bb9c266b49491eb71ee14f4656c90cbc958c95c45565c671a455479524580c96c410517927fd019952dc936a678838e3754b59ac12f2b93eab797e48923de692daac71a35591f415ea6cbde777fc79806ac794d65ae1a63f2b6c05f57a3c4e44667016baa3822f649c1ffb9e1bb3956cf6df78dbc2fe4406920992ce03d7ebbf5761638ed810a2b1fe569a1a28ae99ad40c6a0ab1541c80168e0d7bb05e47cc118e636271dba1d8ffb2e00acc8d2c782a32e431c78fd9f4c26226261feb398e757f24cfdfecc7af848e092219e724a8300f7a0b9e7b41dbf5fc865810d9b7ee4da1b9ae7c4658e73c757803ffc6199ad0ce336f82b2d4aa326eb5434d2cda5d0f1db4f7562f16c74baa2220f121cada52b0ffeadf473a2ca2b6a0b352ea924ee1f35fb9626841f109db8ef4ef77ba21308e718ee369b60bedaaa71d4fe2d24f5a01eea626b1b9069114d1e5caa68734e03cd411ced398fddd444c1ae16cc57179feaee58e67c889f13d4708cc3f2c3969c655c2492c68e72f9138cab7e4009c046449e00548f426ad1f541616043411ec9e77b1e475c17d879246773bbbc97943d60b884c7dcf1a629c6442fcab1c610586c8a2b6ca21d84a853c1477249edac8de605a102226e80a8efce910f2a50a86125296a6375fc1713cd4f71a6ae2569b8c7df24cedfe2b63ff3cecc6c8dd0fb61f31dcf27010597968d9972667ebf6a8fd39db12402b09d679a9f7290037ee25314309713a571a6d0fd2e2b7239c14b4a2c307501b4f487800fde81923a8234ab8e5022b0813c9689e99b3c61278abc5ad0ccef238498f6472f86ba61f8fca64ea5808262f20f3a96a9627a4baed7c331c273ec37933b6b881624fb9fafd5afdd13c53ad542c755486ef4cd5f6fa6d4b6c4ab30164c5d8461dab497af17bdfed2de0593d126c28a57cc49cc9c49d1e1f61c66c0918947ca0b622ea127e571b421ba9cf89820de6a1fac8a086c31e001cd62a2ced2957ee7a4b88633070c5b0469bfab8e6d0f391e55712259bfca6fbf2a5ec8d6d4ee2c58b60a4ef077f50fd1adf21be4a52f85770ee5981ef9d44a3ee4672163d6fa075b433688264310ac05b24b7cdeca6ffef9e4635ba09f0b6c0f940b6b9417431b4fac8ac458a8869114796fba88d54db9a340303c12799ebf2ea1bd3ab9af152f23795bbd8405085c574f53af628e9d79beb44aff5c53de19e37c48750534ee8379ad01f7d3a81a6cadfcf843e6b77362bed1e9fb5dd865f7efe4b47e1c19c0496b6709b01744a849ab100845ee0525f7f737bc601400265dde52f3fa31732b5ef6c9c58e25fa0cdfdf775acced35e380d4e2ed9dbefd65b8831357462c27935b10d61faec5bd69eadcc27199c22e706c34873ddab757d78ff35d3500e5675890699c8188deb5ee8bd06e6606cef8063396ca19a7d77ff8941116bcb2ba4e5c283cfbbfb343177674d167f9830b0804a7a645a4f1eb884d7e51090fc361d9270688ee4f00f4a62124489c709bb5bf8cd32c5770b001071ffc7780675958fd4e31eb8e4e2342f16fed10534b3f2bafcdb03a16d300193f50f499e070b2692c5bf56bb0125b466ab4a372f0862a7d911c160c6a9b0c1c840d77000d98536abd13fcccd2dd8b4425299f9bc29ce9ab0f34b72c1f94e2e079caf0ca6583a7fd22d1d9568087742db538fc41c2512ee1edcf0b2e176fbda974385fdb631f41fe7e6ea7da920665b008bb95ba068cfbff46c7912e59d853ca6c6a02a0901fe919c351b0b0669064360fa8033de642aea294924bc9ab8230977dae229cf481b53f8a0c809d087b19bca771722b89245c0d8a256c5ded4b79b51cc073306fa3fc4ea6f533f9235c05be4931cec5ec45d7a577531dfcd6cf60aa16601161e2a43a6d343881255c628c025114ad4a5b342590be648b36990613391487a2d78f1b7c3e828edc149a4fb91a1e9d77fe2069315c5a903365f3c841a0cf91081a8c47636975cc548a4b14bf0081ee8d9fe1e1f393db5dd3783098320f7f10ce4894686d1f696ae64ae996e0dd903db225582f439ed0e558e5c8ace797daa85d59bd5d23b155beb85841731873ead073fdcea37c0d0c001038e0f2171eebfc00534d73961c96d6a76a4239e0353a690d4e75311ed0457d493a022e134c90510c86475dae7f9ff8df9c3dd616b8af624322d26800912e83c25b582ad29f9f32b64a6f329b4a035710ab3f80615c4ce496d863c750563d896e90a13bac003ed05f372b7fd3367c91d933035cdeee4c6ccb47d79cb7cb693c7bd5e58d53432f2121fe38a26e9afa76654b3da415c78f92c040c17c38d152c59a33a368e531b62eb324a1d7b3fa79ec3fbd8349958191afb820e5a4db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
