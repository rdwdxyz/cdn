<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c6c92a93bce3df1ec8a53038cddaaba277133fd70d91db623aec9bae6f77e2527e34d8f3ae721d1472940c937ef5ae97c97776ffa7a9b88f30dd41cfd6f7dd04c83c6a6b3711cb7b962c8d6d94fc63ecbc6eb8e19955e3aa2b23a40eebdf9da739964c7c8a39387e16709697334c91f8e084d0347668a31b9cc3c1459dcd0d2ae641b69b44f1b217d2eb0aad8d0a1923addc14d6338550469d7ee7c0c47b879afff804f4fb390f5b034f6f4628638813bd39712f71db67bc8d434b2d3c5fe804b789b0459a46e075ba5957ffc68fa46e2fe3db8e85e2ff1dca165e0faf3b59b8e04147733c97552174e5bd2830fe00ffd3f265d5f6405380471936f0f76166852518d33a8b4911b7ae201d2f6850cd2c2de1a8568d13d5422c6fcb06174c4a2850fabe455d93cc9f079359b14c29f7a5236fb911fee085b8962989461cb8ecb34dc4d509188712e5a030995b47b90c31a99ca2149e3e149335ce20ce1f97652ffe64d7b0484b80016a9ea42bc89615a00763990fc6c70bcb8aabab6f3a1beecdd4e6ca7e3f32ff2cb603e49c0c9d0efde7c7ea9d3f843c97f78e1d223399babfbc9d61640a472d727c150307dd35ac0e67eedb84b9958f25688ab58c401a2224e99f97fd7a4f8b7fe8eabeb57c9e7462631ea4a1a7b59f0ace346825580c7057e98fd3d791d1cd060294309e45a62fe8fb9f4ce9471bd0b6235f9697f7afc1f1398384c60a8707acad7db5fa3abf57d16292b0e83a6954ff709a8bd43e58f79da988285380c68792168fe62149ccf382391d9e4959f316b2c0109bf191710b3c2594016b8b897522f50285b3355d76aa5b7a1ad9b1b9c08a8c188ab51fbd45116de40eb93d0c6aff5bb3649b9f20e54c8c5f7453cb98a0785696adcf6bb38f12039aceee71b606e870cecace514d598ea809633831ff2eda2b4bfdd4f057a676f38695393ce38d2a7cbc63127245b3f959f0625a1b259549d09737c70c1996e7c134506f2b29a0343e685025d8aca5dd2bd82eb2f139d53b8d3077b69cbc0315ba22c07a82cad414a436fdfa4b660901c148725a136e65230ca0d8488c51f1f599357548e89f2d50e267c32242656089923ce40bf3c2d4735f5b4b5a824cfd2c216d9511436259fe53d7ed3db1b71137137847df20b6690504303865ba860c83542ecc7d1822135fcfd76ef6ee11a33cafa6c038d88ba9c42675d7069fc7787df17485b81c0b8a6a6068f45fb18ca9a21df0d5f233dafddf29e1ae416be82c2a4e981928cd1e3dae9af9418da6447cdc1f82fa83316a607bef6073b6e1fdaac8cd98f97dc84f92c59df3c84a36a17a6bd17ffe800ccaa5604eae6183f9ebc437dd269b6c1fe8a8e41e4cb13bbe4e5a00b936cbbfeb1f35d397102ef2f31d114327b5e33f0e716a6cfa8a1a8c8ce007934a495e86492719d30466ace7f9bf5ca04d9d0e17759c980e95717c6758eb6f1b3b62343d923bf7da57965c9a170484b9fb4974f76d4117e418262025ac98c5b9410e3d80ad68270a034f0f7ae98426fea0dc897b82d13318902c0a8e595dfb39711f5d0fa8f6ea08296922b9689b58bbc529d48845cbb54934baf0d775c6fa39f239d107a7202ec85080deab8e99a376a5bdc1d0360ae3de0a7ca0afa4b671a6b9280c10169d09f1c7e291077d34ca2e7beb7482fe121c6b5dbe2ee1730573504fe5e3fa51de22f5c16b15f1343c62210bed8df6564f5db37fa1e13fe15adc0ca55bffef610955b385c730d3cc1b41263295563622984dbb08e7345d64e4d2d207f6b90957258ee2b9c1ffd6a197392ce92030fc19479908eb7f2bbb98b31632c2bde2363f028dee75d57db05fb252ba9a879f6d8208ac83725b9d55239d00e617524b1f8d960de992ceffb30054e02e46b126c3852a1769a2429889a5c68edfb5ec02fae95c6c068bc12da5f692e9e00a772d287bbce70c828ca1ad5ece92975d8b911e592f4db2a9c0a82821e91ee01ccdf567cf2e8a36d45a0930742026c0e4b68da0b4f09f6d454c6a6bb335688a8eda4785749565d4537f71b0a7675e00e39b449094cab4ba05fcb7f005488f7eb9032e512cf9f1e19ede6ac69f1ac5eaff2700250a169b24e59420523d46065fa48cdec81a8957dc7a75bc514bcc86e9cff3ea5a3be93fd62e72c0e48281f25a65e54df0370104acc384447334d8f86eb50e891cfe806fafe9d912a4f2c58937c036d81c081f48e8fd3851c37d5cb5342dcd6137c3b2e204b2d76307017321099acbc4958238beae5418de194a32370ce4b935422c666400dd600c468e39525ae54770408fe8e0a416ef89bc74fda6b41982a2dc2339cfd5c358e07bf3be3481d5cc770f0724b9d5128e94832862f505c3efda06aff56f9f248e817c6c1976f0898634a2c4f1cb556714dd479f4c5ddc4db4c263aeec28490fe916db785f164f2af67fd3b4fae5c8f89627c137945ae9cb605bbe5194de817a87baa7bbb5116d58895d3aef839de6bf08341863b9af3a16b0610f7b2cb13c5db6027426dd345ed6891ee4af3c2607b3e1bebdbd639b827d176de8383248ccadb481c97ef37175419bdd2bbf144d89dfde95deebf463715f8a776aa8f7440d0920e4f209e305ad7f1d32e24c23c2f57d02b11f2241ffc51be6829213e602e89bb4563ecc33f2d336b4563a734e49fcc6cc2b5f82cd9297850ea932404a127d4165e156e3833a4013251182dc9ff5dad9ed75ea0a63efd8d4b7ec323fa2a67cfee24bc6982a9c2043a7e284b2033c5f58eb0d47e4dac33e7bcdcb053ad7c707a292142d8c5a38bca2566032a138d92349c29bd58e2a53fb71fe45aae562ce13741ca065ab75b47b62ecb2176a2a6a33b1fee7f9ee4159d177555f585d207cb8f1482ed257af4413dea8f989dd713f0f7dce66abe07da10e68d4c2ea7bca4ca77ffa713055f98247028bbdad1b1d01ad0b482b51a30c60547cb29ba4a9217234e97f9d7f4348b267c97c6e2cc3398c361a0254e7a273d58d2570f1fbd62880df3e1dc6ef0d277574745bb30daee66739931fe591daf981d3d82f700418834d7fac0ec412ffb15c79521d92a33ebaf6b4c68d5354646d398835568faa96e2dbcec2ac588e127007d5bbcf3cfd31f8258c9380a4f8b9fda3f42f2493d491bfcb12b0a014a0c61ad65ef322a2fa8f5db5cfc61b9de1e2f6f4a5218c8c989075cbf0603f0a2b81e31eb2d8c82c782214461bbe3a73c61a70f4e983dfe9a474b2bfb1f5a0be2866d08789930be55d9a8107c197351def3bfff36fa08b18b1ecf129b1d65973863b190847f3870403aaf6b7fbb69e2bfc2cc98e7694601bf86505a5a8b6271df929b0cde0977a13f798f475bf9e8adbb72cf9493176fe8c121c2eac61dd8a2ed36a357275d39a1495f0ff2088f7cdadece7c17405713918f307ca4ea599fa9604de3a976c079ba3c459010af0379ff81bd37377f5541b3e1ce9ae223381c912c80a124c493278920fe84db0b037d8979a64a0c21f1a67d4a70f278ac4e11edc2c404057ccbb2e9b82df8567d748a014ea40e66b45593730c1c84e230cbfca605581df1682b0133c56c03dfa4d950511150ec588cc40870e76f0bb3e8f2b72ed9907a1b1d9956d6f339577cb7bbe4248536d97475709a77ac0738403de42a977e9d7c97780154059342fb7a08ba717ad1816e1b29e09db7c09b0ed2fc2a6709b5a34ee3b1e588daae18c8835f53779bf696a24bcf63ef9e16212780c71e38b8f22dbaed684fc047a8034425393a470c836ab953ceb9505e5f99868d8b8f3cc039d638b3d72bb0719ac78819e50f2ee280b7e933f841a70bde10c34f6bc560212beb55189d9ae8c51764fa023b38015ff33048d5e88e569de64600e9a46f3965d4c03a023ccd3218126f750eb7f43673dfdd8a6c5bc28ae250c1a9fd629871cb7f2c7608b8e3ec77f1d990d213ce292e492be7a26d6b6d59934431954283cb8673e5e91a367fb073982378a38e03492aab5beb301c4a599c33eab4faa92876e54e50112f0f5f3bbf12cc4bfc2578b120bd9544eb02112a1ca7802341fefb0307f0d45af95a805cb1ffbea28da0de5dfa6f79901322294c9e5d48b4fc8e6280b0f6781bcef1b0fd7ca79a9d7ac5f2de2420b7bff8ef2d78c60ea1b51d541315ae2393b9f74d812a68c8ec87b8eb3f61f2e8276658a9f9ce5669b607b71627bfc1228f3d93b723d4948b5599a3fc0aabc754f490420b7a9b899d0975aa27bc3b4986d0d1d4e0d6fc155ff2727935faf7ee5043fc1f0f1a38573143770a2a96ec7053898ef096dacf54f2a177456080527fac8565b45a1d5e96cb90dc02671358a166fc98116316f1413f3c5433bf3e3673c186b079ea396f2d7618a36607edffc67cc200951e869996dd7525e334f14ef7bfede929b9d23c3d71060ae67ded1e1f622a3276d1fa0ad7ec18d4db5fea7133e4fa0a872883d9b35f576d945afc74405911e750fdc3827357408ca1d9aa5a539dbbcbbbdb395931eea28a699c746c719ba4b3ef29c295d0b35a88c3d7bd4c1a03d512678ae236630743a0fecca6574c60bfaada7660ab01a7653c3f79b4dc76d06c91b20032545ab3692afc8edbd7eec2040ec834c0d1f6131bc04cd3765de7040d0e5491681f94dd1beb77db17099a0258df8d7a590c9485e1df0993cb0f5e7b5de231d58c41b8d489a95f2228d9a453f1dbc9847680083b39a1bf01cf84d29f244dce2311b129d98478bb200542ba8a7c5591e0f8cf08a00139d8ce3fb72871b9b628bf5e18be0045b02456092c575aedc8e0e88a91b64ab69a4f2900d343b9945ce16ab4dffb52760958711956e94b5205ac263bc23a7df03641101d9e60b7c98a8bb4d7a0489be6c45cdb734088edc5ba5dcd60186da4f3a1fd9bbaa2430f00eb3733269a1fe95f44ff11990db649fc1cc957c56c34c9a4c4509a9adc9be496287d528501aef41ae8af95b88340bd490dfd5751006311f81e9a4059cedb657bd88c3dceb57a884d800193320b5e3ad059f8a26d63cbf55572e92700f24100f46bacb3e594c2eeb2fbfb165d64c6b222516159cb5ecd56fdd4cdb2996a375175f4a4bf09f43141b44aecd6a51667e500dd065710decca1d5330483bf95a26b771e3a212112d46c786914549e7c1a99a9799eca4db395026efa00cb9c077b0283a51e8a76deace696e5274e94fa63820460fbf3687a537833f9a68a45d4d52079bdce4fdc76e50c85b447ccb90e0e0ff1f1773fee1463b7e98a0cbea742a3e95f3041040672b51558c2cb51c77f739ca87ca7e5119e0d0fdacfe8888810e50910a45d2353b884d552fc981bc41cbe3d577fbe1b89c885edf8d7465e3d17209fab44fa330459aa05a400f9ea77831a90baed5eca57c69fa8b3abe9dec1ed7881b3f0f189bd4f2410500a40a180c5063eaa72babaa8b70fb688e87e57d45b373e68c62c73de977f0e68273dbc8fb1ab6a3589c3b52c778dfd9fbd49d484a6b4439a646b6092d24f5da4653a4dd77565f11d070844989f5932e4d8265d3c52d9f1b9c4f69dc51161cb4ff308c325f0c3b5ecea4162103c01d1cec6ee8dad98119983d2422f907dfec5ce3a3b3a09ce89db633ac82659a0b0eb864e644dcfed7995c4d607454125502e90b84bb58abafbde366fefaadb2ac9b92f14f51ba496ffed168434550b327e382715190ddc4b60a000ef6b50825f462e4ea041c8ca3061606fdd719cbc56980029ebf785087e23574e1c1f61234e50928fe1592b531143f15199ae4b90a07f18ed8d103f69542ff861dca375496e67aaa32a0830c8e5e818c6b6f8438860b69144af60c451da05c8a3c1b5a505b4102f2890b3b203d5f643b02faea4a64508fe0329d9edc620d4604e9db57bbe9dcc5b5568b0372801ba89932286d3072db395a1dec7b7004c72369d66c030302116945abe051fca97d331935bb901d219e52d69c12faa9d604e4c7919db2c1a28abcde88ad489d8ac98ce1d25473daff24af7a0534122f1ad3cc5271382a83236adb221728289b48774e13ff617996e585b33c956045f87630ad0c7be98cd7f8c6e7d55646b38fd92fe2eadf349964aa773c03904a4293f8874b8d44416732b954c30c8c13feb11ea202dc8502cedecf0da5bb7a2cc47e7620553d26a2eb76d8904930d4b08e88a61c141f4db98fea855e32898d800697bad73236e686fe1b6208b96ac204a6124d23940b87f43097ecbef2552e8c5f150ef8aba5fae07725c559732cef32af8fd602d2eb1f4270a9a7df920ee0c666e192b165c83d02a4cd288fbea67e20cef9585317b923b6b2bc6a48bc258de717ff2ead2ac858f410278534a54a0a297cfd0e9239979d285cb2d816ad1573f8f18970a5dd70175f70b1c9f3b1085807d5e5b1149721ae0af7037c783d45423a74c3620ac19046e9c8bfa598bf711ca3ab640e09bfda4ffacb38d443137879274b65931f73ca822feb6cd461ffc39e107ec8bdf040e7258a6f3a987e3bc0572bd52422d11849d6fdcf4e0f88cbce247860032c79baa50fc2c1efff5a07204d379ab0e64920850c7e6305ff5f8908e30939291d0e98f9d7c7d4885d5cf42098d3275165ec22ae6985790bb7785dc8d78cd929e01e44b8c9116f0d8fbeb191a53963529a891a879c84ff0e57dd586c9cd0996cfa7b84dcea5ca621a71b343a508cf66e63b709ceda10bb003a162d0a2bce575c7961bf6cfbe49deb20377083721a94bbb0e025a47874889c44d6fbfcb3b1cbe5f78f48b73c3a34c914657288ea9973ceda46620493d75cc0c81277dbaef3d1fb3e10d15b566b1d4b3ea74c2a880bb75fc5a5a06e1c6fbd65a23973b01ff3919a4879837d5fac6a287e1900ce574d9a9a761f3c441d13a90dae44637e14957bb6915398ff5f4ead25cbfcb4db1d3d25863a99228b9b74a5220308c8e5552c7428225d45283a15837463493507e01cbee858c1ef5b35b1c489837bf88e5407de5749b1acce007f76221872db39f0cb1c2016ca899dc04a82e84eb79fc728289581bb5b21221e8089811ff882c507718a3f4b47e772146680f6c637863428ef3d7aa926f8152c23ff490c411f16574134343bbc209e2f1326384a0b672c56f33d82f75024cdcfab606f476b5c6c739d4f09e13d7cce99c7f7054689b3459a953d5a376626d8317e24fd9348ff2bb4cd5ab5f9abd5b3892a94b61ee99563f201e068de216094fc3940da385e9b8743e0939c52e7fb2b217fce5f48a6971e731c4791b1072cb86c82dd35f0ef0068762c678928bfc4b593949c1c7102bb673bd897c14349b7783f876b354f78fd5a62eaad2f3aaee94ffc795010322300c0b0b3e003e6c6bb3ce8eef740a3d1e4857341d52e9027ba191bc742e871aaf22a26b90bad4ed4d12ac6b1de14a05c26ca618577187c4da85053973012a59a513a85f53c1516f7ba3899a042e05696b9d110f67231f53e5a100fe1441fdc679a7b7f95af1707da93e745a610efd1e798b3badf8ba8d584025f18f91b8a32199c4ba7aa0b85f3a3c009a478715a49ad95ba606e9da7ab998674694b7a5371287f933a600b4b02740723175ec9462e43950d7e44874e2b462bbe8653008db0d18336bdd16f193c7f329d10662ef29c78ce552f79ea01e8674b2aed3a7ee4907c93c3da97771b3e4d8648152b3f17e11a3fa605f4dfe9ec6ea6440a6b8b12ce2b12fb69120b8b89fe23dfe5036529ff2f96d22248dcee4931b608187faabdd1bd93622779700bb7375e3d798187a3c34bacc7d4f5fe540627e08e52dfbf1dab8bfe6e66cb101332aee486d698aef5552c1947196a6c9aaba299c655df6d4db0ae883e13fcbf13e16a0099fa2b5e1ed7d5d35569ffedd7c8c33d3819bab59a0da283b54a2785c757a6ea81b71bdf84e5611eb81e20ea93b9bb1898efe5890a4013656477913301ba19322f05405d3cccce360faf2aad6e5e2c7d19a371cf9141c6109c0cddedb0ba3902a871345e7edf95c79991e74339e1e83b8da4da8b7b22ec5c54852570d7ebc5602d37746c74c25a7494e5a9a311b4d12a8903b79fd54c2f866c8b3002601bf06a23fc080ade2cc66cf4552202143e1f065d163c0c7fc623c0e699deb183d9289ab2872f033d12e152b6cb1713672a834ab7497e59ba2b2edd590b9a4d177506dce26d0e9f723f728ab315df8f89b3729dc4522cbec3cee17d9303994d30bcffdc9f27bd346f76eb058516467c6e602bebaa53948338a69e92388eaeabbbbc7c87cc2d4eeef10e78ad110b47041111ede73e49801ef2889e5abecbcf4f2ee900ca8fa529c1517c5952bc5f154be4964001c165b219c25b17415e44eb79a42f5055eecc7a83984d24c3e83e39a23d0d934d07c845b05cfc3b307e978e9ab3cfaa041b7dd0ffcf80147a18556c103f3b6c6dca1975c44b65956c5dccc8bd9311a6abcd517fe0ca04f0a0a246edcfb7cc699109a78578d811b835eef8be903a905ddbba5451cbce402c45729de7931d07a2be63330239b12965d45355defaab2992e88009344e063461e6dfc8273faeffd8f4b24c5ef8011d18726d8ab1c2d5dd80e6a1ae70cfdbe4b77482e19a97fcc8fccd766b2f36f55b03d7b30af74d6dfe5d36343d7e2215852c49454da7b01f8cdeec3f924c4217eb24a5f4bcb338397f1ffd1f23d7228ed1d77b77d9864de9fd233e16a6981f3bef3b3cb659c4cfc1f0c4c99fec2abeedaf6791a624bd069aebd6dd3578c95e06d99690af432a8c2131fa5bd80239f5b26b25202886a11270da6df36b5db23dd537f2bb84eb56d342c61096e7b01472bfb473779961348502ff55501e425ec6c8a47939e3ddcaf5a378041b229ac52d836efa6434b322b5b61a35098285344f134abb904cfc8b66632f6df3275c104c37973c4faf72965b87d5051fbdf4f1906592d49b730af741e527e3b6b1c9492c3df3142c860a282710e196becd07456d5853890b8bb1f261d84d6ed98a94ea6ea8e98659ad3166e3cb2408206332c37660ecd0d6cda75c7afcace37c1db60ee246d60068c9ba71fd9809614f4c97fd3792fd2de10c6a6e9925dbd0570dd6833663cae55cf1df31200cec23126b7b36547211cf1003639f2797379e4c5f08d3878686299b17e7587c9b6e60d666806cf1d0f98bedb820f0d9b3fcc26561093b90873eed00914b8a858436ca71938318f8ec2f1660bb21d50c2adcbec1f420f760611cf82008297a5cb6d3e685f9fd40790a075ff3196a9fdc9120bed3c0e6ed9f2d9ea0685b22a003c3a12c4a0b845779457a99d6a138151d68fabe402745727ec96032faa0b625a955091acef4e0c7aa49590af2ec5855c17acc38315797c0444ce9c0605be98dceefb3fec41ace4d909801991088f8247c8b1413b7fbf6bcde916b9fe5846dee1f3fe0529530edc162c5bd7125561f0f8062915ce89133968e1ba4d6d69e01cefc5345891785bc1f9547aec08de8f8459145e1e0f8178a8f755665317d8bb990c706bc8f31b5cad56094833d9a06622084fbbc98d3aacaedf30e1026c6ad947535a5e97b869b16dfdfb64da5fcf9069af8844f54c15c58d177c32eeba7005240e18272cc37e52ab92edfc163fbba519a73dd6717539c0b887f1216e502ef214f5075fd1fda41d37db14e47b24295c0c11de4bb13fbdab2e7303d02de69576aa0a752c76d30679c31876d483a90c73075434321d31e3cf593665d274c74e4ecbca0f449e1752ca4424982329583fa9ca31e5235f332eafe24f9806789ee7344bdaef1f114a4f55f448ffeed72ddd20125964c78ecfbc263f5834aa5ce20a589ef2f797e9a22a10e981017967cd1e4a3c509d1fadf65fe2e4350095a9cb806a82681a43956bff8d65f78eaef702e8abbbdeb29e67243736455af2a113cdd39bf0b04cf2c3acf36739eca2fcbd3109d4087132fe394a062059b36fc92b54b5b538e947ddcbb678bd9b278a31dbc0de9a6a15d5617d365bfaac3d5c75e90674dbb72272380bbcc2955962adcca2ffa732107e1bf2841b36f860da5f35f267ca612810149aa5dc0c13bb60f429f8c991096b2cd96eafa78f80f5a3fc146f835539e00162891bdf10b8cf792926daaef22189c3239f90dd82159712b6c02b9c4b8a0f69f6baa782cab41568eea76a6c4da82463a50cb96c6d98c473299d3175f514baf2f01ee6e834c5e62c606c494ceac7628f0dd1b2bead309973df0d1fe5149fe2d3e0b111f726438187b62885748c2b27a2fd5145528326ded82112c06e45d673b48e58611a91654ff862d755887cb3875630bbe09a17240a319d14ac519f0790d987bc279210d1633ad34e591747bf59a522c2ce8cba90eba74dd04c9a98e7d16fd6c9556134d96f72d646513a9ffd2dfcdc8bce65be07433df33b5cd0a3cf91f28dcfe5a05e1a51db5ab2eefd05196b8c9553555d6e1a83de05d5cc7096c6ea0fec4edffcf0a793d008b7405d543ea721f67d2b85c2316710e8b1edc266f43362336d39b42f70c0fa6e903d296d259c045c50ff8c860b0781c925ac732357f65314f0c8d8598ce380c2f40e01f7c6c68d1cd97b979552e36fa9baf3aac57e3c2d25cd220a61c1ff9aa1b3e9195f451e49b9328070bbb0f1b14463438a4e02477fbc1926264b3f0721d14ada9540e1833d5b0fa076bc2e8619818302650486fd59e6ca3f8a73ea5dc66aa89b9b1342a86b3367be2f131123f169cff2c2e9a2d590eb058ab66bd4d276cdf654cdf01ee1fd738b959208676bf99a18b607f0a41063de19cab451ebd40e0654516194c4c6ec787d193fba81fec4275b495c71ff8cdc8fbd74a6db2def3b87a607ea99aeb4828f0ffeb6cedd3142baae683c5d1f988c6d805fabb60a0aae0b36843e106b426aab916859717d66600098f1161f42dd5d977f86d279ce659cdc7b5eccfb45cc553af2b6039061ca5574d05500d88c5b7124db8da3b3f1cebf994360629a33f4aaf154bd079b2ad435abc733529dd53736e4db8f32857b63b56b8d5094b427e59621b4991cdaa371839eb1cd56d7d45f28882e0e3a2749a9c8dc77e33d2ea711a3505cf72a6f412de2fae7e95b66731b7c64bf7c281ff0a3ab3328a1f318a28466614dee8c1844e03432f621aa92a53bc60f4e221ea1df9f79bbf3f7592d868fe5764e5cfdf8e996427786f9af787b0caa60f93527db5360b05c5eb1a7ec020e4f5c8297838779c8289ccb9e59deefed948880aa2966d98017f797d772b66b850b874e15cf4b265efb360e980ed140d5a9c9534efa3aa7f3d10831fa45dd81d7692638c23402d1767efc2e6fb6976ca19764caf7983c74b26948c1004d49d3d568c378b3edb5d310d5da6536e915ec7ef090565f6a679c0f42ec1299cf81589cb13e3e4e14d2a51881de8337e9735212398df3a2fe30d3b7b618fb7decfb9fa8cec198334a8a34ca665e475749485fa76be3c780a3fc8537c2b783a3e4696f0205891d208898303a1d5887375ab0709245a7295f995500aff3581e1fbbb754f0d1350c3d7f1def23d65c05c3256e94beb50f51eb91a37af2aed55c6c245b7138a3a356c13d1ac8124bc4d7c92ed2391e28ec4625a4b974a1e547089192c286fd24995d3ebe5bcfba3911218180fb1b8c3a273aeb76e4da0f77279c7b3b776f40250b93a143f1b7f4b19e61f0fb66ee6d22f1f6c4fb5b7ec2d1411e00139843f3ff95c3f51d6c8c246caef941332f98ee71c4687a2e1e14f885738ed7f2d340a4a3cfc65ade2d6eb149d076d93f87350d1537c0bbbd7438fe6e170991c29706222c71759d1b8b7da1a0f8d10c936c910d1e1f37a712b8774704498c61bbc532f3b7dc8d0efb0c9aad2d7fb329a3f8185d388a0f06a6835d4818ba8df3f7c4091bac08c6e9c958ff29b33762792cd6df179073a8aa185540cffcc127d4857047284c4e6e0f3ca46dbd920d4a136793ddf5e099d6837d00b718233d8feefb67c5ef46e40d1c9488dd1ed84075c2a477cf230f8663e59e2d9e7682fb9642cd0f2ff9c368117b8f01544bd643feb16a7784ae75a12fd122df3a83881955c8dae2008121d7d7114c2101128a1717b2a4b9d086f2b75eece78e3b5b5adb1cacf36bcd5c3d460e061488d288d33ac35c54e6788ce99af58e12e3334b20dfe11ca35d11876fa63f60074aef9efafe018003acc35d5ed7909c53cedc56b90575efcbc69794d44c7d9bc94a7f5619a0dd3122d211b3a20abec202b0a88ded1b38dfd96aa9eaf48bf8a0571fbada8f595feb241125c73ea0a93f1a47aa8c498ecf57f2ba477091ac43493d373a70223b47b2d12462664ac55060bfcc11d34d4a9b4614f0e3f87fa791678236597f4842611515cf6958023f2d4f9812422e243661a75369d41acbcdb2680b1ca63d9bee4038a89596139fcaf06cbb201f74b03c1ed98f1115fa641907be02a3bce1977e8c523231ca46df7bf8fa86cf22cdf7b5ad8347e279bf7434dec56de501a50020372046770c0f6f85be45c945f85a983d9fed5ffcf7d83d519677413d1df7d537255b1f5a42578354f8279a006b595017d243c4970ef79e557555c3a177e1de09a4d549427e50c93d72a2cc31d45a255d75b3e6430a3328fba79840867ee9978f7323735bc7fb17550ffd0d754e436be1a713b39be840923ab21a4febb2cd2ea499ea10b86c98d816ffede0baee81e23f3e8586c83d162926e895d3c76bf3782a516b6003ac0d5a9c3c1922445ebe953fc265f8626e4b9a8f4a0aa79d1822c6f601c064fdb4b9518858ba65f28b3960ea2eb1214e1a9ec365f4ece1f083e6a62860c1f53961aba725bd8da83a9ad3204e7e2b5c829d0d1e3e69e561f20ef7a091f1a3e1adb5f61194c56fa21166110e42d30eaa6f48772aac5fd7c1f14bf2b8c449801e8acf2e8a31991a94f27ae880331102b751f406b048d58e63159741591dd2569501abe6cefa1e2076c7bb1b0e432d0eea1afed076c2674cf4b32e3a5841bceae4b9bf184ef3953a6096c16c0c8432c2b0ec1f20907043fa62f58031b4ff62101b6e4f19a1f24ce5fac916b1da1b16eb72d32fbaee288872cc7651e7c4d939d06a4ae7c53362c7929eb6c2f47e0d07499d7d599b60b4d3a27b3aae09862fb4cceebaba26f84bdcc036a3817ebd2f03416ca79fa0e4b07cec5145da3c513035d46850f98f2c30f922b10e9fed1ff7f9f7758097d104d0b4a9c3a63e90235e9b78f995af81297f0f890fb575a47a28de09e59b6e87998e5c6f992a5a8209d69ed9e2283f6606a13f57164d1522d140fbde59e4b7153a1a9add559af63387d4f9bb8d8d146d3917e1cbc415ff25b83b631a5d6235b6ca2758e1baf5a4a70b4913509e00807d15fbe26bfcf6438bffe8d5ca7c75913612ee4f5c855a7b417fb7ab8c5c7c1963724090e831d39126f777426fabd508769b372a52a5d2603524cb4a32c75c44886188475c8de48c96c42c86c61b8c563ca3fe790edb6f817b7a1e0c4b9e7c30b29eb098b47392224e2880335106916db1ef3fdaa8cff2ff309b67b4017d913f3faf5fef66f4ee13b676272f7bcc781242b9a64865f3c6517482f907ea8aa3d8e8a2f5b888555d5c5edb804feff70bd71f6cb1837b05d7e575e0a20e900f845ff2cfe4308875b935139aec321599a7c5e11da569dd86c44ec1be5d5aafa66bb4c26552871e553594fa9623f25172f5747cda15a4a927e78aae56148be30afe5e208079d072caf97899b80d527f2f0578791e309ace94c1f7026bb0d9dc66a9510c0e910db2581455b89e9fb4d2118f28c1506c7b312806cd577c59a4a789345ccbb42b2b56554c8376b9f58deb4dd183dfc10419cf6f331dc9c2685ab747a0aea91669b9f16290e2dbd38fa3d7b32903744651bfd436d1d101a7a3911ba047557771ff8e3021b5dcafa2cb8e206d1d8054ef13a00a8f55b990be4d02e5306e2858a8ca95e9568b368a4f0bf9c590dcfe94e3d97c06495cca84e2bc60549c6062690f875928423dfa097cb8e123a6dc180ba41eb8e789c948469850241181ecac03842b417f56a9e430bea3393ba2a64e9dc485d3521c22afae730902448da17fc5243b05a11e9de33d08cf383f82ce5169de84f41ae5ec72a4715872fb2127d12cf2505147bf0de1a1fb629b8a2adaa528924ebe8056caf51a35a088718b70d59f7653eaade7fef830ee56fc5bf299c1f914abe0d1ec018563c5aa700ae243a97d5bc7e35c61560689429349feb5066c11bfe8c6942dbd4709723bc2d45651ceb1edddc000878ddc265624db149e8ec1e4fe5b575254e454e1d99253f3392100554484b60a26b1ac3141f8773a8029d7ee69b0c412e016f8be23854a76dd66547a9e00b15d308305ce799e30a108e91d872b9f60ce0356d57f6ba33a9f26bbeb24bd322a8f1b99ea9cd521b53fa1994b255372a939e4a3745afeecbdd8c9b0e7742bcbc956342c2414d16bffa2c7095f925c2b992b895f422f0a8ed4b0f007f39c1b07b0f4a1f01b03dd9e3f945e0415293a94f4553dac551dbbb10b99e0b91d7c3078ea782e5f84d7df5457f1eb794d69c4bbc8068ac840fbdbd7eebae3acf325969fe70459c24cc26ca2450474965fa51eda3599f26ab582e8e8cc904b34040bfcdd9e4af499934c738797e4c2826874bccd6fee88755859665136366dcefc86ce39dde28d9e27af11ecd7800a0250b0c66c248ba843b5d37b9d3967075bea5a74247a2bba08a40dd7e87f1e1a6c3c0c64db4b23f24533abea64c06c15a48f1189f45941553c3cbd64a8b0fe58d0eb70773029895f5db5e553339c013329d79ccd4e7ed56ebed990b54df4331b8b252704e353662428d54971437c63d010f2a770a97d098a2e39108e525ebdf960a3c8e73384409522e40eba7f1a43e949f03f4074d36bb5b9c4d25b2f3094436595c7a76d6406b0e4c9ac3969dac49936c3bd8b19054d8b8f091fa5459be40b848e5a9e10cdb6faa020c32e1b7b98ddff8d3551d9f80a9e303a38a2e28a02ec17dc5e2f3763a17eaac779299274991f8ba3b80a7d39dfc64e31b9eebe3c49db359a0b311147a2fc3ff707db8c913bad11095a4e37bdd19a7603999f5d753f17192a92239d7f2d9e430d5e25a4f406655ed4592aa8f2fcf003dd1548b669f2db826a6a859cfaa310406a7465ad1414c7903b687bc1eb93ce6c049aefa2984b3ddebc6bfd0cbb7e2e4df4e7879dd4e42ca645801a432d8a4d682d9d73c81d9b62b1555ac12e7a59e5cfc0cada4277314bebeaf5884d23f9920aaf8bc0699d1ff8610dcaea4d19f8d8dd039ec5d73b306f2cb23ff3fd3f3dc2fe9a93bf305f76bffc4148be6b7b6236e39e1374a647deac90034dfe2bc818ef2a2ce27e098bf7b4e41a52867a8511f8dafac6223c9ae44f66ca31324dfdf94181bf2eb75a3f5d1bedc79ced0e015da543305b33db2095252a08b5697a8141c1a18b6c13f7b1159fd56c96d78a4fa1ae3899e017fb45ada61fd4c911578093d1224f0f0522a7419d7e1dfa85549b60567dc091cc931105bcc45b1d32aab8612c75a53a5fdf0d8ee109c48c0659263e42b8d29082145bbbd7e21a9fdc19f950b681921db6851449e38b861cd913a95e8452395b6c3fb307e40514130fbdb1169bfbd00133b5c98c90a74f2036c19b364b6af9800b899f640b32d7033c41f8d52eb8d36c2d91bb54fc8b8c4a1f61d4b0f4d80d62c3484f38463df1c461760fa10841de53e08e6fdff27bf5e64b328b6f46deb7f5e1d97ca52c01429f1edc53437cf5644a7040782da32c2b3972fe6ca357190d4cc87a5af13e41715dd18bcaa62199ec7de9eeac42cbcdb70f9e23ad0809678d5491c10d94f93f982d44e0b5166a15fc81470e0b17322c0dea3f2ad01b318bb21ceaf45049aa612e0be4c2a26cb878f519ccde5642e120bd292c7db65594c9e88bbdce8964e029224ca1d271a602278e0c628a31f868756e97a4fbfe7cc20c38a29c00fca04999ebff3a9a426f1fdf02b9010d4a75b75febae0ff43d846a77d925d8181999d8eff9e469ff9525ddb49a488f7bdcdbb78f203f3ad959badf18d536b8a275ef7eddab7b36ec27f0262fa5a0ce3e461b31c4927d04f8f0f756539860096b1239a2da25627a77fb47bcfcf2dc57044fe11f9274444bebcfb788aca73fe10d358626576eae7ab45f90937cee0ca1ab703e08e791ad48998f5fcb097bc769f722da8e9f777e2fb860e89d62c0e00eaf16c87afd6dc9210dd37ce178cb212d5dff810b92ed029339acaef5d6f8d19ca5e025d71d1b97802c0765dc8cba7eca7eac273a09d3abddcaf92c1ad0717c1b129116b25315d26958b2f6ece2dbbbb810c3fd3ce3b09ffca069870ac1ff1e4cad22129256fdd730663689c35aeb021ea1c5853bdd43a9e2e8a94ad4be2c6582f13ceefa399a9b0d5c178b04e189c6e563dd1643cc7e4a694df8a223b8822cc902ee9ba1aa58d3b548f99ab5772e17b5b1b4da724ad70049b847ec99a91e6367458a99f07aedc30198431a6588f319a9f3af52076f8347d05ccb991ddc9582e9b35a054317c7899b1a374bcfd047c3d52ef560a17d0a1db47af420cf44afb30e12186fa798a36dae1da4788e37b87f74758e15033dda29bc7569be2d35278ca1f42ebf74d5fa74d7618900d46940c19084c0f7845419f65f2d343e5d9aa8bb8a4ec54920b56a59f2e8c990d1ccc963e059ae21a551b22932cb1d77bb9d7eb6a1308531a4ea531b09f96e089f38a5e4bd454196736b64e0192e6f79ffbbf931e4ddd6609001a9a591c4cd1928232efd9668e93335f42ed29ada77153a6ef754ea3d3fdcf55bac2f0c3f81556eafe69ccf04eea81027cb65c15a320440cefe3811134ac714e13b81a909be6b74a225f0e8179dc27481f47c256232c5f51eab2cdd7a88395b90df97fc682719fa84057d43feeaa492a0c2e8651fdfd49ee153713d685da4ed41eee41cc32010dc6af6934ad85755b768862b929532ba7c855be63a234c162b940709ad82a3154473076a5b50aa752104f374809f4bd257c0662eb9623b5e52298984215e4bfcf686fb8436abb3e5408a0596ac31e84ba26479190572314cb04135bd0a3c7278e0e82972bb694ac308db6951a745d37f70ca1aa66e877983b58db3a443d204cf48ed4b3e06b1563a7f65c42b96c35ea4052f0c9e1b03f80926ede3e244c1a5528ab66adb99439c8268c769d4390007827cbea305e43fa15ff5f062c0b89dcffb7cba70782f30fe1641fbfbc248b95d8498f76273117cf33b694c99b7240b1d2c572d62da49b39049d5edf308c09d5a04145fbebf624f0e4b2f67ba961d15256ea265a25b4ddeb27694a0add4fc94a07e23bfbc5f987f2c7f89d686043c6be796e55e6da7333bd0c780945557f8c7873b7504581fe013a76ef831224e3a56841ceb206fcf1dddf038aef1360fed8f8b2bc51cfd03f445cc3fdf88170623643aebf2941d55e5d858fc807d9a8643fe5975e4e024172889f548d1c4670408feeafc89e9a2b1fdce3789c91306b0a5b9f97c90f8ba12504008d7129aee0785dc2201308bd4f8ec35e40c5ce0b7b0ff26722ae2f42d5182d055c0e90e26afa2975a696edb9a739e1c96f6165f8a4dd59c3b374595e4fd765c080a220bf27ffcf306eb2a1b46a1c4c2dcb915475909e7e87d07614004b82c143db9adf4edc09eba30fbe0e2369fec610879bea0bb5ff618c253be39df3b9153f504574442e640915fd293ae8432ee584f23a0474476be34adede8d8d2be66814473b7a5e537e693eedfe68a5d7f383d70c1e96cad71434fe439bf70762bfd89fc30e3a56e0f39e9aadfd32d469da754f437502012f1efaa10870ca38653d3c05836ecfd4bf6c88e9b403d835920dd6bd17a4df4779de09b7a888690e7c17a27f1b198197b06096ef279ae8978ee417a9068f1d7d7bd088a2f1f5f84b91a3c9dfbfee57f1bf1028208950e03c8782dcba66a509270fcd2be5e867750329875999e8b97eebde2ca86744a31b9fb8552b73d81e43decc03bde6e89e746a2536f4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
