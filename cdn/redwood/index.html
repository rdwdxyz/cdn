<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b6fb55bce67328691e0ebe1719d138671023ec8d7f492fb5e721605cee5c0b46fb4110262fb2a229e50ed555421d6de0bb27b86bc5e1866f416c93a3fbc4c89a3c6c144c0d4e318d2c838b4f2d6146bdf2162d0efe282ddec4684d974257082d6944dc5f4e95ab3c27475634858cd378299e9b3c411efe3580ab0ac665f4a497e04c11480b44e070c6a6fcfaef8fcfa96f998b86ff3c4fc55f424bf7fbaaa357e66db8547cd6a01fcbdfc93023b782fe0bbdee83055acf358c1e94ad5c9f8e8477a6aec02d67f9b2dbec2e1afbb4d03062e68f19fb5814be110ac175eb8f57f26108749cc0998f3ad98b47da0035be769e9bf79460be8cc02c488fb32807048bbf956438e0b33af4bd7e0c3d4f05ce6f68d2b2c812665523ff5901545f7ff9adf811ff2a0cc60cdebcf7864aa62376848dae56a71188899896ac58f7bbcc31699f4a7ed64b3e18191feed2ec1f2f9a685bf8787d4c093ad65a0f6c12fb8181cc54ca30d9c44e275cc16f854848f8daca590e185944ef8cbaa3b7360ea0501bffba8574add2ebf63009e643d6e73d2a4ded074609a118ff463185d4d2d34d3960166c199847358ad106211e4e0241bc49fd70acec307fcd63f1aaf7b0a15c38f1ca2f65faad914b21f960cd3dadf1994987cc4de07233af4b40764aeb02650b0cb277bbd6041aa67e631976bf16b069fe5a40da2c8c72b9f0ec2c02ddda059d1bdaef8e31dfee08928360493ce23b6b5e215ec8a2415a013f4ec1908bf5b3509620c8a176d850dc5f235c772ce8df98f60322699f48d6d6eec1bd52302947300ff6e7afe53f6e526b50ea356c0c1a07a1afb81c30d08b835ee6ebeb8303d8d223bef615ee0cfaf8c31f052200c5decd71dd0432cef53692e0821b13056e5653de5d15e87b51a1305a0352b33b1484231ca8129af168e09b87daa4532f2d603ceedffca7fe5dcde28906ef77d4eca6a5a1e44b9106e1ab5c1bf28872e652d71c67336a844788b21778a01ce8916a90a60f019ea7bd315123054c5dd6c6f37aa742e80999d654ad1fb77c3c4ebdbb1e98d7a4b289c9fb3f63af0934fd55d6aa1f973ea3c6782b0a9d8029cb4f0e38726433a972d17fbbff4ae25edf09f557088836c3a66311947a6546da3ae8aa7fd4dc490f3a7b8dc979883ea095a243e98c0b51ba6a496edf794b704a8e8dee68a7aed8ce469945d8c593ded3cfa3004eb455f56b2d7e940540d76ed26c8791f6a0ee9c33ce4a8398bd0526052cdef0f2b38ff7f9d4de8aebb992b1686322def20c45bff1d424f47e800927fca9d2dd5771072229f0c30487663418926d7da4efdd11d38831bbeb55b2b66c864b2cce1c47bdfeaf36ac425f9ea9fcc8e3953e58779f11762201ce4452ee84683acd5a44044d3cbe25c8c8c8e9ee163d4ab3b2c028ebe5056524a3974ae9ce4cc87bc48abdd14887ea2bff9c4b8fbf7150f27a02bee9c9e4a6a2f21c23407083523b50fcca0e7a9f02621e97258bc875378d60d46714879f8fbdba89fbf2224e1843f8fcb4284bf07613e163277972c66310a2ec891e804359fc256c698758166bfd7783a05545503e87d66c676288dd758642fa21f617c0baa1624dd5e767d02aa51eb3ec6d80a4df1b44c325d9297345937ed6f8aed17eb25f698a2914625739acf53626d8c5172cac089fc2f0064f37714898c30c93c98df98a899fe20ae93b6e44a797807a2a8500d18dc4da692859da12dc52baa1c614785d9462f642ce1fe1ca11feeea1adfa7ccd6b245ad445419cd2cb39382a60b7c1a866870d75c8be116602d0c2f6dcd7cafebf61bca209d2af9f62d10cba6e9060ecebde09f38998f14434e80ac11ec2709bd7f740e5feee0fe555d2c3fa79ec5d61b87190963060aa3b2849ec0963c9801c5827e9700470bf7c11265fbb45c749e53cab751312de7d1abb8f144506a072751ceca411ff493e220be417103f1b4d69204f888b539a64982181bae2f26edd50f7463ab02c59f0d901db9861b436e7c4c00aa3f373d7f6a373ff9b8f5bb01cac9322c464d5a2b7ff5ebb6f827393fad5c093cb51e99c20dc9e3c2f7082da3e6b41a806641736e446a07cd1ceadf5ccd35747cda8e784d9ed47898f1d63379295f830106bdd5fbc7779391d7b85fcc3b3399793565e7e88ebfb0ec24ada0cda53d61a7c4d86a8c843e9c3457a84350e89d0712176dd9598e6a394b56d5ed4fcb446fc93fe32573defe91285077b0043f6b5b4cb032c0a31babcac903d77a01e88b43103ce39124b4ab6eee8f868ed4ae689f186f318ce1e00e34f88318e188117c79b2d84276b4806acaedd4b95e08e68a3c84285401aad1b59308c5bd87a157c4377eeafd0b124ac28e6a82321bcf3721aea70a3187d1793e3dc087c1a9ed32bf8035e00e4d08fcd6bf11358bcb12b914ac92c3f4a0eafb0223db2f377231b10d259d22a233883d6df85727118276d239615e0852b9c05c123694c9b7eaca7f63ad1adddb071f454092948210f0fc5e4746d079beccd4ee3a642c202bac4b7674ab8fd0b8e91c2aeec697960d133a5a012ee6b5e49513c9543ddb840fdc11a3f8fb196c159b7e0d9b88bef94e2ccf166202ad02dce4d7e8b49dbeb5958004c7864025d4a5e0a6649a01e989548743ba83771b309db3ef4e1f8a782129905f859c5e44c67cf2a2484421a62c9aa7dc7629ac85fed0f63e84a223254ed9edb21bf100c7bcfbfce56258d942d38228a193cd8dc0a6372bb29852875dc9ca4fc7c1f205631bd673700cc615943c96f68194ac0c17bbac607d342b5cf0506d8e8b4edbeeb96bcd96866604ef3bc91867c65892ded31a249443764b61ff861b2903d17bc38031b0e9e1b2c7eaa04a55e01172e20116b24dc208e48ac45da89f766d4a1a0f02f67da3ebe592c6b54fe812acd2bde23cc8328f4cde2f3ca1b785988b529f808fd98ceac7453c3cd8c28c0cd95614b5bba8cc2e8d1e29420d9a9d05d87c33cc2add299ef479d0ba52d3e7f2cdb3ee5e28ba31d3ecfed10f3a6c5f885c918523fcec316d8d9fae8e72a7103bb6de5b72672c500842af07181f4166cfb985b0fe0c12c25c7d0565016a2801725a3e26f37d1411924ee1169a329133eea8eccbc2345672cca217e57335bb0dda429fe2ca211d6fe3822188c314e59893a0ae16d687e537825bba394d32f8baf01828c404e59a94d79c45e0db29f513a2f131924729d47fb9a45fcd1ac5e7d429362c036d01bab6ca94e8232554be02460fa468fe10baf102d836ab9b36916bd20c92ff493e6efc72f1ec72126e551acbcdc50614c495dfc029df114871f62ce93a04b2b69438cb380e33476c33437fa38c30c45a479ed1448d504b1a7701973b81506e645f7b5b6e16fdec2133ced3b9b22f99d4d03eb9c99a5d7ce8295be388e3334cc2510c71c8107abbabc3e5eabf60ffce1faf83c6edd88beaecd826711dff82261c35f32c1e78c5e33e4d8017298800c3ae1e9313e6bc11765cb3cd6626067e61d6a35a7afdee180fea11748d0722fdbe6696d312ba9241bb3975aa9ae4a53fda6daf40b4f2c8bb935e1232c70d6417fca30ef878ae301bb47008fc2e78028f208e56023d3561c2bfa3282f46069d0fef77e7296d79e117bbf021818b7eea56c531b526732ce36e149b98194b9d8550aaba09f3927271be4290df2c89932d6815f977647f69a1f85130d80605623e7e75e62dc0f4fab05dcf0cc787c2951d90bcde7af04419ac3695387d2044ce0ebd3cffe0fcdd7e3a3e95b097c16092f85c9d6e675b4f129b6957fc663f53276e72aa05f4014dbbdb009857f9cdf1d56ed466ab4bcc30dff196653e09684a62d03ccdf61852f12441baaa0343b87b3fc3b9b39e10135c05e1564f7168ad85ffba89a1848aa4cc1c8a2bfc5af3e0b8a80947f619279b21dfaa7f32ff6dc6e5a5898214bf29c6e73fbdcf547e785758687818a058e2039b431f4031627eee7a736eb22ac5b75067d145dfae0a1289b7724e4781f4ee388af1631f7b1872abfeffbff6d58cad3c02d33b28dd598d81d0e7ab428a5e138578753df077e4ae2aaa509e76ebf827e1cca772bb8929f7d832adb7411279fd8b5c7c043953ccec352cf59cb0609679029cabe9ea8861ca936e55840b4b708b1581cbc5fd7f37c23a359e01190c2b4345fc55afd28aabcfe33b3109f0f4bcb3d84eaea8d2639cfa396b393a3705d0ec54e237e6608e17a0b75623e8d008892e533716822a0de85839f8259734b6e835a7d181b95cd43a7fd47e98a8809ad95d7cfecdac5da3bab95759ac71b175db92010d59adddb7cef45f90220a936eeefeb52bcab80c195662b35266366766324fe612f9f2dd2224c54492e92a301506bc214ec39b70207e3b3364fa42889e7669c6dda183613d13005850ea72d915d83a7bef839ed2bf63ea92962566f07f7b1b2d3a8b9e86ec40fc7aa39822c0b18e96330ff4481c30024dee8a49b4597338fcb420ce3089467f7cb0d1dce5b298fe074c618d630935b564029e36f734dc7e05c706547fca3063d71eb56d7776be0628e2a6b820ed738784e079765a6d64f68058e9564596d9e2bea230c43412c3c1b5e166e3f300a6b8f6e64ccc8c7bc856a98a1b742313499d2083b7ed2db14ece87e94330369408d9c95153a2388de8c052decf05e1a052f27fa4d1dbf9e50bc25faef18012878bc13c72eb08095a159d2a076fdb5d34fda2d56434ac6102acb17b52c915934f3b07e3ebab634471b8c8e9d03ef8175e353870fe34c9d7a93a8af01d06b29c4673e78aa342e33eca684b37847103d33c6680ed6f612dbd4224e27c786bde99bdeb3e8fb1d52bd4f93be6280a094094e8827d460b43ee39cca4b9036a8b105258bb6d2bcc0d8036371d0fb340f0ced39c9cd05f4a589142799729c304527c84abbe9d29a52df27b5db37bc7ab3015b726edd9413d96952b1ad5be5491771c7f64cdea7fcd0421f06cd7cba4e7de943f97fcb347051282eb34da8b729dace830c7da09ef6d7e5b51db24cead445547155bcc2dcaad7649fb0052375652d66bab99302a0b511c0ffff5a57d20f6f12ebeae0ec4338b5ce9fc436b160baea69861d07d9fa614d9e89e3e9ce603068721fc83f9957358bf60fb83dcb487ac723a155c256cc69787e6de64a2ef88a90549db8d459175219f581f3ad129872eddf1cae147df03453f3e21faa0d64c57ffd9a7d67033502a2353021d24c9ae8218bed44c392a713f42df1441ef204b3e0447495561cb322710ce58e318e7082e7fbf7a09b910248c6ca2d57e76dd6696abb798e462f925e2aba89eef029e4bc0eed43660863a62752cb7f06a662398a5b0babf52a0b1dade99f6c6912e9fa056111f6bfce019feba6f3c0d1fdc1ac7d5c7e2a30fc34e6bf60e15f19125da9aa47186f28034bb1f066a38ebe81895e112893af83f3067c6fd8d9c0f1203aef79fa864a8810840cefb86b423b1cb28f9756746a7f8e73601641925f0e055ee8502ec732f2d69c165498e2f79a93649df7ed32c600dd1f2c5789f2bff4e5d18eab0d09e4f9aed899ae5bedb0ec27adb591d2e48d10d8fb03658b36fa9d491a09e7c4e1dc625695b2b5b0bc0613776cd8f12e548618243eeb94a19f1fedba5c5026cfbd41409939287fbecfa3478757952dd3dfb56d10724bf4f4e4a9f4786098bf1ff398efc471a437b2440a0d27d9d2e5c28bc33190a24c6f99b5be50c3031f6c802c8a8957aec86326d797e37ff507923de627fff54e168f4aa4ddf577d09ae3167d1926c3f800ecb1a776a8c086b06e8553e55acfc13aef859daeefccdb89b178f2f1fab0bc21e954fa88cce56750dbc0b5b3733d0ad50e29a923f0380634b9f2647d71c256ee68275cd0ada9f2fa4a17a74abe2c9027db1264478188dac2ef763abbee976358fdf55c61e740211bfc368e7597b045d887e7feb71ad66a26db4d9f3461266467cf47e9b2b5cae94822f46a4d69aa50a175ab67561f30c8b617612059d3b0495ad5c5fc3e4fe0b58d4ca5295343840d73f64da1b33720b8e01c5e9c2f9e2050dacad881c171550a892034d8f5417f43a3aa8e6555b41c46b403b7941e84e323a840d3c577802df52424e92de95c28570027e2373295fe3286613d3f9bd520a6c14de53ef519e269464ad4f645ee79b33146381024eb76e7498b7e4efa3914543e026d3a33bfdec1faed07aeab006eb7a5f0a377f71b51de2eee22422ba46d04a02ff8ce19d5826265eb0434606f7701bd1ada1ba7b95ec6dafbacdacc0b1be1fc6b0260ff337999573012b0d3e5f1973a432b2702ae84ac319d1cd44afa2c6741ddef9377582c94b8acac05825fd66f1d0676afc8633440fc110d155c1fbcdad507056a88f86bd267a382ca5bb363c2f3ea48937317b26a5b15a3909b5d2c5222aab7271497d99fcc127e1bd84249629e347430ce703c038af7c76dd4ec1d5dd5b511b41e00b8612fb9eb1e0ad4bc57300438883ddce747dd551d52a3aac841a664f038f9390bcf3a49e5c1311ed18e0f9b5cebc51a3ff3ab6b5c6c3243805eb2ef6bf86950b7201f3e83aef557c6d16dc022247c937395649a941dd0f51a4d281d1bc449b2dfe584da41babaca3da06933ef91aba5088e91903ff60caf1a33c3e541e4b1c5529625c7e6732aaf173c205d88d1f8fa397b9bb729764046a2d3957c9441b6ec0c5265c15b98e57bba71a11d8ea3fb00f3d939999eb0ff95d89f6ecf4f8d80838a7f01b8a110410f081abf7f3804d3ae022d8a0ec06e633bbabbeddc1de50a88dcecd350385ec2a57edd622b239c762b68badfd7c93614b4aa0df0400ea318393c5f181631c4c456d76afdf0a2555da7d3c7f2ea6cc8e0f9d62721c43800c05ca0290e2bf618c4b7dcdbbc24925033cb0635926bf27138567dfaa760a3e33cbfd01b8a0cdf26b15d1a343a67b63c850534093008c14554abe31736d59bb252ea9faf57d075bcae345396e51f03f4ed6760e710c426a15f15808108ab59cabcd5bdc56c1386574ddc0b05b301068aaffe059661655eb6923ef8ae2455e95a103f993e4f2c10493f8029acc312219e7d2a186cc9af795c2967e6986023b61f5089073006042ab7373753c0eca269816143d50ae4668118b7891a21e7950d85e44811689d3cdd67947d6833ee2220b3a548c18e52cdfdeeffcd43899ea0c794b9989bf5eb05d55da803834e973d0b0a1838bce787398b8669a9f1ca5047989c497eb03da53fae33a5be238a2145f6dcb7bb8d3cf0645a0adc595aa7beed1eba62f6894afbc04d184d442d4a833c8af34bb395892b53e2d4c365b80c5c50275457e3112f53e0149c37a816dbc4601eee9fe666873b708bfa9e9fb8252e6878214c43e26ee57e92c9b00475432eeb87233567290f91f7f0ac3e7fea8f9fe0e022c93dc604c993ed6d877bc0d3baf8af5de040c76b8214a9e4df9d36db27b8e239b6ca0069b3cd56bd0d46243cc75274c475278d03baa307b80578fc7165d3e9ada0dfd0e385f5cc871ab2730abe1528647a5879bc3e7dbdead99436545c9fca6db4b0bd6baeeaed047240dac35221de8902081ab20393b2891d29f323044b72db49dc543a70d2e6185148c29618fc23b4e9dcff3e6cd2397273d5da9edb5005003a8b6439d747f22f70bad654e9b254299aa8189ad6d9855eb0d2fee060801b25a77253fed40bd7729fb9dcead870ebe47ed7a60d054ded1461d3512057a5787e9f047c14341c7808800a0ecf08464cec2b094d695e8815af6d42669221e4b3f0188e29d2ffe9be5f1d25e5779d03438beb252de048b8e634b261ce48bf8451a3afe5ddef7a53aa91b9f1a1ff85772cf451197b0a61d685b6dd793499d7eb3b0cbcffb0e0b7d65b0990e59bd717a030ca71106fa6a0ffa8fd7336959b9a445ba1b24590ba41a47da021760fa429b0b3b821925f2ce27832310ba2e8f911b2a55489533df60a878507c54d5b5c6b7a5759a11f1bc9ea527aae0b46b4fd08a822469913417a7dc3bab3653def5c737ea908edb8ab7b86cd4df12e9fe6144c1f58d4a74702e75db63489bcc63afd9271ee47c5e96603673697f816b212c6c872b5856689aa668628b18393f5d08277052791a00b3ad795a66e285bdd336e46b05337d4d5bf5326bd07df76128d905b790bab5bc2996a1cfb8a4b91e2de0d332e01c343643e8c11ebe87765467bb4b712c8c4ceaccf4010914bc73a62100d5ff660479e1c949348388ef0def283b1a557c4855f1e15a1f129bccfa0cbd299bf728f88d2615cc2e0ad41a9c7b21ac8d7a81200fd98c7feb3d896fe071fe7b0825e7e0102f818c440cb5ecb6f85495bcf57b2159ae31e7f830f566b7de98d94ed7ad9ac147d3a75d3cfd82fd9bab3e55fb3894905632aae748f8491f48ff54e63248679e44d56d7870ee74d2186bdc486c8be3d7834b93536ef2142b4e4da393853d305939ee3c1d28eeba75e526bc965ba59f0b934058b72a2fc1e959f35b529c81c464fe2067ae7d520f756747dc3f2d76750edd83e08b537474dd87dd7a46ba4a1052c3aee660e8315648a7c2f96fadf812084d696ecbe03c529773a4beee3411c79ff7aee24d12026a5d6ed575cb62f319ab90753919a602d2e8bd249cb0163aee40997eab6cb0474d3f0a4b22c3326c51584e9810e504a9b7abecad5c4dae99abaf2d779c108adf51ec54bc5ad62bdbbfd696089a20cef2cf8af67ddc6006a3a856d29c9825dc01c73cb3652e55666eaac7549ffe7af56997e100c2df79eb8fe8d65370d6c02739c0690ed1ddbba18be303238cf0871b99fa84a9b3577ecb95166cd9feb605b51c9c627569c825dbac684e5fd5f1e3692eb001c114c909e18392d46214f6eed9ec762304ed69399f68d24baa5f7065aff9213483f62e45b8f1104ef4ec04fac431f33c8775042c3c3bfb9bad141274d822fda6fe6829608d9e1a91557f57dc4eb259c4c00fd56d46058cb0d4713c97206fb51e3ee21b25cca04fed56cbb0f22da7fd0663b033420a1980e24cec831391d6f6c22f102a3ad1cd381817b11a498d50101cb6310c634593dd707a6f05e67e5a99f02f979c7d63df93fc7f308f1af86251ffb392e81549d59e7f31704c6fc95be56c772149606aa0ee674ecbf8b7b721649daa1b189b3bdf0dd9abf733fe06771a72d0231c796c18083506c1ff437439854c0c53b66945585716c87fcb188b5797ceb48ffddc2992f2db6357fa13a06e8241acc125b879f6a170d9594a42858fe430f02a5dec3c432991d5a550dd43423c326efffd3ab94a5457a4e8d07ede78ffec0abc2e93c5a3066b1f0781a0165cbc3d6b2d92176699ebd910e4a73acde5176ade9dc29b0243894093d679e4f70cc8bbeae948350fbdbfe04f84af325013c6854e41ac566550157e5730dba65c9ea6cf02b9f13c646bc7b1bc841c16581cd7b4fdce1dace8b64183f9fc1d5918650801a99d6eaac668ad005188f384a24927cdc18f297325188338017630cfea4c90df1729623584ec405e813b8186f5d483770e31fd16a43a5ba09442e4ebbe312dacd11af8d69fec8464c5aafa8b974b9fd72eaacbae9031d98635e50c4406ff228970f492a14b4cd5ed00e6f4b1f8b78b3ac5e58c6eeadf5a58df09482193eaf765112bdda5b7a44cd6a8e57cf2798ef23e4a9e159e042a5a4598018b388be9e83187b5bea2d988bcfbdfff7eaa36ded16032762a87d49f2e8539d5490555c61bf0467e96c06f1d92263d4f03622dfc1273b6f1e64e49379252d5091364b104d84fd44fd37cb2fbef51fa941dfe4b45b6c380a4e13963f79cfbcdbedf851d07f877089a9020ff1649d057da8d8a07c712bc448b5f76687b2f874a49a4b0a704e9132e07c2f9518795a78b9c19dd3204b17486b1706f9e75022ca43ef2fdbd89bd18124173026b17e62f1f6d7ce330de12cd9ef98c846e6b3525c4a32a495df0421373b4b956dff3de612ecba82a8222e42f7162cdb307a224d97402ac0fb051266bf4534d0d344ba2bed0abed2569c83ef3846d0b8f475018febb2e39834f665ff4dbece8b2454c77752c44b4393b18c73fb29d7f3e2ab90becb29af560948c443bba3bf6409249fc418237c3c31271bbf3b50e771158529f6bbc02c6dd6c8678f32f934ec4bdb75aa7f8f432f20484fc3718bea038aa290970537d2a3fc94b43fa4c6505669dde1a687244c05831d0d1c5c766969e4232fb57672a5c8e619433294087856145c05e66340f5b2d076e286dca6793c6fe6d73fb4ec96dbec7f0594bb089c023f01fe590629b29ce89b703c143f9f85d9ef607ef34f0a19f38a9bcdc40c545435519e5a4013cf5c3257685c2ce63696ec50ff498ef896e58c239c6c2c5b0c6d658d3b33746358b37195cfecae602cb161e8501d8e1ef7772365dd03a57aaeaf256e93b7a9100088510df255aa157da491595bb36b7f13b1177471cfa14b7afb2e9436fa15dfde271f0818b593a91ceaa43128f5c2e313cfcb6c5bc9caf7eb64541e6b9b97a25fe6ae81519ef48cc262b6f327da31ebabf18634c47dc4af40869d8f7ef15ce46891b88a55bfc9affa9c4ae53b1e18bf3835902a3474888297c11980901c18cba18b12d56cdffa265d3fc0008df898ff9122f11fd3a17afcdae6976e186e18797263ea7e98a4b1a2e051610d0f16e6e95759f97f71986bed744688926532118c0ac55ce172edac9019dd57fd2b6250b00ef9f2102ad308589de72ba6618c529490e15e3d51ce1b861829584c79e0b2a49942f52d5dc0137ae17c58e1fae28e801685e9558dba3a62e175585eb85a8259736dfdcd0850ac9fcda780ae82400509c814fbfc19adba443a8cfbe197aeb83416876e618aef5bc20f95fd3e45f804318fcef1aeb94d35de31e0d9c5796f5e5927046c94632edc505728027d82d73a662262955760a7c2d69370dcc6dddab24caf163bc99a625f028b5b821f15365393bae03707239c3a528c37272b5cb88b762e3461e19b8f2e3f57ce823042088e5b5c09141b551d16168649938b3b3f8cab8fcf1777f40c3e84c550945c525e5445de714996702c57bc7a16da01b1925072b8e56ed93cc9e43cf60842a26080d65a99f6d16a29c501ed98448897e57f96f3a8146ece5f3df4fe9c0192fc33261ccf3ffd8cd95e375d105455af17a71d0694debf98f118e75388a3802b78083370281b544ba5c69508eb00494a92f386511936e25a8f6721b09a78daf5c2750bb6d8c9813cf62a26041c27f0899de51ecb77953b7003e6bb54cee958bba70deed2849bdd9823ecd0c741acac272a581f4e681e9dfcc90a74d321458b6df8ac096b716f9d144b0ed7db8a7e306b15c870d06e686eacde4ec1b1e9dd8b009359ce54b13eec1cce8f2f81a67a7c69ecf410ebd179c599277bf5a606a2047e7811b8363450df5b417f1b9418194c326b67ba008178d3ec42c69bf38e4866652d2c9a2362062935df737070bb87e8086a4c89c437b139aed4744207de1be4078e644640d6c128b8d1ed790c93b138d3e5a22f36461748eba298c2d1b458e22fead9502eaa63acef9fbbc0865cc010937606d471004f2b6c9c88581331544d09ec596636fc3457a8e150c7e792ea010ba202e4cf4f59f6a7e169190c6e49bca628e9d00470bc1b36972a5dcacbcb72b886d7721d939b6fc504ed2fd61d76a055bbc2f71317bd0e5f92c4ec3f591513c846730fea1056438ab160e88d8adbb76c80da4a1bd74a480f35263123e15ea930b4e1b6c12a81142869a29ee1293ccda0c4d18cc7ac126b2c63287d7f2cb2b69bfdf094b530811cabdd4f3028122600f65bbd21a2477159af9346ef87a3a6420935a18c493455eb97fef33e6b605decf4a709bc858cbb00579b99a54014066c26d00c394e6a84cf8f854c61065709d29903e1324d29c2e83777ce4c5d0b50cdb41bd48688d3127629233ab673ad9ed79457fe5fb145df920024bd6d4a3b51074a94255f6f28c0dec4d280ef80140b3f69591d4176cc12fb2d9a9b7b6190eeb08ff9ce5d204b3a978c6bf5537ca89af9c8dce42ab570e0758451c138cfbfe163344ccb8213246435da680b3003bfecf99d2e7ee86f64186ac2209263c7cdf301ecf2a732aa69989ac96caa71d0691223e4d6ced1222129d92124c6982bf77bec434e76fd1660fd23ece2aea8d580f63b6def7d2cc511b786108e8fd22c4e485c4bc50621895c4eb80ae4233f2030ed3de354acaa4d78620452cabd8e025e39ac5e6381486ebe89f769d2c665345f836bed3cedba2ea0009a4ca0869a4b73ca0afc0afbaae529afec13aebd3f3dd0d322c07fcaf706611502f99a15d30f9332b62dfb4e336c3a5c6d26510c4b2a3983baac5db86376da2da37e1954caddb26ffceb95d82931d1604344d72ca3b8aa2873dfde78362dbb1908b6697ba81de8c08300def71de243836d65164b7c458ab8b4d630fd335165b63d72f6ecf0900cda3ad4a411e5b09790d5d25122771f4f8ef4a2443ed994d615829e17b0206f9b0842416ad58e0b80a3812e2ab27c8c8d0a9193c378af31a947366880b257f7c02db1850fb020adb8a5cd9fadab37eba5247b954155cd71ba26f51ccc4123edf0d5bbb5b2ac56ac805e9c474ad1e1637067c6c3d9a7b064a29cf8fb41169adb28235b1aefb3d7b70d47a9cded49969187c5658dba138bfd53a69c0134e92751168e8909a580b66125abc22c21d08ff03f9b9db488bc5d103fa5535ad7b70b1f4143ea51ec007c2f2740993774bff4977a743a65a73a98c1f42ab33a1f1443ad0010f4d90b62c9565a50923e095dc9f4f0d049c96b28f866fcc93d5b5c28ba9cba3cc3f7def55040c14743b1afd3029150c412ee0ba0874d15de893f00e38e7e1b347a1b317a4f2d505bb0534cf9dab94324d20fb22246cb57730cb25355cb82ca8ddf3a7d0716d2adb4b4c48bed8bf19b3b8aa63774571bbc3f080d1098dd7112bef88ce92547c39095cc9e3924144f9ada59c6fb24a43573d7f34bbd535243fa3a4a56e746296791fa8492544b11b25fe4b01654d36c849fd5406c33a1207cc62624aeddac98156aee0e9515f01d1bf602c08a9b7ff3730e04b0e63268f77a4c0aeb77db1b63ef2b82e62a511b2b18e4d7e3ba9023f7f499fe12605914fbc4da96b9175d69cb3bc51cb0c48cb0674ccf9e000afd972c991f84159da94ab20850d2595f8920e1c77be92daa5650b4e0d3dda910e93a6787c9559b4daf536c9966cf7e79845f327eb0835ac9d348371358303c3de5b131d5047e4d24b9cab580f77ad99770392c69d61cfa0aec16263082027c43802465b1d38caef57f45d0a3739a61383fe0a7e5ef344f92a53afdc5a0de61fedc965c6d3790b07b6dd0e938b13d688b34fcc906743642acf74b9ae757594070f5227a081a9af53648cf3c10e417abc6ef48d4017ef48157a2d48340fa0148227201d36dfababedd803596f41ee615f7798d8c584819196271dcdd57249b5990759082f4aed7dd151c97c5b6ef2cfba52cb9e22971cfd26d67423883f12e2b9e1f0fedf684efa8c6c883ac0f2534d21c67afd0f839a1a4af641ca90542ec05d3aa9be47f21bea9b3169122d4e35842ab5e10feaf105fbfe3bcd0afc9a370137aa8e4b2b273edd28af5d26ae6b377f89928cf01f6b0088f627a26cb4c1a884d2b5b9f9d182333d675b07b63566bd72a201099d9e4cc9f358636bf6c4aa8f68265cf8c2331341fa043e902d25233c5d5e9b15a6a35d5bca72dc4f0afe585891eaf8a87268057f394fcd4b952e7614553967f2b176955b5e9863c07fd2162bf453abc7ad94e008ef697fc2cafd47789a82246117ac315b09d3095d3a6d366511ac95a7a33650e052652ff5ce12980ac5f7f412b0322d26177c15492acc7aca306df172283355ecd520c76701a9a88b0835034768930e719088097cab4045a477754933ebd07c7747640459564bbec4a01bfc0056c763e0b34adb38ff8b9d290db6954cb027dbf57e233d7eef1a99f3904a61f4dc4e05e895d44a1b900e0a7fe0502460e609256d40354b290e7a81752b544cdf5de1bf8e7fe96a57f7bbe87abe16136339532d631ae0042fd173785c9c1afae1757fa66b1e4772b5070901cc8bd9a702adbc834bcf0a515ae2ac52318d0db0d2c123d90197b207ded11869f48955226d6df8713e51c2298237da4af21d1f470f86c502488dbaff38aefb4da58146671f73230f7e484896c80b5491cc7ce05336057a772ffe803fc32f5f0ec2adf9e2132f5e0cac3aeb06c7029117b9fed2d95a8a4431f426c4068ceeec6b5c2ffaf01a0ede624b9715d443cd7b50ade3750f95d8410e8c0921e46cdcf2d39b541909c0d1645d2992a9c604d0ca70105cdbef08b92b5102f0104df92f7b70db4841a6fdc6aae6c3b1e7384a26b699263f2a904b10b9a9ffe3a67dfc3b441df7dd8f8675977ad0cf3919327e22bc04c3900068defde600d590c376914d0305ae2352d69ea553ee2a516e08e7eabb9998ad7f9ed200fa0d4e224d6cfabbbda7a8af8446dc3cd6301a1702ce49e194f5a57798ff65d4668a231b1bb217dea75ccddb59318bff2d2ea234c31caf7642f4d0c2c9322be0d425c40a3e7ba25803b7d6a950e080d30771e1efbd03d454a6fb4149f56d2f258ac7aac3a597dadf56d8cf2bde30c3e1c7977c3f71ccb01bfe57077f081c01692e6090f5d3c63d47a5895b6e69fdf8a1b941a8cf7a2eb96d04f5cfa753d8736da615fc9eed7c57877a94d97f78f1fd8f73ac577b304acfa26618646988bbf69485085c3925d92fbf5ed706f59a5cbedbecbb1c39785a12447dea28462a928c99143d8108e010c55cf9c3caee812067469b35ee06d1be8dfc239e988c6e35d31839fd89395ca33dfce3242a30a413821b72d00a2be95d4a897600f7b089271a348561dbdc314566a342a460528535eb90acbdb0e0446f2d5b35f61f0455c5920de3124321ff0accfc78efd7b02bbd4b658ffc2c35941262a3cebcc74bdacba8d5f156ce793021ef7bd3196fbb46ea92aa17e3272c4ad7afe4732b64f314a8a53ee9be3cde2260b6a856e03d891722fe5d4888ac80189522d7e629cb7857ceffc1cd0348fac01934f1bbc3b34a8fa1b26f90ca0956580d6cacac3403bc67caca5fc1baee9882b9f4393c8ea5085131c026da4b35d723ec4ebe73669a73c586c11b1bd0dec5d8cb7a6f97f7a7d09a91ea5908bec50827a6d087029e7696bbdd4311368da983faf566ada7ab5cd364382f647d479dd03d50f5a19ea276e8f11612d30a4614ca0338e5e4079ddc493643c4f9cd61da3a8d56645cd133b4279d8f987611e3c226ae434eabf2963b341e77665bc5cdeaa2eb1a3ab7adc8289ee25f65af8d4744a0ff4bd415669617e4a4170456339ec35c8bf8434a79a80c8cad2e8dbbf12e3ff14f02d480db551ddfb8040be15d09dfc18f604bb4c3f19a2dc3d704fe66f3f37e6513e00b2d2b21395c6e58a0bbc872d1a946877c34eab86e5eccd3b159ee85c9ca48594955e829b8551fd1047b10506ed01a59c56b525d422880b50a9c15bf5835712f568bed8f4bb9c447f782bd3f61747dff38ff758e4249e427bad17cf097dc78755094530523d596121fcb787f926a235f208e1644f916b5f3577e15e8b77884f63d9b96119745907cc26956fc2c8c4893eded49659327ca8dd25cb76b0e59804751cb7c64f54a277bc61822cf5652f55a5b5f2c852f5f6bd52cbe655a966381e00309ca98feb8c598574d34aad9c4fc7c3a5e45d56d7e5a4df8d764c6e1d39c389b6f7a6e2cf44e5c1f99b9f604b537d0812fdeadce8fc2918b69e7070832f900af6e43182df4605219d1603ce6e51b2ad0da44fc38d4d3a3247d672aa037dd4dc69133ca241588d433a66dec247b2984434e4f06564f97c49fa5d29c687c267e856e30d79fd4a29ee3b6dcd6c15f5ab2cc1937340b032750624361d20bb43f7bdad7338e8526b9949ddb06649e7aa13fe49334e50401086ee46bfbdb05980a6995d7c2d57ef12a581d3e5d14686092de0f467ac3fe1948451f0cd60a2238c9905310caad2f554c6746761280ff99861c5e8d1c40e59af5ad262e2569173bffd17ab8fec4fa0120e855bb2ec550e8e3b143f2ea3fdbe6924c261c31865620c937806f21499847c832055f374bce0286b03d4d4cb74ba0b22c39865f2b4797f15efdec558390d19396824406724281af0cee26cc97f35c6d46889aa15b9c9b043c3ffec5a6d48e0f6adebc8bfc631d4d31b209ae7141df86193a0b5d1d7768d65fdf9c8a594db76059ec3dbe7d688b959464c647f001a6d9ecc893debc9e9deac2a0c2c256506b95a8f317e44881d645b05eee3b1fbdadc11bfc1c4cdbcceb7209d6c3dd995becf4ea3c1f1d70f82395d660c39b45286ab8df9abcc75f801ba617bcbff50f61c8e4abe76708b57514969d4de1dfac9015b54791156e6174075bc82542ca2995e3e97358603d83e516d1e9b293c47c1fdf06f91a7a563ded43be7eaa1248faf726cf1e058dd24cf92a1e2b3fc31aecc9ee2ccbfe07e90d992daf892c8bc01c4a698d9da3f3b83f6d5d92d10b2bc57ccb399f30ddd10468d9358afb6527e3a4e23f4748884090cefbc39b6092b73712091560cdb25ca87c4e7eb52f0dcc7857970970b7c1832cb530cbfe2e095cf9cdb92a7b19e79625338c90d8928bf704fbe87f340ee7782908e69059a27289a45cf3980988cc9e2f65b52fefa199920c8d9c6b9535f4207500ca5a1f4ca7717e2e5415ff7c9bcbc918e9242a4029a1fb85143d3bf17ffe74b0e7aa9a299d1627d7ab115e849d3a532197f306f3e848ca767ea84ce3841bcd6a08deb6802ec49049d1bc4d5ea78a97c22378fe832e12836a4ba662ecc023e78d020ab6b9098ff7f3110f346584f5e2a22fb48e7466bd2853abdba7633570a1276056b7f47982633a9bbb67a503b0447d28a54852a29081adff821f8f846770fb20837383274eea864f51411aed58d9cf0199c9b1d61464a79553cfff0631d05815ee7c3725a7986686156d63481c5f24a168c89e72e56448bc5a8aca8a28e3af27e2d910ab42a82f4e59b9e92023f7128f3fdec666d0abcce773267da726f2aebdc6d5884641a1a2e874830e71fa9bb7d456a3d932be56c84433dc572c5f2d58858a2fd4a621dde00167295f67a9bc5a4ae87deab6f0f59c7ad29fb6580b96f645bc0df3fcb326d1e0f94bff68d4d218472775b51dff71c0d77a34fc21f10697e1a44c2c6720d555433a26ba6b4799b5bc79e0fe13d5476720dd7e1c4be0bb2453c14232d947099a96b71960011ce80a31b7245d89dcfcbc3b2258612eda404b88bd3032fb51b37bef06c91cce70817e77f44c7373e4639c8600816662b62db2f31ce2d43199613cf2a06af98960cdebf1271fcf0b7ba78b0ebd7239eb608194d7fe63099745c844f7faf3c18ad8a1a713661738dfb61c0b5396fb4f22ff969d048e95bc76e2c937f357166e76ecc673495ba9eb082a87009110ba54e3bc2cdade61ce13ee7c7068f91531293135c15c780d3df19fddda8e8507d5df869fd6f3c7cd24320868198c48f07b06282ccbeda3de97dc791b9b31187bdbf48da579c654ff13e2407de72f36b3a44da0930b384090a286f21a03545c732607fe67e1d0cd7db6562f6a36f2a0ae798df37da2e9b94c32d35348e9926551c2bbe30fae5d70c34228db95166e15dd02e9bcd346e1e89f787d33b3d595366f3184b7ccf316b7e7f8129d13c6f3237a407f7df61f2f1f3bfe5cd2040e46ec247f4fff57766a95bd083cf264639e605bb38b5491c55d50b66cf08d9a24e627f6a1b6f8ea01b6a462120cb8b8a2ea671fbc42585b9864a48ea986f71680a028651b6b0cca4a54631cf895ae2b09df325433ef4b227740dd0523c9da6bc8ac5fad297fb7fc19cfa5b2b26662c962d46b85b189deebcd1754ebf5725d4b9ae550b8f58bed98854e853a2e7a4a75774fead0a3b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
