<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5ebd9607ee6d02d63642560aedc20bdad85e6c8fcc341e25932a2499a0a9976c92c0b7b70c12d70b6d1e12e3e017db10e64e2d3f9427e0a973cd493c786fbe698db701f6e91e88f2521533d053331594e76940f1e1bb3d7f0e5dea02fbe6f3adcaefa8ae2a35ac9955afd53e4b93c06a74ac2ac2be0eaacf535d7e5908074b342c0624089c83b5fc6a2b70c3b69805f711cac26fd953a57a74420449c24897fb0f0a00a2b9cd23ae792003d6b65e269c27601afd5fcbd4bd2d952f48042056800a26d0e5557c57533d67ac403df552f9aa7f98ac15011ad31e2546ad2c83fa847578c3d0a0d90f4cedc4df81e76d394d3a4fde1c4a61742b77efab47246631b3992b6d7b332920d610b7f4d471b460e0427dd64e55ba10eef0e46a9edcc9e28b55e54b07c2b6035dbd2719032fc3744f21ed4642466ae4584be5c3280bf19f0007a73d16b2e93c860d4d265ea92b560673a0358c83b8d6a150d34a5220c7498c2147132ec315e2841bba29d88537cd1e8fad55ce2fcb4a05cb5e500fafb30f46182d17f1c369ebc21b83296d99925de44a64cfb32de213799edad0c46ac31e355427b889b129fdd8f62d7932652002ce777b8146f770688dc2560325996b539384c22feb5f1b3f5114ed16285d116f8a8473be0221b65a8becdd34e01c8912ecded304969e63cb5c8622063731f084d086d3762f5c5222fb415faf76a9b3bd62c57f062ab80409b22450b13326a2a57b60f953026d21dd0b68606c01a0d29d1d435a520b6c10772d45333fe50ef8429ecb900e345035d30f652867983e15bb047d57a320ac24619f4891b8c49d9b42e5b6760ac91f56a3c8340ee34c328ac8973624c4202aa4fae64b46af99e1bba4e2d16e2f7b30b86e254b94ca37bbbc888754c55a1f561ce75dbff39f333783cc4171a560b6f64b2079730e7003d618c45456bab0118281fc6ea323877f84ed1f398e85f975f3f989287e7318f503e43ec17cf68cb905bd378af996bbfc6b72b848e947520af8ddc91ad8178d70e9c65c4c0c68e2607a29e6ea4ed799b0a0dbbaed8cb2d481464b7284005085187e87534597af450405522baba978ac92b3d7c95753d0b25d7cb2fb329b03d5137ac5ac93dc682202611948d809499743cd66a6a4dacb7e9ae6389484536e6094f1293627a6d27b95124b59b7a2bda4a1f0735faaf0055fa647cb6812ce9147ef07caafb97ff9c90f1541036caf8d2854394149b3d6e2233e87fd07c069cb67baa93104606c483d6ad71629ab1f53cc6daecec84da574ff486c3a2f425dbf2f582651dba2712e5bcd3c994e2c4724157eba42814f0cb4ca40525cb477a494d384e3c5014685c74f83cdadda3b4a0b492540fd8ad6b7b5de3dffa077c0fc5b09c539b32c1c25d0e22df637a09588b41b703d63c06937b231f4c48532aeeb47122a6d2ffe471d7a3dbcb8e919163d1a101b24ad48f8e89206eb04fa6f53b32203b8e26314d3bf104200930a155af61b2992f0e3be81f23392ee1e5a0203687c31ca707b67f16187cb334b0b5436820cc25c4c23fc5aefcb49064488a90fe87bd79be0cb261b8613f83c5696bee39a3201c28c8e5efe8b44250ba29a7d04f8b5602b19e6724afb8e1b07093de10839cad37005538f7778d44de7e411ca109ee927133c87f1a8b0ae06628301a100aa24a8a2a0a485c4e7d8b867fd6cf9fc719a76947957001f69da499fd4ca813fee0767e310dbee58ff7c8d3efb2fbc21672d3179f4ddff789f0271bb91a6237a5654e6e497a017261467876b3068df62a90d8945519cc483534752a78e3ac999a1262a7463fae522f36dfea44adc9c07d6aef0fe6839ba0f48d075cf89a2002309d4b3b1c23f3b2a87ce3088ac26fd0da8622251175f80c1abaa3f210b08fc4a6eb82518c01d4d9e3e12cabb22fe7fa7c607f1b66c3ec9ca2b79b4b4fe61cf67e95a10cf106842aa640736043a685a69c96b3e564914d0de7c5643f28de220a070b19b9e17b1a45123c97bb036ad06eac3df3c87af33236106d72dfd7cfc75e020db4ad84d9fef6981e2196127b2fb2ede77fbfc1c034734b5e081044c44914096dbf4cea7aa78a4944177b9200b04b7b21bbf3b2bd2ffcc5e847c7766c59c0fec248dd796275d68307919459fe578feca3aca2a33ffc2fb3e721aeae9bd34722ab89fa538a243221a9d6f39d3fc1cd4af0ac89623a67284e3d4db69ec372ddf7384a87c3c3af6366fc8cf2587c6fbb2e88ae66a726428ff2450e59286841dc31e3b472500bf37b88d101d2ecd8151b44c6343bab2c991e3e6d300d0d4ae425aa3daacafce4daa60a13dede0ddc422752463a5651f5ae265b1048d72c88cca8ca5d4f64cee2347bce0682c7c4874dd832bce6421d00a998b64f2a0c40d46ef97d7aa252196dce79b8d2266a360139c0ef691b529b0438d4138e61603b58f8fe375e0552907237e5891566b74d5ac59f2d43ac036370ccb0d5550d89dbc71cbb5f71c02914a9b466c71c1bc8abee71acee699fac66a1beba826b7a075c773469c06cf28f402c54b701c543eea16e34c992d97311a4ec82d12f06350d14673f1ceaf3925ad535618735d0440838f508c5f8616830e5d81789ac8ca528c8385f36160620854164f364d2d455e014d83bea591f671c485bb87b3b76f8dddd1c23bbe706cc565692a134d49f68bf75758395e2776caf3f4b29f3252bdf7ffb4f1092b5a05aa4e6a545a99646ba575bb591a2872b5d0c1a1f16d0d367ce3300b1f0b2fd37b56356857dd995a15e3821b17f2cf58c4237535ef04f5c12b2bd9f8c64a1d7bd38066dcd5779427149c4e7be024a15cca47ce831d5f7297d57645f45a02237ec706b218b07b551a2ba48e8fae2d446fa176b85482f41dca2c745720d10959f02ff8b7a1c00f043757c7093c89c2f206ecec13a49800413478be4702951c9a62b454c756556f444733f41443bc310b1a1f18da65b2f4de5185d05b62a7065d0b0113c637a7ed09a13d49b5e6d0389eedc77bcb09d5e11e659726cf971d1e5b86c59d12e58495f8538927aaac152f05c4689280560492b84b36b5d042fa6650770b0f2d83d8d5032ac2ef97a00bdac39c079953224f52079c988d1d6408e9d493c9cc3e6c14b4a795f45b5450b5586b7998ac5f26172dc0aa5fc69edd2703a06953f82fbc19177d2b86c52ee48a85403d413f9e05431e9febc0cff15fb8032d43c291416fb0e5560bffef1dc115f1531c1aaac7089902ebe2aef9e4b3695593f394a4add682e003cf74fbaef979340d9a2901ad11c1dc71d5ad9be73034abde03b0f653d5409699c4ee9c8e3ddd62ccf56871da96278c6fcc8a1d13472f32e14c8b171373dc7d00308804886d6562a2d14d2659ba0821faf0a6fc76e4a0bf7c5edc0a0cc6a6eb54db6ff421405f7df642fa56c51399dec851deab426b3a369b7089e3f565bad1392d9a0db1791e877798c616ac822edac4ae79ee06b267e3da2421238c844072c18dafd4859e79025c7e7744ca3e182cc4a0cd58b44fa7e31c06632528e98979a4ac887ba6a892cf41db95a9d4bd4f1e3df01afd171aacd29f4081255735004ac3ac9047d4f24232379d339cb3ddde461f14078f121edb50a6dc56195cf4ef443205f57406e670b4725030499535f97b90d2a747116df87b27085e53a402309109c80692ab1621ec9617a5162c17fc52eb918f11040a5e2da2ebb8be7e4d997b67990f68e0918e61db3dfda13ff5f44a93d9edd89ce9b9730d926a4fea04f1c1c9d4c641a8d72cc400e56c5e5839e6534d78a5a1379cc2dd7ad8ba4a7ebf0f61fea4ce950e117c01098162815196d7845f8f2bd50a6d1488739eb60889147dffc30e2d94b1cfd21425ff0331039641b18b2d3f5ce3c369976070bba11f7736f98746f18527bd1075ff39b33e01d7654b624ceaa5767045dac67998af75c9416a2608a836bf6c06e4a90405808eac8749366745196071d5a3079898484095b4bdb6656a416674f4ba40d550be96024489fa2a16c11e5d2c75bef62d0d6908564ef305b533d6c94eed129ad23e247426e2afaedfd59abd1edff649cacfb42f67e3304558d2543850ed6f848f77b07903be8f96b1b76c1472296b0e211629b0b657635437389fabeee823dfa491fba9c0673c8547d7862c8ce4c8960a8d63080ad45ef06a4484fd3c55e26f75c8fb81aabd638ba057a52a3a3dda4daa9c1872902f32bdcd52dbfdd36767f992ae852ed859308afba7144049efb73180a21f684f8e75bfa447fe72fb27d782b7357616e91ef7d14f69bafa1fb48c37602352c03381412c9ae32781fa3aecdecd69be53639fd4c615779a0a0a969e0c5de23731c8e5bcb6c8ad77b2fe9d9b7e0f02a430b25b271944201f41df7e53dcba2aef2fc65303b01c3ba83280c383934736b5c861ee6b72400ba632af994dda312f9d35ad1a93fb017fcd9dfcabb95fde85a54ef997ecd49c84b4aa2e88f48e79ef78bde63595a00f3328d44614ff05d01432962f2476a39b238104866c4a950eb922e8611323c65df46debde862bdaf28b1d2058988927887099af3a00592c0c959a9a7fb8e98b4f46a7a5e69f3659810084d5570deafd72503b1a020e003dc15a088919b95b6656f0d71839e1ad7133aded7df47e9237b95a5c22028bee607c2587978d02b6022bc1ebc5874e73a3d6870d92fdedd0cc6afeed697394a05b6e7fe878fb19672d459eaf058ca757ec8d2237ed6ef374b150cacd6bcc3c1becc19ba005fbd5c7130df77558bc7b30126464723df92ef929267b06f6ec6683f00132d438865aafa6a21aac3af767bce08f4e74ebf380d5aae3c83cbc9f0750c91505026e4025e46df64991eff4075d068db4b6b361d61130a1d5575f11b85ca249b3bd76b638a72964ec749e42c66d8eb933a07d5c194741996ba83b68a4cf9cdd1a444c6259728b84ee2c7db7d4fa6869806f8c9bb2209b2f63fd944103ed9c03d1afee9a0d37331ac6bcb55c02ce6c2c9d722e105d65030441095db074929307e54a7a20fe044d7a40353de8d690b756b27e1d4032ed8c24b8e59675b649bb93731baad135940ed8e63c8023d843862f03a204731b05e27ce3bd3f963b3fc923eb02eedf621d564ca27a025fa92d10ae6031c261f710aaa70a2b1f317560c244b16e25bcdae4ad32886c500d283487889f52cbc3eb0cbf5e78f8405ddcfb1e4f65bb601d37312ce9af25465fd7cda63793e13f309a244ca64994e6b49e3efaf05b5efa2f7bc5b97034a4f84082fd7d1f17bf5b913f38aa524c8fcb9d88bc94d9a45baf8c22e3a93ccdc95a03700fed6308805b325f0885045724fcb58c13d941e44803551fda46295472f87b1ebd7b6b888f619d75aa249b20f7718ac37eda5c2e4416ae0370c0b80ff9995cdfddf62edd7d820d1abca4060c432ebd59f0ea5cb6b6b0e0d9e5e094a991b330bd5b1a2e4f0908cb85937b3b3e316750bda22157ee43b75828ce4b8a5130ec8d4012ba6e5f7b11ae23ff2a789fdacc0b65864298633e820003d09a49778cd8a8994a954d8a838c14034e5cf275366f29b75440709e4bae718bc7a29b18a38dc799a70284af3dbdf205454908752be280cf43ecbdb0db42420c7914972ebdab18bc960e0f96bf60c81cc2ed195f6ca2b7134c39c4daafa83100ef098ab64af4473562c4cfe06109f85d33b5eb84cc158efecf9752ed4c0b4b644a7e8e3a8daf74e82dc9e5d695c2896f785d643a2edd2788e1d2f5526bb6cca69eee3d6cca7792063ebf7cbbbd4afec9b9768522e604bd40194594241ed16e7b85db633e1c40569bf0bc4cd5cd65436b1d199f1168fe6a139b8e530f35f24402ad8e207c18c3b9e1904ee6d95c0249840ad62916879f32b8f16d796f5c81c3f6c0b021b55b9666d23b725984a6b2d2a2616600bd1a4d623c6d79e8520e6b945c4d882df1335a0560b7538fb5fc635860d30595130a79e7624ea1ad46be4eeb11e4ca8648043074d7089df3ff75685d91bc65ec8a33c71338d7ddb38a8a73475dbbce3d9939280f959b2dd0bf478a724b83088fed1a9c5762e9070576d21985cebc025591601e59b844d913fb2ebac87b3560f7a751f8d809e7297ef75e8595c33f3eb12687745999e7d4d0bda329670a3c1ac92669e9e41bdb6e4cf7608b0a946ef0686f2a1de1cd988729788e3a4ec22601eb262bfd162442171554c337a80cde6f066cf2bf927a0bf819b6966d745274f0ef13f0b65ab8ab037b6c5b85923c04aa33c694e6084d13363891b3c09f5ea7ee5df5110d60a8de38c57eef4a438f6911b303356e1bb94872c7be3a2fb95385bc37aedabed3f7f0925fd764de3a97f44cbd4bfa7fa7d995e05186145be4b8aa0c2656063acf976e18a521995ecaeac01141e3d0f035660ad04ac2b0311fe766aa05bafc02fdc5e04866c1a758bac17f6097906b812b29a0ecbf1604d4a91c8f049196dd36e695f7051ec42bce8e1c25ec9fe403a51f60d852ee612ec78705e08818df3904767d3605d724d666a302cb76ce8b424aa845bbe3910fa2100002f65b50c4a252c58e7efa14ea2ffc3d1541ed83108169f66f64fd9b66a330b8e6d1777f27872ea9b6495b8450fb9ff73504898e3d8ac16f347d75cf21aa027562311494dfd07f189e0bd40e71b66952ae6e4b3d3efba9e2850007ed925348fe0c167b87c4d3695242e0aed8add24b69235bb513a4049c348f63077582fdb543475bbb0858a00010338536e13bf5f5b62fe012bd25df2b490a4b01ef8f91bd7862e0cd529a8a42938032246212e1ef9b9a109774430d02da21283e2f60c00260cf96dabaf97f7886a04dcb477e33381bf7bdee4c9ed002f4f3160c78de276506245c0a8fb7cd86359eb460855a362904d8179504dd069111a75932e6004992007c5a36224a92a22b448e4f2dc86be197dad50e9b603e47accad8e7bf7dd0df16a8b2f0e1907e485bc1bb10bbd05d456b527edeb3c5b4580410a6e57492f41c9a2f0cecfbe61a049da392ffd9f8570a5e80ec12045254c67f848011af56128f73824edf47b15f7e11e4af63e2b1f1dc2b570d21f0042f2770d40eb716bdaf9a5c90120673bd3f576cca4ac5d46d9282655e11cbd198c77a466f91c3a59d61fe4b8f3be1a3b7181268da3b9e5058cd62b997adb054be1d8c02f4d3f5de255617cb8ab0e6a860cfe327c3c18f94e596ab10083067dca1e0dd01b6d19eca4e32d6d5cfbb0a19e9fb65099f3dc95e7b7bf4d9c969ddd48e6e7fbe411387bbdf2048deb5326991b846da96ef4955d5bf7673d23621a392d4ebed0a353d61c3188bccb8f357525bd0f89be5b8f528141986114c5d9f22dc49aa608274a5f74858603e1b195e0b2edd80e1a1d6b07641b23555a507ec19d23c7fd2d297f1d34960d1c73cab8204478aac134a05a4cce32f562d46d17831f52f4a462845ca60c6d317f802f30918ad0b505dd0221950f698ce5f15422b84480f223d17bfb4a52c9ccb8b6fc53c9c36606d44caea97917b4e08df5ce7ca77e229c9b1af6a0b5da3a9a1f5cd0a16c7e95fd91d2451494a9afc08b82d99931a1b19cf9a2ef1f8a4e6cd38eb008ec50f5b4da47e7daf77b5e3a00a37a5c3c879b52ec7df9f7bc083567c215a5e53b94079aa9f3656024eb0568add222c93ee2682543cb4ded57e5c3bf5ad1c18b4742206853856f4197265d883f68dd3a138be839c5550852b73965a84aed6e22a2d0d29634cea6015e4bee70a32cd650e21df6fc88a55c5cc8c65567efaf7da8df17af7afd009e5c4927f0cab4a9b6cddb87e1dd43b8b81d61c16424b9301315f1e499332707e0891aa56c267331aff41c818f17e2f464390220e7e4b96ef157639de9f3e4fce14bab7d871aca74c5c4932b38ad7f275c3e11cbd1ae8aa71ec94569e6a14fcbafd26c36a9d66525c1b58ec947b62568e858ca50f11f5de0c914d91b3f5d3a6430c0df5fa2c499664190a438715e27ca86a72dd1e070e4ac503690210833e05c82d061fed780cbc35b7510216510f8fb6b7aecc30008b293c6026051b58b769dfcc15a6c2c9aea21d8a0793299a516cdffeca29adc2d36844952e4a13282cbf4e91d192ef6175444c6b7585eed49bae88ad6f343782187bad121357a34bb1124d02f37da78baba4d3511b6d37914bb3379cb8233a2e66737d922ae146805dc1215a0f9518ef11d5260029c23f2c5c128cfa344f223deddc2f7dd7d665266691d4c49f8025fba4aa4e7ac0c654afff37a73c0d3801f8dc67e1b66ca036b7ed8f822632e8ee1e3c09e57a9b566d3c0f0472b5288a91d31856c9ac3530d1d13fbb62fe95c0ad7cdc8e24521421bf435583071c9e89900a9f90d7c99477d974127430fc4c37557f1ea1f10de094edfd2fa3ee4c709219219398cb608bc1d809d0cbe4e3bff40a95bce1bbb77c1e3a227cd31942ab7fa62ec40c55bb9816b0a33e6667a687c2ef68a0e9301d346db0804506893d53cd804e4bc5e6a45bd3f97393137081cd8da16a0efec133a4388c2ba91d749c8b4189db337ef575154af44c40048e4c3ae6a5d1ce096491c9bfaa2ca2c6a7b60667ea395b46c3ee352054b706db46a95811402c348b94aa16a6292cfabdfc4458eac5d03baaa226714a1002e0893f7c0f94040cadf83c8f0e2eda956a572dc50f2d7723fa11dbfd1c7228ef230d69243edabcdca479d0134f397bb09701ebdf3dad71d9792c0c28bd40138d0e7c2bb7d94b68bcdd4e998b51ecb5f8db9b1846fbc2a6f4ae6a843bc0a55e2684a4fb8594693e2acdc6fca22d2323befcb946a586bb783c493f5b481b0638d68a07bc326227ac55844995bad6dc3bc94156063f6886c237cf578ef7e6fdc2e5323cfd49c82953157cb46fe4e8cf132ed7a210e75411e35df93982df2c8c56ad6075d8ceb8461f0947bbae07e1d3baea589770de7c8a4955757f66573c1c1b1df1f3366cb4401222827e10855b998dd639cd97a3dfbe017cf136a18396e3e3a6e097b4179bac15895d5be911b1aeb8403ce35bbcad1113aebac229ba2d2b5b17d2cff3a3a4a026c3bb064d1e2c6308920861ff6de0d341cb6af1d42a6caa5df963d65849d812609819700349aaf2c364876946fc4b6706bdd1acc559ff87257c2f3bc76fc3e5187f9cff124797c2b70ce6ce3c4f4729ac85efd6a33fd06eb4dbb5667e9cc3994744696169d2656ac860b802e7dd417280c63b54858ace9651361d7fc8e9447d978891762ba5d49c69d3a14a283e29d949e108085e076ba9f29e38191840c5425b839385b24cc858ddcb120f7cb1e463ba54ec414d13871ad4a3bbe6bdb22aa9d5b45ff0f1076365f0037acc69c1339171a860d110591e55ad19d5d0780536f46cbce2152d0b97dc986258d5a1b22575703346aae0b92f2814fc7cb424ddd2a2f99e199af6bee060df74a72795209ca4832ddac9d4ab5158e233ee28d6c8270259566e0121cc6ac7eff21e401499ceb8217d18c8b2a71019aa3645929459f5f1c808bf2657233b050474b8b26595b11c3dd127c746fbf2f1c6190c3ff0bcb47e692bc344bba2e4efe537c525b5f34715146afc5662001b397affb9329676f4ebabea7a4680e125269e0c3b8fc44899129e43c038024510e5bf8eb5e6eb579a8a80395a6f8a0633a70930ac32eb70253d0e56d60103ed878753208eabf0b94ec2d96f8d0fd1325dbb69901f37c78d8fc9b0e53e3e21dc0da8c2b31f4d0b60268d038817bdd2990ad0746409b8478e146580683e4efccca77873d48a3885866d98a6e783c623cfeb27d4e851b45cee115781da0cad2de240d509e5f360e7256305941eb6c2cb4770f6fae21048724bf24e0f89f470dd36a1b6ad633ed5b3ddd0ee2078de78dae2111471db303b1eba9075734d91c5a0c52849e6e3dc60c579e1faa9933b84cf5f4c42659e181af15a57924f9fde3348ceb8f89270c966b401b91f3875e8c7fb09fc53676e5842ac678ba7f9801532f067658568809c98d9a007b16ac1f877c1990bbf6b4c9cd7ddf4824593020c2daadd2c9f4f2e62f03caf7896b0a3abb634bd2aa62ee6de88258c4c0f4684f4d71d713ac2c1f7c251aeb3dae4dc1b92263264d82c707f0e27011fe74211d3088297ca1ba3a0f740598c8877fb78fb7c682315c7a3cc78e7e4342f3a7306bb582b8958f600233f2856f282347de0c065de0e0b08a39d77551796f8453bf28266a2866b1cd675b1f998ce3922ae5515958a24e977e41e2d5ab46246fa34b6b88e178f18daec3a99303097be371299ba3a4923b2115e7a2d655e0b8526d2f424617be32a405e29dfe324aacbbf57047aa98c98645b2b6d1f4451fda50b846c84af7cdef5028b822fe60e6a44a78087d21d3965246209fe23987c1d818b4dddb29d45bdbf6ca5ba7b5a412ed2d588b3aea8ca19cd7ada63179cc6848a0046ac367218b154b56319cae1f52e6a7aae26d70d9c4f1a8a9394488b07796d9732ed24442f0bd25cef65586b4e35427ec4b0b946f826c172eeeb740718f2a6787b9606300915b559ca95e6369ee05441f334439d72614b6857bf078c6c8d22c58b301f63b35031b213a3c75d9066bdf2ec5e0c23761792bb2e60c38bed272bd0e417ef834ccc93d08b9a6124ed618053d55b06fac095ec433d5b44ace0c4ed04c766098f8a3c3f24c09ed7425b0785e52b511320470e56fa717f7f05fd43a4630bd177dfcc67c444e35bb52b056cd62436093c97a8e390d5145ee9ee72dda24129d09f404cdf0da6a23fcb091af9fb9efa15382b41364e345083c23202b1f3bc87ee01d486d0983b17b85a0e007bf40447c3a0247169c89ea4fdb5b87aa87e8cd79e8cdc8250a2cd9c564f415068719c1ad9b99ce3425cea22fcbfd91abaea5affc99f3de39c1aef3952de41b1235e25c933bc4f965099e49eefa8813c0b4325a4e34c633dee3060d6cbaf84ee7c40e74489b5038f667cd3f6ca57001f51f139485aa44873dfe3477364827b112c9de74cb3027ce75ae9773415c57e6a5a0314cecfa472e25e26e0ec625aab91b9b5cc348adad64a99ad0a042a2dc95e15ae4909e648cc13247015fea9f423a4c6da86dd17e6167c21e4046441971293d98538bc1bb08fb98aacfa2032003c9b3fb35cbf00167268c04821be3a5e9b73c68833e14711659149e0e01bdc6d8d6f4abf5e2fd19b521910b4b2331095b88ccac33f737d286f1d69d935c5109303204c01e93ca5edd92c366cd68bad69bf963384522114d5bac1cb7c68839e7f361c995f426e0abd5210046970fa28d92db0fcecbf89a5bb86582cc07fd6169ffe412e7d8c1435ffdb9ebb6610f99c79564bf6f92f35630e34860838e812d3fe63e38dc99fa81b92f3f80a23d1290a026f7092aa16979f2a20f75c36efd553cd3d2d9ed8c81b1abc6e3ee1b1bde6a4bec5e48adacd937faa86c2d8251687b9a6d99fb3f361da0538640c3e81e5c9130a7c991e51149eec0cfe00dfd2d789991b555644c4ba7e2ddcd8a8568d85b5377f5fd4b45565a1a031f625c2d4af2110515a46408438920eea0ac76e23be4f7638ec964bc2ff2622c16149558f613b6be003bf6dbd5d83de70b2396f2bf6968bc8df63067d606520de570a0ecb1589d97e0786e4db598d9402e800b1221d5a3f3e1c6f4b9427d696bfcff71a4b62ae3ab20e9c1b7269861c24c5207428184acfad2e1b4605dd8eef89c26ac8ea46e253e254fff88c7f243a1f07a0515b7514418743e924dba1ee5f810eca70a31d0142db890f71cff0d3db2bce50beefed0c135514af80877d851ba0ff0e92a1dd991d2937ba644ec9d3f293cf27ad6f158fa2a02aa2dc31966c3137e2ab6e22429f4cb02ac41e0771ddc8bb02502abd6e21b696977fa8135f1f9f6e65a1f1af57cbe881f87684a427848d427bad3dd43f01fe29d64fd23cd675453d934af26beaebabd0f2f6a34263041ae5488721092ed99b1eb00fb22c148f66638ab15208611e934b6b0c8cc3d39de8ccc8388e68962ba3317509e4d12971e726187f404223237f1ba4c09ecc068047cfb9556dd7c395ef85696064e928bb0ce7ae23fbca607f806e4b713b1eb7267f7bcf81ea7f6cc01f3600f659e8d3a217ff0ae6f4519d5d21f32bf47fecd7440fefe3ed959ca78e5755ab00eac8d877412881e2d7873191e87bd3e544f3056bb8847e7b3e12e279248fe6bfa67515239e0391da17f370f35c58d8e9f7fb396845295f8b3e1da3d4987a1ed6249855600c37c12a9c8b1f4b4841ae9e8d309f483a478f27620d0984faf27f133fbc877b426fd26d176015f24801b6d9e3038072376f202173962521007c08ea74afc0999a082cc0d09d74accf02d470b3c21e03da097353a4d4b993cbb1b0d75d4021f851edc85af3b45a45672466ce35e3cdb7301ba62517e40bb1022dbf3f35b6bae6eb73f2ac5c46d2a672a2558d1218ab3b968b840cb6bb19d40dc1c3ddd5510d4012643cec23b61675e8a6cb511e1e9c73f23a5a40b3029c871f8e6df0cad4ad8cada1f074435eb75a5cb14aee85f395ab39e5b19efbe8de02eff3ca5960581074482bf6ee72abec574d44b00a7431124bcd8b319a5b34f50b06c2e39162d27bc011414042eba4f9c0b2f9c7a9b9b02880253e288d701ac504fd93d5deb1391d42a5e5f14191368c35adbf1b1b7118b69f1ca5016ee367da06e3d3acf49a8be2007bc65c9f82ff9f27ac7c5dd02c9ea51ea9f82c9ee2bf5145a2436acbb69b3f5351e36cb8fbe89573bec49f38350d4d161208e6808e5472b25d1fad67e9faa0479e2a4f50f18ca4b55da3f81354616856de9d50e18d57c6860181542db6ea4001d3b3b805de68d0a1fe5eba1384f7102df0cf465e6cc33890c1251b4a8ea85a4c476070ff21384161e4c9809909064fb8544c0c55ac5662c0d7022bbab84ba3b44d09f1bbed27307027c6ad6dba972583b57f5040ccc00161ddcf743bcc66012fed9cc6963c5f509ea50191af9a3410cb8200f05a64df0f69ab901289b9e2a7fc9cd9f6f2d78622890454f4bc41d3eea879acef8d96b4b450141838226a811a2b9c58e2527d081347603a65c40d2ec56f1f56a502750ccb3ccc503a5c69dd07731044ad58255046922042863e95693c0ae1333f9980df3f8d1c0e4a887c4a1a81d542fb44781d0e331a5b53e5b93824ac741951f5362a312783d0124b72b6c600c8d61c478ae6abc4c4aa7dc3de96cdb610131c61bba9948cf9b85bd7473292c5ba4167be8d6bec3d606fd1a4dc4ea961a35807574781cbb679216e14eb3e1f44d52ac27a1606643456f91ab0052402cbba19cfe02554ce1f5b606fdf94d33d72b947d51c3e493b2f8e7c572ac260221a9c9d0933962a9ae0d99bf79debc1767f7135f39833a1dec333d685c6ad3e8c2b0a49eddcbdfe46c3a4aeb5fd847c65b9e68ae089e2101fedade2c0acb62627a75ac6f47c4a13342d2c5d8a4fe6a4e1ff2b92d26b1e2dd9e8b53ec3d578a7ebd1dd7ecc2142d907bdc3974a1a3b66581214c8395dd3ee816fa7197dcc5614cd9c6ff84f09762e73c3a154990041c82d20a2c2b6d8772ef090fdcf9b385de342c886d1e38265d460de327e711804eea3e2550b2b3e6ffc5fe0e3d4280ee965aaceebf94f0e22a4975f7f93eba502d044e36747f8c10473c8428cc0254fef5887edb169b394fad70da29d3326a60fd94174356d2718ce87945aeb97801581ae99f6e32bb45e2fc64bff4e4b0886291bfa300af3cfcbac034d1fd3c71151091b2da3295abcadc5164fc1f416ff3ddeed7814c17dc587063cf45fb7e11b89602ba93d7847658d6e90e637f685d3309feeca71eba282d16a4e03bb6e56c6ab0eefb4b00a8086cbd7abe136032f82dea772069f451d33bd55d39c4ddeec9315c5a408e6a40d4fb7b77cae801bf326feacf4f26c438c253eb6ef289b7b31c923dd1faa8f37b53b37d07eb24fbff822a84d5541ff6359f6b31dc2fde5764102129c249636648dfb4d9a5e00e00fb58e72eae3ec4c0398bc0d6ef79f0768e9ec883466cf23504c2a330bf1acf8288ffacb5023a771f68fe24b5483814d4f8943760d0e1b40a5ac3710194d4353ffd43dad4a8c4ea957edfe260b74d22b781ea95609db1de1f4d41434f5c1ef2c48dee746bf7fc2fd2344d36f493afca6a1c036f16f8619db45376da0cc0db87655048b065f62c085a1de072794b516816ef20914d01718bab1280928cda3a78db7a968115055d7f34941027403de5d5566394ff44abfc581d469e7917650aade905b4cd7ad6a4dec4d4b3dc9895d4f8a5ee0977dc214f216e1b4c663fe2fbd88fb4a5ee86d5a74bf7b805e8781fdb8debc80e24d9d9e9fd2413200f1cd9e04a44ef93ad0433482291b2669a8c9ffd319f9ea87b8f3598e8b00b0674261c5d54bb99eec6d9a559979f38dc947a3ac75cd30a5d35a56ee97f0b8258d0dde684d44cd4de432fda5d8a888e400799a2697fec09928570fdc26705ff485a4d0017e4d43898c77170590aff6d63617109df750dae9e66a44108a121760e5ab2cc0a31b37bfd1c7c0d8765ef1de42c25c6343d4c4318da72ccd52c79cf44f60de7ba5a6b7ae331645ee93fa91eba464bc9a41988db936c951bfdf27b7dc335f5725fc5ec58051aecbdb456e6d1223549081d9f70c4691d0c60478e480efebbbb2c08167cf0ff7f6b9141a593cdf8b5af084915228edc1e7efb9d7563740895bb687f6ca7f3a103305610e16d16dbbf53bc6052c7153abaf2eb768815935fa3fa709acb633c05bae13dd6a8d3079861c59330b2e62e9b843f18ff58e6e805702c38a8345bfc5c04f0823eaf38a92c8b2bb3d026bbf2df273f6793ce60d3b43d0d2c09b7c7f8d2c7d052c7f24de0d6f20bfc091412cceb692a8d7913a48844b0a9b352244a17bec7f738aad649d09db77c5a08935282a4ca7e3e6a2d30527ff920e620e15891ced5a86f9621aeca4873086bb4d0ea8a4472e3b19ba9a4f08eb2f75ca26703bbd58787e443232cc22ee3087243d0409d53d6b8c881af5b101589b33546d45fae85ee9d344023b2cb140322481a2f1d0ca1c619678bb15982cf9da1145aad9edb749ee718eb89efbca1a306957b35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
