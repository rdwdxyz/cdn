<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"820348fe0499775bcd366846e05b390a3f0c6f477d0322dafc0492bc8a0ed77d27c6af8302f5bf5a95fe5b28173b38c200f52a1c0ffaff6a4ba012bb1de46926d60a425fa4402d20856144abd7a2d4cc5805be29db96daea9387e77ac99c3ff19b0d85e260e08ee1001905621f085074d19fb3d2cd4471014791ffa6ddbc63fa32de58553c105b2335631f569431569723981d61e169cffe12569bf08ebb7664297cee7c0883aa59ad83c22a75f5bab608535ee7f15ac4243c153bceeed1aa81496dbef5d9815086f3db587ff3548b437b8bd8a303f890b36b8febd5c8d40f9d99f1a73cbb4107c78378058e62ae4e45361102159881e1b2d7919e36ee66dbd6b6a978df9c9d772e5f138b9b77e11bbadcb4960b9269ef952be540a502e6832f34bb5ee932a4e33f366fecc9edef3bcb12663a7de33d8439f8ebec73e89de93ddd169003c8089d38fc6ee4c360f0d6ad5889a2f03dd34ccaf9aa4cd8bc21fb86066a75032c11887f3f45c4297dcf85c8097c20fc605299e153c4de470302d58e1278302305c9a6368f75e44e0e417cf80ee10749abe59b5e2fead3e53782fa33fa68239b1c5d6605c0783d79d56b1e93011af7827f18e98e91f29a05a3cf3da4751bdcfa52995ac0e4fd9e95a14084f7230c87810d30ae259810ea9d642e3ecb36d7849ada74eb6cea63af90f70624a85fede27a39d963e11ebf6577973929f23a899719525a4d398d7780d14b5b1ce30f7f4a3f8ad330025cdb481339aa78fdc30051de2562e24bffb01d7ffe6e13b7fcd772459777e49937c38f26a5d7c56a6c7f05c4a953fadce560c435312216806d18d705f16459eefcf926ad86d8663375ce46e9dbaa45cb1912b84cf2c1b5f5c05cbb9f47039ab42b7617e194d801878582c8fbd67fba19a31a43e885c94f21ca01d4bc73bea9712a92d1fbc83f7ab4b73fa36e068b40cddcaa63c69824ad650674c25e9c23d81d8b2b7c35fa42d8949efe42c2b94b1011514050dbcca1f12828624546922f2934a6b2d3c9f975272629fbefb62a78591fc5297530415663f9d4c9965c87b5883dd6803326dc426651151e4f7de1f8842ad26d9317692539efdeb7b5a8063cde1bf34deabab7850f75c3956fbf9b8daea7648d6c7f957bf1fa09669ab87ad36cc14ad924f179115a59d799fee27d1acc20680dd9075289322ef20dc67e11c62b315548295124cff51b36e894b1c2832d8a92e34012942709e74d90d0b72c2617b47bb73df92dbc01c55aafb6caf20ec97662b4620c35d59c3ce96ff4a812487a07f3e2108c612d5d7917db1e1e711a49812331ecb3eac0052e9985c0c9f137f0be68e64c712b633b674f85ed7b01b2410b4f875f89a2367e94894aaee5d5252198215e63698d68652af0bc94ca96167786f935125160578abbb89225e64f59b90f2992d5ff601ce32f24b63f49186d26e7c09afc2211ed26c8eaade4df884941a67d00d6d8631abc310126ec43161610270c819b0ca53e0bf32c400aed9f247fb72a0e58c0dd8e7a78b650e5b7df07c02f32d205ede77fad1a3ea9341b1b6dc0ee73fe2e8a72fd26b48003478cf856490f98226a7a2b0bd6c523824806eb612dab4e52bd59c7aa398ce77917759dce005aa105fe2eb565463873c4238d6193e6bc89a972e554087f7608bba751a8674ce26c39cd6e9b0abcf6092e7bd7f29b2b53cadba3ec708db1fce8e94a9ab1afc468fc8ce935091adba69d823f22778c6393fa51b8c9f97cb247b663fcc1c981f3bb4941eeb4bdb91d7af137c282cac72e12f61b4945a43abfffd279bdaa07d78156e72c545a3a33e1928d0b89ba35f29393e75768dd7695060894a58f30162b913d1fb3cff997aab48a88d4be5a24b4bed215da4f19389f186e2942a255762cc971491d0994ac2858a28d9a0a676a7a73525c92c7d768c1fa727a48c549ae0ccd11a2ea31dc6630c24d273de2e92e6179d60c85542d57ca2cb95aa8df8ef811160f242bc00e61dd7650fd047e1067acbc3e828ec66ff674b5cae23443632779924f11c3570912d5b6c8246f10a41876aa4e1f1246986766063b1e6b984466b3162757b0fbf6e7e98c7b63c6ed13243244ab5e1cd2db4df6ba8744df9511f7388fb76a9925c38c679c0f80728a2306a7ff07c6efb4e85ab8ac3c466d270fb1b9bccea888b305695a48ea4fc368991e202267f37b0b1c40bda018089a0c7d267f16240e1b5c8c9c8b1dc6a5d959c5ec0e22ccb8fdad07a1c3c7a867dcf55a6b2ee63b76204609ab65f992a55215ee32bb6405a8079046b5c25a64f840428d2bcd77cfe71584a99c0cd4cec7725a7446cb1929984738f8eb8f7950e9b5331380f1c2bd3510d91fd759b496594ac59ced1ba8a70330961f667468df98d8894697571d70c1fd2a685af29111d7582894492d7be17753dc9cff0023f44025616d66de1efd69d389feaa22c01f65ded3445308e970d7d772442dd53ba35e4c698d269d4e913fd9d5f658df3fc386c51fb60c77e7506c1960f688355a483276ea1ac4549f7cd097d7a2e6880d96a53e3cd79a8529e04c36b2dc2e67b089e9d787564b0feb328e3f71707eba4424469289577319db1fb5c7119e1aa7790950fe0feb8a6e42e78f34ec58ba0e1015139f4ee59b60ddde7cdc2615f0bf6d396d03eecd6ee26400bcb275cd543233fc20cc74fd3a8882f31463547d69e4377ea903925e05ee35be996d516de7e4d2f68454ad728e3eb9bdc47707c231f4db16a03154a6b2de950c25c66b6bf9e7dc4c0f382cbc508b5dfe2f1cc71c72fc7cd267fad49b91c9ee51b4c211216ab6a33ef241807aeb6119ca652955c354674100cacbdb90602ec53a34cb9ee103ba909cdf5792bdca2e96b62192ebf384a959ad1d3cd264d69db3df8aed4f28c6198a9f752b5df31f8ad09b29f66364342b02abab7f657be3a42294c82992d01cb8467fa2d68e30ee53b61ba56826d423b51fa124b171464198eff261e6e492ed393fb815cd700c352f7905b227ae0c529a9d3ec6ee53819d6bbc38003403b747f711e0b351ac19d595940e79119359b4b4c24821a631cbc1d39b182715a5df34127447c81fa79a41f4f144defc5b4771f53ba42610fc7db411e31321c824d398f8ef951f600127d5715afae6898072492650d536354d93fb18c8321a34ed4af89be1648fa625369d384cf4acba5c3896aaf77db650099cd7bf420279a7cef55d4e03e3adc1d4757b2103699474397e7ccb581f5c1eb8a42948d8095d8d0f8db46a687f7ab2bd5cc3603b2ce856ad880787cf72930e5d05b684006101a8a18e4e8e7988dacaae30ae2151e95cf19a2fef99a5fa92716a545beafe281a8e5019aec7f7ee1b2d6cafc0847ff1c621c018030a948d19ee50afe1532109ac2cd4aac8c83d06cc148adf03a2f787278cb679159c069374a967065b8afe4fb08e25509e9884f0b72cee977561f287abc349ecb7139b0aeacf95066f3888124008aaba70bedc0303851f660d6825bfb7eaac23d09b32ba4916076be5c2903ec5d7cb145af6bed8b9428c01beafad3f611ec010414ffbfea849d0b5d37258ee241f99a2d3e7bdb630bf9492de1e48c90d52dfa30a5e45415d840a6782bc80f404a4b6ee15cc1f613b70ef7f273870db211976cb04401c30624aa7709e843e59253c0e4fbae53eca854abd303cf3aa43e4e5b87ea39127b78175a35719851a200aa526496219d578d9acaa4d7af140ec751ceaeba974d6950db4517674ff834bf125ee3eb463efea7cc36e948c582fd47107cfd35ec73a5effa959ed06b03ea0cfdde105e4ca65ac88ffbf80b95360d3c29d37582613ca1ff34b8b21d0bd516037a33a16518fd81962166b121b30a6ccc9c31a58f144c40fd4359e276c03c8f83bd6ef891b562165462c60d9099eee3d28229a659007b9410199a317bbfc4ccf6c79da4cd524688eac8acff584e994176d832f39b61ee5013c1d1285a1aec2b0f52edc6bce783e22eb0bf58761a7aa4095733b6cc5536f17fcbc40f1aad885fd1e3ec76f160b7de023b36214fff04881439bceab9fb0e6a7190d21e5b6c17a7c398d4023670d68f2f8176065928534678c297710d035dac6feb8ea2e5f417619009084ebbb1bf8687eaede576f850a4255a3ef55cb9695cc48e15e26c5fdfa4ea3becb91fa61dbc6168e5330a593abc7476577af848cc10c45db66e9241a3394c66bbbebc2ec35a30a98b65bbb31392e7f63f6f3755379ae59b40368911376c02c301055ba5d88c93b41f8b02ca58c37535abd6b84a72b8f969ddb5f380f491d9b1a4ba8ac7e9a4f13c36fab17270f811aa421e0140f54f9594623b950e4a56ca767c01d3d073d9550945eb02bb4f1cab4343cadfe3b4c5d6a2e5139e45fdaa3cfc956b04107de2424e53caeeb7c57841b7732b0804003405cfbbc2db63672c6ac2d64f56094c20764a759eae78780f89d0c0301348818a130cd7c676ec75f1194a565008ae36b55bf7a4722e7e09cab46875c61efe5ed7a900d3edd085e8ebfeeef71b47cab4890ad6fae787444988ecda94074ede7db7397adf193cd433d8b5e9cc6be909b9cac541a5fdb8c786b0e3199b1bf71b77f4c0931616853ced8d69af6a5f1de8dbc6ab0207cf24b9425ec958fdecefc365f431df4bab0d786ff2aa2afec2641e49b9b7e81854ceb2952acfad62645852fcdedb9b7c5efbf4c524511dbcc8132879a4089653b9a9495d320d3282d4b6a4339560105c757ef720c65a33144195cfe3bb9016fb9599b6afea03e515c5c3bcbe47a6022fe0326635b4ca668f699113079c62c1c9dba302657d9f1b97a2e21045a331732e2ad45bc79243e920504e310bd6539872a094ec3def83a2b6050d386443155ce8d16f445095b4f141d0af4abe1eea67cf5705486e7047f5297129be2b3a9ff9fe506567f842cf10ac7ec58c2421729f3962f6df609a2e30748d106549913b682bd4f9ac466fcfc4065fc18e14042a5a63e969e831e6093a226beb31c02b1bcc9424a3da7410c54ed13fb8bd5f643378315abae732f90ee274956fad1523d422de41727a2bae12bb8b0b94d4d826a921a3a7320419d47a59f5655f4a7d07a7bb941821a425022a1cd0b14e9b303998c370245e680e257917bca3ef4a6ca8f20c49120f3bb7fc7ec5a68144d7caa0a33135381597c58e609a0954574841bf54bc3a70b865a38cf77003bb01cc835b4d6b266e8a390302d2f82fe8615b9b03108d4175cb7db9608a8974555c6f7c0b614aaf9ba62fba71e5aada4c50b3c1a9c8a6db660181425571d491dbd05d89701323c304eb54de7e43b28695bde7dc51fc74b74480481df0bb350d031b429e8e4f71d5ea3003f3ce61929dbad08ad451a52e85aec8cde00f4d38d31cc4556831359379425656eacc6fe692a667c59071cc8542504d8676374efaa43c02b86bc06e6c1eb504e816219ad439d63dc221fde1d0831c45ea5b7f6d36b0027ab3ea80b5a02c3e9a6dbf1ad57d5f8415ca9e2d30ad9242b458c34bdd2f7dc7f8440569a2463390c27205e81732f050c89b9159275a18b5e4c811308670601b2cb578e0dafc2126267c9d7d64868bce7f59fef4ad31d7f402df919901e2a0a5f198f9b70b05a84c8f54ff701e980e88061bea14c798401ccf806efb6e9dcfa00991d4b87a551a00a375fc6ec63065c9b9cd76c35e4e09be3f1844422d09ea268f9fe5b7b1be2f02a88afa6772454712ce861515542d86ac9f1c350936ceb7ff20cbe58b561044f43d609813246751fd9f2526ec84fe5f47fb1c7d4f75876f7ae5a4e3981ddc39bacd4f1a266f522b99716b99d1f339d0ab184206d88a8478d35fb21585823d461843255c29aff337bd18d7e115e437dbe267a26ef69c6ca5082b0f7c2e124a7d47c88d06886ebce0d5a0a1c5672e84ea0d9368805aeb2f741a5f28e113e3e95a072d5b4f0664608c9eb7f8b821e3763b5dd5da61dfacf89d1b9090b922f0f0cb4082cbdf8ff939bff804d3c7078a162d65b84b2d145526d68e250c88642d05d0315b10286c0dc13ff8e8f86aefcbd43a695d95661e0189bb2d8b90749c60600beeab2873b00ca1bd3a31961f229fcb12ac595d92f8fdcfaed6f9f89b9d22da10003d21bf175dd125b4bfac06f1e2967fe87474720e26ce7e4d997a7bbbbae4e308981626a004a3e18188159f228405b66a712a5affc32f23b46a56990048a0992836c3adf7c3b34d285f10963f2b88810955cd3579ff6a5f24c7f8aab23b309a67fe3a37ce75296ea238a9d874d336c8001d1837e9c7d1ee78b640e9b392287f3b7ea71fb66101242a0f20fa5ed4482c561e31cc41acc7c2b0edf0f01222bea04ce2918ec90f6949b31879d55f745f9d1befd22f5e4681f79d196a63b7b55dfddc181b48f173ffbaf124c94a2321710cb5fb2f84471559ee2c9c6045c3fd7d1231f93de66e08dfca2ac24c4567c8ae2d1e357ee0fe46da9af838190d2b93cc863360c73e2ada7ac2af2de5879db04660734c7fcdd7d39c4055b3dc160d56437ecca9495f9b2e074e57d8dccadee50bb6e23cf2a4204aa1a82e342ab1613ff20d2a42f9fb525c70224d26496d8653637352561bca7b7ac532705527d1436f2a5fb507313685fb5465d771a9bd5caccd1c476054a4bdfaf1e2b1f46abcf6fa8e91eb7ecec2c0f46a42ea08d8b54c4583b5ca93717ede0c8124e08e1de48bf65a1ed80f6b147822b72de434733c1f91f9840257d0711d8436e1a4e2f6ae7b8c3649f1573090eb315dcf940cd8557f0b74b2c1feff13c53f186bc28b4d6ea723f16d15535eac24ec11050065c8eae4fd26ce8c059f661cde022313da150a1d72ffb9860e2ed71870707f1ebc89e834a9ebf38745a5a79e98c9c0aab154b8a3c7fcfea6dbb803a8a01723426b9fc5bc0c09143115551963da40d6d812e4e3e1046b25be19554562241fcc4f541440e293f8935d3404ec2a57df87f869a2ea50747154dae5657b660c43692136964dac5041f18f647ca25cf96f71f6fb10dc29328046fa93936a4150e6304a60520da54e6b28e0326341b365785818def37e8938f4821022307cf4e534fb4a7452228797cba32e465986f5c0b3c08c580f9e649871d3d4e0269fe59cd1ce65740041f792ac229990cdbaa12be7abd005d9737a7bc38ab27cbd9d83abb7dcb00de8abfce37afca7ae7c893b6180cab6929f45ee0d9d0cc9add845123aa5fcdcbd2bcac108e2f4e5e70dd1a09eb4dc7d9d229ad22619690ef478357c44edbb625ea0731f9c9e37f948dc45dd1271ce97ec5c04387be11aafd2a0c14e8d38f86a3e04e46c75b7895370efb09055fd18f6f040ccc0014dbba9d8552b2b38b6b87968b500cea92e0eaa0115132437e70c599ce397b514e5a2e1752b7101d07cd5c6d45d8d7b3741f92fcace8c15d88d0c675caf273ec367bd524a5f98bc2521b57028604876de4a059dd6c02a96242f41953e467bd4225eba496308787ee6b009b850c4410c6db9cd3e4eda79b996d5a30b9fdeb87b2c0765637025677f25265d58a7acc13f49e2ee3c5c078bb5fdef4e5ab91d28f9d1c657a750148dbfde76162506537bbcd9813f80c7136a1d536586fb1386a7a655b656eb6cd3c9827d424c50695700e7f76e34a34f7eb04a587439ddd90673113922eb8f17fa349cdb46131ec70699b6267e1b351ef36395d2afff01bd214dea3e036f41be7d9210418fcb900376094a383a706b7674db808cb14f024a47dc1e70c0ce2f086f37f2817c84c4ba283e88518e01ab9e124bd6d186d836b2a4e40c64bfb0330377f00d96e8440934fcf1fe289f800a3996a664a197c56ed16e9b0136efb0d3a409e6a3c711d086c1b1e57cbf36e0170502d18886fa1f58c4ac8decc2f96055315efe383090cd316fba1100e02ecf0c29d7d765e49e97979154933600e3a41ba59a2e8adbd724efeb563cd6eb37949a720da7ee57668d474db988931623d040e67c7e54be922c91c798c3fdcc571b33fec2516ccff2c22e11040bd1149c14198d98bf48f3544ee46b4754b68af4e358eb327d524631c80453dff14a278d46ec67d58c53738a5e5b845341955302f9aeba07c792b57cb304cc0b194e1c68f82169c43c62ecdd86ce58a69e831e991741fc024cff45e2f1047236d85fc8db5ddd7cfe5a37c537ce94ec62d96d687537be3386d8843ac78225e012bb2b3b564d3b733acb89e351863b2389343a6ae8149c7c40a9271f76c0c980974b5ac55f40582a92647e6a1fe1f65f7f2f450010d52b528d42f275bb2d72727b63a3ebcf09910623ed8c3c677c0de7f2838e7ce20308a4352849465762f10d1257ebd33bda10a5c437044b090c933f204b850f6ed08f723f54ce09198c5eaaf8e62469aabfef29112611064657ddc923f7cf99896459257b94de3b411238420dc4c3ec4df600c5314513f5b268a070bc0fce35a23b1a68ac77c023f345b4a6ce2e9c28974f6b6bedf6bf1e6d3da4fe6ba7df84beee27dc0288fedd23aeaf91d41afe9cb086bc3a428c8e10376bf01f65e832a65a0c8d686f1fd745ed5644665c01964936cce2073758fb6750e98e9c111d2fb339ce87be56ffb54ea1234d5453ab08c56c75a1aa4df3a40c0b9ce645cfc0213dcfddf40f17c517f069bc464d81b9e3cd0e1301c32d4f879dcc3fdd9bb920e3e7e379b131315536fda48a5fe9a533d8976311dccab424ae232fb3d1c51148e5bceb6ad799e694a91523fd24c1e7d6e3371efe63d93f4f142336036ddab36033c55bd9333d7642c90563c318426bd328cc0d855510d8d777c07725232a5f1caba6da5cc36d137c0ddb856511f65b6ae41c3007ecdb6051068dfbbb95dda8f0cb91c3f96c046bb2bcc505a7a36bf0890e5e901cd4ecd2084d779682e46d1ea60b32a2b9bfff6b6a23d1d5a13a7e997d877fa42e81433d372a99970ca4dd5f9561344492db3d2a5ad47cd695f267f2798d7c2360b3bcba74129934de0ef5f64f53f2fe3eca5a13239eba6ba657ec0be60057418b7a9b039c9c147c267feb0143b287967b9d090fd538b07b178d460a13ef4587f1877b5f6bda5598f4bd0fed8785768825bf8f7e94c8797d0c9c6020c90179f11863101c72504f43f413967438f9b746f03bf43484f812dcd842575fc3007cf126b54e2ca169ff42580f1188c9559f9162e260a5d3273e60df806317da3ca16101ea3814609dcd68fb1d31dc32d189baec892770613f5618baeaa3c05c9aaf855186e89be6e7ee1800a931b7dbc41a9a3db168b118970e703cbfb0a68c35fb7495b173b733181d873cc52e691bace73f794f99d17e429ec02de61f2e4052c00a95a02f8293a37851d589930d35be5dc72661b8f1071c08e613eef9228afbc749748c7f93b5b934122ead02311afe6f6795db8209ff2d084e0c9be22e2e27bafb48399c19b05cbba6734eb8af956be50f2b11bafe253fecc8198e317ca44ed5255b2ea2f39d47451c9c12865a2ade95f4b8cdd54de7ca87f562b135fa596e9e790c192b262b009a8c76643965b943245dcfa462410a294e99bb7ec9521505b3b53a076480fd2e6e49f886e7ee56a4d7f1608b7f637bc6f4fd4d3e839ea2399a16c94f32fa8400ac83275b84fc8811240da7cd5bd2c6550fb94852d6e4e54167db28a9d219762b32ffa0a558cbfeb21e533ad459a04ea7dc94cded18a8686db40e4652b95f18b538d5e5104e2360c8607b4a4b96cbc5327b294a1060738a851d68f4c07ede4d52239d12d4e49eed20b43eacfc397fc6d8b1396770b8d3c23248524f0760cb0108ea70ced916eff6e2ecc26e278678051900696e3d5d0ddd79ce078958c09b21d5473c41e00bc4bd64d698db7dad40ed5f56c9203580eda9783fc031d32aead372c061bf18c31e6086fdda9b9217ca087b722e6a0c6bb010a7e6212cd32021d3aa5c621176b53325abe2a7020f5ed09918d71eac7b9af510676b9d9a8ed6fd9ef465d8094780b27097f862499951bcac49fef8f8b15e192970004ef834877f23b67db455d552d5906ef30a1e5585ff3c89100d32cb74f3914c1278cee97cc3cd6632af197a061fdb368f41527d1cb97457ccb25e9acad4c811bdc3911bf6c7a360c368d15284a866c35ef4e0d12d822b3bfdc191660b1f008011fc5baf3f7b40e8244f2fe25c65718faeb34840be40f6d41a3d81d1309e64852cbda6cd9d7f5d3d4b9816d5742fca043fb97c5b65cc13bf68cad85237b766aba546671051371e43774c2bb85bdf4038dd38c8f0b22a6ce2c9bd49115a6250f013e7a934248137c46411d84c14c9f14d2f39962dbdf64cbd904e0be97b4367a2bc51eb4a6efdb4b7e13f2ed848f87f279d6c286f416b78a38712a83b1811310e818959188db01cca7ddcf482457e32e897d0dd25089df68c79175250d58bd6489a9c6c9c4b4e062dc41fee14dcd1835bab65367cfcd26331e43ec13f7fe275cbb8db9a4a9887ae4ad839430a6934f7cb463e22e2ca37c7551b72559b9a9c100cde1a23961129962003ba3cea1f16f858ccd2941f783b01633a251df3bd398dfe9d3d450aa8419709158248002550e4ce657946f0f7568edc0086b026141884f6a08ffa23fc86a592807b3d77585740032c8b4dfc254767c267d313d7ab04d039eee02206bd627d8dd36becffb300c058cdea6bb5e4e63a2ee8453fa1a9af2bc6f31d35ff80168f6bf36693ef27ddeebbfd6f87686b5bc68ac6ca54574e0af705cb17a89a430e755a8b1de31f91efd56a61e3066b7ad8f118fb6675784b7243ffac809dc32f209459ffcec80ca3655b2b12cfb03309e6a5148e7809615fcaeff9ad888b76e1aae020a5c59ecbbf140984c801e9b30662a2db853c12ad49f0fb58d1387a1756506a5de7804b65e7580e6efd007716732a838608e491161e588c59fd873cb0c5b867efaf979a87ec3b474390dd10478b341ce55349089b478391e740e1b42899eb4371872444bf05f62377b9253330282cf5f74013303c834226a4e02dfb7be82c47f0ced62feeecebb2095b59682e98ead0d720bd1d10be7812623420bfc62bd35b57cd7abf2783884c3d20c0e6c368b959fa130b8a9d02d8206a36d8a598efa28f6a4d1616f46180d4942902de9ac165860941530f9fbf8bc833efdc530d251867be120155d1c2bcc9f952625ac85e83528993da4f4f7eefad0654adb4a2450bd1a887088948b0e17a968985f327f61aa3bdc394bc897c4d3790f5d6b0fc0a01a696a3ec59f309ad8502df99bce42d80a01dda42653cd5785ebbc3b277ab3857a1e8e828bcd760ef42027eedd75958e6f9c47b0cb052dd2a5276326ccadaa76a32516fe66789f9001875e627432f42c493813e44f4e5f556004b643e2f3c2b4e91bc97204c5c7a8f9b68fae980ce8f937cc62bee105f2074c146f25ef04fd266f8bb1b70874b9e070db55f6d79c0cf7e8c67cbbd354b5fe37ff324f5cd00c3937eb74daf436a255140463fa8b9d28d8f00e13815559db02cee221c3af900f2f7e4f262d6ad0869a3cfc82b212586012b485e37981bacea8f4dec7a45ea4803fcd494a350bac61bca3cf1f7baa9cebe4658dda6624dcd11eda2ff45b2af60332fa22d398e2201eea1719611d2c622862a4e9adfb1e1af3728154196a669b125048e462954f90958a4abe7e02ca3642223ff024d6aa1faf865f06cb3c0d75a474e4aa1b17aa6960540722cd9c8092b6ef944fd7d2c357f7f5debe233e76b026449342b5cb109821fdaf556043fbeb5245010876b15f06c89037949054b02ff3264e7bb322f92d4dbbaa1ec36d9be6ad5d566c08b212854b826c5ec5365de1f46ac4b2af8947a7f39e04e585f1a273fab39fa147cfdb0f5e638d20b22373ed3eaf65553e0db46e5844bb99f35bb964b7db2c84eaf06e7254b34fba10c6cf9ab477fe63c3752c98937ce7291eab3a230c007d3b9c0687c20efc3b6a269b2e31e81e892c6b0d284197f918b44c7d4dbfd3ebce96fde7b275c13f9859ce0913293dd0c8e53ba3e4e7d5107b7bde4510a6a3ac77ceb31068eea6651d463a54fef539d87cf503482e0c9e25b9d0b4cc601d1ef0ed33651e0af37cf05aa8ad7da9482fc4566f9d269e75cb083343864763e97cd9bfdcb001c520e9b1c606dc4e477fea1b821d140f1016856065fa1f6b24c7895e97ec04c3abbf57119e9a7e94389b40c0dff99525e205cd23e896e7b560e1e88d368deab8442a734359ccc9fdda16db09f80d0e5f9b406bcd42592d035d2fe2e77eb3fea36bcc92d804f1e82e8756a4f50314051ba7033020662ad631d0abd0bcfa693980fd0c066b7f49d0144542ad8481b887e1b6540e1affbce1dccc9cdee15b3ce66967f2d789477abb7a55b316d2ddefb5a60bef76d3d74a1985c7f320bd3ef0eb25616b3b955a4eaa0f586fa3e9f8286d1216440458d309e3c98a6c8902f841b9edac831e52a8b9e735fbbcb0c24b14a4198ff97a9cafcf98d554884dd11de8c8e9218c1fc4f2f98217ac6b3a77c36279a27af1d7445ffc19c54b39f321025616234756f792f6aa18c92b77bca2a839de2d8ec43fb2760fc03fcde1c2cbbef3795e9e9e9bb447d848cf6de5a6f4fa033bff1c3af8d653b3b140cdaaa3dcce37cb05906c294d8e6472d518df195533345bdfab8e06653d01cad3c4ff6b83f9e6efe1fe504f6ee1ee81adada5a13d4274272d8a48a08a66eaec5d997b29fde28ecf37b93359c883f04c0966c9d3a5eb811e97528943825cc3480b8a03ea80ae35de015e9b25621e6c19bc4350d94fcf5d12f47f8b5bcf846872d8be4f6e310c57dcb75777cbe453430a066ec689e4aceaf3890aae9309c8f48a04c0d3b023fc88a7d08fb98916ac8ce711d3ac42a7775e7f9106cbe1419f944ebf6ae3fa62909085bb3e33c394cf5b7e28c11a6a3099fea87576fb876dda280471d477dfc7c454a83f71784d808a07d9e668bae0f80d14017821df3de202bb49dddad34ccf0873eb43bffde1e577e96152a258c4e2a5319ee48b8dc6b641411b54192cab197e9ff4f9a579df9cda16b69797894f79008282b0482c5f2de61d4e27a17200967063726f59a799e378410604a947eb06d03693a2b8ce5564b0ee5e5802566de6127771ac16c8bb2ad2f3494d4d7e6a953766475dd5efb03bc36ab1e11e5ba791cf7f6894b320b0857d65028de918a4d35a889c6e102ff8aead1e49b9e41b2d766d2ebb0e814a13ea346bfc32063bcee91afa4cb25625fc9320eba306234c383bd44038daafa15b229f0be634e29658b83e80f503fe492076acea3872f5345e3e99b31f1675cf32a6fde6c4dc1a9090dee575c830a92d0d5447880fc7008d012fa447a77d9b1ae5bacf9bfff8206f80b5cbd2dffdafcd2449c88563cec2ad27f872c5ab588bb1c2c5b2c93a6c94218a81adc07ac36b7d9f0a5bc2017663ca1bce65a8cf6c72d1dad605f050cb9561e1f7c04916bd141729c0abacd3c7cd89c3f4cf97c78beaed8211235627a06b548bb2496be5b9388b37d9227ad0040b0a7d7acf2fdb172f34a4334da4e8ca26efe306d6001e245dbe4aeec83645a82331e170ee6fc4f6dc6868de7d6c763969362c2524795d61274a0e1dd105bb2ece3941f3f4169937f00af13f0e25269724a6479e5b4c8234c7a254cae6adad00222dd93a7477643e10ac11150c4072dc2452dea2a427d02a72ffa7878d007de054e56f2f41ed16c0da13069f840263a3d85e4f5d021e0950139da5bea1c8a0205cf4d59a1b5da24e6379e0a2973290722b4a6852de0b16a6abca23d055ff9b71c4a720ae0ea837647573dc76ccf6d074d3d7ff942a182e0ae570d673791e86afdea39de19d857e3253449cab680ed84fe6119638f6504139586c6b8aa922b153075f6d4d415c3094f74c685f413be0669bb26fb83766a352c10c12b8f55ff64fa97f16869995c02aefa5433f078056366d54aa555a1e8a81c1add6a4a12818f0949e844240e0afd0f4bcae43088005d57f6fa65fee2750ab314c6dcadd0e1fbc2fba325e62e1c5d9252794f10bdf4806f0133079f2fde0f9bbd1a1c2913c7d47196aa84b91be5b272b3bdf712c5ceb17fdd184b7e68bb9ee6816cf2d698816c4a671971a3148518a5052bf1a20901ee79f90ae89d6cfcf584b2fd72bf3a3bdfd569503d2030ecf9289e0eac8b3f791555368f2ddbfcd992bfd7d82d4f9b0d7a1026bc2941892db662d01ada06b59cb7e7b521fc8a87cf5b4e5fac24160dca230a729482875d40c7f4455271e1853d2f1d0174ee78d564443b676b6c65fb20a65701c7a0513f8d9135656e8ae70da68a50fb1eadddab1a4a3bd9d53183acd8788506c791c790a1d80f21ddd122d61fb7f51578410ae96247ecf2b93cabedb8c4f49551c516c28542713b83b9564e618bb0354bd4e8425f589f1afade4fd0875c4255a2cbfe38b42dba75b95ddb76b03589c1501b85ff0bffd771035a63f9131774597d9fca647f1b1174bbd25ab47d76b02b24fa762bcc0b64327f7580a9f18b0e9a78bb7a7ce4abb8295b9b0c3883a8544aad3162e361187d02b0730170ea0200d31ad038e008e555eece731a2278a3237e0f0d359d5670f200431eb7f3f58a1263f7f3d213a09bc1e3d208d26fe5e565af63c2cd31ea94f1300636bf7adb8d41b1ccdf23b7cb3d414fb31c6a5911ef8f440e38f00bdf291351c9fafbd14bebb2350a4264635860919dd751b21f474c5c37f6fca2ef383c0a1a49b0c583c2705f3dca4624924fcc57328f1e9627a18c4094348200558fdac4b2910027d42864d68a4925559ae8e25848c5e3cf93a85f1ef3065a5e57f07c71520d7969009d58771d79f7daa6f8b9d7c971afcb17776662c2937a04c60cd63882cb8533470256a223f5130d9270e0dd814ba608e30cc84d5524c255c75a77879e886a9f00d28906d81b131214a2e037085c9afc8eb8b8d3f170fa3400352f78479fe0ade7f2ee5fd0fb451516edbe994c9e37d39fcae18a319621c8d2182549d53d58dcbbd5c9bd2b9720caee256512f8379418d7490073e32ed0d2b1fa046bc5b6a19f3e5fc65b1863e092d1661d4c136c89ee028163372e902cdcb6a8376a6cb2d12484ea34607074a707d46cd07f8f9740c74669dab02d0aa60a1ceb299043eef4934177083597296f66bf77611bb1a6973ce1ac0dd769720af28c47fc1f251991de9208861504bf4f0e9bbf744a4af9d13bbc0f6612a432d5aed07c69a2baa7d48e76f4e6661bfb2f793afb569578bf32a914b9d96c7716a86f7855a8589e492c7695bbe41d383a6c451639e874a14de604ecfc310ba7e197cf46105362b013a949be1b2e1cacc03a6ae5bf6c953c95b9361a377a234385c72143aa46abcaaf082a08d0f24bb2db5ecd95a8052e88ce3c6bef39a319f64cfb06bf0a02529e5eeb79bb90c7bfd934b998e960821d2724e0e7aabf517b7412802bb4c1cf0af5b5119ed42fb6550b98009beb36d27f3b52e708c157d9f807a69164147a6853800296928e36b6691f9d9c388da12b22dfc45479f1cf4652601829cc8acaf5b25fee51234f04ef6ff208eed75d030f2159194052cd325a4b05b286bc001d54e27063c0e248f4e7609f11099bee20c8608ecf9212d169becff8d3069a5feb78615c843b2de826ec85ccca08a2b826a555cf6e5b29b225ad359e98799f1fb886903818aa0cd4534c7172f06de466236a9f3f76cf0d1ba6fbc47d0fe238e1d16f6d5a624479d9e1d0241fa3530d87383ca0fc80773b4e8d24450b99affdf319c4d3873931827a41b28398bea95227c4b6f0a4f758681e230c1252f8719586c75d28d432b73203d998eae3b2804bc25519f33e6da84d2477330ab4b4b55b63b855ac6f2bcf2288875772063d6eb0ecf154d34b921ecaf4ecc51b9d26da2090e4c7b3e5a648b7dd1f239c5a855aa271d727bdba17664d025edc20a5511014f77dfa4b04f6d80aab3d5da284ada7177969d246fedcab9f4b8e41c0eed5eca545d39d34bfeff543d88a8394028ef556bab62ee363cdf28817fbbcc01a6d51f9a223a044dd678b38bac0c27db79b88728da781b670e3ab67a7467847dda2200d6c54d510c7dedf52c1535617f848113362846667ee6fe3b7820768a41ae77c98077f123a5e07ff5c3682108c9c473fcd4dd89a6e2e7b1267fe771c067a5a72fc62d46c844ffdb71546c824de7a9561c4d0b9b21332e14ac6eda1eeb0a2779143bd61c6a6b0d48dcc26de957fa1ab6dd5c259255ca25171e47b6653bed8f3512d6fdb3d94a4af64ed87b4c0bde320ae00dd729654be3923c8182c42a0a741866e54ea7e48b5b848560d21f3a535d85ad1e49dd9aefd496209e4d0c65a9a11cfebae6a8390ba73ac0761e49b3d8584c6e11a1fdb0134b32d8fe44f54dda173b8a72c8ee652589f3408f464d7fc28e31d6b91f10192e7a348c4696ba5ff126a38eaa8209ceed6030218420b57dabec5480926950fbc3ffb45dd1adb54aa877ef79fcab4732c7885272762eebd219afb65b25da61e3d775c6977c787c7aa8baaf15b37550ff07ed6b7e996895451384da03e2d12b67ee6cfa9006033479164183608599faf2e2810157658bfc75162254dd1a5f8ad2441a1c8e3b39f41dadcef59102ac9106e46b3bb54f749fb07a9c43b7f1d513e451d16b08f5105958b5000eedbfc105591cd06435669d500a66c5368c7165ab54b54bab6e82f624b3fb7ca20986d2d6fe86880956db73778fe097f0554bd4417765a9c6ddb95f4a7a46a3644bf4ff2a399ac73595d8112b3a637b52ec0b462f19f998843598d08d280387487212ea2e97463c81299dcb7bba2b952d57c46e41217690f951895bbb656da4968b9dbc4cf57b84eacefeedf5c7a02e1f183a8f00e89158b9c9dc22543c719f8712a4d9ae55ad62ab98dd82133c7a899b7ce4137364c687af5796d9ab6d03403876c499af86f13ff3d29e0ddf2a68dbe246c128ac00849f5ac1371a07e8c73217b44c7ad023e4bfee7f4853ab388a52f2c921f4addb1b14ba828449cad5d1105c781bebe31ac842de82605ac88933b7ac1451084c7283b12a07f1cde281b2d8d4415fd7fb932e1eee302d81c2b8ed32817b724e9cf125bb63106b4270f41f52481cf430ee75ed8525abbc41b209114a801d1c64369d0e359ec7d7d84295187917a224e6250ec4ea0c9077ef42665fac51ac5c64f6132ca4be62caf8ac5018249a04144e7b59255374af775eae9dcdc96768c7b935f77c565a175828fca6ae5cf29c9780594f9d84c61ba4337962e2a20386244ac1f0bf1940fb9b119b198a2394827c582e41c5ef3ad79744a545ba6f1314c566edaf6bf93fb52047451a1af31e80f2c3d5bb7218507c22457cfc4919c2b3efc471516357a22bece663c072f9786563a00e2372c887d80b83dab966f8215c209ff2d950e0862af9f364a03cfb1f4b5fb08dc2d7029afaad899ec963d139349f3f290bfc7b655c95f831ac383a0fe84ad2ee17c5087240b0523b3f1502ec46fbda84e420ce6b58f00ad3f4d8ac2bdf0b85d98a8695ba0241fd2c00ad4f5639c8de05d4edf542292596a7c036cf3ba2741f91e502e30ec9b10385ad6d4592a4d6bf4e8a32b034077d5f3ac816bb6a75602eab27b8087cb378deabb4d1b42ee3a7c61bb70cce938ee51f770f6f21c3e674e7fa30a8908366bcb9e8ab09cdbc6b9d8bac4d48606e17795158d556932c6a23234da254f4bdde5065b19d843599729aead6d81a56c58eaa102f2ba852541365321c4c4c01d2f6911f13cb2be7b8c01962f620b2aeb4d68dcd30b276e603676889de132a0e0cac5309274c7bdd13b9405fcb44adcb35a7f51f1fa08e607c4d0676df7a788938052a611a0448e71196952d37600da1ec9375429f86867d7d54cc3558fd32ca9b2bb89ee5ea6eb9eb44ea6c8e672c34420da08363fc031f34cd7abc277015eb4691e6675dcda6f318681786129b8a85a0a0e921fb7234eee56e5c9410cd430ac30c02cbd1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
