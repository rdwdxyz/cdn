<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a657e95ea8bc82422038421a60a96cba61b43179611d727b0b79cd82d52c95c14f60edc5e4fc79665fc34e621adb63f04861289c06777e219d6300a754cb0e743b5390a3dfb7647d308697a1f8ff63cbccadd47c0448808e0138d9860ad1bd3718f13f5b76c11b66d4e7655712e63c7787d8939e07e9f20692a3e5dc3ec87e25d22ba58d34e06b6eed8cce40e7a27eaa10cd1ddba8cfecd7fb1b955ee0d13736769d526467beddce9a894c690eb812851cbda855ebd1700a9349124644e72f49c6c566d57ebc5de66f09bc027177298b4a2a9c4118e1953fee2179b2055c1e8bec866494d68abf9f02b2aeedbcb08348041c5c0a248240ad6d6786ef6c4e6800506019f0309efa98709c1626cf2519b8aba9dd245ba342a5e249e2db2b3fa3a66cda573a6e91634553abdd5901a26b0a701bfd8827801894007b8bcd47c98944b043a9c8f1d0569e33c7624acfa6a07cd880ebce9d2450a68fbda5fe625abf8b64464dbfd07d0ea3171d0deb79741c977e124c291dc7b2d251f8c7dee77a825cf21ffd2b55cfa1c314dbbffe45d554d476906a9bafb709dfce02bb62daae37ab035035256e6b1fd6566e3521e715e7e092412636ab29eec37b3a23ac1a0ce7ed42fffc668d65cc264c9ad64c41f4f7d8e8e6ced790ddd37e7e722a6ab40a98d68b84c3bff7b9e45e8f6cb8f9278285a0e83cf80fbe191bf632265f674bb3f608c9cfba590a8576a39d5a89281dd706e2ad7f156f1c41a44c0d441c9e7976d33288df4f6c754a5e1a2fa885117258eae51634a7b6946b28fb094156854085de1b2736acfa53c14385c6ceb126e52bd3c9be1e05bec0c0991d16c0b81f8f93de80a0dd695a43d5f44ce806cd6a44f50d1dbc2c558f89e5950d5bbf12812f76c2740df85a5a2fda9b1b994ee98a33c9f63db2fb210fbfb229d84eb218cb7205557789c25d1601c4846c2a159ff35d9414b9949f922f20679d82d15f1946855edf0a0c64c787666e7ae64312c74ac83e37edff998de5bb0fc1e38f693ef52c90250d204d8a1c85c688254e7aa3e56ee2702c500c5240737927af86a02a235088b268377563742bcdb441407bdd2b43ee9200c1d34275858af8733d3058335204558289bb78779407ee968eeb75c85759feb9d5e3ec672c8ae6a041e434e625fbdedd7afba407bc11a2a01f1d038ca37eaa2f84e5decf17c6e4e8944a3345d0479157881bffe9a4038bc7e54ebe59ff2f09006533d41decee6f5e7103599e1e5429d1c6fe9a9f68a28ea77490cb4d9c277e7c440deb6cac81dd7606437b2bb7ae0c76002fa4746cb487a6e9194146df72e6fde910b69d23552a4831bd4d4aa76805f30272713ef8a22b06953b029da98c431880c64ded12b3320bf225afc7477339bfc59a1a6a7ba4106ab7f998163fe133848885a17c4850499ca2fa996033da0133931c8707b8653afed04dd39bfa3f6c09463e0453d960951d77cc5157f2feabe4983f7257046a6a79c33ccce2feecede9affb47b636589d39e3f164bd4f07cf6a210fc1cc076789bd58de860f7c2f203e579c3ed3b0ecfce7662595fcf583cb217ad85cc0c273c4a08840a1a151d38aeebe8229133f9e4a3a73793e157d768d009a7bfb63db70673cd3088388309f94c613ef9621f4b7664491f1622104e78a5fe6240ddf3b00ac54a25c1848c6c02634cdca71665cee919a38772ce8220c3e557e62eea2736b1482609075328d9eeecdfeacaf899cfdad13d40ba2640a879af4b968c1b58d022e36c78c668c119ed71351206e13889c5c34e7052c9cb145ffd75d0b7dfa72da3c8ba265ef51b5dbcca9014a3812fb69d5a09eb6497a76eac1104b95559eb30258363ff39abc6e094913ba4d76468932b3e017df371bd3b26ec38d152da30a68b0d55e5ccf0c95384ec7f4806fe4cff5bf234ce9f2e7ed916fe95ac6543a0824c9be86250430c92ce6944195e8e835a288d44fa24afa2b428f1036aa257075b14beaecd5bc3d140ae32b5cbe1bb0c1aa12ee3d643089a31cdbb2d884c1c732e878d742bb248e7a26437ad1257367a40080a587e8d1b25d6202248335225af24aa68703ce48b0932bd69f75dc91e526445e107d21f2d8789eeadc8bcfea08843cd4e1b5000b48970859c6a89f2e8e72e3a15586c6fc8439446349e5afb2755714a5b352f2cb179e97d7cce962f86be81a7917f86d7d659be624ddff3c7b998e678e4ece1f640d9d66da359e450e2ed6fa465dcd014bf6409270a455e3179c0f2c872a6a2e3a66e907812424b9768e7c0890cf1e167d608c92fd669e8761b72a583626f130e503d4bd968d4c856132e09f11188266483db7641bece869b2559c5cf952a906767e815fa17d617c02efd0bc7c8b1f3d57149fee7a99e36d9e3b68acecb3d865f646c3786f2d23d0113b8f3b2e66b44a37a345e964a5f4e886449a28899cc01a7ab86a9ae64fdf999dc29c99ae25f823487038a007c2fc25b5c39dbd2d940a98c3f405a361b979c42a9bbfce6b0dad761bebf32c88a34314cf562efd08482dafae450e925624fd9fb1aa0d13dbf78fe4b1b0d89662d3c264eb08de16e49358c5982bb5b75164efd1861372d1a49aa9a4680eeef48a01d9466317cfe913ea432a055fa85e5d8f6d3f2f32fe46c05d6cd173d5f934724c11c5f7da07ba37c1d1342e2226c67fb9cd9ce0424cad6a32a3de2f2a3e51abe63e6e764983c9ed82e7c0246f5a812c39da1e3394b681e0ef0db6af2ab6ce9b45240c4533ea662f16470520c802a0850b27775d34c6164d4abd2947aba3671748db21550df807c40a4c7f4f0d9abb7f8a16c68237bf53eb7948c088d9efe8d7c60c52731edb5df246aecc0607820f2fad693e715b6e71207131b508e93179d61f53cfd2a07aa59772fa6ef872c39879522832bc2971d9eca5438c2956061a88e79bcf6b6f2ee2a4fa1feb7677d184820061d8414d3f7f96c3288560eb442f19aaddf2c093b26d43a7b5479192f68558e71d5e5396d7067e20b32b5e413e56eddec88521aa9f766fbdaab10b7b654b9a4566cc110b9a2a0a12d87d723e8c2c71b244b7f65404f6153b8fac42470f8b5e693f3e7b75661232fc2217b40396aaeb830989863881b03c85013a82ee5892a85ca130a415870f50a260676645dda7bdfbcc5490b9a67ecfab4fefb44ec56f2033e0fe77b94a7598d11c2b017776d257c6b68e1eb749d4d738f1d0b09f37822360ab598027a8a58afb9d95870a2b4f09c9405ac4529ed41967013d0d4b1c5448dddc635c5d613cab515246132eac22daab0269f1e80d3c386102f1e5cb8bf7c5bf6c946fd989e5c1fa7bb651854a8f992730bec9d1ba07c7d981449ce1142ee845326cac2cb9394910f8af23a47c36968c3aa37ceca0df0735c4697dfdbc3c3033d86a18a3876a4f70b9de95e05d1def8396b4698ce31d995ca58e0acef22f2352090e24c0ff0ad5997acaf996fcbcea9d51511cf0af2dba7bb8019dc69a48c62c8d9445e8cab606656870e0cf52962fe62eec61e68233fa2371cc396215c2ff00ed68a6a0aeed464fdf9f676d4682822014ad6fd188726cb0bd1984d281e8b0b9689a7738bef38d8a5c1bf3558382f67817be7975db6a20aeb0a4150fe092f773c8652478c9c18b78757d7f9df71e10c5f34bddd7ee5e8acfc8fd672f9c174cb6045d7094fbe3b35a32ddcf04047524db506d33db31799c2fc878c1b02909518c5089882b8afe4adc469cd91e98ddcc708afca01c0266a4c73e124c16b50981b652dbe0acecc3ff34edbb684f166e6775e53ba80a690b3524b1375e1b481881b78a78922193594832b6db6aa779b3ff51f58fb07d049f63690b3330ae9bed01c1db67ad11f0fc9523a84d5562f72d5623a03435be2d8127129934764a5b9fb11cf51b38ff2d3e7d3341587caa1c2236bb7dea7b0c0321b51498e45a40813dd8946331134c52bf60c268003120bf300da59a7950be6ab392d3494af5b6e53b63b311b52442ec80cc0dd3724a994dc75ebce77bc56295ac5f029b91cc2b3053564734cd622f4e9e7acdadf6795ead436b2f7bf00e3ae4aa2882062c91dbf74b83f0bd9baf55efbc74b00f01afc6326faa523df3e4665d055fbb009877d83560cc3d453c0349e6edb8af556eea37046c303f360f761304ebcc5dc2fca1eeaded55f482256e91f87f2d0c948fcd9e68bbf2cd3c26fa03a02de1f98e96b8bfaed0210de518b6899545d41690e75d42d0fb509bf1c49dc3b25e948487aa34ffb39b9df3acd1b9094fe05d0761557a2aa5237b1b59a3c598b12dc286ead7d9434a012205b28e5bb840fc2a825f4e5765c3f93d5a01f91d4ee72df04bb41e86896d0e9cdf61d51bd03cdd4028b78dd2390812557017f8a4977075f02b77b170c775d8c45d134956572b1cc8db18e2f95cbf6ccb5e1162b0d564e41116cef4e7a500838ff3d27317cf9bad4dcf196fd940fc87c8546f1716f4848ed35c86b56b5f1e60fe6e1250a34214c592b418910fb72967c7076392284d5c4ed0541d6adcbabc478a1b1d7c150215bed9a402b559409ba5646aab654e5909379f49e5f36c17b06d92d8185a6c7881c20d4448ad14fb436ef991fbc51466cef1efab64c8d25923180d10c8cde03d290182154f476ce9c5eb3669423b7945ae90e87daad057cacd937c858aa25c242e35ec4dc22b96ad0fb583fbcfd1d4c05933998f8cb38bf1c4cac64bcd756030bf40f40684bb380f041400d5a0f28ac9fdda49e8f01399a72c01342e3ab96ecaa5047dbe8f5aa166602636a6199179866dcf2444c9047acfa0382017f934e6c298f626e6510125949b00dbb4210fff176212cca8392acee030a7652355c504be92823b968beac65b84c8af3ce74c56a18c23236cbb7950b14e9c03665f9a917fd627db004e2d045987d07ebba104767cb6781bc8e9f8aa28651c30bf1a4c6b66b2c84b68ba3d26590d2d3a5ed9980916135d3a3aaa992ea6ccebc939a340c75ec14825fa7a29755025a8de81b9c3b626954d10cd5ab398c7547dc30544825622e77b4bc4f364eeaaeae4eb896109d2ed51d6833a6a0d4944110611d0833271e96c7ab117fda49da2881af786d09e723f219290eb70f4d718c80e9529997056bf1c38b51e84dbc75679714d043ccfc8585889d18c04606e60eb90e8b12501ea81f4acc912e54f0eaabe6ec400fd807535917cf830fdd4f45cb8db1b4f0151352a50e6a283ca074aecd96f77fcdada0ad971aab6ba2d68a4f72be1797b5ed026f29f52434e5d54356f7bb30146e64897deb8e7417a39bf069114ba5111858704105e1af1f82c7211d67027232a867cbb251963f73ab7ae4b9d58f9630793d7da30813c08c3a4977db2bf42a25aeb1b7455d22583dc21628502d1ab778798c2c34f1baa01ae5232d1a4ae3de923aba716ac12e5598bfd4bc4d1fdccd13c73c27995d94800972cc5e817a8a7fd4b05fe177dff1e06588fd74fd720208040ac48bc57134508d5b3ca3951314f90d4ab39aeca2c2432b6149048752935eee2729cd8f32d358a81080e51c80f4f0ecff87b90ffbf5f87bf0a517e2c294a806a232a795b3ccdea6d42c03313a2828f315437a0fcf52bffa9d980406121a6b9163eb70c56f41f348d19abeff6f20a68dcf0a649a6e54a8984ed6adb2102bd6cdcf8cb8b0dcbd4c47b4fe511b338f9ef3109119aa08543f21978e65bbce06dfc84cd0abe363e2d24aad612ac43c3e08bff2ad74be74f2eb18e6cf613c7476de194087446f178d6fbb02e0726eff968a9359c6fae39ee64b13b9f32d575b6d53e8829a2595c982835be67356e95308206320b4f628bc28d7c49d7ef275e17809e873398764632553bcbe3bce495cd45178e29d6fc53bbb82c02c447e392ae606ffc938e6c2fc87a4959731dfcb6018923b0e8057f47bee59975fa5e9d7eafc770ca75447fcf7b3fc5e3f8e1de026847cc3f16fe19827ce0f060e76559985e62cfa63cab8bccdd8482ce3d3207200d218675aaf5eb8c48d1275eba9349c90da33f4e64a9bb66dbd2f1de771f2c992652e0208d9286bd28711a8f4e1cbe3d457fcc1f1f252143b3442b4835e27ec0c0c043d0b3065985ab08904eae6b929ea8619825f60b3fb044dd9e8709c25e490fd0815c7e0a208ca383fc2f13bb15093ca1412bb1af028fc3a8becad6070fe0199457b4ee7d1c74fd5d8b8949c3ce824232e254f6d47ad960ae97eafb1bf968fbd4de7913851a7f393b3e15707918f06f38b39e069d29528d83ad9b73702e8f61066d6980cc466a067a59a4f184be063c854da9987851bf0a300f0402c62fcd1ba591d9fe79e3801e9780f56ee4d0b91a7120d0a4d9b5d3f46f53da855982a0469b0561fe7987a8d378f922848ebe1216181c65e0d45607c3f456095d1585880558c88c190830f871f72e32b617b6a182b3416fcb5bfeb72d2e21a7924740714b13174313fbd23f51350faf8885d140d175d2f995e2157aa3dacca670d06bbb2d6384affd4eab5e3e6e32b1c84be0196279373a2c0538bd0f2f5ad3cf92f5e33699c47ce7cd7bc7b09aa1377b03cf22ac067b9dd1a6b89e14b45a0791b19a4fb7af64297555b56870dd1ab1a4368918b3726f2d2bd530752705178f015864fa1ef19602751137ff156cb2b0896eb812945f60cfea69bdd6e4fb3533150b28721031bd7fd054857f3a95fea9689e60b6954b40c09463d00755770263feb1f199418ffd7a5f9c12bfb19a12125cf99c03db5a759a970e87f52a42785588d7fc4a82e6e308fde206865c79743d4599b30e99dfa656ffab10230bb509e94de7f74da64b3efcf7a089736e841736bce9e056ebac5550b295d8df1598e12753f40280d944882ec9e0d347e43aa1f5e577c690cca21f7f1790d700dd5dfe96b1665b29aaa1855b2bea163cab5ac7a2b810a4716d87e2536dd954d154a5dc9f4276a004110deddc47b5b31c885b49194a3501791090e2661ebe7e2abe7568641da414e2a45eb16dc41dea5df0b8fd0d403ba392c60d9d71866e1806751e48763e94a6dbab4aee66b3f099f25199f897c2185a63b49264de5ec493311d6aa2d40af8cb819ed0f2a303c14865660a0dcc95b3064e966e226b271a6115804afc4b93d06635315548e93775545dc095475abcd4468756dd5501dd8d855258b69be6d31ab8ad07e3013c4af6417a4beb1f65299377f542cc7c01e0f8effc60ef26d43a883a0b008e73c0364857f5862773771ad37377615d4fb2679306bf8306096d9df6be685e73e698275f11782e64372781d1d69a92078f474bfe97289f8b950ccb65ae6ccce989da08aaec6e8da391aab4ae1fceef8f16e470ceb3841d14b5fef71d1760e7cab27f4ddf3cc6afec71d0d01cd002d1c1c389edd12b9ea94f1a4d097a979d31013a57836feebba063140aef4b28116cce382587cbd13837606a2897bc8c3bfd23bc8bc1ab0763b1224892bc91fd6eb9b24bcefc7e3732bc0b33c254c741b12ab0fc96f454b2bf1f30beb5f41fce77a9b84c627d050cf9a09a21ca2fa5265691d400cf0ab0a9b7172c160c71da91afa06e56812592fa89dede9b233474cd9f11a4fcf9b72788abb8f9844d267df2ed9be5490410dd63fb52b97ecf21cc550dc44d26de30109c50a7a07e3aab2535f002c0dad8ec72963c85ca605a66071738e82329a22aa7514d13774bda44c670a400bade41cd0851dacde50b9579f1aec22949161481c2001981f05af03836a0721c27ec78dbc361302f9345f313b6073d535974953a0f0d095156abce28b21c2f11b1e982515b0cb8c76e0c39243bae8a27b7a35740836f7e7792635c5824e8ef4a31a2adbfa0f969faf386a81544f40a6adfe357fa1c39a3e352ba5e013433598b5ba1bdc78de64bbc12a8442edd5b15f2f3b71bcb51687d5a42c4a3f7d0b7b8edf6c4349d4a4c0492d1f21ec3d809fa906d23f974432cf10b3d28b9b5a42c1d37840015f9ead010cb152dd919abd7be03ea0418b4b4847045171f15504e6033c120fa14bcea957e42a39fec67b20d769204a163c04c155cbc8a863aa9670b6e0a49fb8a030a6f8685631a57f26db38fa0d0fcf71f50b9fb73b1e002be0379c741fe71b8b0502fbe5ebfd75752a0da0bf3014d5ffc723737acd5104d49961d8483efdf63060352590ed1b4dc463d8cb175c04f7d58b73e2d1e2539e4840e02230807794d95f4e062515ec519c8aac93a5117cc1f6d7016590146ff982f56bc0824ea3480cd17edc7c295a5570359aa3a228fb85d66393d2880ce350879b7072d601dc28e3edee6bf7ee76d4f970dee7852fc8d8041b620a4f32afbb1bf03fca8fc8bc9a946aff1df02f091035e7e38fa14637f6a40a292b3a555709c33d5d62e43027307196a5b27d6d140a369a9428398c68e3585a96597c2d49f0cad0f916ceb72092d567606b51b39670e1ba75b56b4618a419f5cb910c30d0a7cc2e1091855cb4981878f06a75829403e9be6fda0c4a140d210a8eed203cebfab826f931f429a2100f3d4df249f60b0f78b9575c6216e38574a287f8d8f618f11d4204fa0cf4b9d276ce1ba1199aceaec943487b390a24f618c2d5515fa7dadd196eb41ac6284cb18fd0807fdf112d56cd089538ee3db43d097046de4e92ca31fb31cbe80ed09797d1e82bed95e39fa0d67e4a9389668940e84e6870df6c84d56a833a3410f2e33a9cb237784a9be90fdd84deeafc3cea6d16f8da66a719e47074139a8b1419d98dea50c1786e7bb3ea5c290100efc9f7f447e8b1c3643e20892e02a096a367ecf95a0996acd5980c8d4905e6bef6a66ff1a517af6a08d62d4fcddfc8e2877d8eacd769b2b12d0bf7dac9dc673f8fc1490ef0c992d40e22ce9bfc6823f86ab539b3ee4ca26754c8d69d6b0edb13ecd889f2f0cf4846c4fe88d39df3669675598ca10515c6de34f1c8cd2c6eb25d91ac83a3603c99751a057af345480818b896b8382c79fe298165d546b181ff694d84408bb35c90d697424f94cdabe423996694d669c371bba05878f74abf46e6d348da187e12b244f762c7b452a7926e893dd5101516e471a36099bf13a7ebbe071f8a19b97e1e8a36891e9f534dae5dd9d3af1d390d57e6fcdd651d618f268a2eed050e341660d56198df0d54e598d260f25f2b69ab7c9b18c05614b2e691d5484c949be6ba06ef7210cada7044e08ce2a034f3556b74bcd57ae136a7c6558ce3b878659a54357afb3d333fc5b8d4c82b7e6a54200e87ba86a70363feb9cd8d97447e69aa75ab5e89df102f0a042d514f9fe1017b26e0827eca8a8f468ce1cc5375dd5bb7342be222a83574e2b1361653be3a91739cb6a6fe24db66863efd8db604c579056ab144012284c8f74ed32ac632a275b6c27aa2fa1db458f3e1672773e3704cb4b532e32ab2cfe28ae2f04ab0e288b8932c6afb2197c4fdf83f48aa991ed87a695a557997521fb54c19a827f097ba135ee57654d123d26e0459cfce52ab09a5497f0546ce20b7e7f21c045d5a446a23cb689be0f078bb6bc887419cc32f8ecfc0f8ecae02107591cc6dfa80f48d304bae92fc476b966998beebcca5495c27ef6d75a9d2086bcff0dd9d6ae393c9c825e9350960dd03e6c0f439dfb5553b46d303d409be16b8af770da8ffc61938a145df4f1204f461493148685b2c96d221c58d1dd310a1008554212e7363d90fc219e2feae2a7090e397a912a2079ba87b2a83d3d4519afab93783b120aa793b5d3147f51569875ab52e963012abf0da7bff07077d00e61b6a48170a83bf1162babbe0993de76e673da61cdc19fca0809ba43b3dce7f1dd91644f4207e2ec0bdc58c30c2fd0128ba5f25919ae87a27ffc548a889760a15afa40227eac6c2cec1afab5343b4b2e6a47155865f3656e403e398ec0d705bee695cb37a639dc0a886aa1c93711c71d6676354af60cda6eca6f53b7da0f46a8a1c6749d32a2c25def579342fdff3a71b691bd19361e2cab13a39b528b4ca237341426af71886b1e7212c499452625ce67191be4e7776f414c746d2e106e17784bded19c6b77e36709b068ab96705d312a0e4152ac9d8b4e2d63551bd32f566242618207039a0cae712211d68e453b170e30015a4b5efadd4aa440ffb84a2d710e69fa96f1714e8064d970f438695dbfbfec275cc62bd96c812fd38510b461285d5c829c3dccd197e206695252043165ceb9601b0ed2c6518b95b8aafab28799535f0c730eeda6cdf37ae568fecf3b5d1c003ddc0d795d3a0e550cc7f0282dc218edb883fb89b8a9c8c8ec55fae50eaa9d184ff367c00c8072f491cc877bd57ba82e2ef5b8bf4384372f34b36c98c572a946ad56814bdbc464722620669d4c501a45f53f9461a9e7559b9557391bda642a9124191333783c2bf4016f61553efa570ec0a383087cbceadbcee3eb11c6792f89357f61f3d6e839673ed3ddfbbe6e5e82b660c76c7b8547270221bf26f1e2c67490ac88978046f5d9ec518d831140dc466d3f25d7e620a5a7c9000feb0a987a2d72c4a2011a7f823d21fab5bf0ab7f6a6d8148db1c7364c65195888b79f7cafdd8d96d32166033e2c5fbd2c631fb645112584b5e14798eb5f765000d48213400bdc775b3e70e4d75505a30c36a610c85159cae469009578f0c03b549ad6bc9838c9b1d10bf3e05a99246c2af9234b68d60e322887cecfeb8ff5ec9baf5dcfaadfaeb36ba8c977e9a75c20c4a801edb3dfdd95a1555424c98cc7d01b7328fd213fe98e895c8a71d3796588c68ec7efe8f3b099ee29b013b873ef93c898e85c9f3029ce47ee0055e2faae26c625ae2e04a54bb3779211b2b838c1a7bc3c3f6aa2e341df41d44d825ab1c1cc1fa82af775456c11592017d1cbbb0c45e403383440e31f86edec6ee5089670cdf2c041f1135ddf6e5a02a91274a5b628b7b277ef75204ef50c39ca10d2a373c44f6a1b74f9b3997be3196064f768e7a5f1211105e6157f49942e08bb1d8ef8d27515a2a4776813f70168340230c69b080eba1ba36bafa7d40f2bd15e15feeb8a27917628bacb9aa888ced78edc5c3fece698a8c32be2b510ac3179e833efacb890f58ec9e236b88945dc017efb52f03ecb02c141f05d0a9c7176a44772a937a5f96b497c83376a51a4917b34315801b236b4a35e647b11ffeb157fbd7f49c6260699ba936cba12c8286f72ece54b87384ded3f15c097011a9eb7224a1c49ab1eb6639ada3d2093490ae6f5d31c8688e61092b58d1fcc89d691376d9429006966d4fcf58efb244529f465c159e10ffe30b8cb11eb53dd5efed37b58659daefeeaca447f3094e4c16ddc10092561519b4962b3995435906332e90dca6d4caa11380875902f881896868643f140db6066ffa18fa75655669a5c4a420580784be2bb4bf3605326f9dc2a9ce0faf677ecff198a816efa7d96aaa353fdd4d2c9f814ec4111c920c769ce93a2f1974aa98276bc3f0570f10692c121138224c1f3471858bf19f33c35fbd5c0355ec17ca690f0138047e9c8e6b52a99c88eca401df0afc03f3e835b275f5f33f975a39fe1e6d3f6fff81df233689b8eb7c46bcc11ae2c3e8748818385b28bcd7bd7f7e6fbecf961f6a7822e83a0f2b88a8f524449ccb63baf5b30c8c6f38dbce0f35d752aef19ed4c3eab640becf2bea98872628f8d1ad15e2531e78d9beb8159f68e521ab613aac4d7f98aafb52743b851e6aa5612e8efbe27e5c983b783300a8c06e01428341b0f905c9c9a1c9cab72bd582e1c83f9a3d8cb9902604541e330b3d74360058d143cfce785df4f5694f0ae60c4040dd6046f9c31ec1b722ae04ce0a05ffb4342581305d631f81e671549a432a5907bbbca827ef54e05395a7480954b8420cdbca50912ca937cefe3fd313a78da6f4cdad6ef222bc3533735ecf9be70670f59eda2de760e6b6548dbf7327bffa90e69e0fb6ef64066c87c9b96cccbdc798e36af4ef13ea7c4fd25d60ffbb0c53fe0245a72cf6951047a31d11199a9990f3ccd373f62aab9d0c341da3b359ab4fd0aff23d5ce1ff7f89e17e1b2878528b2555bc505d155b3bbe5a02276d253325b07a8112cac425c6e839034bd5830774ab94f6bac14d5eb8d7468891c309d6d4946cd274cf1a837f3c473e0df5b3ec2adf0a8ff16716943e7ac01ba8cd70eb3ca92e3ca354d026af9eddfe301feb48425df0b3ec37db03576043f1c3b1d9dc64f31e23ac9f1c602f2d896da514a90304365eee78ada1d58c0e3c76704ffce949106c331f40dc155efe097a12c42d3f5df33b683d0e5111eb36c770c353471467a1b39a9a6769fba02a2f99f76efadbf702835815847799f06c8f3a1910bebb0411769fcb3fbc6fe7c47e643ca1a95a4e14ebc9fcebb8497d39d3b3c05223b090554e430251d40e3e409d34075eb1daa9da28f845e8109ef6ffbf77e8d41381a1a84981549c789030ccef945b0adc8aecf34db5a29b3ea70407421ed4f7c3bd6b1360f1ebad33422646b840b3cabdaa0217b90390f5aab950833c5c740ff0b917da483b188a961bdcc89a68de37d1efc28de00d82c3ed774b22a5fc37c7c49499e461bc04af7990d9ff75cf25f85fe4aaff171433f992d807b85c4c7753677f7efd7ddfbf0a28e5a63b1be86f291867920a5a32a20880797aa785b40ada57bdf6a2ac0d4c017f70c4f1c6d66482e98aeee3915766989059b53174221f3ac9123df91e0f460cf50014e9c2c74260ed5b0d37e8f656ad26c6ce0ccfcf180092b55bdf7635645ea89882dc372ff529558c56fe4730c85cb3e943309e636cb6b9e6dca065ed24b48c3c5bbee27ac4bb0b11a2d2eb64637cb6eaabcfec8a65c80faaa6b20d3537a3efbefa6bd759e409db8a2ed3f8d3ed6250e67826a74b22370088223098c49627486662eadf9fe36e4ba411af6828710ddb850c0921ff995014bd02ec45375c97d6540b30505bebec881a72cfd7534588455cad1450541680c701fbb55edd68ecb33798104ae896f8b983a6bc6e0a8d2a42968704f1067f2f4e1401ee013e89a5171467057dc6dbd75fd9ac670314d0b7eafe476e26df5ec8b9ada00b569f46a836927ae225dbeec7af91029191c3a48c97559caabeb85572db53b736dc19baf5911dc99ebad60adfbc8440702ba437c0d2c80fcf747dbd10550c5e56884998bc41123fa856dae3653ed99038a83197eb705d10519dd7a91e01b04dff62d059afea108f4e87d9c619055bc83ae0685a3befe0521f112f614bf936a753acddb8bc5240aba4edb02e37732c8afa6dd86d82c0d428c19db669bf27c6f196716adfb1af39260f3f294bd280d993b86da94c03b5e95fb585b4b455e866ce81ccf74163a2b4ecf90c8671788a26b9b0bf76d2d44a27a7c79a4f0cc69f0d721f76b3031e564569164f80e0d59f5b2cfb6449cfe6fcf04eb47fa56e418816982664258c0b43c80060e36db8d9502f05b184adffb446336dd3a81446322aaa7514916cedd6457b3f1e51b3e834c2b0d9f17c711feaff81a5156fb84b576e04b725fc108212db0bd6939d0bcd9a74bbc735087319241bfc748a8e5b5f440760bc72ef9f99d128036c0e61d38b88effc3d01c7a5229026554fcb584aedd63b107f6d6dcdfad558ac420a6dc785e215fc4b8a3beb875e86efe68533d5602c5bc91cfe66ace21dc6c838f5e4c670dee82fb225c0e8ee824202edcb27ef0714a3a484688c170e70ef0badb54ff49eab01697dcab89525bfde06e0e129203699f17025d4d02c14560af52c2d035bec3730c2737afd8402d30120020970aec2711d88c49b98588f709764ce086b135feca4245e77a493e0cbb294dd9d3e6a77f255c74acbba39c095d6d72bea24acc3777d9c43ac94eb1ef2e534db3a9ed31665256d352c5f1bd031ce4335bf4b9a2a7349477044f4ddcd97ea0dddf73dc3afcfcf32449bfa0675126ae9363fdfbd557568c0214f1965df429f8ce5f965e70a07e3a9c44d6cdd056599855575712da35eaa27c89bf457b63962f4e2f1f1ee596264f868b3beac3c7c302e8e8030139f9a3f744b553dddeee34329ce5f4072295c20057dc91fabfd430641b811b0904d552dbb76dc8d9d9e98a6ebc9c3dbdb39406306d3aab2d7aeff103bc20322f92b144556701ba9710822c5158d4d636205107cd47ffbf09bbdfdf0956eb21551e4c349e337b9b083b644b05f2d5add737696a78e2a5399fadeef4ba8711fe270106f61f3478c75a67b0e5677b0acae405cffefe6373cb5628bac97c980c6ba4c7a393d773a22679d61362951207720974f3092787e59c9cd218bf13281284a27f576ec367c2d82cf405f8158195f5d237d2a80ac235f59c889a680e8b016d5bdbf7bdb8fc840be33ab97f51ecd88365646ee4b8f660c3ac9ea82d1bd7d4c2c04c6cd9ef7c1ff1547ea450c0ed8296ea12eada90a380aff52dc6c7b21d4953be17b1362bd7b9dac0ffd57275b327c68599518c98c2a2ec776707f68304e791ed2252701d7b50fa023336fc1171e34338fdbd882318c22b7cb8a7d5918559f603b911808117c4f47754aba7f72674ad02cd6b0fbd8f6c5d6063b7e9d80af87b60c3a41ff5e16fecee566a467cadfa4adcf506bd2bc1cbd9dd7d6bd055f024bcea0e3cc6d1a387846bc03b8e0d6cf9f0951ab5723394fa1720bb2d7b4b5e9f96200f93d70261788a16fcb56410a939566065f9b663322f7bf516a62ed2269798230c9c74f073ae74c6511234881ed72389b30cf3988e237e6ccb6c74fc8249cea8ad037cf54c5bc65a21f453ceed2622ab71e377244c2764eb0f409ffe7ba027dfd78aaaaf36e8842fb2ccd649543ee529af1c45da7d01a538242c244fa3709d7836c8dc5cd7f30815f6bb471a4505957d8a8c49e2825558c1b960f1ac73d2ddfba2efb24524e6baed2c85cd554368722158cc3cdf295ca15d0ca5f1edc09fd07ad2d75622e84e8f0d35cc2fd185b5c2a40e6794b284efab114979d9ebe7851df3ed76e80be44e27d38cce3c8c1b586723bf7be54f6978f80c724c42c2f1c8a677686aa662bf23c80080801747f39d9f690c1761507c0e39a38eb0f0db57f278bbd5d55746112d5a3b5817109a4aba3a4fc6ef9801c677f34f72571cdd897fe8d578c3f6b39d2d06ed6742de01ca49571e4b8a5d3812c5ea920416fb8f80555da921024d393199d45651c54431eccd575e4a8b7ebde2d37db0b65d791a8218a400348396f706b653b0bff512036aeeea20aebe4ae78bef28fa2cbb8083f8c870f82aaa81a09b1160946b457260d2627dcc8a342b7dc93d85336de54b3d562b599897cefebec3a7281b600382a2cd8f56fdab8f73697f24cf053aee003ac29dcd08eec187d7959539b6c3212232f30871d9f031d8cc390b2aa40fe472f362dd53051a0a010f2d9e21bad28c199ff6277cc8f2170cfcf0ca7c53c1779d8fed9c9cad07f199a2795f8e028faad9205e8b1ed748de3c81f6205eb0b57f4c7b33db509aac9b84ebecf9f4347bb58a79c70dfb39124126c174d738f3d3410e4b2a31d5c0693586fe1881221dd953ec6326cbc116d9138389f53f30b571b4216480848e300b9e988c2d997c24a6e1d0410685ba5b9bbf6d25960c5f53632435b0d4a5506762b835c820c54e091cb5d5b32bac9da49792e553a2515e5a21162aa765fa130ed10bd5aa6083db444990aa24c8366c886ff05ada16f818c3a088217eff0946483cd69837ddc34b3c6f0733dbb18b73d82817da282190570784d959f222dfad9e50a21534538bddf7a152749e27ffb0d70bb030ba2d910845e6dc7b677cd0c256f23be0a0dbe5daacd707598f1b6c7e1370d8335529e7555259aea9e0abb30ba17a901f99fa6e23657d939ffd752d47e7b9c86c7a332468fe424363c293d765d6fca22c8a86851412dcaca6d588d04feed6c8b45c1a585d0e03f6e84bb51a72f26c21a96777e491f0ed65961863fc856acf00b4bd548f91e359e7bcf8ab1b663cd550749e4b7952398b044803efa40064c2164520b15e1d080535a9147f3fda9b969fabf6f3de9fba4916ad18d6f3a606fb801d4782685d392f0e358b0e972794d52c4218c5db14ba1292b08588f3b0ad67d7cf3be3cd320ea5567a4a3fef01c7f4bd44afafdbab1fd217dbaf935fbebfdfb4b974019dc8779e8cbcca2cb51784170ea253a2b9dc5d9a12c2c88d261384d75c2c0005abf533338839631a695e5140f7281a39ebc4f48b210e403ee633caebf948c0c5bf1def2d4963d04c8362974873465c6c23f333d4abd22bd124bfe9bb524151684943de14f4267e87d9403eb8c640f843b4e7d57c692cc4ac56249897c955e1b8d102b8b34e409fe81c7b57a69291399800e8c9562e19255576b4caa72ca73196973a0fa22992303aec308bd762ca255e057f9cf58ce42453ac83acd629ba6bc24a47dd6ee2e2f9bd66c739377c1f6d79bbc1ce17365eb6284bb0f93af5bb9e00a2403a73b597868ca26884c2dd25dfc5668c461d3711689b2ba38261269761f5f5e39ce8935e706a5731ebabc1e4ab4d97a7e86e9e333bca7f0e633c2cb99b4e4222c2591036fbe7d330ad2dd803c29e9af2d67d1f8d36a4ed019a01785f9a081eb954925b3b58810509abca97d6bb110a4ad31c03ac1c8d5403bdfae4e90b7d7bda26dafc0751467ce42fdcfb7c74a021b732f94810ca299dfbbbae7c3d33da691e670227f7811075d5c22ad98c878b731bece4acbb3f71c5cd6201e2157e056ac54608a1f8168e236f200418ced1692cff75980e7e6fca2a343f54fa514a16376207546a515e6e0ff4fc7f97d771c1ac6b631616e4cf323b479634f6b6ccb31bd73429d6dc800d0d8b1e437af1c209b54b414b89964da1cca875862bd5398b6fcc7235d4ba0762fb3b270b9da7e472d4ffc42a90198b851b5006c21b15c2a65d00b68642a5480b6c916d50bc528f0b642a07130a42fa204fa571b00141a263130f371e011760aaee164266ff5b446ae6a4e07c52de3b5be8cf3b863a52f63d31efe01187f62cf4c153a4deb54e27b17a2b6477690e169fc2686c6ad766baae6c924918735b41d3d9e96510f83f1b6bc9f064b5ad99ca8b0593388d7aaef04e60ee708ed5a637eaf270269eea697ae833b6db884ad27c15ac96398e5c73a8c7817c4a3dbac2c815aefe57f0f12c60ef289048e5fe0055ba4cf591568ccc65e51cff0336f170ac6892799790ff8c4ab55d258f12036179f1d50e7af469dc6004c7e608b0a3f2c552839a239a0e4bbed101ad66ed2ce3e9db18691c7a6d36cb931f4334fdac320d3efc3a55f509f044244a3d9e9033df41e53f11fd4e8679051b64a7248b1d3eacd8d3748c690720f8611b3a4917dc6d5189d871a81afd2fdaaf13b6279ba969ad2307cc1a72087b1f68de40bbe3dcbe425b7164538ab214881e2d4e43c1a9ca263afc535b85d9f1b4b27ca9e269252a685f29f2afcb0ffb70a7b08ab9bad0841f954bb2fedc2bb21c6f8552e30c61f5ea54f6e079748e3b1b4db4f409a1fa579ab2ff43836c16236f92541067db05366fdfb92f3051174153dc4b88ca384f7ac0e09ceab164e9aea3bb66faf7be26e335358f1c7535ab56aac1083cbbfa3c827e5b722fb6841bd7e85522fa0cc00e0b04da75539d1edefdd581dd06a5b527538156bd16cf47a50d5864aeb83244bfe1608c0404b05b32c7e0511d2a08cbf14c0485ddba8a20f772d5ae4bb6bacbc76aae8710c91869381dd40cb5bb349262d45e510f99d4001f61a432ff063d8b1441d8853529ede48b647b9b1227c572f2a8dcdf6b001a2b14e2d8641df67d6e3c93849df16d5d4487a1940557f97703a7b6e58a6ea8714d5753bd11c6185844402e87c293a6b35649991eed7eefabb3dc587dbbd3774efe964831ad1f1b6edd351ece9d7edaa27d3e764a4102262db01c8e63b428ec45337cbc14117e22c3c464f9b4379567e1b8facbdbf8080e5684da7dd786ce276757146596eb1a87fb2b05359a475e1879391ac759e7a1a80de192","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
