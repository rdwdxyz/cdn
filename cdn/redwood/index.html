<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1b5e5f49f705987ff923c9b7489111a0711b38570b5f1ca5a30f74b04331076f0abc2d6daf5fd07332fd3248a9d85090a2501063e988c2ed8efd66ae26e112ce13ada40f6b6b600673d90b1cf5be0ac53cb47c89baa16277a6aa8f91ed739de6abcfec06058782a1e8aed4850eeba55f65538feee2f8ba7952cb61e067c14d593d65835b792f8db570740d25fd9e6b737af4a95fd8c68b88b53fe9aea673cb673a02f369cc37d8a9ceba48c918ae8ffdda1ff949e81f57971336fb48c86fdcc43bfdc5e4c7c78be2c8de996588e34dfdf2be41e7aa4a95571df75f8fd68c5c5b2d5cab9d48dbd475be52b4dfbb9efe49f353a72231aefdb9838378e59aa393bacd84e38e71d060b15500842187439eff669112024fd9fbaf8e85051791ac0aa25d77ef1351bcced3d5b5f57c3c80045e3856c04521396f56e61abec538cfe92fa6454421db9bb942ebf2d82475002fa165f8c4d45697113dc8beb83d7f68bea5a4447e50d29d94ccf5e191b8a54659b0c1c2d90a74ab4c3073b57904e18c29731586af8ac0516645ed84102a22a828dbc4e1d0e2bc4a688f856e6fa7ecb0d6a52a2218a2285e9a8e1e6a746b91748cc6b0501f519ec9dc4edbe5edbcc2f57b5b9a7fa87db774a3a866fc06ae0ed7e05e0235c7b928c3ea0dba82d3a9358288fae2814e561d1dbeaa42e1017d6fee0a19c3afe66edeca294aa5c139a831f5f58685261488e89487670d8a05866558d3567f3ea48f781cd04bd54151c7e9f52ca3db8103df7970e772ef2d9729f6fbde73d80c75d306124edae7fbe3498b5bcd5fbd29f54c05f94bfcdb2250a918d374c83452534a6fe22be708335d36735a6a3b6d77929c9f45eca04790d3c7547791b82f19e79d527a227e48dfc3e6ea71a700edf1f6a90abd888a9e2fa60cb3ed2107327509e9287d1d999b8455fc51ed91576fe678b5ea98e3384468eade2118591bad05fc55d6340701662d6661033b658e561b48a402e037375eb49e5b47d6c0cc00fc85746030acd0a847c72fb890a86ce217b97ac22406f5b5ff67f0ad0e2c807d504a54c8c5078f9d0d154a9e97f3d3b87af6166bea111b0a92fa3e1e04c2434d92889ef786fa48edec9975957addd0c7fd8c9d45caf77d0d7b52edae80e3e3cc9d9a36951cf8fe5a4e9130876f543077175f56a1bc07ac98cedd0c531a6e8ed25d9ee048300367a7aaa9834b832077e0369cf53ed55d609950c0be5bde6b59714d9512d0ab629aa33804f895b9adb01ca00bba6a35a254a8ccd6ed780373243670d2c28120817dcb396c84876436aab0272df1f81acd494dc838d4c7de6a4b7e7e3f40f28104ad47371a92979a6636fbd0ba826c7560c777ffe9d87c58e2712a12e6e5824b6e434ee65a1cfe5e48a544c40a874b0369bec0083704515378497b608b42c39b7465e82595dd1b7383dbc401bcadc3923aceed333722d8604cab0aaccdd13a9b1ee9fb0c0113424d0177c4facd35af162035c6dadf6211e5740c89cfe1568b133361f7b234f6a539a425ceb68a028ec897bf0250d0d42bb7d3ee92db5a598e923b2a7c07c6ab6eaf1b36894beb833aba2c179d937e4db398377c3dc6cf2f215ab1ebfcc74a3f109b92ef5e95264a4f741cc8cee4a30f3ec76138a19ef43a524c1994bf52f506d05b8df4a7ec649965f5c74447ab45fea2661d2e711fa5ebe10d4f6bc720ba78da8ece79fde97bca4ebf41c7d4754995e626dc843289ba5207a3ceeb3010572233cf34fab0215a787cdf7e65e10edc34e0aac85a9f3aed669365c432595af73252bc03cefc05986d708fa368b7ced34802fdadf1e91533dd8b6e01877f137a1f09fc701ce1d545ef748bb112107aa454d58bca6153582fac903bda32b06a1b66c8500dc3fefbeb348af6d8ccba855f2ccecafdef5b434785e97ec470557e535c923032a9ecfbd53d866c0b38a338e958be49f78643565e5d9b8c60e1c7b5d744b1bb74ad8e63f472f1602bfc864bb0af60cefb0ed5bbcc9f01b095fd88b25250356667bd9c44d17de916e1cf5a41f0a83cf4f9295dbba2c7fc6b9f8fb8d982134d773e25b54534b93e6e127be9172e477c94dbdcc220396d2990efc4b9730ab3e4091a32d8310f2653ff6d48ea2c13be281b2438ae69527eb97d18dd975e1c77e01d58cb00a68161cf972a41bbc8252565b80589467fa6a91ea01d4670ffa32b18bd95c3cea89aee0cd8db53f6414a42b3e5464dee6789f7a5f93e313f56237ebbf2e1d303567f601abd12fb82162103f4cc734ab5e67ba6c5062b26144db63176b659740ee2bf227650803c4f889e69dbde650a612abb5f5c10907a98dc1c834edf80ec3e788b6c7ff225baf3bc3f62274fe49ea2361d9e1b0467db2645d6970eaabfdc511ab4a5abde75e7cfcef97bdf2e675db606a3c3f8b0b6420e30dd3ce6e07e25e4366fa093edc5b382a242b6f585b39ac08562be9f1220ae733b5aeba9ffdc24ad76f20dd801a9d228a218dc9e2b77ab97f82b5a401479df15681d82059a6e8500fad8f5e664a471b8bdd7d8ad3af8387cc477fa4fdcf2bbaf2efdd3bc494a7b0671ee6ad691e569c9d9cc3e76ce16eb7f937303f2291c6bfbf5bb82d91e2f82ec6d1afdb69cd8c2e745132380e46685bac7b99afd185e4302cb795007060791e0e4a3b44f781b12e58b17d058ac961676c486d9ab1e14df05554b6d4b47a82266a29c66166c6986c80b213b7b3b7fe54c1799a7b5660766c1e1dc532337d61a5562abc47d1c64e51332a7c2ade0f0a9d6acbe352f346442e32e367db0a83ab047414e4e4b1d4b4012bd38d9e2090c6b54e43eb1a1a079206d32a244c6d1dd644552dd9ff48da4f88eaebbfa74ad6548a498ff98c9380cf50e299582d1abd0531a31133a27c4eebfa587571482b4281b581f606f1514d8ea180187ea0a4555b9fe58c566d85ce32134974ebd1aa8e41e8c5ef889c0e2ba6fc395175ac80a52fac057e4567235d4fe03c05b3f3ee95d38f1c7c2f539293e73a7614f5e1eadac3ca10d1d4d2e49f174f694c64dd378b43a58b5b2b1be38b71cfeeebb66caf75391ad9e062bec3b6aba2abd16e61e3809919ff4f1e10e9d600be0a103907bd46c7d87bf234c3dd456e383b11ecb6a780659b4ad02090fd56c628986792ff426814cca7e30f34a0ef3e309fe5bfce16e5125c091dc983e46f47f48e86938e82f41370c78cff2465649f1ba80f46bf62ab107de8db5dba9f83b4735474604a272c73aff9d6e0305a89841a88303d85a57b3193e170311ba27668815c7cb25023ccc70c38e9653af07956751dccfc2dd3e8e3d09e96c7f067c1b43bdf5c3768ffdfa282dbe126430cc9e4f193ab965fef725483263804e0222f7a8eb791867d6fc2fb36824a77977f86ff128c76d6541274e2a776a8a69d999552bba579040d2c9e9fe426273ca99de118a4326db2f7f217fc084a630bebdecc81b32cdb744f5783e12da6fcfe573954be071c743a7b71e1da237536a4a7d097b2d4d7522921d2f68fcac16740f84fb4c9aab1171eb48f774312ca3b3e29e71ad4e7da72a021c2c06292f3825653ef2e9a5f70f36f9fcfa4e480ff33541b0e21db4d3f47182183057b6cd53d54ccf0085a09b0fdf6fcfe56a295c0c2b0df78db22780d4ca126f095d2f81b0ce5bf3cbfa453f99f24053c724a8a8f2e3fce5ede92f85cb82894454cff64cb4f8b09ba489fca3da6d995f1ee499551a12d7acb7548abffd010b2a9871161a5932633a86fec9bc24651a939964b49a73db6058064e077e2e46239834cf18277e08f466a0b89a547a37c27097b4f2f51fc5b101806ee248f41231e0dc6e7f6dcf841d51f4f313b0aca94d2346427c48127f60d4a6182692dffed306bbdce8e5d51d5151445fd1cad7da51f93c133ef5871eaf9f8d66da6208c7682d35092d933ee6678a45640903f12fe08b72249a2bac2625b39ea3f940695e1baab29acd21f3794a4a9e9204f7b037de001301294c608a70a62106eeb7924ac207bb0a0a4a3da98bb27d884de7d2e2ace407c291598e543e53561c175da2da6fea6576b7822546d8dcf3482b3793f1848e716a66a5cc0f06be7895a386b7c6b1ba51dd1bc83f706c60b2848cd9fe3c894ff0bd3adebc79d9606bf9f64223c4667f70300bd722c00f38ae7ecdf1527de8e8cc3803388aaade3a353e1ffbb6cb133350265af562dbc4ad5e4dd792e16a0b915db682fe2c4ec4e883717c1f91f75006f52dee5b59942f30457318091ecba2c66e6347f29619a30b066de674015d1218ce8d4a19442a10db0dfb73dda0d561c4dbf52ea3dab6b1553c963b961620353f43f00acbcede55618d08fbcc4a6c0895b35cfcb2feed1a47e91022e8a95c6b8f686c1637af87d7da844503709ed6fd373b924155fe2d4b432bbb9a48119b80996f89921c34245528bb7f2159b1c57644f3f709c4c9f7079d07b49e09725b9d39d2d8dde48b750cf5584416f6f129cb5244afdecd573c46fac415bae227366ea1bbb659fa620888f3f3cd71f8f81ae45a18d27fbdf94bf625fe5b473db0f3fe8606a030353b6527fc37dd4a57a3d1e9717c0c695956e44c35278d3d519db471bbec9a007eb622df54c4d9e473988eee16c1d1852ebdbb3ea7f7e0606447b1bdfe6c2ee0b2482a07a327ff58fa2e88f46c14301465c57ccb0d8466639223ad87dbf2b7cdc0927e638eb61763df0f57d4b49eb471846681d1ca30056cea802434c438790388926a22f3db4adbe80b0fe61be73f25685f91e8c44ee05fedd5b3f7ef7191b41380bf78da2b1128a3141b8a3d8c4c970fd79c999d4659ca437ec11f281e779d05f168bc836f17fe03572c4d1c183e1aca1b0d20b9be18d2e83c2cc431bf8a833f91ec47f82d4bdad45b829ecf7f80bd20bb4f00ff3e8484f12afc9ad19cccfc45ae45961942957d725a14e18293d4508d68cd4bf46802a35a9ec8c48b0778a6469da568b2b7f4d096ff0889b88855e5d9b688dd59bfebcf774d819e9a89022a8ed3bed6f9bff4dfa95814e8d71f365aee84d60008b7912f34fe046ee8a32840b26dc2d81cd29fa707db7caa210600b123fd855d97e44debd519c602f84d848c89f290d825ba4899863c938dc6b8fb7ba9a1b2058b6bbf1ee5a660b0a5fdf81aa46a598863003e9613f197b30d9f2a96b5ddb3d80ba3b11558248a3b17c6036d6435fa18d84455744404171c901f962aa55435146bcd9b917f2358633feb8f45e5d5d5ccf8258c95b9aa4ae13b3cbcc796e45c54d1ffcbf1e8127e1d8efae2c27c2eb24e697d0d5bd1020eaf8439e33f767aa9eda6c041587e445fe858c9d2e5f2d901fa2a41ca0b53be5937605e9cb65631dab6565b754445e7499a2a3e7cf90fe7778b7e80f30d0eb4f185a9f31c805792d575587c5c77566c4e05f52242a7586003ea70d2323bd1a967703fd3ebe7aa131214b3deb86bba2515fcda5dae6790df3b273c73fac5bf91baa72af1edbdbc03a596500f571c90c94b5d7ea3a7530034111e1aab58dde60f6ed1d7486639e6fb610f5b28f5485e9a7e8708a5ce7fabca3d93728a8e411f27e19aac52b6c6d781eff52c634867ab76dc6c2f757f41eadf5ec75239da8657f5b454a78cd3637932b3da605d58b313553581a2b1b8f5dfb0be4332625db3feafd78efd5f5cdba2e09c69cb6b9814983d2c15719cc55efc6134eec261a495da4b8406a2b0d1d856c89729f3ee43dced11fe25cd9feef9cb6d0b7a2de49ce4a42376fd8ca79bcc0ea9aa77b1b941ebf0f07d73ed892618fc4482ae78f2cdcb18f3863bc7137b96ea4be3e7d45085806d019ba60de7288a5b1fcda65434c8026fdd66aee18c61a9a1b6a46dfcc177dbefafb949e38b844320271878b46a09d804bd37fe1610f261cabbe2e4231678c24f9b2062a0a9a899dada1e35df51510a2dbdd52a5b0defdc765cf4b1811119d7f21a0a2e887e9e9308e16b0800b30435f6b928a35b10fb1a7ecd88edfbde308eeaea7916f008165b6b0962ad110b076bb9f098936bf6c6f464915649e9b2d04e28182dc1792a178fe6e1a43293dde9bf68834159aa5e97fc70d5965dd5ab10d6dc3670a02e42b9d2a31f19c45d0cc64df931f27e5aefa54839c26c2c71160538d2a025a905c1b1c77a2f76ae75ff239861634620a22f36ebe9f186346ce4ec70a318af39c9e50682c4fe4734b5bfff6c7a7a6e4526b9e3288c082c3ff0a7deb809c7b9174d7694f2559d7ad3570c24d7f0c364c252b2a312de5af50a7769b553df7c5c5f0030595358cb269b24c61ac750c53137afb4ff9f6fc4f10183ae7c8a5cca4b1cbe5f9196b0136b01b45ce94b42ce88d6c717f82d3a92a49756606b67e0b8fbea359520fd23a4a2fe15062373cc318073c7de96f02e3ee5933824058096e8e45e98a6fbc2de23d6529bb2ad23adc46c5909c2cfb57e067bca3ef95a4692f2506a95c16e02fef3f37a0de2c670a6409de8fded0c448ce152b430433340bc6e82e3c9605f02784156abdd304f47ec2566253b8ce32e7992d7991e1ddfe1a0385d6180183c9d789516f82cd2c69dce0cf1936058832442e866668d983295fd5881193e45e5906fec75b50947fd6a15fe9a407638c392b824434532085fd4c5b174c873fa3cc9395d89fb258dc8936822166489013517d9c41e9b8a2bff011baa74c5b118da1c807137590876570c393dde986841ba5b61a5c0c19682959d710ab024de454d313e90d9f320627f82f90c6ad1609f3a0b4af1d574a3c47f5edc78a20e97fca2c98a926554d9ab93e4f2cbe686ef6a9729e7594ffd682978a8642fabc457cc1caf2529dc3b745c18f0946877b72e72ec358ff1b0d758df0c539ba35c75218dc77b88a043106923e2e59acabb1ee02c35806dd93516cb1c67fa807e3ed7f60f598697ec70c4cfc27e133a1c4e68282cf3caef914bbf84e6ec122f972c0300369fe1eb9959670d3f63f329121d2b56425b6ac1d1a240c237b59e616a72752aa862c270b2c9c5c683bb8ad78aec4eeb0dad2806450382e91272fb5ca17b50797d4bf7bc5f86f178884331b625cf6338709aaadc4c70f91b8b8ba4cfb7167366193bc7ee9263a8797fc226af48d217bd4b103a01b137513ee007cd25b51a2c482105c6163675989482ac8657836bf0ebd3993ed1aafc3d94dfda78a2396f66d261e301c15fc710cfa1ce6167ddd3ae2830cad8db2fa2e8307dcd3cd38bb8b9b576e63da097fb54418c60b1e2ade6d2db43e71771316597ff66304ae63da45a690a08ff2c34835b835630f81dda0ce01fba1acd98a45e3ad1706da04c35c365a8e111f57a092bd15e60ed7a6bb3f30f5d4af7c87c5ef4aa75f851c54bf44abe3ad92f2cad479ceefcd5b0820ee52c7fa0c0c4200fb3209d8b0c9c2e28e7b29e9ee0bdd89671594dc418a54fdeed5f590745d435eb10047c6dde8c6eca0768c7e8127d5063017ee63c6f65522bab1b2b3d2d73dfa8ab4a948a38ef96a76a41be72ef3cb277c34d1a2bb46dcd83b7860539d2cee36542c412ea673f9e3311a51f93df257f69754c78251baefc5ea9e62c7ed9aebb47666739b8ffd4944add4d1db8faeec5209da3154e6792df00db34cb81a61474f25e4c1d1bf63d82a6888d6abd62dffc5255a739d9bf36c786d026e7156ad818ba379224cfd9966668be1d53c13a503bbd10a930ad7e23231c75fe5e1a66c38ac2c35f630b40640e7c4980f78dbc6ee6e6c4c1668629293f27359748b90d3585c551126dc78481de448c06ee6dcdf18212ab639bac2225e5ab4450b1ecc01b998964beed59d276841dcc8c31857ef0cbbc5b3600f3804f04e9acad885bdbb3fed57f435630a13d095f7677905cf9184565dab8309e9775384f604e0ec7312f0c741c1e6b76342ad8b986f65b20bac5e08c543b080af98043b826488ed7b713a3e05d0274f45c1540b3704c74a235e14b9fdef5fd51e349354882784ad2cd4e744cf6785853e62c038e69a6317a1e7cee3d43b9aeb2083d4466661df9597fad94f3677110ce0d9139ea5fa049a96d37c9fa9455e17da3529385f6621e8f5ef9a5ded95ca56f873b028e2b1ec3ed82b9dd65e8b4171871b69e774da2e77c181f08038d70a05454e8e6551e6dc37b66db9e07392307588241a4d621b9c7d8d748798b658dbf44e40bffeb10c8a02b142be67cc0337024492729898ff1d4062adb06435fe0021a555badfbbc5beeace9e1fff3766f60ff99ef53adbcfae5bd7640192b418d57e613d61e5ca2ff3c66145c1bd645d29f7412f3fc179132471c03f61104708e4e1f9b2c5745167ac61186fc3b1987fe0a137867dac7498d63896c9bedc0ac95b0be5cf762897bc94ad1f54117b0fae6a988f4cad11e101661f45d4ab0f107c8bb8a65efd7caeeaffc7a2e2c60243901cb2f9d09ebf975d23868cec290c0378d8cd1039f02ebfb10e0c4293b8427e67c616d5f90b6223517546e7ac4522882e5ddeb6675e7503f2c15853fd3e39448e5c532df32d1ab5dbf7aad747866d13f400aee1e08e58c2a9f6c3da60372b5fca104e9860683e4bedf6a531b8044a0b6ea5b856216601bfd9191226e0d3da73c5223bb4f67bb1bec35d56d37a0ddd62fb85d3c85472cbb088070444c09d0a288f94384c846bf5c61c6ae4487b8c5af6f73c7e0c7c24719518f9229d3f472a7f394cb0aca61f58e9f79fe9c9f4027666637312e5f1bfd56ce6068e99b8bc49107707db58b01583fc70807bd69b81ab8cb91c172549d914fd32c6ea1eb7b481ce12d31e62ba84579c566c57031acf9d8fd56b4e2adf481ef9a0d825894a5a7b8abfe3cd802e92ff302aef948f9456a977c378aa66bc7140d8487b0135d7d932a1a6d12f690a9bdb4f423cec6fff1e68a00ab2c7644bfb0e3eaddebe63990e8c258a87cf36b4435281c2147db02835c4577931dcae1f3535d8db9875931bfe839e4edbd4f7c006316239d7681cce2687e91265324d5898a91b6a946d7750a2236a8fa75e3696086c6717b8fdbfc872c2c6478d39304b45739f0aacf4724f7dd6834517717cef0bca9d379136a822502ec4e0178ebcac4bf3d2d44d17fe836f822f5fdb3593d79b569e663ff238ef99c220fadc2d6b11fbdfb9765f367ca9414ec639cb980842b1050981eb5cf8d575ab1fd512a728e076d8a285ce63101f22d49680be059a9c26ea62b81c512b42769f9aec80db5f0561dc6097fad3b6260601393f431b86910b39e005c0208960e7a504b6c0c190f008fa5f7b5006811da1a3d1fdb0d6e7d1fb8b8d19cc76daf9657be4ac35a387fc40fc857592113c13af7d5c5833e7b3fc21045dfdffe4290f4bca23ba3126083f191465dfcddeda9c34931d93aba45bd725027e14b47fdaf8d0d5e12bd4d1614345a24066de56a39e625f97fdfc6f8aff72298bc4c46c38abc6fbb1828ae8b2ea834f0720921b922cb167461b9caf906e2cedc47fdfbdfe6ad4a37320c9f7b2990f0d60bfb4475d5800cd53764295a3cb0213f1fb4b67f194fbea56e623d809a4a710e80e1ca610fb185233804acb75d208f4f5ea7f8120fe79456bd312389b8fba61c146c8f87d49290e9a24247fc918262c40d8feb09d8134746f5034687623c92d34cc9e3af9eff638bd958d00892fc070973c6f6bd4bf66da12b2842a01fb203a6e59ba3af735fe78acb98e09c2f88181e2955ef178a217f9c8a919d5cafb072e82a0a93318566d196bfa43bd1fde116c78a096d1474db9ab67c9d1dc64c24da822b4dfca02c4864ca38d4c132d4ea13f4951b1863ce2cc93c3c7b78e1f8beba41939d5948005e5724aad1c20f3e335c6c33ef89a983ab8f42d6ac559859c32d4b69b416643c8926cf6b19ec45f5c93426a517c7fac0ac93a50ffa2cee9df588314e010b015ff76799162893620403cf0925c4f4b1d3f20589a5b7cc1a700702e63cef14ceca6dc3321b273ab747f5fa1a5ffdf3225a1dc7d8ec3e5a9b976ea1c6715732040cced77b95dc95e2b1efe0631fc8a5217c4e87636f0a690541ee1f0a1b6058f3243a323514c103ced6a531884d77420211d715eca205e7da3243b071508869b7076a8184f2e31ec6d4a4b820f0ef468000691e0d9ca7bad7a1d79a438c9a9f9433be0a72c8d271175fa42352f9ac7a55c65505cdd7469b7d9969b902567a98b52f94c7ab0c6d36460f98d3b92066308e5fe08d732b799abd1badcaffa6a7ea08d6469ef396a8840cd4adfd2b5a3e7932b32e4c6c8e0b3469be0b00ab26ffb98a806f82d0be256ea310164386db1fda537e1a22a64d187c6ce5f18d6ce1c844febf3f00146c370f717239ce623a141677c606de6159f812f014037f33bf609a812c7fc9e695510491b2b74b4b77c14abd888424e4287792605ad6f92ef313720e3b5821b3464316b2ff89284191224f6a051785c253bd43fd1ea2fa6355f7bf68a44413a85af7bfb19d9be6749a7b95cbb6fdfe8453d531a0268465f8f0661c19f1923f5e3093fd2e280e1cdfeb39604b9c4d835af9aa62c73d569b19fc5aae99d543c6c20db9f8888fb170c79d7784c7c939868eb954bbbf569340e2205a43b884ce918a16d9faf8499073513b8bf7fc0c292b9f6085ba8a35902d41efb05ace06709b6b112094866c570aff7722d7b97b49e384bf9c1e18928d4fba822f092bd2cf2bc8e9628362135b440a62fb216d99d0af86a450ca8c105a3d388c48cebb8b543d05bb3501667c283626bf2847b7546ad61144b4ae0971c701a94ee321ac91affc91e3954f9a3629e41334854720c6fd60ecddb09eff968114c192169e9cd654e31911a1088cb1e425e4bfd63e7d728502afc769816872802fa9da47e3f49bd39645428320ae8e37399f433932afa4596bc4ef8e5763f968ad48b28a145df932f2cc39ddb145c0f6240825b238d27f60d233122f0a542d3c49e6b62864eb9f52e066c51e4fd034d0b38259fcd2beb2c576be1f3b9b77c948d86ed761e0c19ec4fa73d0aa4e82d049f8e3f087c61912a53d97b895fc1852548dee38e20820dc9103e91832ce399b86acfb295ddd2c996617b4914427fdf34b32a771edbd968925df1664b3ccd80bca97c83e36b9db32db3fa0e8af83309569d7468b434fa62491a8e847aadee6a2fa584b23fcbba745586d3fb6a09bcd3a88694b47f213dba6a2a19d5f0364e368a7a66503a9cfd5417d4face51e2eb85924b8e1ed78a0cf9cf150234ef03544c8f5cff7e1be5a846ecc7e60121816a95b8de6039f9c3aedd5aee37255b59596c5e2a3f903a4425cfa25c13a6692844156ab218d1bb0cbf11fe443eb37f167e0adb475b76b1bb7f5a711a577edad69777708ae829788208042438ef19d997575909d208bc5644a412da753a5a15db771f118e2db6df27fedc9b920eb2b3e33cb722e6ba1f676a126c82e372670a875b7c259aa23d6dfd1f8dcfa5f10ae559bfcbed74f58e48b975e2cae6c4359ccc75d6e1c7687bbec4345438324be587f2d377e210fc2bf28306c2fc2c9ccde1049290e0b89665d53c5e9b5b5e80a9e7f52268f1e8f5e01e49335d51af3532104e31626649c307ab2d67a7e27d3c5d9124fc741d5ea68f4f00d2e368b210b1d6e8affbece156db9319c21548fc7d6edc6dea9d118b670ce7a41353cac00cf89e54581d1a5b813a9e8c052a1d02a9409d85f1c7572cb7cd41efea67b3abbff7cec8ae2479243218fb5ec59554f91702eb91201e233d72b183f95588225c3e1c5d6e25ea594feb2026599d1cd1d44bc9af1173d89de5b4dd1670f58b3f21ffd01f0ef22bd501e4ef6f7b3d0c8fd4bf834e4ecf4c441fdb93a654c6376ce7890ecca0060f760ab41fde09de761daa95690ed98a7e094fe2b3436ea53853b9a22823f8fa5ad1b878a8012cf2c12ac1d53a64c46f65c23c3b718db2be6ed41516746791b1037e666ab16b89af75fcb8520a92d3626628ddb79fb67f05805ae792f4348b8d9136fc1198790064a47f1a81d07fef3b9a76a3429d4347fcad9133f9337411d566fbee330806609a16c459e47305f02bdcdd4d6ecef82262266df9c0eb00ea13899dcefdbae3caf88227ea0c19e581b119cb5f12683bd7f66a94952cf54d63781adc65388bf0c65f9e0954257834f42b41daf6e9ed5a3cd97d954bd53778faac4a405bc9189aede9f52438db18c8cddeccbcba91f8cf7590d251a27be7f43ec9bf4d1078561edda772d074807b0a171b34a1b7215b9b23960a3e9eb9eecec6e3cd99f4c3cde472a098c55ed94f6ac027966715d6b85a46b49a102309d065526a73ec2af532dca0b0bcfe4a0314d89d7aaa888f686b254f601a3908d9af5101d87989997e81fc43f00457399d48e786191d9489788ab0f9bc727392a42cf6e72cab9bcc47c825e83821ee8569145d175c2cdf6c2f53139ded3b28114af1dfb413d239c7d3ab371d26ab525b1e73f37ab2fb5a461e5b81ebfa6588abd7948ae350290d09bfe1f51a2e9c1c9d74c44b24efa5d92f0c9e279c8c944ce20c1c360295fbd796eed9b83d6ee286fe1064ae46ca214f7d75368aeb592d90c69e2505acddea47f7b214bedf5b40d77db53ffa932da2cd350d5f31fda5634eeb045c9a1c1440eb8687bec8fbad24b66778cab7a29c02143b8f2cb8cac1ff68c764a1135181ec3fd31bce99793248527fe15b53ed2ceac91f6adbbeedd502e9d6c43e399e2bffe507a4fc3e8700eadc9832b783c95c909e3612a7513e645ee797c343ba2c066fe1e293a13c85ca29a34b4c06bfcd14a19ec128500780721f025734ed71d56c300c6c1ca148122090cfeeb32660d62a79ba7b23dbd32852b62f2c9383fc9a1305b57a88272aa65fcbd5693f35717581f8e6bd59c7e4c901ac168352a314f01f6fbb353531b7a5bf25c284fc5760786285c72fa897ce569a04f0ef149ea8c3f1a29a8ce6db3cd55e01ede773088234ec7b852ee7427a0b7f114446a0c7e8534efac3ad641fdccac45bf7feba9abe3a3ae10f3d48f6cdc5db4e74731b81d45624694504268ca2c8799b5c8a2b61dccab17308002ddfd5f5a9288f359c5f455d349d2c34b8bafafcfbbfc4c5df21523056a0b62082e640bd795321ee2194dc0a299be6145c29c644b308f70256a2b02c2f1f9df2787876411a6779cd26342b2fa16439bad9bacdfef13ac97d5b06fe5f810a4a13043059f7d6160173c2c5fe106b535b5a5a32644ff12b97f555fb13e291cd687fa402381d47d2ef3d898357ec7a650b7c1d86298fe725b44f10c7656a9cef486f3a3bec50f45cbf1a96ca17e90c7e88e775d1e35072e286bb8fccc5f038561d77afa95e5702e7f8d367313bf686c78949aa6554c8f1967f7145ef6664af096fa5db8ff008b931d44f5ee39ff67c3c0ac57b98fc1b5cd5fd2f2e4a4dd41639c138ea51e1e691139978783ccead23b309a6b54244ae8cd58be25855c832c3315795f1684359bac785c4b759b1008fc953c927ee2c04ae5520f5683b6b97e934b10a5d6b39fb96867671ef0d733a09e401b90494622e30bf4775bb9903e1554551865b935002d05722a8197368961dbc91b8db88d4c2286889fc2c9dc25087589a4988a3eace0eb82c8aa2323800ac76c14365eeaafd3ec64e9937dea994a2564307c8e8988fe31cb54e360275eb0b6ca3a9a08231eeb8c515f15fba71f4dcd788f675a75527433fcc20efa75c9ad058dabbfbe2604f28c80bb53fce02920ffed3e2202d0ad576f84c2941f37b80e70aa75d38ec77bdbd81d74c6dde39116fde8bc6a581d569bb9ccf52644541185659eec2ac37e29eaecd6154bf50a0c24b5691fc747851a7c796485b5b7510774e94f3d1b833144750731c894fc713c90c4155b2a3d05448deddb0edaeb2daf2d896de61eaf2bc59ac25eefcda036ee0dd48e48c55dbf6429610d3b4308ade9da779c0a3b10f3040cbc6085a63e2280a6d17ba7075f4cd40c5bb9b755ff27acc29bfceeb5d63f4f90ee365613891b0db4db169fbdb55735d66c7ad8363d5a6731ac45bf1c82b256b7aa354a9d0918ad2334bf8e4fcdc60fdbcad1d70a8979c960256b7e2f2c49a9980169cca57fa7d9a74c4eaabc87f0f3df55a459f481c82593b0df1ce491231dc8f3b4f4b9d859cb86125c12a7825de06ea99126b4bf86c21c71d1b0f01592111e1bc513055be7bf6f1a9b0686fe63fe08187492e95e4b386820d460334e930ca3595ae35dafb72109b8891705c39d66ba7cf63850e28de3e3a1d5d60bf39edd43c4aa498655c0e131b549fd8b6d75e36aeca15182ac6029aea72dfad8c206d587625aba3bce04bade23099b37c0a4e165ed3d8860b8d21d6939b42c257dc3ac8227a44c4c34c7b16e797840ba7ece7bc71959902b30465cebe3e4697d7934b77ea8f54155c79e81b996c6b03189385ccc15d3fda7697a24d171e889460c2d6376484bfe6023946d5e47eb6c5390f33e45be82383a95009f74c79d40902017a42c5b922d467a2f91d2fec6255afe13bbfd4c4fbbfcbcf857687da45dfb3c9692ba7f86e66dd140cf682948c48075d6d527cfb1583bf2c05f9c17a6d94c42bf29546965b6efbf3e4dae6cbbeed5387022bff15a90173f4e60012273aa8c6e527c4a7e89eb5c45db576ff1171ca7d5c8c59c7afeebdc1ccf9233ac391c63b37d2c060b2cb50cfd9d61c2c0f44704ad743abdefc23d48d8b35f93922df63093724512ea296f4268b4be8e24d7d18afec7b084ac1400b63e5984c4324110ba3938a59fd2766d068709bf473913ca7ed39b71b9939e247caf480505c2e5bff0a0a2eb7e0af1fdf15664d9fb6b31f0ce46d3622ca85ba89e339ae48074c60589b10e439917463b7a2cad69785b827e11d225ade900b88aaa8750f04fee1c549642aff44444b9a737730fe9a964b6876ee5970a3ae275ed3383e464f30e07bcc2279510855d4531348ce489924274f35fac1fc39a994121a8361578503bf3d3387e5ff972dbfb3e3e9b786658c5994f210b2db7c450fb55aafacde5e92e960a144bd5a11a929247a1c0f92fcf26081bab01e96f4a6eca35bff01de44d8aa7631685df7a5576466f4cdc2ac64b762fb65effd36ee151fbfd8c2b356aeea0abc63f0d4804e02cee6540dd012ea760111a53ae90b63bb4eae4976adb1a82cfb1451e4d4b8b2e67189ccdd6028c1010508e74615576588aa99c97459c9e3da4c25a3c2b796627f44483bfa32032d6ae3adaf21de68534f9e3b9b37aea0ac9b5d933fc6d8c4520f5a143cc826ad74c291cdcca72f7f79865990260de16185f24530b42b0d37a5ecd1b2c1208de4ca73599c94ede4e0cdedbd7abb958d946751d0e256d90f6d28edb6b76dafd08475345df7ea5ba85843925255c00f6b63f15305491cc6fa360a2abe0bd09e0fb307afa11635c7a7d4f110ec0470403c879d50d552b6496fb6b82fc8f56bf96a27a7c2504deda2b0b456e60ffb94f2cccfce103d16a3c9f31553053b8df238f8110f1cc51f60c913e77bb9be57c734f7cbdb1c2185d62b6fa9cd4aa1a628760d09b23e81b6cf495826b18c36a4fdb139c7c24c1da0fb1677c9e4b8250848660720f7f68e3cdf3f71951b6179387a74f69128ecfeacbb349c1db75f40d004259154e4d164240cb9bdda81461aaeb3ed757f962e8ddef52f8a733e96d813180369e5ba965628cfbb2d3090baf66958e63108c702807c1bf1e343b688b04e5b98457fef323e95accdec52cb789aea18a2ab763ba69801db729cf48fe5821d05dcb61010a2ad8767267d35b86b755510d79477e549b9b8a1854756e12a6a28bbe007351cfed54915e91338be6864dc9b81b80b258af9234aae182fa157bf273f21049aaa53664cc261fd3157a50cf9e91968f523ce83e3c3c1cab8c3592ac21f73a9645983a441a4b986c282705f2daa858fa218298ff9413f282450ecfb6d3ca3405b7c99c07082af47a14f082b6e3a96ec2422bf868f50f28724e74b719c49a84662d8b60469c132808888110e47188ad0382c115d13679c00e8d7662bd966c59f0601029a34fcfa98db230805bff1f3325188ed7d86d8a85462d04bf99cb2aa618d9cd5c89942cf5ebbb4f5dd4c2f29a566bcb7b96a8872fd28f9d63992c5b43d6977cb06d6bc3b1db680e48e88c9bc7e1a7023e90e69e66915c4de5d85b3db5e9bfb37dae59d8f3a09b7d18d6b93b5f6dc7c41bd461ec41a4d859cc43163ea9112d25691d51865a147230302ad5de21b4f61deab06cabad204d6e59a8bf0ab9ac8fabaec8cf8999e3aa3351982f8e4539793d58ab642f152f03803ddb21966514405717324a618d4c9ce5b42f4e9e2a41262a661dd5af2a740382b93cd38384844279af0620d27712875a10d0962c4567123874c3232784e53e8fb0790583c680e37c8ea0429a675a38a3ab2d9d665e06fddb89604888aaf8b6e06d02971286325731c3504f66c1e5b5d1e87760bc03b92022cfd597eb2725370cd381d4e2b8647d4576375b94556e4fb33254961a27df1c53b3b44f64c12db91d60bc2d2cabeade18e9070460bfe8d795bd7665caf7771947c139778d54dca584ecf21c2b57c6fee3a1edfd3ddf556e232bff97343e9b6385f1d5a65660b83459f46ccb3578811d99637226a6f4d2ae64ec4878aa584840a7853092d7a88894c651bb2d4d4e099c7d844e7e6a35e6d84b0476455c7799ca0f53ab5d5def97e541c2001220674a8ea12f39151ca38f9b2b3f099916b0759d2ffc317542296aa93a66d5830d8fd2a89b387a12b728ed0ae56cadd8ff37853ee44ad4ed6fba0d24dab2ee37ee87b75556bae88dfc2256d13c0980522a954abd638d157482fb24c99a9b67f9a7622426a8cc6a5d3c2ee3ffd9ac38da23e64a868c7189cd5b2d3967c8a0c7352641778f89f210a88f9e47908df9f79bcc97da108a32acbf5100ee7b989bb94758d8075b33a33429c343feeeae9cefebb78a371d3285a027ea7b91e41ba13c9da0278d0f6da6a9e7bdecd5e1c02b6a42f0e32519c9faa1f2dc7d77137b3b95aac21dd4141da8fe75c781592790c39614d825114630acd1bb9dc13cbf55a4b2f56f323a7c6b8cd31b275bac1990198169f9e4bb14d15067e9065034d6e2d6efa27e735ad4bc4268795ad18d13c90801204d3c17d194411e0aca83d7a76fa78be0f648cfc43b3c512403b9ef9f4f044885d0f7611b6cf09e8091fe6b505d38c70b2d9836a77fd5f1e72e78832521501c5d76a43f481b81544be6700a1387418c95c3ee2e590dab8d14e2e4dbb1dd9c1c1f86d3f152d1ca7d49fe047a49a81bc5ca09123cd56ab7a95bf1fb795e174dfb88706a80c0f33c1bc9d322b127387e6524bd1804bdcb25a5a9de8f9c1f34ff1d02ab1f4939e5e13c1e898db0c726524e535c888ca394c3d0bbd6bb62e531b4724d8d6a7bb4dfe3c211583a444a4f8422f7dccfdd2cd74af8d5a2b190aaa9b1e6ff7162db51e3a8dac735f1f0af8327c4869d33b0e66326bf04d729698c88f8e55c79ac47d680b25f7f5d1371d547f376373e3f4e132bf471d015a66bb30cc173b7d42872737518a57e18044541708949155ac34c47d6534cba35cfa000e807b98753abd556de5d11059a508aa691a10587d515b0abdf598583558eb73a497d874dfac07f10b527e38aa6109772d1f27de7abae6b9ce3942d8bb024170a28e88da64e35bb7576b73b4684e04090309185933fdac403f7ad28158bac7b2fff970c09ce906c6460a728d2abe69548272046504c0db35d3225603b276cd2c35e70bc51c509cab98e7c314594d7621040cec76a73b4560424479440a37bda2ff2b10386378b68defcb243cb1ec2a5ecc64bac2e4a57a8dc24bc73b6d33611618ad6c57e8ebc08c6ceb4b763b4d46b9a569e8ee68de0eb61612133efc1df58fe15991a05d7a21d110e33d06c0189b2aa1eed1140cb799236f63af4734bf622aedc0b1cf688e17b134872c5bc75480397accdaafa44324a6e2614688fc344a3f56cf290e2e4882939135ef93db7c2e5dc530dfbbce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
