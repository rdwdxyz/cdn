<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d59553165eaed05b68938aedc5f6bec5f47efedf5f77e56828323e88427a17188f49d63e50f731bb533d63866e6f03d71f71841a943ca62f19c314c03c44438131c767c4517cff676495151878d078ffacda957c7034ea48eca94ba345e6179240a57d454b174d35ea0a23b54a5dc6feea6921290c34d1c6ac4a2e818229cadc03d0333ab52ebbc6b5904da63408dc911caa34905148e35492df47be09a7817467758450fd703d4629021c494017a57b848eefd8af928831cb090af0e9750cb6823167f35d7ba91dfe30b1461b940b31af38367b335cee1d49cd6c0635a47cafc55342267d94c7b527e8ac7a8a11fa69399f3a19c4283807d55652852e48ff0b64670e66473d0b4d46f401bc3466b25bfa2b8437e9ff17e2e5605cd4c1785e34be6c70c3b1ad10ca210dd5a168cfcf671c9e97a631d4875700405f6a6bd2fda2ed641e8d4af342e12bd68c1bc4ccd8255a9d5dba4ea4f4c8bcca5da8cbd8314f809f813f97ffdc12e647cecd81abbc9d0178c8264ea2d33c3a1dae0c580f991c00fc8770fade44b9895ed78ebd4bd3e0469c1a2a312959befc1e9e574400b28037adb61f4d2626d650a73eae66af38aacc0b48a14d8a54af235e69d4b71aecd8b885ba6c6d9a7d50fc0d834d0dc411f57f3a6090b8e01cc81d321a563494e35bb31165267a6bc5f8e3b24cc0b99cae8c95bb937f029e1716c7ff57bab917f0f244a5f8813692a3ba744f44a78f5770b13c8b612fcc3f1caae228a6c22601dd7dff2b7fc67491856457f14fbc50edf29e8d49d2096419145a564b3c92478affd1583d7f93b3737d8b36c6264c6d9dd61f24a030ca381e59db99832ed5b73466cda861b38db060206b9d2b55bc7dfc1377d6a4be51a9203dbfd748e6e41723c0c29df725e839a5e673e56cccfb3cb6a80e15af5339e0fd511dd01940b357caf980d8bc7ddeefc0b6c1ac5d3317073d165342ae300d2ae28a45754d9236ec8d8ead7a2d217f4cc596d7cfa9606a8614c8acfdb7db40b888d918e99abaeac23dc0bf2780c1f308e3972786c2d9117529f11e3e850c345ccc7bf0c4f770ccfd308556f6fdba6104c3e37491fcccf6cd229f6c0accb480de3b47e75485e929f076d9a0e19ba8e2a29f0d38b417e4a62c7124c6191995c6b79f779cf4edfc2a8e2d4a85c5135d159bbb52f25e073e63b660668cd129a725aa9b9ce7eb5f5afb4227bcdab03084a1d740c0245a731be890b32e78e70b01b10d8293f2fd89f238ad5eef1f6822dbede6a467738b89888dab21ab0f25cd4bd06ed8ad8a50dc37c30eea8d7f00d0dc14d1dc0ed7e55a676868c0fb15246603b23c1eaad8dedad277a5638cf477896d020604d884772451e23e5bf5afe8d69c886e6b3d0dafd52f8679d65790ac0773f83dfc5ef410a6eba70c84501941ce38d32f68bafbc875ce5e53b483e03388307b81c8ebe3541c06bc2d5ae20fa9263b1573a4506ac452a27cf643e9cf3515654041bb069b6cab7a2a179a073f18de8a3a07825cde1ff8efd7daf76f1d623ea5d305155861c0854ccd110c604294cdd084f90155241c5c6f8c54cdcdde2a78277d8d5bd6f6eaecac97d75d42154f978c743958106181a0608dbd75b2b8dc7d45e14ed6759174729d39f0e188b8d48de2dd7cd0c70be1986daa65fd3bb4dabb4284e23c163d3ba5e5c40094d9fa4ba6790419e7677c3345dd704cce65fc7e0a0314c137223fd3f539bc2ac80c88e81c91febcb587d9f6add87863564310b8e7c2bb7f3881efe0fabff01e2c3b6314997c4382473a430ca2b3bb113f4523fa9706418a5e2359cab0e6c272c74d84ec2d1d6cbc75caec6ca5a154a865ae4b2cb0bd48173b93af7da5cdfdc8a830fbbd4408f7c026855534f508a0aeb4cdee30f29daf23f82f2d89b76f43af5c86585b7b92c275149623bd84190b9a84ac4b3ab4d6d048879fff0e0f4a14a9102e7ec901a1de09bc54439a23ddec5a91cb6500b87739d4f24a3d8f9ccfa0b8ce3adef0406819f93ed93897fa85b39b2ca96710cac4ef5d7d00e7cedf62f25832dba6ae46df6f61b74d54b2ea9b17b30cce8b9c09d75855d95382bc179fa78fc3c282734bed2feae02fab738b8585a7bdc8417284ae536e0fe171330e2c098cade6e0678980acc54922ad57a4063a7cfc1df69cfe4628585c050a90802c5a9b41ef137e7c27dc8beb8dafcf54a6a46c8fa902827e5660ca6d10dc6d30ea8341451327213e76661132f5f98ec1ffaf8e5d3f51621c87e97d3cffb66c0347d62405fdd6ac37fc290fed5e293a9deb46a4f19fe91fcf8dee131987c8fc8d81d62c573fe4054b208ded7cc0d184f8b876fde5a6b5144b0255f32ccf5756dd4adeb1400cb81decce2fec0b3f2b94cbe389b580bb7073428327c26847f9ab8998763690c53da35745dafe90c43fefca1665b87de41d4a7b2f15d96aa6eac21543689e3d0816aaf3e5d855b6d80a32c6acf888df8fa04c0a5ee789a02757092a16c2d5a3e092a52d20aa554a160b86f56c86d12c9a2f06571f4359317a0289014e6c9348ae9af47e9b775ff980d96db538b66885a9b4959d7e026fa49122c4fde8fdd2f3c1b108201d289a245be5a53568c40f9cd32c495334932b85dc0750bc902aadaf2a2e70771420c7d0940671b85106334bc01e9d1be0c2ee39dc06b7901deb59370fc0fcacc7cce5aa6746ac164b7d01a65984f5087812169991762084970307da76b6fd41b31f0edbc0157ccffa8aaa3f092dc708c9d4d0a27e1ed3d7f626b789adec56fad06cd2bba8d49e4be5b16d84f6e14d5cad7ea47293a314cba46213b6be13b745ba2d48811c8c7172911cf24405ef3e44823fedac3e2ef68589805449b6622f56d306a6d23e1319bc5fca7e0afeb006a3f99879657ecc08e5f113d30c4b733058f846f9667ccd1c633c4d24c946ec60fbb0ad1ba863c3b5b06d16e005675f2d0a0c3b5d4cb643d7697b0cb20fcf2b16fcf7d025e821ac03176a94492ad03a8b353aee8f5880dcf805c6dfedaa330b9ceefb6e727535fd624d7f483f638519136d9106dd55266c4e050fc317ed1f18f788eed736a677f8f42373aab4b218b8301e41ee2218a800e2596ec46a46a1d8b649a457ec7a37034e63e2b5a957711d1db99f18dc8a9e3ba5948d560e813cef7e0454077a6bfe16b234579a18ca96581c5a62cc8070351c0a547b5fab1f0fcc43f3a6f0080ef061dfdcd20609a583d7c50d2f8fc43a73ba0654f51e520cc92947b547ea05b21d8c02b1ca1e1042b6e2766e134dc21aabad3ea95a12a73a7e557f3dbaebbd777e007b0de049d3a8b15cfc4358ffdeb8b57d7748a6d6600929c85090b914ca1077a2ea750de35be239ee157a3745b52fd8a159812abdaf7fa3c46fb90aaa2a5caa4a118928cb1421390bae313c42762b2e529299fd547feaff9ae6d557328d6da4839ff9922a594022ff4d1bba3928488171f606a218d5b579226a102c6be6cf6bc9fb133be54993fa20fca4c05914a31690380e9bf4e8b9a0ac0bd0e4822ebbd5b8ea2f57d186f332b916a9b49fe034310a7de74acfb5f3f09b4cc133c27639e68c1098952bc5a916eb30cc6f3780852c24281d05d81bae137eaca93aeb010f71389375d3c841a03c0034e73f8d1a9d8e4647f6ae431df9edb4652696820a1839c552c6f607f75cc526700806962098cbef21547a304be32c07eb80b800ebbbf04a31a871a9c04f6379d1af2d1d8e080fa116b3fb4be838c4fb3dfcf04f038a3599e31ad4169016bb1a8052439b58d203c355c509498fba8b83afb4d994d7668ed94d2e013a40d1cf6cfb5a290f4e17f08bf417605edf979103dd734a24dbaf501ce7f9ebeca67871b8e597d979fbd31c9e1f4bebf17d6d5412761e15a4a4abfa98e552138ab0d91058f8a6a023f410a01fb6ebf06156218c2fe9ddafe8976de2cb3defa0e5860031d5662ff22af42989d9b7a49ee4f3298568165d1ca42d562e28f12f5d15a87edf74611365d9a15b641e837980a0f824b58326c24c9d7df89608d6184b71e344613eedc2d8741bbb84e5400caaf653f0b8a00a461f9ffd78a4fef550aa6ade0a257cce6a8661e98cf7b2c2ecf54b83bda656037987fd91a748caca42814eca6cea86514993818d97d54f370d576f794630d91ceeaf898541d2b229038be14eff18cbdc652f3bc70e0361af1a1ebba5049348cec18d4db6bc3b4ba1088e21ae41cad721bf7ccfa4953a22627a5ec7f8c21bcfd5e1fcc1e80670c1b4582043b83d961c043bad98a14c4af3d6af9d0bc3008edd269001a62bc3ae209ead6fba1b46b9fea73c8addf135ec5f6e16a59b90fdb3c67202161841251673c6835f7da0ebe682c40b55b51b90b876ecf17de3bd0ada95e813d4c699ccd6862e61d83bc8782efc540162dd62996b9980971e67cfb1f1ce9feb3d6fca1db150b669a4ee5a81730b1d529b69f7bc819695574dc9b9c9407d9cef4aedfce1a0378523d6fa13bfb5670296e7433aff090f217abd24be42b1df43f4423cd28d1f4a16efb81cf3f96573c751a82bd58ecadbcce06e2e1e447f39c7e3564a8f3c36148c762051f9b379b08f1ee29dbf963fd3c9ad4762d90d381e185e0e921e9c2790da5cd933866383cc859a671bfb853d5f278042db84d1ac28fd7e9734fbb7bb13c4130f5e3f018b2b3e6fbd6a42560fc05cabf3b4a2aa198c27c9f0721ee1276e1de795c55bb149093b8fad3915f3da0ef97b9e98a72fe6295db4e30695ccf2ebd12eb7b32c8da63b8022bc2993c9fe736669ee93fa8ea3f0f54cb38ff0350414ccc4c302b416036b089e0752dd315b67f5916d643bb1b9951e02fd3a2fd1e1b3d513a85574d656c9ce4b71a0c2ad1e6beaf57994c49a316bbd5b64516702d224e0e73462522f0dbee5dfa211ca5fa92b922797053185768c6179118235456b9838e2c05cb921e004274fb5740287019db1eaa801f0b77138a90ace74fea159589e4e1a245fb8d86ab985440622c47808fe5b3a9a932f27472c88f55f38c2dd9bb7dd74c485e0774df3581495d75818d5dcb2058959918e23ccf6c23603ad7f6274b99bbf92e3a3045cc1c8ab7f0efaf10b1536f87ddbad012f5d2f9f06de893b7e2061b15112a74aed34e48c5f068b61421d9afa2ce27a2a03f569e6ce255099ce6108765c12258e86262a3ab9c14b3d54d6248e3c6a11b9a846db4e29e2b510aa2309418917ce6f6b3f2defde1b772f495078a646d809e3e23adb5616e9f0dda0034061c8af4e7ebf9e078f61cbe4c5755bfd9bc9529fa44f1e074fee08f0e346596a62bdc9497daf2f88cb5aa1d216aad1aeb25f0311daf56d149fda987707e96cdb74ebf54ca89b463439239c77167d9a7d4fb669bd314ab17e7b12a7b5b384a4dbd3de0c7be1db9eb022d7498f7c8fdea537f88ab20e4bc26569e98dc7b85b944cc76eae5da7dd86d7e7ce73a2961e94c4721332d31625ca7f1afb8ab99d33eba4d890ba5707ba03f4a71663d0b3686d295b1b6d7bb7fa23fd7e68a88d1207ee8f5e7c764934028ac59948bb6312518b6e3554e30114a5dcebc98783b4f39fa4956f34ccb4bb1f6da7965512334da05b30fcc8c6b091503b8d2c939bc55596cb822be428a492ecf592b2fcc2924de1823c2f614fba2c7da1782bc8e4c9c4a3bb85b1cb555cbe8bc32948cc8d4dcb1f0024ab1323923d4ebbdd001f33c568a3cb3b2d8cf138bce774a0b05a8b83c2df7f12b492380a67318e5cbe3a0a35fa11d2e526ec35afb4584b3dc768fcfe23f3324b2ef351b082f7b9830ab36481ebb868d114f54de46cb0b265adf70bafb3c977003ef7efdd5d40a25177c684c790bdd1713516391d92456329d4a8d79c5e721d6742aa983105051e998d85ef6ae0a6bdbfc79db7a0bf5b9fafd8a47430d078a85cd14d562069188091d1b9f4d538253c5b83839fe7df11a20852eb6f85a7cb6e8e3e48d198b4ce2bc6fc575e5abb09438c3164974fc939e617d332d21b8334d6fa9ab6dc27b77eed16b57b9fdfe19de3c3552c5ed51d5be7eea657d6e46c84fcd152e6984224e5d9db55f71aa844368c69b67eb77e40cdb32700566066afb7937b0c20b9e052c7b36fdd701e70fc741215b64a944730e83c76a3315e2b907bbabc1f2b6158b459f453cb25cca5d9cb5bc864dcb9f966749c79b664656dc02a3918d5342f5b99d11117f869b26f3af60c3437b482e7c4b0745da116e5301b16fdd0c4151b74388fe1893355c015d09b2eaf56933fd39e035cb0445bde79390f5c8552674270c809c723f88dd45fb9f38ac491bf8e246866671cee615552a8681a724ea4398c969de85eae3bffd3b1a323ec502bdb832a97db04b6722b4ed352738ce604531859e4403f884e6e05fd3928cb820a2edba065f08f2b06a41f175c8400615c3021867e717b75d58fcdcd89df4f1ec82e80ceb15d9e3366fff2af05a464bb9b600c142c1a357e30f6937c94df194a3b2bb08036d1eb19121a1b94b26108fd805bb3d203724b744f8b685ee97e26a1e0fbd0fc1aeb2e1d06812c91771464985832650fa6619d8197b6b5c81e8e6e2f8bef23bd1d18c387229518f54c6b40479759c918b11b409dcbb6059582a9fecc9286b36d4907f8988afaa7325cd929236f3a71e016cab5ea3136042df0e5ee8d45bf316657a9dc7add8710483ecff1bce816248f953ae4fc24be1ec4e72735d8d429af25203983cc36b869c5806bd62106c0fa18d955f075f8620dcaa1cd241459e6577af3cdc81e749d9fba73433b1103a1edc8daae651ac19f34aad72b5740906e26097e534e7ba88074b53a139ed14b33fc664967d03ef221169efc60216cd7b90fb9662aff7756ee65976c014299f4528c1faf8ae00d480a758eafed369acb247f6c56433086a46903e12fdaec115c0ff6fc043be1a724c68d8c8cefefbbce0334e6afce9f3a28955f84e8149bb1c49300e99c0564ecbc54ef3d118c306585fcc3a56a88eb0c447ddf2f04445fd4743c3293eb1625fd055c9a284d8ebf4d039d53a96c8857f47dcec26302cf14de08a9bc2a12683450da048096eef01ca7750a4a2102b3cc56d3fc32a0b69e2b7aa6bdba4d9478cba6423c69dec0c0c042ed6d83cf1746de565aa503a9ec2976c14116e70f07cbe9c1ec3b92219359734576ca15be2fd59f8071e318df0eb90c067a717b66321158ea4405a2f3032bdec2eadd8147eda326b1eae0743b4c1969f84b1e259fbc7cccf961e704694d31d421d1d763402fb3363dcebbb08e046feff5939cecdf60c313742ca9b8c8c0cda0d2dd1650edac200ec6ea08b62f25ab504ed7dd9f06af75be20f5a969dba4bb281081b3a96f3efde90264df72967a3af6d95c6780272d62e3bb4637f5060ffa44ca3d6be35e2b77de39dfb22332901b66c2a0fb18a02fcbc8ffd0fbe043c2b15bfafdaad0fd34a885c8220a1f695c2e4a53efc322222fd25670d60323c127e1b9ef566f010a646918d7b236a53d175bd458749b24999938a70e8a3a58e2b350482f593a44ee4b519701f6651a72da6bdbc4cd971339d22e87acc38c42318be38a59b873c8df1fe370b49a90ffce87f46daf139d2c2a37a2cf4aaf14c4a98b8aa7cf13dbdc098ddcfca4f053f1f228d00f068b1e4a7158a95d4df5e42bad19def44828c6ad5e1f6abbd2eae4e32cc021684a92993308159688fb5496d446c9948a6a506c1ae38714b496e5a97b162f78157ff933ed857c241dc6c475f0301adaeb24aa69515a2d7ed2501af56cf0ccaf3df178b47b76a7317588f2e4982cbf2e7a29aad9a7cec3b7082330d66749ff8041626bd411e2433aeb6dcae8ec5579fbaaae13d18d6ff16e359217c03f3308e33e36a025dcfb46bb21314086cdbe05aedbc31423d60a0df9b3c9f15e8b4a3800307028f8de53ffe2a5113888592641f0dd8aa0946294a2b05ddb718c37bf98d7931b90aecf7766ffc80eb49fba785a61b6f29c3c67a1d77d96626d261a8ee392971b503f28cd5413f659d366e0680bf351c51ec294ead2a2366ae74803dd2c84098ef45a0637e7e2f4e348a54697e6ebc26ef7ac414939b408136cb030f6f74ab5837b72caa79bae03c618ce5009ceccf03ed78806f02a0dde5da9c924e8acb08d519f6abb4ebfb115e8989011c489e2c2337036e995ef0d3f98c706c9f56ee81eeca82aae2fb01ffc468a454960be7143ec19075d94f75d744cd2578fe7681bb0e02f32d4786885e3b7fb6a38efa90673093873fdbb4291e71303fb8c63f0c78b77b7bb2f51d389a033c384845509e6cad355b4b3457282daff714d04bd2c343daa2c2982523e9ac4769b78ed9ab938a47693b0cbf37b3803c8c74cee0df377169c87f2d20cb222bde55700f795afe80f2c48a36e2ce080259a0a2834d606e901ad415a6ff18de06f2a2a3dd12a3f7c50fce27802a1cd382e26ce2d9fb9c226f2dbcf27ec423637e77734bf9948f9966b9ff224e635e0a25b544eb9641b77e2cd0a889dec335b500dfcef6fc7abe7647c2b845c26148213a8f17038f2ef55d5594f207be7c677bb16ade5ddd2fa54d5e18006e448039e9ca09ea9702995460116f31df168ce47c689844fc66421af0b8bbd97e3827f0a1d5a7b5b39c76de277884d302bc91addf6c955c193c3559a6fdfa3e35b3ae35995514a488acef0cb12eacb21730237dec728a5d8a1286f1e428b06e4de55135775aa0bc22f3ea01c33f45d1bb8a62389ef03a84d560383d7581054ca19378053784a5fbf935b3f8bace85e62a02ba16955b038e8b0103760212afd81dbba59db6720ca84e49214f420c820be9dac072dd4718c2935fce71c08e6ddc224df323cd2145c1512d6b0127740c08c3ff18539cdacca1d81f2273276ed00d0b7cbab04ee2951378a2342c38eb36ff13622bb63ff11b6ae128360daa5a360f631cdd5a52e66b75213b1e9e494e5b1ebf47644ad23832c5672d31a396ccaed543c0041ee7e5741a8f1cfab0741f0f38f98b24da4a34db32c7f3a74caac7845a99ae58d91b40640459d3d1aa83dbb0e5979c39b5b4a8426167cebd0d4c7580ddc9493a0eb5bb3def828285e4bd21dd25d801cab2c74def033afed878932b7b96c08100c19a0dab5202b36a8d59f9362c5a344326508e7a4475d5c368654d830f5a3dc7d5753bd3f6653e458810384050bac493d768147e3cf5d623ea4794cdf71a189417ddb8d042e2e00006a724eebada991a66b54b622487f8c1c79d8a176ffe2545ee6518f3aa958967c0a8717571d22bf365c8f25bc4f8c0a25134330143de8cfa76089132b4a36d44be4916fd2fad79714e8abc0ce3a5eaa8381d986c5fcd732991303a4e03a582b7815bd112d50ef08c4e5212f30d9be8570c79a73f912ca04c57e8096c6cd4c485e14cdaa81146b3ea82713b6fbec95998d4128c77042fce5adf7a45ac349f71620ec8fcdd1e9dd757f4cc45e9c6fa0e8018377a8f4dc7c1afda891a104324a2604d696d390cd67847ba6eadc52de096d36a214fa2e5c8182fbe1fb6a046f5ec1f122d75eb0206fca0a90231a13eb09a74955e38af8c6485667c2b8b934a9fcb7fea7e570e84a8b2aafbaffe87d8e65c9f5fe18324439622c284f508fc16bfdd123b08f3e3aaf0dcc6a5ccf892752c3d5d8d9c885dc4ff2c03fc2d463b823144af5a702aae7109547e4c4c34bfbbf3ae00f0cd32547a0ba2aac27445cafa0552ec58506dcfff8de044fbd26186924db0312c12969747f831d6e8cfe17f0918aa6bd5553cab0e11f78e4cb404a3ad5faefc095bcaddfa264f0feca674aca0ab915040a5943ac2a3716bd945fdb07ceb2a1daae83e5093882d9e6f1abd8ee113ce5d4e85416b96886f9caf8d7aac10b398b81f3f6292864d910b6da8ed2dcd098ddb54cdb53ae600da50698f5378fb0fd4bff11f84ae757164ec357b9810bc30805a2d6dbe493447df7ab40323d0ebeba6bcd133874e91b5696907e26e11e43e28a4c1f22fa0ab3243ee168b755d0838d232b1828f53cb830cfab2a89de5de7e883460cf439f31ce77272f32a8d14c387be05cf1bfdc2ab82d22355deb8a61324a4c50a64488477aedd9a29656b9a4e33ed2dc31e232c909451bdb3841bdc2b95159048306298793648076f811ad8ce6cd4bebc261eb4302003e5bddf4552f62a6850ad0ae0952cfcbd92ee14e8f437792fece3ccda455060a75e2fb01b262f649ddac941698841e55e0abaa252a2e68f0c8b25a41f586f075c88fa1c0ca095fc80ba016ffbac1c0c6ff6e4d06555403951e8519e76de4320561b0cbe18355ff3b6429e15ee7412e334da58af5500af96052499ff9c2489168771e79f9e49308076a3128605bd07443caaac19c2377ca16fc60e9f29be8764910a2a1c0502ee69d57658249186f40dbe79a45ca0ef868c97f4526ba81098b822d129e3039ab3fe22780934a844dc55c0e171578ac9542d5255bccc4e7293db948fb1449282ceb7ea6f0cef2670cd064623547b9c1303ec08201d40bb53394acd307985269255c868ab2ebf31058c1dcc9d01f302765a17865b4104315483b2ac0bb3c6367859349722e3fcd3a2d4e3a07c5e82d0e43b012645a8129368972cd70c4daa4c7220525214138920b19ba2a13d902693efe72f9a4c3fab47eced6c4f9d7e85b79ea3a23aff466cb7d7e04b2c8a4e7663dd094de766777542ab94a79d06a8fe4b699fb92411cc27a8c29118da4039c7734c89db80ca8ce59121b6611e3ad8f9172ec8be2c4b5568810045eeade36b203d84b693b84b0ceea003e739f6bba5402cf54e38b1e0a9ecea561e137be6325007ece3c93080b6f1ca6487259a08d79acb585d5eaa3d27165fe278cd51fdf56cee31e41412b0323cba9fa9928e3bfa6efd228704e82ae002277603d4c04df8a46980a0c1e3086029dac38a057387274bd56b304e6c2a263758f16a228719d40b44740931d72e741516172b578208fa2567f50ec62b81b518d9ecb3ca0574ddebecceaecdb90595d9b2b1fe43a7f2917de7cac189868e9dcc04b329af6b4713259b8d1e9a9cb19fa929567c45e45a1c50dceb8ba6e00eb1bf8e790a8b4bb51277efaba272f81930d46f4422211b3cef586668b04318aa257c30153b451253e48fd46921582d27a763bfdf7b547af735eb4359fb5b8b08849d6e3f6736cc0abc36b021ffd2620a9c1bb1763c2a813a4b954960d502fbec7333300dbf8ec1e4f56371fbb3fad09d887f2e1cd52c95539a0b4a974f0f74b724f4eee4c25f31ae08ec629f169763c88c7819eb69bd15159c820088d343930cd9e172dbe4ec60bd448df9f72403c5236836ab1837cfd01fc7584ee0cf92231213bf539871718f02e99400cb22753b9fc2328b045ed1d419979aa7536e4ea514583a6125c28aeb35497a3a427572ca40aa8432a1ba6b63ccb3eea3dd36a9da122b8f717aa876ddbc316d0d75e5df01dac21afda28d28c7fd3356dbc78589bcb618d3c26388bc38f9ee40ab57cd2e8ad48aff375a116832d435036865bc0213bcf51fc912f4e98348891d3a444a75c7baa66625528e0fea188839af493446ae8b4cf8631ab7f76506632dd1647cabe63b186452ed0beaf62f710dbb2174fad4132a50fdc121b456da75b2e0173350a8b0061f982463fcb5b8b2784c625870c32be24beadf9ecdedd5dfbb8536d4ddd9d3fb821c788bc4bc94c9c0e1d48aa8b8112e48b28800f46ce701cc0553f4596aa038b6cb892ffb366f63c22c57af0fbd8fd47cb9ff1e1c23b6e18164cdc96f0b00468c5b4ef08b79f69875b58c3566037f1f69f94bb04f30b8d27322ec2632e29b18625f2573792c8a503ec0d4eacc7f3a6bb7f4e623b0ac23a1099ba82c400b8cb3b2445697dbff35c4bf1527972ca75e0f76d9b6e84b919dce945ae7c061a63734e211018186e5d6acd7c1d516312ee59810cfddee47c9d46448c03238446d3ab9e7e1885b4b83173843664efb107ce90420256d962c2707a242934c464c99ca4afcd2556505691df30b15b1704a8b0092133e23e9682e4541961af587554f35d08f13e3134254e56be4195c95d13131ca2f50e98b7803aab3b135e15a1af2bbcbc57b5d0cbd9d4e72923b2cad7eb655ab1908b9a9195872925fbef00749ac27824fcecd2db7435f11b39cfab62b520a787da2cb4e478558a6fa3d034d50d83cdcb6a4f984ed88b398c9e62f51f7384880c8510b564de2657c9d1c363d48800d06092344e70677a38a02d90a3d7d21fb5cd2f7021d6a09f391e5e09db4fcc370b517b6e60be3d8c4253d1d6af6bb17e08cc2ddb9dc7c9f13db590a659c3f17d10e0c14a977d072dda6d9ab8571905fab7d2d2c0cad775fb32d7b563d985627f2bf6539b8ad8f0e454fbd24e6b1e9a8430bcf1bfb973276225daac5e39ddca2de4a28bac28afd516b3fceab67cd01b4cfdd902a0f927daa996d3ef9b1c47075e692708b23bf90dcf7f30d1ece18d75e730546a3a18a42e07bc02413a3bab1e4cfc159dd67a8bee383092e320428adfd5980a655d02ef9c992e25bdf453c2c5673bd6278fc6475ab2f4da4b558ff5c70033609a6ce7cc636ea0844e0016819f6decda7054b7a476d65732508c6673d4b10557b0328c8f0ea597f8df60e1fde8d1e9a20863bd50c7d09236d978fd95abf157ae11f3628220cbe59c777e0ea4f626b9e4175ba7ab5ce61a89914a09ac553808272e4a0f2c9bf0511fb32a78be66cc147a3e851b2197d7c3636b0381023a8c3ac197e8baa371a900bc03ff548c581fc03bab22f20a9028ede4295324397f9337b8cdb3d32462abc36710f86b1d55691dc0ab711ef2f4ee77e4909d0dac0a6cfd902e92d4a7740f8418aa996def6d766ad1253b9112dca7a42a14e5dbfeeac96ad278ff563b440c5e0cd2c97198965a43f66a2097852beff0664431ee2999f6f00f29b7918775186c9c99e49c45b9cfc13706993a9fd0352586f6cfaba6d221bad89571cd80ced8226df28177596a738302d779f2ce13cbbad7cf7b6890a307d0e0d7a15e0566954f619149dc01727e2c64df1f7c4ad3a07cb2f172ff1229d15194a14718dfc636fa7f64e4aaa717329af4a74235ca867ca5990a2d61d9e50f4d303217bc3a13a77c4e285db253dc69ebb1b553cff10e24e5c1131301312cd422251b275398a5256ebb34cdd3f3fcde18af4f0ae35d84ffcbb5a1bdc5c1efd57af05d7b3ed689b2cb1953c84b0b9255bafc1790b3302fa9eb8ac535a68b47b205fc60f05377c1b5c88ef99202c40097ec97e9e38626366ea976b26615fc07422ea412b69e8b6d3b4818ec56d49e3e7a5751e925864c57123d2e82d2a5bbbf81375773e7aedbe9c964239317705a725db7719136e778801e35b46ef74985752a20fddd42c9b7a03ed164e41c9c9b236a0a5fc4bc20630b58f5f2b3610e99bbfcc7712466d8729b09c1050cc36608b3194feaae4f3019a0453290977cdce223e4ef216493c73fc16c77de27865e8f8ee77abbcfa15f78eb0399d14751d252395ebe793c7e8f70273ec097265062bdbdd489ebc50a41725acd41251c7f119d7f337f45943dc110e80c8c097a04100c7440e012bb13157df6fcdd4ccc849d30519dd92b212a0ef746af824a4497b68c5a131e77b69d8a73989a2faffeac173eb80771ad36e6bae777e1c8de144f97b782d4379b0922cb6fc7125a0341ac781cdd08c39ce979080f6164d5cf70151eacbd0e92d990e57af9e9a50ba69c301897a422d21b360e03abfc7542a79833b50df1e680d49c202ebbd4e779513122b24f0f4d5a0bb62e9988582e3ea7f3cb5de75c88604b3d43c20e81518778849ecfe3ac6e5f52b68d60e9fc20a9c88da642d4862ec5a716f23d25d080589b8b5f658ac3b0f58212ad3d70a15d6fd9b5448d565378f5f75b75c333d8432cad3ce6299bdda8b307269d4d7e9e892bbea37da248ef98de070b41fe58d45deced9d6ff9ac9522766e89bcd10962f0267f2dee06fb771f6a27ec84603c80bf13acb81f26b585f34de882836d6d93fc2961935998e984cb6d8cfa0c6333bbb7938becea3de44aa87e95b2abb67d0d6cfd53212defa997bc41fb337636cb76e5ff176892d5cf2792f5290358e06ea6805851bd839321f27481bc850422c3affaf8af1ecb3938cb22c110e43b4c1e135e08d00a9805e7cd15fc416a00b1e9eb12f36a0beafabc0561383a8f5c8b5ffac14e8ea4d50e3d81197978dd8aad37fad7dcdbb50f60623a8915232215f7e550550c21e595d90c1b9ac9635983919766019e523282ba4531ba3ba2512750eb4e7b1f39ae06b332f86d58fcce5ebbf6630ca559980c548876179b6d31cf5d0fc90bb11ccf0d9dd8e8a41edce969b64742259c363b301630fddeeafa37fb522afd07f96ae0141831a1ea5a74af42b090ff7e6654d637648f48b69bfce42265b48beec53e19edf5892aef77e9d720df79132a93a9e4e2c8ebea610c6cbe5bdae0b541111b7592b51dcdb5692aad7f6061e46f87e59f4ff374a407e57983ad4b1502c29625762c1d7c76188602f35f3351c24cdf7d65627bbb661d172ee90ab1d13c5371f5b9686f28f2ddcebae24ae484d002b709954ea607fb92df1928500b19bddaa2f27eba213a8babb39730eb32a723d6b24b38019ea653d54e50404d3ea7041f98f8343d933d9cd91984fdc80417a1ebdc988653a7eb01756796a402de172bdbb0aa215cc553a3be6fda9555405dee82f228b9857490d8a4d98d89ff9d85483d85af0de4f2070c921e97cf03ee9078d1f97d00ffd0797e2c79c675a06a678b895f84abfaaf227303d1ae7d6b837d864c29697fb60d9a479fd0da345ac4451628ca7bedc22d009764672edfe0ef21af699520f45a20f89d531468daa27b575c7c04e086ad90d1707c292efbbde2cc3e265ce297feb30bb4c106a85d4dde7394dc820f4704ad5138ff490312c9610117a95cb187b9b85949f9f60ca7bd866ed99bdcc1758e598a5b171d467c228b5b6760fc9af3453265343a0acb8ba5c7c90c85f8d2fe35d2072dc7d9a5c4ca653b2457be32b1d69526db2b4197b7a187ad59583641c72f3771adf2acfa221f877c4b49d53108ea901826ad41818356c8e654104a48d7180f2c73dba74d7358c10794c2b381156c65275efdc9b8830c4cc2e147f644fde87941565554264aae0625ce2e996f40b90b4673c0056a7aa68a568c03b9fd801313ecbb0d5dbbcd2493597241e308994ff91eaff7c502b9d535bf27454c821168c3933e9070db34a49226ef1ae3854f04f44945158b0000a1186de63b6532803543359f4d0c18cb5bc55b4f36b33875f8b3ee73f02a5265973ecc0ba06dc818245e0379fc3d475602ff7db578e65265565524229ae72df6b8721abfba297bd61af2b104dfa1dbf1442dd15e7cf677976d56b59a6ba6c3ab3f0703799f95d26900e088986d0dd569b1cb2c59c3f2d8e72cdffd6201c0ad36aaa36d871f207edd18c6196a51efc928abe4b0e94804981abba320ffdda113ad8d1f2748ed35bf62959823aba02dc571261b0162bccea67fef42009eab0978abb483eab7d41ed09ee7dec880c67c5ebb9352dad65878dfca8653f2affc9fa5e2710de6baeea034dc114391ed0a793c223232f27cccd3240ac7d20baa341b9f9a35a66ca33f09fb9d6cf9f412dc13ffa10397465f86694be690dfd5333725ad5207dd2d9fe15f6d88ce57fbf815a36fa1cd2c12676621e6fbc3b47c9abd3f5573e18485473f433df105ab1be0bac4ab32c36c52ab29c328ba6fe873f36bc4ed36173a40ab750f70e56885f93184db6892cbe98f7f0c968abbdf86a016bf65bbffb09a3a95b68e498e9ba6052b3d2d3d7facd5c7481c5bcad0212133c69c6a7b3ea3659a2c74848486c1779c2b360bb769f0e726efaa08a2ca2e871c07b388ce7585b1fa688058e1d7f2669ffc7df0f57bff3db6135e99bbcc713cb1b47e0ea887c78ef6fecc5915f100a6b630c0d88be3e743447f25d880787487e18d192f3051c3a12adbe275e1eaccc871446b6a1c56ee7797ad8a57fec2b62745e10bcddc556f435ae4abed305f76e4d6cc9ba5035d70026b2b42c14bfe30b3ec1f502ae4c577d885b78ddb825a54d67b2a43a40af3fadebb4636b4ef36f5ff4d0e342ec930988c193963a5a291ce6a4ae1387ff1307bace3fe66ae3ceeaed68ad8241171625851b06d142a746d66fe566c414e4feba27f473c787e5e11a269652e593f1adbb98ea308ea8f18133ce9ef59cd167ebced12591793430334eae44380c1fe3dabca62cb3589cccb58a2ca12ef334811e172e10b9d06817ed55e7f6c14129fd9d8e9f14335f03fa025b2f6ecc3417cd9dde510086e435faf30b15e30e3236653a90d9f69c4da64b6fc3afd822a2692b43bb089d3dc2ccf906add71b98a5c0af58b6a924587f476af9f4c8e3b472169e59a67ff7c7b9cf498e3e8670739c2d89de98f5d41c62f46aff9c83b85fa8fa178ace7feaa6bcbecdd5ded15e1d4c0a58a712fc41705743828a46e68ff9e87dc6d03d0c45503d339fc6289b2e26c9b904f4e3ee7e8459c0ff8a9509162f33feca43dcb0ccd4c9e2e679f658a6a498d14773a2e0a69493ee107806105d20aa3e06edc86b1a91d32d4b749351993430245b6ce3b57f3dc8fd91b892ddac0bb38fc4179247fae38bf1bc172f144f344e162fe091a060e0d366174a4628910e3849bbdaa565943f483a910390c5591e408c416eef3459587a5d2d09ef316dc7b1e819b484fd43c0d5387a6f812c534539c07d62d6581123e9ade591ce887bbaa362d3e09d3388dffc77eb7cd2ff76449cc4d79e469bd2d8b070b786be4ee1bdef0d1490ba6f77c1c8124191a6fafe89706ff904b19379cc80ef553ef2c9f07b6ce95f1d53bde503479a26f0d443832fa3795c673f204ff719705f75ffe80dbe212d7b20c3b4b089f7ad00e71b423cf707b71e6e48e7bc68c6479edd5046582619500113ccd0f249a98a5b774dea9a926497e1c404065ba343d7d934ff04feeb476e68b851d2cd0caa12b0846e835ddc18109674cc1ea17cbe5209762a7509825f3efba5c84db12bed1207f3bd866d9bf1397d9ea4c24f3ac3bbbb8aa4468757bd50cd17ee250a5e4cdf9496296f27be425e685e8210de352e1167dce6bb6d7622b9b8ab88d905bbd96302d7805107b511bba067493f377de446c1321644d777ee42dd9d6874dac2e6454525250a8e1b131e3b3f0c5a5241965875a28573c916320a7e706c4f5e38a3e0ca6d721d463eb252853612dde7fc00f5f01585b70bd1db74d347f80724025bcac7cfd3b46d2013c42a7d01449198b279432ee21d6b63ff7f2caaddd1233f80f57869f9ac1833e8f2a4e292939bca28d6c430872ed4b3be80b7b0c910b8ab93c0edc5390fe924d06466bfb8c474ab43bff011289bb37ec69f38e0541b1ce0ac901780732bbe0213f0a8dedaede71161a5c833309223ccb7924a422ddc7e081cfc31b526d47d203d09d307a7f064965b341dc771c88acfb3f6e0f2fd87a9d495cc68aa47fba935791de5cb5c6e20511864867b48d40357ef44c2ea5dd9bc27a04957ac2af3194d56483fafad8af2d9c4e41c644656b9003196f3fa5d23974fff840b172ce55776b6f831355c1d7b1aee8894f82e7c4fe6e4a5c0df9fdaf8c4ffb780d47edd91fbdff2aa963d780802071bd345786a4fc63de1f0413d93451ab9a39cb6cfa4afde667b1c4f442851391c7850d0b235e93bd6079f09aafc047bacf2315a23a9fe06d99bb5d606a10fbf5e0a68671b05341f9337e2464d453e670d77e917c739f49b880ecde22b99968bc1d2e5396971b567800daf26fe1b7682447674f6370e6312418cdb4da1f1c7d04c88c8dda52c72dc2c484a67cdb3a206aecccca1657aedfec5cba8bb6b699bcb4e35e52189f0792f44c28a9254125305e81f6ec30a5ecb55ed24afe5f83b43dcd5eed56f6eb1b8b6d224f7a5fe53220a6e20b33120e00847238b9a833a62cafc70fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
