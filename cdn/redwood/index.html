<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"322b66737a8ea37efbcc8968d6c2de5cc629dfdf4a8d6cb94996e02b7ab9e355740668d69fb79a7110ad7dac7a2cd41f8db4b4d85edd56dfc9ee9c4ac40b534b19131b283b59fc506dbc7e359039f4a9b80b08e4df3b0730c112456424dbd471376baa30bcb9eb1b6eb8432d3f35e2e7a27da48d9a3d8cf67aaaf7ce81b255cf2221ec51cd08eedca14b6d4db403f10a0af76fbb7d088e23197bb0ce7c419cf249f7e603e51f70d3db68f191304258cfa2222c6a97a22ca4a00e0d51a235f6443f068f3a0972442c951b5cf47b97101f5619550c659194fdcf6003a675355df316736cf66312d0e2fe91ffefd6ee0332616adba67cc34b5f737fc8459845c57ef13f402af6faac9bd5cf8bdf0d51512decf3a845db7d8cced7e08f13c7f485030f80be778f2f1ec88b0dc2f098221deeb325a642a700664924baf7687ea6f88e2f16fdc28007e6015e3e887254b57fe637c9765525823fc945168af35010d49e3d8fd4ff901c18bc8611676758b3cb808e2003fa5f12f2ad0615570f4b7735f7f2771c90ab0b0c246fc4f2427e46cb5717df057203019ba52f39d5f05f9875e619a20fa84c5e01f42168da98c0cc71c2ca06436d69fc83d505c3834fa5f165803d85ee927b61b45372aea510ac50aefdddddefecb939bfce80af885164e84281140c57b527e25c6fabe36dfc2103e4e35ceb19e9a3bc9b1e9fa528fbcb7657f90fc71bf8cf721719630e3a6656a0bc1855c9b9a8476effa628af486760e09e226cd89fed134ecec7e06fe13ca7eaae9bcabf645cdda6ae84ec8311026a8aa9c4fb0dc9924c911b755b616c2300a31df8b4dc3983be5096036c31b4fae6e627e9178efd930d5530935535e6ed85cde9d5edd448c51411dad2b2c09314eb6a1365342c6b025ef2dba1ab31b341a3003cd582b70a99e8ad1ad04767e2d955f137f369fd1483ab3dab54f082f16e5495742f3758fa206e74037b462f1df18bfeee7f49a1dd46880cfcce6785c8533159aec4e4dce41fe8c72cdaee745a60abb20afbe011f26fa9daac19f37a4791a4687d98fb7fa253b92cba9a7208602a3f50dcbcb5e646cb0c43d1d6d760e83ef14305a1b419791e0c978d6d40ff79ee3ea4244c4ac8d884c2fc9a10e07c5a8fa9a008cb5e3b28f50fcf52e5bf85dfe35566eb75e404ea20e80313d95896f4bfaa6a1d1b6a32d10149c6f01e68e0eb0e3297896d1bf8974b4acc69fabdae6d1e731be01ff8fc5bc71ae531bd36fe3c735784a45568094ebe81022b329c9f8cd88c3495a6f729a9c8914c50e427bcf58f56c9625331a65faad0277c4c886ef68eb799a892383080f1b6d2cc21686ac9da5ba6bf1bf9bff4675c43139d340105632e8f7cb6b216009030811e02c12024e9162ec2f8bd372fa00fdba93d276af3ed3b8bbfdefb4aaff8fdabaf4ca58f8977ec7f17a4681ec272fabb23570fdbb878105bd2af589cc1bc569f663dcec71f5f781cbc7f0eb48595e7a9ade981fdfda4f1a7cec7e0745b8c33abcd7eba64c91044c766f4ca1aa0558c270a85e8c35c3dd03950b8cb6863aca1785839f0c4e171be5336e87479d27044e39d9420549681a3010ca1392f475a6bdcfcbed5d0a0faf7a723fe4d85c1e3aa4b151f003385abfe4cea1ef060aaef1fbf77a0455e1d47991915d67d0431f18abba5f496a4df1a61065cbfa88963ba457532391010238986261a564a3d394f5f1f430ac94b4eed8be11464223c41a6378f82e5dcdba99140a5eed93e3d04e862c02db022f4975ae2f7a874a762ee3cac7b582f0d9b85cd3bc904b279d6da69f1238cf7ff87f6bb7ba3f1f09d761daf702e93d67df992c26443da47e349cd978e68e010493696c2a9991b0afd186af21af95fe0d95cad0e36281e701a82169417568928069be0a2a80b8673b30eee195ce272b16c3819635e3a25ee313a81d452740c79e51a0c95159dcd8040a7478021c0b4e47924021efc6929742102a8d995b32ddbdc4b43d1003a5fb847e564e8d3e6da6d513cd0717fadd391f81ee5e429b825e0689f938afff83aedbbf547ff8de1f18398dcaba2594bf01977dee5c8c155d0fc1702f8015676b36d7be97fe36f120a262e3e42494f6b4c82fa8a94228f4e3bf8830cd5de95ae9dd580b120c4624ca859fa55b7294ec14346b7691b167c462e9c629310eb1540b21b12e6189bba66168818f183235c0715b3889c745f56adc7ad8046af3d41bdad805b97c1d412c1113f535465a968280bb039b190904d2f7c92e37007d79e7988514e7cccf3b68958cec75654c9c11ca46aa73b3a6fef6c447a23522a344e68027fbc763641b35e2a9f61b139d71ec62066a4e9a723949da9cf781cce63c0d8132a544bac5f000db13892eee1d503cdc0be7d96a46d8125cba28fd28710383688dd67af47ea99d5a69ee43c3e3663cd3386c6c69360912b3363e9d0222839b6f63dc47c1a0081eceaf530ef0120ee71c18e88e903a8d9075090ab500c0c480c05ac0d355c71a6373069b3241d293f34ad6af415281c05aef181ff97d6a32ec6402e5a61f7d3c7184efdb01919ee15b5ac874619ca33e71ba6ca7cf49dd6c56efd86b099c863e2482cc744605a5b78363abb62ec12dfe133f58b917fcb9f945396dc57ddfd2523802e94e70ffb4a06bcd1c27253d06e9bcbed11ef213d31cef3a77ff3427dfbb6dc48705d62bf627be0172e025823e018ea2d7efcc3372cb73d3ec41e7f2337396d11940cf7e6052ace691c4bc2695f5b773222913d5acbdb009ee933309d74d04521d7b3e9ab10e5eeff7e4d9e7412ae4f482db5121c3b0933ef41c1f91374e42044dc6afab9103edd5af19bc139282fb3e364a09b1b28c056778d56811f1b8b068fdd2946aaea118562b7642b78a1f75355b86001c393fa97b7284b8b899fa3c5b06f2815130061f16fcb15b8fbcec86ce2d04cc4b5b62f6d5f5f89c18a37a4c76666665cbabffe5e61709a03238ec71bd79dd6be1427d198b7c878c1d145ea3acb54dc6379c90dbe9554eaf27cbee20ff01e65176971853a49cedf2d367c4e311573cc37f2eb68342ef8ee3e7b19e9943eb6e4a5fa10253008bda5ed3e939c42c65fea317b0d7b2217a27cbeaada29384bf54d6388fdfa37db9fe0088c7945fee66eff8f10e5c0a5b2b7f85850700a7c3554a9b620fbf60ea9300a3905d34e1f865b8a49b2fb2fe046613e286509ed412ce0a6e491216991a27f9586d57b2aafc30a45848790339cc98a0d590d89ac6564d7a038012eb5a8413241767f56be6d381643336c849ee9f8cf88dd1e979ae03b4178918538eef2f5d45d93d0f41b6404fc151a97e9d46dd0f29cdc77d7a5fd71086457c24f3c00c21958d8d29e8a4a4bb4efdd7d28b0064ae2eac56959aff66b2172604fae67266b167b068a13ff08cf10436643f4a66ae213bcb438d4696922cc9873a302012001889af01b93cea5c63ee0292e7b763a58ad6d5d61f62e6d2c91d5a74e1e6b7009cc1e4e991235fc04d7f9da438ca423b067c87d011dc9bbab44741b6d01890b7898a98237e0124a2dff48ac252f3d8e9d0a9b76064059a1a6bf823793ad6e3e016754ee1dfb272c5b313953e4f95aa833e25cc0ef606867748583e7c75e625f93338b93ed29009dcbaefe53f91a877786dc8b6727d37c864dd1c075b385e053718dacc88f04d7247e5b9fca8950c3f79715d9a541527c0777e31645c523f0bc2ebb6140687096ae86e3e09517fe2aab9bd4d60bc0634b0a3f6ae18d07ac3d1b254baca4c3fbdca277a3203a7b8340ebceda16ae39f156d342816da3cb05bcd8976a5bacda78984e79592cf40235e233d228e44d2da749c0080419e2aa8936a97c5b0a8782810546c85044e66b9e12ca7d1c971d65690c4ef322facd180270279eb16a12b45b2f5fc1cc19590b09ee43fea55e277a7a32606c54a88a8352b17d27e36c47a44ee29ce0acabb28e24ff77d2a4173ac28cbe0c804f8133c8ccae5077bf43ff85e077605859121dc5f90e0cafce7904263f1a7194cf560d1e921d512cdbd04c466a31d0012ac6dc0c0502a0e43d6a06cde109b2c8c8919525f1cefe7619da5e9fa22fa37adbc56aaeefb41dbc2a98df848b3bc58d2866d23e4e2e088d2e1a09cd9bc8a48376453ec4577896d36d45962ce7fcc94981e1687e17a9e5691082335a5cfaacf875ebb67561695d413de3d10fee23d8a03578e7aacd1ee51dd25d8a23fb0c49e5766fdba0f54df964fc9fe47768afdff46c49c72b19ae26d7694e890cf6bd9433efd029ad539360b554020afd196ba0b021e8323ff7098971d776091a94928fbdd8f48dc8203619425c9d2a022dd256f5613b8b57c34bed3ffcdfb9e89c8b1cb79af7a48ac363d658e960b14c75e22c4ea21cd5849cd89b6f3354482d00b8b37191690a460311e774c635436b20d8de62be9d2663968940e9f80fc226110d7ddec0aa16388a2a6a3ddf80e563e8d09cf01e8b1f6671cd899ece6aa45cc6eae72b1c1f0e5aa005037b0c11e97625dec0b19bf5f5951918bc07bec17813c5176773006e3032fc8c37be42d4d7e90316718d0ce1d8de71e1cfd2c7cb6451334fd8a357cce6e002e40a7832733dbb89696ce051e229696cbabb41341697d34d55eee9100475950c935eca570680c28636e46576b016d9b4bd6c66846016e59e185ed08f088525d953321fa5e2f8deceab3c1161b3b10dfa43774dbccf661502db0913bef195cec22c7d0c83494326eb30324f353cd17bee8368fad4c8de9e0164f9ee3eb704f5c2bdf7cb8da2bf56f8e2393bbf7555fa6f6cfeb3f06ee8c5957691d3efcce517b7aae716a9b3beef335ed234e12dbc35fc1f912dbb2d9b7c99490a6061f8de6ab6915c6afb8c78b058631282097c61639bfd613cc1b02e991e1ca590f9c6fe671500ba783a27869e87e7f2e3de79af61f3758458fcd5831dbbb808fc70a2923229edbaaa19d68e27a296ba6ad745f03aa653412d00ce8823bd386f317fb92cf952a5a8244db28edc53cce2617b856b7dbb3c0c0436d456107f988cdb53f4eea5af2d91e11d9133d6ff66cd4d4b62072fdc7a931486fa928a52d1d128f50579b4385a3cb9b8592bf026a925f0ee2d7c39cf047aa0a98416b156bb0ab69fcc8306a280666027bcdee95a976eaebe6dc4920cd47a5e2a7a567da2851fa3eda4e81a3bbb16b0cf0b1de0042405c71a359dc09a87e7d7f9c2c707389dc551021c04798986814fc012b4ccc2b96ef0b1106bafd8a83f4381e6ce1f2b49d57cf80b9c67613d2bd14a2b9eae3535e163eb1a7e2e8475bb699d9b6db24c5ef4471995c89b9e61262c9ac65a593cd8a7d044c4439e857851ce719c692da81759e75457437be55abe5dac680c384cf5332e6a2f49c1eaa62693ff9fd411210081b478f8efee064e0de6b201bcfadb2cbdb03939f14dca345b57f6cdade29c8384256f8c3e7ed280a8ccb249b05f07a1efa8df7d3c366e8e5ae33a2c336a5a7526a7925617bd7fcfdc90e1cc9c51fc25a09b35fe1bc8550b7f29248c151d1d691852e1d7f27a7adf04f8c849ea71a760bb968db3126285389e90b076927c214f1aab5b677e8c7936b35c599ae421d2d8faad9a7ff96a43cb58b6106d7dbc9a043886e37bff4b941c252d7a3b3fb3424e76781474bc3f05ea0c5f1aa7c92f8d72a4fd5cdca7f93d1dd8720aad534f9244a7f140d857dedd337c0025979884b76f72e16d067915d43131c54eb9b1db7735288876ac7b817a4deb08f6a68c2ba99efc254e15f180b789d5fd9697f9f2b056d663338d4103367acb3a6cb5dc8ad4da9dd6347abe83ce92eb25bc65452ab4e710b37a06ef7d8a09257f07a81588a32e82401055dd57a19750ab5302d63e0dab3a3bdcb01b4566e8a095a1b801d245670f393a87376d562de464aa73ec1e3f915132967424186f2536be3d7a6c404827a0992b31eceb14ea31f6c32fb508dff1c79ef3635b6b73cd192db8e8d6bc3896a5cca08d473e426209723257af6267c07936ff56f4825214bf356e8177794425f893fb0232315b197e6ef6c2704127fee02e70e9f982cc28a46bcbbea127b41fba594ddee5b6de3c8c9579d7f7feea0f598c3083cb3389a6ed49864c19f9261a0c97c85b42cb250802a7a5a07681580903dbecd731abd0c948ad1484f951eb54d6764d3326d959e0c3d191697b3458a566ae3a6204a5b26c8b2199d5a30b6a8c9417521294b0b780d9e381d747db2fa0e0d618b2147dcd8bbb34ee9835c5a9bb7d9107cd789a0fa0b7b218575cf1922046eb79cf63cddd87b0371b33ef11db616dfe4678f08abb5c8b8e165f1885f07e660761ad0245c6b7ef4348f6d28e5304420673006ab42125e4bbc4e6b93de331e1d46e16fdb368367d612a1832489448e8d097a5f7323275705b60a8219600fc3ac7bbf27bf836555428e4807a3db2dd7605ace2ae695b93904f22d97268cef75856f0eceb3da289e059f24a597723099ee78803bd12248ad5db38ea3e651524f82c60cb2269a7ef69f8b67c1ca08f5f37068e341d8a76ae9733e4d03cff33f51ea5f424e81167d6bbe956e586be3424bdea902fdbdcf550894680357b616556891c9629375c4fc83f1db838ca7aba7455faaa88eae96149c0ba220afc5f8341d329a2b5adb474f8188b6059c700cfe214321ebce89d471d73af5240279f682e8429c8b7b3d35ab5e88044b7179fc49e9761ca0b49bbfaea2f181319f3de08ace823d21452ebc688cbda8fb888c0207e4e8ecafc46fbd659335e2aba784bb87dfa745cf5d4fa366f358907da1b0daccaaee12b85a2986177b1f7b619cfb895db4fc833d5dce45dab4df2ccc58cf1f33ca79ee079768eb6e6a7dc695e9237fcb8af8fa6b9536b27ee03190fda3aa34cb99f650122e6ffcbf64f998e3ecfd894f43194cbda889a650b804f4041c73b8fff195f334e207e3b30f78bb34788b815edf32100d21986e714065e6fc6ecaf7e56812f55ba80e609a16dd8de1ea3509a0e0c8f5551a5c926ea007fb6d35d621c512e12e7630668d70ee99a692b809f908b43b80b69b36d96d45d502db7a8546dad867796c055d352e8ca8cd570e212cc3dc7999e7ed93fdb496ccd6185ebf3834fb1aaedaed3aab6e835d5e0d32cdd7864e31ebac64181a0253169028ec4cf0a6a22da2533b967a2dae3a93df42e90c515d2dd535c12a728390867a69919053bb0da8d5bd3242f2d68fcb1e91e1393808e3df0a169b568944a7c74f2cedc44b1ed976155927ac96c93ae03507c070e01c7760d6aadd13efe9f9d00c1e04d4483622267cd32457256e965cc6647f23267fe3e2ee7058725bc27cfeb28a23dce1b654d3d885f93cfbbd3136afec1cdc8aa101e36a551251e123c2a364d2015b07bd3f64064434996449e58137a182cba7f028bbe9ddceeb47bcc7115f9c8d5ec0ebc5009f2665bdcee2c4c0b1e64e3bdd3a3a82887f79e572746b187e4233a9de8cfd75039f37621c21d950b95af44a3f17fda8d17233849059aacbe630fac19cfd2f5c728a58df6dbfae68b2e58085b58be7860c49c779732e91d25bd7dd323e1dc646de516f7db795863e76a4b5a1cb0fd6beb9fb25b76208209d276614fbe9376dea4adc450b6f063ae3ad61f5149ddb90ed00342ad45e188946fe5b448aca51cbcc6da3460866e68a68b98649e442af1c526b731e6b70e53876ede3a22fa22d6f96ec6b0e0854491158b1c769423dfe5ae1d0c6f3dd9c9c186fd27c3d623ac3d54c9e1015bdf09da50dd175d972c17d5de936e2ed8b08380c61f1df853864f23ea5dfefd2c647a6be7166af5f61072365995278c483ffc32a06d3b070e73d79143c71f1231d48c699c43ac8690a532d2891d707082bc387cd9f0db5929cd477f1a2f0af923c691e5c682fdc4e1f563fce7eed10f4d5dff07b95fc7e3ed96133de964ea3e6e1676de47869c7c16d63f4000b86eef81062db039fded9f1b5599d5fd01d3216377ac7e60d48b766676f685589c9acb92e92af10823ddfc428b6a05e4200c61448b1c3f5161f2961e8cd9fb8551905c6a0f3c628eb093612c1fa2a74cb32e002786b02dda5b8d9012f9b470ee1582a025827c0deb794a7d21e51fe3a659b5ca40fcf96d22887bc01a6651764381afd50415321c2344bdd1c8061786afa64d30d6b20a69a4e8479c8b5cce80d08b77eff4ba8c26b0a19572ae60c890ec2a3c86562b46c3a8487392371fccf100672342c65c243f8cf095a2b72cc737de25a40f7c3f74a2bc7b3b905199be0b18a1006528e09b8a03ca1aae62f28dcf178304313ad30aaca420e7e8fa5bead62d86fe7adbe1386f748d3cd1095f4e1c2c32181106526e23f63d680fe16bc2a2625a7acf3b468e8ef907a21d7c34ae6a6fd35fd6afb458505ef9774327c1f04d1010b202bc347a48dbe6f0326cc29c6112a2b863f79e30e3aa54801f2a90a09d7ff63373f0092c83bf5d01b174936ad9edc61ab1aaeb82d354577f0f04dd41d57df4996841648ae2149648416b536f8513e72458dfd0554d2b7b7a3c3f792d6bb55f870ee21882ce828cdc4cbfbe75ff564183f22d6a87ddfb7207ec83d54732877393572ac8c3ad1f61aac6b9e3164f48cf113144b68888bc2528cf8a5da661b8e2f6773f5923bbdb117f9beaadc94075207b9448b109ce6a42ab66a7ff047050cca7daf328c927f29711b7437c6f556929fa9e60f8360588ee64a69fa3174faa5224501510c70ec4ac248742cd19fddc47198c6f871900efc12c27dd2c0d17c24154c839679fc965aa8f1f71c2924a80f8b37d0aaff6db8b65a55424e59820e8865db5b7aab5652f2d9159548ccb2f3636818173755699d7aecdba2e91131d7435c4dbb78ac63c3b7c4d816ee9e6ac80d9cbda8f8f8fc92a38f40a26e5fe2c2d0e818f8bd7c73c3332a07975daed74cad6adba81ef4e1271ceab91e98a00559502e1bbad0dc5669a31b1ea613a5b22a751391157fab4385eab726a5227a8f612e29c27c6de3069ac172f17a746f3d7032e9f64c298db17f58af6e36eacbf0d7c6d24348d451c97a84bdd0a1cf66bafb82051d4d6b41f6af33ab582a8c1b12b6d15cf9beeeb7aa3f01879304070b515d615d48589cf0ef5d681178a2299a05d1d05d06f1b5f89f3dc03fda3e0bb0f4f27f1a3d7d49c5e5dd13f6398798b88a8f30e09973ec02e015ce77fe26ab28e7a4ac2ce12b9bd786121c3ef14bf37160ae98b434a2b945a91134c3fe915e72d22959b1dcb097f7346f13533879068d8c520d50bc1b12f15c470acc78c1c3fe46df8675421743f59fd7f100ba5fda844fb47fadb0d7900ae4a5058894717c56b22db0a1089e22930e09eedb3ec9d40de3259761709ca7551dae825609bebbc63f66d3233a6a3820bb0ae953060a5b48da3b565e7c88e6ed0da3ad5b06cffee77b44a2e956e0c73c76bdba9d6f47232026f9441f7dfa335cbaff1e9e75941a76954394e0ebae1f807e699a0318170d3239ecf208dd0c3400babdfa403dc26f4358e22a2cb6a98f1fd40cbc590b3c2e50a5e517f290e832da15b5686f9c25a1c8414addb9d333be174ce2ac5bdb4abc05f2fd19faa3de58f7dc6276f1325dd49ae6b21edcddf8a1f925c13c575d978c87743feb9888c963505cba22d96e8f011c96fb78f9a1cb526eaff84967996fa56fcf2a4229eee5650704dcf42546ecac418a3df594515401aed6a93fb3d14a2e9c84dcb7d55d9c1799788e4d2c34b0c20f32e9d571b1474c989a14a861c97942852976f7a5bd3de6419bf363f139744c60aca53fda3d753c0e6d853d31c522ce0b503ea910793d48000960e17b491deb28469a1ce601f6e0a2e2eb15ad30e962f7f9d998b7f9f5093526afb2c00373421f49289d002eb7a0a9bc147c911c3258e012aab165735d1fdab57875f04940e4de44a7f0d60234b0c6f82584859383443eebc463d59f2af6fd05cb1b7564462db01006de2d9b13b93aa6868ebd64725a8bbbd36caa85f248e31f2756d69558726bf844b207350c49383112a07bba3ab5da3bf69946588648e4c996834e68f0d02ac593e394b1eb03ad82e01e321c77d9555e3cfe5880b41ed07bee518b21ccb27eb311a26d7f236bdb84cb861aa09e78a981c001bef8f1dad300ce7c356e5bd8646b2e513b64ffac46e197b3e99274bdf348f819125a15a27251232f77b4a05e03d14c55de025aa1d0b82097cddb929288c60d1c29e727580650b23be2be5693ffddccbede75ca578381f0ce820cee278076c846f489904dd9ce085bcf6f4a29b75baf9503b5f3f0065c3680cdff928d926ffa72c19c59ca279d6141de7fe0daeea12c6983068370d86dfc3198a3808e08e6429304ac6aa3686970f1ea4621e61b789835f21f0f2d15ea43fa1622dbcd7e0a812e8666ce2eb2f2935719426f113a400627d54e0b000457c66532c3e2656231a2367136a03d79fdd6bb74e8294e1f20b5a0cbbedd02b08fa7cbc0c5a0b2a524d15064845936c30eee76fa14a083667461ea54895da32f2d2a4697594e87bc65b79beafe4a9de4560f3bb3253a2f4ae8eb564788533aa45b5e1942ca159305f07cf0578819b87fde4e7fcd16bbe65c7babed222af17c403aae8b07745a9153ed06d44fbe1406c2b225e6ac10a0ea6f11b8d2f51b1fcbc1e93e6fd0d666ce20c0373958807ae0dc5c211e06f52c8620d52709fbabcd93c0b38f5c63f49b76d7e5d1ae1ed24985bda200fc4a1624f63b1d19f65ce45bf9e9685828a4bb55ba7032e7f4b4d962909954a619dc3eec8695dee2743bf710c1d91b58c70d8994e27af591c6289350778961c74c0f3cefd7a59c436ddb26de55abb5aefe8e03ab238ab87e2588677160cceabff05112fed0554e82f30200c653dcbbf367eb49ccb329b52193e404990736fb0fba753caa78ac287e49726f33f72e3c57ac12fe76c73d62b490b5081ba63e325afb0b63b6da414d7fb8f7dd1fbc3d3e00ba1fe3f3fa87ed97616ddcb050c920fd3fc046cc351ef6fc6a6498f02499f34f83c1823bdf5d20813f6edf58b8a6a205ade7f613065f7ab6fb34f15c0d9bb24db6cf412dd969a91a49b75ff9747bd107604d3d75872fad73df512d8f3473f6b2b4ddd8d7610243d4850fa3178a2cfc56b125e5099cb92563cdc14335e69a106db538cdb56ae94baf8e85757b8e92d91814d963a5f81d323f5d77c0aa1cb48060b50c6897b06e67d8e2d073177a15f8d0deebeae873b1423329137a9445fdf111c320fc12f6cec593a83710fc3bd8ab31f9cd3331a31d8486966e98b53e6dafde3a16c1c4e612d123d3be68ab0bb226000758d83c1a05c8c74e407ce3703ef0f6f6ada22e3734505d0e4d6053288a0b43a321d7297bc69bc69fa68549c18356832c74a12f26f2212d0d5dcfb33981d7727993679e8a692219ae641722ec00625bc1e1868435f433d3643b08aea624d47175addf99d91c47f577c7f4d2d4ce7064a0031bb2b9f8b445e9f62e5bac2fdf0874b3303c3142e9d34e76833ea767a5d74acc4c241c633aba770772e3585bfc67dd1ce166947cb51c55be3e549b138b9057760e155a4d0aa13f3a35e24b0d727e52f27902fab7a82c49247f1cb8adecf97dfe5bff25b8f9d68c6e881acafaee3447ff081a73452c0e3741a80ff0c7f4e46e54ae9a07d5e90d63b67bc952e815014a9618536a9bdf80dc14189005bd38724fc1869104819de905d04d0e03e6fd3d99fed9d07cc72130dfd677d3e3e4a722d432b6c535a886000f5e6c30149da9311601c6db7e06f0ed1c7a61e2be4d46187797f7c4b1de047ccb7e7b1c3a26e79478df6ba44533eb63692e1d0dbcd793a967d817a1d66aa0a5af35af6e3e3ae0ab43b178a4c56e4a60d9c248c0b24ecb4acddde8e959f4a847dc1a2538de9a66340251e43fd162d4cafe178a8fd2190a82747980c1b3ce738f8d2d581abb93ffad96db27fdeebad9175042c0f7a11cba04718f36280b4b238329af9917034fd719adb8f531d68d593370f467dc1972ac31dce109525e97ef3b7b57a0520c64a28628c97b915c875f70802c7d047f33c95c7cff88387b38c11c9144155578be09cbbd6cd35b91f318336519c5ce59daa8aa2c01f173ac40d60cefbb2584542e06d24b457991a4ceac384037af4490f97f758e5075afaf691a7e04a3ffeb340fecd96d1b591de726aa23d40e10a6a89f7333b54b1972d634f52e91681373d3448e298480f40bbc6bb2b3ba60c926b0d5d644cb5c6d2861e991ba016f4446ae7521ab9d716eb588b41160817bd1516c7d56a74073467d144d39bfcb4a95ab61bc548c835bb393cdcbf2309fd9003fed3231e6d9b5cb8a70eaff4aa694b0fdb68b37b9dc3a23d5d986d22083fcc9db39c8e572195053a1679739404ac650438064d8aad231d560dc08b5f716a25580a0ae25cdcf7211b3bcbc6647363d890a5c68eddcd9cf4e4af00e96686131082083168de79525d2d663d848496b3065027f14ed14bb60b3a17cacca58c13ead0dae0b817857fa98f8a9417e9ca9193c7883fc062f6e285d89e3d506c88b8a3eb904eb76c9ff2e35ccc3e07553eb63a13b7b61365a5d95bab3e7978198212fa5d2f4e1de63c52533b1cc026e6d8f386994b3eb8920d9b027f97074c2eab0bf2b7eae09f2c2f9f5498779f96a34b57a27060e6b8496d319a6aced2de1ba87acbcb75945456bcf15a01a00f85cb858d4e1d2774eeff1052169cbe3fbe82b11010f5fc5267e37d9f7703c10811e784999343e1ceab90c108c4c7e25340c8c9ab8dde3e73f9c6dd968019fb1d68a30057b360dc1f3286bed031715e6417efab9b842fa325a46d0e0e397d9ec30d32abbca955be7074e4e35e1a385bbd4b043a9e2c4a3f949e38cc79a39940fa281fdae51453dfc7920e83e51d43a26bd2cdd63479a1ffe83334997bab4d03838a540628158d390bffcfc413aebb924be3afb69d96c10e66d2288de1f5c1066929d265ef696dcb332c7b06cddef050507b4b8fc584e3770f9537f22e61f39340f71222c8d8f2a2d3ca519e123adbc6654ebb7b9ff791fe76e9e952206c12ae38f787c34b50844c52d1374e00630843c6891ebbc64d5040c327f6d91db3ac9bf677e96e7be0e6f90ae1d58cf50ed145a3b1bbf6c8af20127421cd782aeb0b9393265735cb4d2cd5ecd2f508d1081d63206ca0f4714ae58deb389fb9d0d51accfb1729b4a8b4f3a8f1bc1977f7809af3652a67b821236adf3e95958d278d7f068ddbb7b410db082cdb743cc5b14e6b35e4b2439f49eb365d52ad0f22b0fd182442f21b1b99f497b1099f0ffc70028d955e46229642507459e363fc504c9fae6fae556349ac75f5ba595b8af901bd138e2e3c9902a6b63826ff94da70e64f872a92810b2d0813fa6c3d0fd9fd7919474a1a30a4106bf027a5ff887a55bd2270ec1666d231c87fc06c8b09ff6c207fbc4954bc9dd9782b25846cde1cf25e72a39cac15b1b1834562a89d80d9c004d03ff107d0abce48f5193ddee75c4dde8d4b0e6fba332d3ef4722d07370906d4b74f0864cbc49919b69503480fed5b8dfe0de1ed6e657e9f31a7b30be6e4e337b83c009c3d734567d3b35695d621ec8e72c03d6102eefff57112d20c2544b144f3ce27d617273f97f3a9ae2fd8a3ccbce0b1b002f41246b4464f434065a794bdc1e4a951107d5e964b95999f44438e413476f64a5a27e755031dc187b07aad91a1fd945bff46a2fda0c0c39f13ff53efc8e7d7af04673b38164ae078a73ea48f8cebb73eaac7805fa5b03ac7e8aa66c1d8b1332812b6e3ce52003217517fec0d43bcf7cbc929c0e932f48eb90be58375924910af9d3cdd93fed0253747f1178aa0fe9c212077df0e550d89a68f86c742823a233c58acfbaad15a4cef67bd365d13e5e9bad1149a6ef28050668123488fe99471fa09b2565170b22008589c692e21ce89aef514ddf33b171844dd4f56c646dc992825fb71818d24eab3045b0a1ed578e8c61cb64706a6821fe67aebc288eb10af0d936aded4feb3ba13c4207358c1fc5feca9f0f466118f339990340405ede6a8acdc5aa7b774e9d3c3aa070f2891d91533501c686265adbc77627d370d4c97371e6bbea87c3e4f7a99bd9ab5f43b6ed8e01f442a6d038da20b7ea4a87d5b47b736493496005f2aced1528f0c77c946d2c30f8379c360db536b6fcee9405195bd4c7d649b6fb43861d7f44386daa0f8528cc839fe7b002c91ed86e3f8a581f55a17320b5991ca6de16a94ec721704face1dd9fc14d7df72148d0fa40926c0a451c77d0c83175d63113ebe6aecae5fd1367f19b27696827cc81c5028d666bf6dc28875722f4c8679dfb655f60b5dd4a4ec96fcad5ebf449c937a7d8aefc2ae31f45f96c43e9ba45134ee2843de7e707c5d7f67d82cbe353633a8db4c083419f38b4377f139a92f6b40586fa9fa750223adcbd29f1672bf542a4c19728527e3710a45da8f77628f0ec738031ab2d3c0955e724bde438c67e1010e90e166c5d6ef8c12e7b46ebdbeef68b6e640e7b25a9d214b95c15fe08fe20c61b51f92b7cb007809dd6a07e6869093df464e7c63322480a7ed1f1e103a02c3df7cdb989d6b5bea9b04a7f0b1b35842585d75f623e2eef5e3a0936390f56e4acbf033dc373e32160e8f2aae90f78f2998badb575871a366fd3f45a711b7c261355e948c991ba700d1664c393881a1df99abc53245eca4c9b00611fcee00d4c4b4db076ac2eac0b4baf80c25d0794856ade0b9ec2ed8c9f6757f79023f1e23bb2ee1a50de59e23c5894530d570fae1cd5bd4f76d1a74ddd1e8428719ebee2f00bf3d3796b015c9505ffdab9a4e009849f97b776f12016701c5ad7f893d7654e9d48cdd451de84afbef8e2460817889b4ded114ecff6e9ceee4e4c2954b51943feb74276703e14947fb1157d1816de6e085535617c6c7dfc69c1e1095f568fcddc04cb7a900e61f8c24342fed7e66094ea779caf374a50f4457f5baa395f94ddb719f9de61801634ecc1ae63f93317d5b6ced3812b0e28de30962ee1202fb63aeb733f5a62aafea5fa9d8a293de01ce20be5fe050246ebaadbc2d64d07c1d3fd461bfb87ab728d84e5527642bb1668a60e5daae927b9c880fa3b3de9ae70fe5d94601a2abc8096fddd76bc7d356f8703f8e0585d7e3f484c3051f7fd1da0ff535dc0c9185a9ee8cd973f6f41b13db990d62b5193878363997c6ab32e6bb4c9dd8a2baefa0e6e80dbcadc79fe8a6f0c55e2bd77301cd3dcaa05ff234f8f4fc21eb5a0fa7aff043fd8be80f0cf8c240ee70c24ac3d7a3fb8887cee8bc5d6580a8d176608ea6926a9be7f89d444748e993b13fdb2117b3746ddc3d862214cd3c78a8647fe23e54b7f9220b6c6eebe660b1a73ab536a438f19d704f4df24ef6ad910a31d118e53bd7b6ebcdc606a2d3258a0e2246b2f3d810bc9eb8b3f4ad5414e3ecad9b5bab2c483ae65235921cc9ccb67a30f79445c3aaa77420381e2b852c10db5c323ac9b190d43d280d4ece050980e59426ba2c524676bc4ec1493d5ebcff470d6134490587e1a0252bf8a19e96ff1791cb5141b58a7ca8a7539268abbcd209f992797bbe11e842d5075c5cafcbcdd2b25cdd2c1f30f27d3868d22203cedc7a3f399fe1c9aae151d4033a4e0f5e37051de462b69d166323c8f381bbc156422a3eec1ab8c6520c867cab4d8e7d4f0eed0a858adb8508d84ae29a50fd3765a88aa230f76c12c5c4807335ca7c8cd0c6a967f9ec8a9f3386ca074ac73cdfc5a6e2917a13ac0736c9bda3e4d69b8e247626831a1ac3ec5dfcfc9b451cf13df1e395aed2567160a4d8f8ce75a2f55c2ef32ba9243651a59db25762fffb34adf2d7159367db8d68539c8f75f7a1c4056e606610be2a6fd96877144ad635a78d423534c19141de633a2565c895f245a315fced32126e842847de111f1c7145a140f07d0ff99d4dd26214db41dd2bfefba6f600f32e2509b1fbb2b8a8e81c20d98554d1e54007231bc8cab7aa7f03e9b1911b1650597c4d0a335ad23910bd49052b3c76aa80e9e2c4731e766f91ac887eba1549802423d009e239c8995d8152764d64563c84a7e1ea49548ecda0a4894409a06c966bc1d38b7ba32dae5d287a81c41138f6b18069d6757ef69bf8a7065ca74b78d63aeedf78fd08f19fb155ad8dded61a4ff9f6eaeeb83e2f2b90665eedba742b1871eb355095927ac791cef9bfc93c8ebd99bfe088a43d470aac9e5bbe7cc720e1868b9fa6bb905e69572b7f8df290dd20843b4a78ad9f669eef66681ece087d5f2ce304af60683201772b9f0856a4d989375ccda42c8c0960e063f727255e8e8665b94a5ab9433b124a16adf4e01b1ebb1fc9d794e1e6d2d9920e00750dd03c820c0e3c3331857fde8671d0e2ecd5567df4ff6adfece2a13550cb354eb79889b00349deeff02aab6d661062abb69f2a02c80aa411edc891a1b84f000219a305e99e9bb0733d8b8b9fef39dec42376e0d7e12ffad6d4bf4b8f4674b2199a95236ace8d253374c5df4b19dfbd375de7c5675c98e4aba2e4853b78bb8e2f938d05edeea728ad5f519c56062ec2b8e101b493c0c564c8455cd7c4bf46f3d142564d6107ed944603b96ee67952b6d9d7b9d421c50121ab9961e1c0307b713717daa054d9a1247be85422b7647b946690476bffee5919343eb36718bff4d9b582f08cfdda08a96cb7d87f42ca01f741d3b8d28f979dbb8e9054c6b6f6d539c91f58c8f3368600dc0763cf28719f2c78f5ff68d1794fed5b932f3e68c4ed5d49c6d3a046063d49d8d40c2ae315f98719a73d27d07b0e84b9d873b812fc3608d3b32c8a613213f5872a42aa49e41f6a1d685545f1f883e024a878d723aeda2600c27582e22104831641325a67d1c6c59d3c36c26ea1057e22c832a8bbf1eaa7787265e7bee671acecf0bca5f5656bf03235c24ed1dfa094a4f5d3c344f1312219216ae8385c301c93089b2af258c997e70fd30d436196dc060083fcf182639c333e3b00ee62278daf07f318bbeaa33ecc7af299f29f19813c513694f7573f567c11e46ae4515b978090385b4d2dcccf8a6892174ef09ac8f99a58c9e28ccc3681617879ac762df39747d90436d87c061c57e6789648095a26063c33faba947b76a959b558db1cfc75e230c1bac03331fce3576ec8cc0c5f2dd78588dac8b07796036c5ecd6b106929d283f6b75616476754b3bfe4a5f16318b3eb025ef4c45ff02f3d2c7bc7ff309db182ef217d0b85a5539e695d1789410423ea860830706e76b5eab352e024c362e07301f7e01afdfe56dbcb975d4833adf13534b17bdaf5535470858549dc3c57318d36912ded9ad87df78f43e28d4cace060b05bbdb32f80269f1b99e3d25b57337b51aefc646771c8b049278644a80623c6f3982c415e45294188721b9cd77969ae0684e2272a9942a3294d5360922d1fa63051764562da614ea6df247ccbd1d8e3e419857cd47732140d6ed11d8d08a87ceb8175e47921777be61e975181a35715ad9178f9381778b91ac38a38143a2a5dd841a90991568fd0fa0a0af9cd3a4acb981ce396acc1d389f59a5345e16d85fab58d4b443358a91a66471a15844f83889e35a865d888bcedc6528421992829bfc8024b1c1be0664606834e28da125a367f4995d797d915fe464113dd3ded79c54d7050dd14e9d967cc75a58638699f935181d0bad117a5e5b0c8533e60098836c4ebc6827b28fba0a4b90582c41fe5f4cfb04079f4ed3db983196b2fcf9f4bc9979f2d1410f1925820b8cfd7c2b55bc28468eafd3f0e0d7c83898096f7a15d50a418b057db659a86b665720c27b3330d3fa8f0fc068c2ae142fdbf13c576896d17dbfb997a54a2681a1e4dc2071d53290e0b1500ac54ab6ee71bfce63c88367abee0de3b9ada1643bfae2fdd8814aacd8b274307cc2620da3489b884946195fd292fa2496bc98c10d2c7abfc4f219c8cab13568935f515db6a409bef1d6531","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
