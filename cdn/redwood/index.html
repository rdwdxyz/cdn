<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f2298aab343cb373cc726ddfeed1e36e29dda0a2e0e20ea3d759d457577d898b66261fba6b0894a6aa1f67b6e9d5c03aa4a472a0dc7f3aef01d58ef1cb0dc4fb98bc57938df8cd9adc1d3423c94a75c02d7ad66191b8c2876d30c62b4d27332fc562d610cc0c72fdffe29d57690bbc4635dd26e29b95c23470b723b0ce39784c825a0dd57a278966525cfa4135e49b756ee8fedaacaca98e2219dd9706aee2d0edf6115e29ec05c8604809952946acad8c057f537263707a9719c4ee92be60261a700a1e7c7a3ffec7fae2c6f24f9096e8dcf0e38e5198316ff94fb81b82cbe826cf8935fe25234cbf6a95942d81c67246f5e76c6954df9f45edcda215524cf2a45627058ba3cee0abd2b2ae5b46fb678809997c66622731b0ea54be82e0e45370f1f210cf7431277359280acc27cb8d1302dcad31670abf0d0e979f16b066314469048afff95bfbea0a4dd64561157f4f6df41669b093198b4d5239542c04ece64e0b33af9aee64b00c1abdd12d137499422b92238bfcb866fdeb4d1b8ced7a6fdd44542930382fac3bde2d982df089cbb7243261f5924b074eeb3b325d1adafdcbe9f8937ddc07a6a2e817e0afcec3188d9cf3f19cf1c01efa10bb6f25d9b28b49d958f660606f7c6596b5ed72d6b44b5a06ed74f424978450ac785a5e4ecff243532c2644992624bc982618a446bc32fb6f6096f7f7ffb0e4ee6145f6cf54400e8095f8a6376652575da92e1cdeea3468fe4c90b05146a91d693cb1b8649440d6c628d7826da52e97bf3cfce885fb60b52a247629a7c420026bfddfe116b88589136a4cb35b217278cf88e24f7a7f54b8b17a66fbae4e45f288fb32081743c075c37cf146beb96be9bd428da3b5127c6efbcc70db84278816e6c3a71e7790cc59c5a55eed2f24ef0167a63dcdf94f0f4e0378ae4935d75e8750395e9363837808b09639ae762973d4ca072d1f9b9f8a7803999632bf47414f39513ac212426bb6f40107bf529d7c625aadfd241a3746020714085053598263184a1a1a914f89ed1d8750f618a079e836ab527836ea99c2b633106bab09ce078d2f57c651e8644579b6591a7c9e82a980b90ca8d4df31e7da3c4961b36892395ad8a641350ba6fd2f5c961dc7361297fda82329986bc7710c22540bf78132528db3812d06ec2a5ce6f7599fdf1766e9ea65a3ad82bd4a070e916b475a00409c198f9ff75c72437e906258b67043a1bdab731e881809ed09420aa1b248f43f9baecf07c3a1c8ca4f51c1cf59f04b53f2141c9444b615fb26f9bb23734735dbd916cdf826c67d48c70f883ba9190534745ce6a1c5cfb416ce50fda451e08c3fa7dff8734ba353f0b302e981250dde212c317705c0c6d27c9d94af902e27f4b739a8dc4675d83387c8d859de8853c8c7193652c22ad9bf282d49c97a978023ab708295ea32e26b053d2aabc15297c93bfaab7385cd7b1703208541ec56856625d1a59b923874c0b4bc2990ea65e5f58096c04e7e427229a7ff3e1a26bbe94617ac2cbc1eb883bcd3031af7006703ec2a97034e4876b55c62f13502ff22e3e5172504d477032ea62ab004b4506315d8602f07b9b76b1defaa968609e33e4d4ebeadc7ab78149fe5b0a21ebb215adc55315d788ba0f5e06e452ced16642d9c61891de14daa1573ed624c8d1471a84437ffad6435f20a10bd9b3a714f6b8672473533aff20fd7a75ff12773bbacbf186e098f95b03fbe57bf9d58df087d63b50060033d085de07b1186650c371a2d4d5634122884a1c78e448367759bce25fe47e2f6d34c9eeef40cfa0429d399bc3cdf8fc0250daccb8cb67f8e6628a798c07cb6106b19c2ff609e0568eeb789865b6aa118784f1a9b6deae75a4177813d74cd74d7b918aa88af12681842015e6f0ff5332783b739c69c29452e49d70d39786907ebd5deb6b48fe2280bb74d8fc9004819474c27aa34e1760913aab5d4328010a640f09e8fd97873d835d666e98c3b18e32018342597ef0e976fc39ec8d0b1a5e18d3baf83de4cc73139f0be340b4270670899863c5ea4e9f32f600abdb7eaf740952d00f3130d034fcdde12ce38c599c4d9594b7d80c8cc0a3582f7a5f7633f0848d44eecf50bf506844ed2639608f08ec5d733ffb9f8742bbb49a2740212699fdc38c77293d995690793bad1a997261cf5460176eaf5cd0d769e527f1f5771db969fe0c519f6a6be1459192de1fd1d576787c350ebd3334c69e424c51d2fa8f475dc4d0d8e931f266e053ee3c7e232f6a1654f2311ee9c9e8ba0d7ad20787531d47b93bf0fce2305fc154bfe1b3aac5bb682a759842d3766065afb495c58a6da7d01d3196cc8452636a7252447d89a2717403eaab2f1015c8dd0f09631d3cec4b09894b523a7dd2c31b3d2749710a8dee327d845e03d75d0d3c2488cbd2b98e09341475d7eecc711c7d600b429479adde90c1c92e8694489602f121160fd7028d4d06efb2c38696f16690cb7ad2fa4336947942d4dcf4c0fcba1c81d8ec0238fc8f255cf0e339fafc1956077fad9b645bd068c89a874ebc3093b31ef31ece3d2d02d8120cd11489fac0fdc1cc8671f1f890efecdc32e7b85bf5d4c6f85d772375f1e4e0adcac484deb389482bab5a5cde99768a314e84e7eb8de2a7ce5864a13dbe18ab4c412ed06eef99051b9580031c770f20e5c0ac0aab759c8aa2a08ad496c97c8e9f317794b3be84aaedb16d16dc9ca731cfab06b0186f0c70955904eb98ccc00fa8ddcc778812213b825aa8f7ae6dea69ba1ecc48b427997a4406a01d451e4912b4c3b6749873cb054187e98b51a30c56d210e331313a81c1ad54dceebd1f1265d537c9b950ab6ed439b30681772df6f456b7d90e3e132d0531454e0d564bb746136d83497fa74e8651e52c1ae52558b720dc71bfff6221dca5489df02563599223a7f123b99a0ab2575c5a0cae95a99d614c0a9ea4291f5a0ef5ad78e35e413a9ba52f372a9356921b8e5d0c14564e90fa12dffbfc9b79c16a66dd5d62452d46fdaca550c0b4c923c13bb4b82d8b7cafe15427075b5a11dc78d39994c24e9d9252ef4849bbac5bc3223d7721c8bcf944e20d5f87761adf8c53b823a0d649c90992cf45d15580deaac301eb8a75486caf2b3d522593d5b85cd611456e59fac14b9f9e31a631b3beff84ee6b109d1ebef374c6a750b6957d16d64f70e11873ee76d528d673f50321af077b21a5696f7bd4d656e430317a105f4196297a7fd4351638368e222be9332b655a26676e63d2942a70909fdc7c59d3fbb234e52fc400008ee0098304666f031b33210518e23c113f683d3ce5052f0439aa7d33ef3c112f479f6aa26ba5d28ed01ff46657297c04888bc3892634f8464b537700bbc7b675a4493a8ba06c9028c0e3a8647294f7b6b5c156d2c13316fb7e799a3c34e43eef076be4ac7f8476bcc69dbd8265256112c1768741588b5a9e06deb50613d2a71affd00ba876c133a7015803ad87bb01eeb4aeb4606906c5e97b2f85f7150fcaa04f7b9c20618abb6daad25b73080e68daa6b33f3e848b64aef1330059169bc5a3ef6d169ebfafaaa2f1e8c41b6e439785987009ed554d642fd4cecd09c9f28aa269141c6088a5c4fdd283bf2474c0f96e3268fe260cc86d2a23eaa40644dadd7335d3da984faa7ca0bf9ce3c51719677ddaa31e405425373e459b309d7863b6b834462cc4df4cae0a1f041d36980c215e3a5ba6ece30f14e1c4ab7a13c9674ce0de1fe95b7d20e64d48ba9672fd1f903f98cbe09b4bd5c27be368625d5d4b5b3892bc9c318a1f04d7183e012c826be03d235823cd0a791ba0864fb6edacbae5b56dee394ba15654ff94756350233e18f1250ef300023bc05ae9ad41c6baebb60dbb6c3928e8beb5220ebeb4c2a355ae014163886c0e2df5912fc4f8d4ddf5410e0d2d0b603327f05515153df6b2911ea759f2b7bcc67b5872963a6313fff93d16e1f60c4358ff45a9d0391802280e2c865565b523b669d8986476018d3bc5ee49d0c18935181848dc879f2b739e3211e862134a3287d849b54502762f3fc07a186ded7542047c63c43c6d8b456f4704bbd0f5c2adb51ceb2d5d7925248a7f9ebe303aa53b90f8e980875bd1603bbc2ed85008f32b9c5cc741cf6f00388cbd6695c4d7f88ac1519d982717d004ecf5c32f520af658461996635d14473fcaad26eabd7631c0ade7ec0106d8648032f84820d1d894394cfdbc1d310d1acf7067f1029ec9c4a271d6d808b394e662e22ba1c48bd77e52d328d83bc5df6505afef7bf1c1b2f0b6bfd99cfb9ede03ee83027f0fb3294c6faa8d09417885bd9c4bed6852b84b71b5a715bb30b069247d2ceb11d0f2afc64743b453ebfaeba521cf78df96416734e568682aa1bdd4fd71f98b0c038c23bb7ec75cae644c277cf7c20faf6fd533e03b7005c0e9c0aadf1d14d1367b524d444ec4c015c82cb740d78b860d3334fe02cd2cd122c4448d4c4aeae7bd360484aa4293f287d7fcf6c3d991d4c24bdae5523c9efcb73a95a4739bde6a9c8fcc09d0bad5f1d1e766d4f2188c929ca7acf586d74acc2389e692e22d3ef30f375d7537934fa4c94ba50d81cc7ef075ebf390dd21dc51e65b37fbd7d82690bd87aa57a057f419e7f852b3efb267635fc1482cc125313342343b7148525c10b2b58c1149cb2a19f3e0d09fa93b3974f1985fca68864dea4285006ede564aebb5ee9d02fe4deb9c7999fe2af92910d7eb394ead6d3ec46efcbd2d853a7baf48087ac1cb1040566bd7ed31ad37749a4bf3c6631e1fdee105adbb34aa643051192512b5b0449ed16ff542db0f835a6c2dab79a183e687ffbb35305f790ca2e26206a5a5d40da8975babb47453e07a5e2751a382971b5b3b8096269633b789a4a9ea4ec0f6b71b9137891c92240c16da819909d750ea337ca9fe003286eff75027e0bb84d96ef6268807fb58540f29873006a39b730a2fb0c8bfa29357b97fd440fdd2b70458b47df3c7e061bd8f396928e2cb6674e50f69be89d4600366d68ff998bb3529a1bb20e4e698bb5c5338e6cf95ccb0797cb6259bebd2077c374e1a92f4518cfe63a26a06696206c9c114d05754094c6b91550d79f876d079b248b0683cc22818871c80a5bb4d4af0355656b1488ca5b6feda3f2d4e34ec5aba73bdbdcf9094d3f12c0c4449fb9929fcc26a63ffe4932a4a36384a6b1781944f55585f391c21aaf14cf38cc6227cd8578f4c65be2706a127e4a240c456a470d8f8e13d9cd65fa35e2faf45013ef57c17f65e29cc6a16fec8ea7776cf6c1dcf41ab28f1282ea32034d2e5d35343845d529da5b46961ce8e9813b3969e48f468b7c016fe81ecda7ee49315e06356918bd4d7a85f28df7eeac9b2ed1e2f8fbdf074ca175c339f869bca6b67da053098b1059f37b44322c56ecdd15288c456266f8d8375c289102aa4409fc21611c29bb4d76e7a283eab9417b5237205247a5c40f065a6323eb9bf17614fa33a5ee5dfaf3eca49a3e535e66176d9095c50383cf025dd1d3dffe3a4018e6f18ff34ca872605fd88cf4231563f06227733f601032b434ed35ef94df64cc65e86ddebff6381fa82611bba9a2fa1d88d634ea01a927fdb1ffa6eb4b6ad63eae4edcb4ff18efd8679c508b75a2db75b05be0bba2ca160b2771819a31545ec356e93ba5e2fbedc920a8ab6931e9d13adaa0da450936df25357a751dada34f12f0553d69f91a0634bf4728edbdb6c1d2fb1d70583ccb662b8b1febe35030945258d8fa43b8822fa5be1f291aa39ee6f2253b1608a19a0c12289cf784417c8cb4d8c71b1fada665b3371e3c1e5051ba76fb1dd96f96b7351145ac7869ec58308489c6708175ac2dd02e99f079dcc6f9690c7245bb3055fb47c9e6c09f6736129890502edcba98cde7ddaf21ba76fc6059217a64b841b1d4152301a3a56518203ac8e5165c6605061cec7ee9fea8aca6370b621920eb519a1bd87dd7e26167b6bdcac4f922cb058d1a771ee0b2e26c7e7eff842a1055059b2673adb90560eddeac813a4b7f5c4e724d4600b8c788dc1e9f3c5d28d12f7ca11dd4bc0174c269ca7390a3423d4d37356bf9c3236a595398702978f363d0d964745cdcfc4130a532fff7a822972bb3ccd32c06ac4d310364aca4875a314ab9ec462e48ff5a5c5a0f111160440acd4e378ce56f225196447592648866f768b587ba86af4e293bc979d32c867686cc44a4c98649d1e90c5c5dff3ae9d63fd19f8e3dddddc44e005cc7d18644aa5b0795cfff6d87cdbb45e896d4f38d1ae290c876943e4f1f6408dc6e49ebceb44fb012f6faba58cf45c441bf6a4410831be3d270eadcfdc5577126db4e66c92db52ac2ff67dcabe314b7bf684db79994945a5c1d51da574a15a7d452df71f61ef46db6d7ac804a345f605638ed8ef991d03fde4f7b821ca840e0ff8985391523f73e24fc49526f62a7f093f69efa478b1e771c31c9a2442ef5b6b5eeaa4d2bdc3ab925731914e1432a4373a27728bd8bbfd53167c185b958dd7bb3ca63c17075317974547f66ed9499c4000b666bcd5d8d2209b45bc1feb124c3c21351e70577bb13d26975c80165322c80ae7f768e160235559ddaec1e75a8b97f6359e74ecab8a7a19390040da40c0f1455ae99a92202ea4f7daf4051b2ec4b613bd317b875db93dcbce76c0c4b20f23d4bde255a035fb9bcda6be38cc54c496b0fdd31669ffd58b9a053bef33ec55791bb92315794a1e54090ec611da9d9224ada643c90bf0e3dcfed46f01620765dcaa780e2007b350dbae960bb752fa412ad95fc6c37e1d845f6422abcc6e1abc90661a84cbe985211202f1da28755a27a95b1fd5b7c88985c6c94eb7836b89c0d983351f6f10aec3ae4e064ca70f3c3b57f0217c294c3ccc7ac38000aedb73745e7081fcc0eb78a5ae6799d4dd01ad5f7679efc2d6cad50a4a36ce06d9f597a75361cca90d9c508b0a9cd0142ab5ad06789d14e4eb04ce00c64d80ce8a1abf3b458c81b6bb4b28e6c665d0585c0df88794e18635426bb7ba8c2b2920395f223cf47b4d5e4f64106789ee626ceb50531840e1b554d563061f3b5c38e8bd911a1e66d55b0dc650ae87a0d32b64147af38398f715b3548844e6c2b7cdbe1613bf6b8718d08b6303924b0061db5c393594f110fb1f3da791d3a266522071ef476acbfda82b889349455b9accfcf69ae7df76bc8482ef947a7010fffe37e1f849ea491b4c379674511a8ca81fcf7624b471c66bbca2d1cb5c53dc97df0e4e2d7d0f3237aed3926e0bba15d7766a8f3ed6ed383f9f9a41c47685a8dfed6cb34141b2059fcafade4031a754c940612bc50d4d994fbebfc4f8936244d8bc81e0114f6bfcb760a00c9cf98cbccb7879c2c3566ac263be4b0a6ed7e06459dda899fd47aa3efaa1b7e8b9a17b0a0ef792cdf1a44a5e9d3248b02194e38089ec1f173cfa0cc031b351bf075421a9de168f29b8ed6df14d42eb8d7d2c5a95ff9ce27a5cb686d3e8d33e84203a302df80cb7ed41c232f148a68a276897770abfbe72535277ef81bc3a7d254eb8b57ff9166513cd58753a37894d4d240876fb759aa3fef25997820fcab4a83cca7a40c0bfd675657581af9946976684a0b52245f48826aba65648d9fe000168d328ec186b8bce86323cd262d3777812b19888083b495b6e5f9f44a2243c95bb450f515d87b3af07ae77f2c843d1152e51005dc578663edb004c46ea81d2f6433c4c573809ffb61be988506b909c9971e92c93096b9c6e1ff21bc5bf92545710a413f996d3dfa4e5f89a550d992239653b5210c0afbbd62b53b463cd808f9ee2be0de3a581b2114f29d1376235c3c02190b429426826559ecdbaeccd7cfbaf85d7824683176fc261f79ea187f187b242b4efc16b3dedaa00863f133c32d6d1ed51dc73dd7cf7641d28652b1400f84a78e0413c89c70db71433764854dc89ee5e3a5fffc65a822e04281c224c958f1f51c98808273899613db3750dac009cca2db9a4137fe4d7cedfe2c9a28b04d2d1efdb41517d61fa14652cc12cde2d992bcb09e46ce6fd736aab6211794b5a22e6daba31f7e6c1e669693c2015f1f3950b582a35d2f5725cc03a5d81e0bb67907d22da8a701f758640cdd183f2ec04e7a4ea8f71d0e1e90e56a582431a98ee95f2b1f685b574f4cbe0fe7c379e557589935cf256abde367e6b9d849a6c798972ea4f85ed58521d9ff356629c05f37a5d0c4a6db892fdb6edab60e8854d28c4dec35b30d517f32d701af848a9f90910b211e442f9d42814584b550566e734e7f48e555df94934894471a929bfc58d8cb130a814c303335d1e270b3e4b17f659ce9ce018835b55cb711d4d5c14d9c44d840b7401c7a40abcf8a8e15f16cc3a6d15d1a95c1be56f242f7d4cc3793a7efa205c89603c12f9322d3b6a41a940a8e1956afcb1e68223f8df5e91dbb4d7ebd0dbcfe6123c7a0d03a39a4f6137d928c7b25b5c33528a21fb1ee206c6e330b750d3afa913fff4fc354f7e5d7f3b405e60b365d009be278d700dbcd76c98f7bd5e7e46ec4a3ef964eee737569e3ddee236c245f9868664382d2796f24b42ca934cf3852a1e5ae25827020ca984287e80ee819dd9206680548bedaa522e8ea33c749f7e1ec84b54daea96bf29875c22185dcc3ed7759e5eb79e685f2e505fab247f2d723f2bbb287c8c41e7ffa3677cd3fcc50a443cb12ccdeda0be2eaee3648c1345404fb46ea567807c438912829ccc84f77014892762e56b9cd8fd53ef983cbd15bad7b4387c3ec8af2f74c2fdd878ec0664c5161bf8853b18bc5f143648904f4f641d3b36c1f88a6998d949928e70c9218108037233b7c7d3e11fca0a4d876a92e69d52b6734dd94a7e396d5408d70504c13b73b6a02a546aa44dfeb257248c49c8e0458e37d9e5fc3f2c9500a0e547d93f9b0fa787d1417cb7b9244f66486ad55aca25fad172cd0057a014e7a6e4cbda8fde5189454d6bba5538baf594cc15b6bebbfc5bfe8fba265d911c7ea2ab8dbbf283ce2300e04014bd57f44bd3e4791f5d752e0aa3f66f53c02e5812ed2fceab19cf0207865d2f5a793b8153bbb2453c7cf21728025d2ff5484fe8fa309258fb6b475d861dc93e030034761dd0c517e219e8e35c8e2ea14ac12bae21b72d4d0c164385fe808b3322fe95d4f6622d36d9dbb135824a051c67f77301f726075bce432573065007d0a42c59720dd742472d6c6f9898230c00d375d0b4da11b777fc11c01f93bd5febfe5e4aa476dad7fc3a6c6df1d6dd94336b6a9f8cacfb06d21a2d5e1bac13d0bde30e5c0e3430abfef19f22942a636b66420a7efadd37d57ed3e983055a4acd40fbda6c93459d9003a40ef184ac797cc1fe893e4bf0816a343fd73650104775edb862300366a3761245a9c1dd83a0257509aa3b78cc55a70c35cbc1b8bcbe4643be2407daa606b2d5b7abb010acaea064e005e149ffea03baa2fd3743a86d3b22d57954a2b5ec80f770d4420ae6c5ad85a0fed6850741db3b5b7f5db1ab8de483224e61ca05433c97175463a37363f9e1f18dd720c9fa66a082f8cd2350a677b6eb295ef8e8f49ffdc26071f3792516bb8422fbfa068065794b81b60bae04905a770b447dd90087affc18293ad3972aea94cd8cec60de72e74c32a7baedeefe803c296edefd3c7767bb172954aafcb28ecd8451a25e3271448a2cbdea5b12aede7f84cfc74a0990008757134d842707f4ac9864ab15f229339228019b8acbbdd4334230089b1864f56aeaafd3e8b519a7270a2078ccaae58967e923cd811cb8c885a64d670a43e2080c6510e689b591efbe88ebd313b5bf70bf10afebd755135d227877da857b9441d9dbc85f4567aa5ba86330669a1086064b9db37116e8cd9dba3e5e157f04bef8cb31b49a715429a26616b8e104fbac1e284750535ec9048bc9b23d84896d8a75037211f1609bab8f8702d8253052937b1379b71ea5ed8b7ef4164fe790f772bbeb64c0acec78395b2a69392ff90cb55dc7f6b6421d40c22508907672c49911815f2429771e0776c49b25b6fa27cdafd36ec57e91e9edcba3574831cde052798a8eca8cd7f63ff967d1b449d2f8e3bad8aaffe64eee099231735a6c92ec678f013336606917c2ed076d1a2a864c0ea6d8373e3921a718586cf429718f829c1c08b20af8e0dd5d75a87e50b252bad18edffdc5c9f33fb5f1ce3b765325c07b8d70f54c0c89e280626a533bdbb88c2de377ee9a4d0968f833bb7518ccf9061443ae17d360aeda2e312f3822fba8ffb1fe78e0cec026564e5eae328f382e14daa2a9b3b0ba3ef29b8249279705d31049d774d5a579b9d43508271027bd3c90992bdf0a10c73c4384d0d660c297a4db4432994bf56dfe2fb94cc53befa7d3275350f60d4e1873017da3b24b28c1843a5ebe1f087a29e8225415c450a56f2a16b4478f8d6735ecb2d0c598f6a86b6499e1a80900b71c3e8908eddb5dbea543087e330bd816682d420e51a88843eb53ffd82a3fd84e1abfdfbc2bd2dade9ae59447b08d724adb31cde6d905046bce66b1ef5c93449f093e986c0c76d5e4deb40619dee41dfadda288c134d3790365a8d6ec8f5741fb346f7072ad2be19790703300535aaef44126b43324af271a30250f7c35dc0bf7b5a0ffeb4f0e48a071dc99c98cccbb8f1d1a1830ca7c891d991165caa5840bf5c5e3b9b0b082a5d5d986366c20fe4951eec56eecc94949592b326913da266dde94506c6bb39ce4a80d740bbc5c2633edf01edc4f9cb5da8f5fc8c8348d10db48209dc1ac35875f5dd7329a3bf22c30aba7106243b94df83b3e009fc04b26e7bef1c35d8d0efb510b6aa3fc7ce033858d84c650468ec86776b38b4afa19de012e480d18614ef19c1e3b38102a3031fd32236ac8b96bf54a42ff4f30c5be3a1b4ca3356e0ef878c3d4d79ae9a136e6b16dfa00289afc4cdd9635c5b2ea884da91a5036c49ed949ebe409d2a2b168f9e56e63085ce6b6989db578e98c59eaba8b4f7c4bec068c86d86f381b84967ee6ed26607dff7419f92ee2693e120979fa793d027cc4368fb6e3a9a66dae06654088bc6c5224d02fb50639ccd42580336171dc077d12bd1396d051591b4740d38a91a72f4c1bbadc260c3ec4feff5f6444cb2343f69f0b1b3d7e1e8d9bddb49fe7baab22c51eb0737b1d8f57811961fdef1461718633f3cf7f09954d1eab1c300a28da468462d1d79b620cfee59154b8c5b4cb55028b402f8d6b2bc57715b24a59ee00aeead2108f6a73ea97351efa4962d62ad2838d70a7fc92721a3e46148c1547016082a7c59882ea9ec0f4d16b90bbbfabdd77fbdae4a3599e40ae64870c07966ac5560deb6708fa39b97b275eb22eaef83aedddde852f4fca585c25d4aa57559e7a2208bb13cfdaf70156c8b960de14867ecfc9de690d72b646eaa7a960486c9fae55adbaea50e3ee16e098478d06d1c34e716867d35c1c43b0752f54f5640706f3adfc93834aba56ccfa71e2c1d2911e619b321b0eb2724011c95ea3954fe5285b88a9f6664230ebe97d98fbf30e0c5296cb21a8caf26d25afd42951954ef704c55cc26fe45e7f231dd4d395d8904c94daf1449c7ff083b0bb5cfda787a140771362972580e16f13cd1ad9b774b224c651788c1ccdc1fd0b4c9f87397bc0b207e8d4dc93d785669a89d6847a334e378780d8c1ba74dc3492991b9eb35acfb932cdd737f6f841fed368730e2d364d93e15c6a0f9159139a20830bbf6899035d49392d5363f8c12fb052e7079cbf6f2dfd306596832a7495d726d5d2a647a296c30737beb53d2b260508df41531b1567735b3b5d6ac6dc929419bb51f2e9c73f6e89a61d002c46e701e967148e032c5f4dde471cc21914be8fb1f0dc668d2d1a1c2a90c30da85e15810d90d61cb6ae50a97063ee25bbe55823c54912a5fcde384e149ec347c4888264fa10943a729962d8541ed9a27faa933bc32467723ceed7f30a26bb93d2d10b18ddb5c678d56c4dc8bb7b1a4cd598385c4f7684c6b95ab2426590e3159f4c838a7ac4ea04a8389ff7e332ba38908bb6321f686931e6afcbbe4ca5bef9914f7e2f957e63b78695a2c72760cb54893d924078edc905333101f7829bfad97eae2ce5ae1231f556556f1a035e7ee4f2a3886d2254f3cc53e7554d470adce79293de5daac72b4cc0771bc7260e0b0dad4bdec94f87f1116821b41c9fdf60b5b6585609ab8655e74627cd2274c3a7ad7644d8a3350ade5de4edaee536a64875d0b5f018d6b2166444a95b4dd1a67b174d2c65a373b5e5b8ffe736c227d2c7bbc2b9ebba541f43942b5356b83bec7b53cd4368ec4793206e569736d153d785210cdc16eca31d2221e5f4d52d8569071f0da8e721f86444086adf1ea7c7a09c9ff16c7d1e803bf735cbe7faf5cc90f791d23e6cd0d499fc7e45a41c0a27e55324ca08a5782f1391d0e4cf98d1ed5b6825d0b4fad456c39806725d8a27df100334512f88bd95860380365da668f493dd98513af55af94505f235707a277c3cb48ec498357d73ae8ebd745669003f1f884ba0b4f3a736b2e7e5426ce1d6e8b30f81ec42341a2408db89e10a83c3b4115f26cf2819549048a793258ac8b50af3aa38649e1b20fc14b701cb279a1991cc852b427cb90f667826a42cd1e6b60efce0e8d55377be177cf01026c31d40fd77322be0c9b224af8c8eeea0fab6930f7313cbc846f5ccb8c196dbace941c561a83f15e4632009441a8c1ee642f7821bda46e3b8441ff01faed5bf700181b7f7e734bae4f1757cc656d9ac55535212b0d0bae3f1541c396ef919864e3c50f71d5fda5842ccf5fcdcab01c80b20bbcfe8046865619f02d8fd3d7c957019d6fae2f2bb2c1be0ea21d06a872134dc1940f5e102e0ff7dbd98683f3a5af6f0afb193b7d7993d9f014b7e8cd94e467c2a705848ccf8537f832316ebc25136fc95f7bac29a3bc8004c5cc01a065cbd978f3733ef59ca174b8805cfae9e8ed344b3b1f866abe4dbc3d462033f51807fdeb5614ec7b022edf79d8f435e546b9a66773bafe28e44741da9dd340580a39e43944a508c3b63a8b0c762b7c866b83e4b1eb0793e98d02fc687210d4afd1ca4cd79b050f737dbe01dfb1a13be5c485f11e39c85bfca945fa37ba9a8d078dc877fe590d8a404598fa0ce2f90ccb6e30d4f42502d1d80b2b197a67001d5972043ebf25d24553536b85abd76a05decad688bf490aecbd81530eb1dff2ea20ec18629a26cf87393c7ebb5d0cb1da75323bc73d6bf758dd74f6d08ca6d7db419a74ec30005d0b07b139bd2c5a7258fecd3dd71b635edb30a5b48d5ce691027684f0f443155e29c7b74aadbaab01e5eee3f7a86546851459380d2b6315894ab6655a5033ae4afa72806455caf540619c7b1b47672be58381cc26ac2d67dd5ddafa0d57309cb3e21fd2a4bb8fd787c35bbf8b2381e7297b299d0ad0684600c125c0fefdb7fee1deff0078e302ac3762fbdf227c8c4563cefc6742b7a1da3bbb8d0a5e55a6d8accffb9e04e02a6045a66e8cff84f3cd09a49a7e6612962dbfa7a801b4bb0df83b145c5c55274f4131768279b5a038fb8fbd20c261c3d612881ea636cca85581f6321c7d4dcfeab2fc43ca89127acfabd4bf345eb0e4abe58e5348b392f3e06306a611d4d54f4c103927c6204fa7527d67a71ef2daa6f7233bd650673584bc8fc096cf6e7235dd2dc7035e93ea810da31caf32bf5bac4dcae9c2eca598584f36f97f2095a93cfb09478dbb38e8947b25659f9969bc5a9a01568cf0eda2e7ad32edcec4f37fc7ff407fbca823af43c4dd61c6351bae5df7a4c89a55b1adf8eb00665e3edddb87527bc6606d47b3bdb3751ecc26ad9e31e3a79ed830cfb8621c94b5df613838d7323bcb492cbd8fbaa8de2e86a0c09a5b2364d6d124699a1a20b040d47be2209a7cecb52a691fdaa8e1b1f27d03ae5f9f9a1c004bf85c0d959d8d2b8abb5ff13d6912d6a55ffcb61d7eb9c0e5ac520d660402c94beb74fb96c91d33fc95979ac4d48ef729a1ed532ecbeb85822ee3f8629020d5753894beaea924d6fefd0ede184f788c0308d3744e564a5916143a621d46928c8271b6ab9620ed1b2de8a0d6257743713d88d4216575c7aceaf4e3c047a402c5d455e45eff7be935c64e43abe55e9c9fffcb5c25ac001f20acb2039ce4e2cacfe5125c43d8bf870d4b4b76182f75687ade404bd2ee777e0c21e253243235779ea9fd555f4e51c621bd252e2cf6f3da96fe408a3f38d7c0c44ebfd2ade8e86cdf91f6bec5b172cc7632624709adb6279f43a3dd5ce9fadcb46e1e2a3442dd11c4ca1ba73a8db41815889740f2bdb71af04094f11baf168c191aaa33adbc0ba07af94163c38996f68e54f670fc428bed22393bceb1ae14d63dfa5ec49bd4e2ef4dd3a7cb589aa5bd8b1bf6096b49ce7c6004d5ba54a8d358ea1d3547b02509258bb788063af4d8772b7024ee2e2dd3ed8013a4133f71b67b901a26561e66efc0a6fd596bc6f6296710f88ad6aad5597382bb465fba7fb67f84e6515838d323785e9d36527f86b8906fcf13b75c3e4143fe4288f66af303143ba7e51c9a1220efd9de4d36047075be6ca7edb73e1f9eb03a44367d74f44956da64a20044ecaa871c5e05d67ff11fdf8c59cef85c05e63bc993d455a6bbd6ee5f7c655c4aaff4d467c45deb9ab606dcacf13f0783e637b673ede016b41e37fd26652d8c525fac350b3cf1846d3615d8d96bebe506aa38e78ee58350a2769552d0e84c00a670517740b367f8eafcbd071db2bb1c94f2e6431c22c50ed3e84eb079f3c4720cb6f38c07c3d558f5b115cdd2d63e950d87638bfa7a3e56ad5169bd798679ac997822f6a9827adb9dbf9de6ce824c331e8db1660243063c8a29f844f5eabd491f9fa9549df6fc45e81e614641f36aaa948539a49ded5c101e1f4e8c851b4e3e345f928e32a09289ad3bd415267ea6227d30cff52f8ec11f44ff8ecae5aee507bb5aaf26fad0c669cc34670085f16878f625f3e39c6e4408481a9e100cfb2012bb85183fd31f26fd179612a9acbf2c849157360036af0c6d03aa926b84c1d0864008dac5abd71c7e584aa437d57d67322e0169be3ad6bd7d4ba6d266c0b80a01d9fb1978fe77062f5c015ca5652aa4e1971a572b89f75d0287f0da467e9a30cd89f00ec2c207334df3d14471f7c6f07caf14c44fee5cd1aa967ec0b6318d0726180619dec0ccc281994d4087f9c7e67961ec3a1b1bf899ed07abb666a38d349f297decec6ba026df768551b1521bc7771a66e9417d460931782956eb4b43a94f9ba4c2431515a617c27df791f46a04ce82473641e44b4fd3e28ae803dfa61aebdf3a556c1e34376e9fce70a215f3973c1dca4885f0c0ee7605fcc4a4ef73c67228ad21a219809ee1c9bc9fade57ca3090217e7ac76827ef3082694e203fe0f024e53e6f3109215ca1d886a4564d39897490e90f673c9b6474f7bff5b58f59db158b9dbd5f1186071e1a07df502a29a1a7a8475a9a32696a1bafa9d908b310100798ad91229f3e88f941d1d1f11aa231c6d7398db2654d580e3c2bfc86072512642f07d087ed7bfd8515b015325f80036ba8115c571a9be7db3ff342cb48de4910789c1c35e5f975d7e7ad871eb1e1eb4462f64a47b7f0163ff50906c2a67d0d006f302bafd9f609a32162a1d2fe8991593eaf87b2a8288bb0f87ed9008eb869f4957a16efab98dd3cf36995b1f79ed4ddeb1c147ef1361b77398ed534c2397e89fe58979745821cde3c2ec6c39af7721d853112cda6209ccec2aafa7b0de7124efda045ad8473b0c56376dfa086b108e11ea3b6424836d5162465f64c6a03bfd70c3d6267b341e27fb068a320a1adad0d250181f7cf49e9398b2d46e20a909b32cdc231e96b4714dfef25b3fed7191f53065b1f21c805f09468452894efe906b91a1c38257fc022b88fc151151b29ee5082e0f6edcea103ef213182fce433577999d9a10725a0248de5f2c223a97cee942abca6a2c50d40406c0f024e7010c0496b3ca12fb496b2fd9ddcb2c196fd8080a887faa0465b57751c2b553be5c470f1f8ae32fd61076c6b971f8acadc56e5de7451645a30624a76991946e5b55369ab690edd7d40fc3adc74e11ef002e0a30a45847f0d2e58dfa80436e30db436148eb91f1f80207178ae6f3cbf9998f615861acb58a5cc2c0905cb2ce2b9e8f7cf89743f0f18bde941dc76e00e2394775637e466105c5632314df4d93bf1939ff9c1292442f46b3ea366175c0fec8522c24f5fa54c19902d4eb41c973263c32e3739100680a3e3ea0e65c29d70805ec93d3355c3e51e2469e3179a8b786e29903b529477f89e35cad33c6ab86d3b6c54f41f22a930ca0978de9bb53ef188aba2f749a813a120e69558adbca4803d3d4757959dce339d1a9cc2536f030125b37f9bb615828810c451c986245c7b5cc8e1db8503ad421fa6e53e331dfeb8cb6765e855c0d904ddbbf03d86568b1b18a0218208da26cca294717cc803a51aee78f5c3d217faf8b37947abc86f0b31f7cd410555c3fe394c1abf157936322e9ec29f6d20c1df8effece78e46cf2bc677935d524de3f3a64f4482a125f23179b45073c0c1fc6497a7a017c50f9e2a70991fb4a59ebd8b2a9a94a8f0b15a673d34eb8f2d2a6aba5803ea8b9b59f2071aaf238c18333359e7b8b1d731eb5ac371cbfa782ea9e4920ae335fe910d5f757fe171e11bcca504414ac0d772338b94f6548c0770ecc6a9cd3acdfe6f60ed02807f3d68003d529acc55f65568e2277d9b1d87521f433d32010072b70ed15af6c16f812c6c79631e70e75001d5d913a35337d0053ccc17f68592ea4360c69ddd0fbb11a9d73863c3df0cff2846daffeb765e20e933228bff7658029cb3f17c289863ef592b6f9ebd1c6726d3fd5b546ba656e84abf157c9172969a63e3831111653697c0d25b564ac61e9bcfdb8651ab76fcf2e22ec4ea7bb10f7443be1913b1b483c23609cf9c6a375428817160cb5eb4cd10e8e28000739f6b61df6294305bc76d48660f16ca387a010ed172b285487c93df989e4cce6eaa30b2322ef07430c909a45641879775e87dae25d42e7e0d0fa65406e1b93680b3f5a2042cc7c7c9df847f094906fe16fa4bc2c58edd97afeb815d8b4e076919b415e8172f4e240f43756cbdd0d17a3d168bf255c33922ee56c307d7272928b302b93411c8750d299ab10619a5a6671b6c7e5fb1971786614785fe73a9ae6da7962c9023cfa69bbb5d37067664e16acaa60bd35c7b441f81d89f87686e9d083e4dd1ac69b79993c6312f0e3cb76b3f1867ebd99f8479d10436dee41f44a3f81292ae61b13e0f3bae3c2e9ab60cc3e48e9e497d0cd8b47f70016249e63d2e7373173481235ef3dacfd1a5b38e0074fb8f57b465eaf32c828a692d05c69cc36755fdeabf5bb9ec41701af8843ad5b3176be4434dfd3859c9ab0578230b6e991b346ba6e51c976649ae8a3389bdb4d97783a7158863120b7fd39db1edbfd5fd5e3ad899a12f587c7641c3c44e696cfa7656b70108a475bbeebb72c67d5bb298bad4b168b2cc08ffff8ccf50e4c2f259fdcd6f87c993a1a21ce45c5ec355eb891030d57efb7a6f8cef1258d1f495bdaec7057718f29b1ef61e6f3fad4ee9acd55cd9abe148c190337e5a7c91cefa5849b0cb6d02f477b1666ec40e983bcdcf5d1f2955cc758ec1be714ae56cd23a3b3b77c362aa964853e912abca2372ccbcb077bb0c5fa0f853f82ad000281c830fd207e71e67f45e87b0ac8fe16ad433c837b813cbfc88901e9868842671ea98d8786cc2a172ffdeba359b08ce36091fe380328bf56769794d9001da3936f997addd9c1f3ddcbc0862c0322d84b080314d9040f5a960ecba8520735df16fd9d260c249bcdac8ae2aa94e90789f3f18970851b6450b0bc972224f7480d1436a9d1c4939ef711f3829b183c33462757d4390c3cd3e46e5ba2fb9e39447e8bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
