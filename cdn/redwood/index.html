<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99ac0e4d4e7e1ba230a24c8cba381f23ed27babe2057636a58e7486b31e72ba1aaebf4cb0328bdd1bf3ea78efa422b42cdf48bfa41eaab52ae9cf84e39bc0c0934809b365c16c638af38dfb7245cef41f3b98cb48a659bc63f929950081100f2ee785adf65943283f3f05f888d1794150c39035a889d0badc4629df4a7de175d9de6d4939df9735a6f3690a011e072e4bc123f06fca2e51805e8a58377ac21a3bc9003fe5d05ec1072042bb4e45c53e96e14d7ff3c42df6f6b35cfe3095a831082bfd5be44b7cffc5aafa5db28d507c79df6f7de5ab5400a01c2c7cd16fdccca38d4be832543327e16452b95cf30afbfced9699560d20dab3411172b18e6de64e5f0f9a3fd70669e4933b981244e4ecfbc83cce00470b078b2bbbd21fc4ffd135ba6718308925db71e267e4e24d686d485eb845cb53ab0c49f51cc3cec38352b27c5a2766999a166453953a86a65401e43e293941a52a8428f6fbb49176b88cc590ab216f1d16477e374ef7f1c2389b6dbcf16c3ae8759c843152953a7f889833cf45d045aff2a44ad894981df5cc722253f96feb5a502f7a66fb1c785d8efa06c7ec0d9996d949baedb43309a6e6d5eaa701e8176c80a4518f6440319dd5042a69fbbf90cb3a10616d110c2af9704e5a162f248c8e7c5571d7392ab2b73f231dc4884dc16709ba54b6210539e0e239b6ed8487cf5483d8fa8b1033109464eea6ad0226ef93daed070ad5e28ed2c9ff5767324adaf6e5e9c63de55a3cf2da7c32a5c6502769bdb654ccc3c42ed9944bc3fa215f1e6f69ddf11cfd1c881680ec44b74ab624ed3a10c9814c6bec356f17908ebcb89eeaf5eeb675151b259a9c94de96044cbeb4ade3083c3ff25c57a635a04eea30c9cc0cf217892686bcf4f229330e7a00613fb69f5533cc40b2b0f79ef9c92123ee8b34701735f77a40b601ff9e7f6f7aa26f55f917996a7212f872bb2dc10254bf242bbf8b0bc289166603166f7fdbc41f22f9b5db009fdaeb6965e43e890d01fa2de1472f79bbf39a8a8a981acaae3e88a96fc0890c3cd837faba7d6bb629f0b77a929503ae07e99651cf3c060fdda203741898b32ddada2ec258b435f79214eb415e7e780b75c77db6bbf63d811b86e151006364080963342f7fed139e205b23822e5e73f13c748fd8d6620117dd6cea9afd85cba9eb4c7c87a4ba53c29a97690dcfd2f34809e27491c9456893c64de2a0a9c6efd56a9680bbfb5b167349a1eef5ba4d082a45539220bbb218077ffe72baf61f261db59c8861191a4e3cda849722fce38443b49b3286ef1b7706d7ae7e288dd65b752053b2f23489f94cd9a517f296b085c465adb7ad92b90a16ddf2b33a25746d4fde78de0ec976eb2980a370b4cd2c178a3bd2d47a96fc829eaa31c4fa8c04750eefef1c521a0567861454749ed203cae4cc303cbf77b4a199e073473396658ee4d651cc001195a1266159a1b571058c689897c307ac7fd723aafaae12bdcc89cca44eb9d54c78ebf7de71db977677c7f1e7004db4bf02624478edddcc01e1134464d4fca3ee22fd3704c79fcbe2f12f892355ac3a346e2db72de443aca7e419ccc8d992b09f8cd3197faabe57e877711d0cc8d3edb1ea7e029503e66bb2c47709ad0a7858756180475384f7671a0b74ce4f7ea391b9394bf7b82361195a3661c86801a9e2bac80b2af5ed1df1a54ea69df8d3c8b3a26e52135d2c501a1009c0531a4dda3ccf0e1ec39e097b973c4dccb2018b656f66e5a0624853c4fdb68c8dee7c7dee837e90c2ae09a9fd4046d34454a4c32d5f74c4692ee5265325b4c3412919f2309fe4defe5deda6c324a1848201a031f98c84dfa4bca3bc242052a3c95ec0d0c9ab12e82038d3a08d891f92b0160329dd2c2aa24a7028211d573a57829f410f03e8e5ab29f6e430c6aeccdd73cfdde611a810bbf0d9e4db3db23f9d50d97fd8a4c03c2bffce3e52ec95273897ccab08c4bdf86f91297a8e221a88435125c252f18e12af5ffbcd9582978a26700bf8354c836db014c5f68780c5310ed124e25e37dd8c7e28b3f73c298153e6cb50c13af2d6f604ff8d7e29f4bee9545b18c8cb520affad850df5b57ef4444d4bdb721b6b830cff04448f4ab3d85b7eae8c2964dcbc6fe75fd3b36a1a3409e3a6d44ef199223f16386e69e8b362d4d566a34c5024c257fe9b258ea91cb7ad8c6c78fd14416ea9ac8c1ba2ac3d07ec17a5210319d2b35bf21ea43f58e819ad891e7097c413e926f88d2efd9a94053afcad213868485930c47a165a9b96dee361d99b5688460d9d5c2ccf48e853eb0cfba58d342765fc48f0c1a577650f7abf15a69acc696ffe4acaf64dd507b01cd6232d8ec0aa42bb2f6bc640f6067a720856382678736ce30056ddbf4483ea4240149e476bed48dad932e6a64b3fc3b082173b79287c9bad48104780d0dc8f6e867e95b52226bb8690569fc17bc668690614284b7d36c540963fa11d520f77b6206d8d069e7d4866f38ee4d5efa54855a03b533f029300a87b453f937f3c8e0bc70e61ae0193f8c8cde1663d045b3c1f8b1658f7469323ab7a2163b89e715f331c7fe6a99bbbff1378cbbef732badaca6e6c9ae1c3d7c0ed71622f62f64281cbfa70d61b66d1d71c4431d9212c3e026b9a36cd8bb87d092892a54fdd784d2c19b9fe48b6ac49d70981ae25f3cee6a840d7c2978e5d4929049f659d1ec59fd2834b3c465606807df26296f3a4d2dcbddc45d263e6af489360a505965c0a2d119c9ce290bf52097099392890580a9590a59eb02b9bd116651d6b7326fc962aad25fd490b32b1aba46973398f3811daa855d9c069e94c218946d9cb68dd070bb6e15833d19bfc2b0facf9fb4d0852a932f5f12ebf3bf224d5bd61c6d0719a8b1fff7d9e71c4faf6afacdc41513153678761bccda65ff339afad098425611733febc860e64743e567fa6ef111691cc7736d30dac8d63e2d4635dde65c70fd906420b027ac83c30393e44e612c0112f2049b24861be8aff68616d692c9374f8437863e9c0c5be8730e9bac1ddcced59a4522a15d81b1807f9442a396a5016f47fd4516ce8e95bd1f934f1a8f736958ef54b93f8eafe1e6d9bda720c484324ae3d60f6f796b089518d295734409e6cb218f4a201734ec31a0f7cb45a5829829fef5efa6ede555f72f4c97c3ba9004b9f504d9327da284a2cd5bd2aa35244126955815f4f16eb1cdd7b81e226264614d67a6f84adf80218ec2965114111e482da932739de231918866a8ea23a7e90a32c6020c684b4c7fd05bf4c061f55b7bb0932afb71c75b09708e3dea007bcbe1af9b8a436c7e724438e38b99f1ca93b88adb962c215da7d54deb3610899506488a69983abcca45f8af2be32d1156222b4a73a830344310cc9011d48f259bde5829a7c1e192196657fa19dea9d137244882ddb688c574338a7b8cfa92b7a9922ad1c505ecf61b6e20c56b8ac56113961f39d401e12ebc26c10952754721405009c6daaf481a4550c05e4d216dc5327a8703e6077b34776071f63030014ba3f9e66c6507cda7fcc29957481d22beed24472763126f4579d95e4a11c018041ebf6428b831f75854a67a794c55339f4182502442c05ba5a1af1a276ff9d978263f93aaa36a70ceb19b283d1c846d287f3f9ca802f8ff78224e16bb209106b90e885004829b677c66638d885755e7205015b1a6ae3dfadf05dc284458e8e6062d4031486f7b4aaec8872103d49d80938d407e6a83191672f499d694008cf2aae9e296773a6837e8a49167053f7cc8be0bf0cec3ccf6753ba57a4e298e5998f10901a4f24ca2d05fa7100a4e3b6465dda2eab29d2b27cbd0542092addb76dcb9780d80218d726578f9da512fe1bea3e2298af9ee7d4ac5cd95f78209ab396be14900217aabff4f2b903e0c3c09511fe88880607d57a8351d70081f6614c16c788bb4933d730cad3f4b5a9fd96bec3f57c815758ae164aef98511510209622758dc38ce24105e337915b02263e849686d8ba0b2e5158d50f6cdf3963053696b526298d3f246e62e6ea36bd79a0f54476d789e4e2dfce8bb7410df56909593d6643f702193b6e8b4d3f2f2e59a0d02f12f4fb6dc60d05a0f6e7bae9b12ef019dd409814ba25d60724a0d42b682768708444beb139be438688d607a31a121f2bb530b7c776628e8f7d4b778c6e1a2b50931e5f2946c22aaf4c47ea911825500c12f7a3c76a8c68e00c13628cfd8c4996bf78f09444d8db2cd2a160f57fb01c63c1f6e2f0f95feb6d8aa4062f2b7fa0af9fa8a03f3757652ae7d41b51388127dac49c7db1a213cd37ff66c829959fed8954f9fe0811377ff0ea88ba2a526108362c2e0508c7e3db753481f4ff790935e83f7dcfc8e772f39af984df51cd5c9973545712a377f1e1eb5f327b52d3b052e0bec238d5ba5e91fef25c62139970dfee6cd19ab0338cf54673023c41f03e76dd9e357e53a5588a28d76692a2b3f5d2a37d220ae4fd3ff2024c96fb1a1a0a7e5ee316789d48546a9f348fac6fa608224570acff6de1b2d923a15d17748c8fd950d556a8b73b79a5df4afcdd856086f37deda1d2051967b624336b6d6d18fe8daa0271ad11cd8bc4b841443b81583164fb52a39d081cc2e01284ba57d4338d3d699450172f1bb104dcc197f3f04eef4f4a214af65a1cf19ca924610c6585443b9a28cf9ba4ce51e938a912f44dd391d6573932d49b9fca9f6fd4b221f9a16e401f2ce61bae499d4114f1b7ea8675e0744bee3ad205e4dd31ae6c889d0b8636f7d027791e73b275a6372b6213c40e8c3dbc827789dcb1516f7d39015d6ac34b8eff7841108623f99c54e44d5d8101b7f08bcac563ea301d897699ec2e9d7fe3d231ebf057e3751889821a1fb478c1bbb53d4b16f32982fa437adcc026ae8d037c8706a61464b7b458f766ec296184591d1893f0bd0fdf5bc9f27b88ab6f77b529683d2d6bb65f1b2078492963ee3961e3907f279a64cddeb8640a224754341add669324ccb7f1724c080b8f6d85f98277210cc8c3422555a0fcbc1cf324add02ade784a760947ab1b2ce76925008811f9ca4aa4f0a2f8584eda9cad07513ed06932f39b3555e001da9154978dbd9339c05e98e16831db3d4613e1453d470c40f2a6fa3356663a9bb1cfac0111f6bba1ce0175a7f6da1a6a33457a517ad10acce6c4cb1756bfc4956b298f444f6e1c40d87d8fc8b3b7a435168285a6132c8fcd281bfb1d52bf961670da61fc6e471bf816ff9600a1058e83bcd24b21f15ff2e950a7b6a581ec4a0f39df20bd652564a147e1beca5f08a753077d4590da0098bba9c8a55dd17fd62950a32d81b5fb6402e4586211358360d0de5b4b811da802aa8002a88f13ff748986f7a92434beec1fdb26e35f998beee41f3a4a17c7b151c35cff9607d4baf191e7f3c64d449787bfdba808c63faf613aaa3ce6f3a8a7d4d7756d94857ff0c8f602ad04bf26f3807c0fb260530026af94c0775d7f317ba20295ee89e0d58f9a2880e4566a12b0a2d892c6cf97bb5693c95b0766c6cb3f628b354f47b3e9bedc260aa9f922ce12066c107da46365f082aff853efa8d79b7c9f451990b5071de40b5eb45e3d2b38fdd6f2a5f5ce095af9b80a778a42f2a3697bed98d396db2818f6519aad739d6c4db411075c62cddc720c31046f2d3d3860cea59e354d1671abbccc473d249f2cffcc0513ed1a6da369357ff0cf4ecd52d5454eea777e8e97b79eab7c8f38194f9ea658faf1ebcd90998be5187129d51f0d7470874593a4e599c6cbb88b5bc8d776e580784d4e91447aee4a24960f1d63b5224cd6f5e20ee2a6f3555ec97b282053ed01e0f607fc9925d34bf70c965b11f6ec0d45766f1e1a8377bb9dee21e88db8e7e80954b965794345605dcfb1d16ec1571cd1d730539bb9582c134081a7efe54a3c3105645e7f26e742783005b99d20dc26d6515c99d7696c32f3a1a4a651e14a50787f672f994ac55062e3deb3bead635b1314f116e11887e21d47a7cf27d3adf8df304782f5ee03896eb0e3a4dd5ed0ac103120a1a551672309f972d9c6da233b57a9628ae1dd690040f0e787ffe6829e3d9e3e01ba1e5399085c59703a8484eebd83c397a64e0dd266a4a06bce82d390fe7d3430655c383ae7a9053d223b531e5cf5bf5d5c6b022b3d7d2a1f2b11509aa18c47b45f1b3939053f7201875f21cc73006c30b5f6b70f7397dc5d546449dce9c66601c76e1d30b23a169a26f933a43e991762a5be29f2b75de9308d90e3ea0010461e00ed5cdd97fe10225632c306d6084e34c7be8dbe2adb891808729e356676d9defa61b57976329bc1932cab8e06cd4e1aed1b8ead95622ac2ab69e20ef305917745746fcd991f4bb8b4237201e9c7a61e725ffaf802ce4f94253d13c0ce7b8634881f26949a61c6e0db6b3049e917ecb733169ed3d0e0128f80a12e1cb190b3451b1f3929db90bec40461f02427afe6d00f5ff6b8f9214a4ee961b9ad81f6cdc07553169643fae9f0fe634d549665bd8d4207b71068cec75565b3523e957fb34b74d519dcde21abe6b2faf0f2d38ca59c2ee0117898e5ca2441cbd61253b12f933566f1ab67ec745ded467f1424fbdab0dcd2429ca5aa6b84cc5c3da2c0e44abc5c32e38657a8f2621ecad58979cbd5ad128da8f9878aa0f6b1cabe23c68ea56f013c62135af5c97eacd6d6d06b34c2b5a611bb9dc82f6009132e3479a6a961a4d307e06dbd23bf5371ccbce659a4c4c81d00186aef1ed78cc9f87dd880c1857da311d94e1ce07a67471920a68220c33e33db8bd9f277dec870aac2791aa2d48c5c725d5e9acb0585a8e6c6f61f433e6d62c231b8edfabde8538be7d6c6ef47b00c8a9f20415782565bc15b37cf02ff2d362a1749328dcb5c49a42f91c4671688c19aa387d97ab70be5c95559d68ab495d667f5f54f6a6fe78859c7abee53bcfe9d37ea4f1bd7884bb9110ffc958125dbcf700c0fbddb49a4a4a6f522081f7dc570a9dd7644e5f664e94d5649dd9fe9f6d84b98b627c0847e69192553f1fb846685930d44119158bd2debde973c01f6db6ae32cd8b1ec9e3a4e3e3d1c750fee771733c65e194ff3b50f5264172c129329ad91910426850f2deed4059890e67d80e5c976f601ef3d52aa084c0d58c91df14dbfa804609059b740e9a19e82feaaf58f6e87507e9182fc463a443cca1c10dda503f3d660b743805e34ad137a995468bc7e057ed597c6a5c5029ef067e30e20366376bb0af9d1e10884674bf7938ea97443ff72b63025a7980bff3ac9771341f2c71af28a08daa67748589f41070cbd5f246f68e151fe7f3b762bdcd703f31e6562c3e27d51dab3df2a4d0c9515d69706edc2b7908eb5b65eab7afe6f4072a857e6a51cbb44804f1d834a4eac63dc67179a9bb8956a92cc0ed8498ef193ed02a74654f70d148a836cb6fdcf8c9bd50d559678a649be9a18c524417326221555599b9eebb90ba16d88d2ab25ad1887f9fda1a402444e69c2f61f55bf1f527ac0a5be3329e48f32462b02a2a6ac0ef6dd415bf26a1dfb7478a59a9695c12b0beb138961197fc94d4e0703934a05819c526eab82ffca933c77b10c5047af6a3489793d9e1a43177d554f4360963879ef590f0bf60d3fddfb924c5cade7d3750ec6c26025829d2c02f67d4b582f991a88b8ab2af8005531f2ba83707c62f5ec81364e30dbfff0679d3e40b3d8031a2e7b49e409d26b6a7c46f571679aca234992d00bd2ca9a66107b0f9f9de38fa71595b331d7852a5d4bdaa44d1d1c975b58ce1a48d0bba90a418ed809cdb7750967937df2aaa137b0dff4c43c3c096442cd7b442db6684f2bda66fa52260bf3390b180c70b1ec8b381a31ffc94bbaca72921550c9c573f9cabc3e9256d1331ed9c0f972d62dde005eab59eeda15674b3f717603219cc07a910cf00aa4cf06816d8ca592e9227dc32b1dd6873e4348686028289c52c7df48b3de9e46d101ea6aceaa412d8608b0df83f10b4ff6b50d012804d467b76451ac3685d75ce491f1db10cbb273fccf92df9a7fa11545f1a1e7356acd89866ef3899ca41c4d43ba197ec28b9a193eb6d7e72973f9d46e66220ce62808a44d582907b887778a763725fe42093293f28ae0275e266a19a14ff3fe42a8ed3ebf8b3e8c10698162c306b1ee1546e9b38c0406cb6a6539f360aa65a0d41fd4df45a8a70d2cb75963f6890ad3370335d55b504d21a2e17a344a8c6d1a4e69dde43e8ca87cfd00c51722161a7d6e281461e11e166f4a07bc38569df3a04b0f725c7fe16398c42325da0b8bccb6a62746c2cc72048b56f042ca5ccb183391e7a8d7c4d9236f9de3a1c83c7a71180f1df79ec7b8cab26653e4e2bf71a65108b5004bc3c90fb286be76be06c79c302622d0328dc8c9038835d034abe37b38820a8d23624d9d70b186c0d548044b299f12d142570275d6ab9aff66a888d398d0ca54e49719e8e0d317c60e2e1df1a4cc07d26bc9b4d963bbb02ccab0f1a24535e80ec556e76936c2f6a38de2f8a4ef8409c448672277e16e8e56c211cdb89e86a37008162db34a85f3b0e428cdcdf9979ca9f5aca06674358124dfab4da2d75552cfcc4370ee762135dfc0a5b9042e33187384903a3ef39307b5e902f520641f83b23bbb69ad9c398348d798183b24aea0bd487baa8b28e596fe14f176b35f2bdaee9e7a9633c24632df2275c03b2c4a83234a00c5d7710d7d5233cadf87e19785faacab70d00bcbdce4c7d41df73436f5a20a3f29d956894531d50a1359ae6dc7d219d2865ba571cbe91aad8069b2d80f6f90f6b050e2691a520661888a1d8dfeacb29845fde254166efd275095bb593dba28e0ee1d29a51188d78e942f2f43fb5a760e4bbbbcca424fd044bd3f547a145374dce78161fdddf0b9d65d497f4ee2b963bde9168f80165cec50bb847aeb93ef75ce1c2e67c76021a4cdfbe8d3960ebfd1cdc4c17ad26d12ea6c01f0a00dc59070c3c6b0147b4c15f9af35dc33bd00fa2552aa81b23bd908f7466a4f0f670beb187a07a65a1f32e8f428ac8dc82f7ae6b84b873ab98a2191cd6b39f2637ffb8208c8b102a773018f4f2afa2a725a2b4f6c8a8f356491b4b5792ab8a06f3f450e967959d151cd1b45ecc2d5f10de975e52b1d6792bebb53fae258a799f9e35557fd99d89da7a6ad843b17a1212baa672401794c1cd566d2bea9a0b63321322503ecdadafe61e369705ab2dff795efc9a1828f32022a9ab750c3f4b899e052a9726fb2e87351c3f0873011d77d6a50581f7a13a20ab94884ef15a7c7afcc831b8a16efd6a98358cd4c2707271a635406afd8c693c012c3ffb9721fc4755566c7f16ef38a56199555d6db256a2e67874961a6a1a0e01b6c126e3b19c0a04b01b58ab4f01903788e8734f4e22c573303d93111f2344ea19a4bc8748ec76c90c037a0f3b5f11b5f0257aadc61b7887452a7a9054da864060e5869ade74f6cca78ff0a0e18ca26116a7f9f30e4663caa97296bc6d24a49463d4b96dfb31f2b68d2e847346d7180caa8074305db8e60891b1da9857e46d3910c4178f12686c2e04e1a2fbfbc9ddd86823dc3ac0cb7671312a92f85775e30aa4082ea0e7ff5466d4f81518637565e401f4d14d21f2da0e4d0cc45548948f48f116957709033db2847eb91e17c6ed21856d23e83eebfee1e3b7d9c12c682b39cbdc417eeed6f672c899f0b2a09f55e609737b557dfda50bdf6c05c84f6a72fc1de77687f6ff2514cf7c44cd179ca3810ed76501afedc8d04aa070042e249d1517c489cee2fa3c67c53f24a40a677b55e51c038f18ffd4c5119acb9f341f6f78e10684528275b07dc686611c798f57c9448967a0beb79d5be9427627ccdff0090999720ada9a15dfec963e103ef6f873e81054eda315439b8c97eabf1a1c7f0e42116517f9959b9cc7ab1e24ce57aa0bd5990fc8e033b97660816663c1216770b65ff64c6682ae6ff02c2f3f947b9afea96030153d9bd687b546d6d7cb7dc25d217114c046410b15ac5bfc549aa65317132aabe60ae2a2c187d94b4045d563a701f5fdd4b097a8c869c71e34cc9605042946cd9b57860a9c3b5259236206cb6ca342d1bf83beee6f08d848a0bf008c76a50ac374b0db239871e6fd2f25716145d7445f23d08295fa379a41218993f20133977925ebf7ce3ee8558d400a593aba48dc958d2f8d10703630f39d1a3a2e9d7d8a3becb4c411464af3a1642751f81763dc63ecde98c53f36932668f449be61bb6295257db2000bf5fe9f5aa02ed2fdb450d46db3cef27a6d57ccc01fe9ceb011c10bce1c9a395fbed188569597e223bb6d66b2f7f9f8583555efcd9b9b097e46032c12bcda1c4a97d2ef57c679b7f9ee0e3e8d249ba91f6ed614179435e92aedfae29830e076843aee4f2f3cccc795cf5c39cc519389fdc2c7c37f16a1674aa085e319e503ef9869afc497e29fe099ae8eb9b785f79226d9e2706ad84f55f6878ef24e9853c77703cdce5cc89084a3be0597c6887ff327e42b5d6ca7b0f7a3537221024df062943f03ba90f9b01f3bd2ac01889c2e71f6c014e44f9b4eb571ddf979044a1b0db84ef51bab78c704a26bc4d5b08af92bcf4255c728eeffeda996c83041be8f0537763de3c347bc037ebc3534171c3b33fb8b404e223e7fc0a790e625d9ae16acd73d7a289cc420637e3116170b5d3e1cbe57328e7c87d38d9400cf496a5621cffa32be7ec6068ebcdc8606b1dd85614d3a0b36de2e91a1127bdb5b690224f5e084dc05a672cec79d1f8984060d213a60216cf06a1aa0d5f23737cc5778bfddb6a183003dcdbd07429c8167f8171c36913ff4a3ab1ece739cd2e42b68bc27dc6a24183ed50099da32ebf93dbb9ad39d963882653858b351314c384303f5fa03d1b8cc6b0bcc4bfba17eb9750608973ef518f9c194e2c4eb67ce0ca8157d0cf108900ef53ac1b71823edff422487b49d05c9ba6884daeac7d7a17933751de8a8ab659cfd67997e0d14be22d38832e10aca07ae0e2612a1f10242958a7eb77d24f512a5b202c6b7a129a20253afdb87fd1f4441bf1829ce6115f3a05be6094beafb8081d25863ebbc1d94ff74ae0f91b9155fd03935c03a7919a1a79aa1af26f36e769ab30207e197431ae052d44db96740df1ffe318410dee5c7b1fcd374ab8658644a3bcd95ff990d6158e1d450b1e047ef73559fd255bb5c87e612a980e80d9ff69f78105e7228adeb9b69fb644717507b62c12dd5e86b950eca371369e580a15bd228fc7acc2a6fcb9017a3e117236d8162c0dc9dcafe1b9a7be5f8a413886dafbff439036003897eee5e9a990a501496da8fb39758539c48dd73fd0981c44baa8ba6570b69d8813f2ae483a471c6c983cd483cb12057b9a832966ad118f3938f1dc3d25c04265d78c3f44d8c61c252066c0887c66f2493f9cc3d67897039fe2606238f93a3be335cb788b5db10f245510baad379331145b3411dd279c8eeb6aa586a0862571597f86a4b50505d99a12928bc587f40237879852584aa8750706a2b703b5d97e225cc79b7d16a494d9a60ed464661fa1066bb08dae1ef152c731e3f2516184e1c8f6fa035b3284bb994a5a5e4092d49b3c692010ce9d2f5b450571cc6bacf2f80fb6f8698997ac6952acfdc5297788ec498a5a4f526781e83b42d6073154c972eb223526e78f94cd1cfca8718e6249d13daed736cb74f9a7155dc2db9fa11635756a653372980081a8054289ab0a552eb9116a2f5a0f990665963d8c09ea2c65758cc6412391257493afd4c584004f93210fa7ed8fb9576416755a74b02c010409722c6916fe5e56e60f3828a9ab301daff5d30fa1986f6ad47186aee069179054b936f902cb6dad51544a67dd5cb4180a35a19a6eaac61858d1e1f36fb667866722fccd5c68429fdb9d330578697bd729a57213da7e175702757eb9e00f33cf949b643b8ad8df91ec02cc89744413da20596f12c62941a5a7a9a939973af67a7474b425fac63331b77a0fb4c744f075467ad239029e3b53fb68630bce562a0967c19b233a392ec44599ed49082cc21b2dc94bc718312369574a9f52c8fbf93e5902df79c58acf66c844ba82ef2012fa749888407c23c34d50dcd8782639d41bfaef1b6abfdf6e7e4ee6276b7e1ce6ed8b26a9bb41252f98cab17f64b5336c3edfbbbc47de27e745b40c0f935a48c52d48c72027ff97b11701f90198ee0498008887e441ae7adb4806e408bd453f798fdcc7b14446639f89854e89b35a1358b4ca787be7feb9372a890eab003dbd80aa23989d2d6d1784d80874297e51add9ff5afaf63af9da690581a672b0289d9d3897c9508fe3b1a0092d5d3b0ed71e62b4edf9586f34f10e7db56ca242b13ba517939ce1157dd87ff962a4916d36ae54992ac9bbf5b95708d3321bf2c354ed9b72082a0884424b5ab56ef056f00dd7bf775bf8b21ab6a1725fc0f84ece27cde19aee05fc5d2d7de92de76ebd0fe8141be8562c61c66deec35d037320188790a0d41721d1d3668ef9d9901233e79e7f0d083adfc8e484f9d98813f1583475d091a12ff99926f2cae7d3d50e792eb1f3c2e60a5f83540397fea1d248a477d5de6b9e59c2b36cb17df8240af6eef235d7e36704ff200fe5796f563b91dde0810b653b73f08ccafea4b98fa704189c7b15e772a3c3544323b88c4eddf58e1d449745633fd33fa28f9649479e4e3959e62b7c485b933c2ae167b6db7bfcf0e9c0c65d93c7edfe413f499af8a96e2ee19d747e50d2ba8fc8cd8ae7d131d0a42a53747a6621084a7c4aa2c72d61f7bd58989ebb082e57c7a3350b4ae465fd31a4f1cf6e0796df65e2907337666743d29f764fa4570e2cebcb702084dafa3fe949e94e41290b380454feb80b77409c6a31fa39c3f41a179018bc93f59826aa969639b2fb2ff0b973a145fdd27573d9604bb553225192e86134f5526f550614add1250c46b6515ff8763712f18ba0f76a1e1b504d538a8344bd96ed3717402da5fbcf301a3a44cf00b69ad2a90147e85d8b78b596ab20f66f289c8ac1c39da93aa415161cddb01c8a3a79bae7cf5105421b6784436667460d810cfa9af417df4e7406b4d934f6ec3e691d1787236ce7f9cdab94a2b3850cbfab367348a91af2ce3489d0cdc37a5680cb80ba217e173eafe47eeee057a95b321a5413da14bfb4e1d643079cb3775e30df94c2a4e98cd462e2d577281e7de62fc4164f1d02020f142a9ad057b43365b76adf5edd5ddc1989b2f5f323188216f87c20cf067f63b2c4541deddfa0f8a885ec7e95ee442f77d80533e8b54066364181af1420eb269a2ad38d7e741b59f4ca31eeed78b236a7890e5dd22c4691b4641da84f54d4179e9919e6c68d50f3a7ff3f696ef77b93c7e10425574a9626680322adf45192330094428e30921994a6d656751c743dd12532f344dd9f9e0ed0c3d2819ff8dfd650b743e95de76ad477b87a8e4494565c5e5c590f633cdac26b5ce0193c706a22f691b4332d7ad11133113bb5e983069760628e7c624fb3fb7916fd0caf3e91cb051d833eef5052fcbf9d742f941d29a34fc2454744566afdf40e29e5ca7bfe828f5df0cb2ad688de656e005cf901156f3aa4cad16ce96ccc475aca425e2b5991cb1dd61b155b20def36fa1dd0207e541030768b838e2498bd8f03ea30eb1fc6f2d87cee6b82b806b247ec2da27846414bef0cc61728bfa5870cea3fbfd771c26967e0517476af78bec747e4e563ee2534e4dd2ca200cf3458feb2ca6e5f38d657f2690ee5a0986bd67e39aa22f2fbd429f129721a5661f362be2b18d8b446fa8d1e9a27c709dae531864e0da6c3a96f202cb88918fcda37871fe95107c5bb443fdb2a31bd0658964c9e8edef2507a4969c224c00680ec596b0eade735376a31ac18d9ccffa556843860b20bb182f0fce36e36306611120172f979b561b66d6fe6b41b1f16d9084e2cc4f163e1789ab6d8fc2dde77bde8fb35dee879d89dd4260c5b31e9f7767198402dae8005b34deb03963a1fcb835d9db3810759d63aff5ed0ad97c20cc5d8477f6dac1f95e5df87374ba9c8a94b48c2bbe710ee7f66103bbddf15befe94e1c06833067811396a63cbf523204b28d79b766144360b7cb6217f068940b22ee11ef1d42ed9d0fcd7e750f3470d65cfa2a4c11d4e8718d72fbbedc403610dcef37336c584f1189c5b7d5fe339548dc7f8fc908b361c72d2462e33a68b727e22600cc181b8a24d396bf70fa74d47edac23366541a89b1619b380404094f1e8f339703606850763efdbe47aecfa9081183a4ad1fdbdce9692821b30a898d007b9b8f7db6ae7f4eb63a1483126697237d2c5bd8663997a72c2fc2e3f9644cfb1dd5d8f41d42ceb62eb781329739c81e453e04aa7661145df266aeab0df24514047f74d8d49564c15311180fa3b25dbf48a707204a434f5fcb37e29deca37cb8f3e7ee9ea2e0d192626be0c8510979c15dbeddf3f5743e2b199489d2a213f102a4dac6496163c5a9fcff6d22c93a06e911c0c1db936f8699009a941055075e58b424f6e27edeab2a3ca071f392a26dcb725a4e1f20f67d7eec77f1de686dea39030550b55dcac8f69ed23ce6a09aeee9f67b33a2c500982a4dd1908dbb4ffebaee18fbfc40d06da254a1cca999259d4ec444719341fb63af694f7551915aca529d2b0e0dc2e6be44c2543b5acbd27f0dfa09b0fbb120f2abff46a2c3bfc38880338fce3c402e1c916758f3c9a03e725f5b0d2adb934946ca2b8c76975936836abdfb50dedd9770054875a2abb4139aeba060536762fc4ebfca1dc0baca81a77d2dd8d6431c3d291b73ba6f3c96a1e57e2211920dd086f0a0d912d55dd20ccd1379d2f6314222bb086881a6503e91013754cbd7b53ebf8694aeb1394a865aaeadc53986e3019742b36c1f651104284d3538675d4db0bc2b640343184e97ca9c6843eda669c34a2ed81fa3de70b78035e02b6e330bb37d4117b709edd401d35723a8e138cfe3fe964e00564684ba3021242b6b533f654b2044b74eb2b9d3677b831bea3d1da18e7407515e0a73c337e620991beae1db0ca4f834d302c72774134c64f876512a583c2a81e201124f1c1e17548f8e68285b3aac34a509bf5850d074f72b56a525d1c29057c9f4edc07c122d771c40e5f8a4e61dac3eb6ed377b46285f2b74ca4f4ef2ec3ac10c8081daecb9b626bceb44e0d7b9df02cc322d8c5abf491eecdc51bc37a61b7f7172bd0498979ca44307ec8e9431bd08766624e75287fca441d23f0767e0464af308183e0593dbc8ff8bbe45f78ac76568dc67fd6fa99d8e7a1da986fd9e15d980d58014addadf6128b6c9ed521e15b5e99cdaf3166c3dc9eb926c81f11885609e94cfab2a25bebe9879f354499084fef580035230070ef848f1651a3ebcc3adc4c9869d3b90805edd5c34f107cfa9d2f01c0d05587c40bfa6156a37d05cc7fa65d7ab34d88fd858ca73c1a3d0e0938d3896ee019faf8a84f7c853278c73712d1ea5729259e3989dcd8f919161245e10ff0d403e4444db99d38d14036e246a07bd2ca48d691387db94726173e2e1a5624194d1a47555d1205bad12ea622ba902f0b59ec6aada70cc972388b69aa57c0dde273655b63617a14aa12df30bf30ee489f55ffecb0acb09bb84266f61d4b57f39fc0fc110080c0deefa92a5f281fab52a1c4b09c39299af531a8eb4c84dd22f7eb2c7a734a0fbabf119b634575f0d3f2c8fa1053d8b3dda9f8e5efa70151fb29b43a0893cb79db66739efe2c28783972b7b4345865d257e6807d251a30ad5fe375e7300352e8b82bf1c7ac5aff8124b9056086143ac1b8fa8d8a807239506a624a1f3537e085e714ac506a9a8bb42346108a90bebb35dccecf16bd529ad26fa4aa898ff41a11695de94ab9284c8e27cc82c6471ebd61a5d94e1868b6efbce703b1803ef00ab3815f8fc61323cbdfa7250953a0b16c1a26502178336e312ab2b0edef2f468add43a8518170b3e355ed9d4e83b36ac0f55af4afb4ba68c469c0a9b4ae7effb01cfe032c2a5034b5f4e7321f276c73f9ed1c57f24f0fd52efdf4bd170839583dd0879402f80b79e646cf43f3c537047e75b712dfe845fef8a9a5b3ed2e52c7f9309810791745738883e8b27ff38cdb08195a5b88341c608816a98ec4e6864378a1654f11e3d62c0ea1dd98d98836c8703d268fb6f10c37fbe6b982fb5d6969f5e91f54c9f5944c4fdb90f6bea19ee38bb9739cb3fe1ec16c93d323250f602552fa260977569ee3a4c7deda256a6537418d6a50b2ada57bc25cc4894185c7762efa3327ef2fb51a40cdba91927291830727b67e4795d6968da8a6ea85ebee8481b5a067c246a6849bee85fe6436e26edaae445516035a534774a23df7d6d6da93ae7f6e5e428d6e59a8d97c5247e7ec2e4527fa01da3a7280295163c7ff0ab7b7e8efea5969a9d8aa37757a87f86732a12249524ddc3e79dda545349b4a3028bc780bb59cd57591f38652db037fd80c077df63f992eb8520949a91f363727f753a647f8b846f93df3f290bfec23b2073220cd3f37b5982f8d4434cef1eb7e08ff6d12b68c06e2933c3b5d574b41480bdcbf7551066fa87a1e0ac1239ba0f7ed29419a6ed48977048395a2ba025bd14abec2bd931804a9cbce2bdaa30606324088c4df1c2b487b50ff7473a31f962c42088a185f9103aaee21714a8d774c29380b866a0e3995d0b5ee2a2606b15e8f80ed62275cc7b3e5b86ebcf85ba3aded59f95ca3fed408fdbcb12c9ff4db6a7fb88e4adcf42b1b356faa76bbd7fe23c0cad7eb29274f156d70dd272b2f233091f82791da1a51b627a32ab41e989995feec1c1c86f18014541227d93510c73b489e70a4844bc78402c8158c6ccdd2ed758303cbb5b26e9b22ea6670db9cca77bddd422ba762b0ea523bb051aea729081320416bebdb42e0647afa041995e9ef409530e6394872870bda2ad91dc3a4d4722bac04e9839015adfad7b5906cf7b6827a1c4e1cc12f362cda064075fb8b7f56413d95d8f0dd6f6a979a403f7c40e4cf383f80ad4ea74d362a2976f7283fbe07405b1ed0278d0cc9303fba67c2aaa806446fd2fd4fa350cfd331aea19ae8bf6ce61b0d92f9c6e63cb6d9ab350b7cbc79c75e3019c584af294a56f909e8273293067ceefecf9baa877c5109f92fe5cf55aa4c40e16c66b9627b4933ea61d4ce23c8b81071be96645508ccf274493601db56fe0691638c7cc202734e1e09f5d8e36810b64f7eff7353c7ed21049f1e10928e80666e76576fe5c0945c0ece18810a0706788477142889a421e8b6e13392bc247b19c1e9225988cfb233fdecb4d737f9b4819a4d1c4e81c6ccfb026072d1628b68110ed85c2d20f86f8b780176576ae06038283b2767bc4eb1499fd2fa34a7cb0e66037261b2426d21cb52a9457de941b2c55946c5f70548481df5c7781edda27919fc219f3663c7afa1afad9b45e95ba11c7043c3ecbb64c16527d1dee1bc01bd37eaf4ad51e3758bb9bc6513d7fc054996ee33d06cc64f63691e20e8cb1d576ed3cf2c7859e5a9b13eb0e1c0b5e4aecaa2ecd7608bde3dedda0d770f120313371b1721b58b87b3703aa4daa6c52a4f9904cc33d7694d6d2011678f1a8f6985c309ac6a37a8dbbe422466573e17551a19184c3537bd65a26e0a2ec4eb1bb58b944db735dc9afc593e1be3e58e742feab8e85ddfd3109d197d1a0233f0869d932edd5e5674c71b54b664bdfb4eb3ab5064f2858530d7f1e1761755333fb0a3032744d6513131f87ec9013a40a975465a45d77a663bbff61c545dc452500f03927071ef53a38762543394b2947f6b54ff48da39d297824e17395bf4afa90722f5a2fc375b8502e4584b6c979f289ed16b737f99d4f2b7d30f6654f6d23978acdd35a4a367973a1ff0f3e790e3f7232111a2c60adcbd96e79e72800439158517a4c4e7d52eff348311f24a09ff1712998c85b01fea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
