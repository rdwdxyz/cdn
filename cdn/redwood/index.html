<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81ba333e0aea68ddb9c193994465f1fa4a20ba9d2ef6cb622b21b2073f90c2baf26e94e6bea37164b0a0cccf09c24eacae3aca596f8e0056e393df9012a67edad66d0b2c2c897a68375d7a11c17a95af7d1d52f6b97723c8939a52751286a79d5b4dce1ffc72b6b6122f7b511a3dd9422de042c596178d89aaae86d097c39d695a2394d5c7166055bc76eda4ce6b22d62f1d7009a2e4aa9df012f252d7eb0f9de8d0e0240368c79d15ab2a424b5625da4c45bfd398e6dc94a691f63d2ae98b5d8ebd93ab0622b9c84d528ff278b264503de99907ed0f46d8a3796838042e15b98d555bdba1582696a701eccc739349565ec7b7459b49a105b4fd9a6b8ba497a3c02c7b80afb7a7588649d4cbdc5701fe9abbc5e582f418f2303eb9eefd94574d76bf01dd794409704194dba39c5549d13d8384205b6256a2af25e15a3d5706bc53b2161dd4e6ecee667116fa21bdd958cda8cb2b9feef82f3fae2386d9d99dfa8429a05f656f2e95864de50bd41b94276822c9e080f2bd6f7e8860ab89bb6ff2801f729af75971fe54e16c3cdf6e7a0f60782b1bfc868336baaf7e0f9f822ce2405de7491d2ff95eb23a9b8a6b65ebc68cb0c7533df5f7af8cad22491bb53c91139d7f0f742954c12b7f9a59235cb1524b5f491a7fb521e3f98fce3b2efb27493f959f05c204ac39ec00676586646a7880845201f94d848ab3dd33c8c9f969679356d9cf819a745dd4a6ff5dbbd21832b5b789f1f58ee13975bce492a47cf1b4cb5e9093e0ceb24bb32fa3a86ad01a815d16cabce15e506c1b64025ac89a5d27ba97111f576b35283bda2e4d9bd4e8999c1c39cc3ef7b88fd207f71f131fbbd9ba4ef8eb25be575d584d93b644742b6b6701cd7abd66a598b9cbf7da076908f0b327fb1ec0b7441e6a6559d22d509e0b79e2270f98a7783af73f9683817a6fd51693a7b9f21b2eb82a8f95e0e59c2db08eafc841e6e02f770fd03ba51b7d6e44c4d67165139ff6d1b7d85a51228667b5980459d22353a5497a89608b05edb20534419f5673f71d777427fea326803b3d96361d2709da803faee6ffd63b0c5a5fde313a8514ddf10182778013db0e2d8f43168d8438df48f3d192ce82f204ae6334b744c6ea366822e950b8dbe450ad1efb6f823462d21221f77f915593228874ff833c3804cfc0304d19bf95bc1b50472ad81142b945a5baae612518f8d65341964b88a1ac848bf0e5fdf7d446672350f3f11f2526481a880d87ca01927d0d743dc309fc3b4bbc889f88abceb35c3e629b2d69bf258375458f752db2f8d31f46d1dd51b122e1b375cd907edfed366d8b3a80ffd681e8b766743a06cef46d8027f51b8dbad4f0909da0c1a917c178cae779c70b17a38f9f0f3ef13a08deaab508698ed3ff4ab4d14a3507172acbd2034cf3a493051c9c59094b0d51e615517a29627e6ffb00369563f1492c0d07825a5e97b2c95ca6a79b989fb6092b556bcc1eedae5b872c8e882a059f714f08759acf72549c04c04e5de30a0256851e12622ea3c58f21667bbfa14d530363d827c8b5ae1947f078415d9205b7d1c8553c77dc2d8b4474d4daa48e479b96d2bf5bba3637ebc0ecde6c3b838278131fee5aa1df416587e71117012d36867afbcdf8375dd32466fa78216ceada0cae1ed0f7a5f92c29e034293666e3b3d239a696afee534bac9d2bfac9954fecc2d981abd5fa1a86fdbcfb656fc31a9a9fd8fd7e9a4f384698648edd34f4fb290e124ede374b5549c4962a7f7aa4cf120faf28e20751aee52e32fed13c8d257af26597a73838de6c79afe423148e55070a439df4570ac6ff4baaafc37e668375fd8464165fa546acb03d5ac670c89750379242285ca33847b151316cad8a82ffe69c64490f86fe856c33e3321021b41bc72315b305284e88344804f0f040ee8d05a5c6a94941ad6e384a5f64894701108a0b5f8e6a41c701ac45d6ace6f983d0fdf6a40b2804ee8e2e310ee80b99a3ce24f5c397ecb4440ef5e4a0ef6f6f31c792f542a15a5a12d1c891721e1b47168b185f2ca3d1a198c144baf2653ca884c420d6348df223e1332793c56614d2fcded3b2ed06bbaf4a55114c6ef89abab2956138db0006e9336f6cfa46db5993e72a1a1ee03c47b51b9fa68bbdffe31e3e5b5817343a03599b251f1f263d9ade45dd782f8f19f93f4c1c32d9614162d176f531899769d6630ad357bdeb652329d71e66e37622597675016fc4b50c877af3687ba3b4cc021c9ff226c3ef80063f58c1989d32405acf9a9424b072dc7036c688b0b714d6fb89643a5ca5f9d0a23f2e9dd54d7b7fbb5da7ffb102b816f470a056b5b973fac4644e20504c31728bacd61ff1b692dbb62b16e5f6046cf8d52e958e94b77a947f8cc754ea2aece36d6b6f53941b09d80ad7095ce3f65ea2c5c3b9f0bf81ace1439a5388153e1e80a994ac6ad8cd17efaab6675ad26343621a9cfb5dcb9d6f5dff2809956a8e275f572991a9baf305eba3597f29f949ea2fc3d4ffed67a05b164582baeed5e5d9d385eab5111c8367d5a7189a0bbf0c4a84cffce53c67c3cc85bf99ea0bcc390f4953cd355453b447159a83efc26a18096410b1a66cbbb787d0b782964a9cc71a150ca7a014efa0a5891bf9b292a7a05ddfdb70632befd7371b930c0a0910140e3aa4e0a26bd8f48b7cee1b35700713cafa0f1ae00cbb4bba31687e49e17f96887fea725cc71bd5e8b65944b441aafbde6bd9a86ee2b47a50a29482a90b34a5daaf8689dffdc9bac6c56e689bb4d41a1e57359d5e0d5223fec2381c974c74cc44b38beb0d585b5682c4d949675fc6a040273f21a3e01eaf4da06bf8a302b7e10ce3405b1e525b7e59d504e1022b9c8a6aed8b2ea96c4823a40f2cb7e9c65b9bfa13ef14fc0553ac6367f6cd943716ca5191a519d8ce104165881cd5d45897f8043abcb8034b45395185129a756a4a126f20fd33dcd16dcb18f475fc816da964c3796ad39e5281aa6289695e1d7d66118a9e2c9293232754c1cd7c1295d8434baf6ffb293ce6589514f85b51d8b8ba21496c83bd7cd29eccc89e79fcfdac7def7e7fdf7611c5ed6c05e5b23677ac20120aa0131ead165a98363d7b41b625402f05c76c7e0386ca70ec2a3beb7b2050ce0cfa077fea356ff9c715d433e2f5dd2c54b16efec912faa849edf0116d820c3a245689fa7995c17023240e6d46d4952c15ebdb10921aa52273e67ff33f1097e07924991da6972c8987b72120b6bb60247ebe15a8240ba9cd4f2e105f37d87ec4e651c15fe0d7aab0fcd9d827a1bc5cd0e149213ff71c90cb3225c39760e62c02588586bf4418a80f65c050628a2c551e609bf36f08108291c8654fe95d78de01ac428f7f8706c2bf3351b5de7478561f723448c3f7969311b9ee97e420f4584ba186e6de66539e32f50524c5e406a792554422115f75461a6bd76a1618167d78b945a53164827e29ea6fdbb5bdfee9eb130324a9949499f61f781dfa253dc7153e6aefee2f1a4a99751f6ce8ae4791a04544a35fc7d576ca75507289ab76ec8bd38790cf1d667d87b449e5bc99cbd91eadb564e767a9ca87028cedc5213caac18dc8528c0d6867d6c5036d891384e96d5aa49957a3353a3fe88093e3c558d54e961c7e5d6822d093752c11ea2927416f63d7026767f329679b3cd84de480c7b67f147aff6debc6b188a10173cf16d15c8962903c603cc994c0f6eeae8c3f3a12efc5fc8a91711c8bc29e69d44680b8618c6e176f2df32c5b7ace6944030e15e0b838cd5fb44917d7a94846235de329bc1ca211ec0575614b18d2967d5a1e5d064f09c08b5df18b951dbc9d722c9cc4a36e0d3e341aa93dd07e87b78075cf7ee22c582497b5779fdba1fd591dcf391a26e7816349a1312d28274370bc12c75f61f2905c4295b411c7f86894c2d8cdfcb11f5bcc5df013da28198d86bae98a20f46824bffc1c3821789ce0283e6e1fd6eff7f30dfe0184611cf1e01f2fd2d598d3d6078c29210254531ea957e1a2388c4790d4077fe0a266cb0948580fa4877cc428def7838ed0a284ba2ddd4debe45210b1c138677839e3b5a7405b795a0bcc970e6aa030f71f731485b578060d186158bbdbc46102f6067edff533dfaec6b536075abd66302d5e5b076ada97854de7efbafe9da0e9532e4d456991add86ffaf3f6b01caf183a8e2c54aad06a8385aedf506e0b484f70278ec7faf8197ff8b6c913eca310c704503aff26322b3b3a7515ce121db88ddd43e4c923d0e0cdf24f06f57e69552a2baa6255d7c51170d116dd63d2f85e30acd0105ccbef6f90bb60b310b2977f7e531b56674ee6f536b0a8796111bd5ae74b2207f8186a5d20316ab5a0271e7fb89c9aa935d1e6ec7213fa01a5509a5feba1e76a4e2826d9890ce433cd01504cad6068060fb48f67b8a57d4d4f774473353f0f6905c57457e81551703a46835c798b8f1101517d2f940608da047573f4fce7225c34a51bc75dc0c502c8e2da4c2c6204b790fdb117318f5cab44313e66368ae086a81441db10c368f9b2ae1603d0511e30748fc6e6bad1feef3e3a2a693063510cc8af100a21b02a2dd31c26102c85f7b809f14f475caef7ac4292c53683ea6a87c8445031edd35c0e3262e62819d91e58c65cfc83f1ee141e863f2382e3b353aac89634b31da76f6e77a561d1aefacac4353ac48e29b681860ac41ab725beab059a20e9ff8964d17a0e146184fd7c9bc985fefe200c8158684a912d746a30ae5f1f17eca5ebc6f4e929f9e78e812f58d34066a31bdf8f244605f1421474479a40f0ff8663241574efd0f56be9841061d0ccc74821bace39e6be94f634138132d692f649d07b5c8de7efc67bf16163eac41f1f264d46f925873e8b1aa86aa84243f6572470ce0617090f2ce03aad99b17630ae4dbe44d8ed72ccf2e4f0de04e9b0a70177dc965925cf40f144a95e708d3b6c61c49e0d266d557366c1e2ba26dd90cdb3130711ca55d8538bd8d6611f4b4d17802665e74e2802d124a84a2e351859c07e016096b55aa2167cc60a603fa3772727f49653aa62d3d1f76e1276672f5316e53269e3c9abe0a87ab5ef32487f76d6e5c0a8dbb0b01f695ad3f96b587d75fa328f3daff7d964b39ab7f74224dc3ad3ccaa738953389ae2f333fa3b6b5cc44deb89aabb2ad77eba467a2fbd0bc3f8195f331e4ac2c8df02a7361a0265bec2657680c90e25e1306538637fe1128231424b6e8901d3f3c1dc8c5deed818e157eee694c0994bc71ea0b5daac5b5df0bc10e0f32858c9159dfe148527c33f231da0abe7695792139ab37097e59fe9f767e0e1e2694af25939bb1e57ea0e57262fc9d24d348553d4929d3cfd6ee10e104e6f89f011b0770df0f1532b6813dff95a334c49765ea0a4f1323c1d339c87113ebeaaa03f89fc892bff175cf7e3ce87461c1987a1802f2a601031d478fe6ab2102ef1467e0c13b25451175c9813be59b1972aea99df7941368a39ed212f43e147deb138ad0c3d5c88b558e9f29ee8bf4259f1ca691a27fa6853efe6f3e1783adc3e5cf58c81ba1c2e3f5b3bf7b89e75c2051b714e20394e656a4d417e9b7f89d4926308b0db7e40aedb5b42c429e7ebdcffd5c88bea0e83b3f8ee065bfaf8641cdce57ea3998c0e160fb7d325a2aac5a1f6a8ab7f259e389bc5f463fe003b74a2c53cc2af58a93537f1dd5df992c2c4d34e30af07492e8c764e2cd09ed83de8eb3208729d4cef2d5bd47f02cd92cd618f7e8d52b8cf39ba759fbce6541fd46340b87874341a0a0b38feddfc64bd4930d0b6d6bff2d98714b77b4354165848a686347425f10ba081554cd920d158547982f4f49641bfb41d3b4e26fa8f938dfd6d8aa0332ac25296d873ed7ae621e48bbfc78b765e01db5d10720262642306cde14fd0b30c54a404c4c98aa780bfabc1e55b4dadfbba6ec70b87fe734cf9520c91d54379ccec23957aa2b07c5e98b3fad0bcc4fbf30c2cf7d67287cf9d3306b63b1bcaf4a52486a0b43330ab525f4f261b1cae9c3469799a2a85c47dfbee6b42bf3cebbae8cf5fe3b350e700a3d38c69cc4c1cce3fd53ae28f851557f0b8b0200b6e4c3133f3ae2933825a4b1871e3a3808d7aea71471921e1e18ce11ed10dbfec2e1dc199c03d2d89ee50b713370e79e1fcd21a0fd1ab256c44d856447794ea5884cee1ff13197f57b58d69a5e391d78beb55a4f027fc04dd7df10fecb1c216339951a840bc8f1f7d90cbad8b37c785f82e8bde4d1d5fb6ba1ee388430cea72fd756b47be23b0c7011e0c7ec2a311fcbe6265c7ae50602b88f2fd8afd42b10e0e96051412076cadacf40dd49d5cd7ad4c5e4b8723a2d75c06e91700208eb33b5d80f9a224f368552b6e208353467a1fa3fbd6ef2c45f441abe325a1473540f227954c9da2a83bf0bcf6ae4f1bf203385bf07be1d0019fc2ae64b211dd131f3589b206974574084a79b659892535ff1904bcc9224077eaef0e9695677676d7cdb8fbb20c8a8fc729d65967cf61f6b85e0ebbc102b38ffe9aa2598725745420897693092f208fdcad39434cbd003f1f8391f08ad5002de4e1056493da56513516a108fe3c3c5de22f716f89e69f0b80d9bbced6900add2fc33400fba882e3ed18a9da0bd2bc976102008053ef9a3c3c1f3449cce2da01c9daf5afb5bb05635d3a44c01b5b513626556a6aa472e62fbdc5170865ec824ca73540ad799f7a7603e650df15784e0f4126296ab0d6e22a9fe2d6592589218ef113231076d400bfe21d3badb795bcd913a38e79f53aadc389577cc5db402c941692d591fb92533b6b61edd3cd5e22f1f1f1b7c25e40a679328341b12118bba5e12107d0a85b1bcbbcc065a1ce8914c6cecd1ec643cd7faa4addf5d2ab2849d6203263b070a95ba86509df455aa068b281e57cb38d56cb774f5dc26f7b1405b7eb63a8fbaa2924f519c7fc7cd10b444044205b783b1e06728e6a77aa52ffbda94b2b654e320b406fa095991d6bc8d66c8e1281d6a054bbc9b49c774f338e452a42ac0f7f610780994b6ded5d50e368b7d23362b1c01125234d41e52f65342fc2e2116af1a42478406165882ac942926dbd6664244e713e5d102bcf116f494a4adf4782e4c78d47cd33bcf6389cdb03f3ff1e883480cc73d73c27d94e285b7081e3a0a7062fe1fa5cdebf690b1bb973b62af3d814b35d64fad4b8bf860b67c208e89df60fd3c24c1884b9d5ebd1cc6ede55bf850a997d87f7260ac3b9c8842856612eb5b3b4546e49f173cdef24a5fbf87a48df38850e45f119e565538c3538c468b064a33499e5ab5547e2036bdef4280dcd943f3b80c68588237d1f454470f285c3b45291839fdcd9edd06b0d8f1edc7c04f291ba93d9b0ae6137ac75e25e429e6f89918aa5d386e67928cb25b617b537c5ad89b0cd72cf557735b7503ea9899f7796d5fb17637c692983bc42085babcf258f78c242cb24fe522811babeb37da2766d50e9b7c357c073a19820e26e274bd5bc9e4229f7b32830fc89a8394bb6bb98fc4dc0a8d13d6fc5e25bb4e11eebadfe7f8797c460da726d88174f732efc3b602ccb4e1b9f83006e2cdea3f80be83c4c2bb758e4f56834e04c7c5fdbf68e11b631a3fcb97cbf7ab94d6d1b285b9f7cee52b8668591df123077f2d54de0fc7c4cecdf0c3490a6fc5b2cbb141c11c627f338ba03e0df06d93c351294a56f7eda3a30ffbdbf3f279b33f2462b7c038423982b6d9a0ddb7a4685ad6bd6bdce59745cc8dc397acdab7663645634c584275f53e9ee54f278aa82d074807b3d8785f2315ec0ee3d678c8e047d71234212783cceb4129f6dd6567372f4190ccf88077efe854d8315f8f61bb97bdc91ce72a278b753c416dd868a83a6dca6aeb5f7f2183a42286cdde45f30a8146ea0a30926f162def2a008306536decf7bca7645890c4d15826e4056fca06c012aef453687e628250b4e82c76da8474a3bddbdd33f25a04efd21e77b6eeecf7212614951991c97e2cab47f89f0508ca11e727bc72554f9fd6d9bb95f0acc7f65f08703acec11e5c44f9229b57a5f3e6b6b14af8a587f99dbeef6ba1024f6a7ef53c9f75d6fa9e977c8c176480521a3f392ca1f4af72502f79a0996fc2d18bac29940140237b39b0a942bc409f7cd85959ea4b0ca5d60cbe39146c4bd8d39262d8b9d32669c3dfeda256fa8392f9cdaa7af23e97d150d18dc80e53512bcf7c51a1ca456e416f3e70d94275d0815ed7bb18f44656ed23c4ab7aca992a040a4a34d2631497712b16f61202f5db7ccf6c9d050a67ebd7d778366221658a74a7bc5db7dec299937aefe7ed8e7073d6d06fe38d860f2b0ee4cbc71e1b442fb9b2c4bf0eabffc83661af9f63dba223350827c5b77ac1f0b268c568f4492e8cc110d900bfa3d87b5f30287858efb097ece6b916a63e4fca244b813d6cffd343779ae9840f01d6896a11a112a3ef23543c9a1c26b9251068b1e69a217227581bc033ac11e1d1647fb33a9bde0feb3114e299ef6dedad559843b03f90c2958b126422303a5fd220ac5a0f71b85016b0ce14f09736f849b985bb2c62a082c75aefb15772e1148c45b45b0d000690d9a98da55c57a75b1e6f4b61c1042334afc92d26040d72cd7e77f82ae5029b956583ed28d0fd5fade1e4f71e7e8b1a7b0592376098fdf53003a80c3d9850c765944e6c8fa8387e089ec411a15764c47fe16169e0554adf7853ea0b7bd0d85f202c0697dcfe3d9c6e2a632241f7ed3f625365ccdd4eaa105306aa81e2a491cb99df894d8834ac6ab767abd08f4f6e341f9643a29f2b8216788cfdbdce14e33faff185215a0f18028b0c3ca1209a170fa32314c928eab1af42c9fda326c01dd7c27e6b7e10719124ca58ef4bc2c1d1a3a8e40ab439c29d2cdfea9a8d60a21d4e2870635e3910b1c4ca5de94331c93350de3fdc8b2608db79fd0b644d8bdd30ef18bb60c9dc4a66e5399c61c81c74c69ccb8d54ac3365c891e546ab2728dbb44aff6a4057f50e81b9d312262fcf4e101c6c717a54be20ab7c0b58ad8167d067761faf8c6d149ddccf7355e2fc4a3e687d2fd28390ba37cff5b308072ce111c0f3ce67857a61820b1be2532e5eb3a3854abc531c91972c18cb305fd954d5234ead33575b3bd34ab4d972947d67e48ddb24a77aba8a44c037de70613706142daebfdf44db0eb3c1d6738f58fdf60dbe4eb04a9c5018ffaf8407e6567082b63b7aedbb0fc90b61fed813c5a8e33da4db366a3ea4d0a63dc9333ae7439e2210676d5f3418af6a62272a446c61afe204d95f49837bcb68715597a0bd7c30b8ff5d6b51fa59884b1da19a9de96cb0d27e8f49a4a2785ef98130e61337a50cc0afc7fb79e327430bcdcff6fbd512ad0ac8f8350f64f182ddd87c52cbb3774b21659d0644ea9bb28d3f60eea114587cc05bfdabcc97d55ccb4af15614be3d503131e93c85f8870ae7c09500bf7801e896aabd21ef58ac93e9a85e637acd932b79cd89a3a1fd97bcdaa46c834086ac1809fca880ccdab76709a6ba79c8b3623b03b8c576bc807d8557c95b31c1771eec957abf16d6631c8d54b9fb177227bb643f54b27a2d57dc8a0a7310dee11afb1061223fe7ae10f816e440f8246e26e3f68525d092cbbd9c4cb2271058ec3ffc41abcd612adaf96ed235a4046d4bef78658ce13b8a63c9b28ea55bd5a31512dd259d1090eeb4829814d8abe2aec5f8327aef03a038111e5770604bc662dd46c7a52cf84d67d8b61117dad810595dce6e265a55372c40e262f9b5cec5f7e1e5fb20044c6443490235efbb880b1e808d9f6f1abf3c5d8add3f1bfa6dec1e744b236282b4b7dbd2ee06e1c65ef63b2b7c02d15c598ba97ae50092ccc89e3d63e75691eadc48714d6067f7cfc2d6c4c8c123e9e521b965b32844cbbc702fe912b6da7b0a2e8d8fd78e2ad585bb491c9a6975f9106e4ec6588e9613d8f27968cc20565438f1324b4a7043e5bab71624272506370237992bebdd0edfa55b946061a24a2d42a219c30a33c71aa2fb27b9047eb05fb16f89d0ba03e922322c1ad29d833b48d800064437770dc113ed9dbfa83c030212228105192b9b410fdb0c17b6660d6f7f04485c26e243a40b936bdf300f476f1c6954a1ea84e0f972917d2ba1095255fb1c1f6fd1ff69683c343463f48ea18c2fcb1aaaa5176c6bc8e318ef089fc41e5b002c88e7dc5935249f6a66d4900532706d0f1ebbec7f65888f07fd021ffe53569c6ecd62afc354feb29419d0cd7844cd56f24eb6b17f273161af6f6678f2f4c07c6531cb0d756502f6f2d2110dcbbf3cbaef8896cca60ef5f549a2c14c649fc0952ec4baa79fa6f180f47c0317761d81480c04646a532773b93f9871de3b94d5a5a83c81cd188363a0507ad0a4051f39bb25dd9326df547c0349134dc31795571c0f66c14eed8469796a2fa9512a499da5d5a9b257de46b81030a9bf573272700f647d8e926e0405d77e90a0ef58360fb7045d325e494e6bb3edf7cf6e3f49e3180a02ceaf59621510f400fde63080fda674b0ea4401210409cd6711613480b8d518ec7d3bccf9798d42399ff269ed66ead765f12dbc96c91fbd8c1ce039147505df798ad6d55c309d5bd8040086d455254ec412476a0cd782f23280a8af3d69a88879b9c619ae5b4462b432f606fd933714e93eff651e1e31e72d580bfa2035e4fd19569d9d7bd750cda62c54918fc6f439b9cf6e22befb89dd859f3eeac3899256b0aabfa78a28e47ca6f526040c17241139c4fc88671dce1d84fe544d706ca50fe3ea7a43a52b3cb7c76f3c71fef087c5ab75567f62409c38513adcd976e7f8fcda77119bea6504bb10aedc2b17abead5e1cae0673e4d67f761523940921c7bcd9b47b84aa5d7002e3db1db5929ff962ea0d0224485bd4953631f56d1b27f2747dffb2045da239db0fb31e2a78a24c7672826b5c18e6cc80063f698c16b514c6ff15b68c68a5c6d70bebde1bb4145d8d90dbb0d5c41591aaf15611b03924201182f21ae74b5eb48e1d4a39da6aab13e5a98f8b840d1177a72fce219681deba4c9bfa410c6a29a45e4b96ccbfa8d7c67b0616c43c4c8cd528bf5d14c9c508f75efa223e0714adf69f8fbdb0fb594f930891c1d0eb58d5d9d54ebe5fd2665659e020e1bb37417dbdd44747376d9357412b030d4bbb21d2aac7a6816bce13c190164fb9b3280a966d64ea263e94844574a42532605695667b8409e09bcb843f21565918968dbb4f680d7e77dead38f5e2e723b5c8e91c3f94f2facc783808984ee609615e77a2466f390bf09faebbf80efcaf0b4bb5a723f941c2675dee0fed9b6b72cada30b7eb2e8d97ffd0e3cc514cdfadf01f11431a6fc70e3350ef78b28e0a8417496859d18256b90dfdfd586ffb4615b491eba3075c818b224c1b99fb300891caad46eddc5d599396fc3c8def85e6f9bb03ac80ee64efe98a4402b4bc4439b9b16ccfc2e79f45baba3f0eca42d9a7c3627349f9159c14685a4a9de31a8f040e2eb85f1de12598cc7a770a43f564ccb2955109078a71c7403c905e14822faae163e69cdf3f850a013f7a17614bb31206a21c87a820de9408679d63a0159f259cd2fe14beab69706e58809f499e4707ce1715baa24eb99266046b5ec6d892e31f8f6fe9747d34bd6c2599aa93a3beaa717698d046ac1f08620adc7a59897e7d1c6851f4727dd53a18fc676231611fd5f8d6d4e252ddc0dc6181eacffe6b3ddf93a4191195396bad76e6e4f23a0160d424b364e288b4f884ee074f1ca34bed646ddf26b400e7f8602e6c28d97f7852eab8da9a18207fab7ea9973b3b5c5f3641a871655d9ff2fc87ccf6e7d5537acd4571e7aa96d4ad3bea7b56c8207fd784a4d116117b8313baa4f1f6de7d9a5b7c18115472024f8a1a2b2e9e55c33c89a2ea0e02c97de917caa4f5448f98ab461cd43ccbcefb29366f5f9e1b97ad76f5e6dc6d3d33c400e3ab7dc77a2ae0573d7d995af157bc90d2974b07c5dcd8fae4354e1bef2d1bc350622d0d6eb9fb2bc5476d345d2dfef4f2e330e0b246b398974bfbc7e7c41fb5f58f8c2c19340532b24f970a809a486f0a5482ee51eca78f67a4020c2058018dc6d032e6d6ef01001a6827909161cbbf2a86c127f52adb20496fbaee0030634003329a0bbe3163452a5c32d70b05baa51e47f8b562c059d29243ff7ddec35ad759e49e8d863ce2b225c9a8fbe850b6ef15d62b3dfcfb5666795164ba0f2a37cb2870cf4b03e8fc2f94ecd3f2e9d160ac86505ee71994a2da316b3606f61ef84183341494035c3f0b6667f6994bea011c255d4d8780fcccc94164e213364bc6f8d2dcd445af5c87662500cdffe5efb8284ec89f373e7a92004223a10a0ab8ca8af1f0edb84aff5395b66a35233fac2329d8d96c2c1355ba023b621e0f969be758976bfd14d6292e289d2fedfbb673925adc113f9c803a599e26dbe863e550095b92d404a8fdeddf019e07e07421061b19b8b5f20e9e04f0afc2ed2f3dfb8b2692f42bfdb8ad9bd5599c621ae8aa9456bc7beadf0115b1cb30ac33547dae421c9ee8f3531206e1ba873242140c7b91e76d39e2b788794e201033efbb652331f5d5c7464c365c16c3918b93a8b71fb3daa13bdc160baadbd2a9ebb452cae2093dcb1a21ade4fd2959b2c15cabf053db73eb466ea08ee2f1aabcc1fa57262c4d433dd3e3de0d113ade1b1401107df24cc4acb4895a8a3c61525ec002f8aabebf7355e9695d91a29a66ba0916aa47a59df619489d07f5413fbc04fc3da539e63662adedecf4fe3101ddf71c0dc7b60434167995454a400773aae2d8ceaa106e267eb46eda12928dda7c3970d21c720cc1e287dc15abb795b774977b184e06d21d9996c1fa3273a38b0cfdc461b65e9fe48d65635fe0e5c8abe1db30fdfe648cb2e0d114700aec23ff156574f1d2db3a8168dcdbb5d4e81fc2daf14ebdb70fcd586af0cd835ed09d88079c7c6ec806af7b6cd5ae990a693ba7bda323c517d292b5a89cbeecdaed6311b8a7ef110d5633e7d81c475b607f4411986bbeba07fdd66eecaea24df5e1d0745c9a423420562b92efdc0960553db5661e5b7f044851a4d184855ca73a73b1f1cc70d338884c99e00a1eb69be2d73f81eff5ea24210ad10fea8a6fef06fb360f4688ce96c9fc26954990dc07c08e511e11e06a525632a7839060e48f5fa094b565c28718fb04fd1e83f33593de07d14bb2edd7f21e5a39dbeb985ba5d96d2f3c0f10d47be1b4786be89e3b4e6164c5c2d2707487e583a0764de9b319f472c4ab889a852c555bf863bd19d4912fdabdd4d6efd76cf74f2793b970c92b8344543f37c77ef35860c8b5440c9c514dc88952ca30c8ac91ad66f692f83558d7f7861aa0bd48dfa320501d158b67310bb2735040f300c3ae7b28c3753294f8419febbac8aa5776d9abb95374f5219ec2fe00f0f66989d90775d204bdc5047b59df7aae3be3843f4bf00c3737fc346df83fbf17be7098b55b6a031bdf299735ed273a1fd56aed3257b9a9fad58b4dd4f70d6950c10f4136f36c268870f5d728bf2df1f1cb5070d2e87d58d5af471e4ca5593e4fce2ae3e06165ff8a6e7fe44e6cb89bc4031f4f8a1ce59df241788fc644c076fb40db3ea3639580f17ab4cb2ef861b1a0da9ee1d0ea663a873a0378af2132f14ed1b835eb732f6b61d185267e7a4c3b7180dc8fb97121827f3109097f0a60d70fbf59480f12ba16a48ba3bbe2958e43e214eaa366060689f9bf2799359594293f8f9eee25a6342600785a1cbfd339d61d7c7d148077100ad913ceaac137ec46ff25df903ba837528cc32174c7809d56d02686ba8e73d2e681b4343d467b07aca198f422ac9922ad630e746187343b47f83b16125fa63f17d3fdfbb67b4e17e47cceebd053e1b39d65dd7ac76fac9ce7441b6c759047b7665435a34bb4b8c75653fae112d4cd9e96203e3a4d207237e01b6928252369f9dd763eb4dbab5e5c42c7c3210a4036aab2d0fc0b8658696dd1f32a259231ce1cc9d91ac9ee15cac8462be240b2ec6aa30b087cbb5d5a0512bb8e60ed1e693be9fb623a4163a021d21e9fd7f2195b44a9964d2671ac743b73dce6aa8f9bafd07bce5d4774ec7296ea906eaaf42d3c65189b89eb0918aa238cce4cb165adf0a49f7a8ee54925b85354497376bce855858636e38920993bceb092a2ab8c807b4407541fa978bd588fe711b23e0a2e21213d54a1472efff5d9c061f10a661d898a3e6f8aab6164a5aa566cfcfce7ed34d4259aa7616b536a9be4041d95b2c262c474803c1911d3e1b8f6c5b6d42c7d3c8f81143e42f968140fb2d34b0496bcd78cd78a45d2cd6972fd8f9fc182d1672aec09b7f99051d37c12acbfa406fcc85370c478374e978544c4287edcf0292283fd8ca268ba5bc2c36499dffba4e919623aa67297fc79b416541418f386d1a795c58b47c97795d664fdb930656fa342b6652c561aed9efa241c5d6571d9e6b2942a23dfd61b49e768ef73307e4dc41486d116b40a909d3ba7f535f1b4b8087e4e51a34b9db3d4704128a48493cc084c9de267ca0314a6c02ba28aeef4e050c3d999635aa611fb3baccc51a758f472460cd8f11c4a0b7c6358092ad2a32eb86e9b68e4b04d2a18b9c6fa17ab4159e2c7de0b2260f42970e1d3bb20014c9435647c9e0829928c64531b9680e27963f9ff44cb63d91984202f9e3ef37c61368a8ee74aeeee9790596fd6993755cef176dfc8cd60ace3fe0fe9bc78fc386aaa172d8bb0a99f9cee02abf2308179f179fe548150a5c27ff4ae7d0536b4e831e3d05d63d3801eb59ad310231c63de0c4136210c0ef517656cc204187baf8fccd4cf49bbb38cda448dfbdc3ef5f93e6adce12efe7a339833096f1767f5d796fdc375fc25ae5bd90cbcc4c0324e94cd884259899c3cbd2268fc841d8dc950dfa1397cef2b6dc744897734d3448b894dfe14448c0a08ef4a05ea142bb5e54c48e9f23bdbf1b658884a166bf4a1e1735ed6bf6dc871b2eef20a42966f43c25405bf13106a65065d1ae952863ef8fbfde347692a150227f118248e46799edb0cb44ce36a197857bfa2956d5e5afd9d35eac906a6edcbc89e837708bed3ba23ba1331601e6ade60e86cab1b621c4e5ff6ec04336ca0db3b04613fef706b1dc10b4659fad633a2f8a906eb5b23f5951d6c9a41b9371f882be6d95dde2a466be14d8fa198e73694ceac277320231165c973c6eeeb7fa77ed8731bee865bcdd0f3815d6ccc1aca010db8aa5bbc1f7c11d3cdd03d474c05c784d03ad60ad64b5455ac94bc16cb04bc120e24a12c90a363787eb210718417bd5d5582352a4543f5fca3ff6ea84e079799f6e8773a69bccd91615e9cb09e05c646b252a32655ca4b8ccfaff698425ca186cd9d5754fbf3f63b8f066cc528745cf346ad02cbf7dd84206f2ac0c7d7211bb9c0b9e07e78aae90770a135a849fe05d678ba1422c3b1d1e8e4e07949c51d525ecfa97fd512dd1a4d248e80295419c577611d0a5e59f2166c3601a97e3e7b48ad7383547ccd3b8b72df4e3fdd4b753d6778b00967ad5d397c6702ad66daf4ad56951473dd6ab932282f6e80627da4e0648af9c7e551a33eb5546993d636630f838d48254e51f96591a26e320b623e3b6e4c01d6bf2921792d150df4f550c17a9d5cad60c2737e7efae17327c2cb5bc2c179bd6ff84ed2912fdc79a42c3c22a2fed15690ba8ac8ec5658a0b279af6600053aa8cca91367cb9e95413654d5b6a4eafae01c24b60daf16c44ae36941f00c427f33218b02102c3bab2bc4260d89b94a5ac3d2954a8823f3e4a44996206a27b788fdb464884306d619c51052224736d8801851886da760f1d8d701843362267a40cde219ec9d2f0a41fd22019576ed84e12048c91f31d790187177d124fcf308b6e384f5df5a3e4011f4baa6008796150c07a636eed754e1535a14d39b25e69eb55d11b72a2bc36e5424b637d5e5fbcb64914ef771ebdf3d692637671a84b2643f3aeb1ca8c0f92a0d0f96f9e51f0150ad7eacdd1059402a8e69b781c114ae84b8e31b909e9c7560086e8ede27747912211d8b373da0813df70ff2d581eeab43fa71c7c6ec05d55fb45a85c9f29191a90cfafc6c49f4e3fa9d7e4d1289598896ff2fded42e512d3d8133d758ac45d4f15709fcabb244cd768ec26d3b9d610c0187e725029779f63f595bef37b8ce14d70f818893174ec705daaba9c2d9b4b74e517179fe58b73adfcb400f916200581e5d01e4a1cd8b731715f9cf74b83aecb56010ba17a49c2f63e0d2c8cc58fd25dad98a14c25e23004da2331e8df0df0c8b2cf24345ae07e96e40517db2ef10a8c676d590475b469dcef16dd86bfb36cef7bee214a0897b016d7b48d8d2fa2bfe3c005a3fc998956129e154fec8037eee9a53759e126690983b36a843ae66e5ce9f5d5b39d050983dad010248928ed036623c7607100b8ca09ff196ce0b9f5b58a4701d083b0201d12635cb81ca5c2b121e8a69cc9f9f221a065c60e8ebefc920a49e012cfeddfe6656ab8977e1c859b02d91e4d057e87aae3693431028862138a903df53a4817762a35053b1746de7973878f5cd3d2137d1c8ec763c1b4771792361f8c196486f9197c9a96906920c11f93ab106886973b44184866334ca82a0ff5395ee06dcac7f9a729614dc0d97807ba3cf7e2a692540e897d49114665b6fa0d0ac0ce943727f18066128bb0298d580b6a7ba9f429c81aaf101185ac0f999ef98b26d1aac37980844b56cd93d028dc690daa400cd9dde3d4ab59f5fa360cd4dab257679d21add82da72a522fdfe09521bb12f7684bc75894f919a891d60f95f38c8c23a9c2d9d554897747cc92a23af4cb171fe960611416bd5d8d6d4984e70ab014fb62e6f4387716ce0e9ddd8783e587b6a97e0802c0fc734b965a3801264fb111414f0f386a1b9fda662dd959c98265651f9b465d9ac1d0502aac047d6ccc6fcff3490caec6236724008c3a19cdb6be02fc354bab8cefc53d282a981930a5800c30f146e131d793024b6acd4d6f5ce4b0fbe983bd1b3ddf1f1f9c93237ea1271ddbd12ce96c4159499663dca2294737aaa20bcb2cbc6905661035ea1763f7c77bffa33af5a3198015e6b695742f6bdbc50a78f98706de81206ed71a7b3725eee7400d53f7fc39c9cccbf651a1cdd16b53e8b530106735f687ad66b3b0b52414065b8b0ae0b7ce2f4c9c1d3bde91d83aa17ee11f38e06cf2fcf6ad04bdedb3e948f6f64385562ff6b9d2b3eca6d4e4e5ca435dd60078bf26e2bacd661ab139a353047bce6d66762261de9414e41f488229549d7fecf5d3634936530b94a76253dd148026e275776409d25596d09db21d32b0a67482b18741c35f2b1c1e7454a108ca33bfbad04b2713d77d5d70cb6cfb840987686c156512ebfe9bc1b7078ce1bdd66dd3b0a81a73cbe4232a2d30e5f37beffcdd5b888eb6fbc835253431c131eb036d5975d8a1a8ec4d5103e444af107852e9fdaf988156f200b95fd9c29065473f43119c3cc7767e63436c5d476d5a3049f9cf2979ecbd6c564ac8e2dd1e17d063638ff0a35ff937476bf9ccd1dbcfedb0ab6c260158a8e9dc8b3cc44ccb9a2f13d02d082e5766565fa1f82008104303a67fb0b6c8481cb45c9c08bc81291b835dc28a5054674f9fb2d1067ea1d16493185f21fa9d55d972bbcbefdf6e37c1317fb4dcfc72d13de50a36018e28b8a357d0d6397cf07859ec3224656f710ea39c8145a42a6764d12df345c99524764c275e3d6b6aa46c1d970c55c423136dc923c8dc03403a60334ce59cf1a5a0b1ee148acf247b8114b0f27db2573bc8163a479e824c588f681ea047e1a43bff44ca216a33ebdbede2f36a95a4d26040d7289d0e60376e1faf6e593742beb2c6fa8af7d252375566babc5df7304e198290d2707ba3990ffcf89590e214dfdd74e0b63f16fdfccaf62777bb7406175d2ce2c68b9db92a1e60621ef306f4a439bbc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
