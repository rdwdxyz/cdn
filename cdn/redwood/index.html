<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"525bc723a58b5a1ff65f1d6bdf1caeea6d9735c9a25fe7e5c359e2ce57fe4ac5ab5e345d8a4a39454107439e123c63902a79d84c03b62643331a550fca1559347e92dd0471bf4abb731c7f144041b6c78eaab1239e25bd3468281162ea68f6d06c1a054c10ab312f6d8a9ad058f29839bfc0e379cc133086087597f874085050d203dd840c11bd65f272677448d495110bf95afd42e87cc1135fce849fb69e5fb42e3284fb787ad87f2b8273fe57707b644e938832ff0fbc589638c9420aa336781521deb4c0ffc21464134a1539c581fca53794661777d5796c563d01103e5e147b02e817e298670d1868b23009319fc9705a0f3730846c240ababd2a64537e68b8d322be306f4c92639e4df4ec87b42ce9ad6ca7bbef295cd2b506b63a788fe0266a88b687e37332dd92a574e1b6c6220898ce9c81c1af2368d90363fa6228d3eb327f2eba0d23f0d2c87f1de99d3348259cab25b105c81d093971d72279bd047f91d719f0dd44e2918f563765d04cebc6ad0508580224da66820e7a97302855ccaea34ad42184de810299d4b88919a620622493066a231f71cb0c4b00a4a10606e356a2ef309c9d526f6888fb9a9fcd0c05d9a36d232bfee92d2cc8dab183d618b4b67815e4021d47df0888c7a39b65c6f1c6f01e1ad7a18cfd8be91aec76d91b15ae00bd46ca5381cbe71dbfd60587063301080f7e1a5f84544335895ee6f57be27c21ba97160c726f97e13b7d3d149d53e384f0d7c782d20a87de018a80c23e2d8d164b16767d82ade09d63a10c6e200dfbaa4ccf3fbd674927fd542add153c6b2d9777be072117fef870d0900f2d309b06af1b3d7cf1a02de6617150011debb775407c1d678060796007a98c20702e32cd76d0041f33cc83b94bef8cf9d4f72970717048abd134b1b36c71819a9fcddf8ce0fb4499459efe67ee5f0713a8dda7f06321292156400fa4bda102b2a3a659fb165aed61e01dfa008d7801ffc2940538413bae6f6b692d972d4b794cf19fc7baef9a06f5350926316dea49215b5dfed516338d38baae10cc71fe67bca6db775de28ae4e0731fcdc3e04ba1030150d69144fd49e5eae60146d3fd6d8f8e6797bed9a8102f2987044b6c577e29c8bcf88583c3791c4f588c82961aaf4de0077a7146df5b3ecbd07a3a951cf44078653b2e99c65c82f28646c7ad20aa89898473215b0b6707ffb37e9f175a6b3f7c954cd7448f4f4e33bdea6ba6758393bbc3464dbc0d0f4906c82800cf58fecc0e36b1829383634c1ba597b1b646bbfe0133bcc99096394806a46b7ebb3367f396acc6078ece2cd48c1fa5be7c7524516990d3507b04d327ccff6ccc944b40d36e454afe67c247a5dd6529fe2bd20625c22f7a304877ad6344c414b2b3bf9e8cb374e5f687d0a87db14d090965f9af028340a1a8d6120e83c5f49777f48bf541120ed89fff0c1be73b6267e447d0d31e95da94189464f1f58da29e2291b2b409069b54f69da6c3a8aaa46c03f80448dab5b2d4a345a19d302986cf5844a0de79356863a1509f63c7152b6ac2af7dc8bb2e1b44a074f235b439a0d66f0e46800de42e6c27265f5e61ec7a63bf5b3f2ad315081becaef43eee9d24a9c177237dbf8e0e4dd233e668056194e25a04f48432a8fcbe8af0352780d45d3c4dc10b878e6c0c9336cfaf8d356e917f6d128b1a22f207065b7484e26c250800e65d4dda076fd8d6d8c19c074d89fc9aec110d09cd4568b6e6bcf6a9597823ef67f47c8de5490a2de683b93cc6afcb6781fb032429516074830be4486d23c237960b359fad0022895c8ec634db0e4204b7f7c93f5a628dd6b72266600ede70fe5c645377609614cc978cd5841ae94de60d72306c28689eeeada6f1af5afbdbfb091a392861d381a3bcedee7d491c321c363a2c9e616c149784b71815e059754df2198765cdfa51a736665687701b8dfb03bf5218d9e06f79f26cc72226847620226df28211fa066293f374410f941832708f98e59714507969ec3c9de48c5d3fb6f9a753e8d42ca88e1ab4153491700d3f7692b4c7bb9e34c2f93f17cc34dc093597ed10830ec3296aa67a6b5c2f7459df04390c0be4dc81305950f0f0eb5c912724055a18738b804f75506351c30bd466389621810354b8cb4a1dbd445e74c8d625dda5388518978702dc1bd9b6f023c89cc489997547bcd1b314cebba3a033eb380981df0a0bb0d2affa6bbc8cd4a71c0ae1e84d463c577db6873ef069fa2c7fa7bedd00ffb6146dff78b567583cc9062b53bdcccf3033e3f3f1ace6c56177c83b894c76e05fc58ebd27999f8336dd16970e3273c4d652ee7bdab986f854d8f2226da9c77cb55f616b45574d1437344ad9adca43d7c14671000fdd788d09f95fa0da4061179e9c95ba89dfe521b39af3b61de040aa2ded066353467f98c6918f5dc45bdc64be0e8f9e7060c0272a7e3b9b47494a0d170a86132ea12f52fff13ef343287d29cec308b566ba3f3fd55f33934ef0970b1619d630b8238573124b39d87214ef18f7087b6510930dbcbb2d1971f90d596cd9a949ea4d83b67bcc84ecd54d3044434964cab1bb561bc2b45966956733ed6a8536e41ed4235d82c6843f2374081f1ea2ee0f6003743f7d6118c7486f5df1f480bea6448da37056d05dc57fcb3559a25edaf27981946e2f872eb95f2c4c8a6d868f83d5be185aba852c8af023e555293e17f34d76f36587b2eed9aa6e65d63bc4fd758a0ba4fb4173371e134e31fbd8f5dfad80998f3e304629eb9c80733f3ee89e1d3264633dfe8888176892f7b2384f90882c1665e6f1aea58eb8f550d2cb448708e46c7afe3351cf04fddc0e196b90df7cd54bc876453ecf9f89888db695c5d42bbb87ea842110c6ad4f6e8b8cf30760ab4746a7cd3f7911752a205fde9f15ea92e1805a94f6caf03dd1a0d5322686495310dfa9eb6462dc69c3067743cee754a7e2a15ee9b2b420f8b9691965e3f9089adaa1d0977543ee48f58cbfbc6546d34bc4d732c3b8a1a81f506a41da254bde390992b8f535214d7b783a4ec2c64245dc0acf5babf105b5fce79486433fcbd41b2a930ad9f425dbde63964febbe6b70925f716a5de3b02617a3864a6036fb41aa8c101b5a34920b695b11f4fec6b65af4336691b0910eb37f1ae0c73b15ecbe8557498edaf8f900d16fa87cfc6118704326650b1a4a5b463bad84cbfb19968c519cec2fde53a9ff6fa54e7df2ba23f81c8bae0de58524287db836a0f772d193537b6629c38cba24b12b312344376509b9d7a27342a9b0359f539afa4da7c01b19463c84120013bcf887ddf514fe81a00db727628d72341d6645a64fcd74532d723fed0450e9f0f1734c5f75aa7ff5783f6bfefd1b01516e78cf11a15932659b9fc44f113b258586bc16c9a68fc0d761b1165eb76652af72513a67c179294e3a02c719bdc766c0ffc9078f548c1af08ded19e9e9e17ca0699b57c0601d70054a3ab545ecebc5ad80285191bc0a037b39a48ca047e4db39ed27d121be402578e0bfb86eb98410c5eeb710e72ef9cbf980227aee4452973964d31a1b1c23d22013158c6e4c0c7df5c8004918bc35861b7060c6ad5f20791eae11ad5a94c85247b45caaa33c8a7c4488d1b8bba95a02b0c535af711e1a96b7cb0dbd2c29b9a957c1eb80c79397e5148e697889f2e17b383fe348e8b969499edb1b1d859bcabe240aecf214ac5c45c26632d5c8bc3253e0a4ef8c387e29d26a4f7654b6d7b10b467e73128729e52d098eb647647fd7bd77915210d9603fae04fe102443950a0fa5e6c5dc046e6d73081bf5ff43185000a868806e4a7d7f1a4cdc749d47ed962494f4663462848c6fedb70d1b0f3cbc713b09da90ffc4f9694691db6b64cece1d3eba4529340b7b5c3c35db301fe53a9808ec22d56cbe468bb76b9257d9a25992203989ee5ebc6eb0fa25e31570b87e03a46b17f85754bd9d15a0c08e66a7155ea6e8b123c292d067bdfffd0a52daf4e59d7dda806f06cc1a1e5d2ba055e0cb6843bd756fa95660bbda419e9f4b50e26a82c67fae0a735852227adebb3886030ac5991ad641f9cb2201640c9ecb39566263db2438c6af20c38b63105d39dfa05285da6f22d60bf072daa79f36f5495f7b6f1f7fd2ab45e588bc4ec2410cfda23b7e6c299a102b159e4682509f59a455ea8c8e37b7f09a58101a57be09e1f9faff14f5dd424023b044daa0bdd3b750d83234f0d49c0299f5c5796e1bb50fb11b13506bb07560c95b282ecfbbd94aaf87cac5c4b55cd84556e7e8e86d62a21a1d23aba7089697c103ea08b9a1de8b77e30892548019c59327cf0d1004880c71565dc55f1b10d7012e33583c9364f7180860a9ac73db63383dfcde0214b0af1de6f390a127adb446612d410539a2a32aebc3de9d3154ea20e380fed4d4317cf9e26187c5a8f4d24f2b9985bf1d0a68bdc93d2b0bb9698960acc8a585a4060c261e3604e96711b234b233725d6f0c2aaf3738d13fd6c946a985e729823e0b998183e1f1892024def8baeb64311a4c804dd57da493813b1f07841f891dd48a8de2880cdbc4c9d1af1a8b11f75b685d0d9dec942429a71fc3d6bbb5917fab3f41059f9f1acf1fe42cc94cb55f5da4b372525c39fb58d9403b15a4822209eb6dadfd2b747ed6fcf402a89bdca85ddbf9e527ecc7db029660287e74322505db25a97e3f15190b7a6ca807fb4c3ee631dae9251098ba2fd3705d96549959ee25f46654847761f525233a66b705b5e087d9a3a83215c543e8403975f21ce1619588838b80211ae46d3d65cc2ce9659509dd0ae698c32631e0cc45bed7158db4ad6f43d21d55b3369424b41988599dcd971927ba39a4bdbe2869fe9dededa0963d68cc8d98152481795dd16fc52dcd9bd82c5f23bcfe3343e43882a64fc8ee2c0ce5471086bb291345d0cc7c488c6ff1a9a4e17109eefe7a081056bcdc45b60ed45b1bcd14f09d13b4f65f55e5803c832b1b77d4363675c33dcffd56db9a80682ad6dc1defdde6661b2a71a6c79f153a009cefbc1f2856cc69de8ceecaadc4fb9404d42d34ae54825d92723369269e8deef7b820e8da08054c34a79a342757e67dd5fab4eff7ca7c0943b440bbb1b619512192f7e1dc5201fc133878c1487bca3423753449c61d4ab9a80452970a1fb0324453f63ad130f4145d38f78fa7a183670842e9a0baf520aa0189a5c3547a7227f38cce3502e84d812f1c14cad30b8117d2f0113fb112b0294d3aa71643508373b3c18722d400dfeb841bcb49e15ca6d4b3335995072ea626fbc9d430cf8ebecf2bd5984c6fbc0def222783012307723db2dc47a03696b4eab9c1c8a83b4dd1321ad11c4ea03254ca7f5570cfe584fd571d7504c5dfa4c4c2b3ec6f7d579300470594850ac906d76e95c5b74f4553f34206523ed21d9d54477518e9f182aae4f309f5e15c5a1758ce6ac615a197cf141825268ef0760fd29408531633945f2b0b9e93a93982521e88fc186733cd225477541a56672de83e58b3fdf81e364129186c3cdcefd89300395bb1baa1ae3a651689af153e839890e61e7620a19fc18a4c7d9c3f332190ef4f6304daf7ca3b13f91a1d1c9b30bc0f608f685c08fc615a9848692701fe2260a10faa72499acf74c8d0f0b0af57b83174a8235437ece3c78efb0435c54836e1109bc14b3b3eed62fdf5d2bee43d6d91d7507af6604e64ec8deb56b912adf60db4ef773354b415661793d7925908c6fcb4ac46c408040c31f848341b40a37c87a06451c6b86860a18edb20c4bf5e14059a8d963c1261de8fb556149ed3779b4787087784586beb52a85638aa1b7f32ae8a2186a3990b41d85e4306c0dc8b7dec42cb560ad2382091e1fe3c91602cad5fcf75fd6b3f4d07fac63934fbe0547053105dff9a0ef1d891d7879a350e27ad3f00dfc35f332449187d8515e01936d93240d822f46e3fb391a47e8aa290d876bd79259fa79ea13f96a83a3ff9d0234ce3fd94f80d16ce628e7dd744664dbd5f20140543e9ea911f9aacfd00141bf9fcad38657ed6bfc3a031ec4a85bf35581d1394f40865a668eb1da521376cca95c16c9c062c16bb69a7f67c740c43550e3141dc00a85e2d57dd1b0e1a3d146f5de39ffc4090ae412991887020afe60913f4369a33d849ea540bd56ad7b4c978fd6a37031912ca7eaed26daa81d4e51352a711e1b503b5e9141c21976875163498696ff5b54b03625914798e26537b07d1d205a77bdb0020420044d47a246aca00b6ccbe6d84addd991a72196f68c28017c95ae0950b58d890ef3e126a62cc4eb3c823b3c353eba952bc6f935cd6850bc5ebcd614f545223bc3af08c1f8c1f8a54e1d96f70f983440c11ae9b6c31a294429835938ebcebe88380c8b78c5272372161946e7818ca112c3380218c6d7f619297de1d0e8e653d63cab07b86025dcee89722c91483ea786361c41392bbf2d84369b0cd2082cfd1855950539dec3eb35a5204c429d9e7b27d095eb8bcdb8de55fce090d7ed870c9ff6fc45935db7f311f17fa6732d945e61876ce4a715f9c9044c4e6582b25cddc7de9471503c75cf44ba49b27e418255ada6c4ff2456f9762615613092dd8558ea35cc9b0562e964bb7518f847e0c94a73fee715ac6010400216bdf20e6664969d8f24349c90917d5150db34ad80d015a5452156fb382adbccafa58969de956aa91026f917089ec6d28de9abe8d3f8c26b8300ee663875377307573dda6103a0f1970462178f6191aea9a405d1d872105417741dd8ee5a2126a96561791a65fff1c303223d249580e3f154e24828f43a2c7bbdde497e0a953e3e22b6775526c2b5b18cb26c01e30753aacb85224c0fd39d572f07898175291900b96c3d9e8f842b6d3708ea4d361d3cf6f592fce0793dc787a0c01046651a7007c355e4bfe5ca4b470c6c8b595042968301d729ea3b0ae4063c12875b4eb46a8cee466970c73fa67d2568f784e438e8932ba8bf781fe00b32ce83967faa5efce856b5742f6c9431201fb00b873bb09ffb35a82fbe8801654304448fc146b712417ff7ec122fb332a35cddac30b36c9280a24f0b08fdc71a685a4979ec42a1c8d7d03f8f3fd8d2bd26e2d17bd9603bc3f8ba576f89ade44e91bd4322dc49bf6a4ba34545090c234834a043c0aaf44f3238336d4dbdad697064b25e16d309ca9841cadfccff65d49a36bdffedfd4b99a22b37cd260c1ce55b867d4cc2c594208bc2822cb0c56982021c6092392170cadcc932a7d8961f27a8a4b951a9898e373630f8db93395fb0a84cce89095d795d2b617c0926972e98333efdc9589764d5946ccfd18cfb076fc0869bac7c0a7e210656be07bd538567ef05b29ad8b7263721969b2aee2617dbccb03d9543952a44f5b06f45daa82c224847cb73cdf006757a9fb3e0f45a0c686f55d9c726810f75ce52edbd40327e247e01336270e971f348593d9a486ea14d1bf265427433f052ce73542df560b412881f343aaf03b2dfec3df1d0edfe29dcc73f6fbcf586b94641ebf4b5da405c1014f215ab490db224bd0ff140bcde80f81e1f88a3b4c64ece3dc0a56d9811c737926acabc2d101f0e6bdfd5c5b4c1f1222ec58a8f97d179fba260c58b279e304b30986ce7f3b9ab15bf3c3555fa8efbe8d46a8fc736307c5bcc2a709752e8cdfd022b37c92c7d747c9a89f34292b8b89de29b4dfbb20691f0ee76d130e544da649eb6465a9181dd0abb0eaf1c0e1e6de5a8414630babfd527f27b49f3c92b52ea51eeb888e946fae2a9c2025dd5f15cd3dd6322cce8968e6843df3a375d0db4ff48cb87e43fc5e68686df0466307645a0986410fe26051a411c126725b463d4fda0e441b717fabcb8edbdb093d45e40878004dece550f1574955ac556e6921a94c568365c7a1d3ec151961ef0e9b390ca556c7583a588fcb6a07279201ddf2ecd7e496a265c2f1c58aaa1500c8c705c1ceba7a7dbf432349f2385ed5915cc654f317abc50bb51bfd3875dc505bd39f92830064be21b6589af8bf06f75eeba78eee0394270421fd0cd250ab9bdd200ca419095d16f4b4d8379588ba9c65692d2bf14e6f4e9fb60264bd01b7298b96a07637101c167d0099827c9a26d8508ad777ce09e1e260f44eed16b89c96a87c93d915685d32173129dcfb588c0a0c67f7650beb3f7ddd6002f50037c8abe66223e6e5f4a51f1140550d93d3f9ec00043f3279165354565aa66a2b000fc849d702f8d24a2f430e1caffa3b6c6163bb3571886ea16133c2ee8655032b958fc744726c6b2ed20bdc73519a63dc4ffc1df59ade67b9630c7981e3132f6c74f7559f24913962040befcb8b984fc1c985e7427cbd570fe64354cff87fc110f0ea2c0fa6fd74108a828010a040a121d630918c5b4067d3c0b418ae5a9c74cea3e552dfd4df9760492bcfccd145bf294ce8cf1f559e131f00b7eb961921af3e2fea8bb936a4d68117b8c6a239feb2219b27f62f5bbd7cd144ad7c6b2f210edff290b0842d9487e062dc7ac3e4e535c2586998391fc94ba988e7ef1b637076f8c0169e2bed888ccbe40f0548431a2b8b78bbc29294facf5ae94c2de0308dbd0a45679270c965be4e7c51f298f4cc776f90b530245d23e66f4ec1bf6db20f8d9aea324dfdd28729028cdd374f6c427e14e46aa0a7c6cff6bd0699f8568b9cc18975ced32556c04ffe16bec45ff195264b71e5d1e3e3593f40a999e3900208afb2990fbe668c5433d1750ed3cb09ae9ad7b5304588e354b1427d9579e3b7d121e952a91033be6eca742b14287a9af45b8d6cd7d93c77f08a960db9a4ef73d31b4a3727a8379daba75dc7d99b04dff1a6b9c9b72c9fcd870887807686a8eb9a780eeb1528de34db7b75aa6be4806e13e057b64681bb1317db5acf36883cac2f391a03386e821489ec9f90b8f0d02b947a9c93249b03e526a152a6694fc7b08d0e68c258325dc37a11679de30383343df6527440627936105bc2559706869284408195d52fe2b2ea8a063b93ebfc7b47e5769d5c6048e29d03c964e768496f2f79aa64e9c496f93cabbefceb2c1fac84a39b6692b6f3413b7823a066c2e7164c5e0a0c1d58b5aa03de9821456f2183e8f1f66d5adeed4e624d8df8b7cb885c143f06cb66a49bbd9a08c90a5675111d09cc0a62cd9602947e6412c52b94a0e60d650f08da65ecb5e25571daf0727fab690c229c33f1f70c00be0ea5153c8b9c87a9016b529157bed61998d805e70ed0326b7ec9adf018ad9a17795828cb57e7348401b32636d114bca28d39950f35afc0b7d691634a19f658bfbb80c75719b1cd573f569b4b2812e6cab368a4bd22365e3d4ddc7c9fb29ed29708f67aa570c646fda7de0ddcafbbced2b485d95db469a8fe01a1551f6677d167c992bff1f41f436c7700d8c5fbf12d233655c32340efd2bfba1f55707c605eec6ad46b19d205b0153be0916180bea97e4f769ce5c5e224580319c0167d00e2181d70a975195a2ac1eff2d413f8b8c1701055d0654e2e6fbdc04842025d1663ef5a1086abac5b90a7013ce7f534cc87308ec21908ba1b14f12a8650a414ba6f26f680b58b683e9113705b1830ddda5994be89617edb22557f5946ab8a4111205066ab0a1c6d4d0f17319c81072244f8fd0075bfed474090cde175444b6b7ca8eae600419c77f8da9bce90cc1529bc4c5ce3c6ddd87e3ba57e0620d83b09a4d4b4e724d36523f235f685fcbe4b605a99e24f0307e0e0e7e32492c6ac958e375197a0cbe33b14c91e3c9ff2a50b51dcf0b97be3707307fe02dc8c16fac2110d38450b93da34fa457c962f942aa0ed4a1d30f2283ec10745a18b6c1465bdf7a17a5f266bd8c8586a7e83389f23d1d2b507b1fefa6aade4f418da32e5f7a655b5b494bfdacfdf98430d6c0a89c6558c96627902e4cb50a1aea2ad2c5cacd8e5ba120da03f4835ecd5e097bbcc853fed709390c5e34bb3eaa598a9fea8e3e43fc6e25bfc12190be928e94708455483c639b3515400846d12be52406a944af5181f7a136b163644d58cf8438ae9a7b7080d8141aec60aca0812864f88e58e596e87980e780bfcb205f94d479a4b3b4f56ab7c8443d8c3ba28e7329013d9e396e0e07cf0076067003381621a94da50cc13806ce58691555744c2e5a35f973ec53b5024308b6cf780e3fdfb06403876adcf8993508342792a8558aad932d15ae5549b7002d9838c3ad6902b23d5a122fea8a69ccd255e71e67ab52f2ec72ebf72a64795f47aa59557156a665fadc53c77e34b28306dc11a48cba32a40c0cf0c69687a26bc2277014e6adda441087461cbe17506cba4215ee7230d9aef4dec4fdb84eb6a58cf1d8bad8e4e95c9dc622170d62a9b157c9023c1e369946c6f7dfdb7d78f2676889de45d8cd31389a4832574eda562de2660336540ed58b1b2ff16879ab42a5ab4d057b466c558e4c13641658d4f14d224ee79a652ac8c9847803097e9f433be0ff2d9be80546a1f607973fabcbc7738db60ca47cd2648b4bf954390b036933c54aca05685046a0071328e3d6c27f060b52b49ba4561ecb4551458331774ee1e982a2763349008e7dca32f78d82402ddd33c6b0893fd06ec8e91d0f50cb045f7e89a4a8ca4464c40d003227c589490046e062bd03baa0336f866afb4ed5d11becc1dbcdebb5d12b48bf6c73df53ba6aba1cb1e4719b9496d0efec50f772d3661e29369cefdeca7b83fea290ca3d11015fb998dce75815ff0de6089be0f87cc6f3420c017e7e09f1ecddec8e6f3137b3e5077694b357456477ec9484346788f71ef423a0ede30728524ca85b37d7bcd16120efebc4f8b574234f02d63c8ba9d1af7973866a69626e6c8e6695cca5284720ad51bc87e3ad8c670c96f9a6c133548c8bd55a76bcc6a96343e97ca73172436840a79d2f1218d1b2077cc97995e25a52ba427c7ded88517a599a7babc7619ec9f6ced0caa20bb87ad4f83e816f8a2a9daa05dd25554565e7dd8f2943d69ba57df7c2c6d27229452d3d53ece7a2c92a99a68d862820576ba08e80636ba8673ee2f526709c608de54dd485ce7ebc82b40ee7549f466c0890e90a9cfd3a23dd46e574aa71472cd759b06ed0e4d911a7438f226ce0edfbd92da32510f0139b474a0dd5e3b651573442da3886ce51548f3dbfeadf9189036771ddd4566f17af1b46f6381f9177e1f209b7061b55afffae0deb4525c1edb9a5d5beb438d6995d9524e4798349f5d1a354980cab209a59fb707af922df24d2e1273844c60864fa02f97b45bf5ddc5f8612b8531388de83ea47cc3ee0c471b2351d9237ec005be5f9ebbb972ae6edd5d4d2af11622ccfbc88408bc3cedb8e2dbc7f5e4c7db64d5bd58155d6bddffac9b4ce6f93f50c5f03e4b728f7a4d3dd22c36188c3125bb715b1bec609a21fd79b3c2a3b2fa874918f8f90cc9c2467c0923a93191159747704f917dd11f748b7e6df01bda036ede4b26ac3c44aee705d7d0c4457766f8948dd105c4d79855ab048c0878e7f6e86ed840953f6969e82c8d3b2815ca4b1c8d70c92191948b78e718577a15436731d30ebd6efe460089b9cb6923e0a3280d77aed983ade2e881efa67332c342d3f157cd0554c54c91b2d90a4607209eb1e0a103bbaf32f4b3eaed9cfb4a440c3bf744feeee90b5d4846a96f6db3b62d69f005862440bd42a0e294f9f3f8b309e24ecbae589d342dd74811e36bf1b862168add9514bf773aaf8bf5e177228f5f7822dc5b16c53db62e68fcb5bf3f4dfd2f1ae92aa766d137fb88584f9eae5772066dadfef68d922dbfde4e17d92e5c26eeaa27eff57a42b31a14e4404f830a5de815f99c0618259beae73fbda1b55007a1276fb3297b345abef52cc4394bdf60046183e0f30b47a2d15e8ee3445b9bc8b9f99a747cb56c07fe94ab556017de1bf4bbe86b295f67cd86a4bf4b686132f11fdd3db84bd1aad19be60995dda16b29ca822537e22fa53e6c259985e0404c9260dc698b78eb58497574d0848d45af5ca58829adc60a3c0481b7aa5c1a8db4ca20915bb0ec0e151ebb8765f054ecfdfb51676a66082376488227d1210bf363c949025e8be9422881b9a60929cca19d429f4a011547b07aef875d02392361f1c6e131fb86f9f8373f83a0177555478a2bafcd950a0e5dc7d9afbb0ff48ea7fe2274c3f59e5499f1b38269ec67d4ea66b83e9d6d0ccaf995e533dd096be9b4f3d355ac41b39a653a69c0e72e069a0600e1e77efab2f2761865b1c5a801c3b14a61cf035208e1b46feabc7d776557b53da39d28476cd254687d7dfab2f459a023a6875928f16fe029cdfab68e1258ba7ad788a076ed0d8bc123ab3404decfec3203567214b89eabad0c76cffe72768a005654ae9c34184de97b99d293e6511509808ba22cdda4637df8fc4b5a9557ce1aa6350f1aeafba7e4df5c0392f23e45216a89b098e2b8eceb51ed3bc15118d163707ba4ea9edfad294b8036bc54212c7c109846efc2eed15242f4a585e6dd73eac658de51c59f9b0b5597ec5a7386dd178d9d04cf813ab8b5d17be2d9dcf78f38f3066719e1a29e847467af495a3ca3a7a2f10b630c3a428f90bc79a877e8348555c4948ba682f43aed164a5104af7a417694762b79bd0c9716714566e293f7b008ce1d92be1098d9e22184823f1de362dd74dafb9650758284cd5cb3bd5c4155606e1a65813ccf4b0383416d840c266c39abaf50f072bd9451650d4de1fe424a3399175e1ac7969ed031eaeeb3ca60ce54e647db70d033bef3e9c6954de21f1e13ea488f7aad933ffc1a7c25307f1677b966c5413932927d48d2bb79eaed818d478f520f45deb7a734d8059f504ad89c585f01d341859cf07e50faf2448255c2d6a25e35a6839b2fbb8893f54bafb8a37935ac1a40e39c638d1a46f2357e733abddd55de12ef11f1368991b464af00dc7e3a06680d804e8f2c9cf775f470efed56a1bd625418f68adbfba34d5f9994a925850f83c29f9aee0dc8c73f0ab8a4ad6a7320d164f1a26232f8f4a3ba601f0e32eb516270aff956e88830dc9d9747817d9e3c2de18e2fabfb0faae81d7747ca50cc91ed62961b895842e611c619ee4467c43f69bc9ad69327e61a10111af01693beacc8d087a5cce32257e7bb92ce89360d827bed93ddf03a8da30126dafea7b08b092cebbdf2acc918019667f289652f88d161ce1f87bb25af6eb9ec71afa255c8900c229f3b573899be3236f7f4d666bb9073f5d9acfb774b8327baf64b22a1440089bfa1ac1547136c263c3c771c035c61c531e411cdd8cdd369454e88e275f449dcfb352e6fafa7cd4657b53103a949d2b0688742735467bc8ca9db197c6c0d95d57bb3fe4825cc5903cd554228f3068b4c820dca871179a48e0e864d390442399d7797f21beb18b67e9aef88d0999274865459f14f39b3107f31b9db59f3652c8b4767cfa43f4d5147e8dc2700495e631884a707aaeda52e2de80bb1ea9302f618575105aa06f8125b08b1043f434750d636fe598744ae121da83508403c306e90ceb08ddc42d91f6e3e59bf618836a4f8f24699526f226f1bc2f33028f7a8c4a9d3fe577d55f5c1861ecb6464b80f27dcc985e69f24d2dbd3e7fc0cc8e983b02d0be61d85e130af445900fd268548440f3b77f2b587635f6a1fb7060d2b0d7b1ca193f9d85ffce4a0be7a1d8923b38b46386cf557c399d799c7450801799d7d6631c65a273dc63af9016cae25b017ba6115c4bc3b90a33317d52745ca070074f056d2b4f488887d51430488e1e239af837a831c30c8eb8b8ba17b7c244fc72984d9ec95aca0314efb1334d4cd4548a005969106d5c6ec07a7dc015b5f31210f8917061480b07d04a9af27905fd98315ae6b62809c936d540ab3cdc7247dfce7b5cee816310a2532478c9dc0930ab25bc1182da3e4bc36b5596169cbc1b7df202865f0afc77b2a6b7889fe201dc5b495520e3ae2af2bf8a3bcb7147c90de9900950571daae1baeb99f523205690ff939c1a27f956bdc9df59aad8810745b530a9780ef255bdf757c07563342e2d44d4feed9a60a5446ca7d6bcc7edf6f966081583ef5585b3eb5db7536c558568927ea9ac81ccd28d64d0b195453e317c1100e6ff11076f78869358516ac666a80049215ef5c28623ab56ea8f3e88d20776a6663490ecfbfc44dc51036326d624de6e2fab6fdd03fc0503bfeaa18838c4f367a1019bd038c7fcf938181dd35db5c24cd55f83e0a52080155eb18c3adf4547cf3de3c9a5351dad7d06d36fa299c8767e6bf5763d475d7eac87fa00c9fb26c6689f77db3607572af2747d8fd5fe62df335ee2ef7c8cef73c634a7981ba386d4f8fd1ad17a9ce45e4fa2b392e034986fba105e93466445a4cd8d905acb745381c44710d67d955b356dfa6cd5a78cf40fba99b73dd803d85c9e019c8be6125fdf33a9dff8d5a59824e3b447e48ce772a24f8b22f63e2a889aab9ae0c048c5ec7a7d9cb7ff2cae66026c375b75efe7462f8edacb6286160740aba3f6e5846d25959555ade013fa24a7b697dc837b512768577ebe5e7d2280da9af2a1fbc94d15fb22b035aeb3a2c5b2cfd242518d9e3ba1347a2ab2be48c51676f27fc46828447a95d96fa7fa7eca3551d2615d599bc2f8512fc4016a831d49c53205c54c1437a9623596558fd62cee856bc10e178280b1d354de7da634e1dbe83f665716c7c1bc013f8b0df5a4b85a1f036c6d79b4b79b43a8d84058e847ab4956d713d0217b0d3970b12ec25854ea973368f1a0a0dd611e12ee67f8929b18a03ea17e9a9e3cc78ed54a4640b91b509398ab5ce93bc1b0c43abfba088d160f283b3da4c116ba0a26a286e00093811ec1b615e054560450f60a4850ab436b2faa9a169354ba0ee01214f11c20338e9694c67a417ad1fecaa7ec5d4aefc02262c4117f8fa379ab8614f8bc967a64a023e2f47c8721949fb2eaef20cddca6cfcd2471dbd093d6646a24ef5a61482a72efa6732b491a17157522325446ddb17bd1feb59041315e7d95d71f5cbcbd59842b15c1d145145ae3af4e16e653f12637cf5fcc376c987e18c69001fb7ba4dfef4972f3b4d3dc3250189cb569baaa11d321f60ec2c09d9968c5d5a260bf13f613a428a35f5ff18c93d6800ef6fd824b717cd55f498b16cdbf05f3abd5197a288d0b20ca9bce2c6f40e0584cce7c809250ec1acf8e7132b0540c82d0257a1004eb97f474f0e40dbd7d458dc037b67d51b27fe1c0487920ca1aa1fda59138d0029832721beb8ef08a4e56a0d21377ad01e2cc0a8ea955732e73ab074b2b0b2cef8dede8811ba7a604d8349a42dd0059138ab855b58e4b78ff7622171cbafecccc27990e615c77c02a9eaf0a1aebd9b211a15f3370ca01066d6fb2aa0c3d8bb15f74a66e0c7b156e723dc538af64f27e0d38749ad8b797c272488b9e524c86cb0d011df695f378ea1b8a38bb1ca1a3ef22f9234d50e790c91b28d35dfeafa4545db1feef19f8be5412a31eb3ad70a3196d22f8013b0e1b8a15cef6a3ec689bcd49646042127ec4cb364df74b0e335f6dcab8f301dc873112df2fe0d02024457cf5bca59a269d6e835b7bb16e9d5f7f302f607db6d69a257c439ba609b49f9bc4829a4faa75dda04a1577f112c35dee109083a71b88baeaf2f7818ba225140d3df58a2fa4642082a68be9464970c9b0a87ecdd0d91f2851864228f97e0a0060a4d662839750ec4038e904e93091c04e83af34edac0350cb7b228630d4a6e17028caa230544e329940bbd840795af3dcae664d64be5eb11ce222aaefcb74d99bb4e0231b8953d274bd982ab22b43c9d08f955eb78b73d2fd730b088b3e3b044a0ff20f176a5082864ef0027d6a217265ba60fb853368ee174c5e2fc01dece39a8c66e211f4e07d97e71fe3697d762bdc85b5e39a34361a25451fefcce3e87d2030118892e5943d7db349a39098c0f31595915a9d0f2b1c0fb603171d5113b5d7e2e877b8d6dc9c6df20d1ec73e2a63b260d2deb0571adc503be9bf125e6157614a048262284dc8e6a12c51f45b179fbe7d19401fc4b9f08691dc4b3a8a85041b1f554ceb3c5bc6bd069327e31c52a415f41b89f2f2ca25d1207c3ec9f83437a17e5326ab2f9266ea1b862abbd1e94522255d483bce7bb5e0a9735932af5a8f186c4c0dae389e0cb67dd5d97d4ce8227a46d2973cf21cbfc6d4fec9434c14f8f8a97844943ed5fd702cfec6c8d50e1dd25f742a4b7d7a7e4b1250e3e07bb83608f0bfb46ccd2fe6e9481bec28a835729af29ea06855881965b261f7571f9386aea3169c9f7329dc13e11f91e56bd79c5f763e608bdd322f2b48fc41ab175c7ad7327ab5d25d5e8c5f52fc2a529a4f704882c42f9313914ec2e66a7418c16d21aa92b5ec7d6858cd19afab547a099fde06dda90996de97caae600faaff707db27d1d10ddbe7607243408dd6de3af3651c51fc799cfb4a19ff7d8bc116d1a012179165c867b2eab971c337347ee0a80d5c9586492b5fe043ce26f09b48d3a57bdd01f2cc206e3421c161e919ba0cf0d41d69ac12f319d89384074b35f7af2485775541314e9b0598b385334978f811eb1a24b828f893319f9a3092460be80668b7600e6099661e7fade5d27ada08a779b5ff9dd0b83eb4b242a3dedb6beb460bf3b816f9aeb3b7dcc986cddf354b40030cac7433c5c597e92294385216782e662c05afd549c3112bb51ecdf3a6ba68bbd1716e66bce28710adaf7b298cc970c161036cd4c70629904ade9b5c75745da8861aa84920bbb5d5ae8d00147d7e0fb1e3c37cd4567690d7cad3512b6bcafcdc7495dbd91be7580a9848c9b82725bf003a0ba6360f3c8630497cb2f1c9b3bfa551f902f4377d0c89e72c79b38758e05da19270e23f026f1f3e37679887672516f0d658809d2fa5e1f911a42e7b215aef3f7564a528c39b63d911e2191ec92ee01eade77072c91cfbd4caf37e25a9118020511c09e6bcd0c56dc85746d7c1207379112a7fdae5ae9793ca669f958f82ce3179f527ea49fed89c466586ad2ff91456a9447c2df129ab296979fae9117f2dfad986ba26e811b3902ec30834c4163c06c70eb182858c8ce5a2f0059f3493b79ce75d31b17683ded0de4478cca306691c434375e407818754eab37873761d7cc7cd6cb91b34e1c05f411b4dd58878597ac8f00ce30a4f80dc466355bd72e4dcd97b63d82758f52247e79c074e6c649b3c1af19460f5c099ac616b3fecb2926173b288f961f0d5f5b6f340e7e44046fb5c1f05e8f08474446ecdb1c143053467a4cb42e7ec1f1193c6a8b2c0bba57a33120dca96fc4f45279caf2c7c9dfcdb34d527234bb0bfe6934f2b0d5adbf906314bab3ea2204166e9b9debe57a26a71697394a4ddb40c282f4567ffca9c18a38d7f87cb646d089d85f796a746502667b2839787e7322b09555d709320cc35e436c2c730b389fc9eb789ce81a9efd96a532dc44f841587dd160efe16573b342125fee78ad7b3a52151b92efa33872ab76717662d164d69c3005110cae7eee72b9d2e044012805403b25258e344e4142c656343a618232721922b9be80c30c4cda095ff7aaa58d106b72a1fbe48c72d2695718956bb911284f332651e1a29c3f0cc803a65f824d48da030281763e703103d614b25ed000b165448f2164c20825f4e950f1493959cab8e91d654f80680c6c535ae2ef6688efafac3fc4b1477d7d8f481e7d31859a8c9993acbeb47b53d07eb04cba6b26be1c741f5ef57330810bcae4542d8e7e2fc1ec1984232ec1a53cd05e69717db437309b1beb5125b56113c431b65e34daf0314771885b8b252276cca93a9d40624bfb2044d3eba1785dd28726364c3fdf71cedbeb04af4509e20dace67632beacaa79ad65b8646d9a2e2db1ff63e286824b539d873110843473af195cf61579078102214e578fa379649908518e72602a005ad12284fa8c596fe31c6a660d08b555060a1d8e7ad2844d5612503cc4256b6d970ab4ea6363b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
