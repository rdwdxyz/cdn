<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46a17149390b21829175b4a35126bca10ee60bb5e74ed9b9f3935d4bb4f0d5bff06decc928998d009bc40afdb4df2cdf77d6506460ee15b112f30e9056cb228f66613973f25cbc12bfe2f458673d97114c29b8bbe906ecfbb39c0d67d046f97d85217736d74fd927c4fc16cc3af1beb10d56d52bdcc0357259e777cc47f436a776a53d1ed7e2917e070e149d22335d676a05cb0241909e384d174b3ca64e59a8e8326cb16246bb5a46c66627fb44f1295078369c7debe0345102b66a723b69e398af82088b9a5e431b1fa3fccb2ed68fe6c242209d6665a97ca9a3545ee9c3630cd1d9c21dccfc8fd31bca397c7782fd944a9559da2c68aa6f9535b8a41cbcf604871e372de002b86d1d1f1dffdd3e492103b07f14580ad2d57af7ff5350becd4bad303376622125d6b79b18e4e23bff967c2650a15de2a0d8aa7acce1e9cf9791459a66f2924e898df2aa1c7b00a8417c8fa54b5f0848644566a623653a9e536ac22700e33551f6c148db4fa2cb4a1c7c1c3ec3b0c2d191d19cbae431ab61e5237f3bc755b9b94c91e3a8c1ad244318c32932804531734622dc170d67f44c5c83f6f1a4d6dee39e08b30fb4f2d4304d50c3469d600ff85ace6450838ceaefa3e6a97e12b42eba07b032b8724962ba904b9b5882619356e95746beaf8b0d41f25daf6134d4a178b753fd8223e766119ffccd4c833e9693e95323e009299afa7449fd2cf3720d9323cc92b5c315326c7e7aec41518bb1c75a14886ed59fec18defa9202cb6f1d8457ffa5ff84ee2b31d2fcb2aef714c94a7fe7715b06d343296e6f7be9026fd17321998d9a32049451f40843862fd51c06df84d20a047d906d147c90482c97b45ce8e06e8c1b379b766a175c465f266757d9ae3a93837c79deb201f62ad9b35e3db774554d81d76102836a39d4f864716613b2872934c8a5e666b3c1682c959a7fd357db24a7399820f543dded8c86f7a61374ec5d151cdbb6db6b3537a616e49d678704a514633e3523f71f7d55ffe835df666130f9109e270279a7065eb150b0717092a5213add64a569710d08ef9f9b161ff766b704e13aeebeb21f1eb3192bbb18790c1c7c45c54f4e89414594319ec376e0d9af7dda93bc8aaea1d03be1d2184d92db317b856d94fe4cfaceff8c4adf52887a97a6e49b0df2bd92abe1df07a58126f5cc85a939e9a7de09fa16b5c53699d22c34d289d207623c8b161b093fd271d90ec1d0afee697c4b71295ad9f1709b8b67562b5d308696bbe230abc6f5fdaadd898874427c34821044210c93ec045ca750f97d029e67847580602896d6c9466206eef2a1a9ec86dfa47636c11bcced50ee103477e2f18489bdf79c76755fda77c36baad9975c184cf523fcee30c420b3cb0f078e1494846745dbd8cff5ad3e70b055a6179fe20cfb9e0a5302dc76a6b9d049bd1c412a8b8562d0ab0a208f23c5e54ecfc5eef963e22b0ede864ca89f84a19fd6b0764d3c7c3ec490f41b535e05f0676f8ac0ca8afd2168c6797aa89272304f94e128afd3567755018b56659bd2099fa1f77a7418214eaf9c80c9b471e5e7c6a62398e4d96909933a58bd4202569b3bf69223b54f7f7a2437dbc8b8a915e7002abeaa2562d78aab9b60e49b4e792190252a2f9cc20bd281ba4f73cabac6f5ce876a43a9991a128cf67d518d6cd8259bbb55e84ee105f29bcca40f9e2ea9980b6e2e91474ae38da3c86bb9c81122577a534a128abf9ef02488c063e8fb729690a6cd99709f36d6002621ccf5f1254e4b566f3dc371a70783c15dc3e4470b6e2d778e67e91a2caa0ff3ac42679ccd97c703b289c1a4f7c0ecf1d5ba879ba26d4ad005a8adf2b6734a00eff00ab277df3d601853a131c1cc0d27595ff916678f9cacdf06eda84b528f20f270c468c7f2811465ea0705619dc4144bea57e4aec3b7257b5205ea12253f39686dfefebc7f6158bb78280090a1d9b9664e390fbc6b1f60d8b2af09bf15cd96599b3386e1aff6be9d197d9cef5c1a029effbdef6a8875a20251e5bca00e0de001b5d945de2b4da8b7a3379f6bfb80b2b218a5a5017dba52922f0c1fdf21ccb85ee8fafea1989f1aeaec646d5e517d130b98348013b4e4282b765a3b4004caf790af50c495f3e0c78aeac508dd71f8811d10ce1903bbd323cc51db53506831a749056eed65918adc4dfc6116ccb5901423be90df34720df5ee62e587cf0e4bfdf44df0493bd80e088b3307bb18e1d292795ef0dfaba7e36b4c377287aad6065e184714cfeca351e83bc2fd77f9bc0e56cb4ab84d92c334acd4c35784f04eee0bcf491d6cb79de2300d89d734229c76e1144871257f8e1655c6b5a02b0958ad57236a6f56b51bb3ee63c23ca8ffce845d0a7c1d48c25b02bc170fcd8e8050027b87e07a40763ed5d54e6b969c72ea1c941c05e90b90437bdfa543629dc1b0dafc7324eeaae9010a06a035fffa4d9d097f184c1c3bfd4cbd53f19d67f60c425d7ad78b8f0f0c54ed3299078a689374febbccb92905e9ffe4cf14a93d5e70848aee1fd9be4e779392d315fe018a41d022dabeef71d5bf466301a7f5ab5e285cd3c66feeff0edd7000c6ff6439c36550b2e485f70f6c82f46a1f840ef1d6f438c55aa7901fd1415c9ab481b4bde9934f36a0b8e1eaccc870d40d97b49d1f191997a7cabc18e81313b3200f1539d4cf7e094bf668fbab1a3689d15bacb37a1306f7992607cad8ff14c51e8fdf7dc95a5cbb86666afb181da1593071b86840352d168409d8f74853adfa81b61b1daa4f542758cf70bb7929c042a03b64d2348a32501b04529beb9cdbfe15f9d74ed27134b45682c4aa47c2004fadb5956b14fbe0106d734092e8d6137c971750378dd68c4d19fb884e902c34ae61cfda12c7cbd84755ffdc3e17376ed7e4667997f0643cfcb952c453c398bae136ed0bdbaf2f62af7b689eaf4680073f4a88ee960c9d2ec5fe730831339d8cbf015497bf6db4eb90c66f78217951c25812e10138fbd70221decc02d5164cd7f06fd396e8b684177eb1d3d9d0184081a467bf54b8e08c114d8d75efc6870ade4d67368be016dc686ce3636d3038172afaf8c389710df0d47a75af325b957c9b11db0756c98cdbcabb9b90c783e15b316c513d673069162c923d6b688272aefcb8415f3512dc8b7bc4bdae9cf2a06c16c550eded012ae46c31b2d158e039f21a62c48e51ffebaf1dfc7b2815eade6e3a165bef27b8786c030a3fec3dc8b4f8dbeb763ae5dc04e62cb3efb9f9a1b855184147dbe3137da21ef472f2334671b46fe6573f50753f5464ddf50ea4869f84414b9360cdd774a7d61e9fcad50fe07ba8756907698912520d57680aa5bdbcb21a475bae2ac5b6f5faf99028bc99824333de0f678b5f597cca05179bd7bd7cebc1f8b234fed01c8b12b5b7c2c1d87ae56121eed17c5f0474e03c6b0a898dee8efe3b82d4f465dddadcdf3fad55b695143cb7e948a4e1ddb51c61f3dcb2232b0c75f0e85d89ed2c9e60a208025e99588174b42ec35e2bc634ca00f883cd6f75d2ecdf67675d30d9bc0af51a32fa5b34151a71e65964df35cea6afe06db034e3fd27c3df212c31c09da937ced45bb95d3f3176a0c66ec3213636607759dc9094f62e88564cae221be3e60905d4139512c8062b0e65b489b6e7ad90dcaa55989c613b4f3f0df000fb842a57c1a7403829f72034cd46669359b61d54ae2a68c9905d40b39cad158ee3a6e05c486926cd17ee61e120ec1afc6e7b22efdf6f1c8928b547263ebfccd51039407a7516dd31a38b991f076f3a80998e6fdafa1512ed49a23eb1a1870426b0964bdc7a115781e58ff2970534b0b6cf1a48ff090f0c4daec21b96431d47b87a9eeff9dbad3723c2d2e115579f24e30f6102a6124daba1b81d88ac8ddc1d5997c9767ec9f5fb9bb0239e896a148ff779939d2e21ced5fb38e957cf936f8a2e029490bd8964a5f9d81d6887aff80bc7e2869e2219dc446849e4cb80f95cdd4c42a794ce4711e2e0e37da0af6337977fe9d87dace0b9866d7e2860c8b53ae592ceff2582909aa5b0819788f3b2e4a202eea840019f3bdcc6b2972e4bd045835ced188800d487c60ef98e017c67477023564e0daceb164859f5e02f9a4d73075b57e3188bba31e4d440ce7c4fe169eda2f623abb4bd4ed1a13dce83f37744c2d03803b72b32eb01e1a56dac3ea6c419b4375cec8de4ce1a4740eb85080b95262e0417793f56695593c4cc4e2319199c53c4d5e4b34de1c5b3d3d9f27cac8cbeed9c77274e1a5488da8baed209833c4283ee67135384bfcf757f20e6548aaa150cca9ebc4d0164779e54a88d1fc24c98b6a5b15cfe804dc26e0d34ec3efcf4f648f0cce19a30adeb75c715e58d6936a0e275fad7fec7928e385a3472166a8d72a35e518c81c60823dd8e4a93d91bd35482e687faad5a0d6efa4f998e59b3420e8d1dd96ed5aab6af107dbb7e2bee65d1f14b60ef9b0c2ca0f199dc32e7625c6089c61276335da1fc018c794f27132759bc4a436afd8507090575505539db20600a27c0e40ceba8b54bb1521cbcda738de31d198d475ff7583d90d8893e336f6d64cfb1911da0145866f8d74f4cf4c3487b80da17049abc752ce9b0d56e862d253f53d85e676851da75b7f6bf77934ed461bd1ebe3b8f5af9f42e9cdc1c60491b93d6c956c2ce867acffb9f57c9d47594a517125808b22dfd20214c7a685f6658a4083071bce5eededfde51b36e85ecba32273736428d07d427781971cb49285eca4c34b4903a25102f114f5353382e4836f8df28fead0e63c4af92d9e3aee262095acd04f92e9ffa7857f8a8e61547cd61563cb80d96a388be671e48a8745e14f10c5a6d4658cb0df2f39c33094937a7c30769b3631b9b324983dd1a6b35a6d8e7178be0dc83102b147897d669da44adca1a1b9cbea2d6df2eb4a6ffa6f46c23f69f16a48cb53b523aa42605c9e6776e9c6a86bb3d7bfbc3e41247c56accd50f20bf8c17f1743236c446a8a97bc448af2d5d82efe10002a611371dfa521e17dcbae7af6bf8700a07ca6f8563d2460f05d756f7c6347837e41d0a15c67d84664f5f8b0998182d45deee0616f7462166a1a244bcf50bc1e7ac25361d9a0f70abdc896c9ee246341f6aea42677b90fc5dc86b036d9fe2d80b55abe9076f7f91a1e9854ea636c1178ceb7230c33e3daa3f8b2b2d8fcd12d0efef43428c0ede2b228b8accd4f06a4802b6b9c4cf938f129eee5d2fa122671ae93f60f02cdec2a2b8e79771deeb378203fbf3429c4f986391e0c39e8d33ead74b771f96a6f3873c8c343864271f4065af04bf95f7240e88cb8e674034905f237312c7c732b8c3f6ce90a319bd676c73adcff9e8e68dfa3ce47e15bd1b4b1b8a7984e2d110e4fe5d69e44a782595a2ea92c6a3c3cc10dec8391c1cb90dc871a22235c7cb5a439d031f1b18bcb97901fef6dbabf537cecc5dfc23337e61cf39a62d78e7eee143c24f9f6ae9375adc6e59bf435c5f190343e26c2fce8c75dcaad58f632d2639f70a5373a4b205d3791a1110058db19f7edaadad1af9e295677bea8ce8dadebdfc45ae28bc3cbf69c5304eacd8881b6b4308fc06e18a50ba252dc91d8b19029e16ea7f01d75e43f7a4fd16ae3624e56161163431e06afd68fe08f00a3c8541359e0fcea33500189168d54dd68188527466d678881f0d457df4d0357aa93823bbff51e9eb22f4dfa7fca96e4d6bfa7df29a85a30abffd8b22f9e2b04635519b4e592e5bbc09e5e66bc396cfe33e8bc150f52ee0133a3eb9c14439398a4323acda6b7aa464b7738dd2504cb794651afe43b9cb4d17a3841a365ad56159ebad91bfa25a00e3d146702e0a41cb3310eb3a206adafe8977ba4d4235f827f3c1e2b2ddec7d8ff74a34d978a7f0cbe396b8d4e757def32bdac665aaf556f9fe8e687b87bde19a733349baeed9c66aba7cb34c1167b916c5db4f4a63c7907738ffa61e744ae51fba543b440e637b919dd7be433471f90543f6c8370a1a3b40bc3e1cbdd9eb53f2a6fcfaf7c312d8163fc373e8d411d28884ac8a05ebf6cacc39631da4334556a1fc34c84bf7ef1437998f873f245846cdb87c027a4c684ce0c4d644c127304a65af127112dbb3ad16501285bcc9516711bbc2c979954169d59d649107a726c9bb287c9d11e8b7e03f2eac2fcdd27c1a71a7ff201bb279f4a23405a177881dec52148db34990b817cc719f457b92fe1233adb400988c65d25011c275c9d9a14aa93a48feeff4465f92605fefd0fab231e82d7ab2aee549c9b5ccf50f2849093d167441eba391c1dbfdaa9ae4f707c03f57c5eda5b6a16a874ee99b253e2a5326af06360b90cd6ad0ad2c91e88c8371d9b3dd39022983d42759ae6458eb076dc7217dc8305b7b12e23de37900738a6bdcfa94224eceda11ed096ac6f032c5f0e84371b35b7f5d2f885ca8406ad2c6bda87bd059ccee596e67bd3339ced69a7f2225d489d6a4a0ff9515edcfbb8ce59262fd54128c906ac1f5b4b6fdc7b555faed89d85b3bbf7c97cb7c42219551e2bfa6f265985a3a8a60e56410013f16f8f43c39abf0b2bc825f118a28ed3206b3658a39223bee9924dcd5a6d9d8a41f40a85000662af74824f8493cc3f8f76c94d5f230b147533f9446334af102580052668fa9504da694d3438b3185c1bde3d9bcdb1eb84f76bf53c6f5dfaafd7ce0cd585b1b6d3a58ae4ed25f1df502b8b331e30bfef5daf010779e299950731602dbf808e22b04e769a828373f26f95e55507e8a63671f8a3487eacf1b18cd8a13ac5faba7a9171244f08dd1fbaded01a33ebdefa73d0d8559eeb78fec8de78e904a2da3696282ee9ab573e57e4fc77bd59b7993fe97e1ae45405ccd5af60181ecd534390e2a2e3300ea49a139731caaad959b45fa62a2e7cf87acf72f52d93bb3894bab449f14210c1c68fc827355dc0ae282d883fb09ba21d1a0d799ee99854db66884649326a5cdf1b60a1528d58b4d98e4445de9b0b87d8e7e32819528af525bab5bfab7aa48fb9130c31eb1d6a44abbbee60709ef993fda33c5bc43ae711d0744c17df9aef161505f64bb0a91a83623dbdd616016f765324033e3c1be8edb403f1d9b257b16b99505e86db9a489b0220fca09475ec46bff4cc74f672219e5712aa7f7efc07406fb62fce38d513071b267b126d65e4d782c3983211b9daab8334638d54ec705d3c5def53d728c488a488691442cbed4f24133a0947ef7178226d457a7bb6a8ab835b3b69b36fc4e1218a16b3b1337e9d26b6772287a7ed6c823836e69c664d07b41509b1f9494e687ffbd3940135ad119c363cb02ebb31c35e583177232b6d145c86d3cfb16886a0aa8c8f6b0ee0dc1c52dfb4d9264debec188c51c0d841f1a025b4d11d4d8261a6f2b2d8f163d0e5fa09dd01b3c03e87ea1a185cb67ee4d3fd945c023463e2e2b4d780fb27ed3d583ad8aeb697ad7af62cae6ae048e5d199ecfead5066c88a2587e7935bef7fb3ec6bd032cc4cd07b9f0256603d05532e85edd6d9cd3bc446557843640386ee4848e0ebbb7714246d5a4c997912dc6f1d3d726b9914ccb8a1868ec73625ef6aa47d4c23292ee765a79692f37aa8873e37105bade683e19635cfeb9f9ca43d38b8dfdd305bc837911d77a22932c1a63cddbd04c1b0372d9d9fd1491b12028eaa87a6c370de4b6a0b06290fa07afee089ad840c121abff3a03d64760edfcb842b4c8f96f4cd69bc8548774eb9f932f3a253f7a6b1000d73944d875696df9fd9eeddde144fa9a79f3e1ba33d40779453b5d8fe836b86f399c3c12e83dd838b6d29412caa6cc2553861b5091e6ade62b22b6549fc51da6fcb990350d3ea66f15bc7ecea002b7331b59e45b5cd614dd6aa5b0d6f9448831e1b98011bdf5194b6142ca90d598e86fdd29bd1e2111a3ac02b2ade6f24db63e6b7fe948e9911d6e610aabbf98e1f9168cdf209cf916e25ebc8ac0c147ba9e5c4f1a385640910d3a4f5f20463ce7d25b0e15a3d11b71983fb57dfb4c8f2ea7db0277f10d63c97d8108db2e7061f245e00620fc0d49b8a096e7df93ea6a04d196b561f392ab0d7b175a6866c5d2f26ef14677be46d745af05459bd997f4da9fbf9309aadeb984bebbc443bce4e41a020f43f70ce2e459d2b090d2163d02de42e34c83831ba10ed9a7b3460dce25733a143c371dd366100321f3ece8e67c7d386f0908a71991b4f2ce519b3b06031c398032b209ff536dfa2aaa3f712df653a002bedc5d6a83d3c59173732bea676f8f2a6b2580a289d8ce22c3fcbd0c5f5c0653b0923eac9a544271aa043f581612b0f151c133c9603bdce3c56f7052c68937b29fef92a520becfa347363144ea1995e7bb8b57c95bb1c142b5e2f941808e2753d5b4560cbedea322eff1b65f68be29fa623514a043e85818614c397f3b60c8af42b06f30d5d5d74c65410a1405555abdfe10f2e288666aea347ef74de414adb52dc55dcbab1fc8a82747d021d75e24b71229da05c5f707238501fbd72a6cd7f31bfe466edebf924cf97ce3341aafbde4e4a8d86e97d97c8310c2cfb71fd3770a0c2a271d0563fce81f5dd68708004904be175ffaac5e7e165a5a8ebe6fcc95a8be0b8766d1ada464721212fcbff7809fc560344f34c31d4449fe46ecf35c0aa13f8ae3735d86802b376d5751d8b7d6571726e563fde04a698e9fe08c3ee2729dc196d3af69f0e9be5fb8d2d960fd59210a31a7a68b11d1c632ae75b398db5e304b8250008f06bf604af972a5c43477866c8240453d11e667ab93e3e472db9caa67af561dce5d723134a9d1839da16705ae72a458eccc584d101808e0973b16a8b0d0d02c09e676a41daabd325de282c3f1b694bd1303fa4c7ff62418ad695e6a83d0b73b6f4e0ddf0b46304264eeedae656380c9e86e3b157ee854bddcb9f27f059308f2c40bf2f60e8555ea5e3c3b516733efe2c293ec4631198a3b2cae972b9604741647c00af292c8df3ff0c513e0411a2a55b2ba933789c434c9403c135e54bf59cc2d9ddb891e617b2cc552ebd5930a3f818ccdd4cee50e6b847148ce89b70e78c5b0c1b40b218cff2d65fb53b21e20380814fc0345c8c71eb35d9964379c908b6d575b18d0ad3edf9bb074481724b85e656dd46862a598b22476dafdeba28a8bb600a772351927d253c1a1c17ad97b5aa2b602f9f95eda8d5c952004121f39e28696d2b6b102ac79b6a008d665fa9c4ddde5411090686c01fc65b571d361e1292c551450aa1321629d74e336ebfc17f12ef2e33f44ac44eb876b24219d5a83d86157e2a5d1349fd9cb7f452eb3c4344db7bfc2425ab9f2e90db77b04ee598793ba124b8dcf241367df2b10c4127395629aaaef74b95813a45da952767c207d66f61a3f115f3903a1485a1398d74652e1850e2fb9526970e323f0d94c1a6bed33c31c554d93e8016b547110a79f338568cdadb156f4b62cdd83348abffb0c08f4ac0888a76068bb3df3b184ff0fe8ef6a193896c3dd472b0bc59a72aa2d9d20e47ccbd82acb09940f1fc193acf00a6fb61dbd95eb6a700afab3d62dd03a47d1b7864e2f73ceb63d6b44a9daf84478cbf19840f22bb694a10fd272dd967fe91335888558e648cc9498412f76a3ade29c701b41ffe9618ebba4a2641e919d1192d500de55db2b54ca7db84a2b9797840beff1779667f1a070fba501f7e576631648b872746e07d3398bf84be17af7ea611f94c19cb19a0a2410653d9fdab6d0dcf770cbde90e18b2444e73d3ce74679a6a73b75ea70260bbb20d9d3cd4c47aace5f57fc0970435733bf0f8faecce64678432f0967a189abb93c778cdc20bf17f88a70e87da4fac1ed776fe72575341a76f01a79769cdb754e1337b2347a1f6c4642019005229b4855ab04c3eb9bf71ddf123acdbfa3ef4a153a1c4dbfbed102138f2256ba446de129b075180ab921ca4a73cbe256f8f0ea24f071e093297ef208caf5f1f1d7e4a1b8dcf93a00d503d1020a0597229c60f3895adc7f1a1658a9ef692eae5484496783344437b9e91e6deda5bc00996a4ccd521c8f3eb425915fb47f15e6f83f0dd044c0dd4dc2fba35b64c370164cbf75d91e6f79dc87d956e0bc0ba7ba79972a483b36ce8cb212802b2d9c07479b4bce544d197de56d4fba057bb85ddd62a81c5cf6238ae34fe8fb9b35175e5d84ce8af6650f9a9b252087848c179594c1c08f994b69aacca26924be840adab1545dc6eb4579baacad15c2559d9bf22d8ae22da7d4bfb7db52a0469e034ee9460441866ef23b15ce1bc6904b786a936439a0b3eb6d4392ba9c3a600145ab480f38e45f968e3a66c89a49f91b6b6bfcde1080bb8334de82551c57b91cddef0e10b207f1cca43984e19f0d84f7ef52d971ec314b1dfed22ec06d5ae9fb631f799653ba6f41a0a76a320c2cb1403f60bd40039056183075146da5a9cfe620799c527be14bae28fef4e7a036f5d979e66d26cb435e77ae983c6f4651020327c8d264c0f961e0c4848681fb741edb53882f94df022fff9cfc1542e1d12c8795176d5a6b15891aeeb693154e0a67bc399c853f46dd80260af80c2b1ebe3d4343a5958f8293f057177c96ce36c48c8450f59c2ed32ed5f9c40d2fe43f7b814d0972c492cebca9ab24687a4d444b109770bcfd408e68c0733b8d57a8d26ee4dc07b578c1b716a2df9c836d92d5e286195d5e61fb5a60d7028b439fc5df18b86623abc83eba549855262b0dae3006ceafa9937cec73d3daae4e50676f2abef33f5f29e8da5758f72f19f9a98537823dd4d4bbc14952606fde5e1182f111388f564704e06890ad12cee55340ee1f1aca7545db31397cb9118059fd25165cd9e5aa2e4e530769a90ee2e3cc23ae01c1e1994641c6d69c62d875c6d30f7650e1f9aba0942ae81eca8e8cceb5662351de4e79095e42def4893f732d8df46be6b5823a7a39d4bffccd48b6ac6c39dd269fbf42e29b588341e35fe6502b49c181dcd5a0160a786494d28c589c260d5724bc4edaaeb0f76140975b2e6ee4c401d2db1cb21f79514279f76775b4b60435a0c9a81ccaefae4c8e7ecf90f6d056d0db1357ce8059e7fcb727ec49057c3e30ff4d99e669301c9d3c19ea8e715dbf59f244c7da3c4c8d5fa8a6fc427c7016ecb36f46039db3e96b93575df8077a1b51b30429418301cd69a36e9de6998d0dbf6e8679a204b451c72da46237ee8d0e8766ec0a66b2e391949cc94de31a793be816dd490a5814ea3ebee7ffc2a2215b63dc240f75c393baf8b797856bbcd66f81aa631910a4fb0d6dc25b14efe7ada078dd94116215e88ff7dc27d63058d7ef41622ad45c28752ebac72ee4831bdd40a1ae014f3cd67bfd7352f19c6ad64e78f9785c6ae4612adabfb5b07caa8febd125a9ae1d6be9c70046f498a95b224a8a85aac24a88a2c5c50450f0dccc4de92d2198ad3ef73785b530adf6591bdad0d5353bfc3150b8ffd2cb7841c94b4abf91e36893899b00d4db9bd8ea1a03e3630be0eb2fe7a0f5fd9e03bdd5084fcfd2fcde600c4ed593a5777067ed14856a81911f87207fd616c9dd3cada4c4efc4412ef564498512b17a13def2810f3436971d1073a97a549796dd8664036e68835d1f493fdd6e9787cbd87ea70e9924da8f4c24571b3ddb04bbbcf2dbfec3768119406c7e650398113f5e028aeeacf12e038963db14599886b4439c0d57fe91bcb237c953bfc81c56830ccda8dd49858025565339087479f8016deefc00604e907cf20eb70a99b4d163345e3cdfb2528c1e3414fd6666c953430ec19ed4eb44b7eb0dc746b825de0bb3d948c83be4272d170c8d7fd9ed1dd4de38cbac27f837f87173392ddcb7cd402c16d548de8cc4a43ea272179e2a31768468bb0991a343da84e7dd3642ea69041892b1653734f2751ca5f004a5c7fd521f7b9b06a5eec8b045384ff916e4438e03539f9a9e977e7649da6ae888d54fe187e417260f600bd38fabb394be4313d4a143f88087060bf316d89a921dafd863f721f786597755b46f1a57237a1ecae9e615e838b4fddf2991c86f505f2172090b1cf0204cb9ccce2652cd27ddfe4a64a4f7f46f7a6440fbcfd392715e01ca471100a52ddfe550766fd1075815e14c34f1eae29ced90511bb66feed70285d5343ac10f04a14c41c15aa8073dd724e46df817da191e599c8b2e5422556976ea900c541e3f59f892a56d716261c33a0bf837cf9e96ae33d5d9b9b8e9f892c356bb036dcf2ca7b987b3c92490f3a2b12c45a1e4d5dd195fd780186b6ce49acefe91a696355ffd8b80d576ca23b3af5c03fd039268ba7ff3c471c5a0cfdb9b49180904ce6e45affd39278f261de2e604a791070f966989db62f87d38a1092affbe5c853cd94fa58a1bfb577a61ef3d159330ffdda49666915a048f3596579e5b00b0cdbe4fd55bd002ba457b5c2521746abb6cccc0684bf828081d03c6f19684b10f3a3d0990295a6d6a6c283cc435d0f3b2eb2b729456883bbd1ad03c1f0efe00f91f41d8cb20cf311a7327c8b7d49fef02ef03fb706c58f6167207c9a8d1231ad16199d782774b96779d1a5b02b90c4f48bfda7b4dc65551a728af026184819f5e82f9ff79a51a194a2e61a5aaae17f731e8b70155897b26e9f185a40d467597cd682ce2b193065435a844442f05385d04c4fbbb6a4db89fd5b43f701fe1b9d29adbc346cc10a634cbfdbb9422fd3f2232c77788aefb5e8256f62542567595227fd1c6f08b49515e5dab089623ed62f5a736b179c7b956971a9a4c95b61bb4447fa6f1c5a5d1199830db9a167c37b6e1ebe96bde9a4cd5ab1642ffd5b8416cd5b042206de85b9742d7e324d0ef5c6cd220100d8d2474d071d079a1550e2fcda079bde34b7d3ecb96b0c37aad7a7585664babae45c8b914d3b13a57a160f53baf40270ad019f1e414a9aaa4dfaea6710558e27a52f8b8f7563241b833ccca26cfd1cd82f2d7d7c29f3f2e1d2cecaa7ce72727e035cca3fc9eb38b94e8e4e1d00f65fbb587e9206ff7179c752ba6953f369f066cf6f344a3c64fb9ab00e60f598d6738fa8364aee4f005a2ff5171c187c43d0d4f1bf4153e01ff5e382fe44c97feaed075793989d7d008376b3bad10c011451d2a905d590a82aca804a91649a461b73109a6886eaa73e3cc5ae842e65019c3c4435631a3a6891c01fcbe50c7cbfbf24034e446cad35e6b65207f5352527cca0af8db711d582315f8e3dcc9e0fc545be40660a510582a3b5fb7f3ea1af081e354d2a293ec1f975841543782f5d709ee03eeb19fe7c5164a4fceb0bc6a9d756e85d7623d8f3638624923e6974b813c5d8c741c6ea795af4197c2f1aa4f1ec9eec083cf0a874de2da24ac4ade18c5814727879aa05b0c5d95f1d96c0f79039b3481e6cbbec98a326ac7135f9ca6288a89f9c4d12d66e1e494e69ad40d4b67b222ed59b34fee6524b0aca5d2dfb4551c888f00f9c1587ad99be41e46e33333c2b1e026f879e7267457bb9e29bee6205b875c12e882f1952e374cfdeba59be00c1b1f89b6bd6b5bd1a9a9363eb2e279863a1b810be991f461f8e41b144fcb21702ebe021088b38358609157f2d4df67173d6b07b9978675d02ea13147db79b80f953d45ac81774ed6ec71aa1e54b414be1027f867200aa90f7ddc68c71f1dfa31029a15788225c5aa0b125f8588c02978ea659f712c18a3a8f85f715c7fcaa7791f57aee556b85e28d55c131ac9d15d1f75ae0b93890ac76728cb855cde27104b9b84b323671e7f0e46866fcd9a698663814e3fe5de671d0716fb3dbe18879221d1c7863c0dfd999f3d74436d624855ccd5609edd964c5e3647309cc6d8d878adfc74a07adeae6eced9d8b9cae884aeaa118517a9b0aeb00189cea39b06330520b6580b4e9d1940e05a1a204304951b813d7ff42e93b9c9a0b3ad2391ea44c50d4fdb36a82fc2f4dddb923b603ae424da2c14ac33d65b4a7e375a0a08d5664cab603c40fcc0adf121b449669be87494a4d8de03e7a53930c66f8cbf0e846d1f93cbad3eba5b6754a3ed32ba1f55967f4dd79c3c8138910ef06331cd38b1d3cdfc24974ec987c50e777373a54a1b75c8eefd82a7a5d16062f5a68be67a7a822d9f798c8705c3a17a2469290b16b83f24e21c3ca21400a615b805f9fc6fed0974cecdb019a31dfefaaa816b4b3e91b44786e7b64e0a469952e28d2d784742486b18ce0b6d32d08a9524bdca68846d76f9430cab8a0f8d96bd548a61121ecc0949bd12a0951e87e41ee656cb55c281af98d60232c1f099f7eed974eb30e6416b426c849bb2877307c390c76f606e42886796cb74e79e4674c012dce0aed44394095aeb781de8b264db3b16e9e151ec013ccad213e7e6930b1667096fb54dd14ef8b232ea5d43366ff888ba011c37c3909bfc718a640bb0fb0518cad5055765e31bd2da42bcd7392af2f84331efab1156bb870a7b99dd16e0130334ca7147a0e3588c14795ec98a6f11c23f0bd868cfe46cdcd32adf81cb90c2df60c554c534936d6ade3c111f286b75596ef9adb7c9864a523138674b9d2ba821cc476fe3f27d25dd2816bb6be1721481511cfef39218874060d8adda46459f7452f5183883defe0ce1fd594de1bd7f13e55164df1c1aae744c73740ec3c69dc82f2fa8f98cdb172ea7efe46e19fa55f4eb948f821ea04b3d8e5b3181aa704e92358e8d2c6fa4b8b4bd48ab5b2beaf0274c435b1cd17f463d4c209a955f21ece6b1c25027c0f314c46d9b6f64c283681321d3c46173a61a0e5c1f75cd6d6b972c2418e2f91b6395f15c9b8e0c2793cf3a0c3f0913a1e85e8a140ca70eb66ddc5fd022ec8651315dd92d55bf67b4ce81ba4c216b43dcde1385c9fc12a7dc2af20726788ae0dd86eacc3da5ff69592077c66aabd336070a7a890f26d38ce6053e480ec64edbd81a9d69e1d18f44a855a38a96b37c29db405dd3c64574a97e2ef858d1ea6c74c18d7bc6f2f4a98adf88efbd720673ecb86e5260811fc2b92bc4d7ebf97ef826f61d61945da0eff85a9768552c20c000ad7257653291d1f63d4df8af5b433ea303f72b4d7dc655cd3f41c52c5b59db3e815f744f127dc06fb74dc981aa350f4d529c3f108a6ed52d94701483658b4b4a648efd5965dd4054caf37fea26c60d0941fcad5bb3a5dbf2bba88b52e4e486bbd180417e022c52c8199bde76b5cc70ad3c74225b019441b0ca008520078d379b723c1375d42a4b8f9311106b6be678476f827da4b925a100147ed5b81a787426e666b2f09132c80049bda5501f1f266edcbb0d113b4a5a52507e663cd63dfa353e94773b08d5d68251049deeaa7deb0a41bda0ccd5cc5a20507c615a5721bea78023857c115e40aba548eb23703c3fb6c08300b8bb0a892c4fcb2fda766c2014a498d955524ecd255a9ee5748638ca6dd506a8f5420dafbd1fae24a75259197f1a1b5150cffa8477b0ac827d1e499c3df35e9138ee5babbc9b18b52505ce3a2d76e92bb0ed6d8b12989db572cbdce7d3597121013298e989a811dbecc9db52829290136f2c58d1ce4e15806e1d27fc469e016a4a7fb0cc4bcfee496a04cf0c3f116ab5e9e4ba1216ef7de241991b1537c6a72a34bcffc44f84d60d83e38af51b3c0d29e9931e011d66097e0880fb7d2e99140035b14fafea96fc6d677280213eb68896e6d62d961284fc3d3168afa94248c1af1339bec071347b60086cf8e096826f1950c42bc3eb399704cc91957b5a0a061b270357515066dc90276199b63b57b68be263ef86ef992028294e71ae415626625c877c7ee4377929295bbd203f4db9321267220fc265835713725d6d0d2946bfd2f1e5acf7fc33a7d400dc7dbd1a95aa4924dd7c1e331e8e7b2e5532c2849ca6c72ec0dddb72219b45bcb0462a19fe5062b389fad37ab87a76f4c8e3f84f9c0d2fed9f4672e7618c5f29b94ae3bb344a0b6b1946eb06c1c500e2d92675ad1685983f33c522fa510d8c0c05432ecefb9c36cea33c623f254f443f2e9f9db373205da6a42f76f6c63a6e14a7f6d92452a5ab44b1fa4b0ddc272d5d1bc954fde02a4c59d60cfc5c0602d78292ea82b8922af845736ec48a2b5fe11479bfaa521b3739463231f63bfce5128a001e446bf1e3968048d14e523355c2058da5c34408d3163d59b581ab1fa23f84a3cf75e960ef1a72ef3cc8f9e0a8cce3c9b4d992f3f6ddc290a62c7fb9f61c2d08820e78bf2151e3c967c9f9f666014a93c69c1d6b2bbdd6936a099f69e7118f92feaba109a15819326c3e371cc172772c1981d4146eb294d6a3b0599f7e9be302ae1e86588442753a2898e7cc30c149a1a615f87246ff8811c257dea3163cb1da702204949aa92de6e90ef73519e52c9ce65d42b4c014f1e0bc4d5ea143a2e02d4ef7908c108bf8896f319ac82181224120d55c34d3db7191de923b08ccea9653453dcb78baa2590abeb0757fc97048933286b68275b30d9ede67f675e62ad19e2bf869e4f0e1a9cb201a4407815e4d4efb3a4e9631a4c4b43a3f390f76dfa77e9cd39d1e26ae77666b34d25b538b0441b6f2f3584af476bc90238f32f730cd642a00c540a7252d61a3c4fc7abefe7fef2ea4498a7fe3a83e135e840971baafeebf9c7f5d1cb99d1c97c5b83546ff0f91fc7bf9a1bae7e27b814d2b88c5bdd162658e653bd3eafccf3fc18106d7f00cdf514f0aa1d2637f2c0a8edc67dc732768b2c219d3fc64188cad41373aec68f6b41aee251fe3ccda960bbeee06533083a82aadf329a5ff77ae27199fc32bf97f9796f78dc61f10a843a2e04f808b69be431435303442a0fecd0297a6ad2859208ea2c7765a2e099d6ed440cee897151a5d96b262c2b2a005a0e6d96a63b9071444b4448dc7008c2c66a47a06bad1034b82d5e9ea5a4fae652ae8c04e15abb97cdff6ff7e02dc3fa66f7a870307a7e4dd66292d3319a0ed9de8390b824fcf66f6b96d6d6edafe6896b9ead31b996e4bd5739b3031101403ad2c56b2fcc8e657fc54b2c83338d2c61ca70967bb3381582ece32ea836f4e0d707bdd383f10a998f65c25530b769b6a544d34dd0bf1daacd9f1a391cd2e657fe3e4d532fd5d55764d245e1e14ef1793f43e18f1c0d4b3d3637c8d3858d48925ff5251cf7f549c3e6d4594d55284c9b4f59a7ef0ad229f5c00401dd2c2f0a1fb96b759b2f1b30cc3d05df65e4ba01c1678a4ef554fc35b476de81635aef9420888f47dfa64d64ddb95d1d9794343de46d9d7d94331f7a5fcfb108d97acc9d67a1bf501da5718cd8179ccc6cc60d719b4c616937dc362b4d3cdbe60e69157e63ac86d0b60a5b970b3d5129bc626efd4e69435f6b6a44cad95a2f2335bd1e7b5f93a056d41f08daa7f967e91a8efb7b78c96d13a4cf095c973072def0d7ea9dee72cb8503ad8ab7ef80e5a50b31990c7eab56de3e2405199975d7794cfd5960d81bc9ba7bb2cb85044cf1c65cfa2719bce958f2bd7743aa68800679f1d4d5fa3ce23c79c4dcee510912e7b316526b7b3df6b9f3707df0e5791155f8f27e7b26597a79dd8b099cabc931dd9d8e50f9f8d2ab16b8cb691e397e4c8f6aab851fb935500bedccdca2d78abf39cc8b490fdd77ff769d252ed1a9530853f984fed1ab85d0eee1093fee039e9849f5715b82ba7b516c78a2b16403d228e2c8ea1f20dcea2e2ad52eb73036d6b0ed0ce00405fbac2814b358021841d29a10030dc81b1f593245887ef989a90500aa5dd3a4ef9c12730b9e695a47e55848981f7f39439fe1c4b87496d37992e84676d9e50e2e37ac128aa14270abbb64a3e85e5c8c9ed5aa7184b9288049b2c8c4cf0d54084f84c80d49416e193dd58446f655229e75b2ee0661914479a7b55ffee3ac3a7a1ca2b1ac3fe00d77eb1024dbdfaa4d2eb5031eb0c457d6611b889cf63d51a13ed62c82a633aca221523a7846378630e6089723991500c6e15cbcc05fd658a1ccfc6d301582813fd9dee8792549d57a16f38d170d21d93e1895ab1b47d5cc6ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
