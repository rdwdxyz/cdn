<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff9691561fad3d76b22099394a3c2ae64d222a4e8f4c8974d00df78cfa6e6a279fbf8c2cd7198b59163ccfefde6d59b4827e0e96a157ead13bbd070d6c3698408adbdfa57f264eccb672b75bd2842b99dbab6d4eb927cdad492bb16e6af38addc35dc35d981a3c5f18b6d5e5d2ef266ec2cdc6ce2e0032e0a800c0823faa585ac56e39692eea963e70d4ec9232f24f162d340ba0358a3777ddc6c4426e172a57a733836b392ac37c5d9919109f2d6a60c8c04b58c86a5d6b3e648f21ea5e63caabd940c60de0619cdd88d210ef17230692129d74199871881fb33bff52998be5feb2a4e1462d753feeb172a2e7ebf0ae8d05b986e2faf4a645fe549a2ef891fcd00343287c9e3dfc81040a4483e294afff8e5c425587f6dc788c0828c756364c666ede6fe3a827916d08bcd9773426333c2e4aaeae771bb81c651ba9186b131935ad3f1eb73416e857d23f196e386e9e96bb289d648c1eb1ab9fea3630071ca4db70912d42d9bf5256534bd3b24a6cff5f613db299d91f2d6a99ae4b00d777da4cde7b863120be761afc9d4682d9330966a92a6d66f1d8f11144b50e2fa5439dab5c88a2dcd6972aa4c63876314047f4f80c089d7e93bd7d73351c318f9e6e783704c62f006b74e1edf2715e9287239b62c63beb6a2beca31c2206e556edc49f5464b44631f284a17430671950e0c1de75762b679660144f3918d54880cf46e484112a33730c5740195f8f9cd496652c163f161b5608f660578c89e538b2698f7a25ebef3648b506e24a7ab4713f05690f75975f3ab018d07e45125fd5a26c1d82adba148c4e3eec5ca78cad54975e5fcb15b992ce6ee784243b01efeb088083988827ed690bd88f5cd1d4ef44e35eba51ff9c5f44e8b1e2aadf11462da80c535144abdf768e3d94f1d06b44496d7445cf670fb81ea1bb8c98862b5114ffa7e401818c379cc7f6b42011b002be96fdffadeff17956b7a596e1a4a2dee21e91f996ca3b5761eaa6f7d04d8b425e262e86d897763871fe3c39d8e7420f2dce2bcd35fecd090a0f0548fe96b6a9980bc2fbfb9eb256c302023c4091d54a01818ae03e8b77f2cc31836cce21ec9a19647441e025952c11d13aec43bb059f898d7689fc44986a17093174528ef81f3296b5afc62c18b4d516e6a9bea071ccbc887173fe4b06bd2ba7a8ce3907c02032340831c32e9cfe5670ebf1d072db1637e85d85fd435aac032635c304c62cca782877bd7919977a85d855d876ec591a59a856f4857752d66e2c6b4a3ddc27240d391abde64f122747dc69d53e2beb08ef2eadb62a80a342abda56d73aa9ebd4c39ac87b08b4640a86c6c470edf26f143cba4bcd2a619f1f6a6fb82e26a974d10124d4e3e144286e2d22e478565bc8e8d7ef1385efb868f8a39dbe79553b05b91dcb64ca0d6d527fff6939c81cc63c969d3ad9da6b1f7b3a41cb8f5558322d90562a1d4e17ad0352bf97de21a720e0fab007fe3e212729570772cc99dc6e08e70771bc3569516600230caa513371c67e5404eaa9bb0fdf9de6c99934006672f8bd387cabc171ea82274e4b6b761489904f2350782aa6aa294be69270cd644b24113c5cdff474283296271b3b0d912e69826e67be84c725db83da5d05ad148c32a61c996879d361abeeabca0bce621aa97a34bcc31ef6dbcdb2df7ba2dee4a4a1ea3f7f159961b2c16ed0ec9a7af617117a2db3f3f08ba5487f61a7a921d49ba6e412cdc57d738b8256ba685b3def4dbfcc8b40283904edb166083e336fbd5103bf2ae81e960ae9d1108e5ef33ec2472ad832a18e5cfdba7c06afafd5331b62aa1619890a60b7b3bef0aacb05dfbc7596a851db09b4b1a367a4e5739d79213d8226ea4e149f722cece37a50e7380cd8a6355491370f88c7727946858b1bd322d6066bc0c65cdb69216a64478e72915bc70c5108c7cf7e66acbf2a5d00dcfbe4bb3e458bf54125f7f3deb29f34481e5316cbded7c4b90a9d44790c0257bc86b35821844a8be456df63ae91a05fb16de86ad99e3d46a565fe7da18c6dee52a637cd5b014878331f8805c16e2b386fa2b6e8c7b3fa1724a618094f087e2d2cb4900a0e0d8bfa0f0de45615cb30357b00e084bfb70248d32435717dee8bb1b24ef4018a5da3e2804f0693613eec13bcb4cf89ed0e5950ecc50dfd1b7ca2c9efb1c54f239d6812cc7dc0c0d63890ad0c69b9d1f271016c35d844f67f7b0dd840b177a32bc3386f9f46afcdcc17fd0f8ace5685f04f72cba0203799e4d34d0b0f7e4e3f6186fbf5925b47fe721707be08c1791562bf0db5c4c4d06b00fa59e5440d440dbe5d98ac472f457d3818e5e82e179004fa5543166b823d86d54073e15151478a35a8afa34db1c37d720dfb09af9cf99b048c65874f321dec14a3bbff5aecebcf301cec2f791648eea28705ee2aec9f27eeeb5aa907965b91daa8bbe70ca0c7249d59df0709675f917eb0fa9e77b37ceb7f2bfa52a0f9027da3deaad22a3e42b8756e2e93627a1009508e68fe7843181cf05c318c885b40eb441b37e729b4eee9d9844d3a3e5b7aa7c199ca15f94a8aea01482fd4a18820fc8bb32074351b1e9f1570df3c179c3f4b155418e7935aa7c1e8dc6beb0f698ef55d6f1ff4d9ff20ccf91fcddd5c75aab95f0839e2138bf327f27bb97ae37bf917c3f4c14e4b7082aa7af7b47365b54703c44c2ac387fc19e702dd925f53cead8ceadfaaeaba5fe73d7ac75fc3400173fb856fad89acafd2843f341acbb228411a48cf47dab1d355d3cf07dc5559dffab9be3207a205e82f3919004fc123a7144754618a4f6d44a7c95db31037c2f0ed0b9ea118d6ed1295f8db3ac67c6e6aeb2d15d51adba7922cf246d1e27d3d74ba4cb7475130c803f2ab5b4100c242fba031d7f7b7b3ef3a3ed0245b670aa6dcd2342643435ecf44bd01e9867bac6b2eb30a3dba0bc13d3b9ba3b7f405a8bde5fae29b0776be69555ac83dc83c4ba0447490b508a4c532cd36dd0bc5a3af806e1ed3d7cf230db7000a5b0eb8295d01a269adf3bbdf358a38a3e7b62ce133885896a1bfa9d110807a7182e2da9110261fb6f7c19894f34df3f6a43ae1f6e290ca2d47798a544b7ae0f1458d443408ef075f7a41816d1e4fdb43bd72a4c0575a560439f1f51186afdffa92b452939530080e299ad22de17dd21c7d3935927c462fe301a71d5f696e2a45bb766f74a677494d20b08a27328afa2e57520fbbe15550f884c937d108ee83c5952718d881d675ad8d82e727e36cbd1a621f7c5db6c1176aba931dde6d63b95869ba0ad0e921abc474f40a1929339e5a7a28c075a288bf0f1be317be387f2cdee44e1e977f3af43d24b5cbd2b297dbd7eb320c7a81d32975b8325e439505a571abae34aa7a1b574650261400b33486ca5a1e36426f486013cabf110b53b0298f528324adbdd0a44a2ff2b0b59c9f95fe3ac7e8d370fa413ffae2a8bd9da31bb050369a7368012c67ceaf9dcb3d178cc64105d8e35b485d37a0bf213c10764b3b0c505d452f37da5c6beda2d6d244f2b21c80491093feb4180dcfc5e33bceb6de87ed5ceccc108747cf8a14b11158f37900c0e231aed2c7046d85a79ea4452a65f5ff18e90f7d3cd1bd4e5a6f05841d2bedc77ad4b52293da3578fc8bdeded3e9f415a899e76ea7886fd039e64e1d42469ee336ec4af8da937c6ddab473963254f72be4424d7d03aedb5b7baaf1405a82b45aa1ccb393f0d09d6fe5594715a2aff6ae81540d1eae191432bb390e6948c2d158621f107ef28daa026b4a48decf136b983475f1c965d7dc55323840f7eb3d39d21245a015cbddcc83887150abd7f36675dc3f8fdb3811839af4bd41f2514833c0ed1fc94663c57e9caa8021bfb25d05116efb81f45d0b9a5ca08540f6deddd495c72d8998c2a94df2c4aa1fe7cf5fdf5c3c26b5357c93fa8fd54474141d9e171780ee4bc1ec726d1530b1082ea524dacddd98e3950a85da4c17ff6e9f42176f76906565636d56168ae5c8f85910694d40b2f2178a29b7fb72f5aad7faddaed10824d99ae2002d78660eed3f88d78b575d866b4775ffb83c7d6ec8fa48bb7dc40311cbac152ae95d199cc21656c203fa53e8488b88fe5b43a3bbe84c71f5b0e09aaa937fb8888e1d7fab2615e15b75c674f7a6333aca0abe69e174e0d588ccf2eba6d3b766782159b88a8dbc4c7d3243aa33f8c3b1600fae581307b2989870216ba3bc9d9af9cb7d057bfb7647bdab8a8ea3bb40866db1205fa2c03ecc8ef700a23fd3ae6469405df5a501eef0a7c3a48675d9891d07e660675a50a96b22a4236d8a3f0a53c01b814de21b0875fc04e79fdd766a048c82e8e94979634a4f2f63f405d7f570807fd8818c75a40e13b63bd7f35fdd3e8526030dbf943dd8350c4988c9f9f49febea9df4bd9626991e176c68b13836889b2962eea001df1a0a416dc1f075380829ce133f1d54f1be2ddc9e7aa6b86ec0369df977edd1f75653c96c3c9ee192c40ace7dbe8001bee84efe44f4a229e5bbdee9762565d20325bbe661a9203090eea83304b08c6d683b1720a4ab0f1605f78d70126be6e5169b5a9af462ee3acd54aae18af194077415b661936683b3073c20a2e183885cb477fde8a2a001451d4c94ba6a0e7816b6c852dea4f53c27cd58f7dd4423c4351da80291b704a6f74c4ed72ac59650fc0132f1933b8a2898addaf4788854c42f3658b4ba8ba4d164ad8dfe3c27b80f871fb4c4493acc37c22a010000f8925959f718d62e5f6a3293a4b3d3ad6a269b3f0ddc7ccfe6bbb7ba6c8663ee13c03ebea9ae82316b72b168e8b3701dd5d8fb4ae645dd67cd8c38fb6add38641764b7cdcc566674be130fdd1f26b5be7f298bc29231aa2d1aa1d879a1bc181b2ac80615195c6515667427315727e3dd3711e73465bfd32fb2c3bf86ad91be1345e362887d73598b8c75d3514200d8ba71fb12cda41cbaffbe5d512c4efe0677e872799e28686d3fc19d9f3359ea82abf25b4a98fbcfc631f9d5ec9df0ca774d9d238064aed56eea7294c9020d486eccf0f5a631371bffcee943d8e391e05af7511e44c4ef4295a6bdade810b044a4771f79a616915db095d3d4a023b79bfd91c901cd0fad3aa43abfbd694ed2b97d7b281f130ceaeeb3654401535982d44199e5fb53ba30e4504b29ea1143c74eb861466bacd0511273f5bcd7d6269dcceef5125fdfff94295239246f045eb4e42dc5ed1d94ff9cb5623d5992552cef4ec98514b6ef7d81e417f2f97b62d8296f9a0c0b74be044d5c44e3c50975994be937b586cb5bf5c17c0c67a1185ebbfc563e9f06544f65ddedf88ddc4625c0e1d4e98a9308d11f624fec79b8c658d4693c7eca8af506738d9b7b5464a882109fa31121d3e181c3a049abb83ca2f2e52d035969215dd6c200794effe8434e1899ac4b2b1e36b6f8f5224cd1e0230df4552ce04766b618462ee0df2d56c00f771b7e5dbb24f022591c16e08c67cc2d5718dbab3f71a8f1404a972eee73e265ae5c4d8eb6a3ed7f4bcd10edf3f9382072dbd3aeb1953cb77fee96efe1a28429885776d4e2dbb3da821e6ac0f46eed8c23aa41860d58ea40bb3945c41d48598c10cdee902dcd4fa7705ee89a9a9d25329770329ae9aba593832ede5f5d8c1d96912c60211f80a208e5f7949f67bbe41e6887cf1e11114d46ead58a4185d4f84026b88c0f119382158c6bea0dbe11458b76d6d6d326e6be846c71eccefc7c7e968a16c85fadafa0e37542e627c807f74a1aabfbde941c341cd7c4a3477eec1beeb15e7da0baf55075da874b85c0a07fc088b52be9ee4fe8253db4225fcd88f9d3dd3afff636c74b853dcb163981d35268beb885a9e58fb67f8738f4a9d759c597efbf9d922c5b22dd9e7df8731ea47c2a3be574b587d1cbdd53614e72669609d7f578d782238fb2952c25de9da5a54713d1b06f88925966fe8c271fa14a977acd4924e230d41c78803fecf192555663dd1f85e840c48a66ba69f4c6999a425c453b2709086b561e68a0f16a011248a5b73234131a314569a72820945a4b5540113180638f161d55e3ca37deb3c556b65ef0b5cf459630713b794ce4abf0f1091870f995bd9c83be8984ac280c70391c69f037666da5ad608cde1b1ebbde742a77b17e58ac90288f794981b32b54357fb91bdab9d62cdfbad8a5afde237204c7fb89aa5ddfc316530c8552898fd94e592efe13aa4b0bae7c621255abd0d17aee9253f07d20ea8ed8c9dfa959ca379bc8ae8dcff7d57eb2ad8411dfd92920591209fd7721385bcbc247c8a295e915a1600a3f0aebfcaaeb2859e722984e1210429c38903c88e4a06a3df021fa5a6b654571036b0ed389b0b73d76d182442413c9258181f8c40a08dfc09d918e004228912a85b75a8a5e06ebf7d9c19fde1c1b151a29e61f8cfe34e04b3e36d042994759a0ab3b699aa4ffd7ef535f97a3caddbeffef6099be7f7392250da589adf950f0292dd987ff89493d5b048c28bf18a0130bc17493425a8239c706de8313e455071e96d6d863ba629ad7401458c2ecfb6f818967a5deee1d3fe9fa6c08df4888f52ee3757ae8f923d37bd96b334f625d77f9236665cf3ea4ae305ab01bbcd5b60c3e8a7e6c8455604abaad0a4ecac8c59a87db5b5242f1c98fab1b1e1bfee59ee3b94e8b44e8b0e3aac068805b391d4e8ad111869aecd0daf74b59990634953002772e3dfa874f32e33a0a08152cc15bfd96f2f2f0ff22dd902dca9d2831f755211b9b9ff9daa739889910cc325795e2424e9cdcd61b47292c8a38526b54e1e636d3bb2087066af78d6a151cacf4fba3448eb1a2ba208aca1ebf50feff9437942c38f3567d80a4a2259456894fcc5af96d2e3ecd7cd4b151950fa792ffaea44ea0d8cf0e6d836f10e45d7a806f539727292090be7c014a8ccbd4b7a250ee916af73584a5aa10b3a7262180216a6806fad6b2c644e66839e0b791667d64bd8504f7dacbff77724fecfff1c02fbab7486af6a4f3f1a8a31fcb42382d2bd9ca3784a91cff84f4906ea4e7a3da72360cff7e1e7dfe802a4b6eb36771fcf8f957dcfe33139a563ef5cb980d7a3fcc1e2285c52019136c4462ba0087fe558e2005c22f3b186dde7205f1a94dd4be22a9862b93735f037cb43392adf170c50e61e572d406bb6fc0fbdf0d62eb3fe1654adea34be272173c5409bcdf1aaa358a3acf3fb583d07664f612eb90852bfe264e356d64e9a24979ef74da6262137a02883bb651726e7659951f9b51b5ea2913be364ecbb96ffdde45f8b5e79fe51bbd237488bf9cc475bef4abc63cc4481b93c35bc98402ca40400588a2a13cdc34ba331ba89759fc22cd55fb3bef8dd97d8aced0992b895241df08679a73704edae830efda1c1c42c0516f8a6c77ada899b5e43f805be1700673b2b95635caab809d1c85aa23aebd48efd90b4cc20476e5cab8cdc55a4b5f5277e0e4a74bd9159cdc72ef2e07c29261f6f2fd6040a115ea7d2b385a5d0f040c4edce5ce63cb5b104acfe7c109df336a756544ae8f4e531259b9ecf1cb59baaee70e1c5b2f220b29b0f90850615c283d0ba90086556fb5387786955aa1cda8d9fe7b8e687d3db85538acc525df4f9094f4e1d6708c6ef29e171bb84ed08af717c322a269b6bb596627b4a461364091a3e4644cb1f5bbf8da0274abae0acb9bca29ebb387191b07fa6cad9f2542323eccb9da450a2e10f10e29538a90f949a39e318326919f1ecd3db60c129ed8f61d0a92bb41970c72370bae39162a93f0fa19a07fd8629887568d9754631404b455b0e3cb590e8cd65700b8d90b47faa74e7ba9ae222bae8db76174fbd6795b0ace40bf26826464e18dbb4e24962d880934916ce8e756adab52ac18dcb3b506fce81aa729c11a46e7fd51bfcaadd25ebafd0b4c5b5a10d61e7c64966744468b4a9f72dfc2821a3c4e24e61f241da2f25f72c5503b0a38ce8511c7ea8ec4063b97f0e46a6d7679e749e7e00c40e66bf617d70c2c3ca6e3631852d4f4f6cebf5003d7c68e67c0f48085e4a9a4726759ae00d4d03e3244fab1e6c9ef4e6b18857a31d90f54ce62864fbdca5c972d2e50859c2afe52857c8ca679f9f83a64f6cc21db4c21fea896b1e993e9f04c84158e6fef1e1bf91fb97047e1bbf3e73bfca3aec5532866d1ce740eff93b4c13ac185e0b5fc70147f585378b6d97aecb7d53ef1762af940360eafc027bda15c56ef0ae3feded4be6720be65964119da39cd196381bd89f9afcb8102bf0a65511dd87228f2a599a7864188d741502d97782e10db64c83f150d9d723cffbb7fa8881b75553b60f197ba5918a5bc891b12d5e6aa930dbe62551be027407f825a622eb2851444e91f9675f353a01bbba0ad0f5ce5d5b749e77e11472e335b326a48d8dd7498ea67f656382bdc189bca1fdb67655b1272ad7494dd153f8171a9a3e97beae470bf859d47a7cb0f049c5e530b0699c36a15455451c8d5736b4db8dd1ada915feab88fa0f177f801880c4924ef73f5023ff991f86ab05e6d77678ab70daba47ab60c229485e2280e8b12de05cc0d423e57d7aff560872dd08d4e1546b3efc1a33656f21fbc85a12314ed1c1606768a2680a256e8d36679fac96eca16a1715722e9e22e40533a0c547846c024be51b1e7859259656a10541bc538cde6649fd55a15fea2267f92d2886c23ff4b96df21aab51e3530ad9aa3edcbb4c875c84e4a0bf7f9db6082255b303e5413ba034a65cced8c4be9114cdcdde3de6a5fab5ad532c8d5863c66f27d1dba0105832784a648f4409fcdf91d1de0f877ef171ebec473ab4ccef857fe350d06014c9272673acc8d56d3e43863edf1fc2c3967b420924cde73fec2d5915dc430c2104e00fa7e6710244d38379971cdf39326b9deab7c5c12a1fd6f931020649e492a7c17fdaf474fa7cbcc347d9bad91482a3c52947f5e32f2186b8cb1ea96b9b03149697eb0d273f92fb3c9e8b48afbf0979b1abb1ff6bb0f0b4c2c72c04c8780c9b11c2eb38405173b7e6c71310fe3f0abaa2f6a0101242bb917aad81584c9a2af39695a64232b01e820f103b2f29520eb192f3e9fa733529915c7bb80935dd5d5d5d8cc205a59de1877dc3e0f5ef2c0acf55af1278a86fbf85b81464e875b6554cc5bc1da3c14ee7501d75a4108a1111a31451281439110b4ec4e469904d99151903261b2478d17cc9788ae559b1f9026162d0562e09546ee0dcbc8e2524e4843104b334f42538b75d4790c6e1225311fefa37304b89cd275efb4a806b8019a41cad328a2071f8dfe6cc0d510ab58aecb3278440c338bf058708177abcbfda07628a5064fa70f91c706a88de49739f7907c01b6b0489de1c841d3fdc5f05f9fb89d060f6e34d4d18ee2e3c9e0f40d95e1aaa9a875580b430fbd0247e4742cdea0711aaeeec863c06132c8aa4190090a59938e35eb6ac4f96884504d817ab54c7dd969eb3426f47d89ff367d13161a052d9a375f911e5f3d4e53d18ece274ca8b08f3c5d8f695b4631194d71ba6bd8206b4e85f504133e4d20fd506828c87898740a5f5528c97a141cb3413a169b9f5b0526af49623563955d438d1788ad725da3005b08c7a7c8361994a250c740d932f09ca97ab1295c519ad0628a3a5fb02d108160b48973da80f3c09de71434b8c413b38066ce7d978bfe574fcd861a6a645d523ff7ffed8b691de852678ddfa92250f17ce703e5820ab968e2e06a27e7fbeb7838be164e4e951bcd0f37d78b4f9354586a8f613ffec81e3504f83dbb99aa25af0d33c4bde6204dce9a19242e3ecfae0e4439d8f821d00dcffebed15f5bd663738c9f993db9eccab09cbe96b647ce37f310dd370bfeab6ddd93cea93007d0702f1db5461fe70bd6d1c9bb3fe21e48927b864ab295099b5d8d024d5b790763f8873d6aeffcba28051282b4bb37e2e18588219269dac0df96d2ae7cd657f89ab2f4dd142bad5b4ca0cb24907ad561ce19aafa22b15f1adaf9605050485785dfbc7d4707373950765386a4a4a761423445812a8bbdbf12fd0be3dbdead2ac33a0fb699d730b292c9ea9fd6eafbe73fdc5b0dd98d33668efde9002607c27b9dc8c3ca10e282f6d3c6d5444ce9ef2350230374da2ff3c5f8c8523a1f99d0b204055fe5aa91470c87611a2d62a47901205c143876de4a33e2707f4310cff3eab6533441a911c55e31e59da982ad6332bd85ce454ba02bc4fc7387c291336e505869f2cb44c98355ed2374d12898b30e0bcc0bb2178cbd7d2afa261302954c0dfdd3a0b7518d1499ffd9acc7100381366e0bf0381235f0dad5962fa8b25106daf7aa51de777c7b6f270bccb8b58291873da3566798c7ca949c09acfefcc7a64e7e64d232c3e16eccb8c451034006f627a5e24ddd6b143db8f682ba414ecedbc77c43b7780e9ac4076781dbfdda515fff37a6d3bf9bed4096426b5b17c9bed4dd51f0ea9da917ace97974950dd871fc906ce8a4003ef24c9a51140596bbdf04535d6d08e5a0e8356a4b6a37974936d0f7ee0d07776d9a8ceb2eab93b2c04e71832107fcbb3858bc5f92fff9627f0951e4cdb8896cf9329e1495ac907153611c511f5cdc98fe89b5dc07ee3ca273106cf72795b50141f5c20cd67106cbb5da8010c5701c73cc76eb09f32ed3aed7ba9dcc6518da4d57e5839e60f184e86d27137badbe34fc7141aa56639006e2b1f7ba31706d296cc57a24f4b002bf0f22f53dd67afd7c12b12eb31326109094875dc2e2e9254ce8bffa78237f9c1b062c859e87670ee433bd2a9b0ecac084c9d344b06a505a47e60d4888b674693c158f95a8e7dfbf3c61834862063e8284ff36abdc1f508c0a63d49a39f9f2ca4e400fae1c36e9ca8c9ef350e2e6a16f9f9d91e6ce06d7b410abdc25ddca3817d38056f0d4241c8db88ccc59b7bde42e91af8e826aa5f939bd06809b137f1132acfe2b8e679349b4f84c417c9b45be17b987976aadb5fdd61787dbda6db03a207169a12afcd69002ee5a6541adbe43321604584473e202a6e05d79205bba89862ea411e72bd618596a06f44f34a2d53aaa6f726a8bcaf5629e4e984639786d2947d473dbc43e2277c8f448de50c6ec068dc3651d7593991e49ec06e2857b307ffb0c83d2f079707057d9313c46df6892029e2c9a2c9ab92e8bf0ef917a7e9bd88125ee22e2d24c73217d7359e56503a1f9ca32d4bd1a7e0c10722afe8e98090a6bb6830b49e74e3ddcfd9550ab74f5e59638a8dec5d9f758a1735bd1087d5bf0d2717342256e01d03bdda0b385f2001e304bef4dd73101c995d36d83c4e0d25fec5dc91d46fda3b167bfbbbbb4cababfaf43de2a72a5d17b56254dd2e1e7396908e18e1017e69e9c818e69099f66a3aa3aaaec6e70fafc724b2e4e38253570c068da4d499c55044d2df765424b475cb23d532d68ce189e29c5a2426e77d3a70f8c0c28ba140da87ba19e58fb4cf11638f60bfe60f64e7ce26dc18e4c14b6a3725a464f9ad8349d41e6d8e9707b08ffc1b7cb439515064fa7f3e325d0a3ecb009da77f914974eff21855735fd04e81b8f05bb6a82400476e99692e50680543914c3721be55119bce699b6edcc8e854742f836c543fb90ad39582622bb46144785f03d4e194a60a443f031f0914ce0eb6cd37d670ef3e2f7f441eb4f2382b50136af3f352ff25398ce4667c5a3c15b237b25e70c167878d26ed6ce2fcd55fc8f359b22f6fc49d9b7f38b02bda9c632ff41400b442e96634e240bfc3337b227a45b33a9979a8eaf6f173acdfde72acbe4bac566519d70adae35e7ce61545bef2e3f50da3eda7431ea28c0f1f596eaa9cd6064d787be974c2f687dc9266142f21cd9b2bdd5f5334d041aeeadfcf8555136004288ce721d085c4a2eff46dddeb0997f7d82f0f88f641d0a673dec04879bb273bfcbf8da36f170123da67f5e58e5e3738930ba0edaf1c8d0ea2182d4aa2587eb0c7179f783e759299e17489856b27538af7225c07ffa14695066fe96a1f1a562413925aaa5f07d32ca454038f82b7e481452fda0859f7800ef32dd82decbe038cc25812418b1bd0b9c9eb2c659e9309645ae03c20a0a536b7e67f6e604374af22d18ead797b8a8b04d4b22929d7c099ef9baf945666623700db1462833411cdbba88def2cd5b90f3d37d9f26e4c1906978279a9bc114331571667b2aaa1eb70a2b602a05c733c9c7307a2c463ad65d9693bb6c0c05464ca91b42b61557af2210c2409dd5fc0b7bb00dfe7d5560398bb4cab04d57887375558d2ada437c4d32e958f0390aa424bec0705dcbd4ef13093692124ef54560a5f9821eaa1654956736fdfe01bc11e323126d1850fcf206d141add82037dd1c72faab3e87cc18a7115c7e9fc189f44ff45d3f3b33b13f1d676b64093f7779f5dca071568485695767df3429ac0781a942689f8dc11ccfcd2112418362da1e5dacbee227bdfa49e5a0944b2304cef2d7b229951507b1fe91e20d0f1c7b825a5d6cd362a4ba32d616ab3f7998bd06b45e7e3a38d57045ec521106b5ac30da4b8cacd414b0c151dafedb6fdb250811ed28954676e007960aa1c5c3b735a2d8604ad232f4c0f2ad1762a56a459e1aecb1e1633eec59d54aa3736b3ec5b559f9d7e0ed0a22e30d0e36dca3787386848aea4ffa92c0a7321796a55d5c57b95525af027431184177b72801c56e5230dc0ff2b99c89a7c8882b1c262d69246f4eae4c8d91f5832da93e685c736606a3222401b712bb2240f21890468ee0326cfcf0b205d412ed78a63b84da265c074f380d71580dc15fbb1e364f7a07640fdc1bf251b58ccce3df3d6af325e9f38ef76cb4112d84c59e758e7776b56490e89970e5b032a54caa72bfdc94fce33940c2a57b07605f23adcc6357a66b3e66df016989219d1434914367d85bf1375239b44585df31ef7eff252ac32cef9a5891da908e2a7625b1debb70e0457a1a2c536067d9d79b7c89d55651be03adfd2078408f2515b4e99740a80ad2904d6e62f65093c38560468553978ec1fbf7d35e71d9a43785d9431b7b9cdd76da3b3511cf537b1244bf936ccc242d0f6f795193e26d9942ed0135c0f459ecc83ab49e56bd5f972a0823b61aac745856121e544f2e072b6376c6fc8b165b72d403cf1f549ba5bba5d6b154a9a44be81710f672f01000173a6ac095f18463c854f7086190b01a4626dfdf369c7f9ce92d95694264ba108bb8b1701447eadaa5b0b0048e688125ffca2b6fe9f1861821f97e3e8b16daf99f404c1f7835225a91e33bf24ef357940f23cb808bb5c48d0f664e83d3b034829804b267d7e8b7d1e61ab9413ceea19f8e2e53cb258e739bc1133e8ffca563b2051743b793727caabefdef4b91c0c0fc7cabcbddfbd0efcc7dd0ceda13ac2ea4d8e11c157e637369a3c62b3050bfc7e5f66646764f4795f8a48241f5d6c8a1c1a6f4da324a335fcb27d408a0c9255e37637927fe99820cddef89c803dac15848cc1d0abc330d642dd0fdb9e0ed7ad09ce89f2194b19af20b10645219af427e171a37a8cccb19857eb936a6d23d8295b5fe7b5076978949729a50cc698b26eaad7b2d94e355e7b5e860d6a8422aa2bfeede134a3a16132f49fc10dfd33baadc582cf8d5467b057e48c83af06e1edbdba1ca328b3d0bc31a2338ed1fca7167fdbda49bd227bcbdd83124683cad25eb740d0e78ae1bbda8a184e1cc2975da3a8ece3bc9907aac6d839b94676e22e9776aeddebb9b6422ba8f4161ae960cf87ad54aa1c5d07ade2d286d6575f0112c80cfee1d8e59cfdbade4407827c072c724cc6a478eab8bacbaee76432bcc1ce29a2b859b5d83021974745cf0063360fbdbf3915dcaf92e069d74be6175cadf9d70adbaeb7c53992be171e63e41f68c43fd255ff01c7eb679eac0e40b5359a3a92247c973fa29df3e079a5f9cc57c4286090f2cdfb3e5ae4ba80ad01708437a966fb6287570f44f94210647b583d308533c6ca7feeaba8098cec6f0b215364ca1f8d3aa406e3253c3cb0cad4dc5eee0a224dc15d7e78d8ff9da953bdeccf31fdf6141c548ea6ab78aaab07b17c0022ed401a62f9d3ec8697d9ec353d7a6cd089b7195b10a1be6aa216b1587fd99a516a7fd0484fab6e4e684695a42641875d71c7d05dad2cb4f943e6ae213d754afe1f9b264c3bfd552aee0804316ca1a1d8df5d8ab712cd2cde55e3dc2ccf1d43ba387978c2b6fc8d33c5c8dbf8798c6307791d6e841c34afbb75fe36a587a0e68fb1f16f54b28144356a0240018067ee0cca3a04c5c73f0b42674e10ce535ef3499ed610584313303d4720b4ce0f10d64b2f3f770c2c2a4db735fd84a71a128c9030eb822c6e813843a2b4075456fc8b4eb164bb8fbf75bcff378ea224c4635cd00cdb16f3e258089ea1e987e964ef2bbe21ccff435a720a7edcf828b8fa2d2d29b5ca8cfd119b6e9edd27414718c47f056928eb73ed6be20b7e26a9acae0a321c1d435361f32882a32554a439d587c068e5be9e90ab26fb7703e9ef5ccbfe819f45dcc31cb00f4a2791a18fdb6cd0eaf39f4e58f9049d365dd571069177a8d0dbc60fed13af21685586d09f632b4f4312a7ffe9f550cd635b4f4136569660f18c9229b796e864da46cbf129a56d444bfe075d419a9cd593796d1a2055f81b56db6d260c04034274be1679a02145294389010cf1773b8e802391b0d644e18edd7cd74aae4b426a640985e766dd3108963352e386986d7b29e2920b72a541c6cfb32eeeb2003c02e90d55c79353b71c700ebc7f119839bb1a92681326709a5c3aea1780af80cde9ad77e57bee460d0826a5c14b0d27feaaf31661b4597a954a92a0571f8467cf1069bae8618a5d9c458a7847f7210f406e9c2233bc99f6fb0f841818413a6325010476e5a7939971aa2ee59c660c488d6e5c95299f5d1da17a3177b2cd7ed6a607f3812113979265b3757caf35a3f2de1f7f7ea01902fed072ba882de35c7597d575288b5dbd0355504a1b7e1dbaace499131b5e01cc04b7877a383269f013185b0f16dce451d68004fce99704f1376939d222d561eed93392bfaa211cf713775c3877dd7158a8f2e57118b722b65e6f3b551fe5830cb3a15e859747a6252203a999fef29b155925e620e971c3246ae941f1e85d7738ed721a64ddd9e5a1fea5b9bc25fcb547d4d0be3ecf4cb69f41d490d64e92f02b73435fd555da2f2e0fe45482e34f080134222c7e7ca2e502deec81d5d2794e058e68c4ad56103b01dafb5d310b17dd139e0c2b8f6476108ee8a6dc905d74b08fba26848f8fa6a7fe6392dec524216bf7391b8f5a30876f67d2fabedd8ade0cc342740c6a72c8f4bdfe9d840513622ab300fa8ce15b8566e40d8be217083fb694755e24558bbd8eb7387be579f1b357922f70ae9cb325eb6095e1f7ddd4a0ab311fa56cd7dbd45739c7f22971e4649efd21d75cc19f8cbf99a26c383be14f935e8d81872e69f8701aefdbec9833307db041355a17908733902c48241f03c99841504122f9860476aa7673a23f2e937a2ca36414583ea049401be6235c7dc92a7ba8233ae7f727d28ffc4111ee56559081b5d6299d8aecfdbaafbe41a1d6ae7445c94daf1cd1e70a63095de95c197bb7d3e467beae1ec840b2a39bab3f70466f9ebd70efdedeca891437b362ef230926c4e68193fe73d01e886ebefc1ed991c185c91661e87809d25ccaf926609a9f973a0cbc1d0000df0a11c2cfc38b4254a5a0eb1dccf80c62b915db628064ace7b1634a8e8a3f948aa1689fbac051ee069b438cb480258be2f52061c27e9d53e1f65c33708bbc6cbea33b79df346957350f6efab55232cdfefc66f2daf935dd7a92256d6a22713f744fd01eefef2f6bf5331812550c81c54380bb4c2615d1b77717a5ef54bb9b2d1a88f7a647ad04db8ee1a672aec25283b58f1e5c238cc0ae431fdce7017bec9885d5de9e5a42f3bcc80ed700bc0abaafc2b21c12aa614f8ebc7a731dd9d86728cc8076ea81b930dafe6575f031e50d1dba44d1eb93050249a58feb01a81edbec1a867c5df0d062927a60315f07459ba1e52a7f7407d4daef62dddfe1e20de1989bb5a164579911e4078b5ba84b76a9f4cdf62978bd515aba87dbbf298a073599832c8231d6bc1f404ac27bc4ac88413c9e493e59995b77587fb8b80f23ee3c82327cfc068c5cf54777bbcb49fa354830c3be3536d333630a460baee186842c5c12717bdda5b5adc318e39f5f6404099090ec83bb71914d3326bdbb73f48552ed4ffe75c8a27138757c644895666d4fea1f30510f3142af5cc12e3d56210d745208c8003cdd7b4990f1415e04006b3d017890ccf27df171a22b7f8f9b435b3e6c6abc04388451acaec2c883d3f49a2bfb5471158f3a5a42ad8ce2466fead02f2b6add6ce5ac15db3d652103fc25b9d6768e0d3d09eff5615dd7a1e0f98e1afb720b1cbf442d9c21b9a6edd119c9e763b61bbdebc426bd90419d0c1899136a1933b3db8386aa5af1a71b077e552208d3aaadf8238bbd9a6b259685de3e90bdfe37c3ddfafce5e3c0df10bb2ac6182176a684d28ef3154cf25f77ed523895337e11c957a301a93b80160212dde53e82fec4483070fb27b059d7766dd13617b9b7bc633c4ae70fef75e69e21d4f5e3382d53e3ff72518deb02ad839b270753a206ee6ed1f9a4d55db0cbfb9d669fe27aef23dc57dff833b9f457706238775065fd6b839e567a07ebf3009ebb306024a67b8d1e1d295392a82caf9db0e0ce7baf7951bc228ac98e3bcda5f64d6e4e12dbb5cdaa958ead47fec91ca3009625a80aea6ed6908d63b7080b9f4a4b0228af31d859967072c8a8e764e9e175638c9c07ecf6be1d53e3a0865a80e9a64a74679772c0e23250f32a2246f6119923256db5f0fefd894392e844d0cce029ca01363da0eb78fc540571bd7bdebb40891da472619962935f8f719f30a5ed4b254ebb37ced43e6b1cb052088938cc10c57d276c2aeb492cda0272ec5ce4901f6a0da3d42087dc7ac3ba16fa20790854d1c236b016a9395d4efc42ffd7aaf7195bdbe958dc6e89d837933d901e9628a368512ae9ac570fe03a99b9b5b44678f344434a6e65a9c5221e6303de256bad480dfd442758a22c6f96ec53b8e24dafb9df3b1a8cc6b044b70fa7d011c21a1392e7ac93787f9abd07ac1ed115bb5deab1273c73573f9789777f70dbb7f755953c45617bceefbb4c3314b0efba7d4ba0d8723c5f9af47775b4a1b50e8b1c571ce6de33f671ee76766bdd64d3294685452d1f967a668b655b9a3e11152edc5db479a0ab0433d081e51fa8e00fd4e4314dbd11e1b40fdce460fe3f93f6d99e6e9d4b06f108b16b309a8da8cacf3733ee49bcbbb99edbef837cacc21de0016c45eeb8ffe61190989143385f0dab29803ef229fc68912b408a59ac483e936effb168d4c2b80630acc5189a265c45786291a5f8905288f34a314403648b72c52a74a19dd236158409dca6fbda60b1e4e75d7220000052e7ebac6015e36b3bff0142f68b671c335e9a2abaaf4ac186a404738c4beaff2df320329b41ca654a134ee064528cd720fa5b54364c7c99097bf3a575fed3392ab55d99c4aaefc30b4a71411d8017d41747408b7d08fd52ecb63210ed4b722faab391dc3d0c6d0dfa6685af124dd29837fde2226257f1d0bcf0254aee2a7bcb777ff0945d07c2459c9864bdfde0314c1adf898d56fee711b5f0a80a71f874c18db36de0a14fee24e30604b66755b18ed537f18a4a0730fa0540dd137c699510f7bd9abd2faeede26d7b2f773777b81d47d808801a975090577a4d85bb588437b329749db5be075f1040b227a00d146b980cf76c80f3d0063f163f0c42b310a70c3aad69c78e4be2d8427b2e6b7ddb88bbf3f77b4a27a7ac464f1e9ab3bdc579b54f61d490f881e8d58e39326b3e6b1e1dcf5e4424a38c1f51ed98b154f9c5ac936ca216d2118162f57172760a21455470dc3e0700f41656e85c5d80f0dc83780fdef421c067a49e598","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
