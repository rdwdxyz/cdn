<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a26640a9b012e334c0d0d272e722c96d3b634390e016fa45bb87013be7009a077dd4bf80f59ef587ef2925f39f548a9a8f03e394a35bffcf89e7d2bf72edaaff20014506052a45c6c33ddb035def5ad48e123ed599c1df10e9d8800d29e5712e278fb9c3b100b3e9ee8ec3085921dbd2dd927c8b180461d9870318dcf537f9e4f2d0fa4b9166e93b7e8e899a124e091e6e639675a1a26abffd1780b1c86071d0eae790b19772d32ec32b225cbb266029d51c855d2b878881984936514d540d51d868dc5a8c44d570c41acee11a52756263856eab8675e0d5370d881bd2b0e1a86c339dfa27fe2afe547d8bf75049225c42f95a14a3b58b3f808f8189f64faaaa0b0e56152dcaae731c701441d4dce7321069b972b68a23cd92e07345b7205a793addc9ecf2e3c9638d16b1cca86b97bb23c9afdd897cfd0e5704dc3a2dfacf15e0ac66587b8929b3b62a04dfdf9fbdcbdbec2923b4e39cfca4bd33bbcb325c8d269bbe2dd67dedc4097eef7668c57153e1f4935a11a81b94fb5b7e124389447423f047356b8704e40cfc738a4bbf8207888d25a5699fd99f9e0f5f8ff84ec27d47b4a2f25464d6ff16b1e429a98b5b1beda8adceaaa72ee1569ae21cf110c0b07782dcb6d9074c29e934c76b0d87f3d7e33ad9b2b268c8215df04db0f35c4c6e7c4e7bfe8112ff726ff43c28f370abc6698782194f4dd52044026fde97eacd127fc79f044f6561d37b5e0c0e3f696411beb2ef852942b37481a5ad5cac76b46c7844b4d07211a1793e0d2be527572f471070d354344a7545f466a8430102d15d261e08c36bcbdf7c4dc0dafb176439dd69a5064569bfa8e461ed7d8ed42de9e87c8464bfceda7b63066864f72fe7cd7a01c0f4d3cfab3ac297f0fca3bed14a36e9683571632a412f15e46f6a115efd06bf0838fa05fb92d104397f7e981c535c8f72f66fa53a864979292e5f81225bf0cd34ccba982b7c111a94be48db1e84e53bb67b92ee32f3b4fde8882285cf9c03d75b1714b6b246cb98ec773eada4bd6ed65b187f32236fe5b4abd9bf516d941d419cd940ca480c7f057c06fca05fba2889faed49c0845630034b06577daa7c370aa71218d3a2c090851b3d0712903f524ace85366240b3833cb0edbbba35cd758b19e5d29af3957298cd4e41b6c09b0b246f347eb885602c5049cee8f0717298de78ae0df54de7552930408cfcd4c3870ad0de2545b78f60e4fb3270a24b1225edd7568764ab64fc550cf3d1430b6ce064d7d3149b9e018d429ff489d88be7533e3c73e3142d1412b43352339e5a2bebc83069b4542d2a9278abb99328009b9a0760d6f91c2725b6724ea958cd0ca0181dc2da43b29c3a05f2f48daa687c55cc479ec8c9231d895c2bd1734b0c7ea930513dfd5a046aa99ebaa3944ec93abd1bafe4cf8bb861efb8345b57124c37d346e11598653ae7441aa88f37a51c24f75deb4c4bd7583c7de09c4c71059ea08307ac48033b05f80bd099de7c432a21574c11474190ab1f998df9b2f110355b6e677b0c5a5018d43d57a949aba9bb1b09dbd6c3402a99c2b428d628da492d3594a6c9ff14b1270a3790a33e080217d145ab6cb63013849283fd113c047d23477e3c48d90ab5bfd1a944252561b7932b77144679e851937dab0dd8f2c5be494bd9830638656ea8488744382de0b944440d0aec28414cc7f30af32f6d6352740d0c36bf6d305d1ce246004d20af57b38b950e8c11b07e0fa326d338321f419379dff41806d7fd1f41d8e1596357328b768145693de620f779098d7791d4781881658a4eafc875cfcfe31b0a73ced6e659abef114b46a20215ca2f7e81a9a0c1d82ff129b1cab6e8eafb452a5830cdf52f54788325cca0aca9ed01b6fc546535808648e87b2475ecc46215d50f67b0f07e97696041a1591e6f6a8e3f7dcf5dbc34902f649ba809edd9cb13c1a78cce693a142e7f4e84345f4c6d6b8441d887f372c9c3adf5fc21fc178601e863e49efedd22fd6408605b2daf94856869186cc2c3c7ba9e569d88bd803824c060c9e1b3a93e11748ea34c571afebedda95228035c3ae47c99005ffc19fd35c2e98855ee6181f276cefb0fce46d17f139b456b8e39b24cff37d33e93f5f0d5616b71798c2386229264802397dbd5772e0549e398c5537cf1e03ad85a932b191843d11c4b1caf729cce9534b0ca16f4e780c8550c0b57ecdf416785d5e489559f67296574f0ea48c7a9935a207e94b582c87a5531c6e83079a2917b282190578888c3ac8e526cee29183e85f477ae941fc4736d05f28015e92feedaf91857cfb1e13a9e3c908b027de72539f1e1d0cc63a1fbeea2e640a8717ac5c5dc75e8378c3a12d1deeec7cda96476ad10eaac887e2099eb7a1abdff3dd90f1dfa0e48572254a71b3087ae163cf573df5748b6cdaccde40f09986c1b7172e6d3c8c97ebf68cc0f44f03dd64e1b14099d9c21d1e117c7b48f8816862cc7122f3eb318017674bce11c15cc8f15dac714f3e70c30fa08151d2192e967a874a28f09d845bc7c5c91a40d2ffe12e382fe11e2c5f0686a2469e9c16bd848cd2b3720262bd4dde05658e04874c5877c24c23c644d43136c924184b808cb9890027fb854143e423d04f04399d09d5d886994a8df84ffec2b7b79786fcdc9bc156fe5eebb82bb582e1734f3183308ad632d3b0b08bea010fe84fe3b2dec924071d0b15d5e9e09177d32abcf666f71108d4171403b6a8eb49c6aac9ccc0273f7cb9d4c427024fe2392cbf1137c310aa48912fdbf701947829f8ed05d847701460df527cba34d3f3972b33b7caac67845e2563ff637d277a4306d3c67d65b47204da82fac6b4ac012124978810b932bdfe04348edf9548251a1c4f2fe0f40ebaba027adebc5e1a90b6e97ef49bc13a4757f97df10c14a15242af4479dcafd31d1f068b5ed7ce15a3a6ce337f73c610e18c92da7a2996acc8a42e37da66655aad5e248874b0d3bd3e1ccac956ad95e7636dfcf939c278e27140294fdbf54ec006f74e306e1eda6a6e7524ded055c2eb040866b1e5c4bc381e2b2307ccea4cf4d164c70282c82d6fdb8f3ebcb594bbbb74922ff7db6371e36e1aecb11d801a843601880eb6070f7ff14e69044e8c6c7116c632fd3dd9ea7a3335e901efae56d3693af4b37c17bc1b5949cffa35314fe63fb19c2608b26fa364959c1ffb5db5ddae0173eebc92249ad0d3166578c94a9c487c33d0ae3129c0ebb28e90c5fb0a746d708e0fc7f4361e1416331ff7cc62a56663c4b905ca68e98b3c625ab164f0fc9b25a1e046a1c6fe485580cbbe11638d6b254cdfeea1af383f116c939a02db2490c02a12aa1db4919f34fccf9279270081bfbb68cc06a2d9d5c26cf906a4202ff845f7c3da563a3511f022ee880ecd21ee7b5b366cca3a55599e2c53fa23bf96e6e169862323350b927b027ca659608c3043b4240a296f1183c874046dc0efcdfb00c5659c3224778751dd269b39ecbb3ec1fc6de62517c28541bdb2078552d601ffef4ceae686df54d7e822054e39d002b24149dca0542c99cb5933e79b582834c4741a0d426b36247adac52f9147f73583185332a0fca79542b3bd423af8a57bda97bc5a0595ddabd25e196e3d79d8d4e9c7bd4a3955428c840a22436442a0bd4bcba49ec14a3dfdf9b87de97f1edb1b695b0cb7642feaa93fb7be832d0ff372ca1f432d62af0aae551e7bd518f8e592bb0a48de676b67097ee335c1b5d0d96808106e2ad48c1f17df863deed1f5b4d15e86568993eadcb4cfc7c41b1db10b89f237c62905ff6d90da374ed9fb3a058fd38749d422fc68f676760fc6921647e101e3a1114b2a2091179d56c9f5ddd8ded33dabac82f1e9c9697c660230922dac0ee9fbca6c2ed483f9dcdf09c00d27711c017fdbef7e427da94d68b11a961059b60ae99483de2cf81041e76631c1d1514d13d680d0940629abcaeafa547e328391d148c9e4a1ab88b22193bd22b1333a572c620a4247de39613d32863c4cd7c0e63a5b20e6ad4413b823795ce536002b27591d951a992e678aa94bc89c725d7fd8106eb3962fd14fb98628a44dcbc77de982107ada5603d9ebe158b81b07bb7dbbef0d8e3d455837a96d1c1bf3fb504ece09aa41fc08fdd240cff905d24fc6eb3e5bdd6f481fb8602fbd74a711f8f8a878869facb67c647126b3196984e3cacd29a6ae19f3afb4293a9aba831dc47dbc2fb0fde2a23afba64f1c8b5e2fa94d5b28fed7154286798eee3ae6d121d9b83d7f18ca619be63e126c8380767e21fca90734b3abb170ba2f5af6237b5c9284abcdaaaa60afc085a8b36702bc96407a388e4bee14d42a4de69955625a16517efacf05c9454a20652a77777a127d47f54bf7ee3b91ef0da290ed1c037ef4e5e1bbf663bc1ff57f27462a477583037b1fd7aef5b550624c53a6c16fee15a31f6e1d06839433fa9f5fa4a3e68cb969b1b95a98d15d2dcf5be6bd903f3ab93c9abb1519479e4f60c4eb923f5a5a9d664ab1f94527628b47d1a84522c8ea5f59167dda36f347c039e03430051446de61b61e6d2f758dcedb6024b8d3a5b1faa3b079943d29333d5c1decc511f87b116e9bafe63f9ef7c72e82770513ddcf5c08ecbfe8eca2bc15bcb159a43243e2b69d2086298149930c2bf98046aa452a38f3c06e92c64db499506c45dce0d78f201fa9ba4d4ccdf22376c2a926a699781fe74ce4d37cceb795ad6cd24e2abef60db9950b50da7d276d311d812e04b1936faf4949d1ff665da5ff12e75d50f93253b42febbe761a00cf9b59c9d1d85b8502e4f8c9b43483c0637940c0ed225cf4109df1cf1f76309ec5dad40fdfce4948798aa1faee83fd5c84a4307d1c83d2474b59197936523bbc6d4dbfc1579d7318103882396d20534ad0cf4db7fe7e301907a8f8fa7ec785a983499f958f8fbdf86c06363ceb727fc6de6e74a22644035a856bf78e74c93e23fd825611cecb19248bcd1a2cdaca1038eca7ec21480c8c088950e5a151ae702022e7ad352a529d8efb548e4b240da53806a9de99decae06d500d8ec440dcf0e410b95737acccc2e5ca3f389fbc5af4ff3da1d878b5b7bea51d9958e1a66af7c255f0e671eb5919b80f786d897d37688cbd0245884bc43db63b001bdf39350cdb856aaa1ff5173b628806899a4cb1af7ce0432dceb86cab2fa3dabf4cda75131852af91e9d40fde4b01ca8522a604ca12b8d6794799d13526eefdebc9ae46c8c8980070867c59eb78b40c15d10405cc82562b227e1c5f36d2bbe8578866881e867d9949d8ee69b98c86268b14280ffe43d2a20b26177044e87d99ec827e49d0345914a9f082b873e5cb3bc78bf13da9a0b2db9711e123cd87e96423b566176cf840bd269bd1b92af7401b201fe0e25a89e9f6e9fa21a31bbfd0dd0c2834bf09d8f6cf8a10a6de5af4c6143a7f4ec147a07f6202246630b54731b3bdac09b42dcc24b449db1ef635e7ba98c983ea1b54525d3046bdf95578fff9c5b53f9d28775c3e319bde0a62d108b6d11df664cbdff51152d9deaaebf02f1b191d0e53a63c5c7116d8c62fd27c04a5bb2c4bc2c95c28e8f1f6f43fa84773159607a975da4f49c5c7e636710330b90e34a95825b2ada294ecb8353194ee13179958aefad2338ddb22f4ae0ed766d2bfacea9b929a77b4c751b0d239febf7f395195523e19869d826b9cd99f036c8a8697fe1e609afb31eaf823122eb2924ac975ff76956954da8f2564462f4267c376f256912746958276f940451b450d92d69e29152623fac21532fab01984ec64b158ad738571a1d5b7de33953e2c5e3bf9e260d40bfb003441400990029a739d0d3b327e580554fa6079c8356bfe2a7d393070903f2c17d5655ca95b17f7c07f2cbf72a96cd23a68834f902d41c1c9b602b03d7d6022d60695fa62d7985a95c1f9d4a132393d6cd4e21a31b238f34154dac3acdc77c47cae22b0b8590a2959c5abac2b60e63256ea554aa1e9ad955c437dbc90b052794c1803248093c21ec993cb40ff4686fcbb54c7117305d2456952f024a5a32022e6e0cf90fee14c2ad1e52559cab67f5a7d674192cec3f221f9ea1c106d9905a21fcae7043209b7ae07700e24467ca5976ecc4678ca653442beae52ce03c2c9ee0ecf7ead5d53969336ee40e7b2607804c25daf0c5a86c4e7b07cb8ba2890ab055789d78150f1f784656f656372277bc939fbe76291b769b85182c06f9d934274c18b5527fc04ce50987893ae60e32757920d85d057f0594fa4b3e96b0b447b84501dec88a2d307c52e4d4576ec490a4644bcc54452cc9ad8f36b15d4a34f8da332c46d797ef5b7efd5707c71188a7723ef1d08709cf795bf9b34f32edf3ee4edccbbbc2e4a817dde99d85accdbbc33dd6da455e952f702a25d1bf21c5d7dfc9ec94bf5e1b39686c8ea67799bdc87f0be3890e9bcb458a8269f5cf0ed32c347b88775a1bf52b7f54dcaad9c23d15cb2ee0c7603b02b73b7e7f480f54b9cef9a411bab7d5d5db4fae0b2a476a7c9bdd2cdf2ec34810f9e7d024b5f43cd5cabce0d06ef3004bcb9f9e17f9cb8c8b18d359c184ce5f4ba645fe701d57e97e75bc3567185056c0b9381ac60e493cf286e6f4e5d37f51b2dfff1a9779f06c613994c6d2f9e95211242a96b3d68351a83d865e07db83f98bf0089ee112692a85e36751ebc9653ee6b4d319d814bd7bf31a32542fa02bc10b07b445d2ce8a73aa66943e315812ef4dc1ae5e23d7b8b3b00fbf6236aa5d36e0d30f0588fdc16e14ea92ebffc5cd103076c547b8c2bbfcea17a30f191909ecb3daec2104f40f2ad09ad0cb4201927e2f402648ac64db709eb8d57ed842ba655b3993b5d6d6e8e93706aec47e57cd93a0779638dd5385307a43109afe6b2fd3632c3d0c1ab935363bc1fdf5323b715c5d45830e7c69ebb34729a044ec841eb9c6e6223a7d95663bf3dcd0a62f46a28475533fafc3298ee43bf9680d4d4a7b0dc85a964944259ada93f9cd15b95abae4c45878719f5e734d4fe93dbf95b900fcf8ecddb8117decc72c786ed07b24d29c0ed5d4cbba64661b4c2634dbaf32e15b34283426407d40aa460bb4fcaf77b65a16f6660281306d3db69cb64b76fc05730d030a33bf52510d46b3bb7dd7d7c232b4b637cb86120c5fd4a0ccba28f51d760ffadb92d16618b42bb966f8c4067a69a142b34703ca02e3b78cb0aa79312a80177b923284f93233f3140b0ba33398edcbbc48ce4145dc643e3036cc8f694f5b34e96c84e325bd258133e2aa034ddfde018d6d65abe31c21557d52436845247cfd3bf02e8b379e34211c19c5c36813a170a773843775ab8b7831e65dd17bb2427b91ed65fff53fe522177d1c81e7369815742436aba59fea4a4185e810c636cdc7b55825f4942c899defcb910c04b55060e221e72ece15d5f6736ace49b1edb3dbc97734ce2451a2aabd36ea2293475852b6c0b2f82c508e4a589be1894bce069dc962a4c436b20fb6a4de4643428df824671f12474cfa858d54c1d67473193d8821d2227b7382ed95dc817dccbc4b9424a8804abc18e82c6badefed247e412e91720d1c9fd3f834eab5d9624ef261e45feeb6b0c574b232c6bac8f7fd3191d77a23495b5e49aaf8713fb69d95d868f20ee657ea0d99c8e3cf3a5f6b2eef4397a68cb2cd2cfd769a757d5830f5e531a4b1d0e9364e57be89d53562cea5f90effe2110627b067778437925ccee485d64d1af6ff5b24d78753f72c50926275fd352b1dc47e40b9a6c1f2b5e3af2084143425e66a63ac00facc81f7a3dc3ee8d830bf91b7b94dfcdee12ab6dd2b7df41fac9dce9e43f81c96bb8a04c39b2c61c20febfefeac84aab9fbd436a2222e25a271c2d8448e0fb0ccce1325f8544f4dba5a9f3ef85084f7c638b6b693c530fc27e105365857584b6beb939b839c52ac02c1f30c5b42d817dcd0b194848ca150151927f2570173bbc2bf037582d2dcc9cb3fd447628cd7ea44701326583ea10d876641326ad0c88fc02354ef2d168affdff64242b1b58586bcbf855042a38cdd15687a3347f48b0fe45ef77029ba3c9182c4907af7c47414a7cbb4934bf676ef03d560ad6e394bec103290149bfdcbf8ff9de48bd3dc677fda2352f24aaadd5a91c943d00c15454c711cf57d1fbd37dc423b7df9863d733120bf238b38cff14f3bbc9f56e1bb7b8f9c66db13bdea7369843ed1f7a91be23c5fc9fbbd11d6ef72163880f07485104b13ba978f4ba213ea1cd5ca874d037f16e5bd707b254d3d057fbee4c280c084af3bbadbf584b3424a48e68be3a9c86c8e1994975b81b7b9ea5388eb574f440ad7bdf299717f3341a3e21ff5ed1ba06f450518068fbfe7092925ce3d442fe118a7a83dec91634e5ee2ab18a48d8e17ffec7bada2d67400e476b0769a47fd96eb0824f70da635a695077b097582b6bbd3b0ee249fd6c4b3a2e9fd3a795eeceaa1eff7b16cf4999eee6b8873816988104b6a851fabf158af4c4630d85d95e7a8b752f0734cac59b776e5469572481c6428e61258407ed0bbd9ba5144d31f4a87ef25622a6020fa610497dfedbebfab2b4a3f0f60272d595f0bd8014ea43046f2e76b254773f2f425c5a9f5df4a36a4d4aed986ee5fc63243a6c4bcebf3b5f0f469e458d0f84be70a509fb98a9b686f4133eba219a66fb89b95c2f664097509686845166098df8f84cd2c29e0e3226665cf64dfbb2893d5b57e299e1d30ee7f55cc18a4367bb8b177677fdaef87c7e74eacfd6df9c7caefd238003630f86fae702cb43c7ad54e05791f8ccb08c12a99ae15800403f82cb86ba26ac39f41379c45f8c10c0d3345c6e65ddbb46e0cfadc3157a5e6dac4093f0b07aae77f359244d65f960d441a623daa86854f392d644c907aa2c5a8c504d4291bff26219e56b5dc61dc7de83e9bf7d74ae9c1d145c18cda7698a3b0bba44193cf1c842ee199a3d2b9c5a7f5a4ed70d80b94eb7452b8faa352e02b8296e874a5aef46ea84edd855efd8967a467a44000a37033615e7f55d1dd07f91751df0b6c66dfd4997a04e3f365b24d39c6b6bc3a959a6fd77da3281e66e2684566e03ca0ac06293ffa10ba4ea636656b56b92162191c60b0aed8bb8f9176ddb97cf0dca41c7ae39d8e552f309f2683b372ec4fece804afa391fb1737ce46c0785f8832a5efd8f5092ed20a06a4e5717da1c75fc81cc2762c17d87f6b55748c74c0040d19f941bc712b719aeb422fa29cdcff9eae94f6305d8b7406665e27b2690ab7e54c9d20cacbfe11d64c28020eac61fc999e9dfee44c3a57d6fcc3d18f9dde8fa3a783f47f353ea9a6dc6d54d076e66732c3ec8899414dec492ed79bccaef9d5f9e78fcec1acaa5d6640a0a3ef718824a5e0c848e8d03e973dadd63a58209ac7d556c8f6cc636a1c2818eed3858bf78c08a55c39fca93662c9d8b9852937a1c7dd0647d1d0ec364dce12bdf608f12b1cc6c12219e468b23d6d4c67475646a40c7e027fefed81632d53ab2651f8a9982a3d6dd00f3cae74d930602b06d50e370d677c0804ae587338b815c41d3d16769b8242422312651625a3c04ba1d54563e8fd0b2a256982b8315327193042f9983f121d0b38701fb8158a2f5a0008b858e90e15a4d6778adfa5b9a460a49796c597ee25e38c6444161123f279edca3b4fff111826e72224826e032ab815cd7aace0241ad567e5283f980075eca5d83f4ce8855d6870889744af623ad86e4aeb08a45ad92462e00f5dd026bdc8c82f345da9917d2779d9ce02cea10ef4df1e83b03ff68a45abef59d17db092c0cdf5d739cc0af33e50834232dc01aef25395353cc1d969502b3bb3c302b9caa2d4e411c6889eced6df7d3a1a084eb1ce72a762aae0329712e7cf15aa963cf2e28da2d14927c79a7c6645b972be7369272fd9946d296876078af050a0646e2df997a0db5def05cb9749557f1f08280380a3274a1c107dc21ecd09fb037304de41d07d2c9ee8e4312fd07fce635fe7ca610ec774df7c51fd68df03bcff1dd35f82efe982b74c876739d94fe1f064aff9588f4a1e838cbf618a58f9fb48384b18b798afb90638af0220a88a95e1abf842991cdfaf62c837255ab0e1e4809e472e9c5c6add8e91af38a6f77d0c8b93b4cef65f49d77be562adc2d7869dc1c91923f4ca983d136d419f8f251985c557b7077f5332fb9e18510dedd73f3aa99b9e6d071d6a7e5cdd36ab5bb1ea8d13a58e3ad30c4cd2fe250435ae9ab6fb696002626ecaa3ff887bccf074daab84d9ecacf42a64104c8b30b1e56e262d3724e1f0b361668b80b353cf875795f9043079e5eb83916b64a7d33a498ba460c92b879d7bfb24a5e08257af18feb8f207e0d56e122056be963547dfc5ca93b1d4c7c060d5a6dda7ccb126cef9cf3dd1fbbe9fef5c840b92dcd1cae3a31bbe91e9681f5ffa8c39e4fc5d62396097cb85c37ed7ed6689d91c67bd0242f5edb6ee76ca48a10398d876118931093668f39d8eb7f8cede65f059c92aa5028e022d753a0088a936072c787b1804c557c79e9a7205efebb272086bec7e4e0ec7ad7c26010aab4c82e5e11331a9b2f3473fa356359b44fff8a88d06e406b51b634d9f67bd38c85d80c07337ab0f63078216ed13b0aa06dfc1302dd738eb54aafabaa55028d04304591659dfd978e4a570880de4eb88e382f70f31790f09040e7b382894946c7c806e355e143725d789674ef80c3bf71d0ec6038e278de19d7870812cd4259f5f5e6245d56297ed9d72affefeceba2a2cbe6b83a267d87625769cc19cb20bd701fa781ba396d9d5108c962ba04b55900a9abd221a1f01d193523f0ad9b669e9715a3db5fdb0ea69b9b756186964f91963a445173d1298e8e05bcb46b4d0e1d2f0932fe1b03100e3897be376959ae4c052ddcc73accd8f9455048b9de79c12917b8c166a4aa8b53f03becfb53b97fba90bb788e128dc680420f49e37795c04338383891e1af164e509d1ade4e42d1c6944366fd24819b022eb5fa228e0604cb939a832eb4f1e80f116bbbf21ab159787b5bf4be1e542fa698ab28413faf635d0ab6c62c64dda6da61567ca88b3aad97a1d57765048ae806d11c35b3a535769132666928dfe444d32de5a2e071a072e75dc15f7a030062a8d39ff53beb483016249da51e7d249520ff9766c8e51a8e2a90415129cfaf416a30f22f3d9338bfa0d13efaafbf2d11321cb57c19d25a8986c0e8a95b2b480114d59b6af236c7ebd86357612da40da45ee9b41dbd48f1a635a9864ac8654aa9daf1977edc38f73b974a7064fd8d0ac7f419d155d5edf4b8c5c2853aa6da3dca5deee3e7193f85dbf8da401224a83a8497cf0c66b061f69ccf64b084c6713c4661299f8ebb71691477e99d5bd00f05b7278794d5d60c7182a21202973d12cdaf1a2ae2f1aaa2ed509264ed9b9afcbf8ec108373588f51fb4bb183e271c282cf4b5ca3aadd11dd6d7ef5e2eaba129f585d7826b26a4ef5c67ce97bed6aafa59332fefb0af66b742442c6f51f78928a62c7f456f68d5941bce44c342d0e95aa90ac1a4ba7e50d421654758e523fb513d44cf9ea8205a644a9c80b072503a6f10bed0d3b86cf2cedd8ef76cb57be8e3d1f6b30843c0876c763a7248dc2329b004f08e6fc63a82f49c2778c821f4a837cbddad63911a26c4a42bb3e31f8578f57fbbcf35753e0ad5159986257bcdce793c43dd2af30359746c4f7ec9b9cefc974ed5deb3dc46154a275f6e554a32da694c09f9b65fce6e00832fec488d25b28dffce453309f46e7fbd411144ac4bd294ca21ff062237db144fba47f269e4c6b689e323d0ffc4493ed230626a4a28c2130df55a08fa59bc5dba92efbbbd29cd487abd43bd54406d16e678539b0a7b73a50631ae10ec6cbc953fa8914faa6c6a5a99d13d4f98f5a6b44c494ef1b0c7f7b3ebd8ff499ba09fe6c1efc03ceacbae14a8e52256653ed368a31da72180d8f3bef20e1bbfbefe1603f6859ba2727c908ca25cb4d4553a5cf3baa698ba334be8c8c20e5d57756bbcb15e46cb1e4c65f78ba5e0bb60f2a2c0deadd73897bc35c2db12127c34fab3c9bd1f6b08bfd74a66c041d8dacb935c8969a789158ac0849c99b9af24749ed954a221a2d01628243a6a2ddd04bd402a44a731f3cd3aae3fd6f49fcada7e0027d463481cde8b46a366f11f8940efa4bb1374e1fc700b9fceeaf38de9e6cfc5d34ce65975fa210159fc92ba62bdf7b85410cae39b18768d077f8786f274b2d3ff9c51d039dabf59d1137592163700e1db9fb0cac3a25eda66b75bd6e9f2853950dad7b674a37bffd27a7cca1f1ad1fde91080c92af62465cbb887c501a8db4fb87202a448d145d3d8eb84fc3c34a0b97db4f5c167cba2b76a93e5f07c6f3dd44e63ae44953fbda5f6cc19fd4482ef4928558d9b25a0dbe38b2a7beccbbd33d55f341319b7511c86b203e982f1ca06971eee240611f17961f0ed89d868673a9052f9a5074f4eda3b111ccdde89651eba0f2e81a68e9247585e99260b77cdbec3f0c95601db1274a1e13ecdd603a8d1513d2235be519ba59a45f93b7a9943e13c92703ab33970582772646e3cf5ffbc96eca25dafce3f75673b3575d867fed5b567c59e990cc6e9bc65b6627cf4f67b2c17911fa8c8dbb33f8fecade60f87fe9d01efd65698e9d1096c94d3708b3c486606be290c23843320f3e9143d122fef4b66301c15f05ce1336cddba6147f5bdb386087b9aed9d2a9227ad421b47fe7cab93e0c7eb522d9e98f1a344a22ea0f33c222598b224dd11c6092827ad6b014c22fc700eeb3dbe07edac2219957d09b3b49cd692fc5728e02a7d8c1c0513faff01cb97df010b32051b23dcd2a62c60ad40516aa177d295e30b182343558a3b5747da53747133560a4d78b6da49db92649a061b07da7483857832e16248ff3763efaf9c4bc2686d5c24cd926362b7a3a2bcc74f8d27d8565488bc8bef23e77ee5324ab49b6f05be58e78054cea6a3449181f7e513e66c141d51315b7e47e5b8864d75e0d138fa9265701f3c47031aa0e1b05c1c2efc31106e12104a0dea298ba7410a5a23864950aa8eeb5482434946f0ddb6774fcf314bedab3def28a47b5e9d6692833e973c3b41697d32f7c01c6e2aaa65d159f96c0ca54aca1a68c9bfeffa6f9a4487efae838571282471c3107b8951d9c8e595040a42130d9080548eae8b8e33e604175744fb6d3d37d79bffef2fe0f975266a63cbdf0364d88e4b5e8a187d04c89dfcc456479629218c2840cb7c2fc16c21546afef8d202a162cf79c1ab056175e0e9fabd829b727e161b42de224d4cfd458b33d5c63c75d5b9eb970ad34b824348349dac91f89607162393553864a263da52421053a3b73dabeaf2ac6fc30eb33864dfb00ec2b800792a2cbf8871098881ee9db0c4d0bf93432747a36c3cc3cfb3dc96504f47bc72f8e70ca8bdc38943aed9a4368c476006fd781308eb40e7798041ffbd83c9b3689e6cf63e5fb13aa6c38f224d7c804833d4cd0e3540a1e33cb9430b248e44d97cde613ace94354cbc0e89483050437b663c1b9686ac93d3aebd73dec304985d83dadf83cffb5c8b6eddfbb0057b3b9d210062304a29599a7dd544e70a3b2825b213195221cd62e2c489cbd4c60ca33d573d02e262a160ed36a8a90454033b9e6077619fd1b0741282522cf73cb3e52c65cea14e694aa5aa2c65d2d571c24e499e047a4981d6928deccc0a59c84910c489d60aa0cd414006cf3aca67da7f45e14acc3b48fc47a38e359574c8fdb201308f8c1df7bc74a7e9989426ed6de3551e4076a6fe7701bcd20db4b14c912ab884fcc1eba39130e22d0bfa0ce53d453ecbf73bdafb67c21310b6fb8341ec1220b71edd4332d6d5930d30bf58ebcc12da728b3771c54fdcfe5d7ba730685f2387757d42c3b58252d0a5960ac54ff259b7048511986e0a7fac1887f102f56250ee135203ae4f266f33a1902cb45ef14126c3ae63af5a1a18197bee6eda427ff9d6da544a48b34b3256cb9bce3f44862d28414bf21f56f518f2cb5d2b3949138c6c43377796b1303b408c233984468a22077ded2ffcba879a785fd64ef56597bad86f10cb0267740e9868d25c762dc4f3ebdfbb0b08ee3969038673ab6e51f8ceaf8545d1cc8556f3bd19ec7e0bb7861f30f49534cee13b97192fd435629e5766b7e7e220bd12965a6a5a104d3de22243af917fc555bcae93d8349c718e7b4cda54a075c46164f32175519d9e511f4d1c18ad8477f069c676c8b61b0ccdf026ca961755ad4344cacc8645564696eb90b4ae20bdba7f31814a3ded398542694b0ce0f49657006523e0f77660e78136dc99599db2bde28869b922feca907bd72ddbdc837927e1b24482a09fd5bb1978508529661757fcab7dc5373814c3684332a68149e743b63aa2b3baa9b33843e232552d515cf42db85e3b079d3476f0507a23c185bbfcedf387ab5d446fdfaf63f06c79479bc61264dc3c3b1676f4a5eac46a0470959fd7bb12ff90c8dc777f82491180fa8c05c6a2ef33aa797d4f53d7d697950f05b231b99bdf0bc35a6037ab8186b07d66ca94c1e8dd2c04f445b155bab461c6666f13bf7aa618b65f5155b5f4b74dc30bba78333c4992bbfc9add56c6037f5b6dece4a94285724b1b5cc94ff87f0e98d8c148ba6e9880f3b397ef43fce5d841ff62859315d3d7c0650441a4df60b128856410f5e06172e41483eff77b5b8f0611ac309d748452fa2267abebd757061b2d1728fe90a4dcca2816895824b93819694c70a3104cef8c901442c2eb778b8960edda795eead9dba5f85125ec421927949ce89be359dab6ec1106164d8abe8af879dc710b8ae8dfc76e3a77d8cb2cf9d5369db8031d503fb336d3aa9441b792528c82dabe64b7f24cbdc78d53bdc182885f2e7be9280c678399fa4baab9dc162215a340c98954393cca1e11f3c3207c6917957c4c273252910e6eb0eb79d4f088de460bbad793dfd045f195283f9c5b077bf4a4791a1bc21082880efae5547fe67156db4bfd1ee1cf4ea394a3549d26620600b5406c50e118c8eb34bb971e578723a4a59fb13ceb00f6e7e680fbed6938bc56f1918b30d1fb031f45539277f9717a4b67c277fda459fe399fc170d147a5c693b219d1c653a8b3e3ce7ea436d28803e84005ac14914e2a7d3a76240aa93f656c67265ab266f5d365a4482666220260bce3c5aebbab8d1fc44dc9bd842d27a5e0d6a2a73dcc2c735e3bd5c19960e7d3284c84305fb7e32f9de0986eae5846ce143f90c87e5cc2888105f312c9e0acffaabec487d34bd8e171e12475ac0763c2357eccfdf5d08d1360940f913f485d3cb8dc0a65aada208cfb13b1cdca785aa2113b4bbdf6f4d331e1cf5e3345d5cd4dc431c1d824d26a92889da3b3e79d3ff7bcca49a18f7ff5f2d4bcb85080644b1e68bc090421977ed7c9e993b81e9352953b73bf56799a95d3fd72547bc4a2497667c9f2065288e77235c25de8789cba2ec85feb37deedd20c9e9af51aa6e7623bd4ca4b63989754715fad54822f39a484a56da98fec71ea475b6b74e5af7ab5e861e5c87d9dec346215645903ebf5f62f671ece5b394d18700c8a7048e418331f1ab17be80c8c41f28ee1b5e965fd70f9fd85a5899d0afffe713287188938f7419e397e91dd8e2a12dd9e89e76836a1b20591a7026323764bd90c348dffa56489fb354c5daebade16e4a8b745aac70c677a6c19448ea0eaf8f9ae102b98165107061c71f36dfdcf5d5101a282aa566a9c57975ba12c2a72546e023f1abd360e596e6acf15b598c2c4b3ffa09a1fcce4c50557080b16aeecc26019d96b8e8901bd894caede2eaa9d7a0970f77636064a8261961c0bb39b5ecdb12b15d0f823de4a28a5db9b2b27d0a0d2af50e31adfb2877e403bca40336baa90ec5a0ac4562abb825a110464cf65272665aae1618d77dce125c8e6866f03b2e06fe3d79ffe991f0b184166f1078af2227458c9fb2d59ac7d3d108a501d497c7b16c781de8aa8098d5c5e04266dc51040d6d9e809ede6065f40a0b11cfd4d8688bc40c855e40c71ad3bdef3e70e737c188830e860e3a560e51ea90780af0ee72778fb292ba0d167883997341415f7d0f554d383012038e9e55469e0716866c5b2595e92dd45c38488b0f5616bdfb541f86af6354ab1f9a3653c7b2cbc607f6e1d5293e0d3dc3952c06ca1ecfb0e692789315a37a0f561642a8489a68d3e063ce5517f55e65687b077c2a6760efd7c06b62cbe0f3d91d1f5c5545c7cba6357bac3671409f6a07f637d706d3aa20135a43c2d06307fac0a728156d78e50b2b6039d2952add9055a4c808c164160cddd151b6da930265f9e70543a0e0b6579710a380f7b58cee2d0e71cf341c33c175a9275c20a3ffacacd4f9a9660f9b4e3da155812bc2d8ccb2ef85965d0953899c3fdab258c12e4645c5d74c73d56c251d47b9fea784460f5b574c279f32594baf329a791aee3bbc62d52e2902cc73132833aafcd2f7a47bcf027328b173deecffab95945e31d2f8ec9446e45f897ed87228fd5fdd17bed457c3c424c35a1fcba1aae2ad1e2cb10256b1f4a6dfbc297864a4024d7b17e15e53d6198f1e8a015245d2e8b5c24e0e485c7af0549c349b97d50710c7d22e0faa72356fd4bfc787d4a257d4305895e6dc8cf548e8d43166cb56b3b716f062083e49caa56f3e3c170050a1217bf32dc120c6d5d690348e5aea39dacc97f86e7a55cd806b5ad6f8469d3c2949f90e77923415908e16b06d68682254f9c89cf5a568e8a35b17c6547337c64022becc26e6bc30c107cb59adb5b80426f000e13fb54f8d1da1669754f020166fe0f60905a373280bd61bdc7a463e6cea75c3062397ab9e68c6aef63e291a225c705247ce82b549e608c7adaeb6ffaa194e2b3fb6831fc910676d9d9d0fbbc000a7624f75cdb376d0b85e121841deed87623d7fb52f8efce9ca8ec1d3947663110e5ea3eb5a4a57255c683f5b831002acffadbbbc443d731539b1e2255b677a070c6894e0f1eaa2e5fa6d189f74c2eb81ee3e40abc098af27a321ffb19290695c8d2defaa5b3337993ab01c207268cd43d0b4376ad100a99f3e1af11686bada4a1a04b2eeec69a4336ee984ae9db2e9408f00606a174c1e962fd5334d78eed01f7fe3e1a2a3aafe10fc0faaf1301806c10267d6490de99903575ab2480edb5d417030d550248e56d0ad5afdbaaf36940cb33718602a52061fc991414884849e7dce6777e2b6e5ba91ab193918ac18497661b42cce0fa381f890905341fb999a7b77ee0549eab88be512c31c92ad1ab0e8ab81910ef0ec54f6dc3ac77bf9f25442d8ce8a45a6be7fd0aaae1a6cca5825d3fd990e378a54361a76dc6a51a333f5e26b59d00efb13c41659a61bb332b9dba921efc44af2745b811645c68b54a9ddf711f3ab31e9a003273951b00acbbf976ff8acb60158e62ffd45755d3088c7adb79f82e7e79975cbc747d0babe5df333a6bcc579f328dbb275975b0f3ab252cabdefbf65fe487f6d6ecc15c5f6bb96190dff12651d1bf4914395fbe753f30e5c24e39e7fad399b14a13a00e44c3d68ae0c4d6821a6924b11c090044a8aca8c133c5184b11340c6b6d2dc9dfbf316b6b5ceb41c805ad327753d4d0ae677598958be39154c4dc0549151fc58e12d3c573d9b8508f79b5bb68edf9cab712b0343bdbe0a27be49c64d525338037fe63f0571540002d4f89bcc455f96582329997ad9e2d8fbd1c207050df7a31d9c464c87228fa148a909ca801541ab70f99ba262487752c868b465d774ac316562dd5e02192575b7be19d9b2fc8823cfa818fc98117ac17d0b3b21a68d1169d27ba58a9fe69aead8e9b442cc3a64a6f1010679ba26de6e42b5495d0e14c8f48f67999b8153a21143801d9cdeff8f5f7962b6b41e7fec3e11d55fba4491d9249bdd794c50064680b405477f1bc6ede9ca2f5947483005a489a41455375f0a72260f3ef3d571e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
