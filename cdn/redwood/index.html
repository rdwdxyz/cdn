<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55d9f83ede80d5d7b9d8b1c6a3c9316e82ee79bb2f25597d3d8dd33769b62d2526095f238cf9e0ee92417f33b58555fe5288b7487ff0a114c463f57b4b3d1569648d3d86f4a22be0761d5c1f3bbd01dc1a0a15049842ab3fdf5d67beeafbf80aeeee7fe0b48efcef7a9ec60562eb85e1b8561a65558e425793e4b191a67bc670e0e94ab59cf274d14c46969b7262a514802bc593c713f8144a0c430581be2e25d693eb0eba7a7dd74170ee8b198b3c33f895c4f08f4be0cd7ffff102dffdea9abed9c7010cb8ffa13a4faa4e4888c5a3b4696834a31eb370f41ececa791376b2517cf2ec11c2e2881bfc98e487538284657ad20fcc5e40bed3379af97e958542aa11b794cd53441c1dbb2944140c945a7641a0c1f233d7cc78c62710bc74a3a274ba7f5f16cc746898a9409ca9fba4c1f866c5ea4c000b15adc14c79b3202b362b35f014d81aa3e7e76bc432dabb88447bf00345e6f9620cbdb143701dea97336d65e479fed1cdb9a1403af5f9008b273dca23b79b2418cf96660d5c8dec351ed0b2c2737676a38179a5122d5666b0334e100c9d8ebfc7d04b71c98e62037c2e74c6af23de518d3c17e5245e9fac930528a356fd014c8ad94599622f79b0977b4825ec123cca258ea879f4870be215f4e109cd2565d479338990877d1a3a482c1300251305998667a0f2020dd6d1066af9093d42bf10488aced8b90614e6117c7101439f885dfe8bc7cadebe9376563101189d03b564f47a44e11954ee50e73b7a874b74927b3b365c1828e18d3f12627adcc609422cdf2133807d9de1915fd49ef9392c8693097203fd3519c06aaf49f3e4cb311d748eefc88db55c63f712852a645a1e767857558c5676874158696dc3630f59f04dd149978c462166b1265fa2f7c06b665ce1fae38a7a9c01d6841c637c654743136b41331aa63134a5a7e5b3f33b725bffe6213842d9a0555a2ca63b9fbcd007a845a6481490e66a2925d46ffa774f1e28457fd0e4e5e93e1d45272ba95478dae29e6080878673016484ba534647a1d89228aa81f9b44cd4c3d2d5a7054f59f66b5b4e820dacd21212b46e1f08f0ab6564c344f291b60335b7acd35b48e0176ae51c4ba0cb131be7cdca708eed88af3313981ed1cf37a7d0ea0851e7a6bbe2045ffd14a50232a8e5b6eda6504bf24927be5947a112c3d26efa78beee674122c008eda3b8cce2c0ebaa1f3f60ad3900a608b221b59a28157c83d795794bb3e1e8c17fd15dfb7cea8b34a696cee6f4811d64d70b2ba83dde394c9817a64efadf3d311ef5e6582820f74efe88533c64d1a03c28b0050825b3fbcce7487f2734825cb4806decd1f13903e89a05ae2cb0ca52bbbc8c8c1a6b11ff833aecbffbaf4b25271485f8619201185c1b08266c3d9c4aa0ce8214e53a3b2af4f953b141b58d9b7ff22f7ee53dbb7c5d0c6241ba466c93d1593cfe07c6d953551471bfb99525e3b819eace10fd10d559e79eebd304d41daf3fa58cc0d35f6d871155494ae7c0a5f8bcdcbe635f3beda5fa3abc4de9f72ada91d48c52018d5ff2e64745ad6e998880a6d887005f6dd0280051c5e1fec772ea76210dc3e66285cbee10cab0b04505608796e21b34e7b0fa1c00f28d40f5033cd12cb0f72ec24a406317c24b6b49fbce8273b829bc6757c264d733b8b179741ba2b32334b137f8f62fb9bfacf3455c059904ed6a9315b2954fddc1c12e7de8a9c8b81f50fa94505b75066382203a6bd6cbedd67d49de7eff748157c920f0647da33331f25914fd27e08e3fd035881a13e548c4db04417b1dad5ce514431a54900850a9aa18d302679e0cfe84ef7009a1b1cff3cd54a6e13ce03caf66a9430338ddd8585fe16e5f79b8a95c34b6eb5ed93a2f87955070ba1eb70614df485c42ebabf111dafbb5aea038f99de9f6948ec458bdbd1fd6033bcff6a694c0abb221e5224e939c0d367cf9dc6ff59f5319b5242dc00520cff2565be81b01b490fb7e04d678e0703a96455d85e4619bf78bf63132d544c7b46a5ebe387ac4e03823177f359d5182b56294ba2948d89d477ab55a902c9bceb3ac74517280f04eeb43b64164bbdf1d3d36955bd9ffeba9067aa782b5ec4873be9c2e321f8769b131c21c7f10001c7f3e4fabb1e303289e78e96d983d8742d8f743af046d2e76cc00578fd2b44467f46ac608e6466c62583bd19a33b10b51141a01f63bb83805f77797dafd0541e4f07393c99829dba45fecc290d765c503332b3272921acce3c3fdcba8b9d77cfc8698b6f934b8f50133f3f29ff74cf4cfb6f376765672d61078517a5b1a098b58da9cd88bba5c725a55a98822e132be383215967884c6609c9effca7065acf7d46458351eae691d3a2662ca7c1dc272b83b18396db3e44c4b0fcf51cf400c88a88590659d01dc7b85171d4c25b2585693032ba6b58c80ee852ebf4ad70d162d74c247a61cd5c19bb545c961e65f3947966a4b1175138b02c184f226cd8b3f7b3a6fb5a925be2986e6fc60810f385bcf7fd88cacc12e1d35c12675b8ce16a546e0b3566ad726f948e73494c766dc23e911a9012733f4fca72a23ae5c1a9a0f2805b435212e2c46293c1d47bf5727c8518c4f489c08db2baf9ba7bec99e6d021b13e27e8fa6ecdd8020de64856a961066c710c7b4089c536a7331730eb6aa643199a256b7f45b9102133112d4b2cf511b020fb32a761ab5b0db3dbf93e46746440e2404804617305754a505a4dbe6e5848f984210673b2f9f40fed54ccf1f30068f84df732d9646d8c10f905839fd0977090a0214384deb1fd9d43314c51aeebbf219f39460a530f05871de1eb053a431b762077faaf5126f3052fdc5f94b2e9f0a5609280f83f8b7c11916436d2c37fd40082c6f3ee8212a5042d32deae7bc40b6d17d846ca479edcb8c03738f60f77154e3f75dcfbbf6248adc8164e2ae3bac98ba35393e41b725bec2884ec5cd05e6216c37c03644dc3d687fd0dec587095fd938c330e4a6d5554a6d42b6cde1f4de0d40bf1fef106dc9c98f5dbbaa4d620ddf511fbc4c3aaf47b61aefe3fceb484c47df96591aa602c0e3695dba57dc90ab0db9c7bc8da49c0396eddb79dfaf75a54e22264cd47a6bf51d7bf251af1be14080294f609eb5655f4a7f06284ae0f2be01e39fe7bde14d25cccf721507c3abdaa2b94d3e971df55fd94c4006bf84e6b8cf6f00d9338defb868d0e88c17686ddfebb3755bdbefc033ec1f1e9d9e6e4d85470c8ae0e3fa22be79e04a8732375a6c5da42497cace88e0f86ddc7c0c5b9cfa77d99eeb699358350ef5f234df122d607910dfbca3b63e51a39d9c69443c17841233f50fe8d94421ed816a9517527831082d6aab8b0041b80461c0ba219abe40f8da95b5245637b41922986acc898e3b10f7ade90b1f90055798891d1131fa8114e06a60c5454d4e0f08eba89534ea67bc214bfcd39bf74b8ea146d8039b11fac33b812ff6624539f81112a09cb9de19dbd2eda6ddb0dbd6ff86a89473bf965cc9f0ed6573fd72cbd77bf0c69913f25a6695104645345ed0e0b14a96a7ae4df870d8425463aa7346c074d371a04375e81189f424bfc3d0cd1744e3130b52855bda8bbd82975989350f5bd44e729dc63b2247faf64a0d6ff098d0f94e6b69a4598d24d355f066ff245e8ffc9f3f7eda516d02d678420cef6c12877acac6dcbff5daa2d707840f89be4d93845c956ffacd4c671ebdf16da3a32d883378baba92cd652ad1b06a8a667b3fe64b381a83efb537bbec3fe8a2821240bacf7544d7e29a7dff4cdb8aecd319cbdf6c6820c1861c9a5dff30caf390610530789acfc8faeaf837e8d7a8ba3b3a97b8b6d6d43203898250ac388cb93348b4733a6cbe8617b8ffb85f0f13a4dd4d55d8ba5c0530c7e8af9fdd6fbba7c513d7afef00485284226b06dbf7cc0e541e51b3065710d4c79845bc802438cc8a781529d6b230cdc0e38676907628eb5cceec351f76b309068f39cc2133b8b46cd942b2a9f6757c277a3ad7185262343ecc133ac60498de854484d93aba88b556845d9225fc5f65f6c541ef35e9edfc0b10ee8a9abb5d394e35d1620aa162e0b5bffeefed5322f751de20abe8477d30918993a47e603e4791cde90a29a93eb9add5cdbb4ad4b05626c72229c32dfa8ff3a7779d9c5e5ec3558bf4f66e988773cfbd76c2bd44d195eb535cc66d4baba98e1111b7e282a8fa45bf884cf1a2229770a8a3f5d8100bfcb7b3c4f0655a7f63930f03afcacd453c59291d11eb9c20a514526737bafc0e06e5aceaf03751fa4c0ec6ebd70df0dc668d68c20de5a18a76a0e012a4b5714eef0391114179d7c3c5064a93f3a95bd37a6312f9822b56f088cf40f6811c48a71ac653845f49367f6175125696440ec13123fe5f01e239d58e9ac60c6bd1be93d11a3f12fef9279d6130d6e7d032cbc39a8676275053e4683e0b0f30e08a7bbcd34091e275d8394d505c72b0b0be193203078395aec8e259bb21867cfa51c7091de0fb90d5b1ffb303a06c4ae0df33431e2e989c87b7a4a6e3dfa863debff3bb1e9626f190337772ecd3cbc6eced82f34d724e82362f83d2843f2276a1ef543e5238f6b62a6e60a7635d3a7e81819b10d2e09400265d27d446ec7882afaace4de9116fd9ffa051dd811b0f608088fca8f9790350388a28f2f32e096fc3e79a28a815b750d64bf5ebce6d0b4117a990251f28b23203d24df3e0c6026a014dc5c7b901ca2244ba35fb410eb6e199579e28cb669b6a802d8eb1fcb1c536668319c336661d3a48449a1d9f6f9a13bf3c6a25b4bdba427e8e36676efe315415a6a20bba63e83fda4e98682abd95832f5ad99397d319426f8ca200cb097c3b187645dcd31bdbae4bb87cf8f79c629e7d204d8a7a683215c7b1e5afce3b17abae93ab7ebfe7d95474031716b5ebc57ec5430bf2bc1699cfe3e5a25de5128f2f701eacb802a4ae84b0aa6caaf480bcd334bf88a72e7f88fe02f3c7453753038101035b93ff5ee23aed42435ddb0eebb2551785978b4c0899fa484a6b1bb922d760153c8bf233b204aab1179baf5ae501afb8b91798e621a6922a94db04f1be672e437f607c7ab767741a6c1816b5a71636729628819933512efcfbf9d43dfce23340941acd98dacece4b97e4430cd6243cd2e88067880b650defd319d2d3681c584842c843e42ea7cf508f8f7b43a1b28e35777e95adca0dbf990d8991f42caf69fe36ed7ed3dc9e50044ebbbc3cb9d1c5ded10e58fe9969aceff8151181e640d78cf7dc45a5d35f73cd29ec7efbc7ed9786f31494a1c4e8e96ff3408c77995b99c0c1d4be69b425a761f11dcfeea2a8cbff3c967df6588e04d2a663643170b8f13c82228ef40cdc61c0eaeacc3eeace58099ce1388d0b3748cf3035b0d567a151b0e42b7d3c98129bb59bd1831fc1be7977845d16e2224c310c12f036189e4d81f043ec84d4f9af7d106d90c26c0e2ce085f14160ba9766bf64af0317e17e3b5065e3944ea1e16ed5aaa6fafbfe907f9b595bc3099c3dcb6659f6002aadb460bcb7a47640d687d955462c6300e21b6ee43fe4ee93184e9f781aaeb1cc0790ae0f4f480fda85ee9139deae6588700ce08236f69d8ec5f39695ea5389a8107784f168be05cf6abb919a092a593c75eb8e08b2ed80843044da2ee2c2afe075eee5e269dad3f7e7ae3a1f0cc11e29831e03008cb8c010bbb6ee6edf2f35e06a028c7371d2d9572b43945857b620873d4784ab1c1c43f660184e8c72ed64145e4b7c0a887a3e7106f662fa9d4ed737e4eb4715e5564c9fad7f58136c5c1635c8993d21806e5a53251f0c94b42dccd0490ff02d78aa277caf0db57363bad2e7c6c983bb4d78626b293a00344d647c3b2fe121b7a8647cc24f4457c1ef96bc26afe898bcf8e3fb836be03920be759942f2301b2c55d5c2504e9aca2fa4bba853e662285a4715f9babe20269aa8418325bcdf70b6cd285e748fa299fb4ce51507c988180f9b1adac256cfad2d4156554f34656f9ce2384db15cf24e3a9c77a48713a208e801817fb52be076a15328539da64619ed87cb7895c9953ce6eb36a3126cfc80eaf212646a345a958d28b0cebb16abd4b0ddcc1f7379f3cfd0ab0b7761b9c7abe87f2a05b790571db0cbba99413f4fe0a65377a84e0e72d8f62e27715da6f633dac9e815d9998da2158adbf022f00c34e525b24728060221dbf8e5940eb5b3e82198e00b73fe0e9b96df87ec9d2073cfaf2b5a751a96af861706c942b5fd4a0f13f174b736af90fd54d1bfc168b273d906e7258aed06048ad55ea7e884e5186058290684cbde6f49b85fbefc02e03af0dd905f797ed73fc273e438c42016da21340a3a6ae211db140459aa54b2e8354e55e8799360a847ef5cfb8445a1422940677f6887346f7210656b913257d593658aad7d097d2d0907d42a0f2e1a2aebc0db94afdc34830cb8b1632ad531d824aeaafaa38174cce0fcda1a766f7183080251a25edaf3ce130ca2d1c325d95ddc7fe800abb57a7d8d3a6847aeb74156e53c5b60ac30ec669d195336792b83b49c5652edd54f352d644a1434df438e618957d1560fcb7bc052193992390c09f48adc01a6a2b81a05b4bae6f27b4e1722494e2ea71c044ce674ea3cf6ece282e5a89e0dbb4f63399afe8a9cdf60107324d18f5c65e565a67067d29323b862aba9647ba0b090a3db7f64cbb7927bfbdd6aff3956bd037ff5eedd4ce157e54fd835dfee6c3e0e292d899ddf41a4f9d32c57162cc0aea72b1d1ba8fc47d964fcc86c1e6264de337365e299b895b1e97ea38383a58e5068d58621f672a3b1a51c8ba9d37330164bb8d1315984e1e0f751d0959049a66cce8318b4e51672776d8181131145d07123d59b3220169787cb1ccb4d08feaa304f136c8347b4018307e1e9eb5a4699c3a891c51d6a3325671d17d1e9f27dea032cb898e296861e9184f3c1466fb21efe269e6cb1b9ff17d3629204f13b8311c73f458f1a48ea7173e553c17e4d7a592dac9f4c7fd46ccecbbf1d1252820b30e106239a55493b00a28b43d79019f5118fa522a091275cd9375789c3cd69fcf030dfa660e193d2311e548187fd5a344fe28a4e334e3c21b237b9bb8531851806588b4aa518a912cbbb34ce0667f502ba1a972a261fd198863f6db0b54c43f1c36397e4f7b43902c6c7c91dfa82a17e79bf9e67b00de80783b499bc3c14f16986f2b07483763d2c4b048c1bbf8da993fb3843648469ea2863acbcd990c658830a8b1226ccbdcfb1f026f0f092243318e8a3e354522d4627d43fc37e58175132484d02bdef49a3c3d43fb00ee0a29c818b68af9cf8b012a12211976d7442fbd2c53cd681c37a8798146fb64e1f02c8255a0938e39caaf3fb381ad49a3d8e97a0fe82cb43e2edc03ca31547d1c425ef8de9e61f9a65bf7d836bfb9afe501a8259a935bcd8ce1feaf9a3a7cfaed558651df56a80eef8a38bd2b938c4661b34f9b6da4dbf9b4e1d9edb1066290d0e78bb118110baf5436750a4eb968026302df9af5a56e8323d466c18a05a536eea76d8f60dc32bf922f439b38196a13c31c694d69b3a789d954a6ae915fdcba0f287b8ca6daa2e3eab1f0ec6839e195e23059356e234d00f95990b56f5ee6693e114340130c49358b70326561462b223468263a33ea011d6b115a028c796c9485cdbdfbbd32a427ce8a7e73369e837c35c010982cbe4daeaeb4d58f8b389609680c56d0d1370c8284397e8472bba77276ed0b5457b82fc45469ac4682cef8fe6b54cc2f55b6614192d9a39eb0342c5ffcf6428194d87e8939cc563e790e58002624230e0702442c6a171fefb0a85284f5169f07a72425422db237b5ce1aa34d0cbb1eb02c443748a77cc10e79159c46ca9365f0d570c84778e472f2598a82eb901b4fbedc4075c8a29098af3ba7919219fd25f8680204b7aab69ff56e736119d71e339511aa2ee7a7a94e436ac0c651081f40d017f9eae5d896fa4a383dc1447505913f4ece75d1cf07c0b29ff7e278d66b6640ac8c0927313685576f5fc247094eefbe496ed54814842825b0baa6a413a193981675cc68eb214874db895ebb13c1ae52911cddb6576aa3f9d8cefaf8202dce0c454741ad2947e34b168ded33f90310c5d9f7c5155f3b6c74cdea6b2183f8a58434666daaaee0e4e991c9dc0b1a031ef38ae4e17c4db3e945586be9acde2ab419befa32624f45cbfe327024dd5907b60884c69ea81346a3578a4111f4bfd27127461f896b1904f374721fcde230d0163a70cabd1b74538a008edeeed5f33f04daa49a47f02a0cbac4053f08d1291f5ad4cba36aa1dab2f98c2fabe98b159c1c7de4faeb7ab958286324097f6847a9b3f0df71ce7ddd497e6158b5da3ad8d8236d93d5706404dbde2aba3c23c03b0e418fad53dfc1926cf9ced2b3ad669fe812b46d991e9a8a044d44a723dcd23dabe2b82c51e4822096d0bb44779f96c4b9dc5248699adf4ef1911432929a5b777b41bfed93488b14d15582afa63583f57b4a1e7abd8b29518b3fc099401e35f080785bef581a74a0b8bbff8e7f0b6c5ee1ebaf20488efc26ff25f015dcbc2b8afc9a1ad93b3cb2b34f0725033dd6ed774347d705d6d72acd1b7fa618bbb03ee460531e0b428aa50e3254ee166216065e885c7fe81074c9e62c027dead4960f20b008002e09a35e66eef6cfa6a7989d7b86381b7205e05b4e6ccdfe2a7ae24a619b93c68e155be0e0ddbc6ca0c8eccabe7ba7e6b6b5fff5329cde92e88dc0ca1ca60fe48aff6fa146acb94df61fb951679d6a262e0415a359a6f06bea26d2d8128560e2aa59e9a0329660b4fdda1d8b537fc34c2af3fc62e1b9284ee2daca8a7ac9f813182855b25ca9e4a3c3be37b1f5d8b6a8e3dce06736396f132f488a9f3c513e76ea74bba5ca6e7ee0005548ca8b1f84b5e823f9e97396c27075caadb16133cbf66e952561a9819e51e3b9d2d4d84c6a345a1f85c51c879419b9323fbd8315bbbfd59c6a69d896f42630c47e3f8e082f34e859b26e5bbf5080700bc716f941237579ddd7308b5edcc569ec99f77c45dbaecfa4b1cf8229cbb2813cc9fcb1baec49389de38b26bf3671e6c98e3d93aa4d840b6be41fe2d9ac93051caf777ea72704f82f9f4a1aa5d64c55e76138cd14fd12358ef40ef724b4db7509b895ba55a1081b9c69138f76ffcf13462b4a1c4d1cec0f34be051098faf8b9fc19613bf1c09bcd54ca6cdcef5f2af933e947471001c740c0164dcfce5cb107a776a2e29681cb1969418c332dc33a085faaa0bacfae74994948bb51671c8569658e74adbad9bc6993caf65e35df6a278779d29dd19c44f7d72bde466dce23c56bd6abedb495c02da860077cef100bee91c140eddc380ad15bb7329d9bfe92eee2de4de8892f3e73cfdd11b76b10e2e1c8ce74471a0301127c166dd24d473c9adbd3a92c3d4e9eff05465e229b88709b43e1c3b9afeb4016a2b364715e3cc94d6bc7bd5130ec00e1724b566d84e7cacfe52ce39379b88a5f30fde1ada547f8bfee19b9fffe001ea91af1c4801ff3b714d124a6d90af41cd03b253634c6adf95574e82299aabd51260a3c1133f55055ce74e6522dfe7e05bcf4c92a3c946b76269339e1e9b7a094475fa298a02f74d022730ea42eb9ae0f36bb12639bc064e1efc3fb5ca5e9eceff7e9286a37ef4d19b5874b9f4224224a49a889fba86f6f1b1cedccb7277d229904b178845279fc1a8220885a84f79d366e24cc9d8cdee0afac61a02bcf478fc713809a79768dace8a031279c551f400f3c927396b5104dd827122de4a9acf8c2691fab20e43c5285d4c3d727a09f39cd451491d4deb867c77d691accff970d9126384fa1cb5267e4ef750f00ec5be53dff7641a0d60979e0a5c65ec1bae6fbd1cd426ef63b765211732516c2d506bb1f81c977bdf4b53d67c0ed4fe07c9554117821f5c40f8b2af40166e41e9156898a07f3687e6695f02fcd07ac8052777d884ae7c00a30928442bf943bc3866297ed54c2d5a96bb89e013ccd00d6d53b567569cd51132b55c219d41e012a9a4924b82867e699d3846128fe5f6961248b75b79ee99d1ea452ce59aa09e1248c18534295b64c4402dfbd7dbaf3caa58d1c160c5d2948aec41705be0b310a7a1cffae44b853239db7e7dd418c99b495638fcac3ecf5e2520fc8b27599602d2ba0e50d0c5a624d2e0fbc3ce8a0591df8cc56701011be29a4f7316a78d282bca412635af67bf5a7401e29cb688eb381f8cf4182643d98e051c28cbc24735ffdad9a6b2e1f2c96ae0a33454b0071196dbe468d12f06d2e75714a2dcff4f523e00b6f770688b5886d885af088bb2b3ef3874d1e3e61ee00d3d4a6a9d1d862cd4ccbdd90bf19876b47cea6391833d44ab816d0c674896199feeb2a2bfa8eac39cc5ed2130e8d484a02afb5ab46f877cec94577667dbf9d12e02feac1cf491d25f095f4269a9c86ce9fd7bebeb78005cd831b7574fe1f3bf9e3452b1bb6c57b874eb017a3517e5443c54ee2aea636c51d966851e5d421543e243201c54326342e295447c30ec2ffcc79b2b606ce84578e19e5104331610d150eb2fdef3272bcefdf600ca55d2ea0dc3661ad64d67cd63c5f23c0f44e2f372e4f897eb959b33ef00bec5aa7ceb51df8599cb12038b1f862a3cf9e4aaa21e56797d2f574a437965220256d4751f346ae814bf3e335f781f1180eaa97b7b3ded9b311601dc9b4168e6c78a32952cc8e72b943e098f0949c5f509230c6e2cf06912dc3e757f14faa8fcadb616390d989accc0866bb17e24d680808635ccaf74fd434cfa69eb0145f0dee1f061bcd766c175639159290dfc8fb5d62c4e120db8494bb5f91b3b36ecdb9ee41e04afefda0dc439a7b696595ccab250a09d9582470f1513da179d9e5428760c64d092739a39d64ba50eeed20ede82c5df1b62e91f349a6fd14958e025bccad352713923f635e4c2fe451f6d93979c552d2689225c2b1b8aa0be55d13f62be420757354052536ccb45029025b07f15e6c4c44ef7df282ff266be367bd97f95161b38b2c1bf642c2503cc7d385373cdf71cd3cf9289e8abe64512e2f01fac84dc8d33a2db36ff2b3ad0df0c179f0e252a952c66f82935bd29e8f0def79266e26c852025968e88ea2dcaa2de5710000be066713da5f98d23174d838c4a5e11fe31c100076a6d39fe9567b2fb7a02fe32c4235498985d3d830d0d808eecd56c0c17a72846d5c96635d8ebea86866192deb86e233d77cbea2d6ccdb2ca09757f46999e0ed1458d1801d7671759a363643e22e761d8a28a074a5054503bf0e2654fedefd8a60cb4c01e86c1e095688ffb1387022eb8137652dbaa159a0515b8c649318fd20206becbed35a36c95b2c723c7eb23b88193bd105abad9f5188cbc4d5e83bb839de75fef4f1f20c32f028e56144519761509aee455e7ede360e62b473d6084135553a0955183e7fc4c19ebd36b9e30ec8512ec221f658824e5f73b9a59b265bcc7d092617145f43741b686ff4e29014d112203cce342be834fb1be7f51ee1cce2dcb7f22a618d85fa0334f27799caf9087e151d135ec62e4b3440d8eedd75177d9d0ea4fbfe37fa8d955507526a39ab090e23e2cde8f1906e6e72e5afd6c546149def40f0327a535c618b84b6e39f64f8d245d2b54f33f6015c246a0d19cf2a5f5acfb8218ccc82006009341f96c763f3b8c3abb04bfe75de40123962d66a4339bd55acebaaf91454441f4b11100ea449c694a51c0875e795b2ccdd68323eca1b4a8449324a60b73efc089a33fcdab5057296b51223996660d337522e57da66c39e46b2e52c51147b12b6c080f729fc21b7b471fcd108d4fb4ca9cb2690c00de5a7d99ffd455e2296ca4ce74302c9362075fa38d6ae69e03c17d832f191b16b393886ce8a1c814ac9c451e9688aa854a57fb5b0fe752d7636bf0cce4c053b9b301d4a30bc3a6823974f68e1e9fbaa196aa2ff9ec7710a36624825fdd4eb07c3fe56a6d219ea9bfb3a36286081bb8c9c49309a4befd16656b06252512f2b5b0fff3f1c9fa02e8d560ff8c95bc12167761bf54f2acc4335e0b50f80936afd40e976971ff12438e573dbaec3721782bbb5b955399303368d2bcb007b2b1038280e2a94d411eff32456d366c7c3af66a8358612bc313597ca01c1936b87c2857344b06d4e8e59dca2b3135bff12db073ed8bafa61f1bb93d6a0d3455f7fd02b348c09a4139b1d6369bee8697b11a64910608472465b597ad81f0cdca9d985c338939df81b64b898575d09b2b7f3256d0015261607ae66b39dd34ccdfd255bf3106350587f467da467c6564e4a999668bd39b651cd50c1cf062109fd2ee82c17a431f3bb4823b9b7a8ff194726d3add31637b76ffceb2b226b5614eed628a7593097d4f9246ae810804b5906e54eede9f4685f03a2b241d114ab814e3fb726e7a2ec6f0271037f28e2e2295b5294a4a9008dbce698ad74e23a202593b2824a9cedd438ad83b0bb80a6a8a401982e0916c4373a7fee3cf2462d0a7f4137463d87db98f536529d48fb5338064938fd366b1923467bd9b2737dd5cc2627f790d6e16897300abf03080f947c9a452278f5750fff6da783dc6a746790a4d7f978d25167cc47325e0341df0ae79d1f2a20f4fa42d314db055d3e1247334c9f7ec554d8e22ebc80f6dc7de7eb1e462fefa5568ab3fe83c9c67b74410ed52df193abcb8e61944f6353f67dd990165b5a5a86d5b8ed6d71fddabb9950bd46c76e01858b9a73700abdf62662b0829f93149a14a96f90bd36086f292dce76ecce6e5becf2bcd358032863ec870b5230d8deb53c40fced77491725b0712d01cbdb2d8a0b1c75b20395b269325cc0aa7a4d7a2380ec29772468e1dcf294fbd36b9399d23fee079e2dd0bd7c56376069ae05a643bef4327cded61a36b7c0bb4312be5c9c8b753d88da5ff0513cf2e134fac47ba7e31c66fab8dc82250bcf2341b92905c95be8bc82018e1beb1c38d67d85ab9796b3d443085e0a8c12c94cde4c123c7089efb1271810e970f9e1eca943c7697ad2300388a5889cb0ec4540b08171b61d8e0bc008eb74e5bcf230a8c2ea62dc7c8bbf5d432907169f802a40f3fa68090ae541567d46eec095a506e3e41822ec1aac2e378b37da16f6f0c9fe0c37eaa44a46d967916f43c43083ec1de395d9dcbb91d3f1df435b40741dc1ee00d5e7d6ac63bd4a9b08755995330bacb656de74d1e7892ab7adfed16e2782b471673678a79781f53e71a07ac58d8f788e6cf46286d2d7b181f7cf088e7d66b6918236951b63636bcf249c9af5f4f070e84ded30b05da7936cd036fd46e0bb2fecaa6e6d8499a48d0c564ef024a27705f63a17b5ad3277617f50a27bec900980f801c3dab30ae017a62da64462d6cd498957c3c7651999defe91f2132b44a84ca86d19ee428af55ecb9f81bc6ebfa4523453b0870483ad94aea51969cdd8991112858e46d62528df77284fd31a2ecfc25e74dbfffde2da99f29fc79e9661926cd52d64a6a8717aee9abffd659fb455c891910d2ae86799c69a9aed0a6c169ab12e668d055d316e5254cdf671db07899553dc8ad17dd228d622abc7519a508012f67616254a626ad0cd01f0108ca39e5eb60550c89ef06a84ee182a544a88f390148bb9fee023013b29de0566e05d2724a3bf85c30d30d863eb4d3e6ed70efb33b964c64610d58477105e328c5ad6b0ce2364028a666abf1d5aa95f69455a1198896d0ff399ffd6014597c9078207c2319203b91a08cb3cc9d3faadf30dfb3127569fb6edb7eeae83a9f10ae88247d5c843355ac7119db495037af909abd7416617a10cdebcc276ae8b31c40d45dfdd11be2bf948b1ef02e71aadeba646fba6e24cc9928aba13932e0b1855d8a452338b9f85afe168035c1b210274f79bb8293bafc17f89ec856d259178c47e0e942d5e669bd084c2b2994ab048a0f02c9ccdcbb4fa1efcf25503e25d5f014e2bf3cb2530b926d7d006551a46a67f7bc7414b1e45d8975f23e6767d3875bed2740f4faae567564874b1532b1ac38b9de7299b9635bc167b1f0bacfa28e903b04689ea96ee9e2da38e1c3557293e6722c28723effda58fa53d740fe9ca7b8ab52dcf8d5c57997c59ab708ad1dbee4ffc8f8a0f854bf1c3037ed2d6cdc03b0c7dd61289a457a5692b2250c6cd8bd931e79a4c83c5af3ddd685be47659d8c76b891ce5b10ff1b4bbc7c3ad43cf281e82ef66b60f3e5e648f8f3f5abf1d3c4818c0008e5711e7bc85302fd20b61c7870d78584e3c1abf711176fe39cf9e09d84cbe008298d957653029e840aa57ce9b80ea1eb666459aceb2da59c0a51887bf98cb7a996bb396d3ce1421688de20da622cb4f0100a54608fb46391b485789fb38eff6d81cb4e77c8f407fcf94fabf04dbcc68121de338a4bee48e970d844a072f27af5d0d511ee1beaff53edecfe29cfd269d1fa1fca840c90dc17a7ea846d2475155e544c821c730de1600707af456dd90f3a724c4dd6716838cf71e4b8715e7ab6218c1581a0ffd630176c7e216470555bbc26ef4fcea2b953d995fe3b9802f9053faf416fb8a050c7b73363f7c361d147a3ae7144e29f50b5d3620a22cb852cfae18d19a22011c254f26992e6035c90c725efd1f63478e270a5dfe5411e7d605ae8c44954c5874811ea2217ec5e8e9a3121a1ef34b04b2bb639c234da938e562d1c3cdb92e194d14d7d9f7834b80f9b7ed6d51bd81265fda396290b57f8173056755db2167d91daa75c7be44453517094d5c5b7b3b40b7a0b541c30cbdb3e00219325a554c3573e5ad452811942964ac288777f56c85dce3d83a8ac618b7ca1ae3a1253c4c2e2bec72818e153bdaa99d500833f883e8e296c26bc988c2615fffdc67c72c59566da06bb264c13320ce10de9d656ec27ff9fc62a61711be518a15e079d44a8b920e63a959afdddba71136f07eedaf1da45efe080782e6c308116f48360183cd05514c7d70ffbacea0860c4394061193c64348cecfab7009d8c7e1b562e53d5392e0fafc5a45457ba3c19c034f4acc7a8024ce1a25821205e0a90f71e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
