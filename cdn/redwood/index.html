<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e090147c02eda27792e7180425103441d9c821ad68e3968ae8dd71d5fc2e53bd3fb3cd47945409149b88eca1361b7762f60e6e756e91243f75388e96bb34b93f2ae61351757f4651d0955154502366f0c59a3dcda7d4a043dc2aa1ab2478c6da45d75cc27ea79bf984d3539cd3698cb9b2d5a7c943cedc0422f3a6734ad55f274ee2cf22ed8c11ed56b508483653e0e03f9d69eeb4a35972990d5ef2226e1d97676d70b34af7ba359150e0cecefcabdb67dc8cc77d40ee301146e9e53cd344fdbac81a65236ec2bb5399dc34cd1a1c3482b02bdd75242eef2cc403a204eb6f3110e59f2a98472a407581f4277fc577e9fd245622910a98e9dfdfc4445c5dee9ae4ca37c04f7fd87542b5208d943b3b60dccbf41eef2cb8973cafb007dfb0f3d60ae7f499d30ca0321b99e53c341a56dacf6b442556535fd2b472ec37cf81a1551ef43373cbaf80fb498adaf61d1210a8f59214c3a11eee1cfd2c42d815f6e307d92c19eb6d9382e1f6a4a264827f0f28e3ce877181fa549f6c221230954240508da666d83345471f70ae5505598c4798ca6622b341847d4d860b1a94e842daf76d36cbc7f4c4d8fdcd40a087600ea4a5ac3ad3bf38b6a610c65a48d8f3e5f28be71e78de56b2d2675d257aa1083991cb65d0d36b35fcad4e32365c287d9273daa7114b6fe116146c56bb7d3c9f9f5d3f8a5929f946d07924d1998dcbba56572982e5b3353aa412f91ca917601a3a8243514c90b8ec719a23b2c6fbc6d16e2ddee4a9d029be8e0057792a9350265dfee5033c9d78a6ecd4c99f275f2267a76ce6fd116ba3a8ef13ec86cdf55d5afadcf9bde6383096e5d6d68b755f7b6dd64474349260498e37bcc50260e7dda72164478e24b45b05514e174fdd129a93c2f49b16cc69d505df8ac9ed76a4cad418044a82177e9ff9159ee8fc1569375405e37e847b7280f08b4cf3bc11cb862e5973f31cab0c64229dfa598ef5c2842673d3f8def747c5cc6fbb4a9771271fd69f3d13200fa64bd6d959c12c4b11aa61dd5e5be72d763a533f6cd13e467f86fa4b8ec29a1576aa0e4cac77d89f4efe1ea89fa68e1cddcb7c715d32ca82bafee0f9a0a87550a28dcbdabc3564d07d740fb8ca602a016539628bccc7926769f6bab90e472613bdcfc9f4b6fe7c5f3c5d8d7c34da069ee549fce2bb93dc34ca8dbcc33dbd47b82fefd1ff9eae442cf957ead5b6c4b201e443f169af657a194c563b007574161439caeeb6c3feb15f035baeff4f23e4dd7aedab17eb2647872925b63b28e9af3a35c975155d6327fd6f6242061a379b99940bc907f423739479da8ac5a0b04653cd46ec528bb57a99b1b75ba1892bd123bf3cf32ccb11b86d8bbbcba461724a82ef21492bffe2bcc2f2b5fda892ecaf1bf6bd2d1fa8985d2f314d4d0f27b1caa4079257888b93e7de1001cdb7e8effc0c4309fac522afca9fcc0b0725767d9666221ba950ebc155071a823f408e7dedfc8bd6fa81c5c1123fe28cf207c0e6a55258b46a68c0e3e1123432126cbdf5fc445ae1b6b4994970a854676adaa9c703a2eb2c2e58dc0bde1898e517939818cd18c85f296f5b16155a3490047ba42624b1d7d6f2126a9e15e26fc5f8d04fe734fc7b6f9065b98861544226113c77b5d6809df7a0987b2a460dc6ce111e6f89e7a4f56ba26967a6dbcdc1c277d8c69e5023140052647b0452dfa60374c62365390a2aa67ac68dd0266026372379f4fc1fcd64c657af44648b9fe1dd82a8e92ace31e788526ddc9b6b2cdb2cce26f4cb3135aa4b7ec8ab41018b15894a43c57421f9cb513723e8d0a9f5f560cc97ecb292beee47821635bedac6e3e3fb12feca256a04fd32bb641b1d77c17df80151f56e3ca97f2115e7bba610df5285b516c290537e9a4cd24c9ad79aff5c77b54ffbf9785784aa75670ed875ef96c705b303c4ea836155a54ad20c569fcee4ed1c1229ba870518da78a69be09679eb111b867c8641233cd77f5d2bdf103de78e4c91d50795e33c587e24b7bb9e58e123c3f973c02e9b523914563264a9550f75ad6e624689cde184d0722540a8b96b3a7b8753b1f58737cf1edbe357f3b292ca19f80798eb9b2b36f8d1401285ae2b8dd707da9cbf5f8682e47b5b5d24028a8467d5cde3ae1958801f5378d904663fa80d94f53bfc17dc655b5e5961bf0f345ef6a7ea2979b3693e8c3ebc25410bdc479e60c9f85cc268b32232ce4a505ee5a84b5c321a723b2ab1b9a54dcf5569ea38d88e4d8b256ae4a31e1f0e49f1b9b9f9ce7e9779f064966571da81dad6f6840be8e17222f8641cedd9c116e97cbca78e5b6ca761c11c1706a26bc5d572bdfbd65d6c44887d1ba7bb7e4a71ef8cb15fc990b44fa6543ce8c715ed28c76f3969b193bb4832832e354297c103843094e50f988853f3e9df5ea47188dbd673423027261bec4a3fcfd8727614783057cf1ad05601b983abd0266ff3ec67e43af2f9799f05dddaf172729635cb9eeb84a4165124249ab9d4348eec5f89cce4e04dad32a8a3f59c595128166ee35b47af1521818b202d234b6c183871238f6f4db94a603618fae734e47941b2b928dbbedc0b0bc0937111250dafd7e2a4dedbd8494c3f1b48cd713ea47bcb8d69423d82ae172df1ec702fc13d067ab340342c1cfa9b32498e4d3a1bba4e8e09ed69213c7cb551f8d90786fba788133083b6fe45af94f12fcd5aa909ed3bd41c802b31506dc9b3239907fe21aacb445549fcfe01ee3be081d7363fb1ff4da89cecd15ee74fd0df59a296815fcac33358248200724906c8717fdfc4d3fcac6d5b06d0913e7acc2f45a6a378f96e429d2afb779aa6f2cc5ec0a37849178b3e1ec2e3d9cee8951c740544001d40dfd18c0a46a4750f60cf7e65c3442fc7808b5d9b49051bfe08edf2215a3ad249e967ccacd6d0f0161ea22292a9bbad85b1597b90c8c917373ffff801d24f36ff9467f57394fe4a7a9062e3e035aac41fade0a77e969aaebe57c54a2e7f3b7c360ce18630c99b1cb77c3cb4657e1feef34ea365897837043d50bce22068a7815c3f4b3ed0dad65c45c43f817f8b54ab6dbae55b02d251ff5f237061769dee204157eb2ab2d174d29f0f091cc37e7388808bf7ce623c16bb3898e419eb5173d36db3f768745bb351c83d6b17e95b5db5c57ef036f92c4315cf3873bf96b6e60794eabac6248e26abdc85f1bc8c9f3e29545fbdacdd54448aa9c097a84cfae2e8fdd0e92bd7b9b772929a22b7e8ac642466235077681aabae0060fabdd73a318bee667b9b2b51f916aa81367eed355f00e6aaed1a13bd1190eeaceb2332dd2f99f7edb857a1d70a402547bd41b058176516e4924f0837c0004118fc45691e5b73c75cb9f953cea20bc6834a2cd596325aa4c8dd5a15711dbd95bd4f609304e8e4a185d7a32c5d9d473145ed22f0adb3deadc42fd46b3f653dc99d98d63d72739ab2a4f226d0bf9eb6a231fc5e331d531d3a40f389a163997331a9e7e9ebc1197129a5fe374ff953d3002b87f95eca68fde0a1d26257094ec5bf095e28679803acd9eaa9bc8a1552e5ceca5f4a4a0dfb4f01326d75f34ae1d6356c1fac7c82f5e7e9e4550d537a348debfaa9d5027778a21e5aba60f26aa4e6d6784d42ef8fbd9cdc002ec4df26ca964586824b446b9fe4e1bde2fe55ab1912ebc7f01dbf868a75fbe2359624519f0ef0d540af1b3e1eea56485dbc177a3123b011dd9686a6a42671dda368eadc80735efca44189224f9624e9764d5c466ec7cfc355d04c4e2b042d601a0c758440371efc8bff0d00d86ddfa695625f975f263f6daae017a4aeea28bd23427d76d1443599764886398f12733b1a2e0e284f580222f9dd3b666a8a50d0d0797fa8cbd0b6598f1602f102e3f4fadece2dc714b13e1fb44e6249ad65b9cd307586b62466a69d484e82d2136303d93d9c8ee14695b057a4f7b6f1ce8f3fa62c8eab53a6252b85bd04252bbc5998918f00d556162f59c092fb12bd979d92324a9cd21214f5cb252384df07f22189ebe70636c0892c0ae7c74c5ff577bef03ac9f1e30b52fd7ef2734760e5b5fc11c925fa22bf7e9a16d07eff2c8ffa4475ca54bfed50d18ab4ac16154fcf34aa390cea2de988968397bd482544a7cc6e2e79bc82719e8bcd22b88cf9ab996908b131485851b24c0bd4cd0333f1e388579c054c88ed3361c3202446320299580bc23f7217fc7a45e3a36e1c1873cde1b4544239346f063af466ef646b738f23ed7a1551e19f502622c39d7d7a3d9d7cb943ec0a9b23bc14a86d9dbc146ca76902b74c37ec6cf4ed2e1111e113625962e5ed8a7dd2972893c58811e824b18efe8abc8990c308aed7a6d0378f1bf52f7cda6698520f1b39e4bea38953e1feb7f6c8e248bfd6d24447f02ae23b07eb0576268cd8505247d2c9eca1a0c45ecfae89985b3d3a20ca0ade2bad3ee95caa81ded6e99b9261e4525a53df9f48942a535355a9dfa5a04462d191bb26e5ff63087d93870355bfac8f6f2949fb50597828b2fbd9b98aafb812cda7e6b7ee9910a96716c79d3eb62caddefe297331831b2986aab590482a2629df7d99ca91522658bb19f0733f517806fd2156fe32eb546165302c73d7d7cf46df5bcafff027d8ed99a290a532be78c155e87634a5163a447d573b0eb5c996724581b41c87fe0c45574a4a84c52a5b8ea14579840b248360e523d005d2a8812cfd0125a6e727c4b0c715f1b559a701d30e2c564dfc53fb36e190b6388b85f5e2b518338d177b4cdfdc01e75dc6ddc85a8b29bb20d190f577468317fa3480b7a4a0bed469d5284aa5ab113deb919fc2cb00bda7414c234a9910d75c3cc798ee5cef7dbc4a29e12a54f0a90b70987e29bd864c7c01814393ad52739209d9159967f12e5e50ff6cbd13c71f0703ccb48ab084e63beed78077528377363fffc1b7a538107abd640ebca779a565852cc5e1bfbb0da1dd2436604434b78773ff1c37a20af841d66cdb6fee621b5ea0b101ba4644f08ed890d58dc043fac74a6c8b8341123d141e56939e397105517be290577794584b9ac8f9fabc6b6668dba8362b4f0761b0f5b0e8d1dcf6f1ac1e8d563aa800d980b23a3586cdf4192963c776b9d181adfd5ec5e6f3330530343d217e64abffa3fc5e23808f5fb4dde59cc1b98748b04fa4cbc550ae2952ae6d4ba4600cd3eb140bc589e2046cd49d4961dea3d90bbd9eeee93bba3dbdebcfa0f26fe046644f58588a090e1d0d4ccd60ef2fb115a0e74cb4cd6f436dcefca4bcd93028875106d5f737e2f1b86bc281683818a19e8144b69f31e26a537e8ea558831b170deecf6f9af9157646ad3353192432c09b1244a0385fd055431d794e756a890c1d548f3930ba1a803ed0d908b1ef09c4818a2b252f7b45204c27d5276b7e4e72b2b44fdf10ce4bf8c5a55089dc62b3eeaaeaf06365bceaad1370efa9c19376b7a6e56ac34b77dc773a70fc6243ae5b376c40158ed8ba64fb456d9f8dcd8348881b536c15d01a7ddf5e1354484404269967a1f9822047d7ba6775fde03799c42ccca06e3af8260c41d61a8f0d3fbe4e9b7c03e943c09267c50eac81d76c3270f9802a3a3dc5fa71b222e469b4dcbd47df2378e3ef1588b854d30da5c2e83542df80c9f394ab2a05159cef098a8d0d2b472e527a14a2a275543032ed39b2ee19769e44209e9c64d69afce288909fb7d9157675423c73c6728247afeb76a5148b6499250b02b0e65f8a23342c03c7f0d2ae85d6f514e11c4cc7601543fca51f821e6e39c044a48aa779b45f5dd8b151d4de1cd7a22d7a6b5821e945456e7d55ab77c5b5cc361ec543f36e235910378fe3014fae5ebdee6b2858714fe92c62ab15f4ab1711b9be8bdaaf7278530c6134d482daa0299ddc32438d7b980c0c916bf9a07296fbe7bde6077026ccfd4187cf7231fff2a675c1b8fd875ba82377885168c67c2277b8aab9cd1fdb498120d531e717ab27ea94b378a76a08e997a2ccc2426b1664f668e15b2397c301c32f9734e0182f2b8a0b76878720432f99f9d054e8416971b40201654cb3ef9853e0c278898ca3b5be86a728133184aa821f5420056775a82660587c1adbd595334d402712d9a07b93258470451f2d5a735a9cd43fbe9ee6640c8059844209352f47c4f7a1ed03c42f2e2050697b8da2bc88d09348e04303639f4ed56c3f38d187bf78e6000203671203f707cb57d40b263b7c4be18358a6ff1fbf74c692445d7c4029582d6b7b402888a1e85d79b19e3cb7eff2095bb4e05c2ff0d493be5fefe8436ff5f7b05213951d88137d3e492d2f8398b2509b5fa217dd31e16b5494d94bce491a85005e2a63e7b687cda23f9867ed078144d236248294cf59d7d207c81f541afafa0ddaac48a18446d9b91c1a89bee77cbbbc847d94aa0a8a203331382cc61e4e8026ba79f3fabae4e13f4c12926dd07cc65c5e0994b86a7dd2c911689a639c870a0e88b26e80740b126dd93962316e0ca68a5dfcbc346e7b970c7c6ecaaff72a4f85747b190b482d543b1cdeab0a2ac0bb0357b314a1648a6c066f606fab77b79126cd2d1f5872e393657e5d91be855dacd2a0f25090a60ac23b2b97f131da56ee36b779e530ec45b18ad9be6fc6af6573dc5065742da1eff1697ee5bcb91daf6443f40c6252f8117c18b69e2d8f0b9ccb2d0393b4250598d11e64d422cb594264f89b0c1cab76eb363f99781e298be1be69f68f1a525864d30e6621121e3260aa0dfba570dfd6becb60898cd1e841f0c8eae59b3c2e33d62abe2eebe80dd313245b3e8d550838fe0e67869837324069bd716822f8f8f3b4d57c07dfac0dddf8d6efa6414a3e187d573a7d4a6b014b381503c1ebf2275c6e4c3caadd01818f2b05dfd6a2247879591eb7a6661782d0330ed629086c9cc97dc4422cc8663323d52d0e8df4b55d414f93e9ee44c6238e932029e716929f5ed7bba2fb9b7d7c130d6ab9cebf73d99d919cf1facda5dc4601ff18c2b88443048e29af3314a3aeee765eb4032bf43728730932cc2f44b9a706dbe3dad2b26d9c1880dca2da5e2b79839c40ed9b19284eeebe7bc49e32fd198f3ff67c36eba7ab24ceae55e6d2516516d240b9b5f869aa4eb7391596cd50abefe5471d964e44ecd1766517a6fda466fd88dd01394d78a590f48a00a716708eb143d26edca8e181d09e6214733f89198cdb70efacd64b69cc7938a274be560b1ee3635a269e53adbc69a2080c1cf732758650c8cb9c5ad577c9caeeaa910d3b4a926a4ed9aacb4deade886741f787b06d31791edc3f389d59f91f56926f902dd5d35d6217d0e570973d4cfe0bd1ea23bf55cc03f125d84e1bfce37d57db2527a5b41136843e2ef76eac3b6db47cb78c7edf0f0e91877df0f031034a996c85334f90d178cb857a9907b881ccbd7eaf0c928aaa4eb9a9cf5a5dedd41592813b3cd7c4f4c48f30174f803546616ea7393ade3980af5d35336bde58fe25724819f0eff43a0c1b78ce82627c4bf75976fa7612ec9559465ac621e09539684747cdf04d5d1ce2b4e475c2d6203ae10f0764be858a398a253f5211cfdcf2d3293605f3cce13aa635438f6da0fb21f723e361cfcccd137d0b420088c2a040d8d39316be9f165862b7f314ff4726f204ab92b1f6c00318da30e2f426ea5cd5dbef9be2c75ff1858645ce084efcc5279a949274c2ae0993e209b654095ad7fbeddee8a327cb2fa82d2c8df414c006ea4519ca209b278815e538c10ef6b1ae0a4daada871d3e1fab29a9fb66ff2b3c2a66d6d95cf1f36502144ab05bddac2aa087e34a0b008c7ab0b4086500005b1e5d72853c73c857975f986537d83de49241c8d883ba1747c7f03213eda5acca5588dc827b265c17a8284164be0452f36ef7daea35f0c56ee4f0e0f793abee02f57bdc27168d80cf5190f06dad859a026b7b6fb067bafb5d7238b2ad1f2c4715c29b21aa2e5a0fd74c46ad6bd4c6dfe33894c3207bd528c88e81df671a1e92e733bc8227fcf89bb4f7589e9c418a0f49450eaf4192f4668644084f34d4b4c97eb14700b02f299ccf90c2538bb225d7bac84b6a3fe49f2a54b498fe26beb815b22aa8a35e4fe01d661951e76bed3625c7b89fbfdd277b59576f73936637f289b903266bd12544b587162657715954918ccffd385f16e4c5a534313fd72ce1678ea495f1480749fdc533b26d30e6ad9cebc48779ad46148489b8ae50dbb5eade8cc882a4d3c8d3d0fd6d5165cb83c72a366003c6d310de13df616d600ce4ab5b81fff468a62b46d57c7b9a4a1bfb1b211008c5b7f8b2b636b1345f223d9449b12cbc092a70e866a060d3ad9553df0a5442bc593254ca992701e04d2223059b242ff3b2c7cec46908ae2150c6f54dd7dd6ff5518da0739c4e69bc3dc8a213605142ef4c6a5492cb1b027c77b51ce91200791737585cb030ca3f443d369e735326b2c07db4d0cc483d24cf5aa9b95ab9ab0479ade8724f224bd98f258a1568c5f3ab52d0104d87d327203fdf12e2f67f88f2e0abad41a78b5e6aa903eb8b0be52f3df0fc7d55216bddef3c97f816045f84be5d81d8c96151bce36d5e1872dab8f2f6e4f0b90c62c0bf2b65dd704d3c116e8813dee4f5a22b437a1c4049cac588ae1f7810e81ca2fc5ab14bfc886373152dca23f95ca129a87e0afdcaf34b1d5c1eacbb480843ac4f5b8057487851420a316765543059563c9159ff5ca1450feac6ba719f28b9d6b9a7a25496660574adc95925e40a0fd2e65e5ce38b8e9f57cd0ace2cf5a754c8ebea176ea6d0c0af7e78ec2e790016c6c921bec95e7f0c460f4e21e5e2edb5802b7d754dfd9f4feb5d9cc92ca470c4bc34932a6f312d742bcb7cdb9734af72ce06d924e73de52881a1ee2114635bb0ef6cbc5255cd8c9b815c360f5bd453d37c05da14c3e7bde740bc3708dbafb376e249d9550b42955c450108c7922b42c05e73fbf53074decd96d143cdf97e46bd5fab2fa2a02e208e9d86ddf2bf54909d1fcfd958121c0910eefa685056bba7d6dd470450e0b57869ad1fa71a021dac794e91f7971a2325de1870289fa0fa74e702fb80cabea68fb5abc31b81624261b468b5d7b711743092e721ed34eba02f760394d694e2ed0584c7945c9fce9b2adc88142c12f42f9b9dd320ce219ebd988003e5cbfc65b942d8186cd521dacfcb38528de8aeb94b2c62f1050b5d496c0a10adb1823a8c37a1ca8781d13343d12de07dc771a09473328a264a3e86d15d6978f0305594572b3f24a9cb19fb74cccc72c66d5ff7c1d39c0b53bdd26b64a9a1f44027422a08fb081ce3081f0ff30c875f95f7e1742175ed66d1f7bdc863c14e4fc88d014e78c876af60d0ac3c5bb512fe6221a1518f219631e15df1585f39df54974a399626ece02057478fd0fc710e31e8d7bfa14cda3f94e3532895c85ea1554c7f191842f2bc12ae1a1d04bbf1aa53d9a2d8e3da04d60aefe1a887eb25a2a3a0a37e8ca3c3d4f4d93e9b2dfe79221b608603dc65351c5ba08f42fcdffee01edf263c27adc26aa0a15329a5bb660c5ad2b3a9a103f575fde0992cb13be2ff02f1d779df97773453e6f80c077701daf447d8ca42c0ea5729515093de7acb75dc3816e0485824c564b600ea4a351779f05b6a183fdcd13d5a620ae6d2b461d67690be59bccba5e1bf93289a20b4f60ad0b95aab1ac214d99fbf9545a6314f14b34126fd3987662333968ce07af9d53b6b2d0b91dc870e9bee762cc60b5b7561a4c9c33aa0a6aae2efc82d77519941ced247acb4374af216e40feee10bc8ba8be0960c8432eab53bff389dcd16663bde5604af8eece14433e2dbe885a31f80ad8724738a2418835405083650a61b869569688fa36d48ea544f27a2ed2aca83f609833ed96336c4b62cfd9b24a4157c3a2d0d0d567c1ffb901d212f8e8b9e968b63f7b9ae7413ab21ad0fed48d9b120954c24ac0789c22c2e9aaa82b5a45a07e742ada8f6b6c8ca779c6806dc2dd3100ec32859dccc247ced7a0b4030e1a0dc510ca3fd28b6f22d0f9849671480723a32a15acc0679b538843b396f69919ae4ab7c3979209eb3eb28b22a672106b886cf732233d15a2415c2297b37daa6455954bbe0c2d23d01de70971f032920d2704228abbecacb7eeba8e7f22c6b248739f6e0f7c4e233662d0be8d02fb028bf011dfe1da803a623ea8b41d291100b0c07e8fff6aecce780713fd3fb06fcf5961c870b126222810eac359936ab93c0ed3132d4b2762d596467b21984cf60970734ff79256e5d1c0c59ad9f2a6bbcf53d25527230402cbb8619ba8256fd6d307199f1b7170d6023fd3f003e7ebea9e61ce516608920a92158df3cd98dd13cab30cc631635bb0e9a5260e71d6f791ae44c4a352ff022e63764e19cf2c1fa928617894c1c20e3c3df31140e391da4b8235227a0d4ac8aa2ca358278eeab133806a5bf1e53fa9082be1ffa4d9ad0359e86a4bbfe3addcccc9501802b3f61ff89cf2516888af0116d6c3168979b8d18d0ac06410f7c84cb8900357cddfb4f8146ee58b1041bbfa173914b694278ccd8db3b66aac0c3da9c93bbf82fbf7d042b84e75d05fc3155a63412044e2a20d9aa958f85e3ca626c4e810206d7ce33bd49010efaaad86f2633f035b7d685706ddb275ad5daaa53370eb87d80d96547dc699497d332e27f4b6703eb9df450ee2a4689e3be40ba0cc1e7980a73ea62cdaa64a7460493997169f3cd96c10e3b96245f7a6193666582a698db78420b97b31bdad8e3e4a473aa3c82c90ee7bf9a76fad3ce0ba14d9663b529cea5885b03fd04d12845986ea9f914445005399055fb4ce290479636094d166b6d0f38c4bc37d00eebb371f31c0e2acad1c480a9a39e1c084399b99f5a2d3f2bbaa74321ccafa098775599214b2dbc3018da427f61123ab698a81bfb0eaaf191e39cdf26376ba219a65a70df7dafb36468662b628fdf8744b1595915e7c0b114a12d97eb043d0d9915998f97e9fd0beb455c9f4f7018a8381fa59bbbfbe40ac53b986a9bd785e881971a5cfe5a444f8b096fdb7f17430f833701f74a5347bca7d21d67cab59bdf1b0271fe890ad9c35097e7815fe1bad180e5eab39158c00fe99284072715a3ac2309422806947bcd45f0b6ade034fa0d5a744fdc6662a3be5597e332a6b64a8fc4e8ab3bfe5905e782ce72de7cfd55921e2fd3db055621f7ddccc965b6e09ae47cd6518178ddffaf24bbf7407a0ceb651e640b57ffb9edd4e1cc290c9d47e57b2dc8cd03a3e9eefd998855fa659a6eccf20264d966a504327b26305bf6062f4c4d776a4227a46c38b764b1d45e5bbb31c8b5a34d07b00a936710e6e4923526fec2a88c9f265d6b0249d1a8c1341dbf46969e7123c242c27e6f55bde68816f5b34acf2b3af2cc035a1043f643813037bf570b8f1b1eaf5f28bc634e384a350ee9092a63ad5e2714fc2a048b43cf1a5ad23786ef46111aa8661b3fc48aa291e253d0a43a1573e8b1a8c30fcff05045dfe3e51cb71ff2cb80716b945c09cd8041df43bcadde424d6a1b0a1deaae73159a8db080a3701455c8ccc08c4d0a97914ca31560781a0811c9b22629154b319db99c3ceaf45ad5ba96ac46358879afc56d0a3dd73642e7bb8d2063b26670b3791422a1ce08a7114c0c81b4ee67a2970eb4d8484ca3a4f4a49d7b5419a48eb5329cbfccd72258325ce2f161fa16584d246c69e1ec4b747475068ec886b84c12f0dbad3194ea3263755bc52991e2390089f0519b134da739551f66ca1f0404bb7506c17a51aad0a083a8133b659b10f65b0fc2cb45deb7fcf77ee00a304019035966014f42e19d0fc810e5bddeea9e24845b5be29b6962d9b932d78470bac1be124e23734ba615b92576840d5f58f2a77c1a8ccf37b6fc3af7b7149a6367315745957f3841b937276f0d14e612da94a38e8ca41a438bcc7235296b3c4695a19a818599ad5a347699667d77e4164ad8029b634952d5db5fe165dd91292d286642ff9c2d17fc0456d10d262ea363d9dd245a3bcc037a25da3dc653de6f691d169dc3747d8b354ce40a032d2737d542ef1ba693f9a691c56cb240335eb9087d42cd24b2a112a88fd77087eea9775642d2c474ad0d5f4a60039601a0428f3597e824919a081d1004dd04fa86121faae6c62d5f0b764134a9e565267d5dfd5b32e3e1c2c426ae93702cd97a90e07d89a52bc4b3938fab270c68e104f0616175a1847206916cf0a20151a6c3801178f9c613e630a226c3432628d59f487a1eb786435558f6ace4e7cfafbedb5a9c20edcc208d347aca284aec738dc47a6d3b362696a97e1587dcdd9d69e737afec38958325b4a4deb2272dfede06e90f5559c528f64dda0eac66d10e6deee56e290852bb2a09e18250c69e83ffe7081b04a492bf356cd2c10f5f209a687d9b84ebbbf8af6101aeb2aec0461cb0b9930ab989714b592d1ea212d166a7e550533af6973a079f93acbfba3d43422939b218d70e10703bb1fc2edef03162fd3afd11cff3416fbc7781b70ad4c7b4ac7ea5a7360badc35c0e3883bb57f03c518a7e2f16cbc1fcfb84dc625f3e3f430e02f61abc7b567d6ba0b6c37e5826af58cb92022cbcb166a5246ee38d18ec5d012d50ac8047769c1852c3ebd2bf34eaa34107876c6139891a6d146a2c17e7ea28a080eb788f9449632211ffeb8d37240e7b38cfec79118fdb2155c76bba4086ee9f5a1a17c75833ee146c35f6244fd68b20fd801fc169c9e9f8f169b06ed2c2bcbd557fb606e4f0ea72661368393d6873c6bc4656591dd7cb4f445a927d5eb02ed45830cc761ae5846a061faa29da33d23acce50c6e1acc9344ca57f012e018fedc6333bbf31ee899bb4ef5ce8adb49a65cab148df7f3148f4fd7e7183068fa930fbc5256e7921856694cf35425a6d87aa2397f7b06b1c7b022cafbc0aa517a8333b6b28c562f0b75e96a5f6dc75ada9a721961d8caeca94f71cfe6634f96732ca04f790138029261933466017ae756273e1ac4ca0e31f5aa4bb72b8fb3a8844620c49d7fa3f9e137ae2f8efd173d70b97880184eb3916eb338b98fb6eb66cccea05e6f8d5e84587689423404edc4893223d59f167c389b45025994adc2c220042f00ff951c1787091a7ff4702f77c4f7c7579c81765adea295a0498b7386fcbcb42d04e12974b4463f1349cb2638a54607a57e88b7b30eaed810c0d72d3bd136411465e6985bbdc05d9f01f309ecbb29781be30075aea19300dac0fd96abcfd3b59b8cb03d4a5e5c87f3f488be9d18d414ff4f2a7633c5266623500bf933c380e975ed7560c57b3aac5f93ec4190864be12cef7bfcd2afbe559ee9966874d74376f6ad27f7ed5a643324b0e093d5c3168b95281eca31e3612e6cbd32e40929af8c2537de092312192fdab4f77fcfeed3bb2f03404ab6ffcb8c75ffde33e486f70fc94905df030a1974621d891638a703d221e0f37b141fccb4d8ee890251ba17f875943e051e41f0949ac5169fc6a6481fc18490fe79d9c8404a4cf969f6da4bf31edd6995224a62f41b5479e29df6adbe1b158ab5707160e580549e9b0850c42d4d0d0851e7d9382c70f3e9620cdd47b63d3c569e658ac932ddfecd6e56e014ee8a5a87a502c2bea6c9f47f3b8e102183e10e3bdb723e8aa896b79c838fe187fb96e876c8b62aff5f2d9c86eeba37b56a29cb0d1badc5bb2549e41f0b6ece6ddeb1cf1bed11c56fc70f5f970330045001b0a97bd1c18b581d27ad654ab6805620dc2b907802a4f4499089c49502fd55284b4fc981182f9f8877ea2c45bc0cb370b3da65ad28dda12111fd6888346600faf30889fd8e573dec5766380af6adee67a0a8b6cbed3165ca8c88ca089265d28638ec12c91462c66af6274f501d32b54d6e397a661fc882836460fbd7588d56110f55c853249f2de012539dd80b91a5ae65b6da9ada34ec837c7eb94f926641c402ece237f430577bf6022e3ca409dc77d061c076b61ca9833f4a883280d7596feadc7b8946495a17510608be15ba2dac25ad06fc233db31b942685908ea44e5701d2a5df909eabee25e2c9adca93a587752f4c40d67ca7ced896420d3aac6ea906474d31cecc747ae1a2fce0a7441b2509579ec3fbeb630d83247bd14735b07a44bdff18749a300cd5184fb4b09d96116d3bcea9244c4768f882d0e559609738d14e2e1f92d3c1a15e6b73c967843795f489f54a4a40554359c5ff83b32ab65a434b5bee07c8c22d08637228df32df92630b63139896046082e86b78e408caaf1856369dc2969298e49420e32bd3b194d5925fbdf6fc2ca6a3b039d98b586f4db4f7446be28e448abdb95a1a4f5c5aece5cd1a60b3c287e51f1b4c46164f38ebcb84d00401000e3ec2acfb7542495c81e859ae88e667454d895a9e680a8e2e3e9bdf96ebfdc0e247a1efe0fc2a4a77de28db20d2d3c6237a79e6af52c30560da682b928754d99579e98b3dba7ff29cb887b09edfed596ac8ae8ee9217d05433e3de4c2d1abda6cd8ecaa8fa857e5fb6ee86b43cd3c2ceaa7bfa43d64eda4d6954c40ae6cf8a2dc1c6c4cd16b198236a64bdbf37fce16057820fd6b0db76cfad48d4ea3562d332e4adc5fb08ba2282d3b358ef413c3ba430dd6594e3e80edd5d24667f138c8b580737b93677741e1b5d8a79996171799a1bd194c21db2a25e762f1282d94b11e979c9b33d47b69e78fde1282da87fdb8d731d57c319d5549d1b8673171be70dbcdd3161ff425205b7558ebda3cfdf4ad1a463a75ff74a84a751f4564ff9a8bf4ea66ab7f6389905e2c522b32af23aad15d66579ed149a4e9ea92a02302021be9a35a2bad04d07f7221f573478e969ff04d634e74b86466f202eb0974ae963c8809e965e5dd8eeda0e764d185bc3e3d56d322ab87b6983719ba2049c89350edd0752ca67e3cd571cacfe89ac786b0be6cdbc403432d611a44c2933bc7d6691b9310f4e9dccf68a3d7bd53a12efab88903faeb696ff5f931dd400c2ab9b6e2ab93e83941439f12662bfafe4757d2a5e0f089d5829c542066eaaa9f7052ca447d91b6682347e62c203b7eb722a15ba4d626a9e7f6d5c649eabcfed70e5c5e8d304dfb239a549cec703e36b168d2d8dd746b8c746c9da1fb4d16b8cdef0895f637666b5a60ec4bbb6fbc52abf1a277653c6f1dde9d2b8134df698472a404a5d7bcaa69733d2ea0c8ea34deeddee8d68da7853e48c6a2e3c6a16805b4835e1f8fe5f54c76f55b6011b8540c52335c21317dfa839073e4f95340886dddd453ec47215503310d54d8c6f552c8310c95dc3a0cabf68936472f895152f13ffc933e88d1556a7bdf39a4c9913c269236edf2cd408d8de95c5d3e6ffaa084c5b073c501243bc2c481899a437217a2430c1cf2694e2b0b554a6538c559ea369368026aecae7a12cca04f8c02a1749fc30cd8f53ec5a6de06565c7983d9f2426ac7bc6d40cdb20c44b76045442856ed5ef7b052120b8cabfe06f876db41c4134dda68c5248feb4bfbb2dc275f12480dcf3bf4b979e23493213c8614c7cb4c042453f531723d6b98258275fed3a00105aa71cf43398b55db2979ae875abd067aa9080c45e1f161c3aad352a77ed57853ff36300d17b93b0de6d98489a1f50ad8027b5d469b6dbadc029d31ec145189589625d904c717e4fafabfa53b5b849e8f59feb24d63b3eee427ab3bb157ec9d233d0751cdf0e806705f9f38114761f12a039df25a8c2f73d30996502c797438741419a198894f516cde7150e292e5f557081e9a6fb31ad567428e0c9309168e9cb70ef74e762d56a49cb836c1e4ff27b60476ee411d53ef2cc94eb0c24047f4aba0fae27a40a106fa931071e6e08fdd8257138bb67fb6050f35e3ed2d600ed125ec9094d11eecd8ebb4d31b502783ed22f00de730f92acd5800efb174ce232ebf17385ec281a4dc71f7d1a11b979e847f487e6aef88792e32bd59aee4730dc1e8175524b6c39b945b78d37a08fa3aede9b12991be0e284769b893010727a5d1b6aa790724ee74ad0fa603374dec95099681708f323cb6e1da614bc7ee537ddd3f91c1647fa2379b5163e5f3832211ee5fcd4946652747f40a7e1b139e3c678d712665f8ae71e48540e8713b6460e6628483e5efaefdad1f4ad3a3d7a512ee3c49c1363fc0061417caf0754b365b3b065aadc28a6c3d67a58f3dc73074d7af94cbe3484cd0cc962545522a58d02a5e1223415baeb748db42156d7f773e5949b418a8c23b146f7504ba7733da63f6a5594381bf7c786ce20421866f70cdb8ccdc0ebbfe37a673c735ac67d4496a5ce0505509d073d2f7caee6aa7976586adfa50863827e83c12e3b1034ff8a5fbd21f7e2f558cb133cfae9b6630248eaf8c58bca75c52cc975e0e5343b060ab455f8ccbbf7de92c146a86ff475b1be80927fe1d0e08cb7953950b7e8958c1c0242591f65f8f862978c66bc36139d7eb2dbc9c82e306f96410b92bbe5d326e029d540ef4450a28838b991f2c9148c818967485e9bd044a218b8086a83a587578f7c261fca58dbc407561253d7de9b45858348df662209946bf91f7edb044d42a692ed7f0bde201b2945e4164c84cdd5fcb9226e5eddb0cd9ae971e635f30443ba501b35e646df2d7d12f52c63224034ecf5591b4f7f02cdd999920ddd813d3f850bbe2559d1f006227999e562ab3d5b3bae42236c8ef9da65b79fc94e20a1a7483f63db42d5cc9d182bdf3306bc4eb4d4b761eed902502782c7a97717b1380aefef69b8c8279b599cef0ce9e7a54271006052872d94f8322791c43c4e9995740e95ad2d2e5f5d03bb1b714311e3df95964baed1c47a1abbd618c0e1ecc2863dc8592f529fd10d0b1c2b6863c5ff6aa702c566c5423d349b518bdf0240835909ff65bd0ab7c52cc0362025bfad9e6854d2d777e6057ec95141b0925e1f2bd22c809ec3e97baf19299bd26a883b2347723dd27bdd57f653c18e60bc6d3eff83663e9888d8d84c45f1479c47b32fbad2927927922972d99cdc992022c36cf752db242e5da377e3f484acd0cb171a08849c83dc60aa22e748af0f64c6b184ac0bf30c62c2c718ece06dd3c0d83135d3f7d2d8ab266c4c999f3da200c2e5fedd50ab732d61994769494765f709c61b3cfcef10688ea01324ac3649df2936307d7a6955d747813c578d6994af37263829be46bfbc85884feb42d5e4482ad65a6a8cdf8ef50e007fc278556ec708c1d44a86b393c4c8c9a19efff22083c47ccf16f6fdd15cf76c3d4bccd1e2d1a1c812d66990fbfde709605b2a14a64238d432bdbbe7457d786d9d63014477c8dca701448844277c0ddfe1518bfded1b7e80ce0356a132a7fd076801e2aa6d3d2e61fbed7a8c4c30a104087c36d82b1c14deb9261cf9906152371494bfe6ada999b5024464714c8f8385121f85679aaf7faec59fe728f4116e094b2cd3eaefa030f7aa716e1fbcb362eb51555cf059d56d17afde52540378890928c37e8e6764a554c6ceeb51922498e4708d4e304968db65574e2d0ac8d96fe9edac76a68677846897731179745ffe349eebf3d52a9af4ee92059ae62a0c18f83d299f809907e62b0b4f07ade50e3f47d64d2d0dd380819979fc7ce4b71cab54c26f9c8f4c7688327635a2ce0aebe42fd6f79949aa6d0f786e363448843e217fb45465f45f6ccc06f43b906f58373f18b2f42cfe03cbdf11232ffc866d71c9b81f22b110a5afbc2d83134c88df08d87615f849caf57104f1fb7490fd73b20f243ff6a44ca95b21d65505e0f33ec3c5159c2d682fe81e635168eec7fc5da65c2b4186b104b525055e37d53419d13222fe963b76c8fe21707c1f399d60be76535f8a1c66b77cabc37a1ac1a36df5554b850d2e36c3d02c13ab1e3921959f40b8f912588114709c6e15f7e55417c386036249118fb4c98a39d9a6923bd468d71f101b7f02b94bd5eaf474526f70a9e707f4200f809e3c4066c3fe6c253a9a0f87c58699cd2ef462b95511922eaaec7769f0efc92811c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
