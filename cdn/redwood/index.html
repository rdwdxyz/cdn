<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c6512578fe7bbe22de6453a47d9cde81cf485b1ffb029473ffb898f52d654a4bb8773abae7d4e4cbc473a44d14c8125694a3a2c441025d1f6733293603f6e2d7e29e461f04d58718962aef7f26aa228cde853a7b3857ed347ccdfa6bb9aacc9f5cd2be2d53449f26db7f1d00db066db00b831814898d2b540f6d5aa7e9f2939425d8fb59c3c8ac612f6f3b0d3e1894da19068360e4d7c2010d97192dd1f362720bb8d9e43a2795c8cb75f5ec22f7a0012082221962b2c2ff2a77bc670fb37c412a1fd8958aee22b29867bf9d6f7918d7b1cad6580b02453b93d02729e75cbeda64642cbdeee94f59e0e0d1e00422ee03ddc29f9f0a75fbb6d504cbd314ccdd0da6cd2e6ad59f12da8932ea5774f3743c6938747c9dc6f010a34ad4e53c1b19144db9d55cc27866d9f583900844945a67d7f1009b90b12a8fe376cc8a93a5e12953a8599a10f7ad88b72baf6d0d808e3c98c388b1bf605e0a9dcdee4890390d2cf3d512d94df3f99bf82aeb73b8003c3969ef5c0912f4b927c39fbcdd828ef6e8dc35e987e3eb8ee2d70ac1a3e74014b0119e4bbecad3d0e45d4975ec62eb352bd48131951d64689d0dd06bab498454b92ddc8bc8dd955d5c8f37fe0b4637aab332f958837f2acc5b57a23c6bf3d3ff8c04058021a2ad996d760356dc73d0b4a86468b538de01027296d57d91db892ea6d4b7ff1f029aabdccec4c1f4830b9d5b82d47dc1370ac769294045b95a0012cefee8be719b818186afb04c5951601b4e78d5cf6c6864b7960567e860047d45b2afb18e49178f8fdfe94054571dab55883efb6fc3b42e075b41cd7dd5a6f85b46c913744a3b8e9da34aaadd2211a49fd200c519de8b009612705ccd1499e0c7a06028326fadaaf8656b5355187cf85f63b27bec7998036d35d71c6d98e2b21ab4b37c259fde631949b865983e1a7785fc1b8bd20f20e3f17329b53e08d4aca28d96382d5fe6a6b84a6fa10f8a15749128e624e97d68649326443c84a2639d75c07107ccfe59d9ce09488a9fd15e9703e53226fa700f30107b060cdf320fa6514c60866be72d1120491381252c2ee4378a70e8752da4f0dd614352fb1a71794c84655220238470ab30e8622219719b7f18171628bbae3978a930e12a0ca1177a7ae74cc5dfda07f85f1fc1cca03bcefb599e1dd8154bad64b9886e61565371af6935b8dabb81aba1d7f2511eb6c1e5b733494d7b84fdad1135a3f28b9ef1c0f2ee34f8f36f16fd17b110a5318d4884c69d3ebcff0fa5697613e40eec9d27c7831fe20d140e4f99d60f922bcde6abd87306ae76515640c5f932639855225e91b1cb854455db421e9fec40d0942408c8bc0293af00241a55cf0392c7ee1f78e636ee98eef0861bf82ccfc67b80e62307756075fbda230368f2165dd8c7067d85bba8cdd2135ab252a720dbc4057e0b85c5eab5c011ecc07df1764ebbeedd23ae38895564aa42fdf2972698379926dfc5f9eebf318d698a1ac9d99e345705fc320e8a9d56f86e8cb3a17b3b7bcd7e7b3a7aad3a0eca6ff0b92b9de8ce539c0c35391aa319c3ff40176b69ec15920bc571d2b8260721e34df3a2b0779ef5273b503472587916c4dc5efdc100e318364082803239e8c9176bc898e41cd8fdd6e61e3868abfae56b973a034872ccc1ecd7f0c9f0a8bf49e6911da36dc103e7aa1b903b55d11f11e01cfa558cecfd11682fae58f6170eb37011dbb45247aac35647f9a3982e476c3b76fc7b4e48dc9744c9566d08cfd315ba1451465449af768641294a04569e2dc9b1fec538e85e4509f3397c4ced6442addc6f5390e2229021254a9656a0defbbcfb649e616b068cc709080b29d09e29deecc4a3d430554c1123db973d3756efb1d717260e8f9aff061c7f16e8b3bd23cd924f5694347b71c7073ce81e96ac476e28c99c8f9dfcb87fcde5585c8db00cd2f28ceef4a29bd96be684bf287f41148aa9f63ffa791e83e161515bc20fee1bf83171ca2e5704c78e1d3f455528e071014b19aa7973807ec1ff08c96d5810be2b4260855d1d36ee8c95fec6dbccc1c1a18fa9d55e89aea92f549926d2d8d2882ee68eae2ddae677e7d0cccbcf420b5b069992e8fcbe05ad396a82b2e0a699b58f8d4a15057d7531bc73ce6072181e48c321f71fdaf7276d15d0bf6a84b97fe4c5b1b7eb3153bcf9037f7a51bc716dde74e8107522fc017275f0064afbe2b747f4db9fb73a0cd586ce127c1788915f4e5baaabacd277a6686951029601fb3c3abff092de66f83fdf032495a513554d2fea5a30cfe3b3a11e82012caa6faa1d38bce5b1122a48806f5d75e7fd79cb575635ebc87112388473d1ac73492564c2df2ead7f8fe2e402c5df019095415b8e2e52c2d135888cb9f7a401be90e757b6a1f866ec60b5bdb61fbb1738572f7066fac70b28c6695a7e8c913f5c7b06eb22c15ee34baa4435000a4bb42193deb461544470d1b19b7ce41d2b8b7dfa60456fb92a0d7ef2a2abf27df880bbfb332171d1246a4d819fd6eeeb6713248bc0fced131a13b611d844e661f10956e53c82734cb0d7f9585e3e07a2c78a14396485c85283b020f39b4bbb11edf886411a1f838e34290fa1f067714439279202f37e39a03629e87f918a49b801b0e660b8a170931127c50c1bd7b890222160d616380c628d992203a795f55549072773a4f7fed60ae278764fe4abdf8adbc5918122a44a1a5db6053fd9db1e3ac3316389f7c0245fe17bf29a75c35d7b75acb854a5feb879ddfe46285c970b70b3d8ef81a2522b1f5dedf149c647aba5f438a16c339f0362ce1387916bf3b32f1d17dbe0c2813bae53c289e01064bba868358dfb4225774de19a5a68616b7b9a5492701a3fce8eff5a3ad738942767997449ad96667ea448e2c88dc1b692fd14cab2b43b91696b6cdec678b180404b68666976b7ca848b147fed1e6e2f231ad08c4b89a5015fd78b4c3af6962cbffb66b1677a8936c43a0b69f8fdfee48f7208ff36cc3ab6ee9209a81b430a56adaad55b0c8992c27f8b4006a8a7f767d2112018faf90e89d43a3a6f29718f7487d3fd372532a9daa5574fc009f77c1b0207947bc75d66b3b741ea1835e38d4619ac5a9b3e4f8186f40ea6e07c48f52089d01170994730c51d47b7c58aa9e26b4f75a1c4f14bd768ed3201d11adefc0eab5cdc51a000b948c70c7490cf7671386ff6c85f2d456bd035007a2caa0e728e440cd879a5437b914ef243fc6fd1d0b5d45c008f5065e02d5fb5abd88b597075ef4f7ebc7be258ad8812afcbe0d798648584a74512d00c82976f129207893fc72f04d7550787f65acd1de4e69c2b79e48238c49f93d58e8f570b961eb7de9016c94017c5ade645352d7c2ba72c601c1f6668b5a3e8c8d058464650d097bb16a225860fb098a0404c8e40670a34629c70cd7771e637b636f5539d5ff1a755c73b6088483186b29aea4fce225316dfeac65bb54ad1c6c936f654a23c69e2faab84bbfc76f798e89319180d189f14632dd78761c5392a322f6ff5e3ef0860fcaf3097b2750ccac3c6602900c133ab448f0ecf5d0541606cc67e63e79897733d4641c9a61a97a79ad5ecb75ff2b9f0767b0608b88c7c71388cd0e7fb2861bc980257442900b707930c1e1afaa06b2536b1a41f1d9240283158c8f8b5e8e468f5bfa80a6495c57522d31be0fd145c65a7b9d40d443aa0643e87c4d0069ed409285c9356f6c527c356592f0ea93cf023e7a5e548cb539b583733a5d1c2f4b489aa25f9ed7b772607e7756c462801b939a6c240969589fe31694edf2b8859d8fd2c979e2127430f76444132d0c6823bf8b637676013236f5f26404ebf9721c11f2a2bce046e79cbc035da86a16476d2ebc1b74b22c127cde0d8ea308dc8e93350a21def0ac382d4265f8b5e7fc1cfc55d8c3cdd409620d4c43cd77195b5ac9f926b39b80d474d5e2cfd4aea34f2bdcdc5052c1f645765631e7699dde78359d64e9779b920c36762d9843d0761c4b4644126a4aef3945c313edbf807fc774884fdd1d965f8b47056abb90001dd2cbd719f58dffe490047542fc813bcce6c682ddff90a19925c763118c9ec63c00e3070d2c1acd610c28236cc1efba6d600d8a98cdf1ebb099b5adcc1c615ab3badd61eba31a0aa22bbed8f8d68d386a6d6320e9cfb13baecfa2e71128f61c928a8f377a43f1b2a06848b11bfcb7b0f6494f13370cdf9d546d900aeec98680f043fe07ed1159c3d0f91bcff6665e456aa7653c0936f678dba3cebd1140ebf97ce025c6ff020388e8bcfe545678bd50e111c830fba9139c1b7ac8801dd476228cd867194bf6d86ff867d29c685df55bf5aa422f311f23e1591452655b83c497e33b3075deec174ec8772db2c29b17dc0537728f56a484d06bff7e576594ad350aa2b4c02e0bb26f5b78ef146b454aeba5a89fb70c7573d419104e6e082633108574f1eb1b3c33a270e289e69f7a39db9edc7a8b5d9321365cc7714c8c569f676796c1234af1db8c5b9ce7599540d7a7829d84da155768417911bdc89b3155837c8313c678abde667fa440940a613c525ede7a2a41ced48676c4398cd94610179509ca755786e09a00033fdbfa9a5442ad02b9bbc843df57138594626f5504790aecc989e61f4ed7fbb4ac3263339caad44d11c062f6e773e51c32ae56f7dcbc47ce9e7e69c0ee6dbdd2a301644264b34fb9a25f11cf289c1f040b680a97e4c8017293b3498a7b9ebb05cacc7e0a4df675cc92585bab25c2f748af117b11f6b8e195c49e8d798cbc6f318faa86e4d75d53b1751ed019686b33b3622da8f4223126c05b94b223e3a650eee77c91f230cc1c52f454e3bbd4a1cde67f6fd0c9cbfcefa87b54170576a5667adf8be7f958fd255ddae8c5fa1ab7cc49b38a4fbb40dc7118a902f3f98060dc644f74c5d6cfd3bc2b98e88f6af8dfef66846914d07fb7a752426823c814c03e68c29ec693edd29523b81d31addea7ee000be30668ec7a513005bd0c765ec3c8f8fd0aadbeaa58d58ce3df2e005dca30a983fa4224702882994a370f8ee2a57eaa16a597e9ee55042564ac0bde38f627a6f770dd75bf59ac61cc7c139a86f3e285c674728e2a5772989604a10cc35f90eea711158d11eb8dbb2e09da26a3ea3bdf65338ef02471ea8ab2bb8d199c4e72067f749dd118bc17b239a36ca3de6a16958198a5083f6381e19eeded7764225d42c5c4104867fd59368ec47d4abddc6ddc17e37f0477ff5667e1c7c682b489c82c6d3b1fe6371354e565f55e2a3d2ed0f05cfe3b9d559f08c20c553ddd7d3d8e8dba481fbd390e6e7cee2650044a264b753b990b7e04638e029d5944cd37db50cc6945d4d57b568815019c0ce1ecb1c7d31f3f2d090b68faceb7af26865be8556ec3eb37ddd9a1f0eed9155d0afbe19d3b12f7794bb11c3ae730348ef847ecdf096d5c5a9f8ccbf98a46655745cc559562464ee51362b23f9bf14c81fdd51b6c73e7d3a89254b1710b76ddd317fda03d6ffe10d11c871db0467680ebce96a617fc4c8a9831dab80ee12651126f8a4f3e1d319d147e4220aac72423db0c1b3d3b0f7b4d3d494d8df415ce6affb963a039179ecd85f612a452571839e982cc70505a9ae6266b364b1d91aae395537e531ec571798e1ec3e7dbd1e3143d8b2f43d4e523cbd3288496b486134b46552a00405056d8c1f5104bb6a617e9449a042d697c27ba3c446d9d3fcd42078054f2b9af457fae36eacd56dd85875a6f804730074274f53e8af8e35b34bb3c4ed6f1c7601a80764c30b57bd5f27b06c117ca0d7108e7cf1983c32301bce9d2ee52cbd4e2b127c2a656ff3f256dc449f0892a336d4f49556f587f1342f9598a2dc42d1c233fa6dedec001bc233f657b1c320a8a654333fb5b14875b4c6c714aaba87d9549de4c9e243a29bf84a639514aa0a4e5268f114dc2ca7a3d85a912609b32ed53cd23f492249e10146903f2ecf7dabd25347af02a900b5db01210588326e51285e06d584d314cdd7c9bd70df24aafeb80c637c4783729824feb308f1038b48bb3df570cf97dc527918a99f313ce7a5bfc3589b4e732cd17b42b523622a2ae330628e2b4018d31f06876e1636d2d4dd4c8022e5af46429e6817804747c060c2114ace1718fb8819851280917605ac2fc82dd896c02eb5ee4138c87d80a6ed933a97c796acebef2a5f3f348efae58323f8c9f096f90e2cd8313001a9d1ca465d3a72f8fd0abbda17dc080c34db1ece129e760d114cba599e4f2fd49ee601e2a8af7fb1059aae7a2aac1c9e4d73970154c4b9e499c141c94ed77f9c2fce16f4fe3209a43548fa4fb991e674e436566a65f870a3fb3eeeb98e7c1ddd900bf30032098a536fc52a4a407c4f369a59e23a8d30209c8693ef0203597e6694576c8909941c022f60cd839088a9d3625ff98a8f082382bf35ae8d5d5ff24615b6be007dfb63c07010ea561ec27ec8e659796ee64e111d82270991d32712fb5f07d2b458013436b93f0c74f557d0a5fdc0757be554c3200a7d5dfbc2e63775e3068a43779e3a67cea427748107f3f88cb24358b216b04a1ebfd4620cd74e971208ac5e71dd3b23dc156819fe82965342fa1f0008160bcc6cd7e110686cb281a5120457939e8e8c7f4b6cd65f1e2fbdde64a50b9951e235220eca435a6d2ab55847687970aa175dd5772400d9b90c4e1ae51771e8e67ae59b94018f7d867d48513bd41dab45bd2836710fb0cd415c8f5a98bbafbe5d764dd9d3e4a5c33bc94460bbcf14ad699a90bc93e556d1439848644c02e81f5262d4ed8eeb304265e37fe3f826d07d8228b2a2e2d53fbb5a8987ad0d16a0656a8533f1e4afc0daad5382c935e8ae53a626e517db7a6cbfacc16f95519067a3cd09501cbfabb2c171752f5b0e6f27c8e8c24f21ba38b4095c73d1d66c95594ad48f7f98b7d9a776e7fb2b737e5623544d7c563602de18b7a8487107de05c70bbb4e1c6aac0dff8b154db65bc8190cecf2a0e248ad9cd0e0aa1570922216afe579f79ee5e11b4a0ee7ecde3a7733fb441fe17d3bd287dd035d4cc351788614c1b3df7fb772c8ebc7a24fe4a11945d2d4b1d2ef5d5113877b1313c44506921a198789fb6dd8a47b6a0e7568efc6820c68a6790719bef6d76ddd5b5c39867a4842e5fde3ea4c79de926848b31993e58f9d766340766d047c7876f96fdfcaacae206d3b957e6dee11f0f0b99de259a2d1d46c5f21f4b7fee91f0346c47c848945faa5993bd05c959feff5f9d9398ddf0d40481eba64b4f7663dfc7994a13cecdc5640ed0288e602c9838de3e74e5a4d7ac826ec3af404d28d9fc0b4c38ecf2691a40dc8faa7e1c4e52edf1f6e8e5e38df74258120b9d051202ad50ade3ec1b0f23a0e633c1944fc27cdfac24e65d03877c671636871419b23e3e4fc177d9eb41e730e2ae2fc75f156423ed9c37990d46ec1696f6c8d4caae55800dddc3a147efcf3f409767b17842cd1601956b2ba68b16ad5e9b0bc9eb1acd09c37ea3cab58faa043850b33a52d92e420239827d027336d173a25f7c29ea9dc1de2ac00be9a1b51a9081cc8d3b93d0b1c4d0a13091a34be5890d8be9beaace3c17fd90d5802d92ef249439a5e6f495a2ab94b58a06972d8335b49e97ad124c3092c7d14a2e1b215118f69cbe44169dac2faa44d7e9a2f8748bea2f510aec7045979f6fc9dc7c16c83d7151734218a6e3882a244c054865734f58c670c0ac8f92ac1592a3bea93820cd1bffa8bf7c1354ea9a5253e39f63745aa9fbb2b9a42d96a39e2ef9a25e0cdcba6d69174faa8df6ac76df861fdef0d4f6767b224d65a8feb326441f48f24b2b2a58f8fa27aa81375f7ec1169b6549aff0bc08d84cce5973826a3b2019a16ffcc25c963ca9997a099f5cb1bd049892da65c272a7d7ce1a754193f9b226a223c92f6407aa113a82437a9377937adb86c6a873edb296d2a85c1d0381cb70f7b6e3359f4f3c4e25ae26c9e853d51cf7be9386b844d877a2f5d15d82b6e85f32677d381301ddc031105d82d7f1da37c351a6a5339330affc36c0998c73fc7e56d3eb180efe06b9d21b6f71856b3f141a4f11c28d98667c1217e1b847c0fca3b53628cb37e024bc2c0ca2e9cb51c1de70e20e4bba5a818d0dd14824d5d824b0f39b99e91f1c796b39532bbc5901f3ae48d20a382babf2af74a7153f9e0d266509d6fd9036b6950cba0bd657a54095abbf5130ab9967c7424f101ab4def9c42184b527a3b10953cb357ac0dbaeaf9bf360ce9712c0c51ec6a2586f3af802e438968303fd473da6a268fe7206260a24dcd16fe95a480545e554462eaf471cc3a1f4fd7ace4936d36894f18e2d450b539cf1219440833e398f5a91b465854d8720c747b1df9c4ab5249d88ec6cb7a04287a33586710168c3829761d4ed8381061e5d5c9712032e9e2ea8d11bf736c65f1454cc0959c254c9cd4cdd68968a5ade7328375da761d6e7a30e408dcd346fcaca5d6d0206669ce50ad016aa2c887dddf4a5a2bcdf490d1aa15a42ac87a6099545c3174f79a9639b9ffdfd19df4cc0a02ef2b7a25d4349bb4055bf857af6682b3f8abc17adc839e248681aea90321a3db93b05e8c366e988e7ea57021083610a6730b62d7a54b9a45aa6b92f98497d6cccea1dc5341a0154dc094a0b1faf22421deb299b8f296fdfcae20fddb716833f59f85543f5c0e3bcd62b1dd697f37e78fd97bceabd91bd93eb32611c59afed2f16809ac5b8f941c065edca2f810290f4d5c82909d689f071f8095139e4564d35ca56ba7833f53fdc02aefe9873e22fbf2294f777669836295131a89c04279d7d7c11a4a688187cfdbf16f53d0b3bc3e0cefc00e2a406470083a974fbe8ca0af15c18b3f596e20f9038985cc5ccf9ef853272ed13abf2090f709a07ccff9a62e99249505d0b5760422597b7ef673beb171895f1021d1badc6f57042bc2f0d7d40fe85960d169babd5127d96b3166fd5b80d6ca788ce3f35440af504dabe4e4ef915bf69e1005881d38bffc41695b1f6ad47dd29f2010ca77726675d7b6bee2d21dd6dc9731b6e900a08aee90a86f4610355ef4929ddb8481bdf4bc25ea9306202690853f779c303070b980e8577b4bc581e02e0b08cf81d1106e7686232318a6ba3257e422caec94d2195cb071ed05b1bbf6270c5ff9277dce566a479d2f8728084838e9316941dead2063837c3a19dc2bf63eef07910d4562fe242717b3d7094f7db68badf70ca551806a791896fde1111ba815ab13e7a441ac42a5833fcdb404f7838b3f0c07d6473f9000db6e8e8947de7dfe5ae684b61cd3e6684b4baf73e4461fa51c63d28dfc9a70cac33da3f4015a75571a3789810bdc5b2cba06baad5efe627700a99e86f3f83601c803a2abc7bd29ed19e4f352d8e3d483aa3350cce85e4627714c6922cbb2a5c3d5ba0ecd4203b407f6bce57bc846cc178a41aa5b4751025b4dc918dea078fb4f520d8207b7daf0bed43b9fec3f83be16c7cee803a97845b2bd540713d97b79f1a364e0b56a09d5ccc0ed2fba7f5d1ebf751decc4d0431139981dd252ac9d1c14c56009b565e6713a5a1be0f3132c90ec609f34c21e8ce4a80a6aff21ce7400880bffc9bd716bbc7be7c4daf5f16e416c7b879252836a5f9d337ad1bf8a69b0953b7a56adfcf96534daa680034fb06496310875209cf1d79b4a30f0e8905d3ebb15048326f6f8996b22af2e752f61a455f89c0ff3a64e3429aa25c78229a0035b23a8def0db976284fc4fe31ed56b1232e5e7820e049e6ceb0c49ce69d47977a199d7048baf3d407ae2994696b2499bf848dae2f72ac32ceb2a25b6daa8e3df8a3e5d79cca83932dd790cf2e8084bd4aff8788b6b90e50eca234cb4783dd812505167d65ab89eed884a45da496275d17734cafbd2817e1d1bb438975713752d3fa825fa5b91d40aec234fac43918c2af908a6749a88a6580b86f17fa29f2d6b248b82932375e5fe215f8b8a6b72c3b0a4dc7d00f495e1d4660a4a70d9943a3018fd1f3acaad21ed71c04e3134254de2b40c4c3e22f0185e2f2c517825147620f01c61514daf4dacf4409b6ff9baea1f41fb245feb10fcd211faf6585fb275ea68044311ea3f5f01c94ffd6f0891275cfec7572243266e0416ba32c973fe45a1ce841d4fce1b5c536863fd9cb1c06fdaab485c1987b70f485acb17ef2f03b3a1acf987ce10512999dd13b1aae423af6b654dde30ee14f6d0ecb1c6848f39f7cd5fed2d8b5b2ef95b5a568089aa6d77cf5430b581ab5e2ad68e66d54bced947d0f6567f1236760e45dbe11d3db244f14d8787915436f6e5dad98f33e3e7ebcad08e105f12caff10d6a4c6fbdea19384b52a64b1428861f7f2e0eebac8adb0afa65f2040a95e9f3ad777462279e4b13be5743d52fc5e921e8a0b4da32dc261d2a597db7cb9c93c64735c9ef662bf4257babfebb16888ecb9880c01548aff067a7dc5721c68a794dc9472e1b69676cd356666f9939ec3fa073dea7ad70502db0e5759fa7c6e7db55f0db9a8cbe82e1e85a428e7ee7f2a8d7694703f0f6500c6e7e198ba9c98b18e8b6c66f3e616bc84f8970065d88e81350b2b5bd633ff79fd8a5cb8f4c597ea160fd845409202a25da54ea5bb6c09dd8d93096c9118d19b77cac206fd472a9bbdbb0d0e1808331e25b524af69cab724b2833451422b87d39fcba9d015196a4c3fcdff6dcbbbc8acfd7154581071686eb12df7b72171eef2f4f5733d13f445870712f4161cbc46222a8c590b1e197a203b29c92d555a4e666f99f82ffdcea483569e207b118b885975ff6a4e0a80fbda7175721dc82922fe03b7b819108ef7b50f321381458220060587d69ab9d827053652e02603a06d291b62b75fc84cf4ff2e428702b2c59bd5f309487c0b1889f6936c87a867e05c51f9b747a48503d137645e8d610334b5d94a115201afa049a619bdd1864f75960bc8cbf47c2ad1fde7921edcf9ff30b283d75bd678fb32835083597aa2c22acba3e8eda7e4dd6cf83c56e28096d3af2b86febb2f26c28e83a0422e2ca876167a8fc65c217a76e7bd5abf70429772db4196bcf3ecffca7cbcb89bb00770618f9c9318dee59c6c20b5ce5add3e2b493f9845c9973d081c9a409ef0ac68011a12ae27aea32e16e4d16becf972dc5bade81a20d4d39d0cb8c9b94ad3302fd7695daf94c2291dc7ee5a015210adcdef9cd8d275523a45f7e5cebc0b31b303a665860267213eb291479fc47ff92ed16d2e04bdf1edbc0f9aa4ff9105108e02548fb58962869e6b7dd32baecde307ad9dc7e164c47f3b0e1c2d284b3294efcb3e17bac12ecd0fbd7b0fcb780b55cecaebad4dd710794b30a2d70b513681b17fb17a5e0630392f361f822e36f34e4c0f8f964d5917d167ef24f75bdc00cab32561f4de386ac0fb9fe49a52131b7973d3cfb996072d634f36a5eb2cd8419f9233dac0e7eda6d9b9c721ed13c93ad036088bd988a476c40c85e4cfbb0fced0937b4d4da187fbd2e41c1737a4cf625e618e5f32ba45f3e20fef13eca0878f80ca7dc36722d76422f9d342c12e2f9833644fb2e4b9e41f4d2256d3f1f23e763dc9b1f325c0f5f172d427953bd67a344965d48bc71f20aa20af310cbed0a0126787bac4b369390dce411ba7329c2e0976a7337233957026146719699f50c847e9217a096d3bc2bca2345ff15210155f57f05324d8c53e02a4b42c97cf797040ca76e0f8036b14d5c1966fa3213a3ce2b834ac4ad476c1994d6ae0484a92c95e67eabe497cebee3c5d106dd5181468b4a6a72c490d04217873faefdfe959f5a257f7101905520c9b71b8fd986a43a88bfd2222eabcda26b025774d5f373396eaf6fdc450bbb5ddcc05f63f4009e0c8130dcd1407eef14363b32eba0ebf4ef66ee35a278a39f0386500fa87c0c21dfb1ff75f9cd11ce91677a349962d2dd25bcf01228dcc38273291705e66c73f57d81655b16ccc763da27f68e4550f264fa6e9cd83e229462dc104b890a3bd5d120667adb657d5cfa904ded573d11ed7b2416f933f7e4d8e7c6bbd1e097a456c2a689c06a6b2112a5ba765aebadf06275920b9e8f89f0bdc2f06c3a5e0d03cad99cdac09528d062bd24a21c1649ff268177b337196a963e1959f3b7fcb95e00e8533853eb999e05709c96c3c4e7db379f886c83676d2b54edbf61c3b51922931e8cc565600d47d382d6b769668ef1b1f0fc559a3bf2090b984e2e89473a3f153455d033708f502ac94a46e913ead19adb35b14e85b5349b5cf23e88ce2df2269f52dbe7cc76c8fc8aeb0db35c291172916132f6aaffb8b834dcb1b86ece4cb253bd24f20f811c1a6e875af514cca6e483b35df546cb040ad2164dffc2f09f0907b00e81a92180b54468d800e66c79c312c2f8f54e98d94428e5e780011e7811c93eab3a1fc53c34ab772501c795286477ca17435e3185dd04c94c19366a692f19b7615e5add88d2d0d7ca35583253d4eed4d21b33d07e0554cac5b44a654a9fc4ebd7e3331a5dd2f1cb2845990604f45f517f6207f5bb07945563c2282b2dc0b3bc37de94f208547cc9843b57965fd060421a49a63de33596d6781feedee3bd663aae80a3bb1e880544bfb7b78d2d07905734d1dfb2c27cf3b51055fc2826c0e25e63f05bce40916b40d84f55f431d6afa44a755b7418e176251f7dbb17d3f323f90908a6df503f4ce9ab7e8f35a6c4385667bf213e614361245fcd7f0daf751ccea8ee64b4c77cac6b8ee08ea19b36cc343fd54e516f8b7021fa991a3a4b99cadeb73a7ecc8f9c158c8c49fe71094e4a6636e3294aa7966532ab5c5975ceca0894ede4e858d7b5c06105bfa08e73325933b638ab388f5f29d1006a820a8d36660259937511a37a6e8b71f91624bf20034fd5673b48bcc38354ee427e95f04f4148fb7f4a93e7e1811d4acefbc460cff21b396332d651f8a22097147584e5f33f4d09fd2d1ee1a4ab83e5bb3c33a3ddc83b599eb5b32ca52470d1d756b1245991e607291bd99cb613c8f9f724b403753074a9b831bcb1d124bde993117338b509d80fb18a08552c07810e65a814c115b47b17f8dcf46dc8c45b94ee554cfa15f764f6e080a1eef22994cfe0d7f394389823bd74c10a1661400f1d819918b97724579d41391a3c42e709785f150ba434f42060909e1c5d4264c196268cbdefaaf142f02af4dd75d1399af9ea03a47b2ac1b5280d0c3eb25d3bc92b4437fc55a833393abad4c6952e0c7d05c40af82aea9af24ebf6f9cc36d3db0953343a0471fec7df219c4d4114a2a0cf69cb6a643b06921b1a10712d2013616ee70d0eb2fe750853c4584adcf1e04f5d831075ae1f2287ba7760dcaf56160ab5f550164ab803c06f208aba2f5b8967a62cb7ef183bf2c7a2b2092d3c60391fd574bd2fb30f170cc1125dc3bb8d8116fc976cc1e5e9b042673b0f48b303c6ca76259071aa42ce49cce5bf8cca7189a2147be08db298e993d0537fdc33a69780a6fc842a5bd7b25da439697ddddd76d1130a37381f4747f4082f3a654fa4d07cb28cd4c575d9c47055ee3ea4d112dd80fbd778eb16a8ad94a0f32cbb05a5f496e53499ae1b8b938fb5a44dbfae4b294cfbd7ef87da34bd522f34e0baa099b6e4477a915de7a0bee046ad5d777c1c5ad8940b21559c92242db5f61643674ed1e834a3ec35caad99b24907622207b67f1b687b5623ff87e95d8bc8f055080714f959b295270d35bcdad53b43e91f4460546c90a48ccc0e41697650eea751be11fcb183a149766e4c2a69f60e8d3a4dff5c1f633854bba8256a53ea597abc30170ab7f8a62631e6373f933508f510e5a651a80903b8bb42f72f8a6acc844f94907035b267c5757e1e562adae600820eba93f12e0e9340b0eebd001ff4eac75c82f1a5e878a5af6937d6e712e6ae6f7e8eed10a27d4a02fcc77ebc513b55fda367a5aa3df7fa2ab4ee00732680019b708cbbc7b4a8214bd6396a35b26e702fe65653a61e9dfa11880dca9bbc52a8a1976df28ec9f49852e4385d69f6832bf687c2f0af26fd3851dfc9cd768091724fc729e6f1a316080ec027a8b4a7b79b3a48845bf01199ff01c21b0c21345f71ed72ddd729990a839a91bb7d60d5ce7b827144734dce03b069b26fbca4ab54b1026b406b24ebb117353e26cef1f77b36486f0547e98daab452b6a99a2e86f507211b87e2b1e54713670d074c6bdc90899b76b173e676bb3ba473f21f71090ee810e55db8ee24ec8e0e7809e57998b1b97ac097f8c68464d4757817bec925f2cd13c608697480deb19da596645e704a05213093b6a57b6b38759f215f29762e8c79384a6a9cec4c917f92bbd137d39add22c2a2151f81119ee376ac9974ef3388c62647fb175b3885a91f6d01884cd704fef672bfa529c7a400ab6ee46d18f973956462a2985c8fcdbe43dec7e3c4c10cd4f5afdff868b3f515dec57b08f449e63d87228ca6f0b7ffe45bdb304703807c0bba161a827ba1a508d05d7e1f20412f3bbf12582e12b29da288d8cbf6d7a487193f3f01ed216a62de370295c2734d049ce1e6fcdd55be393aacbb1614d526b126fcfbe18376934e52228704337990d77792f45ab22d7a7c9a51c85872a91666953631a7cbe1e3af76d298655ee8e46b0233c018a566cb727491d9a6e570bc2431b5092669d41323c8f9a38a63a68acb146f86eda87f4827b51158c46d60a1aec159b426afe31b68c223278a726b41e8e618088f1a427a411d8ec53f85ffb953ecefc781d043ec2f7c82736b9057d6eaddb7b9835f943dcf45e24b6ded7e7fa97692a9721caaf5359029ef2e237cbc1e27c9a8d940d308c41e348dea2fcd591df0c34344ad0e7354769cf3945d95c5d92afc003f507d233ab05d33a442260057868d80e4b9ef6922425e6fa2dfc93788a742301e21918da4138104b4ebbb04ec20e5c4c2d7abeebd867a7c796ab13f556ec45c1953f547c7b4b721696d31e08c22fda1933a6d046f4eabc79379aa7c5b9cbeaf015f161426fb47003de3da012c8d258f6472cb300b6eb972d65ebc4fef1e09e5e464a3dfe90f00cdb9f43bd38766fc5bf5271229adf36600c24ecfdb6cee7e0734f9cf72d74997310b764e85fd5d735dc7610a964aad6019e61d194f732c95152ab2fd3f9e32146e4a3fa90dd9c2eaa1ca2ca99e181ef154f6c5d0ca31ce6688bf9c082d28549faa44ab8d68b8f1a4a95e7e65aef5aba948f651f0b071a65d8a342940a9092cf176b297e970a6af89c02cb941d6abc0b1a5ecd993ab66f9ee6d8915edac0e733ad568426442a133d08ce80ccd6b7090d57535ce0c8531aa7c2a8abc8f719feb7de5861f8a45ffdebbe3838bf1b3be05a10b8e0c3caf16203aa0b4fdb5782e533d557da5cb32e09d27010c7bc05e3afffe0cdd4e5a6763007f6691c7c0f0057f7854a2d5687a89742360881bbcae59b8ca31081795df7164de07f72b0338b58ef3aa82b0a22106d24c2e4ecaa743f09a53207ae3892e16738e9350cae570b272034bc0490be00bd03d7a8322e62d8c6db3458d101bc4d14bdb9897d30da39db05fbfac422cdbc7f8aa212d40a6e0fc27305eba321efc4e50f8ab8e3952daeaccf57bfab60d74df016a147d44b230632a47d18a964a061e6df40625e105a93ea447754a2b3c39f0aa0ecd74f19341ea76383bd0cb53f6e52e67bdbfdf1b9e0724fa2d932cbbb03c03a22583cf5ecc6f598890ea52636d57be5cdcbb885a08a1abf3b676c9a3a5fa2114a155a0e6552844a0fd3b219b908fecb43569bcd2fd49bfdf8751b72ef6f87da21145fc89949dbc71cacdd4676f3bafb799c83356b7b27279facea17e82f166300ecff023124cf251ba0cd2af628e0d70c37d1e83d187a71b07c5922ea3529fb5776c30e239efe2d8652a1d514f594ffd676dd02b381f1672f4a160cf160d4ce33ff91ed44c2094b562677de80c643be09538d72f9bf767482d382deec45884ecbf14f51e95a6804435a0707481e0bba448eeb43a1eb48e689d77d82e80c7d62729e6c86157bffd030d423411659c65e2eb929e34e64b5be9320b451f241e15e2e086fd1ef4ee37a5c003ca78879630477197acdb40570f0f2f2e22b293880f0b1ac628e095472f46005d78b9505ca9ac7a5ca79b7d0f548c4afab4be59c3bf438671ee629dd575eda3366695cdb307319c7ce7352edfe83f121985812fcaefecfcd85e954d17c852b7518426c0f4a20939a140461536d047f0fd371361dff09836cde27b75efd14ff79121c6a65ba0d9fd7257741dfbecf4651488075e7248e24a63775bfd50a69b74cd3ed62fbb9d351386594c97eec1e9d31eeafe15f1970e274b6a07ae6163964530ad58b2e56f212ceef37eff3f024f02c63b62e0750e8960d59324a5c6de64eb91908b77eb083648bb9d1cde21686295fea8810dc02a8f76055d074b0554be540b6c8f83b64a3f40cb8d744a9bd3e786a51efb6457607c253bdbfb10963deb42d602a7a70e3423294beac12b977cc0877ec58a409a784dc2e1d537dfee7b79351d0c95831fc6bcf945a9f178a10f694aa932d8ca805aaa9448b80b5c1ae73f6fc7b24563d61aa41748e05eca3298ec9a13c26651943c6ac9b0e1559b6f08dbf2430ab2690d9a9c63e1d33ed2628c60604a8c20f760ed3f09a0113064b8e0cc0276a50f30a1e0a26b91778f435625eb22957eae39d938b0f3811077a12e75ce29e0b0a5c5cd01afa824af918800f76d3eda3ad032e7243c0f3f8233b8c184f8fd8a8f4889c0a612e78450231c19ee4c1a00464394eaa6d430d5ed875a1f1b0e5691e8995e3af156cfd361aab8d48dcd46df321f9cb7c316fac572ebd39fcbc9e0ec52a729723f04f1c48727599104c601f40a61f408a6bc8c36282b4649382981be87798f4f268985f5ae09b3649cd50ddeae0b701fab78d2561b1636be715f1190cfd669e3cb7c9001f63e6248590dc4e148ceae8a85600019404f63e04ac4250b68eea95a16fd49ae86703d35b3066ee7a1ea30534e87a719b6687ec2d280f77489d2bbf711903fd9099f3c2d28e652fca360d7eb0f41a77dcd28ef351b08d6fecf8ffa66544588680e0c0c4acdf003bbf6fb9e2b11f6f1682766ec8095a01dde8a6562876a101654d463ba027e1dd2d1cf517940b70d18a311b663748d8a9b5f2862f24be9012c4ee266cd1c89712dfe90ec08e153da1acf798fe34846b6dd04d2821c2647fc18fa8526636a47ac58597ffc5a760d4801d1f36fc6e6cc3a909351eaa27f87d02e8509e51dd3cae5bd7b36d5bbbd086f8d1aa750437b169c09db9f99108a8318fa2f757459dee177912fe595bf489fde95313cc286f253cb066db630cbc9e40cffc81a3ab83d06bb154abe363cf17b80533dbfa051d3363204963c929c21c1aa688623340f19acdb7c64edbfb031c9e5e073a278689458cb155a2bdf5e25f5981b0dd7c7233f888417974af9b4f8f3d662c0aa79c2685bb4b387bf5ebda12f8604622afef6330cc63b363046c2f6b7fd9c8edca35eeffeb09172bf4bb2c43493f55c2df7a4e00f1dac35016cb9920f493694a7085366747dcb335f8463e7517b7fa136d8183f3294409a32e611121d55550919c2775d8461df34f5a1252ed9e90626db972742f01487b4aea2fea70f64232896a5835212d901f7140f9a40afad76b99bf83b15f7d8f4f7396d13f2979cb7880af87fa69c0b6cb4c8cf375ae6f2c57db2d9c2a27de145bc0ee6cad69022f070023dd46386e2784bf075bc2c234cf30b5a0cca3a30412e3f836026b11d0b71718a50c5632bb7d045b001c39d6c72a28bdbb7fb7e2b9d42614e3e3f3e6cd52580950f9aa415338da8813fb37f1125a6f0f0c4b6540061756690ec816b855cdab8ce94ace5668c824bd56d10b52eccfb3d050bd9208793dd218d9e56d66a1ac3f56b80d00d84ff75ba19ae4c5b35cf239c283550a315fe27991268fa979bf20f481c0f632da001643dfe8956b1b78ab626a1c200e6ee10b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
