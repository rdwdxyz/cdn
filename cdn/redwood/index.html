<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0f108e333c8ea1d2e08b902180b846bafe6c7584467496dc6ab4beb62dbbad5d08475d4fcf1d357d3ae02a424a48f26da1b6d9f54032c0575195deb3f92e96ad378dae2de6e00fc94d3bae0f07925dc0c357db127fa0b0f8596d6d96fd902356a6aebc228481f775660f7a94267bf2deda0b549f88cf21944033019b05fdbe77de0a77f2474c3596da4c75155ea1eb47949f4f26f5c079af2402cce7d6506973f907abf7295f6aa66528e17ebb1daf53f2cc9e3653ff6560b78b68c499eec5688c0f55afc0ab0a229393a99dc7bc3c3ef77f65afb83e10f7c6182ee564edb253b1f6da952de3372c719197fac273e7cee743ad502f3b27bb23c8602003a155a5be659cc707d8e97f6d837762dcc366e194595687bd2d16f0a1694d8e2a0eaef15b8e8677a8cec012b78903815d9c2713b05fe24e8e42f9a81e1e742fdb044ee6c7811be17820e8162dabc0756a0f7af592b08ad7445934698fc9f186e15f375840f9a4449b029df8268a8f86ef6a9e5f2a537ebf0af5f48a120d5dd8a97452fe140bf00df54e67967c9197a8bbef9bf49acd903ff464776dfc0c67f1d0ed1a38711d239c738ab2a0eeecd2d0e7edaa273a1dbcac910fccf1f2f3810fd46759f42f5cac20473c8a0733ed9b9006ff7f4aa1a3365338bc4d23022f6509de27857624fd303633c5962d9011e2305f7157bd13393694b486eabaca0a8960e918ba417d21aa1a7cbd20c624a33eb4992022e5585797a1e090f3a3e9908c255fbd83911f949c92d322741595d2a2dc50ee3a3077847dbaabe98dd475bad007c7a869474dcac635a2db075771d4d20d526f9dc3a8ba08834839c012e65c7e78068b09f54ff458ebe1988794750c1b216e1627fae0cdccc0bc5effe1ea055f560f96eb524374155c232c9da8a9c22942b7bb8ab9e1469b2797e04e61e14c5d1d35901858c29b9313e45500499cb1ee92a46ac61144123b1961e788369c2618fb4b325719c9e85cc2afccd611911cdca9684a9e4ca7b4256788c6eaf260b71214c197dfda1f8bb53883a0240a36ea6a30d72c3a747ea389d3c5d523ff58893dd892c97df52640ba21b769dfc9122fbf6a2a3ec83aaf5aff926a7423c14ef6f6250360090c8f00e1168519c496e42fd8f277f20c33447e6125f425b771a419fae7e79cd9e927f41d50c405614f45b5a620d733150d974e7e730a0519e8e9a7508f22682b960ce88f2c09dc2d3dea1f6abac0628870b5235c3bb7a31e3087164b04b992f0237187c3fc468cbdf95934e0a6f1ca4329cf7fdd4da3b781e7ea0950613a92cf9041dbc5ef93b327aeb058bb3d4bfaf439e239544da6e8699fa2e07338a827f3788aa9eb010cdf2297dc246fceacb2804b92e51fef118e7d6ee5daa5268cde1d13fd4f624a47310b02f4a0eb6068fc2939cee4b2852a924da87af63743f7dfaf0074580a18561c31d3930c57c690953e71fa2874b284f91a5cdcfe66b80e7c63b1d100e203bc980cfb902c8409359ad04796a51229b43654932aa9d88ce05d7c925d8a12f9e48c41f40aaa95c629f67a0964cb27ab150ef801b1bb56f58b78d89c6fd2339df01cc794e68a82dcfc887a6fd90cee1272bb4bac1ec365bc8fd6846fe24fcf79b48a4aff183f24ad58dda0a29ea7d0f9433a603b71fae9bd16b1a556ecb9acb1c44d67a842470232eba19c2a12c464ff700975552cf75177326005349b123e4684c14efb3a21352ecb0cbd887c32e9d66a7d84648c972b89c319beffb0d69fffdd5dcd11d401372e3c88b86a2b4592b7027d7e26281cbcde63ba2c3abb3d40d444b80b17a45ba6c62d6fd79603513e2ca46f270e75c84f23014bd7afd66b8b9b426d3cb398dcbea78f5f5649b4ea7def6d5c9e8bc3673e2da7effb1cb988501ccb72b0f4e01f1a6830cdb448eb2afcb5c87cf0189e7f444b52c6d40d9223f3d74f91a4722c3ab79c72716457397500dd9caef85d99f8ed387890bee79c886436060069a7e1d2b6aa5f8696197ee994df0ed5531443be7e5258923400c6614c2e729d1e7d2fde377114436ee78975d9533de53abe6e1dba8315bd11426d8bcb5ecd9a025bd49d0ad85f4ac33351b01e065e61253b2c2b0137a5e473048ccc7344952b7a6a0d17d425c5f83bace2454c11c054c85d4ed45bfe7e14eea186e91fa6f27e9e91bc62354deee3476944a35c7aa971e884d64f08013f21d68169c99a999f716dafb580c092bcd8c46e36035d13cd12f211bb83fe8ddf35db0c4809cafe365245c8e4039676dd1ca1adf853c7c195320ee2fe978c8b9a97d9a9a445c125a1d30db7ff6655c5e41bf883265c05291ce01543d23baf67523556cb021c70f32ad923357f555e3915ada28620fea33b50e988048bbb7f7a5570579a8ab8908472c467be2f7762ba30393fe2f36c2b40aa4bc0200cdbef787e022045f946148d020ae63b78281d9300544a5d867db95d21dcfc5c8f8bb6553712b4707fefb2661d4a63d21e821f465febbdd805198887e453c57c67cc1b97fcfb6cee61d56f7287c4843217baed2a832562f2691cc4583e1c46b583495573b6601b6136de42c64225072604af0eae9d02006aedcf845bbd376b63773324c8c51f617b59116287ccdaed76c8663637026873834ab3d0a9369e3fd592bc9541180e37cc75af98da1c0d919bea592493c8a141bb530399f2b8941fcd2b22d70f331b5f11a40e1a7f7170b0bf6cd9be402790e179acb2f0b112c7cc9567d9e93edf0ce9027c4d9c0bf063d596168a0d38550a5500470381b7ff4db69426378978a92832c4d7bbe8a7b69bafdd82cdd673aae6947025476d43f0309897757e7b33d7d339a56fcc093871f5726cf66fbd80d5d3d3bb194b863a511149dd052f036c7b86d3eedbe1aa1a6cf9a7a94799ee3ad22907c0c619a0aac8e3c0355e334f8f2bf38e0352900809c695166f759db7cb68dd95c4feaa611d145afa9bbd0fb7611aba2c19b334e7f3287d67ae73bce52c4f3d1626ac958fbfa549ae4abbe389f105d213fa74c300e6f5e1b2daabd4f5db71a9bc4836a91f443b8b5cb1bd2bbca801ea8e2d776948d3613fdd935fd141d77ee88f338410254fbbbc2f63d679846a6c0ae82c2086d5c0dc5fb3d64298c94e88b0c49b21296c337d2e389998a440934117dade06002a84fa68894127fd86dd05eaa62f0f15625e41d5f019cfdf0dace20196e11e1dff9e27736e497bcd73c1bd877af37813ac347c4d3686e7616d400687ea60663f5badd3047cb2be3c5ea467aa6909432dfcf72413e60b29dc3f1839ea660ce9da341e0c08953164ae3e70aab8e1ea380db0943c454f622dda0124c08341d4c985c6f9845ddefe0832337619851431028d6470cd749ca8902a4220db62161658106e3f4fdf9063ba3152b3ac578cf6e465186f7bd35d9c70f73373577826e8e238d316ae9356dd13ffe2e23a9aaf94dfb52aaea805203083094a5a38f770e59e2b533d33a329c030cbbf36fe309bb6c31d48c20b7793b7f62ee15ca11a3c50d2fc8be40df49a62f793cd111498f1a47cce41697727989fcd89ab1afb5e6e9dc8b24c9a42db7d8cfcf9b52dafd230d59009ce067eaa37ed31f117dc0685b359be5a3278b6f3f83edeeb60d6223b94fb979f6dc565d50a171774e3ad03180099c42b1bba05575d2a328d8a2e86a8b193b85a8415fefc5a1307c6938d68c0a4acc03e39d0c4cc4c6fbdf2c411224a72b6db927ca769e9a65ca9cb52cde1d9c65f5660704be5e2fe811cf534f82d8c3af79bbe6a0d0af9491ccdd5ff71795f6b265dacc8eb8fae314416dfeadfe5a3142b0d2779d1ad1d614532a6d0f4e7217d709ac83af68d469fe4d442eabd7b9551d6754b41f9cfc39a7833cb8f856f8af63939bb81760c40a77f7fa5fee13abb9e12a1a60c6bc3cf918ef8f60ec80cb924500ea739cda01143b099e8d71ba65808c642b98e32be442336a1d456cc6e1e0003cb7f718e4828d1b7ac460a7bc91a07eae1d7c867f832ca9bda3fa4edc24cf2719a41a49641f4a30e4bcf832d4723aa96a1fd59084ed3d97dd25baca5753e9c3c5bb854a00ae6829301ddaf5445bc06b0ba2c8441f2ded749bf323a96595c18d53bfc0ff335fb80ff4131a5428cb449561d8743b2e3a36a7df0c665361b1d533e0d5e02bc56e368f994b03914988302ffe7995bd66e4b0c6d2e8d5539c3d2fc30fe7230e84ef820116454a84d55df85b697b8b90ef3e73d2f56e3b006a0c37576e623f13f527d4b982c23001434df7e8f285a04ba70273fe69bd677bea2dcdfe2a6c263eb1d6cf751b91b80c15073e055abdba87f7e8ca08be56a1e00c5e83d6087838801754ae0f380b11c9065006900719e7b940fc390a9e6f229150a8fd2ebba5e34bced7d72088f55378363b984c3b592186863c521b82154f4fd20c2c42c104aaa95dd98ecb865e60f57a5d00d5c539c5ae3f582480baba458fd374149b14bc9cae67a463ae0a396bf4e39034b77c6f83734a76a415ae1e62e59aa920d8b77e4102c5e13696b074a8b9b54fb7e198c31060d4a8f9941dcfe63fcb93a2bb7da537bdde4451199214d39b3eea3f217125e1af8f6633c5bb5aebb341239c76c147a1fc1bce146810cde243a3cec4cf6b8b8731cee24e66290d1223f8f0ef51fdf0a6e07b53bbb01fd893b4f3fc1fd87dc8bb9068c0c855272ccaa8f608c505fd9df77cb5ae243bd289400407de508f906831af25d76a603b136d80db8917a20c3d1fd05526fec454544983800325c3c5e5797bede828608f56aefb9ec3f530584e7fd8cfb9edd56c22d0901eca569e4e11fba1813b3481e4a4402ad1ab3f03627c1f4bba6512ead826a21cabb08c5dd178a565a39b88e35e38ed1a819c33374f8c90dbe0f91045fecb0af8b549c53d855ee26cfd162ea8f2b1a35ab807c5c5fa8c12ec95a8bb93eda0fe032353e3f1d21c31f81845ce0dfa658c4ab0842e7ba22f11e64c9596bf04dcb742d29e5bac3fb5d218befe1783a3a50b99ad8b5d14b5913f30766652e94f46079f57ddd3c68195e5125f5218aa410eb7351e7f79214d03831d150ac2ed8711697d88d51e244d65dbf0d2e4a28a2520b3d6638d5e045b5ebbf0bd529f098aeb3031a1c0b1b0aa16d38ea7c72e0be7f249b2dbee8951a0df5a3013cbca1f8fe8892d4e92956ff40ba9af7df3212165092eacbe94aa99075112582c426a72cfe9c9c41a39224ab0c33543cc1705e81c75bc6d6969af97e46555f8f6eb668194ce2ea8487c3df839511a2d02fc4dda3fef830dfe236c1791acad1c945ce9529fddc8b93f877ba0e4d6a58b10a566293d829c5f95e4990a848c6971ce9ebe022758f613aecb316577a7dd9eb743a189d0ce13dd839b345cb1842cfd85d2b0af8b038fe7898942c1eefe9f01d0a85d1555cd99ed21d9fc4c177cb868a9fef67ba714afd7e689940c71bdbcbe4c7997a299dd2838663016f99e6fe54ff0e6888d0423c6f96799a09d1973ceeac70f7b57298243dd9a616f65d154be4af386cccfe65a94d751bf3408e77038212bf41e2969745d685cfc7950022e75cd5a5e2a783b2f5c5550a9025b80e33fe35f6947dbf57228f5d296e7d144dd9ae3f9e1e7bd1cb841cb0fd7374eed307ffed3f13ed05c47e5b30690e03526c4236f3ac7ad05a4c8f5b6ea4f0aedc6133428fa7e97acbd9c1630e3a995e2d1d7bcc6da0a481603f9361cb4b85063902f4c5ff3aff60b92e11b63886e2969bb0d7f06bdd60e155793995273e5eb0ba2a36587f465fd7a0a19383e9387753fceccf51fea66b8a4af037ffd53725cf54511784c15a2e8ba3ea2e6c341adb334cfb4ab4661225555118211ae356dd3680f24ff39f172bb9b8301165f0fdc1896d9876294e78e716f26185ca51bc13b13c9a10ad79991a5b83373ca646dae14238c2927806bd90947995279e39773aaa0b749143ab57e3a587a281647911ddd5cb2455842af4efe99b5c1f6ac58c85f54a25664166e573bb8908196e814fc11f04ff6d91b97f33d925c9b7f275c7369343973322bd1e6aa083de2afdc46ebb174b8f86514b457d9de5172dc1c60cbe82d873eef821b9d12c21d1a044409db420e37ebfb15fa90e9ce896c99d11e335c9cd9a03b18180baf4834f6189a3a6b2c6934b6dc2244e97edf2b1f52157bc741312a41efc4cd761c06735c0e293f04b66d5095ee716b90960edcbe4471f552d393920e59967b40c765e55e0b389474ec954fb09c2f3badffb33a2f19b2bd8960dbc1485d6d2eaaa61072e2dba2513a2d2b38b9e108b8ede1fb90d3dd103889af33360e10fe9c72437a21eb16114b820795817aaed9a12198324e6ff0c592fc131baf11f8e61a82ce68c02f617a8b614f529148e6eb9abfe8af40429b35bc4148e881a178863626ea155ff0d1428ad6f68b66f2a650dadc1e084fc87a93ba884650f27cc6b7204449529c8e24145872eb1977d5589b3f5b7e51d0a685e652aa74c3f369a54c26c4cef33481c681f2a5bc5779124717015a680014be0a8d0fb5df1e6e4c4ba9c2cb24082388caed6a5cb79fde0821b219c721c3f660d703e66149dfaa65cf24c4d7276c4a07bd1161960dbbed19f7e8fe9bfca7a287766987edc81ff6beafac01954210dbeeac14e544fef3011e4a591ecdfd9ddb6597670405a67fdc6a128c04b741e73d9e2a8697c20e39900e38ab598f46ca2ce91756d88ec8e9d2101f1101e26c061341c2ed3fcde528e148cf646ea8013887bd6862a444550bba52c64260b2de84a69af3ef9716210691f275cda107f1daa5e79e3886b7934aa4d04afaffee10c9cbf487e926cb7f26784b8ab023e5a92ae11e7b7275907f977405c0a2350ab26d70653dcd9eabc48545a01c26ae67b195e9093be912f4f21cbcfdc961dab12b88a926f7a099429189666c2d289d0369319484d4e0e185e82814bf46af0133ee4798cdee207c2ffa173ddf6b7ee087b98360f8959fa146d543d86dcdf71df1308877ab939b8257c5aa3481d673a211557f45fc3b53e6913af615bc3f51212c8ba5bd81b62c21953a7e17c9da6e6610556564758659136082be548fe4a12678376e06f537646699ae1324669b316f93ad84f5612fb3b18133c19bcabda90ac44915fcc67c5241d246679aeaf2e21b40d87b6ebd19c0e155f49740f809fa80e55e981d7c2ab736efeb054ef4dfc1992a2e78585b7d46d10d31b9bbaf40efcbfbb0a56bc9877703ebc5b982e326a974966ee46ab46a563c43eefdc40af640158d56d6a4149fa2c6c77ad6852cf45e2d6a4d0bf0893b64fd24d4563e2c374b99c433d7878c89948064ccf9e2c3b35fb678e4e2074fb1b01233d4baafce2a27175b124a9c2e7a6afb4fe5f5d4ca1b8cb6bc857e6dd2f0e14a5e0bef31af28947ee641900192bc7433ebf8baab683703a86c1463e5c8cac32903b52716c44440b582042d2545da505577de69e9b03d13dd428743796f4b7e8074fa2206c1230aea6957b46a372d2862d81664ea5e0ff8bf255ac93769c65e8b4fb525f9d336d165c60f8a5cfc4f5f9ce023a0537c948eea1cfcb1f505a66dff8d6f4dd060abf5642862b549ca612b341426fa709c5914bf912bac89015e3d48f65efac1131bc4023dea176627ed742b77c64d46def05acac175b4682f71845aee9934d468834d6316501b5d7fd124866891697eeeec9bb6b2bcdf6ccac2e7c2c0b00d103d1b035ad57fe387c34db93290c1f1fdcde0a2a7ecd8fdbca3606649ce0a167205a6d941f7a7f52995d2e48abe63081423f32d55d4fe7d738e657bf79d67ab8598d59b62935634996624d0e6ea3eb972bb0bd220c3b9d442ec6206363739e2246e22540a3c9129cae4a3c46368bf932f9227bf89708e05514f002a7e15169c5ee5f093f7b5488f2035be5787f78637b1d1de07bc54f2e768e0297d4aa7aaf956bc90444920cdce13daee17573fd7b2353ed35fdfc10d277810b023843785cde6db2bbcaf5cc673018c46e6c6cda8918bcff482983f3e4f02fe3eec3d743382559ac868dfce7b5d754e7b7a00ccf518772901be63f59be55805c7d56afa83b98bd069ea460f8926ee2f1ae92d4b4d628ec803a17f0024f492484ba3cb477c67e0c0d019385bc6a1ab16634ddfa71910ea63babc6ac7b68bc27760c61004acace1cbc56286bf43498ca7d2f37ee4f7f208af7ee3d26273d1955a52e32c58acf959cd700cf21723f7df6850b2edda8a8ec984caed1ae0093c54c1600f92bd32ff2aa7a9ccca7ea4337ad9f02de0f85428a1e4c1845c3935729080f042ac9c19bf6bf143ae23025b1049078c14a76673daf00cd44f1610932ae41973eec62186761bbd8fca4e0d678ec0b10fe8725775f3df61f826fb3f08607186f26d305728ce39fb566649263f1075f5518e48978f2b15698be625a63a8e1ddbbd758c5baeb7f863990fbd5336932052dfc66b1fc59bf9f6dfecdf7ed268a3f9c176e93d951f7fbe2069dc1f35b7d13460757e88007a2215d5de6ef349fc06f5de36acf1437deb6079124d860136c1f8dd7cbb3d95b739a0312b53e648360122fb840459a87ce135458cc2c66703bb61e05505cd46e8b236f03d9dd883cef003240b8f4c74c57509097687e9d4c125370e65fe74f815c041566b411f8d3587ef4fb5618f1d713fa8d71aca0c1be0044794157088ce6932c5259829f209de5d4441909381cac757753ae884acb3be0033ea18708c86fc3472d670b271bf10856ece37d0b677db1aa92ebc945617802ce12139ee0568c0519f32e4ac3881addf432dc0e35be5a52fdd5a283f21761d0e0d0c6a4bed67cb306fdd970c8f2b4fa7ac0e5c0d045cd5d3f0e859f3a6e59199b287b048426acc78cf2f9334e81ea3d68428c11582dd5e715f2fd75763814339d962295a0c62e0ec4a3de345531bbea60b49ecd2d7dbffdfe02ca5583af2140b0ab2bf3f0ba8546cc5e1aad0983f5e3bacf86ad81f1b5d6bd4b7fd3b91786574849f773659d0e5e234ce55b83d98319cb30d71213c58beb66f6badef5cc5b005ccef38d8319967051888b13a7ae5f5afe4786e8209a3db3101bebf1f333bc51d09de46b27e1896903765eae9a64834834067a77233586bb1e56a37439e1c611a5f6f6a5894f7e5ae625242ae600a79814f96bb5c163ddaa89d54d32c45eee043430938300d56b2dc5e57230d42e495daf14ef0013f45596eb466274d26d03c90661f1f9794cae21ee292a00c07336d6046267a660b97962218b6694553d60d492a1dde354f5c923d12ee3ac4ad11dd2ae90cf3c255de8d6b0ad98989249e304b4ed2b8829b58055fc76969a43ca252e27b3ee02718367fe333dfc15eab6386b11b47bd350df895c6c3d103eb5c24261cb64ead6ab6880655b476923891facbe9d9043f0dbab1d4db98d09bba36df155e9408a2b25699f9292a122b916c2c24a179aeb1b8bb6c81581212fed1f3b657cf543228924c181e40914fb0b0e1cb3efeb5ddcc8ab83ec11fa07f485f00be29bc764ab6d99d4128bcccc8af2a03831c45c20f5002d39bb555c1a5c97f341d9ee5f6d845963a8b6334b901d0a76a12ba37605681dc9d9c8ed054866492a47b01bab8c3bc048be847cda9d94eb25d57bdc33bbfded5639a2fe745c50463761535cf7aafa3d4619971717bf805dc280b70f33537ec1ad433cf607396a9b974c6fcf39ff8908daf747de43c7d77b1063374d6a0b312dd2e6b1507bf863ff1e6b831080f8cfdbbebeebe655c91945f8a29d0429b8050e0123ba6977c86e3aafc36a21adfaaae82f4c65ccf518c7985e4ecb2e4fa6cbdd70d39e771059bb6e1feb086937726265c85127453c833e9a39e295d7a4a98ee8ff6ffcf903f46ea3478cd251cb33fced458025ca17ed335f43b9cb16269e65ee9302f4c7d0067305c6ea8ba71e8babab1d5fa47d151ee701e6811591db7bd25b08745ea872a8b6e91f968a3ca6bd026928f86024a568b4270932bedaf7d2337f82e1e92b899cc7a5fafe1651148a6855266f8f1088e799096e306a88aa7aea772ad33b462fc4a3d9c88779590a6fe40d1e7adce1593d3a7769c6c42de6bd8026aaa61a55b28b72819470eaa3f1acaf4fe4657151f0e9983337e083cdc43466a86e60abe7033c82f721428fb2488c61a014d4f4b755d00c006baa985d0cd580e7089cb37d2b44d423915d8be28675b28c76927e931900a0a85e472992926b5583d3033e69949ad4a6e5849893e4bb602b9a91295639823a85bdd05a0a551fc5d84a73df68611e50159904eff68f1a5415cde8d8985adc0bac068ff030193544fcae07398478a07f81f99b087b2bd57f382811935f42c72c2506ae3c2419663805b38c49bf93ab80c8586a5ca976cd80352eb4fd697b05295055f9801c4ecf6920df09c2a5733b5035d3bdcf6461f4c25b01909811de16cc72ae2f541020af7c1cd9addc8d6c21379f780b40c9ab08ea18e1cd854cd32542faa271fbc738b08f1ce543458f36b1ee84d29c3072b1ac5ee62b276cdc49c0f2bc9190521332d6947edb13ec740a9f7f97407fe5f88ca2bb6a3d9eec82b20d5e6ee9f2cb25e332200b75caeef16571c0f1ba656877dbd6661804a0f7ab812b139075e8fe6296b1cd0e23f065eced43dfc533d725d4cc0cec81a8283c72a6f8f5127dfe89258117c00981622b0760ce3521d34275d32bf2b034bc083323183450d2400379e1f55e33e41fe3ee53e02ddd0d2974364c6073f05bfaf94a94a0c03b6c8ea832bff1ec3eedcc1c3aabcdec0dfaef05c68efb15ec707e99339b858e34b7b73e6344a71d478cc2db73a875172fc168f5ee798f3b9b6db7cac690846f36dd5a0c65a8cec6095671c6aef904fbd6a5b746129d0969da0a0db5a9943473cccf89720e68a895f2d64fe6aacb23a52735f2a5515f4c3db9294f8b571f63c813818cb39e772548bd0480065b05cfbe18e218cf1088e06bf5874c133ae7cef228ef0f165580206fc8134d75e2729e9b1776c54130cfbdb983724fbcd535a2d74040c17877a93ff50d7951d7b66c0cf6952cf18455bd8c4bfb61ade388e1382488264ec9b2bcb47a996f7c16d683f6eb01f22f62549bfb94c6c38981a6dca8123dc4936b81e4bef4ae050477c1c997629b981cd7bc959c98dca27ee485270bba15fbf976df7244e1772d84972dcae9820e81737517b679259cd33f3ded1550041b86416fb434b244c6a12f75ff137eb69922a6308229f6bff95a8361f3dd1c0392c342b049bb853acd5ccb6d5164668dd93fa8f1b9032ba7529486eb79bf2327f22910a5cff319ac099eb24f2732152cbdd3f06a5b1cc0117c19f7d349b4b71b097d2197c88b756b4c7768b791a71fb68d63bd451857d338964d39036d5ed95453480c5298d29e710964ab7f280d6717c1277b011eac6aa7efd52a50464424ce2cf93bffd196e3f42b2c252f8bac5acb730627d4462a5bf44d681d6c19981206f57c4539fc3e8512972d85a982cb2e4cd723b6314802fc19c1f1dd691a3fb5a5cd30f021f8655afc925da74e46389f8f03b37f4d5c88c848196ae2dc3360c5f62854779928b6c8ae3c9fc91e6dae8d0af9bc6476ced1852b78fb63000ce90f171b1b4c421f3fb0767f13d3372e4916f07ee6ac32d522934410d38349d0be920e53df13d8b0330b0987c08e0d3241e321655d69a66a892e5c9d2adb7fa46338d675ac0be60703df256c1177d252edee01a92628d3c7de438c73b70f9655cfb459b403f7e561bec9f3168e811282b395565f73146d940388cd6fa626a63da1cca96149708b235f07423fbba8bcfd7669e4daa9fe601030827cb79328f04348020b78c7c8c9f5c7d9177a1e5a097e7eb132a1e3d4f7dd26fe61d173904bc324486f6a7dd7a2e06aaff559a6c174177dc01d756ebf6eee29a51eceed91d17e33b90d80e9cd4eeb9568c7231e1e2ac02ef12b81d6c74451091380ad3967fba4dae96ed265052edb00f4fae2eaae7ad20c989990f375d18f55a3dec6159d5702685fa1f2f7bcc1c8228cfed60e9b57439fc1cf5178f822c967700eea6a2416159621b6deeaf02b0cf8960345d57b873f0f9a5031db57b030490a3130bf7fde0df9edf4a5dbdedb82c6f67f112f975130c35c73f35352983e1e12007ab624501da9c26f2cdf88740f9a0de7c9c1822daa0fde269cc89d253cd7b0bcfdb2981051c42bdb096d101f0ea94f61817624f55cd19e4c2a2dc47578af9753f826f7567e5471997980c77474d853583aef237523654b23ecf61b272d956f8eb921b071981a53a6c8bbab3e7e2264e84aace2fea1e704678e9598cc78dd4126cd18a9426ed0749b4216404235b0922e1683bbb94ad92f9103d94ea0b47bd88ce070054a9cab1853dda0fcb5b8ae4852888de79d2dd4cbaa717dfb6dcaf71ef74ee92e1b796f861f52bf12495286c5e9d8d7fa4def16caab30bbed7f2a97b55715eeab8f2c13f8f098868bc8baa71ca231e9aa1eb02710b05e56163821c1dfefd5a0304f258a2c9dbf955afb4150b676dc73df1721583f4554477f0d689d867ccc285cc69be72e200ae36d693445e420b5ef3bff6c47b4292881534497b8e970967b4b6df616b92fc07bf3dbccfc5097de8938c03f75e48846477208c3600994cbab67ebf40860abad503317db453f5d6037100ea399b5056bc887394e9148b736cf26d5d9ae3ab3230e942a76c0b25ae799fe1cd0bd85fcdf8bb7630864629afbd9b54f85f6df632c9da28af08ef1e998b0976cb71a26a7d7c78a922e3de0963e4d7453b2dea8a1937938f174f61afdb85b80f788c9f5457d05b4d5fce7e371f8169012c483aad2178f295aa12208a7d44d25cab7c5c46b9f2a8323371a2789f08e357c648102f57587337e179ded8742a98e5e76178f39f6ababa72eaead6538c2da697701a462b5bd0520b9a440956c39e1d719f0c7a1b5986a69ff96a04835d4f7ca9c71be263b1874cdb8df5f7cb304e81707e848d477a0cb9f4c19c9df152be68ba200fcbf395fae0ff7df6f576a434c182d5edf2558b290a7b0a028aaa8e2b98b8d41bfa280f2091b83db613866474097a808a9eae88dd7f790bb9ca661589311026edbebe6e7ec4c31be73b031a61e251d5b356e678a3b6028d118a4fd8366075eb1f96810b5b0b298fc900d3163c61bbeb7a2ee02008ba9e784f45943600ac4c79ed961ef45faa8cd212a5a2d5babc4652664a2bb938f3a04ace0ab2144c63f38878528eddaa09d6a358f99c3a74e4aa2333c8323f73dc723c04221900461516d443ce879d80cf0e77eaa540a9496ca405acf6563f462e060a9a1b16a702b7adfaee0ca01e04091864fae3e8dae5af010e016bd9af76336912f457df1944e745b17101f2e70d8320b1b114b50d0e05a226f90c26bc2194c1b07b856054a1bf73dfd8d176fc0417352d5af8cd56b58d49682103c9ffa5e21b7efea372fe66605e043cad2badb068b43b8639579ec78defe66a32570c08442fb915b8c2f29a27c0d8fa938f9f16f5feba383d1c3ed2424e97bdbcfe4e322419cf5c1fa46d193a73f78caa14c12f10836af38e87934deb877c2bc7040f30a7340feea7eb815bdeb81c5ef805aa021ad1c330893e0ba2b6b45c86d40e32a8bae35d62543d1a21ccc3f9f15a67cc0df41f222e726857491e562f52a843b6e2138550a04c21412951a7c14f90ec8f29368b61989aa85003fd2b6255b7fa0209e29df36e669618902dbda86379089d7680ce53f977925065c7d263c889786d81e2344f394906c97166aec0976c686648887d0ee13767675823d6a52de579969a84c495775fa9e97cf25d510cd6b4d5c140ca4d7efaedd0afb92695ff37efd63e9b01d560e18d906e5097e4e76a93e8e531b157b59b18b57f509c17f4134c4fc87ff78bcf1403b27c2cd1e49633eeb921818997a0e1989882e118eedd4649cfa772b0c7efe866d3a0b7cb7629c19772a857f65d95f440de5558556c490249c6f9018c818559b933d83bc6526f2012ad9e9412af614c7d3f8f52dfe470f3a9dc719c0ae44c78101fe17344124b4e47371c043f74dac25d1855df292880be27e173b721460ef84dd6990ea6b9e9b0c3a8d25a8b1176daaf55dca50785ddf6f1be556e48948268edb71657908f27e6ea7717707db9b6fd499a32fc923952461ba2b12eb9e4a1c3e118abe8d9a65c1503769ef3bced08dc4cf7eff0d1eb887f3de90f1a275204adbb1f44597851e4e44938f57dee0200174d115682987d326680cadc68822c38148cec35b3d1dbbe98be80905f5311bec8d5cb3d7ed37319345e02d7c8f1ad19e904da5bdb226cfd0f8be0bab84d48ea49471e336038c93197ea18bfdbde4e87ff867de1908ae474396b024fa9ad040bb5f4bf112b9f9a3b470cd157ea753e75d08a1d4b6afbd2e2ad939ee59b9627061be123199e71c661ef840472af060a3cd2b26a2b3d2eda50a0c4a22feb830623037c8882dfe795cec11553c017971b8952bab573b0d4538d77a19d364ff13e87ef96c226cbdd67984a1ff16baac24aef081b0323e37c9a657890be46aae5781bffb281d6bbdfc6ba4966ee7004999bf852f07f5b3b35bac53d408511fe4e8babdb273fbf393e38b54fc004497647296dd5c6c95f0e2af53d555c5e654e70b548f1921287ae3e8a8d0dde649457d1734e20b60fdabe786b50a9464638de68c5d12f6584034cd3ab8e0cf2868905fbdf2a58f24706a1bb1d6a1d7ea54357b24e269583b441ae6479491aa21c3a5f4e181ed1e79ef7f10604abe184207b8ff6fdc3c172017b09f7202283412836d27a1550a53f10af5b4565d3ea072e9b2571eb9f589b2f050f249304200c4a0c8bb243e81c128d5910116ba2a2fe9e639893c380e3b27ec0a4f4418748701e0548548a34e9dcd23fcd97653797a0536dbc2693721788af456a34033c78820b60b5035f6b4a40f7162dd87ce9edd14fa8d6af11bd58986aa93591f42a93ea3d6268992953bcb026ef485000a4a14d9629001b0d6815fd42166827867533fe31bce9b92f06d8152c9713f0853b386a5385ce9e5b7812adba9b62083a5c5475d4984474fb2210a86334a726f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
