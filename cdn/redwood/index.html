<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab6b262472b1f459d1bf575cc191872e067200dfa248f42b808fbb3733d4de7aa396df4d7524b8c8fd62f25105a0a438254359ed92916a1f3f92c1370ebb1879027d3847d4e5a767e66e1212f8d9a06fb417f3ed2575f68b255e7ed425617e4d198befe97af35deb7a353fd5795c584991596021c368e1c8ada4e1df22ed67cf85fb4f93ad3170c5bbdb7fe23d46bfe9bec98708bc90bf195c9e7369d1e429a5abb40b4902ce642f1d6bf3d3fc207532c088b04f8722718cc127eac118b843fb15690e9411bb6ffddb007c9680653bb347ce3eded68210a82df6fc34dcf1ec1f6a46d91008137e56e3ccc53517dbd73df99c2aa42dff16928367c1484bb0617f7e3bad5c6aad3e5394ca32676db891c0d3ebc43f85333226e8a2ef8e1b7f13e18671659b573dfcbe8fd9ba7401e37ecd7b2b6eb91860b41a97435ac33d71819f1f839222ea9fb5bcb07a69e288d1df87defc1408885c07a8e1cea9ec58f62de237608711d9c088826046658f29f3f471013931d0a546e45ad04956e2364d849d1132c34cb68079127b9ca813c1329f474398092aa7b4b0e40fb8998b162caefb8a2ab142265b687f0ad7c0e7dc7d33d4add20299cc82db376055347ab7f66abfe39994b13a5777b235a10118ab1547e8457a818e7e81f0b1919a636e22ed13416ba93f8eab14ab945400d23e848d45fe041ec932c8e692f3002244f55f8b9f39490800238a90935d7d83bfeee56d59802709bb6dc25ca1686abaa2b1e224b7744d90848d9c698f0350434f2ae83bb3116c44cf6d70faaf215f2f56be2a6ee31f3e46784e3e5a3a97028035dfa0720b2d374097b9ea42d4e307dc7b04d021726f3e822961e3125c59ac447c9005e8a51c9c9b02e3c0dc652c4242e354cf8651cad2aa8e63c092510a07ba23f9d6c1b13c059a3d230dc593441782562c9eb7863803a04fae0efb5914416f2d1d55a3bfffa2340ad36ce5726ce05c7dc8c0a374eb6cd2334aa397fe3633cc99a883cef8e85262097a8d5b051e3c24703a52ffab8f10afa44dff92ca3390023b814428980d331dcb5336d2108a6ae673857d0f06ef8e03d77337a4484e6893dc94919c8b743343fab920a9ce3c7dc86e27e0b8cd8872928380cadc13426a1f22356396c3f70dcf3bfd5b015046e02cc6f5dff281c83455de9f6425563726fc631e81672b7d17c70d70b15900b9a4c462e3386a1f6530d74a5b175ece11908edbc78eb70ffa26240d7f0001340502a04ad5a827ce826e7dd3d7280024a4c3c0a605058db83f76818378f4dc17b01ab1ed1b7fb40b3da4d49f43457d92ebfed9b6d7760fb16fe4eac5a62e4140f4fda13f3f0db09255e5006379f2a1c29e058c5c0e820d9732a0eaffcfe1a4efc2c2274b53d373dee53c936d2e5cf7afe0c52b6c447993e3fca61724fc81a4d09d593656484b16f421e6052ea57c7ce0930ca7a2a1bfab991672f645c335ef24266b1fc18d66ad2fe710a63405affdf6568df1ef58bb6b62f0d8d1b16493772354d7c91af195be73297506fc65d5e970cf69e7d35f624d7d7d041f9f5435d76767d7aca25611083b6090a9f43be0ca63bb444618328161bf4602d9d93e20bf8b90d89c3bb614d6db32b65b77ce7a833f354bd9ed303b5f02f3e4725b2fdfaff82bcdff7bed25859c3713c8645fd69bd0544cf831725c75485029044e1d3c1f6dfb76d727eb00929a6ba0adeef30456a00253c8a62d68e2f8dd9e1d2c2667829472478d617c5de3931a556bd4e60613770444b0af0c6ece9f51723d1502fc20b113c0e10744f7a130e36095bfe96b92e9ab1dda43425fa0c0400a95e10f8c3d13d75b82c8ff15c9648c36ce39cb295d7eb0225eda589ffe82b684067a669e44142b4cf41c02f65b073c19679cf4464fda113ea320cdb56cd0bd84223269f07865451366e042d81bef69956f752870d0ddf8249a4bd881e5a73f68299613a2c08515bc143c6538134308fdfdbcadc8351d63bcc0c431a165818a22fd6c5d63a2e9619059d9d2601df1c340054d867f964b05ff3f6408591cc22d8ebf6954b6b9bc3192dde54b8776869283f55358da328f0639b3aa7222abdc96a9d09a3f2ffe34afcd957a5035d87e5374fec268193c6e3d5e5bcf217c90a08e0b8c9ba7d160621e634945d03a63db230a41d3769165f368e62a37ee6310dd3a58d12e21c9dadaa00ea26d3009739030484d416cdcda1ebacd136aa2d4e0d8388d8358310e449d00b73a5624a483ddc22e0a2b8824a9ae6594de8d454953c43ddcfee24581dfbbdfd8894df6d54672f819feea463b3d19d5cffcc5e2a5c2427943ba11a2db16b37fb3bf63836a9e10f7a1d8186f31f17cf80b9946ac68a7c115d4ee553c2343917732fd24b53777817737e30759842f246b690c93549326224f7eccb07c9bda21d16e0c7956c7b38eb995e08f7473293be044d9c8eb2ee361f3c4b902996320f94ebbcc570422156ee83c0bf735da4f02d57720cf150cfbef6b36fc0790132c5fbeb546792b6cfe165d02a67cb2aaab4e62936bd0fe8c2d0d2122e9b3eff1545e08559a6a0194eb080a9b882e6abaaf14aa359081fe77fefd700c7697e93a034f0ebda7a1c544cad7d32e251472b6b5ae53f1cd530daa5bd9e1e7303e9593737bfdcb75875ad4dcab0fe804a9b1285c73c6b4c36866c20bdfee9b16db8ae5ade1ff70ab369d397c48023169c16c665068930bed9ec24965d7deeacd211d67b5841761142db75eae78f9bec13c638e8b3c4cc7c1e3aeef570f36343e8e7887e619a8c453e9385524ee95b26c8f0ba43bfa39dd720f67f3247074cf27972437378a071591cf2d40e0d029bfcde3b8dc4205977bc6ca488ece3662fd72d8ca942b964be28cd9f722834d7757ba6e8cd0093153069bf54260d9078cd0d580680ee8e453df4dabca6ef9e3311ebce5887cfe91e3e1c9ce3be11da60efb471d8caf7ce5399045a5e5f56b5c7922d2f9c8baebd196694f324319d1ccc701399588d0136287883fb3a4dd601c318fb107cfba2c8e738d6b7adae31eaef7196bb8645b0832e694c335da3d3fe4c30d39f75e9fc13ee59723d02b9e57921a1e8fc9f0675d29cdc45f7cba562cc365385e88d4e16a59a22bd2225a5de1516aa540face5f83f0fcfde9a55084b6c6b53d53d1d07f66fa591bc38ba458adc7fd40274619a4c113238a06198c76a70940b36b80b1920c5d4e60822d3d28ce0eb3ed1d7fe22f11ba1aa130fb69400e6699b7106f1a1c5fbe55e5b1a5163637133d4a6496abe7ab6cb907a2be40fc146b68c916abd9e260a61de099ceae1e1cc0c93bc52c25635ddfa47e66d8448a7dabfa7296e9951a2af529acca91f8404adc2af7e9fe6bbc3ab904370669651f2b9e84b4e9f836d95f35cfc558320cd438ccb06a1b457f0ea2e95ae8a2c38d109ad49099cb9f3275b6704e09e4451a0efce450604f72323170be16d1fb7afec8c9af9320694815518ad4de8f8d21f7cda943a493c77a87eb90e6dbfca6cbe3285fec38ed0e66033ff2d592bc96a5496dc289232182b7a7dab1870ddf658e44c5dcc7a12b530d5bf27c89ab62d77ffb5213400cb4d14ac647c14dc1f3d88d62139a200c240642adb23130c94d96e46aeb33b032a6696e028437f8692d95ccf7a532111414ecb6a4a4b81267e0862098ea129cff963c361b50c2196068ea0163117461befc3cf0f4532792ddba66e0a61f5a2c0721056872ba5e3afd025cef387d7b226ae997662dc72fafc1b63b5ed7ab83b920c177b53490729ae175ee330dd8e6f5b99e417125c8860d6d45c422eb0bf25724038f9ac3794b88f075f19eef630519f744d7846233f4ea93990fc8ca35f34f4f22691deea64e2be67dfd17c2035ca2c2b67db222ed22088553304d23125def460721d6d72704b0d05369f1f8116ac27638010df5c146aaa0c2ae00574f4cde07e90db799173bffb08dca605153dce7ab434831512e7b1c5d3ed4e36561f3504be466f7e13c57d86e56a54fa7990ab7eda8e96014cd8f11cd417f1f78e5d6119c97fd5df91eb18d25671c4e6127c02b509fa28c631ecf7467c98dbcae14d69863a16d7b321cdba04592a930643387622e22c0521a7394d2bdce949145b58b979083a27e07f687e4e4d05f49eaad44f3cd598b17648b3c31d0610549b20b959d8d4b9db06117ba58f57f8e3d69317593b5cbb3484ed362ed464b55ad4c0e2ba04d48f0e6f68e6aab7a11d85f52bb604998bf42932294d2177b8f0da0a53bc03d187ca59fb40f4a201dbeb59534eb34dc21095efb2cb52a2d2c5e9e61733d150642d4ec40963c2f833525eea0e4153329187a85e439ab55c7d53d6afbc4f03d0513efda81bfbf5f01ab4bb37a6927fb7412947b29e29347ea4c3f3bc6fec9b64e78a5cfcc7299c4bb7a24fc268b8881a285b1b347db49481367e9874a0d4d14528f3f67d9942a9d29233ad641c811b5a7b6d2f829266dc6bad3fa466354bca9a24cc8b402d881e91bd6695dddf8cc3f300f22195fd5687114d17dc0139e072f7b9e37cb87d142ce351e97a499605203dfef06b8f904c5696a89c17f1beb54424d740e43dc8ad1389769de88ee15fb7c792a18b5b027d950c642607dfd540996edabdfbb743731bdc174d847eadc916927370a3480403aaa4f2e1e06eecea6b86baf87b8bde032addd975639ee9c05bb98ccae6db33995da967402d82316d7ec2e4fd7c9a23ccb34da5c3d2375e186ce9fc4d55c7c613da71a06f16193a2baa9ac69618c03c1cba81db96df3896296d88379ec1618cfe5165a4c81123d102cf6e72ac9523a089724b5deb218ef0e544e1ac8baaa5cfe60c0f6c159ee84541b32db224c6a683cf40566f7957910359e384bd525ec523fe6a29b7a1a7666f3d94355979658588d8fd78a2edd290474413aba3383c3469d1d682511a46ac43667865f92eb7e30eb519873f70270f247cd3dc76bdbfc3949ef57f18ec41676a75c2e96816d70cd63bc95325329fed1f3aea83138ce44469b1246360a6be24416c949860028bdad9a1dbd189282876b34e102522507f8dfdfc266227c524cf5a7eb93ecc2daf1c6667c245b16f76eed3edd3f367e1e7656523fd0164c5c3fc80a0bd3acf9a63ee8d50a5d0af10501213f100db3ff937fa5e6b69d5a083abe29f33bdc240375b6736a91d73ffd038f9496c3f956a93c33da2ea6c860ac3840f4833d1ff63d2bf2e74a135b01382116ac659bb4725e77dc372e47980702649fab0d9c657d5ada5c7f7b4f4204c381c22b67b325fd2f30d7ffcd631a9d0a0c2ed88cc59b4f5946ce4e9e02ee1944f8068ab96ec2fee411bc81930ba36d3f405bf572dcb44211a05fdf3241dcf81ca0a2a7edc19566a9deb1fd82a9d70a05a0372649e322a34caee65d8e5c51f16ece708e15f7ef29c212786ef0f5cdf1df582b82a4ab333999ba963914fe770a2def0bfff47b27050447571ce14e4e6d995ddbb35006c935554468e5d8a4b81e6fb0beb23d563f493a8e673d0ccbcfb89eadf0323f3e88652166cd876edabc4b8601bac1f10d0b89f9cf7cb678f3f884b7c12679fbdfd80440d2845ad903e760ccef1fddd48d77e4af9903301218a542e0081be9cc619fa04a945e24a51e6d3f8179b6e6e3afc5bc4135f0cee4488f46a9d9e9c54a193949ec994adc391743cb65484db080f22efbad4143a0589172303f59639ba6cde3fd93d14adf231f3d8693ec4b812b3c31a431793d943af4b18e27462f3f47967d07cab6ff1532689493e61da6e129499a7a5d2976969e313b001189595d02efba4961e3fc98b1dcf22b3e30a5248d1451400de44b489a453c8ec2f683b2466679daee4a93b0caf3afa4d3513cb3515f9ea60fa1d845ce77955479fd655924066a73f65a759e80b4c1fd10f2d0b4387bc1d2ada0dec89227e8d93f21eae5755bb40f13ead9363e3af90e58342d6a874ff63a3ce6cabc4d8d4e0e59d962e8c916eaa80be01ab9167d27bde52be90dd02d7fcc34de2a1909e41f4e07e613bc804a54bc8f9aa738daaacd8062f09451aab0a17df7e3409bdcba5790c5b36663906c7efef875116f46e2dea9ee951af1de3ecd4c0394a223bbb92ae326d7f01746823b1529ebf28a715ee9f1db3a0e9a00c16bf95b1af868e3135e01f7330390051ddc371df1ce7cfd540f1381c2adf1cdc39e5f0b532618d35552bf05b2c02d18e9b427acb620c1769e9022e658907920aeb1610439bd2d155cd9fcae152a49ffbfc366be1e6c537b303417ee6f252c20405b20a621ab1bee8fa5b3569021a13e617f6aa41ddaeec8fc24163a667aed9bb84ec9fad42d149cedbfa5634adeca963fc1ddfc79e34b079171e0cb13b82551576bf38698ef6fcad941634cb2c96b6a1923c403412b812c364f08903bd5d8833665c1088304d297e2f6c4e023fbf1d661abe2b9ca53125ca46a567cdba1c5a2f3eeeda9b448101f5bd5a1902e7ca3a201689163399e5740ad5ee2af14ba7c00aa31e78b583819ecd160e40feb53e9366a0a8725f92316d95b2f67f0615736de788b205931616afb276c10c100f15ceaf4a227b5846ce5da672cb8d311ebd8625b1beeb58eea411ed7b4d5790cd8171d18044199aea90169ca2b37298b8fc1f5b00d3abf2416b533002180917df78defbdd3b8dbb85cf6f3b2c2ab03531d4e506a32a9e3aa2859d638b15e962313042151d683ceef1be1459cb11d05a39bdaf922e68716e2ee4546b833374c7fa5f55a972be31759367c3058e61f5814b53c2960f29bc2a83d7a94e9af7cb3ed7b45c8699da266d5313a86fa6702a07af8863b79654f44beefbc4a46adbecca263d2f57f1ed4f91ef225133c68091022557a495511e00f0ea12ac40cda32298802e527b89b775234b08b7f7208255013fa657025e2106f60dcfa4a998def15d7b71e9eaef8bb927d1c0337de52a66a7119a80d4a381750e7808bfec3f9c3c6870af8bf9ad515aa08a54eac6295cb03ec12495ce0333a8759d34b201d42802f880b24720a0953d7b9cf35eb96f5fa6d12db74bd8c3b1399cef6828bc0d41f7c220069166560e3d294e193e1b19dfcbd1fd3e31748cf70bb25f31fcdd80348e2435cfa1d1e4b63357c26556dbf8925bef689d018c0fa8399c5cd26b87ad02b2885d075d4832f6f2512154dbbdfe01489cda0eb5c837f505a62f1bcf97a0ec951c0f030482225ce0f18a982ba2d7cffb7a0b89832eec4ee10033aef694c556cbe8f417a1b127301b4d422925404c69fee2124b84d2a444b79c0ed24a91d0b4fd8e1115ec053857a510c3b6bce48d771d9e82a3dc19e20ecd26620a7f71a3d09554d9f03d4b785a05b942670b54d06005ec2eccd15c026bfef1b97922d35d57f92583d86ce3859e296704f19306b082972a93ee5578a2e365d28e0655f97a6b6e50c6cfe2597c1f501a3481247fad4cd7f1509c37b115170c74e67f90d97ae08ca4108ac6e0e66a8f910649775c6dd137c0f0d2bb8e92548d0a4d950799fecefa42734e8fab7dd2192e093ee47bbb2e9de8ff992dd881fa5695f039d6193ec2e52e151bdeb54d588a600a700a7da3eaf29516e6968bf12445a885032633efc47434a2202430baa0c93726f629a10cd4f7f69cc17ad4643df7cbe4a2ded40aea01ec3e7adf7bf3c63be131fe803f3f1cd567c4a03e95c162c19d8923c0f633f77058a7d3080f9c2cc73ca2977fab1e4879ed8e0e7426ed6439ca496b1bddccb07f7b759486d6e1626dfa4ef7acc191669a46e464f8a66bc8cd2b07d63057a87024af8b3f09e3199b251084516a6393ad8110943712a97b107803b79394d42499d931c8a52f811e533699d91bbceb3afcf05eac8020784742397fe65d477f9d218c26749120c94626da749a60ebbcd603758aadf6d845aa8cfe73be8b4b8f0a8b57f2930d5afc87950347d9a1d28ad06a13ed299356f37365a0721544604e84d5ff1a0245ad56ff72c33811c7c3fc4c4345d4f20255cba825a7d5eb4cb1756a4c6324ec4e8814a40205376732bbc06e7ab4aa0e7dc83e1d54f005855e991c56acf6d0773cfef45db2e31d6cfaf198312296f618067dc9f1d469db0ad3c050057ca3b5a82ed89f15f0d5c6aa834b03e3f03c8376086e5af7e8a3c106ba161e63499d6c77500387578025282ea89120aab69baa9a14e706232bf9ba9daf4fcee71ec9e4028a91ca109d950e0dd5c14e904d07156c1b03be0192fc659448ef22bb5bc71e83ad1f3c43d05197e15c73f35a5dc122e267473cf0036616a9b4e57dbf5469b8e723484ca1f6d20175cf7ba022ef421a220aff1c962fa3117ff9e6e38c598caa0b7df7a3612851f74b5dff015a32e1f137633e7b07dbe4413e6cc2e8e1f78ce6b454075be131c65bcaef0d763403ad81217b9ce86b5a2b8d2a486d4eaf4775d7b043a5c3053d1f778651261ce5530007cf762344839381845ccb5ef78cae3570e106c35a59ee05478714ae002c8cd22da5f8cd321fc1d3a9934e4aac8e2277a5ec15387f59f6031380d89c6bbb7c424885a869cfe49068c96e68e193d44f89e7f305789977ac939833b67d47aec46ff36b39ef008026f3e993e4a160c95eb833c926855a89f401a358e0245983390b38a91784b9195ea9fffb0477ba90fd4ca4dafa764df343c48479073cfb5904bfd97d610cb847ec1f85ce431e5649410c7adda2fd6e9c298084901ae9475e0869cc665b8c393c43d321a995dbf7d063318a0cf1fc2279f55efdd0c2d9cd124190906aed4aa9c654a716b7d49db46e039c689db12ea73ab32947d84dd79de062f26396fdb43986a94771fcd05098b1254b95ce23ec5d409cdafb53e4764d45aa6827c1c8847a085eef1a3378cb01dcc5c9e16b67218672ca7568a4ac120d4d6e77f18d390c7c2e25c776185b4b61d3609462a6b18329d834025bbca96dfae6cb726b9c83b108e2df4c36a6ba76cd5cbd5880fdc1f197cc2cd455f0003e5413f5265da525e330cdb743c7430931a5d76a4f8260438b5f59051006cfda47ad84e6faa4bb2cb282b74796a99cde4867df901b40668f5487c17626536bb3eb37a38b21b54fe67d3dc7de8ca924d59f755f991ea7f37d1774763195bf6efe509e2a9ae24d4f5b233d3411502803464ab8c5ce5f34914d9233d982e37c1bff5bd6c29a2c6c4d2beea79303137bb33fb84bf56a8a93e8cc9469147540b928ab909897244a5c7ab5ccb0dd4667f3639bcb6cd3cc37659aa34d2f34a44a1c3c45fcf8ffdd41666faf5bf5cdf1ff0b37581385dc5ad91a7e87182a41026d2783db210f57f23d73a0ba03bb16975d0df6e4b17ab80086d43099f36ab2630af8b52225adf4d48e7f451199d75ba24032e04f2871841e386fd3077af2f6b353fee535ccf64733e013ff10fa6cd6f02e837b6980b9c3290ebc3c1c6354a08d5d47722a60797dbf753b22cb65e8214afb9a7775002f139f419ed4e20a626c5009066fcae7b007adc2c48a8a3a6147887b12531178b52dd28e0c0c7a622679dedae67cdfaab9278572f81d3eef0a7d3d9e102764536f3e1835c2e4e599858cf33dce967f29fd2690ba6886bf2bfc1605f6028afe03c51169bc68149db39092b9036325a703baf68a46adf76ace84ca58d3a2773b1779049123bc027f214ea8cfcf7b58e78b2c09b3a6dfc826fe590da807648d15adf430625bdb9e835bcdedbeafa8b874a26862d9224226316e2bcaf3d0877bf2b26605bcaf45bfb7690fc2066b0ac8149f06066501e49c6a8cb3f2612208218955b0dba8391b0e4c70cfd51194ae575bff6b7e90657304c87ae8c14a19c1d796dd6751810662ec4e1c5fa38f7ca29d8764a2a1d4952ce3d4037a53a6629cc014cd374addf158d0be2057b992983f5d4da6e4e36e2b27aa9ff82dd9b8c1c5bf7adeef46b6f9b783d93d3fe30e63d29bb508d514be206adceca0dcd54b4d8dac646f744c127e764eabeb982041ae9789ef4d656e319380c9987640722ce707ee92bc0fa031e1db2157d80149f360a829b2a1502531a79e183147bbf3f0c2182ac518ebfe97022c7408f882f4238559e22d268f1d58826a0dc34e907b13c18d9cba6628d7175abb80b89e723f9b3f49c4d7ba80cbc97314a390a09c9ddd6e3c1f5fd1feb799281a5e7ac0d02f08635b1cda2c40847775679338699ad0b42f2be65d42e0899e06bd891ba25cbf28820975a9d11e8648888b98ed66d702d388a4bab3d97089d9dc4230577c5bd62a608e78dca64138a28fdcd2b7f4f58242ba6933e748d39c757d6a5092274109b08062ed9a66a5e70e7f6df6de85d6fb240df69078a77ecf99649cacc8175589d9ccded82eccecb259bb1626c213b21e48d693e2ea17f33e87e876daa551c8eeea6fae410507163c03dd7c7011a6a592c07921db078da6d344e48f2cd22c333b7598e00a806afbac740e1f3464dcec8f4029d5447abc5eec057d7c12068309b4b2677086088ff7516fbf6ec19ac7c025bd353e3b23cce273e779201fc661a7f7b334fc52e3a529f2533f6abbd16c243e0ffb418cd45ca56cef65913515fe2a117e22f2625fd8e1a51a7d224308fff05c24f31cfce0c92b8b9b6b7aff2113d784155a14bc676550764a0eceecf84fb442a5d0198307f9fc564bfcf3977fdf5a23249b36347ad4b6dfe1fc0edc8233594f18bac271abc69bd29502438b20540460bafb88c893cac08999da29b7b40c41eac083708d84ad138e9b0a8a673e3854934e1e53452413250910ac2f2c16f825b8e3cb947e49e9e5e3992e03abe84eb07a8be292dbf3938949609916111fbe755e0690aa639a08d2007d9b2487f11f6ae95d43af0794409ccf0a6217e5c7de7fed491c917b796aa9107f46ea0b95d4a0cccac0eb500cfd3041aa87c4c2727fe024206dfcd93c3c4ba09e7197dd4334fda452a67a6fab12799860c54afb09e13efa92d44b2f75553f0a8a866e5637aa8bc95dffdc016faa2bc54999ad706d4ed20046eceea2e22d2a6f781e460fa04389a4ea488c2a0db764b54c8279edb0a449802f86348ceee1a358fff6e3644d3ffeaa32207a4c7bdda8e449a65071a8aef3b72eda9fa18b423500e80195e066f5b1665e9fdaf1887ca9a6044ef7af216cdffafab1789eba06da8a4c99adc059137a0867c29c235cb84c22fd533dbd7a46c8dd7eb3fd9a26de6d6ab29ed94f5b58b2a69e88883fcfe74c019f23b7db4d25ad773f234f302ba5a5d6eab6ddf1db6fe4a8630cd561cd1566bab979b76abc2a1c7c3dcff7b99550d71ca781d4dc8ef097c463b8d5e03d375f4eee40207c3b0edcbd78559df25f7c15deb532daae81121646dd3c5120aec9e19efbb4a15c17ac9c2d6c833e67a2abfedb6d832849371dafa0e46f7452a9c509662aafb7e11e7042a40e59b34a6469a94cc5a508eb06f74c9c74ed0bcba3850cc0a25b3fe243dcaa78f2e0d7cb3af110e34f9b800918b3d902f948bf00a802307ebc7623380585a4db19cb94f305249d62e0977d126c79f5168f3ff1bfb13dad89c65e95f2cec75709a54915cb6f10275dff28ce7a5d2cddd8ece8c1e36be2ae8bc9bd169b0f9d72474449a663e303526e8170f06b0a149ba14a4593e0f531e4cdbd9fbedc6e57e1f26684492468f17dd3825819867918d3e1421dbe17ae8dd9b4ed44ea786d052762559ba464117aff6c855c0f9907109a24d7a08145628d7e8a806fe1d1677dfd3d9c2da242fb248b1f13955285f710a320d4370c2a057a2387a74a1609cd74a115698e0c452cba7a0a47bd54270daa96ab7fea951a139d211331ddbabb99c4cfbf8c7687729e6df87c14c6d9e1f47cb45279d0af057236bddee69fc5c97076a4330051bfcf21665fd187a693ec345731471f95983ab60db8a77d140296794faa6dbd789cf5f787f06edb9ef2fcceaaf7387a5c0ef8f0cb7bbcb7e7b3e1495d0790aae0267626720b920ce9a54539945e105941529a40c29e63702950527806f0a4867afca55df4330ba455f6840b7f98c10e58f7e12dd0bd4e8e35a18bdb1fa41f2469735828834a80c64b4d75652341d18f62d88816aa8cd0d19880bb250237eb9f56c8e712b6e3458cc6c2af70bb4c61c761640efd17c20091e0620831b8fecdc40b0da501e9a02c8bf0f33333b373b081e712350b94cf94766163db04718d7f68c6d69a1c114638e3af9662138733c4390843e017720aadd7b05c60a97869d7ff209c955a027d3a41d987de3d4c6ca387c5ae1d959e18010adf8959903ed40d9b380fde448eb1eb10a3a8b11d57e8efec5917e71805de163108ef305fb3d3e22b1f05fb1c00277a57b949cc131e55194f2c3eaa69115fb5e9b3a0526d6c04925caf2923ee67a413bf234bcb72c4e534bc614edf4f1815a6c555f027e551d8b5820b851419b08c9327d73f83ef78c9e7d5f25332023854a9b9c9175d4eaf75a3aa9ef4ab829c4bf0219abeab8a7fb350dbfb7bb250db7caff4940198539f68094a81c5badda648c84a1fae2d2042bbdbb154282e762810c73f935f16581228d7df85e0d555a6dc5d008882b052aa885ed0dbf75d6b216b417e94168ab4e05aa3c4d17abb9995338183d6c991d48ef12d47a7e1b3d88da2e7bf2f53cb0250bfd867ddc9f4b002d06e5b47ca55eb07519fc36fee29c87414b0db3dbf36e1394b421ce432b6aab4587b43ac39aa3d1ea14a62b9b65f0d9ed0622c2f133a9374339ba1dd8e994577036208b587048da1b8691d77c2bb3227f53727c0ed1350c4b14d79cd5d5188df2d921b5051b8212446565d88252fe7cafd19fe5d21e5311806fb0ff515db89e89732fbc217ed91bd5fc675a0ea19420eb4a6b3258a1b67e728298c8c72d9cb9436cf463ecdc400b2c41a085e1116b821c1135a303dc25ea731dfda17017cab76bfc8f2529c05cfe523917190f9435071dc17efac634be3e5cac8982d0014758632870668edce3d394b6e5a4d679f783e12761dc4b1f11b8444dd2b706a27c90db5b8362e067ee8dcbf2cc6bf8600a9a925aaacc2a51e9f3893f194af2cac52c41da66fab38a2bd73bae3ffb390b742748152026ac2145900736335052dd4187925fae780b1c3c6ff205d1714b20cab784711963328d80817afed4a7fb94749bde929fe3511a7891e21aeba80cfeec76b66acb0fa21b3d943f5cee8802273506a3b8d25e0258d3f0388dd5a1354d48d84631442284fa702ce2549d39a75980ac9a6cf3ef717bc37eb5f885d3d52c5f03d3e9438f944c3955248f364d25f1c000fa13a90e8b91eef2ef03f7118117d02c014db87b2b6abb706d599cb79b10579f9d97bd6c1d64ed8b32dcd2f17da1f173de10811088a57238011ee16615f12745b13a7560bcae0c80ddb3703050f884b2dcbac05c3b141a4f22632111c771b3847a97dd070aa1313894c31c712deee0005b190c8379f5aa9df118ef611921b61c40d56c0f75a40b24d1da2b7a992ea71053ea361923a6d53d8438409a1e269af8d5912e3f3c378a596bb6eafa02a38dc4507d432f0e87b96b4c64621633853669201ccf59d45f85f5111e6a25a189e7f58f670210df407fb5fca35baf46e5a8b5bba306de102d7c0d7ca95621f9787a1a3cbec2a70c6ca30e377d9f0da611d1967cd8507136cd7d0fbe977e1426a41a9e79f7954113895159f5a3f5be26d6089f12778646e7e550bfdea1112f233709781365bce9757101c4d9febbff0636fc656e4b127e75dbcef72e48751eb241a603a3d854ad3acfd175fc871ed077330a3f85a4cf2c5b419c8957337c068e540f33434c9de2a23e7cee7ec4787cbd3469cc0d000f77394973ec0efc9526b4c0b12d3a56bd9198fcc566229ce2c82866757e496ff2b0451f1ca6f9c996c6434a30f0d18a9a4cfc5d3c89ed4f9ce19cc6d0ac02eb69821f832e5bf8dba6ae8eb8f2f8e3d8de8cc67b74be2bc426895f9a6583f117558d8494afb17078f39218c970264d6f266ef7cd07e0190e770c300628b97f7c7ecfd8b016a084ac9eb6bc07cd1893456e5a0be5334a140ed55bb3e62924dab858962e5a76e274390bbff972ee21580cb90024442c1ed310c617bb1cbaec8c728b6a76265b216d1f9732625d9c63bc55b8425c190591075cf1abfc1782e2024fbfbf46e0a296b9b0fc13733e5e320fdfd24593b0a61caab90548222587c3cde603ab65f3a29e1eee5120b342c623030286c2439d6b272f575873cebc1f795f6d7d136e879f58eebc8655dfb0f6ad5b8dc20c03cfef7af80fdeef7a57a8b4341dfae9603c5f85e796330499115466591614372a79477ec282d744c17d9833f5cc06ef8797c975af47394a529f3dacb56f6f22121229d5c03ee2340a24e45fe1bd124346aecef04c8f8c1469cb3d4eb71ec2501c9813336ae571b841dfb61cc5be8ddcdb72b422f7425f06ba90d91dbb4c68b563dae51182bbb30a7db96dd6c18f5da0beee39773cc2c3064762a0ea5a6411d466ef6073fde9db7036b05e2a65b4c829c102db0ce469c5b3990635367a51384d80a04b8dd259d2154e74c48d94d5efa147cd062557e0d867a30183b5e1655585f0ef594b010f67417173a6d41d9180ffa207d09425e88935b7acde119ea98ee46c3700740b7f40b07cff52f0a1f8bbedbe93a717466257aa82b477537f200a1b522433d4390c08826c9728e90309216b8287fbcc839ccbdb1fe297c3b96dbffed70c2603e9812cedca9e09ebbbb25267f66db644ccb5a75b1802d962a8550c9bbe4110bb750f254f2ec2527f81836c4de19c93e223675c96900a877f5e2ae32d1a8cc63fc861cb9baabe331041b8663eaf4549fc9d70feb5274bc69dae3a5ec4529aed88c1048d350b0cff9921502b61f267956fe7b968a97dd763373452ea19457224a46f866e02d213bdbf512a2affbcb258854e63c669b552a197e39af4af086dab09a69dd074108a2ad0cea8f8e64fc406adf0c39dd195acad576584b9e4c73f0a8c97bcc986c3231c5177cfcf3cc01bd5203d7224fb0e137bd8459a7fe1eac71094dedd02ea5b00498e8dd120b043298bfcd0c9e7c5e97668e02ecbc8a1b0bba40ea885e83ed5e6e08823579b941c08775000dc536ef133a19f5c76c080932ad2610ecd6a0c76a10b0e44440b3b035775f31c1c0ca99ebe47a7541a4c07d6bbd982335c36ec18ee3e9d0103f265724fc20bab1c876aa51e31d1ec8bff688710c146b0a996270152d27959c6b53c1a97846991a6fa81b9c5bf0abb390b60c60df81163e35a6952b0db00ef7caebd6be7da29b1a25aec45c833922fb60409e1e2700d109e071770efe72d1917283203233c6aaa636d4d8de05fd80322945fb1b166b2f5d45017ca19e4f535532f811f53700228f0f3ab1b4cbfb43182434bf9e70258e7ffdb0997af4f3adaa81aa19cd26a2d34b0d5e5c0294be55e238896255507ee159c4b6826d0d0b17580a2f2ca7b2d763f2f334f14d56d0f157de58c8f5998d8f09780611c7f9ba1344b09bec35f9718c4de63e2f3dc4c4afd35507b9f8f2cf658b28703361c8ff68a9a27f5413a2ca46dcd50c3f02cd80a68e6f50cfbd96bae29bcdc463f8e0706fe41a5d1c0472f0f99cfcf061fed69a31ce54e53f9233424368b2bcd1c77e71ee3b43b4a0214a48a60338a1b4b2a430a455392c072f19adc61d0213396c596c81248b18d3d0e2ed9aeaab411109aba5b523cb3569ea1e761343112e27978f5bfefe005a522e5eddf71836434637585ae1c25947fa141c37c65e67103e4cabe2c90a1b3e8186d7329a093f3990ea8a60b14c77f685488ef4d94588739c4da11e1ae571632e692cf75de2174b0cc2f8cea2d9611eb7ddbdf370d2705bfa1b859fcacaf16e4dc2e21ca5c1303d1bfbb04aadaf060d3aa90faa8a6f82c706375a6d20a862063453d4d53b84612c892835c63ee19b26f3789fa25391d0210e685929d65ba02a39bf62a2bbad03cc72eab2468a7171a9ee44a28a58763aa717679794c0e3df22a0eb07056f32897677326bbc31e6cce4b73a31356c28967165ff4cda0af8f998e2572f5e592ff73403aa19c864f679deca3d0c9435730c0f33fcf8963cae204881341eff187defd70ec641add49d13ad2d04c2870f90f0df6c72d669e1eaa177e6811b6d39d6dbac471bbde0533dbf73688463a4fbdbf67a1f59249a595a35f779d598b006b4fccc7e4692ba572acbf36ebb62ee9a467ebb8856d415cfa7dcf61ed8a9b0018b016d7cb0238b84e3152631cc7d0c2a21e77598aa16ed834d4a84c5e5f8600f762c99a4f8aed206b26b681e3a086af84802127b347914b0ec163a255a330221a340601b3cb5b4a250968b7535c5efc624e955a0fcc631086bc02b8ef272d23230d3a876e6a2ef8398b5260f4e2c19710aa780b806abf9e6028a8a87b2a5bd46b70ca31cb5741e720dd9c8cd4f5ab65088212fd2f29391df36b7c5753e0b735f84d8b613e3ed5fd7a38704791fe1a8521533d4645fd19174a325168b2a561b0f61e40b052b55164a42a181c0cea1612e8c6078d131ec56357f0b65efd77e7f21de21d72a76194d1645341da194eac75ab27df78459dd48fc48930ed8ffec250de657779829f7fc051bb908005ee4610d20eff662c2c6a9c53bc2c1641db224a867db3402f3397f2261c70e2cc6c5eeecb7827512dae7a4418cfb390bead1ecc708028f37bbe6b99f2956135cf903b3bc070e1bd4046e72707dbaeee06e9f6e9f0df679f0123b01bbb92fe50a59d73ecbbb144580dbc16537ca9d4d217bb4e943b01ac6480f637ef5e7ab51a0c84afaa1947e400f0f9b6dab70205313ccdffac1422fd836ff67d5836b583875c2706c86ee08b97943a40607db160fa33c0b4ef081a0bb52894f764dfb777e4a898ddcf96470beded707301c3b7eb5659e374a62ab4a400201419a50748ffff2cc6127bde14101ee040f27e285a79b36d07b9509186ab34dffc52115df235bc21f01f74d8110f0d9549ba201b10d574b9583c847b100c138fa6d086633f8e8c8a85937bb0023d06185467e0b4ae0ee25f98e33c7b8d6051c9f6e0c05c28c53bfbc472f199a13ad5e99976b5a7120175a4ef3a512b303a2c811c72bf8a1dd9270cb51b7164bd24e8259342241084f4052a3268037166d121f3a122afe52b19212aebe7cbe8c6f57f88967585ab4d045701687fcc7efe350b66c65a8d8214d55675661fda8de555a4d4e26bb8bcc1c74453057d31e6650d19e3572f15d4021f3a7ba2a3468554e2f77fe5f8f4fb7d53ebed1dc09764295bd926798ff686e84ec33f1e49749e48131114ea15624efacc617a72be2179dc3c35945569afe67e51097b3787f479b85b36640059c3d1d7795657bad86822fcb396fe4cb93cde33554ed910b2e77b739f651bed031fe14871c6f60a89c50646dc622913fd4a6e3ca0bbaf13d1e16853eecb11a5914fb0d7d7b6b53ab2ee0ba8fee2e970775289fcb68c993b8d21a948da84f668b4c24f009c140d30988183c42dfdf0016395048cc63ec85b3d6f1902d8968659a12276fb0b1de3b9f0b4930b0fcce0c48ac43a8faba48a0aaa7bda44ebee1ada30c96d89d1b62a914b3f1cad578b08d7614fb0d19675cc0f1c9c56522e373ce5a08a9c28187affd1caa52c58220fcee2c73cb2f61c82ad1884f07cf90a00f2865e532724a7ce8b072581b503f90bba781274dca5182feaa6f0a72190b3143aab4b13df23d97a71cc7775372b30dfda5855a18f7cb843c3bca8c24e8941b5d141d57e97157cd588d03038fe91b154617bca6c759694ab84564d04d343d27108eb19d5f99d22932f8f9e90c949951691e11099da064136e38f1c820a6978a8b78e25ca123370c7d73a30f2b7216df8ff661ac7c7dc625287b0739805f204eba22631885df31bc5edf4b3110880c87d0cbb21a339f142146d942b547b830e5a7b5a6b8ed3d3161c211ab44c5c9c6b2a32a6161ae2a2827e2b514e7740c3d82bdd1e0b4f2bb5fba6a9919bd35a776a048d920db9066508007266b9b64d0b6c54cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
