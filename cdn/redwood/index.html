<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f219b31d7dc5ce419145daea5d8be408db8dae51f5a46b2b1adf35356a8044a30f8231fecc5f159f93f3605775b7ac8595624992183d3830f50eda83ee76d465da17eaf8e435bf2e4b39e5fd93540b97733f11b535d3d83bcb5a3784f579e59e1b48c96d3d577d919d0d21bf940cad4f1138cfa27ee0fcf572d3c0eadb46756e88688a5beeb97b5eac4e06819525630b389dda93b5dbb52ad54ce4cb9ab47aad69229bc7f9ea130a83f8756206c2b244784f0ae8c1a199fcdb4f248f18e8c81937125c830d01560f73661754873a92d9101b14f929d678f99ca36c4fd835bf5a28a6aa920066f2a5b919b3e049e0f1a40224c688335ce03217156aaf7ed898ceec202ebd269b4feb64d3daa2c18a47b7f8b2b1b8e0a27d3162636bf05fdf83bc1ddd4d913954d8b210fca4e90afab1d24a5caf0a79012a01b35189bbe31ada506d2721408ccd943764ac9970be3ffbedfb192885ae904a87fb41e8ccb4a411523888085cc9a7c1b872489a6ee7b2517eb8d4e587b1fb5a5742cc2f5d39b85a9944d5f60dd17cecc46c1ce0a209cdd4fe325deb3c6a9eecc12eb026411bbf979e013c062974ff652ed31091aebc97b9ec0cc72e85d5a6e4bc45bdf85068a5d3b3ebc850c9004d1dfa30a3c4c0aa38a8c937d2bd6b2247793ac89d27aa4398f6c673d702f6e0269b364ea8e9317d92754690794a9b9da6ec2caf89abf0065af852c3aa0f8db5b69abfd63e9e898abec3205edcff5f27935fb645220d85016387ab7cadd72961a96052f97c6f86e9657c7532f1ee10f3accb790e575bf489beede1c5773ef90843c54dce8161c3a44e9fe64bbbd3f1ea49bc91205f4ebb2174057bffc4f501a36fce69ef7f49fa45f52632fe8a9da184927b4841972125f0a0751ed486666de9af756a1a3921a3b08af91224d274cbc339f2d3d7fa40a585f44a5d14f628da4ca61452680cc736b3d1392db029836e5c5ab4ebb6de2710babb9199bd3e00a20029e609bc9f8bc8e914614f92409f1c76540fa1849e7539e79f7c6f412e25417369e1e970ef150fe838310db950fca108440181ec5f7d95d79c350e71b17d403b94af9729affb13b9a7335562ced883a76372da17bfd4a884bc2700268eef30ed3c3c8db8393fe9d223f5cf503255ac5be3ff047f2bcf6071501d7b64e902a1e75c8006d8e73812ebfc2db7830ba2375a08ae59150b3b5d7ea82f100cb37c4c322f4651a0d69c2496262959ce71f64f854b4c9b639e0bf50dc3492da553326f3944294eff21da82e4ccef2c0bf7d1676955494aac742672e64dffc190ea4b8a74d7e35be1a6f6c28603fbbbf2e60e97940f051dd8f6f66302409f7eabd61764e13af615f1cf6baa89a58f66fa01f0b53e74586728e9f47407614ec26bd3df36144c45c10146a0193019d5b3728cd57cd8df4f4858cb61b78a54dcb4ff2010d0c9ff366bf842a3d0c213c8d30355a342c7f61419d935c9c2a4cc03241e1a14ae4d4fd18521408882845458fb9ac41ac66ad201755a8bf1a08c71d25b689b1aded1e527aa3e609bd77285eb0cee4e830d537829a3d7ffc6fd1795bc6b4fef3aa8278444626def899009dda438b02980d61ccf018ab7eb476a7ed90af70758fda48de7bb5d4f87d8cd15e268457dd481c400559df7438ed49c6f65804c0ebd53c32c4f92b36a1c26dcf4206f0ff15be1cd98959d0719dce7f0dba3ca081a7738ec421851f302e90e48fd785d9f513975c1b34b0d71c5f68e4c70a71e3978de4d1559c67ac6f78da27d7b9418ac9f8f35c579810933c3397d0d57189656f0c3460e62122970b090d5fea3c382f8b9db77e5a5662f69ba4cd0886e99a70b132341d60e3b98e65d4d21d6001438e3c7a11cbaf3cf114d7382b7d931d8529551e2bd7575386736e2c4159c3aa6890de51e3f65856a3cbc248c5868227a40d8440be856318d13aacd1a3563d23c4a44f6a66ea245cc53861afc1fc9abdddd97584e7c2b837a261d44dede10ba6ecdd1c53007c983f1a2f0ac9ad81001b838586431549365cb1a6e333ea9a9d4e0380886a8dcfbbef065e2e7a65c47798bb413d736e5164d16708bf1b99708139dd981310ab8b39e8a4010ebdd7f877ee7ed49176b3940693004c7707a890341b3753b1464bad18bd84cd6a076acc1067d6c92eca9bc1e01df8073eae60306472cfd541488b75c95d3e72cce10b342ade0ce014c3b99ddfc5850ea1ab3608925921bd2f7ff1d717e5273e63e2a419a948ee7f25b4f7cd70a83a4a3e10db6301eea0ea23edf89f84e4b1974fd25c3b6b8a109c9ee7c06f12599dbaf5227062a013b4b486750f8771c653bf323cacabc58e400135c251716ad5c2002e69a86d2e1af27c282cf6b5ed70934517481641b5a80c01f660e87948feb746b3d2bb63584f0397e78589e4e1e1e36a03e9d9c8f9e5703f3a41fe0e7869946b6b4c8b1703189d7409be81525e61d2934e60c9e49721eef37da2415031d35d1beb1eed01abc11bc01f9d50dec5577c5e77f7d50b89bfadeea40ea176481956b1abb9a9056655ab37e8b32ebb403d854e9d6819fb1298e9e84ef4af029a029739cbb312e1e07634ac732028c2aae5b161c9211302c8985711ec27cf19e187210f5376cfe1dbc9e124757dbf7a3dab048d3d8db4f786139d9fd812b4631ae1f5d21c3b50ffa0457b9c8fd8bd3d71dfe2582a44c14f69eaf56b4dd0af9aa3a0d3d455b2aa831a4afb52d3d8f52ce38587a14b83f039430ef7053af9436e5d3161aa79ef67ab772355d235f7f4418dea9c6c559b9d5d6b9ea5cc26d20cc6895f2305a2bb1d0c467ff014495cca384b5229ffeb257defd2d9f51a4e2c3c5c3cafca66d9d1f09c1f05d913a681f90ad003b8c6cb847a191d36453b6c4a85d303bedddc1a1fc37e0b06c41625315966bfca114c92ee6c989af07b17c8458116729cbbde3316e2c360de309dc2893020bf87925aa8ceca82bb153b0a80d391741b3342bef009a880f4f68d0fde8ef4a6cabdbc0d754054655d86587185e874ec1013b2b79f0f68d02cb9a77e26e5e8e430454e1b2000746b5eb811b3e145b3183dbd595131f3778a18c696c622c399b5d4f7f096c8880cdcf3e489bc496148f4e1dfc1ed4f7a413ac165b114db851c5e5d768e098c3304476162f414182fdfd8e4064ef5ef9ceda35b0dceaea93c36b271f9e1b6ae6e4d97cccc705cddd266a0a57f32a6cc83d2c5500b68a85cb24c2dc82c3a9178a8a7d7ec50add97d79de711a006ae76b2d80dae0e025821ccc6606a26fd8bf56395307718b362ce145715af704f00af576b60434a48adb423e324945555c0d9e0010656d4f7065951fc347386e0fb148c9494de884e4769d06ea2bb498f509082e5d51226ae4d1049f1ca58a1d5a386b7e0ff650bce66982db57ebf1917c07ed8f24b1e0ff8933c58d172daa08148ff73b910ef3f8c420f8a5e2e97b282e05bb4efa4b69daf22a58ce6eefa16d9c6b8b8b19921bdb49a6c0456c373e71d46519487d02cc7435167b42675b16390d3b9168c15561dde14cf942e31c0aa62d6b112c034e094f0cc654bb8c76a6d529dbfcac37455aca71da6e6a8f5c806ec5993781462967557014d472125caf77476047994653ca0090299642b0e9f19ede76fdcb42aec4fba54b92bfa0a1a0acc1d28f3d9dbbb8c953b8ead220f1fd6125b9e2505b306998aee4d20ef98104c476bce8dd317ce9dc8645d45d526b92d81738e78318ead38b9d03c63938635f7e04290b88cccbe283ffaf07d17e8c8cc58f0665b356ecdb4c97c72d5053fb971960c4e2f364856e6a42df6fd49a86166dd3aa6c09310439bbd359752c8fa55b11e8234a20d20e735ae9068812853f00a3987ea65b4abb72fe4f476f763e4f508b69f56bf8e13491ad7b5d64870b2e4d48d998960fa692b7f8d0bb9aabc612ec59118cba0c351da9da6bfbe77d69a1657866272235fb72b6968ff6e95ffe2bf2cada6f8ce094298ed3075f10077def66f43de4da7c0f63d7b2ee7aaff6fe4b6be277e45e67cf737c63e6a2ec458c9a3e90d9329db3ceea5de0e278e872df3230604ecaf20bec491fd83826c39d33f2fc4c5ee015c26effb303cb2df3beb5fc59d6b24616fb07c573e82e3bc9083430962d78ae7c38db0b87709200541d3371d9f629530fbb444139b53e9ab6a330470e56e2a2a528c5ea041d2ee9e44531caa51417d4d3c12015b4db6124c17b30c5d9ba5bb22a176c239b343eaadca802b5392f01ab685e3aec2c569227aaac910b4efb3f26bd95853c972f34851efa6b723c2e4667b9260034a1f3c67eb2f167a46c07b390f873d21ed7a199d9c1768088928e7aa65dbd7a404623942c48b2fc67ebf83894b046d328b28d4e4245f16535fc45db6f944be20ccb413b187a5f88a4e35a1ed6ef7066727863d7c2f4eae126bc6c39e2e5e14129e4585545cace72f5c6d8f51532ebc1c55ec9605237e9e15781cfa0b63f0c4b5e38b3f3d9f1bc9274aeed1bf78ff1ad86ba3b0b4da8c6e5ae2cefd8e3de717e5750bb81638db895b7b71d06101e5f33c620f730ec0360648104fb6fccbb1ec877e969bb2601be99431c89a54a939dd787b8221e5f9bedc2e7726160e1aedbb899572e81c7f541040f9cd452d8b53a76e6a775cbea0267e8854cc472f279d6daa3f5f218db180d079839d1beb2283113f164326bec58b4f64fd18339b6eb3c674bf371f176e83a193dff85325952f022b3cb541ba1f0aff8c0d291ee66897f2d22d31b06aaf86492e79c8a7244c9e56c18579bf8233b79adb3071782c5b0e3bbfedfbb182941e123dbf04f9d1b337282f8d88890e170b4e1580b78c2cadd69146e0a7e783a95120ce50b69b65de21040ee16f3ff90c9360c6b4e98d00ffaf8342a23a1c3f2751040736560ed05ea70d6a7489ee41898380fc2e49edd55f2c702266d79630dd2aec872d673d03f96167ee02e0254d010dcb6027e5c551fea58b67c24060e6335ff2d2ea7b9f285259caf28ee2ca4c1b53c0debb2853e142be2ab547db072e7ed715be77a25bea76f2edc0bcf819053e42995705123cd90049a88087ce76dec791d4b06f0086ca4e838792321d9b7e668e1a2bbed8846ae4397b01b057de2edb690d6e5caa72d44a7970ac24285d22af6ed67eb3450bf67c9222ef3ccd86f9d1e4a640094eb8415d0fbe275e25957a8678d26dab9f1e07770a38b150b19ac9c4487e17a5995958a9754cb93cc9c3195dc414f9437f61c34c8a919a7286dc3a21ad043461ecbc7388ae06debeb050bb312e41654b2c23fefd026162ef2b1b049570edccbfc91784c2cc3cbb28858e83b42e08954af6645fb2f58ee8b615d10a2b6a2426dcfc142e75265586ed081ed1191c0c5b19b8a52478eaafcbb8431deaa345632d2867f68b76c8085df152be486c26f9774d022b130e85e81c516adc808101e0e7adadd79bdfd4f007f606469b432fcd90b7733125ed0e5ad4fbc9737d0f35a1f74cdf8fc900bc4663bb96c561a196e4fd1175dcfc01460f241c0c67c435f7a61c5f9838eed5bf0a3cfda8c4d9904cae4876bf6beb12cabc7740df8bae4ff98e76350db775aa9623ffe11bea0cc631f0dcea87e1606ebbbe77a2f81bb990147aaf7a075097b1c7832c1a570aee0a0e50c3651970a9c60cf17ba25aec0df0f47fb9033a8dd1190f2028235eea075b80f489578c405f3a4a3ee65c79e345b337a67c25039cca08845ddce38790f5ce990b9e20783057e9859ad75109ee79f30141a3fdf374efa207f7a585d2d7ba5d42434f08dbf09aa4fbdc4ca1584d8a1bfc9bad17807bee404836064e4153d8c56d5113a3b238f4ce1f331502526436a430f5cb0fa1bc943bf0e522423fa5ea9793b7250f8a9ca46e5d2729dc953b812004d615a4e50ec47108dfcf68bab2f9eedac8ae4d2d73ee260811a0d40a8f5d8d00b62e5192836c8198874377becd5a3e64ff818f77b371dfcb390acc0cc0e52d5df20b0c06587c6900d11a551d570b78ec868166e61cda7ba1ee795b2acabc1105138e6495454d89b1727e2923b17cce7d161e538a1775457e99085738ec1d3535656973d76b6b336e1b603f8969ad09d536460fefe452b6e3455d81b71cb6169095e410b16a253e61db6c60135ad1e09ab8656750a4446b73bd1fd8a2562dc8140f261515df91415abafe3fa8754ffd6b5f8b6ee97cc112b22cebc51300af9fc64507d400188bb3b60bc7fb062922585a2f99e4fa16cda84da5e27688a0f611318714a64931857c99345e261479757175ea21179a965e16842c9c20b1d4ec318645ba40edaa96989cca97d16b61423b74c3a127dc23a4fcfd234c7901def82ba0ab4a53194cf0781451e141b62c58862f1e56d3aebbc96434717ebc1ce652187202b23a3a5c29c475e78945baa5c973e5bf0f59f75afffcddacd5084891a079045f013e2716299f2759b0b6fd264f5bd5d39f506427b90a1ef944157e2723111ce127673f2fe339896ccd8fd7544c27b37325d5c7da429ae91df3cfb1da85b047c0ed7b15219a14098145b09bfe4b5aaf7ed2fd7b6fa3c0e3616acb96afec236a7473a18fefcbdccee4ea6b4eeb8e5ba8d656d19ebaa86e7bf359ac7db3b84d7b66321b25de5042bd2c3ae3e8020a6fdaff0acc9c57e67ea6c2983e6df2652f7f3f42ce9176eb576d8231b9a3ff31a7c0aa77128a64133a6be744ca3562c8c413d3f1dc75af55b032f02f30073fbc0d16a9f261fe6b0034f5f197fa87cc35eb57c80acab79768711b5f785c3628eed4503451dc535ae426bd374e09b96efc3865e245ded14350d2988e0377a2d0ab4a8712c261a2dcf4c4af181a4567e6df175ca440c98c6af4a2a69cae4cc62d3b2d2fd579789325e1d797b1b258c4ca1f3273e6974ede4cc029cc56c51d4feaf92ea68bc31f72aed6e0e4e9191de970a1964bdead5b0caa8e70d1c5ebf6b5ec95dd2bf9107a6f3204d4d21239522060fd4d3ea1831b8dcaa0046acda484c413a06ae1c57e54ed1f6220a676a97afdfa9891825236422a25aa4f2df95b8b7893b161958069816a896b1ca711d2426c2227c0bdc9ddd11d156ca2f3a8b57b233cf0ef458005d51ec86d78698026d679e1409e9e88848085517f484bde370693ccf0ed06b5a686761dc484dfb3a62a22a77324c90cca5894413331fc3f06a632e4a9179569e05c13a6334edce75083895ee30306a81f52d9c85adfe3c684024fe1cd731e2e64fa6f9b0bf1c0c27ea347ffd41e2ba6b97806dd3014861d54616424d9431664c10d19852e07d4e310899141d24d4b7ca1811c081ee8c7d9a4890016851359bd436e5802dfcd6893d185dbd4755427ddffa5a22c2c59110e8053a5bc5c006826f4c11d6e18a60b5e361f475c70b2c97fdddd85cf36fe07fd365c93dc338d90ee19bc7ce3c4102ac2d389c182512c065e0a4aa25a3a0fd272baeae69d64ce525e9f573535ee4d263c7f3071bd07ef54f3cb45ffb655576ba8fb6a96af9eec6cc367ca4bf4419d5a65d894c786806ef994c196afd3100b434da023b58b4ed53cbd13874e2579385b99799fa3102cb69f58aae88722d0157bdc746b2f0c087ada6a56dc8349b9d49cb01e31a9a2a60a2ef6b3433e864735897623c462b8f8f037c5891bb97207fa7cc6c85e6d067c5fbab012b847d1cc25a05dc40a25672dd18c4019d4776511e10dc1cb2815b2cf315af80b2f0559eb92f43b4ad7ce3303d0f6aa6f432be6f85889ed980b82ea1e8b9e7f024255927fc04030f54d5f9ad93d89f85ccf26cf82a87740a80c4c33b36f1032e616b61bc8c9209fb28d4b6cb37de7363140c4fa02d828b02e2d318be91503bae933cfde5f79d690334053e2cebad20c15c41c49884bc853f6d78e61697d01e93078b1a2cfb43647a8dfd1feb5b55cd8b53cb21460f3c59636593c9a3345ea7813b1fb61a0a4b9011f4b686be3f6c0e6136a74a84176610e7fa2ee40fe20e537736985b81842e05c4bf73290c509cfe6dcc82ce65c010508b0563bf215f711b72702c984fab96f55a69407f9190b246f2b04b054c798934a01d634ba6914794f64bf2899c46d4531b29955e05c0eea333dbd4ccca1b57a6a0cae537e3f8d5ce7050816720d3cce851dc8e7fb4a6a383e4b05317fb678ae27a6a8d7c7d65f31234e0df95bf4d355db5982210c10f56067093bf8c721780fa60ed1f351191f3f5b7d06de9f5d73585dc352ff688adc105185c08bc18b47cc29aedc28171329e384b0c72d553b5d145492d711e69853cdfe6bff4e2a2e6c860065430ad56f1edd4bf81e26e3f5544793d478f9f7b7f1744ca61548b2d2bf55ae8f58e532ccf77097b256e11c64811065bd80454edcb4b48e3adf8254e8ae2a956437a0c7c0cb73871221fd3776f794b2f428bb0254069702d100eda100b7c22cc6a251fa986600a55a9d50d573c908c22f22ac4252876e5defaacd2a0782b07a21da1e3e6911abfcc4bb44c4ec1444398facf26cf95996f9bccb8a9e742dc44317295d180b73e60c22c2e3cd83dd41a4cdb19b3c7fbf5abe9f6345d663af46f531b78b98615eea097d8ab40160ab94beb225f2f58e0d55438516b298a1d0d3a99a628c43073ce1a9deb235d0946750823c557b79d621390256626a5fe1e52fccc0196c105d34358e9870a2d713f6601a2c20403fc052f181a89e373eedbbc36d6996382ce3405b3dd25df1e772fcf640c10aa5ddb1b6813e6e6b7f0080498fc879c3d67c839b0b165e77f1afeaec64f6e5f06545222af7ba6e04b1b2e3868e0c98943d965303635a5e7095b373c23479f100ab1f6fc06c9e776cf01aa7ab5a397dcbe32053f7a16be1267da8c358c5487212f81c3d67a06997064e2fb32576ca0142b4e621e940787ab29babd23be594a33ee33fbc81cbe0d003f1bc9ced9f08e82458348ba58f1eb2daaee2381c70ccafe354102ded48c5152a8aa978b52edbd3ebcdcc3e972380478ace1ef45c69fb6442b2c3260c92d1da7d23873a3be9d5267754de1c8f5d9ac69d1c34f008d51bf3a4a882a421dc78953b9b44372610bf1bb1e222170c615c1f242efce41d42cd5f3768fd4efc49b8acc81d89ec92ccae1b576447f091200a66a1a39b525eb6e4fc8f6a3200666c3e3bdbcd22173ac85ca4bba13c5f7a08390a8c1092af30820bc6322ec6369cc0f3f87f6763ab845b6ee9396194ca5b3b036eded8b8ed9cf201546edb75db528b27bd72bb8aeddb4964631e7954a9cb4600614c17434c50d936b18fbd87e7917f853bc3a9db2a964294ec8f320b22976f4f15c260b468a7b051a2ee82dd1ebda2a6481327c05c6427acd7b6752472d330832172ae8eec5c8e0d5b5557b9ac03bdbada80c7c3ae496887605b54fd09d27e829c7de7b0c4db0e2eefbefde3f205b521041ff458a09e20f06db59b5fef17f10de003ab1688c819d08d5b739a82613dcec6d8304a4ec200889048afcb84f5bbc31ebb1f90cfb3ab40ef00199c8e9e0e3ea7d0425b4ddbdbded4c923c53c758509dc701f8dae7a806235e33daeaf86215c151719022858e7601913cef59ea107d06862b69f37af5b41c6035553f9ddbcd8663e84707216f01d6d5c116b14a862d594c2afb1564dc3c1c87004e043fa7d1dde22e07c61fcb1d555cc97f23106826813d751e7e24702da92c1f12db82004130111c2ce6904d19645f211ec36dc9184aa4aa169706175c0f55b3b448cd6f2022eb238e86ebe39a46c76e053059dfed1f89e391851993cc8a5d660b538ad4980f1e07c77758cb3c8ecdf08e6cc0ab19173c40b07874a2ae5af3810a3bd6a0ef21afdbb3907a0c54cbc3d5640a8e2795af3a0a695891973a2a5904ab19aae2b3ff419f45a012a8398ded5dc15ec6d5788b2988313123f09fcb60795998ed536809dedc26014edd85e96cf6192e1ba049ef90faeb6c4bcf76281eddeba9bfb42ddc17c42ac1ade4db05b113bb457e01204bbba011e4f0d48bb34dd16cc7159e64ac197c9ba0045511d5dd4db86830d899bc5557b4b5f8673e4f8f13f23b1bb360c5727e5ad7d6097582199832b8cb77af496e46ab2225c2473f9bf2e6dc197ffd2f7331d81ae546a6b05156f241449a719aaf6f9ab5ff0367d7523875c6ef4959d6ada6df390ae3317358f6903c26fa7d0031cd763c37c4095dc0003d263a7a00e76047ed5197d0e29564cef0e7086dd3fd7c2d0bbc538ee7eeea3ff396d80383a481bc750b244eb8062028c943378b8dc46f62dc064162a4bb7306d9ac71fdb91cccf39746ac66899589a2e9bfec6f6dffc33a4d8c844785884ef6d88531b0b4a2cd8d5c561797f8a20710ecc4534cd1e121bbb5ac41a90121c1525027d522abaef365386dacd1ca2402d401b181c1d643ef4ffb9cf7d8c4b551d8121adb192491fc3ba551286e5fe38002dbd7abe474e91302e60972c7b7ea94923e75cc828b57497a89540dca994f010ddb0be647cc62687c03d18bdb698eff71ede5f7ce3322117ae0a4e34666b65b7dfcdd4947585189e7b1f7e44e7570666339f65e473b3376bc36ab2e2488bb28a1cd698d93da606b86be51b5f190cdd6dd26f8804c874f7bc8ef639b0039f5fd01373b08679a397d2e52f45712382dce496edc01a6237d82e6f6bd4cb02ac08c9dd6d926734fda271621ef918dc642d889e17e7516d74f8d8162b0c1fbbc5ba452623be355bff52c0182300cf4419666930f61625e8891d4ed8366b04a372aa7d5a196e12dc759f2a533a744a25f88b13f141561319c95f378495ae4c0e635c5d2b04171699a4f66a353cda51c0bec636b27718653fb2779274196fc773f6f319563c17a46da1a23554a5405e5c51d280a2b018a30be25e56fe043a5556323de3c8d42ab04bdeb581a0dc37612f9f9f6767f416dd0adb04a51df0741a9abc6cdbbcead3422f9f3dd5207294565187b92d49cbb6e9d064a9a1f0eb5818e7eeb5bfab11a715621312b7773960b8f7a38d5bc971e576b6e9e5ce169b45c1542fc6b01748402b535ceccccfc1ae4ba063cd311791ab1567e713ba1a9c8c25b07246f8bf693e2762f6be9db4edc47c5daedf7791afcd710cd1068db314dd915ed2ff0bc1bc35ecc226a811dab53319cb2044cb35ee67a0c13e0f602c36f1ab96e679f75914a10537247b0c462f45bc968ef921736d4c80a0bb279a5796fc7ae117b1eca46fcc685afd9659e8e8761f7e324241f9aeb8527cd6a4b26444a07d04fa7705787b5239c1e82b7e799ee4a39bc61d75bac8fa6c43b00101f5e9ab9265afc41d007721583a8df20b166783a3f44ddea610b3530e275b11233d273e065b483f6b3606d19573f79f70426b157df8976cc7875e9368522b78b1d8c53e77d315f103d6e9191810c11ae0c15f69d113876448103477239f539becbd4717e184c5b88a5f4bf868cb2612fbf2e6fe20b502fe2f1cfdf9a09c5a408631de616f440efb03fdd990f9f9d5593fde3b129aa251036ba1ebea26ac7f6f56315184965d97bf902b253cf3f1c42bff6ff4d1f6f0754e57c113b591a51088b9dedb79dbf6e2154a5bc9b38eae810ab05a1d090c03e98a9b25f77c20f05c894d4f16c0682dab5fc9c9c2ca81792a8f4e9e2c4cdad5745af46f438368439dc575db280dbec7cb499adef47e3d89a80a37a566bb176c60ab6428ae74b79f3f59b48d706842bd471cb55fcd2edab73317eaf2fb179cfb4ec47ee6e88ac86016a5d64adfe4b3d41a99d2159bced53f795983047c628d2978a8e6b89cc4f295ef6603f7cecda5078258da70056cf843f75b4b8ae910fa3c4018badbe8ecfad2f8b951bad568d33a615be5080a24abfa2dd1aef8be16b965a6bd72b5b03d2de4be8a38bcfb437ee5b05de5245a24966287352a5e2fd21b24bf07590a59fe952ee4725d72137e94710ecca9a8675e247daf7d05dcbbded451c2ae355aa52efac58b3f8d92addd14ffebc763fbe78e28911b958581901ba6a79854d8a4995d87f16d356e66fcf054fc511a51a8392c6375c3650206330ce9a3861923674527cfd8df420aeac88bb1bf80e499f8ce47e14a1a5ebba08c9d9d223ea132d962c04919e81343761c297b19e8758bd3a5ce4ebf47bd151005f48e079df0c01d743ac6b57b96b7e6ea4b64b866b83e1230bdbec7400a61b00cdf013a11134e591411e048d551422c4d588b341e78947f75b902cf9e1b677505a722043c822f9573187ec36f8350649bea1a16bf8ff61438d0c3b48ec79b57df775ae3a8cbe431f9a66a4c797e108581ef2838a4ed13e2ebc2e99857592c90c327021efd0ff5062c22d25b403772cc366a3fdde866473523f905b8fc9f0474e3254cd55ae837be59762d5cf45d3cc755b65fa0f8bf9071bb169642d2be2c3a69f7d7f7c68db02a02940887ae12f2721447443618b6444441e64d339aba9c9a0322e5c4a5c9bca3a3f723e61f0115b09e825d292bd372fbf2466f0fe33701e129276ef3c143e6e30ac545f4d76a49cf9cbcd7d60443be95ffc04873d21aaf5a58ba2d35cea6c190801ca3f87b0d3f9df96ba580e6960c7e2bf5a90b9e66731944b08d6cf59d7d46573e0c69234f3a4710c3da8bfae51edeb43c664ea7c22db4bb11924bb49c5d283b87a2b5a4bcbdbccd916983d8cfb11ea2aa5a1c67df4f576a41d9f124c0a9f180e9c7d66267c6af28f46497255c6b86805cb9f5157249c6f635884c5ca4a51884d40e7efb06d5b21118b67029888a4d1db699b7e41450ea601531cec35bf1e4c310635e80859c27ab30094215b1049f6ff6c349cc2ee1bed950001ff898b5caaba2366e8c64dba62c4bc6c9072a769f59a7bd077baeccb12615e07bb4b97a1f6613a9e1f0e3c59f64f8b40ebc213bb7534b70aef0574053cde64b78d5f9fe084635aad28d5ab81be7b5c3f9c4487b04f19877f09eff34b1bb90680fdbd3788a23664024c515e5175deb16690b9544939236b0de1c02bf51b9e54a63fce4a1352c579affb78a7e4dc0efd74693c0800d501a606232ee13ef92687cee80ae8a43f8a8c23bf83172bf5c984124d50744ddf8106f1e49538cc89c709ae01c5bedf9853459395b0f2d4450726524d0d13fd63cdbc804b99eae5e687846c8d1c6ac28fd554e0152db38ebff416b8bd047c1f94709eccf8bf08e564d86bb9d4d1cad0ea9e28420b5ef717c83c02df41d07f1c07c4d6204ae54649736410124390388c02323f6730a9b856dab10ef2b1b7896ac803b4ddc5f409ecf2202a86e0cd086312b77fe9f12c6e766d1567dfcc17f32abce1b9ff357caa00c1555edf91b09d08e32adf4c290833f6f11d33b1a6888d92118f61d0dfb028db46f70ad0e899de24da0eb588dc6d2a4a4241b30246f7b67cb7c4eaee4f1e6c0d871b7fd5945ae5f0064a065193fd97c864d2538b01f46d0dd0174c11a5bc34032fe11978de31e72c53a2c0e77e61ae4f72936ba5d06bc20c380ca2d0e36c987b79b421ab720bc2c68eba0576440b9d7b54f9905a5a026ca2c2cf7a4bbb98b20c1c9bfdba30c6a6e6566cdddfdecf27565712a39ca3d9b287b348e1ad47627b0532fb1b53658230cfc0d0b4eafd301a2c71dfca00483239dec306438b57bb89d529aba3bada985fafb3465e7bacb143eac51aecbf46ee7df1d7e466b41f263a43648d9dba79a6b446a8a0d92bebd713f28bf5539791b4c2893fa45b8858c5b227e3d47d90b902dcc66727b455d8af7745d3ca5c0d0ad9dc326b45b34239efadbbb42697cdc300f1cd3f99a946991452121f87106d388d716da06e2e222426d6aab3c67073d621a29e605b062b30b7815f71286689a7e38024f5299da85fe699b0e37920ea4c1b984dc4c088cb36727a55a0866d796f5267be0d2727b61219fbb7687a7bc4e0b2b32ea96fbc931643be7f5b2b2f6e3158a7ab2c5ee8c58482d3da49455b95c235726e8ba4bf563e852f4972872b9f265eedcd47548c7dfc23923d0275bb40bbdbc8c93c603696fe5aca21a6a3e8182d56d30314a77695e233a74d649e2536f92a26d4baf9c3b619d7eeefc045d952bbb5dab152abb699feb438bacf0cec61e83767506af7e2010ad86080c8876e43c50f85a98cd9928783d5ae79cec87e17179bfe362ff9e479e1d1d150a954d451ed3b3f8972af2f212ff8941cfae86b5fb3cc90ea26f5d5644dce94c24c2f3abfa7a0fcb52f6f27432055398413dbb59546d406ee3695aacd587b4339b341d602907a608ee80cde763cc70b9b07daa339517abf6344059cb5c95f0b7870e2729310e57286d57df12dc49926f003e1f829cecc55b1d37038844d673da5b67095608a0886dfd30e5f88b9a2188c3955bed0fdee6d6fc96c8f15f3beb812fbfc1ac21b1af065dfc990adc1cfe7ee1f54e57a469e97889c24b1e466129a57bb43735e5f0f1b01f8896e29188dd9cf7fd3623a354674e4c56d41bd811927af59be4c071b43d3876d7d8a62d1a32cdb6f4f0b61a5aaedd62d4f37e1cba49b2695471f7aff1bc74741ec6c8a6c51fd1f1087b652c5a8d70dc7f2f9a45d3df6ed6f319800d9213e17da7606e5ed96c7245b9f6819511fe6f929ad019b62f9475b48b80bbf5bf7416849ad19aebc99c560477939af0d5b67be42c67e237012d525e80f148b6b05d8fdc7932f5ce24ef2e1e6006e7ff391aa9f7d0f5f0d77c8b480922463125e3f099a75442cfe14500edae4755296486708afefdd207043fd8df89be58648ceca3eb5e26b7838217b8d85eea4b14cc84b963c8a1c3e92227fa8e04dad3a56cc431da35ba8ec493c0cf731f1e32e772f795bbf62351e20b3a0183e7c6c282259688220f9af0909e04d0faa38fce1db0f6be090732ad77dd57ea909b53202292ffc2f739088bf2007710a3ebf50886062b06cc1cf1c8ba1f32bfd4a35882dd5b7b6e1f38a833f438de54a1900685ac4453220b602a53e061189077e940dc8ef1f493ba4a3c2eb7f3505be2eed9381348d8ada3a83be00ab3321ef169a0595c9ccd9c363387c8cb40ce89fbbc70b37220353e0c0e97eb1b3c8cc38face5e4e0863136a177dda5bb51565f380ce636e0535d8613421cfa65f7cbfa04f4ee65004f5d84aa70f7edd222deb9647f2cb6656f79980e1e0b4d76f1962cf43ca9f2f6fa3dd17549784a44d542b9e4bd73d25e53260e9a7f642f06806140786f2253143be4a7996c875bbb5cc93e273e45924087aade5b579a1397b59e0dce417b3b03776e7ca71a4eedc16aa9f8f38d1bdfd52703c86d7fdbb0955ecd28978813ea61534fef865f2d792cdfc6aad523d5960d514452095386e679194d35fd92add08e49262aa2589d640f3e5e0e615fa5fb0b96aa62cf147fd51feb88f4f6da0e3b1d32061e719ea51028ccfaab4fa54edd1ba26decef30f3ba418e5a31a6db3e00958c2a97d1dd3362f6baf1975a81e078cf6245dc59a84464e62adbaf18f040fdea7fde0e9a10cd579afef5265731342692a8cb792678e9b68ee423ba2841ff40dfce195850ebac194bd43060baf1483d84f94b7bfefd9be25ad4e231dcb80a202a61696b673d037b2c47d893326522e7ac96960b1a613eed9bf2db63427ed7d760f4a084e8a888ec1913d7aebd52c79b373cc5fcb9e25c3c7699b255173604e7f57d57519010ef156af6b3c760f3df5b14223995a0711879e8ed500032170da4a2696ed785a14d517ff414006e733d0306f4cff3f4a9e215777e0dad2159343b81c52a3d64e8fdfefc793f1454d06693df5a83898579605c4a62edc99deca7f753a4425a9743f2c914c5e0ae7f3b21dfe4e0c6f93616b96ee2618556aba8acf45c93fe75f90be3a8fe4c48dcc4eb3c9010bc8d7433b8c9ae502859613b6789f8d83d42da4fcefc27f4bf3dfb7c6930b7bda26e191a254cc5a912c6d6b2ddc82870b97c89b719ac515374f9bf0e04610dd43e31b14ae71ba7ebdcb07eeeb2812d42ad3722ffcd039f88389023b5b6a2aa30608684769759e4100fd0848b9c53dfa27e6cf71b4b3264a3588dc195aeb4cd8d7af2eafe75a2a2cf7b499019a07945a84101aa2b4e6b0dc78c3c8287f6b5fa55bf2b982947ec063a757c412066f7a3b79a7af1524e0782204d2f14dd84c8a5787533d36bc67c5bb5ca53f34be503db2779d79f6461a40687ce525d45a9c1af66b831729bf8992d1686d16ef5c1e3207f0a5f25d6051203f9865b258814b8d04bb8c6381f26ae2c192c45f5f4348920da5083f67d666b01cc77d3f1ef91363277fb1887857a19e031675e6f0caa7e579b25da2c1b1b5bfdc01b1013934f8c3518f6fdc38fb8618b2d25a380f19a0dba008cae71b7d0a70f9eb45d6554410d657ac95327a3de803d5b570081e7ce4704dbe75250ebab31ecb3a362ca642685ea88228464b8dc5611977df092692300f6938fe02a2367c56f405ff0a2836f68238339d46bb51266ef95c332cef4c2c5f1ec625851db30eb0f41187c56f2c7303b5101c7709431128f9604d0f65e74b79125b043c95914e6bdfcc5f168c149592c641a86c98b643db0968b196c08e547fd9e15d476c747673e89f016b491beb290bcb3c45a5c2298fd8ff36cc263dafa0ab67d0e1949967e84704c77ba88c83fac6cf5ac2fd786a93dc7d71b7cb366742417c9de8b103c49739cfc85020565bdaea464adbaf88318c0fd118016bcfc8cc2b912ee94e8e34e2f525a2119efdb28d206822c3e5fdc87c5f0122173c3e8905f35e9b3eefa454dc30a15017122158bddb0a95a2d090756786b0c275d0f223ba08c283ee395fd78caf5334f9bda7035b7b6aac57d6dc8a24d110b54be23909f57e90c535f27f02f20ffda0eecaf8905682ab39c493d24ed96a27fea43c113c57941fb5f23f02760c625261bc81c48c25155165a51b7371ccdb7c790143ff9a701dad9f24751fd613fe95fd34b31c9c6145a97c3cf78dc286676b167daa02fdd2018d258746272e0ce80dc02ac2c177704805464fef538451ed6c4c23d1b514e4d0adb93430a57b146a3ac898de4d216c6eb7ae173cb13893a37ef76bff231c5cf42971b475f16d2b2a7a2b0b5d291a5c04f5510f9c0dc4cba5bf2f3fef7bfd7453b89f82e2928f707bf66b48c2e90800c93fead7cc8f1b320c9f05b1bfdc0db6bb286565d1f16a6fef06e10659675e9d6b0b250d3206e497c485b4c3861936eacb3508d6400dffeb16b07aac720304065093e3fe9f766a8040a17030c95c2c7621009bd681989d523bac6c6f2a27b66698be39a7febd736913c0f601318512d8c9bca359ff5abec3ef181333eb45921815751ecb0be910f819da677baf2f3f0604efcb962b74318d734c39039e8ec1165d4f562a6c9eb486692e9ae65519a17b680fcedb9b640988293dd55620ed023b336709a45f01dc40a5a29d3c8021b76c8a71863f261f97c0f7e4212a0445ea8832322b18990a032a6db3c3a624510fa8cf3afae73da9bd3d8fbf2889b3535a0dc7617ebe6e9f114a20acd8527467614f29ab7ec84dddc80ffc005b2f968a1ace107bcf0826f005d17fdeb7ec122e37046cd79e106027499398bade90408f9ee1fae2e2908a9a154e279b6f3cfac1e690551a135c3d6c0f17ec0da39f2a343db3ab6d3364851d2286468ce07350f7236259a3b3f9d78e7b067003d40aa05f476be15c7192f980b40b98b372175551cf6061573d6e99531ff0c18d06cbad4b5dca175edc5034011d10470fe8c1b98c4b06682232a476533b53645b128f00ec2a04acdacce077c6d9738613cf1c83d9d7a5727e5c40b0f9db529a5e57e21cde78c26e721267aa727cbd9869e72000d422bd2d6758d5076bfeeda07ad277db1f5dfdd9598e23b3923bb1e2412ba05f5168cfb14c6724fd6fcc1e7c836c181ebee84b96356af5b3553e6bae52b7de197a336c60a603a100340f570e44871a536ade53af0e8b45f2cc424f2d5198ff86fb7906cb0286fd22738e13e093d4537bf5549b74be867b3bd327102209724cd1503d402d1d5e30bd348e32fdb9e1cc5e1411f86f3f9f3b8bc42432a8b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
