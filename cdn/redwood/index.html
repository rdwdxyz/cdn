<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7db0f5fd6b92649235e2e076b13508980be16eee2442c569d324c8975ff5b6c11ed5619ce0bcebbbd1471380f4e9f6293e2dbdf1b7634ae9cdc7e244f350a9555026648041ae034cf256417addc22f0fad3bfe6ca38cb66120d578b2b07827ae3a1501e567ba553953660f49e2e57b6e4a13a6e334904f8042a9d46522cb597d80ec718253bfb67164705c4ffa2d05e846c86b4bede6b2d333c75c4e4455ac76b29b135924fbb9f3f4191ffbe29944cfc73fb960324889bd105a89cba01c82dc098b94995c5865e68f38735d63c743751bef0905e13a5c560f667486f834af3953b99d0a7481ae9fabfe9a40b61caeaae779caaf3dd88a527b790a92c423f8e2bb316d7d10be1b4b1c26d7ddf948e6894846c7e9c6eaded4b3471dd4d5a30472d841d717e5e99c5d456b0b63020f8a4b5630df4268d2a5a9ca75bcc01d541c0475e22c05edcab078a334c3e9148e311f0f8eafe6deb1406e2a05075c9efb81ca62aac05dd52df12e6ab204450aed35d88c1886e053e1222d6ed6210922b8fae062fb044fc10472c6e74a9e504675a899658088aa1e6dda14eb69614a7e9650258387933edceb275cae242b5e09bfeeea6f043d798ce5f6158c1970e2e178626c8eb49cb041bb55ba0019aa1768a65ea507c07c99167e5646c1f22a41ff3e18af2322141ec8c48aedac1554b72fe1367f91d7673a32b8376a8d2d61a1f9761be56aea31fc76a77225b09fa2cf035ff959aa1677223484b6dc5bc576afe9933295f3644960f427c7d776de389dfc7c52a61dd0daee2a5a96f6b2896240117ee42ef2b9bfb9c54c285bd8278bdc0eb13a8a255d7b61fe97af53b58f0a0dbc3de11f10ac114e13431bfa30eb3a731f93f8b2a5f578981773de9caf3bd7441dfe8a9afbbe6aabdf3a86bdd275e572303cceb799830596041d185f3fc3d39a7a204752e38c865197484f9ad0c82ce453e272cd8ce7fd31bb964f7d22c062339a3c5d0ad03ed9abc2f1ac73d162a23ca424fab066aec882c6a5f0b6717535d7f5fdad2796a53aff12ddca061e010605d6ab6ab6589bbac87650386bd6ae70a06db99ffbba02556fab79ca562827945d7e3a4b60edac0607e54bc5e8364f13bf5afca54e86afe95092d07ae7bb311a36ecd266b17415ca418d0d2e88a5de379e7c26883ac553d8e78300abead806579ed015cabeaeb492adc9e6e0aca74840c40ca58a496894624bab7442369003fb2522bde415ce902f1986913f58774525f9bee38140079e55d1f67d4172985e1337fc6b92d462153517b84d60a239a1b16f8cb0fdd81ec126d00aecf9d1221d9ea76fcc9fcd1dece545c85929c8dff0a9bb5a5b8cfd9d60079336ad7cae26ed1c92d56915837a5d189675a396b82367aa0d6d9520d26589ad785835354e4394f76f30daaae71bcc1fc351e796cf0b4d85f44bcae696c74c59d97a597d30c4d00791069e18f466f2f77fcb77bf70e26317db492a4f5c69f7fb5f118fc55827a45ae087adbb4238e0e258903953630c56d6982a92505f243a1ca16cf226ac3ac14de970d6349c643a8b64dcfa9da39965b169080a2a66a4d1dab0d6761b948011c380eb462ea7ddf47c73354986be1c5a8bd53626c5bfffc9afb1ae8028a847a8b77034b68c04474b1cb1a0f5c19668e2b131126a57c83df2a9360c221bf17705a7dc56da94f540a1a4faa4499570e6b6cc38fa1100b925d5a5c747896c77a53479759d9a085d8fd4f45fa3306080b79b8d6be7661dbd0453195cfb682fa619d53ee2da49f057e1d622260604c20f92353151d161dca0c12da8ecb48d2ed0e8df6b3eed21e1156041cb165b810434bbc567d97348e3c57e5737518a606165171addfbdd99caffd5830e5d35c9cd3bb4eecbd38b768c035d7eb7eaa14da6ccdad2982dd645797e69cd5df6d00c5147a9a0b09e95f7e5ae648b304ac29b3398dabf773d49da13b32ba20382496f5b2af85544a83a4e45d5dfc35a0ffd6ca17fcbfb9e705d203e2478bdd1be7d4b85fa8bb2120f9e723285d917e05954211ce6e7a88df7d23780fa2d0dc19b59bfd333be0f982592de71f4fabc010a799b1ee8457534b941c7f86f8bb18f229dc1865a73dcb6b85c331b2882a0d610cfc825d74e2686984d616c63cd63541c2a63ffc3537a6bcbe6f8223d2cc2c8cb9a2024634e2a457ac4e3e4978aa5a4bb41dbaaea835e5fa24303c346d5b6922613c2f34e3278d4f51914bfdcdc07a0dfd2ba1b5272997222bb6c2714fa35bb745654e9713b82d595af6f07a622b9ec5c6cf95849cbb7c6281e32863cddeb9f2c7992ff8b8dcf50684ec461b6108462670931fbd1e8cb054b3887a58c232e8c1fa5dc48314f50832f903ebadf05c1ad1b9fe5edf3aee41888a10cb0668865ca1ff9d27cb04b17c67aed679a16fb4f81000541c0861b138b5bb9419d522e0e8a4ea2679cf31b2e6fc89dae20024c40f4c5b8e061de1e4623642648a1a5a8070b3843a1b12201598a62f2c8493c69b0f9ac62f9b608233c8bef4a9e3bb0fb9335f4438ce85ed60e328c3ed4b5f97e94f79c258d1d6fb6033e53fc972f192106f77ef49880731af7bd3c8024c61637d8212e28849ef974e1d122079ef77cba041a6d2f9d448e2daf60f01401b6d058918a3e7f5e15d202a19b544a834705c4e3a9eaa9d7b55f60a8f83e70e9446a1ae795ee3aea3e8994d16c6ea77c93ada72d182cdeeaeca4ece41d29fbfae8d56aa1d60463ab25db2eda10783e7361c801efadb2cc988c4b80025c95bcc7e3fde59513cb4906fa76288080b21e6d3f0bb62631a5334182bebb8f059d5259d8e0fda63124b28a2c1ee46945cb1beacaa8fc68f4a22d909787770f6644508bd0d44d2d301c142fefc603c356506256df312a9aa243b24050d4e4e914dee06600a036fd97d518609703316063c25706c557c68487aead8ecd4353f52e41668d889ac530e0feeb1160836bc028d20c0f0751f9a2c74784456bf995bd0207fff2185dafe20ddc8a1c47b0b5cc8266a0ca4bcbf8370536c7ec698c34ac04397aa10fc91aa8ca282a25e4c47a655b465d63bc011ff0cfd5c625b7994a882f33204e956cae8d03d7ddcc467b42d384556993dfe214f4fafe98ee6e8d0469b88520b34a495c36b0c3d2616c8e347f303e99d0d018f35f00694b32d5dd58791104a65fccb05a676763f063d2fae4caa56e8946d95aa94d399e2541428b23d1eee04d48d31e5f838a83f6c1cd9a6376a3c3fa05f18dd0aac580275a1b62f7970797009c9d31a4ebf8c8d559f4210f87ca45979bf096fe4e30324b1d57605fb04a28dc6f6dd8211fbf1c4507ffeeb0e49b5c0b191313b02a617c3dcce646783c5461c870c2c8d1ce115a118bfa0e9a9a5fe42b4ed28f34f30e15782c2c55ab6d1ab8e4ebe667a0e5003ad476383a0b2c4b9941dd78f97c6e3d2c98e673f1fdbc6b681446598c8c9bacfbac8e6af7064bda870df91280e3e5da51fabde57550e9f1592b55dc46e3902f9b20eea6e2ac3ab77f412b6e23d7a40f28348777d69a281a9b73731f4d9bc8e150c8da6b7c56d6e6627c5b6b62b8fab08109a1279276d510e99c5122a79e68925b950f935a214cfa7f49758d72224a0340156b850994439ec062c433e27fb9fff7bf20c77aba7df01bf10fd6b9555357606f0abb9ba314c5cd9b16e735d542527e18bf254176870b405ec571932c122a70f94e45d59f15bf6c07a1aa0a18996049afe4db73ae5ae996e75bd137e23d35c2a07adde1e82a0ea680f38d4754edb2b504a4acecdee9f3170ed69b664897ccf3ff39afc8500ff7336150e705e90014a05c14ff677bb1083c8d3e8a483cca5df2ad03c3d9611ac3f9d38498972d6ea5f4db256e8fb45f6784ba7e18127f69faf71890ecf8b3c85837dd4d0f3878e6099795368f3a5272a68f7e59eb09983ed683099be569e746f923bba5c96b50b1b885beb4b376722fb2aa0e515d431a01c7fc6ed4d9ae90103b4b3874fa8738e5a5f5cb83df861335125c2cdc479713afc16d86a6c47868dded324621af585a6ae38b199000848afb1136d07f4df6fc273327a9cf05ba49af4f5cbb33d4c3a27a6300c8bd2e7df5b5764c4ef6f07a85cbfb41990712a07ff3c6e7e4a250a7174593b91c54b7a307eab930bfc5c56e64af88c5a6052f44878e88fb8be3e6f114a8cf96c95b6048baaf172e7c1999c5418acb1a96008e3a01dcee2a6c25a4f09849f705300d399c08b70726198c76c03e5f09a74d14a0898182520ddca012d3183bcb69b7d9954f0db8d640d2d6513ee2a9089ae0660f7d66041a2ef18981a7b64b218e676bf5bedeb0d5ec4dde4532565640d21cad9a5d4e4c66957965154ce00232a0050c90033a1f9e97457ed20cf71febdabfcb2d7a5ff9dbdd6aa2cfe3f90f1b50dc3479c6cba1b08c6c08fc554a0458e861fb0fb1512e4d09ef9bbbb03cceba7179a120c1dcf0c12a6e4b0f5069b7873cb490007a8a4ac78b1cc11d91d3ea1ea23b05f72d2e8d2f4acc5f2d0eb8a2835f79df21ec79f5b9de51a45136cf06874c45b2bd5ae939911323063c3ccd0137aa85fcc0941f1b36a7084fb631e0817bd1ba96fa2448119f87ea9d1ed7a2e6524cb114a7fbe7b3ef52db73ee9cb4c43f0993be68369a7ad5f2b681b5147460536c2c63689ebdd5813f9ab09bac011c4ce18c0cad21f5477bf6a56758c7793ff2448a3b3715f448efececfe19c739b8be633deb2e538b41b07c9beeb7b8541974998e06b70968d53b4b0f05ea9c5fcb0c5592dc369c7c7c6cf91234d87bfb5af99109f73a15f403a2b41757b71691ddf52968a15fa8e95f3a8dcdef5bd482e6613abfc05e89bdf3b92d06606a689dc6974e042844f4048d8631538adebbde40d2499bb119f55b4af4878d8cca90ee4c4a158fb56914b893fd996d529824b9cd2dcf504a74b16ee090ff515a4d83f0ece321f325879094b49c2036edce4be1de249cf9142afc4d56465601fc133e669b20c077a71099160106c4953db986c749c90e8a52da26c04dff31f31e6cbcb373f76bb5249c2039f3fb1a5c241e7a3319afef1e8dc9fee1cd1469fccb33abb4297a6ddaf891ec20f2a52f39efa1b2abaf3cee206ffb9a6b484faa6010b3725152232a4bc80c82f72560296877f866ee7e4d041513f19c554f72cf380d7a1e39d932befdd362c4c563385bfcecda2f8a8ee0da186cb34bff9e7772f178c8fb148dc7d65f467bdf6d48be6ea6ea34ddf62e0c7deb9da78f7fff79595d1ff1c6526cf0b156277baeaee7857f4ecb72c93c1085bb5fed0a279d55c19fc6b84b2308ca65f6d02c4cd0ff147821980804f270a49a06a0e20362d3d11693ce6545d02f2728a8da15d5830b5cb92bb98456ee3f508ccefb7ef0c73a76aff2a75c47270ff6821cdbc38b1025c582d5805c0742f8f7e64bb12e46c23ddeeb93211ad8eb7ba62379588d718d4c24832335a6e90dbbdb30cc210969bda796c2897615d4675ec8269cba5568e752a661b055233f2a0fe58e6a8b150d3df7dcaaa934358f5260415f54fbda96c209b617b611802a98c709a0cf6c3220668edd95ea772d9293bb7d431adcc1170345859915244b83bbfacfb24ba82c93f608b9bd945828f1542d66c026623086dde55df790bf8a79f2380038559e7364d06e39672b7bc5f94160f627a180ba777a50f6670cb2f969b3cf8e57d04edbe8cc13ba35f0299a13e0bca66399547c643f14cb1657b8eb35bea8f2bd6f50e28463dcbb45e0a99c7e23085a3019b5c6b3865263d9ab43f58ada0d2f07b7b2bfaedc2390ffc76dd8b375face8dc3be83302b60b7c1f63f09f00494f8c1d81d638ee744b37e08a6bca0c063aed8a523fc90665fa040763b9bb52a8ead96ee9bd52fd1480f557988efbb7a4138eb010cfac61c4cbdbf470156e2d935f405819387d24d0ca6b49673f0a5820e7d774c8f45d87939ce43a48c775a1d676b2c9681e4b45263f37177fab6a75b965029ba1460bdcf476be4a0f5019e9c23f25a18d68a82d010f6519f58925f25623196397f49ab95dd89fbdc7030a893cabf67ecd6f15183f97f6837cc80f0ba18ff529b24737f07f173ff00c13932e3ad78d0161f7bc866d7e94892e58b0efc2ed3a4bc139f6d806e14c5cfcb55577028e6dea8a903b2d80ce73120068bdae5c48060a4b30c3a7c479cc2e8ab8e5e6f0192cd4e5cf84dee6811e80402f036d8677ca9fa8fc1d45b864e3b5f13312817daafb5cbf834ea14f5e417d0c05d761b0a8bd8f2242cd3c548f27bff6ffe65c21da0604dd4585d01796c2f6ac84a12fe81312c4c5580bcb9f07a2d9548266837dadb7839f2780e4e85be3c9601de20c3e19fd0661fb161525d6dfe3029ed557abcf6593880f4ad159bff969779ab959377c97b0938bb52b16f66c5b3cd0bb88e87eb5937b53a2b8f441048b2bd1971263dc17c07183494466eb97479661b689ae2bb013ed94cec06f516fdf182867e16d0794546c3b959446eedba3738af0b6ccb89493235cfbce901073270f4fa9db3792a2b244dd69bf9751ab685daacc4aceb64cc365d99afdeeeb0bd77f63826e7b7607490b689ed89e83cb385620a85e5f692f5a9a9b31b4667f342d0f9abf0bbd8802aaba5b7e6c57aeb4d0f0ceca52468446e2ce31fa0f01c96e1bf5f3715807ddb1158073e3a89e262cc8d5aea57f0f3fbf97b0d9d81452ca8ddb1ec6286df131cc4d44c3e3d124a67c7b1a12470b18c33188d1b3ac1c1473c9b24e013a5e738adac64fb771c284b255f4c8e21392362b3d52d89483431d58bcff5612f8ea4b6a94bb54996a4cf1d30b08750aea79d6dfd3c10721b1d0c3af06071d91410cf27ad219b6ed432f7f77a094e11dc590be1f345173246b442a04fa6eaec4234e49be495fa8abc665d12e693205b99e7a314dcfb2d53019a4d71be8e8080362b578997152ee151fbec06097ddf884dbb05299a73dea7741ce1039a98cd383812225583b7497c7d3ace211615e25a51c8825b983ff4be3608213d4e84a54f796917303a687f6877f3f625d15627900f3e556bcf1d70dbcf45f0630ffbd370a72ac670be7b6184c3dba7c4e5827df99a271ff2c81add0e7504e38058ea9c54bafdec11b388074aaf1e6df88897b392e7c46f6fa403a887f324e3a0e9d78fea9db81e7c831982eda9c498641acd18f98df5e771991685ff5464876cc2f5b14b868ea5e21de5bc700a9fdb1bb8f0230d1fb36e2b7dda2a18d85bb060ac39c564ec7a0f2ec9fed4fa3e6de4f1a37011aafa13daeadb9a42468771f84684d22904814e47951979754b76d1be0d8a6bb9dd6138a8735144d07d9c0696522de6ea82dc38aaee231c386010b4c3b58d58dc0c41b0d2db0c7a2becdb89021c4790a3d2022ed520e077ebd208a215b275def4650f283c96de981689f0f0528acb818b3eb37b251dd61c577419bfacf680c74322bb283290ad083bfe3a0d35f6271a7c4c57b2e294fb4c8582a0ee66f0ba11b82dea69076b450d866f61e5c2357632ded7032972663f8ec2d9da98089d9cdbe97c9f1ad9fad422f31703bbd941627f940645fdedc6b2e9386dd1b08db5b476b5ae8e9b4eac4e1880912ce54dc53b74a399071f549a11e6854027268632ba1ecfdf25c876c1c0283ca697339a1e2b56f29b99e17952309d852afdd9a3ed0c91db55342d7706012cedc27d670c9863715e3a13bff48074cc26a700b83f98e1cd047f5a4342d3f56f1ccccc7715b960b159ffd8dd45d2b040b297e390fde3db6c0751c96e8c542a653e22cea9ef13b0de9b0cde68f389ddaf3c9f4be4791aff941c6b7b8c4c257b5cac6810d9c370534bc92ff9851b023529e545b51f1327df1ba4c7b69278fd0916d0d76ca9743c861870dfab1109c3a51daedda57d219123a0bfddd4d039b5115fab2cf9d8fac64df41f6b037779c00ed91a3c8dfe0acdda544958aa1fbaae26d14ba75c210aad294027a1c481b82314e91b5216aa5dc559a44c68c6899f81ad93215a07577e238407ff4665ce8843caecf74e3faedabb2926f62e45c1ead38f5aa0934b43178d1e0660f43d9cc6e98fb0e3453ff4dc9edd7d57df101acc128eb6ffad4b950ae59c2bdc165eede0df5bf024d657d92ff9eb72b508a804eaa33915925cd33ef925b4767242430dc26b9f22644c62b45b1bef9847f7c18e2cbc6feb828aba2debd33d203db3470b8b761b29cd64e4cc5862910eaf58dc41cdbab0c7c2109c09269e6b5092ee4df078beef8092b2b4456032d9b5f9f04527a002fc1eab2907cc4db77fd99f4690d016fd8d59b613e89eeaaf0985c7199e2d8598687a12493cf73e6280e59dd225887ec3ef2f5fc8cecfa9997bde90872b15691ba8140bd42171216240c37ec6e69aa08e057ed89028f1059f3799969a922c697fb9e385ba29ac962d724fd6db9c8cc0ca45afed10c34d7447d2ab7061e7f38719d9335eabea546445d60539f87b50ae1b35577cfd22f8a13303570721536713ee17bd159ff1298edfa2908170c88ed49a92ac0b75a3c8d328b86bc4f46df42d385cbbc36b8d3b9573666d1c43caef7bda588c97ee52e174a470d26aa03dcd0d208ab5a7a3ad069312ebbcabf59aa8eae288a359003947a74c6af929df001caad9d1e4c54c158220cb4b34654c6b0bac3de02e71bb0796a564dd02df16a90d2a4823af38f594edaae8859db8012f05a0718cd94003eb015835564f4dec93724114b4967e681e66eecf13b7e64e080c693e79b6e6c97d8d931f8d0e9a5c922ad857c62adc351a0ec169459e7120b73a6e6ba967c536082c4d600814b60e4aaeb21706efb5cab77c0c5965e72d42efd59b0b675cca7130e878789ac4b16c06f99278a6748f891b1aec36a93671bd80931e8885ce35d71cb38265de1ff000c2a529d0470b81f8e4c07377eeb561e32ada7fa73ecb357f470811e61739dfd6ff2ca9034ef5e845a8066a0056ecd76a27ec7d4ef2c18cdc6de90179eba66bca910a64977665c9456c26753d4e1989b85bbe44fa93f1b5d167a7059c4fca9280754dbc402cb3929a32ae5a71a595d0aaf6a048f32ff7ceb165b2ea310441c0a9e754d35771710ffad05a28e82edcbcf8f5147eceb14ab723da87b2db3e365679e5b4bdf053df2485628e762fd1fdff6608187f9ab4e31415caa53fbd5dab440b47cdd9102d3d9f8bb8eae44705e8fb0407f76937cd8f212cebacd188df22db484ed5d2563c83a87e02386e654b14954c86abb02237b4210663651e53eb581623b1cbeed5a99eee1de343ee6924a03681042d3bf7440471765dcc6189305ebd86aeab5eba79385bef6ec2ea260191b5576e8e5e4ae0526127fba621a4c3626f31f5f681d418b85fad38d51a85699984d6d3f9854d8d1f6be84401e95060cf7d58b66a3a22d77bc4558aaf7f0d4d376e07c5b74a9da76578b025bd41e1acfab49c4af30426f737ab2f2db31a223c6e0c48fcbaf54d47f75e8070261d5befd19f590358667b77f66d44aa3960d2d8ddca30748a16f229415593a1262c6f0103a8ee2659d5a2b59c1ecb2ffa16c16bb6f63bfb4314b3ebd4c1ab4ce7f3182c80fd76f6ccee7fb64872ced2b03f55289ea87c469d13b00649a9fb37cd2e0cd7ccc42b6efd5493883b7dc12c590dab0afff319f4bdda90b4510ac04ef5f2c491d0f675c3a5c46c8e1d7af6ff1ed6913db1e928046c5c465bfce2c51c86fbc6be42e3f3ae21b6da80f582b75b054b49c6311de0f80366c7b1d5257167c7f911dc2af3e0f44d87151b203956c51990a6e595122decb7ec57f5d2602859a57a2379dcda6e08c2399403037d144b083880b5fb04e7bcb21ab90cbfafe8adfeffefd49c7a0598586bdb9057c82fa25b2535035a76c7d44178465e475d6a368110a9da8ae043e1922bae0e584f87f757d2db36be81ba5c5087a9ec63435c067221a3d51a90f4ff650f57297e6e37ce937d22a3dcf5d4b47732801dea63c6e22b2468d1ab4228f04c67d304eae68d2f8454a2ef9c141359828e88634424b4410f484e257cdbe5638e305381bd092eb198d2f05c14b43620bd003a7d953d43a493be67571ac39da3add32c3280538d4c173c75588b16c1fe419af81d09bbac02dc5e57cf3b08c3c9e9fab8281a3cb5c516e12905ec86dad7a17f395458eebf0e9de4c1707a0c9a2a8208f98ec0b11b59b3ed8d750e6012034eb8ff636a0692deb4344c983b5f7793f1a336f78acb428af426854632e40ba7ba2c0af0d480a5315d18e0a83f481f86789ddf4a8124a19a159b75b4c19171b5d46b5be0067a60f1dc7ac58e14eb85aab20453168fd10f618608eaaccaaa1633b819ce3a6b3f05fe8ed596dc03d0930acbf806469e34236c2c95f2aa21aa5b9f386ed8ffd05ff15cc33a31788569ee70e89fc818d9f0c8f82834a0f419c0da4ba8c78d2b54c3561c34884191df9f7b390c00bbb693c4f7f8dd6ce262988171adf49352eca03fd2a8886a46208a1d3bb7d5ec5ed6af5296de0cc176fd8f9d2ea71ac753164b017eddb8de39f7f1528fd309668521c62d9408333cbb0067fbc356c5640cbbe3662419e1397f7aac2418ac2e207f1f21683b3fb014c0eb052e7b8321a9ba39f611447168136a7da73f0dd9a861a4ac9fc28916c520367f22725ace85f106a3ae19043af0e46f2f238134abda25c1b749372f5b92d92f6e1ceabfb2bfd63d162b889c673f690ef683a866643fa7023eeb595a242a78e4cb18eaa8b2e0cfe996bfc982b619bc31e58ad6dc25fdd1875634c2362a5bea0d2280a58eb8fe9e0b5d4bb960913cb9eefec389e24566293f0aa715afc5241e43b05839f0fcc44f47ad8fcd2f93f2669d1f46baa71f2473da38b7f1100102875023576b33122ee80ffc34702615906681229c3ba5b96e8fa8239cb9d106981969ab596a0eb31b501654c95d25d11c3126b09ed2fe66147ed1e11acb8497ce1bf67962f1d1ac2d290130fd335a3f916e06cad1d6a7660f4ef3cf093996cd508d261dede622397a2295f7aee2757ff5d804ecfc6de56c82fcf3da9c63c5a10fea228974f795c9b5b88dfa530d7a5a3f05a101e9d14d343a2453d1cbcf91087a72826be56fc72266ee80cda0704e36e328cf8f415c3728c2a98659c1620ef72db57dbc802ae285d900e8c9d9307875181f16534bcff70580d9dc053262aac570299e81fc22dc14a3df2c2ac7829fc3492d1153eaf62432a30a18aa760f596d39766a75eaa92dee7c9d218e65cc68d6b15749dc6d1668cf0bcd96f0fa8103e6eb053c94e13b169745b7c7d632382c42f6a4018f0d2f333aa56e6be918730fd85190db851210d9f6eaef07b7ba820166b205899567e6b779ac8bf767936ec92ae007266f9f098768077df6d4178a051fcfa5f71fc4c47466dee64cc3ef9172c1d0ce95552beff1cdb0ea98613468eb2ec922c8eb7794c4bd10901498c80803a42c7e33c137b853b3aee3f9aec4255e50871721db593ebfcd7789acbcc47607c6dabd010addc32ceb0b980df18be0f693d272bfdd3280459c229eb40bcce53b724a913307c14ff63dc50fc944353303338dc2a568193871ce86bdf26686cba19fc4f8aa66ec447cced38edffe1c738764a1f3d6cbde4204a16132c2caf95f9aac13c3ad048224acde07321a67b0f8e4cbf665549eefbe14e601e3bd2e7c01338a39b257cb2bde6c01ed4b0380fb2445ab6deb929681ba4c4fa616ce4539aeddbebaebba6f0ba2c7e34e22dabae70c239fce51e4e6c0003360fd47ecc8b4d8b3df7116d6e94b49ddc6661c37af048167b5fecb7865608581129a857042d4ef1b2dae3fb65b50e3f5cd9d57e105eb6349571a10b1323c287dfc14cfcc4c1a1ee8341e4ca18eeffa657a3f7a6ffd580490f16fe7884c0d9a4b29046309f93963b764d7c815ab1c4e6e5452838d3447180bfac67ad361cfb118dc8719a66727b4afb2c99176c33a7f1c4d5f7bce1237d7f77e536791615a9037c48decec411d956f0a477be2f2b32aba7dd766de6400ec0786b1a56e147d642f2e7b940060ccaf9515e35b35f67e4e3327b9fda36397eae0c95db492f7623e533824c42b624bc55b36472bf11527c2d9bab40e3b19208ef5c2c082ac7993d9e5344c3e370b89f1adc0e54b50bdee66d30cf4b8960a7f68f913508015dd0bd499410b2ae1f364442ce88c1703d047cffe011bdecb67710fc065131e418c24ece192ce26a5d3a80c3b183f275633d7fb9528ee98de1adafbd251bde2935de7b15b66bc3e10a5c3ca5dcb00d3471bae7c8adade574d070377a29b718c4c25c5527b5eb9d7f3db1287dcbf88c50437a6aae30d18cbbfed11934918c6905c3868bd6b3f666ef43c92c48a57656e145007287741c383aa26675891474a926c623580e08bfce8b5f8bd2074a09f496718565f1770e642f25286a3e4b4b16bef53611e17e41edb573b3474f7b0f1535a8f57d60b55a2b82d95aa8342fea1655aceff94803eac49c612bd2bdf81941d6a426f2f79c7a875a190ae0feacbc998a4b29a2d1d76c3571b2d87ef631e6f9f66f88cee97e9f2fb5b0edd73bfcd349a16ccb19640c9c3aa18211ad8cdf8330d8dd20749979f951e467bce6b6c75c6288d02af520b4b0ddb735f54c621e207af81ee7b4492ba6927d783c6d75763e4807a70f6e1ecec7417a1f77fb8602ff96bdd924e21387bc6fe9d03b8e56a6359fad20e0c85b23b00a9f0036e9a0ab613d5a32a6b359b0962ff3bc8111fdd9ca334d734e889ab7b1773b00bcbe1b30e532a59646154146567fc9514cd76d7698a66d765d4ee8e2e7a96438caf9d41bf4253581573c6103e331c707cc96612e94a8659130f0ae48b15ab15ab956b1f220fe490209c6943abacd64ba05649171f1b3c5e4d5d92ae48dee8ee6d19596d629bde5f43447302cb73852386028f09b49eeddcf6590c1f9fe0ee28546b53ba8596a9ac33386d8f144c8c51e9ec81c31c69eec9251e3e4c42d40f7c38b38992cb27a4b2832e6865219fb0080a768fd5b15ce216c5bd5629fe5a7f62f651aa12a6caf5c909394a1d79fdc686969cb58a6c72c7a917f3d2b729445450decb9f15c0f73c43cbd25e1214f57ea467381793713c22b4b9f0a14e64594dea78d49f4433ed2337baa23ed8bbe4c22a3205c31376546e0e8b5670a6be7c79ee423cffbdc25551fe6125fcfbc50607456b121260010bd5f6016301fb4893764e0107793c91b3f063876e9e650511741e78c652d40a87e7b3b0690bed6154fb56668c0620856a4dbdd5c969dfb2ebb38f5c7d4828e31ced905383f2c17cfbc2a9add0b5a8c349fcecb3c11bfb287dc2571a296deb9b49e9ac125343fad044a617558f41f7997f050c73d0c43726637772ebab15ca39af4393b7b0948178f031238139a473de24cca4f5fd191068d76323a8a1b9b6ca375d3abf14f402c3260ef255a2ed266e3a8c36cd655f232e3ebafa5fd6ea0642f0d016b053d8f2d36bfe58443dfb1ea603c058ab924ac10cd6f009d83dd0087a7034d26708a9a95ca49d8282913a129865ec600f6bef9e369f874b6d888e49b43754ff0d3980436c0029864afe3a75523d8d843b3f56c7ee0afe7e4857952a26153e2632e1da1e40b7696e04e18d9d0ccec8ae09d903ef6d29d1fde28e250233aa23abd16e7e86af98b53f20295599517cc30950e51539931554f9dd35940b351dc2b0f918c49bf999c462ca15826c4a6d28eba7e13e6052787f8db57cae910309218e3442dd28ca62ca7a7ba7708cb97488197ddee920cdf5bd29eee25e3992aea6fb74ad7bdc9cf06bbcb94ed480932d406eeb4767dffb886e4f7e9893bb26d9a03392ada47af82019f763d55cbb5cd326ec25cb59be522bfdbada9842977e565c7f28ccfd6d83f46d387b41f7892a022d6617d1ca2fee29a2976d68f636af31e0bdd7cb6d6849caefbbbefa2834aa2613fdd37c72e6d774d748116692523a4cf1ed1520824ca4aa44f45501e415c653dbab8bfe76d6f36d1a08182809eaf0498b242d92bfb095f1c3ef0b71a2f3fb936b4ba5babab620472eed8a55993b7827608dcee6bea88375979804513a8ced7560f5c246e8758bd20340aeb30bba80485655e88929bad929b2a50ac21dd37f2ac0d423de1ca7cb18adef9e8cf53107b9b972b85b66b3bbc767d4be2920789c53ffdd6621898def0d6a5d40cb49c4888358f79c69299d8f5582ff0225c527cd406b981582e99c5b53908112f70d283843f6ddc92bea47bb3606c3c25d9182c589e799e21b8e9bdc14f415ac8834580d2506e837c1d618336d5e02ebcfd9e540b0382a9f93e266a122bc9733fd9388db3ba835a464da0da560ebe7435cf0bfcafd3788f95d89c8c146d56e4d12f50131380cb6aa0dc5bbfd23406bf108df110696c2fbfdaa641d4ce02f9affda5a3243d749f13ab656096bd91122b35b454725e2fba30e5c38f18cba39d5a6a9b69bf88d1f67da7ecd353ccc4a5b79abad7b5ce22043c5cded04f85b0657d76ca25969658951f113a1fea04ea6c63bb238cff2d854b2d2761ddcd5b3bdce3146b0869b220148212707cda411dfc83d001ad366dc7f736ec9c8d67f914e203ff9017750df508a01777d8e113a1eb0f509a243f90d55efc2dedfc9608e1c175eaacf2bfd64be3f48c643254cabc63810b0465a2566f232a13896b5e5c90eb8d3732d3b188145c0e09cdb9d847e864228933c173ff5bb48b6e85c76f6a460bda96237a3cc896a34d8bf843e960bdd59f0d889213505409f76dc662bea518046c49fcf508ecbba7ade59033d66cf24c77f57276b6585f212fba9f6663d794dcbde0ad20f8244ecbb7676a45bb46ea93b21ccdca70f21dddfc8a4430c637f71d6afeeae7c4f2c7a2ff89eee3fa953e99fa04f31e677456552dc355971ec3c98d74676ecde19c2648d771c2039e951bd721c7aceca4613fd6134a469f170e068c5d93eaaf68bea4c8613cb5d3df262feff5cbb8a2f527a3c38ce98eed5dd779854dd9fdf855fe12172a80f6c9ef77d9d1d95dcbdb7dbec7f84a2068646fd45f39f33c680050338298f690163b4d837cefacc8e9d25cdecb3ac5dc95461c32b85312834cec7b82b328faa2aada750ecc4f5361a5637918828fe49eb1a8b226e93e4a4b9e493efdd13a38af287d05910ab33eaabb9406c364f263a4b661c91cf52cd050c97539a36b9e19de455c4b6d4f312f7ccef2d48ef0ac68e60f52e19b190004e72ea14e330a832f91e4ff4681ced2e764276b908679aae3d87c122815c44c9034710da02b2998d69e24fd91f3664596ff747e58700f7e6c7d2f9855213eb15b6870c65fc59417ed0bd8aefb623d9016dbac261aa5469ef43d30b409df5050c6da7c42591ad9c97b48b74a07c49ab0b8b6d764e5ef6118de133300c19fe6eaec61c6d09d4871b02147841662abc07d58d6c66f2fbeec25a2c9f44b6ce4772b1a86879fbde49c2e9d6ab9826c4ea3b34d16efd18fa142ea7460cad00674806e96931d65a167b7ebea8f84d5074b77635b0b172dd713472dc4a37731ea4128904d1d5ca502be41291a6c4d8e20277ae84ca129645554f6ed27b8a5c05aee223d88b56fe3dedb5ff2fdabc491fee47b4b64f78f305af2b978660a455081203e5e881965453f216e132a888ab907570eed8cff0bba9ad7f7c6d56b328e583a2653801710e65820356839c93bd61941abc185c78923b533ae136953ca8fa28f5da1111bf7fe369df53c8a474af2cf920f0c0a803e3760eb21dc4e622e9c1b6091d71660f0796e635462b92ec0d60eece2492304e25e858a7700d852e72fdcb66b8055390e99a4de032cbd8a61fa7d0bd6dcaab831a78de2a5826f797098bfe4fbc81c8e1b3f2d7df23ee3aa9189b2e01a440df4f7702167502613ec1af676169524f1c598d0d165c1b2cf2b2e51bcf35de3124890374a59f4d6f49bda3dd95527ac71bf888d4de1bd5f0d0fe10284a04c60cb1d340175d2f35c1d6ee7aa4c60c51f9890e8875832d427bd88160c1cb7ac7cadb430b35d214db1762725c019ae3c2dcefae7755b1255b7312908f1588c7a113023aa1ef1aba016d5d38846234b34dba70cd4f8b160ed06f646aebbdd9b023a72968af1fd3434f58548087a2aab807364fab57c3dc05fdbd1bfa9c0e65744947dcd2bf2f0889d7ca29669808026d7372982d5a529ba4f3a468e6df4cf2d135ce36576863aac2aa40b97073eb2263d906b95bf463f40af531bc4c149445866259dcf19a4a5c62ffc295c6ba53df79854dde8ff5792e6858503f4a5689708ccfd8124baf82f9ac6e757ba41fd608d9b905d97d2933f598ff9ab6b6825dc20d06fa7416efebaa5784eb76c3ce5cd7ea24b829f900b99133084bd6619f31065bdc7ad2494ebd2995d06849969ffaa2be83a1c6c734926d425d8d8b38da26b3cc16df57d69d6d537f3e6b6d0a1b63da9cd52638401b5d483b3936695bd4ff4ff1f69f9fec1314e78f0621c851ccef3cf264eb09707438019085edda7af522c53fa36f72ade720def6a3b9029e9f405abc1647211c1c62341382033ce8e8cdff2e29b281a864175a935bd8382349abf0c155d690ac725e1a4078b57ccb607d5a0ca06786de33f329bf7f86d94e5b2d10b41a6434a6ee469747188650e4e7d94817830e50c43347c94e8574e7e094467fcff208d09e90ae826495a29e9ae7c53a260fb2cad723bb77104d0285e0ae356846ca917e3564b87d08869c41eb2f8a3cec4a7df556d7073ea8af3e452706a63e1b36279d2beaa44c6819f041d0e1cff131be6c2c66f7e49fff10f569b6f336706440f9c00d06f56dc7028e6d50087a608bb584b24a56ad4bb1cb490909e3ad856a31653909fb96cbfe1e75504fd81bb0eb33de4fed710a7cb21d4c65643de6b36afa12bb8a2e75a72b4d6acf7c4e197f86e28f18c4467ee07ab33b5f14a6c23d448f1c200b771b42197eba52d76c612fd631917ba3e4bf56ef9094b163ab8ee855cd61090bc0703e1f18530a08d3901979c4c83c69f95b76517929fe8bcaa5b5b47e2c51e553e8d88386fb4356c4d69913a148f682ad63408ce2a62b4dff1982af2c3a5722328154566cd73aab091f03992563c929c7b12faa98da2c962877fab6dfe38290b599a9eaff84dca22d1ae1ed523adf5f76e7611c8bac4cb4ce56684b423ba2c0da3ef9506e97a824e077032b3554bb31994fa7bab0222c5d138c3169d4e9c2343f62a90e9e0bc17566c8a2718f62d225c9d844e27ed9389e932404b25a76e8225f161a3c3445c9fb1092d210850b2e08c4b2dbd118e263737543d9890611d54a40443c6ae51197b6a8056d00c572a415c0257ad25fee13c02f8fd9abd80af98dc2f29cb25057fb8f1bd204e8a44fc970ecae62da378b65c5a572489f612bbce3ae0449d97631536df7677f4ea569250f406adfea18acc88cc362c5369ce18ea1867feecc9cf77cde9e46cfbf43628a7df3fc4ae5fee9d851cf1f4387b15f2661dc39ecac1683852d32dd5182ae675c4d052fcf1c19cc5d269f80c2e701e8ccf420391d95427b03cd83d0a56543cabe0a97b291727e94c8fed7980d22856b774e93ebe51092a58fda64de123027831227f12410cf39f0f02f3b1bb94eef168f7e93fbbeeab9528d1cfa72fa1bed9ce514684b5b56a80a50df6820f5f9b1628cdfd26cee9f60d84e1d858b33f5da4a2a0d7ef66f0dc4a404c3f0c0183dfb5c3b870a6be86189c156e1e94ef4874b4d58f09969370bcdab39208632fda5df6fe64209e74d8e80703dd55caee6b0e5d12d1f181bd7ace87d583e6944043c3e605876aa593868346339c6f6538dda1d471aa8249d6fcc9c943f5b6529c0995daef3fdd1b8e5dd1706e1fe3cf6849fc4683ae1109a8266adfbfa619d3d6d26d32317a8afaa2eb59a76ce5ddc84098fba086699afb7e04e774c25bbe110c47614ed62166028ae7155460fcbf8971b8283ea7802b9a9a106ed348d9aebee777b536b7de834efef6331e158528ebfd1fc4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
