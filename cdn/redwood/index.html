<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d482bcf675f0ef2f8367d4616788986758aa29e2464708f0a4e49626037b3d4332686172e76dc9024496f21a4da35438b0aedee7f5497f4728e4d72a83d4cb570c83b5b98bcc943d42dab4851f25791467e9a99d981a8d0f6b71f30910fa4df4b626764bc53684f8424411af4456ead34a9024e1742b35e4c516ba6b93b4a3e445384851bc5f2ab389bb9e6ea1a66857e91cfa4e21b34806d25648e519ba3a8d93ab451eb37f0e83e711d5b9fa1d57891f10dd3de544ee21ae3d08105a4271d3803e5ec46c75b8533f928de1cde714d1284e4ea8d22e6dc0dd06388052e1f895117ef72bb13cd2a43a87c8c21e903e096baf7e00e5692336804e64506deddcfa6d2c1173bfbeffc615d22a3ff75bc84226ffdeb3502df1859d3b6699b1801615e18e71f0ec2e69d154811305f19c4fa973da78ad80c12ebc36cb1af29d98792c50d72af956c78b0c04e4d3b617895043c853b26ee11693af430908c0b6e427bccf371c531fd69bc3d76381420f4210796d8918df80384b646233e8130fae630753a165a543e4e5a490710881527ec909f61b55903141f832aadd2067eced99f0e97f3dd19a2188f3d2b596b4191e5bc866f64ab77b5f8081d6b3164d12f6e44ef0a065533c03ad69839ad00043dbc7ab5a00f04f50ee62c6f1b0aeb6792faee245be507df0fe013787ed5a678155071064d29342c203d05bdb76baa1f1a2e5acd88d73e7f5a36a5b84f034e2adad1152a1339f0f73d006337e93d6a7b2d7e35920ed22324c8f1cbfcd2157eaf319d369b436e912ae35ab885c1c12261d5d73683a2f65c8fa936c269391ebaf80660e7079fe78861cf14c5d89dc6900731e1f4013f39d5aee83140c1a706aef446f7ea116b48cbf0c20fb8989306c8ff417d3f7d727e315c2d3ea5ed4d3531aec95cad963efceaa72b583eb6f0280fe6673a9a567e3babac89b761afcde0b277a185d85888281b35966d5fb6f7988b90c0d6cb9e1b6da19731f85c45719b8d9f0e3ef15dc0bf9a03b9fadb73703cd9d380d1864d564e6d72ebf5ba1881678835bd6af082a0220aacf8abc11b47e3a42c28f999f77863bbd4110e95941d5dd07aa59e621961f1d94ad727f8be2b3d589c043205c4ae2a7a65064ced64676ba73d6ef2508b2ac331280feac40d66ac70e001b5043f1015de63526f798c05a2f480d8b23e60e25880d69a526b442f73da098094cb5ab84964212fbd273cd82320999dd8e7793a686a9e487a7c9e5d6aeeb88d292d7e2266fb75c649ebb9f5ca3a36572928dfc80ee8eaad67bbb897c5e737ed8295f6d243f6f77c7be2d0240ecff70b62f56d3619eeab8a71114f27afbe311bca695becc94a081fd3a2bd02c79a005559481ce0ceb07565a3980e06f134a18ad9ec7ca932116471ad988cf57f261b265cafa13bfc08c7b243fc8883c8902f70dcefdd015d5ccdcbb5efb22071b5fb8744a74f08b6869f38695fb4e56c7dfdf4a888690f9efd8b6d561bbb8fc137f9dc75e6e1f271aefd258c1a33ec28cb7024445dd607f908a3a26924e9961f6be6d6731a69dc267eb690af7f1fce4f709a49f426dbd094b8a691fa0a49cf687e1b3f4425a41a0d553ca2ff7705b733451f43e4e2a863a9b6778dc82c493ce297da0ee38196a311a6e9822f05603e6132757de8a28aff0693232dff6f60864776d0ffea1bfb658a3e6bf7c5fc39281f883079284b5a027b3714a53cce587a45bb706a4f77db42955224a7a42513b61d8d3dde0700cd46ceeff19df646888bac1cd09bb3f2fc9eb01f8ba3cf8e9a3c9fa1f0b8e2d77efd463b0adc6067f5fbda38490595242df8cfd7835fd53e1575bf6d065d7455f5be579bc84595d0fe423b36c90e8401504c2febbfa4670f57c1bb724fdefd8b3c6ddb023d8f63e66aa35263e7bde65629eb352fac204a181f690939ccedad1d631d82ac6ff28e5a455a8d00b0def048953ae35a27af5bc3f1106a3782cd447445139946f2c6efd69847fa0ef9493a4e28576475b605c4ad4dd232c1b17b5b8fd63a0edd70399f4ee935ceafabb49cde832e780aa22a58e8449f7b789763c342f9df4628010ac9300ddc882261a25e9da2b3cf9de08f29785b7d48bba48696e8993bcab12e254166f342ea640ce6c017b9e3b9c0df0c46d360806934fbaa7154a0c9a97348c7138ebc47c507a6f9bd3b9f7e05fb0a99dbdeb3b8ba4ace9444a68a33d69df26f720b798afdddf560231d28ed2adb4fccfb336f14891dfd5794e7be1cebb59d2b9159f1e58f745956b66752363362a11db5bdddb70e51e74d60cdd1dc8ed2319bc1aff85b561f46a80af99949c0cc5219c8be2af43092ba41cef50a4f802697fc824b1c160e07b5156e013988fe3d48616d1791badbc7b2ff2bada8ccb081a162306ce31b937c3b438bbfe7603b4dbe9c748cc113cc41e744f4be36ea13777dff005c12a8f79f6439d66077a495f00bf21e1e6356ee970c1027b46709e334a4bc3a2c38b12c6cecc59e5b4c24bdf4892d4813819e429d1a642f8478474dd279c252aa10b40fe2c51f1bc01b5f6d5a3ee1457e195cd51e7236a2c60ffa1378e8341e0776796d88fa7ce8c371ab13c1e4c86ee161b825040663afd28afd5a0022c9b7d920346a4a3fb2a6168cbbe7a6169d1e09ee80ecb5b4342cdbe3d9d5b74842c18cd09d892591b6fc6cb399b44488c9518748b7233cfbb1a12194d299753d3d83609d4b0e231a1b9ed8a9ae83f0fdee0424647b5287afced49698b94df3e66f3dda1b1508996e92ceee8b285b5f8ee8e90ab504130f6c039a24b47104b81b726b825158f1d05610d1a77a863afb30cd91c650052d1d05f1fb396e9822f935cb55d83a43124771caf2fce8c2d62fcea4fdc9f09422afb1a56525bcebf669384ae7961c1eb2a9ffbdfc47299e95f82a316a94b88a49dae7d4d95f61000e815ddc9b0dd0642dee0c332ab838869bd535bda2f8cef7cc10e9db4e3ad938d391c5c35f1afee95ebe13666ba8254381a2db3704f14c4552a60df6b80f7b87dbba93d77ae11577b92e419e6c7b7543893d9c4b6f9a5e3e09c94f047427df7899b6c08067405ac063d521870ad5e9ce93c3eb21254cedb5b98166f0bf00b88ad97bf722fc724d6f5aa21c7f401a2ae8efaeca539bd5d96d57bd37e431dc369c9b4f1026963f7a19d53c4896a8ffe5ab7276c317439b73f3f021f409b60f36bb8eacc9660b2f5c62529fe26b9891d95970b400b02c524650178af966109d8cda2381a48580ad0f8753421ba87f34f2447628970cf497dbedc7f6720753fad6ab6085fb0dbdfa428fc0d088e5e2636e7bbc37f03328744b4c0bede175ee0929058159afcf2bedbf7f34a17093cd93aff157ef1dfe546010675d6b0e5d9bc322e93dfe4379b5c30c1f9911eaab6f6b2dee74a3c8995fefe9cfefa25ed817e150215e061a0a0c33de186f134f70f5913fcd984e01d99cc3a47de72c73b3ef3af0d69c5ad6ca71a56a31b95355c4f14aa326d3bdf2e47bef1d33ac37341e1ed16032fa7a8f74f40d7901db42f68c22f3cfca5012748673330403daf054e7cef8ef14e85c6bfffb8806985fd0f031ec2dce1d86e900eb2a4854dd295e7bbb96c28325a9025cf5d31575dcf20ad859f00c7e550fb7d82a1c23074fc03c466f571ae08635134f07b24540b2390a51d375bae62d39e991e17bbb2f5f61c5da75fb346d24c61bffdc40ebe5b14b3ab13e451d781bd10225e8e747c2869306a9ff7930862401ef71f385d1aea4ec5b37a380b2ba708b56afa5566a6605bfe95477e2044257b517f5b8fdbaf4bd18b64f863e6cc5291f90af73e80781a45211c3fbf0d673bca056910453a63c7fc017307bf990438415778f11e871d71db22993f14d0f2ceaee4677ac17dae4af9909aa7b4b15a3809d2e048580c87b96fc36bb44140545413cadbdc828c72c5320bcdc38579f369dcc2837bb3f8c0e3ffe9e167c33913baafe93cab1e43b0f11cfb1f36cabda828bcc343ee4a8826f5523286958dc5854307b7047cd99675024da9bf2fe922c31d0eb0eac79eb1865ae0ba4d40fdbd0ba3205992af077688756725fbfa960e6873e1c5676085823e175349a55c31bb2277d5ff9d63d4a1ac753696026d92093550e4c416b7a1c8cc63fe4efa4feae0468698cef7de13fe6cb9540c6193fbe914f9f316b0fddd80aa0360793f0c9aaa637e9edbbbb33c4a261c0af94eba3b07549ffd0d80ae81ecb1921e797024f1c4c0091acb6573261d6cf012dfb5ab900c15f239c6c78089bb1ed9deb68b6b43e30bf865e5ea1ebabcd2f3d1e56431b4a7db5da2c7f934494d6de6565b02c8c908d737ca336681dc7aa11a497265bca0aa7eb81a5ec81edebf879be7db3728587165887759c6ec83a85e2f2f93c3d12d1fec8a7aaeca5f7583ba1efb1925d44d1ccc5b23f3ae234430ee7bee64521a571d76906171bc46bd190b1b8a3a297f11c77bd516f08bfee235b416c2c0e3318aa7cf00a1a5f92d7eefc3841c80709701e581b5cba183ace12b5c86ce7583a923558ee82902879533dc71c658231aadcbb7f3dd791e6a5ef0987e1e8e93607e2a8c2804918ee54d59c865d6c8912363884d443cd3caeefa565f9339d077345136c5d36141c1602774f5ee40487575b5a36a7ed8e89b67f164d0f7de083356aecc38a74abe469d504baac649a4dcae33891429f0b44cc3a947459238c8f5fb033a71c2fdac4100fe07ba7fd920bca2265aa2df1e3ef2e1e09b85c3d47e9b91e8aee5706c6a352351717c6321b71d3fa3084b7d9145537f749e590c56e41cf91c5a70c9a0c6bb7e3309a22f1f58c565f6798545a5696deac231f1a7a89df4224bd2ce02b731cb03268c08aa2148ff05693db3a9d73312e3db240988f6de01a90c56592ea44bac3eb17f9074339a0bbb07403f5fe42e56b8db69ee1d55e0e1c3f98783f582af64cf362e23984bc4ae1ce0527c0916be9b7fab3deb1e34200d7fd5c6641fa842463af015e9969379fee63fb1079cbfe2637a0259305f5ce08bd118b0f5de628288d2c95151cc18b08eee6109a2a4dae654c95d49c12841dcd6a005dad81668e469d49cd8a9c93c0b5b7d0516e12f8d7350ee1e26bd5d671fb1465101be94a836a545fa10c10c3f6a6ce03b7b0ed5a429372d288b418e23754fc9cf8cbc4c853c2e80a280c66509b2d6d68473e62c728f822a963f9722303d38c5c0d886dbf1fc1eecd69924a06659145f8865cffa2d089dcfc375d779b81325af75a7d666fe4cc90cd2ff4fdb18276296fbf3c209414aec5f2947932c4fd2dcf542c5e94b7138be9ee4db3457d9f87ab38ef081564850be3b8c84b6c2cfcffd5390a52de56fc5cbb7e6847b2112af1c1c1307f42885cd0de77e5d5ecabbc18152638f93d0d214dba00676b39e37f556fce261bdf8bca2ed91971900f62fb20dd0dc0b14f2fadb07e08f9b97b5cd1aba9ddcacc8d8e2b3ba2b3ad18055d4c525cc77e424be911e1088caba47c6313263a0a197eb5f466200d2e81b0b55d366f020f838dd721301afa40c5501d646917822c91fa5602e28fb6dfdf2af8b4a2e06758f18648deda06a92d2e22be11bedf818b9ac1b163854425742750f2a7b88c8313a1da3139e379ed32073bd9e42b31b62d5d0dd1763dc8be6243ea126f0a8d04af9e8428d0258d24518f097acff58b9f6551369dea7173030f2892a767da00a7f5d1286a3d6ecf8bab712370c109ac3f1fd6d3b01d91219fe1c44ba71204c083bb9f4f0cad8585a455ffd119550e2794652fc954f4e11285129d484e0c850372efeb2d6d1e957601d22214aafd5682169a37de8ad1fa7fd5fec95cb349e07ac6030ee52fb9af21dae5e7d0a982414a7baab9e7ada487eb90bba87a702486f6958862dbfa379fa88d9253add4777b42611f393ae9d00d570450879b2717096fae14da56e865bb5796c4ac6fd7eb5eac85c9f15aa6394208e8a8ad5b0df787c7d9a44fceef9f6d14e2a8d14a37da6b40c63eb4cebf0e1952118a439b509a82a82df5d8feb6e86a7788dd6504c49fb4b5b3eae31f983b1a0560172e7d039629cae961d8b41066fe024cc11c7b73c056aec9387043a74ca0b145b3c29e439f881ec6af565a6db0c629d0e55031607f8a71f512def5fe8c030068795cc5add87df160bcf4b54803f358c244312a9e24416b2de24f2bc1dfcf90684fe3818635c18de0e37acc3a04f660b88dbf51743d4c2f140f19148bc281a9dc43cf9b1f994646b5a897b877f211a05f53e8ce40e9221d128dc4551b64969ffbd3cba2e1641734f83b4143ad98441233d60e5fb72869253ef8be8bf4870131cf5afd9f3a7962f752427d36fab1835cfca3cbf9c0eea4b0195b47d482d8186a5ad3c908eb9beba248021e742c8c0013df464b413414fd288e9a1cec4cb27b8924e063c8c92b42331c1bcc8a30d9249ce5bc84a77bb26de3824ec148933612886e0ff9d61e0d5d6c436d3e5968e7e93f19f82b7a4fc648651b9e815aadc1add06b9ef9cc99cd1d4153f988830bd50f7bed67f6f803035149a3e398de7014c20a4883e07647baa28ade029df5009fbe057e36c84dc34763da0f3ca3de464cbe71ae390dc5a27b2c55b8ba21942ec0b09ae63c7bcaeb50b87b86c9f0a7cc73c2229881d3ee0f9779c20b71948b6b2afca07063aafcac8c31d0558b9cd2b028f0c6b12c696544d6189c43f2cd578e459545e0b93752b24932adec2538793595fc78399cc501b92384737e47c4049fb11867b5da5e8c8d3d46c2fb4a7096236509fafcc872d97d35fefb3fe13b4f38e79a0a9e9691cc6f07cefd3d8e8ce9e8b099fad6ecac97b66b5ef394ecf3d418d03dc350b8ce8dd1df6f532c10f6adb0c3d6ca3a9d4ebcc8485ba35d15fe133143406633b889842974b476fc6bdfb3bcd6f8c0e3f7bd49f3a22063c2b2818eddea90929f1d3c67b7b3209b87728370babff0ae8bd5e1feccdc2ae4b6747fcbb32277bdf4f875025de1619ea87d7cc3c7f6a2f5b8757e30bf1274bbfb96ff66b5f477bbe5d8022587a68466e241d66b467bada720c82d0d07235263fef786051e33675611d0043cf35b1e0c80ea7b30045737d1389b21d203adf2a08f3dfc5f90857d172f05ffeefd276cee96452e2387568ad7a5af73e64eafec34c199a6ca3a1c10121044ccd0be909af73c3f81fadd6572f15f696255ad67f21a3012292325634c50b2aa8318d1d1084f3016fbb988ea18dc5a5fe9de13cd0c067993fc829e189daf96d9b7a8aea6e8acb431deec933d2cf082fbd728011cc242de00238232147678e1163ec1149f7378d6e31dc15fa44bdb1fe46a2e61914e177eb185500550cbf66955c3328f9b1cf4e7614e36fec6d7e89d7e0a70ae52c1c6e04410821617e8bb149e45b26704c7938ff54ecf519f4e9aee7ffc5310f596bf436ba631e8be79187197078437190c45c76434e01178711f1ad1a640aeddd53ddb3d8d2ed136be70ca8ecacfeb83f48843134aeaa071deda3da657ed221e6a93eae0f9e5aae071feb5ae895f5240a7f55da5362b07052a5186cb22c42ba1fadf63e45303858e2509a3972e4268fff2d092a85d7b0071a89294b16f711c78caf0ca594d7892ff1730a6e855a5d11832b2cb9988d9056a4084b0466261a557e42b75b5a5f2b8c554512e42bcfc4baa835172fbb2e2d7793a8e12e3b40a321d9e6db530877f9077ce9c7febebad12c26ca409ffd4903ef78ed44e0f21c4eef3bca65b299291794408d6d115e075cdeb7dbe242485206b619fe7d6d922fe5e29cc0b3f1128df8f3823487a0d58b27dd33b4f14d606f22c72a51702463acff8f82accedf0ed23af53a887af307270fb4b232c5f4370acf802f620d546f6bc63b83c6533f9b28328efc6f06c38890df7f16c27971eb0c8a6b3e932bbc24f999a1715482b4c7202d3b744ce702590c596ff0f2add33fe3e2271cfd4edca6c06e55a0d61c3a31fd724dbfc28b0f4d3008944a065f9d1cee49fa08bfe1753b1b5fe8f5901aefe6a1e57e09b17765e0a998f5c6e9ceaba26db57fa3988c814f28c538350b73551e3378bfb997ed27e45faf9a2ad027afe06e3867d0620b752bf5297ad389c00ef020ade22a1cd1e1abb215b1beea2f894d306cf47e938cc6543bee08a72d97b05c3cdb31805e702a8c98be0a432119888e9f6271f26f17668f62cbe9502acb01c8345ee4ae213fffba2db51cbc44dbbcaa1eb9febf18de0680262d67759121eab92c6fcc17615cbfd0c00742cc8dfc1cb67e0a34ac716032c194b72bf44926775b0ac1e240ca226060d94421cdc442d49863c6c32da2b349b0f7fb9502d385ad7c13bf4c393f3cca0281cc295ae2ebc42eb86ae73ada5f70760ef28b23e4e16b9693b0d3591919ced1248014abcc3079f03f2d5d9c591260b6a33b90fba7f88b1220acd3203f3a2e0515eef644190f9f87214b2937cf5cd3988dd975b013cf37ba7a147caf963bcd57918758e82013ec9730736e12eb7931a2db2747fae25486dfa581e1ccf59856300ff77c5cb3af4d1cf9660dfd687d25fea9920af8060fa03ddf61d0507115ffb831de735baa914a0baf87d865ba34d5ce08e8d55ea16f8dae696c78c34bc0486f615408abb78218bd1311ef404d64e8725580ee66923c9b910dcf3224928d4ac5a2b5d8c7e904b6ec3ebb7cb654ceafd3715dab921cd5ff04ff8abc6e0adf10fee19c77a7779938c8693a9379c6283877d34bc65f4b14263aebd149628d5970767064ae96cf227b61722694a582f6dfe9893583e8d7d896261439099cc25a14cbc1fb276f706c213019f73801b71117721b7a3b5df2e6837395da8cd5db19d6935d1db967821448e6b15ee1fd89785726474669d36ee300ea060800c2b5e1926514ec506d4911adb40df4cf6b1b2b40b7620cd7a06675b8ff80f1a1f6b13825a49645347e8b54d521153f279517ad458b1645100a8f51f05e1d005e7d5847390419008703917945123b19612bd079bb9bed782b8b7c82ae252daf90840c6bdefb6228615daf5ee39dd2bace7990048852911617049c5203ce5524c88b3961cd8f58f8c6d45ad96b044f922d4d4374376c9751fb63f48d13c0b5c7fbb34ba3b4f75b9b670bae42f8a697328afa042596968bbaf6c876f9528556b68fcb09be53c4dfdbf5501272988bd92758705fcf4772da566e9e0aee5c1f158d5c0f04f5474023ebc77892ef328841ebc5b0ba31db6a71b8274933498831f67aec7c174d79e2481fc613603eacf03637b3b6f5bfd02f3a9a507978c6fb110fc6c7e24a77314407c420294360f6ffda0a6a79fb5a0f56e53acead4870550d0a669a47ec220e7cd96116608777e0a07d207dbe18ee62ebe3183f32f23f19cc1272755be561e2f74202926566120a4aaf5f3fd8e317211ac90f243be2ea5d3931f59a9f68bb879466dbff3c6f00399c46df725d680d46e0ec43815dbe4d721eb5885cdbca0c01dab347b22a446d38fb3b371944cf2f3b07acee8ac767ad9413c518a87cae1df9671cbfc5389a4baec4f0f4e46a943330ee4ad9b5e6f51067140266cb317e141e23351aac7a29171f3c11d801c418908817a09ba8089b52db2e0354c88ae16ce70b6752a572b74ea497c747c0d81d21bcd404471ce120abc5551e449bbbc0daae393ffd02c8c47e97795af5c3bf03a3bf6647bc305cb21369958ab412ab1059b4094fbe51a0fd08319a2804224e04fbdce2256bddbe3835a9028f93b985859914acb5d2769386b8b0b3cbef3106045c2abcca3de8eb908cf6816e35fca9203044b55c08227f989446bf0891fb8ac309a61ce07bcb7ddb9d9e749cc20127678aa023d90050ee809bd159ba208159fc61276be0b977bfcf749db2400abe6d0b8aae8b4ccdf4f89bf16644e902435e7ad369866fa146f7e3a2475ed310a7728351b4ed2f4c4ef9f71bf608c5219d2a82611f5b469d0c20238ae6241a45b862dad91e582bf8c408fd6a28da3396d3d9000ba6de7fcfb3105eb5102423a9fa051c396b89b7b32b7969d0fd2f618b6c5b79d2e82dc8ada1bf1dc61cd54d8c5ef64a79608cd02a7d36178eb640468d5c9a9b36bb199261b6afdd5939b300e65dfa8a0d997ae2b99ab643b99936edfe628d495cd266934c6c6a800e3249343778ba60d0ef80439a254d265621ba307e76dcc7caf3e2d06dad70b9b1da08d31d4b3e8ad0c10e91d5cd0c746ff89f471591b64c04195838c6983625c54ef5571586b02dd674e9d882ac21acc82db0f40eea726d57a2a17fca486ff935e110ffc0f54cd9ef3e8c5874d75dbc74225d356fe4867c9f682f66f2eae4db9873444c6b622b8b89ccdce9c2e654905a289c241c02310ed2678dab65bb589326fb65bbe4142a7fb968a8594509399884ec6c6c628ed3621e87a12858c2fbd7988b91ceaecc189945e579f1a90eb1098b74b0906f6d4af60da2e23730025771a9a9a72536b94d2e2d4c40713a14c2803578c9229eb04404b6074a01148a1f3500ed68d80f5157f49bc234139f0c60df42aa1e38bdd7e6e633ee6decf98ca6506338a29e4d680c6d09afbcd23241c35d9dbbc8ce6a8336f55664840b51f7975dde849eb9b3948526a435888ae5449f29ac1cbc683229931557184fc80902fcb1ac528989f0d42fb882003fbb274972b193354007bdfcbd7e24456ca36c90fcfa0ba6e87df5bc3fa1a83d7b36ec8bc23176f8a35551620cf48d610f0d107ad12bbbe0f299d2f458463170b4811b3e76d00f822b13dfbe1be4ada8476465a1f42145c4ba99e5357886c9078996e9bf6ec967e04e1bea2a09bd9265e324c45174fce77d0d2d8a8166641171b873222103a9e9a8cbb0e3a039cd2f2286f040158e7b4c79bd20330c2deb79ad520753dc5604067873489bbd7436b2111a332e6897f5cf658fd864998da6ac5bb026487ec2f81b4ea797148adbdb2a8196a03b502b08c5b5f6c3b184b3e2818d6510b266d3f7f2d0293f1fbf889835d9765d265c652cf72fa3af32a47cb1b499c98cddbaa548c2c63a4e3cda007983b63e804b4d0af4fc201ffec73af5bbb21f8355cb23e22452ed6eda7918e419bc8afd9de4b94f9b6254fe5c8a577c1f87cf7a39e078531df91eac4653a57361901465feb57b804851e5865909fae5dc1389c151c6cf06dd5e55aa7d662ba287039dd2fd9a63007c0319bd0c7ba6f40cfaf21dc9b93096f2bfed2bb4ee2f14ed24a912227bdf19af5ff7d8def691935370e47f2df2440ccf0cb7bea7bd73d85f1673084d8fe8eab4aac98fcbeaaad136bad154d187788892eb2f45fcdff18cca446a2b21a729678164198834f3a45f70447c54dd9ef8bc6da61086031313c6b536e2d884f9ed5cc2fffdb26d159ca18607d34b3656ef27342df378a0134b0fbf1a306aa3c1b45bcc2a8f4302e831a9cdfe9c63206aecb52a17a3daeab5096d064ec0592766eff6f785afd87b585a937d50bfcb9cb7515608431743af892e83de003c4e163b7913e0ed590d565c70d4ecf58253c987d168d0ccfa68acfbe7de395e50dd2c77bb69606dc1c3422fdaf3c9a4ed13cc6e5578bc76048ab86b95042b69449b12ee56dea24a63e453581a2a1722dd4ad1e07ef0b2a5488c6f1ee0e9213fbaf574f20db430f95c72d253334bad43fb15fa8d490d42f93cb630f62357b6739373dd3742f548a7f577af6467faefcf5b103809c982860a78abf7690efd7391dd324d874bf435f48523a6bc57fa4563955f98d9591b1ed3c13075ad128cb70c3ea20f05ce183de1f4a3c6608cd6a489e143c8d9cd48cef563de3af737a90b5d7bc1081b26cfdf5d84557bed860b56be6a1a568e2288ef80612da7ffecf944bedcabb57809076ce4231a91553f89e5b1361e17ed686eeebf9d8bb19ee3c13a39914da0953e6cf1251e4d4959e986c79ace93b0e5ba6269620cb44c09949053a7137ce65a7b194baa72ac2e85a8a000a3fb3712869fa32064b7d188cf76b857c9ac4f29947b1ff1e9a06bf00782d64b39c77588a66f185693bc28e89d41ceaace2a6515445da6e1375a12a048f15c864965077ffeb5ca4fef057e10fc60ba7617f97dcc8c090e74779a30351446994500431df61adf9b7feb7e36cbe9ba571468d6d4dd11c870e3fd5cd42209cedaedc2d53398571681087a1beaf9abf65d58d3d9ca84a25976318848bb1970aa6dc9e2cfe8962d9062d66acd088fe5d0d4b93ea0f8b720c224ca3cda44d0a66406f394a43b51526a8f15e107715e6785e28d2a36a60b440053317339b5d6f92008410fd3225e964131f9842447cb0368ca94d6600b84f53bca42272ae9161d6aa33f107dfb4204da16eac9c2fd7bc409f64818762e4e023841ac2b00ac390397f8178d21217aeb0b98d615603a7be77f5fee426b57940ebf6b97ccf3753ed38149f85208aa493dbafe3e514a7bb740571ca7880df4deadbc2762ebc7153e499e860bf4296f49a5f4c1f3f088c7efe785ee14e559006dd1b4c56758f755a81d8572dbfb7523da96a9a93a5eca2a437b4ac752aa76d324c3da64a1d6fed2b84e1914472c1a4e088942bd8f7fe0ded335bb6dc78b42975a218c4611c2c3b4cb98696a62b72275b0072e0bf861acd672b36c0576126a65f1226001fd52e3ff23d18dc08d996f657cf3df2463862bae9c4746b77dfccadb96f9689c1f833889c8298327aa78cbd6993637281a08f82987fd5a1b0211a846ca96edce54a2b4a17aec6cd1a7d754f5dbb508dd6652500b3e58474991d8dc2ee1f5e01ebf02b06022543df2765d5fca3997ea9e08aed6b3b307e92e1884bc7b98c3a5b79dab8c64ea7570b4ff92f4488cc1f9e4383d39502eb9e9bbecb0780e049cabbf36965d925fe5ee1c740fb3e723fbd9558d530a08e4c37053bcaa65a826f6c74834cde4118410a2998d528ba75b58dc7d4c073039ac05bf9b74817d44cbb562f5523adc586bc14481ee8d9b61b912af79c41630cbb264ca86b31b7987f4562abc545b432404ebdf00b808e9dc7ea4cf8c18c2873a74dd13f7ff3dfe54263f9430d391e831c68ab2c027f1f74fe334c50e1e4d10d5867fc6da3f870225caa8017d02bc68fd5d001566a988404ba31d00a9b66287f4e0e688c7cf5e028c796db941d08ffea3ae3e506ba90658da89c8ca93f78ddd2e4eb4fcbdb5dd1a53c65b1af518f73d92a6ba2c0cf2c22bea52e5b7d4df4adf6bc3d98980b56f99e060fe8274b7257aa8ac106c8c398354d3b4eb1bbb49a7fe5b513bb6419a5cbd3d010e3cc5234d3b0557f6da4c13fb09e69a5c9f5b5758af510ba8e9d97e2b4d46dcd392ce2961bebb82f6c93f18948668b7fb97516804df1e735310f5e4715663ea8f800a9137e8d3b01a8aa4a9031ea522e09c621c97f679b79cf62c0afeee9177cc567c1056139b9d488cd4005018535641fbff879063344cf34db173198fb910b66da8cb1dbe4f1422567bb976f4eb18feea3d907558254bd86e818917503fda39278ff543652998f1e0aeca12b7f5dd8c767cd7f3fb7c25b3739de6b392ce1082a02cd42c5e296bb9daf02b6d4ec5cd2f679787fe5305f298dfe071e64429368daee22b6dd9144a291fa959d30414cb255a74e206208cfda16e48f354ee5635d0df7d21004333cbef395a625c7aad3df4f21edb4f493f9404b28990c0c77e1f5c48f1595204c673c1c31a59ed231a67f25027e5525249c03a38d1896884694c3486213d21af97ef7814f4bc059a1b058085ed65e9d80847d1bd80c8632d1c8746e0ec8bd5e9b4ce12e53c006c6fb183f7974e9a0998271023da345b8ccd94d5ec1d0d5527a8a8062945a35e692ab4fdf02b368de73afd0ed461042d142ba916d0148b05633199e1017b08811ec3e29f6096efd94ba79e249e821802f86d6235773037415b48bf6ad611966d8a6f7f6eac06e497247869d66ad2ab45935ab83c023e03d46d73e804f0903787860f54a55edf3f804d031bc5d25e35c661877ca5055d07c1b390fa2ddee8e77994f28c953a46088a97a1591bbdf894485d12fc35c08b9fd512a69fb5f9e8f98ea052c1afef837f813f80bd512c3c35a8dffcd5b1ae0cb607baee2d03392871a66217b362e6ca071a82afa133017f1db9d5419b19a60c9d2416664fcb67011107d0ccf5eee29cc22725719df6d5efe0d947bbfd2966b677df69b421d7829363e265bfbb5f83b85730957f35c5b24faad896cc1e7150b8da2c7313762d5a0f27921df32cefb03e4e7e5aeed9b60552c081a82bbe37d21862c8d18c9327abce7abf8b8c457fdc1fd626d3d8286d1249c80d2947874889ea674478362f0a4829035019390e8801e589def11f595fc47c093eca7341597406cdb9132dd35f3952a8f659f400dea38d9e8d7584ee6f692b0c16aa3bb5d96004206a5af8eff2dfda8e18fe5e93c765ea5605c6b2fb8dd26e527ba48e0c6e2d7dc539367b41159e5849d1b3c45528a440c5ba1a72d723ba9cfe48bcdd1a59158c07a6fa7dc1f766ae467ca77fd1617e125147dd538126854da5d4b80cdf1776d46992127c8adac3f55df59363390e723f760866a08e6c834f157fa8db09d24c293282406584241cdba72a08b848f5d60f3ac00b291f0a1f8e98753aadb8b9df34b29bb51522f90645cd3c3fd46d77be6ef64fc9adda951e1f39f262f4687097e1472cf49c9a4341002836821e11377df378c80663a8517b5f5b50755ca317dd3c995e9d049f0c971d20fc4947d689f3974fb3234cc6ee875775ea21ea498345efa8fd9397eec5a4d9a4e2a8276ff9a9875c43e8e2d857040f1ef2f18c0bec89368a4b769164109e7f9eb3af7cd7fbf2d78c7984381349b90f9a107df9494ca858f9815c1cd8eb0e4ec9257ce28c6e6b6214a991db4f5e3bd862d2104aee45f981d5dd53cae5e0ee8a5f1f7f34cc00afd7f505ec32b96c853a83e19dc42d3ebfdbab1db90421612ca9381f0ecc9856d39581c92e3647c602993a15e6e996a1655b3ead900b49b2e8df83301a24bdb7d77b6e3de1fbd608ef3d9053fce1eeb98adc08b9fc46e635fbbc634c13d89b786d448c95fe2b8acab665f6ddc8099c0c3a75f8f8e5778e3ec420d389c1db362d5ecb82b164c7f7467d21e4cd1056fc3cc45241229733a9711a2587eaac1ece0218322a83702f9ac11a30d2601648323caa05a88d87c8764b304dc9f5ebbe0e7fa0f8fa9d999a713b856aa16d629e03c0a42776295a16b92f9a8325c66f9492e2fe09e2863f1a1e3afccd4dd53f96bc5b06dd912184033ae3203b17a7c15d15307993fcc620c4ef8c87323b36f9f0d32dd1cdba33358169e02866cee757f53c415ed801ca549c8b521f4c2a38fb0b08ab29573bd83193a0352d448a13f28206409be42fbdc389351570b9bc2520c4de8569af8fc486b3a0596c0820249d32bd106e4beb211e11a694d77bb5d61f2653f321fda242bf4d6fd5016f0199ee51d8613a76d6ebe15c740b4b9f5db5830f276d6c7be3dd6fdb1338fc1d654e5e390370cc3440569837046dcdcd7964b0e2cd3f1e77b9c13a7ffb67f25ba2515e9f64b01be05810f41edf38bddb9c5181d03e717eaa34f5d95abe6b4762443f9275970c2127952a85596ca824f750912684f9685ba833f4fe4f148e13a8f87b2ef6611361377e389f8305524433eb9adce84a37bbaf25e4ef55657fad88de897c7d0d97ecaea8aa1656858a3b52599480a72935da6e7488f56c469da46510e540bf9263f6ecef42a640670ed0e3bf2310c749c2e770a6e9aeb964f239bbef5a07b444658c5934b73cf196bbdf1a4aea6d71aefc231e893730b221bdde7b62cba0e1cc65246eef5f374e72eacd440e91a9a874e732252b30fba1a18b42240748ed91877c6c681212278672ccfec006120b9801cfe027f34589381facf5eb8b8df79596485b92896e8d4c7a2db918696273e16306be0f7b05b938b2e1c8eddd39d989885963f1b4854f9b2e8355921b1e2db3e27a050b977f57df5c8ba7db222c87859e7970dca93304ec658a106b8166e82d14f2dba058df733cb43456367530228001d346002c402b02a7044cedffd9ebfc7654b437939e65b7f3dc76734e273c89ad02ab8ae3a3d06e1fc83397a23d0fe3938e298b55520ec4976278e36e8700a10d2df7b5285b60f34b1964ec8380e5b3e0ab618e0aa26734c0846c299b10781dff9657f5230f087a4caeae07cb094a85321a1855c0440c66b63615aa105e7b4c0990d892d1dc7d2cdf7a8cbb8772ea5a7353e18fb55b646b0daafe0991bc05275d46570380b1ed0400e361e8cc1b0123abfe2eaefac908ebd7bccec707bd8158a84c71fba2baa16a383551eecc6fc79614a7311f8aaebfcc5edb0e2e3de7c4aae4c3fd05e37e07b8fb7a392002655e97500bb02600cb9bbf823324eff44a887f67f007fba22b4c2534743d784012d92a45ee20c3af2218902782a0bc3285fcb3afabbf82eb3021c662e6cfd9c756b0a4ffadb50fab29a3c67efb8242cfc10fd317b771986e8e458a9f322d1ff09043d347055c3e81aff501be4a4e1fe25e536a29cfa542595386ddd5ee7d084ae95782204c14090911b7e7ad75ea47a62a4309482f0207215d7cb9999bf3109ccf4c2403906307e472f6fea4aaf75827bd9d2faac0fb67ee12712a64f66956e0a8b8ac0560d1dc5e169fc20ad10321c7547a44fd9f2f88b5e68209a6974fb76a09a3b56052d1f63abc1e61bce64c8d41f86ac1f6f4cc85ed027727aa5cce6ec8207ba177975e6814baac7b00821833cad64b5ea86b4e0c22a8068d02be53c05d303072e33cf53f47a75ec598a37f4b2f05f0c50fb47a53a1861f9a56c1f93d3ac59d14c1da2c6649ed143f4aa765ed5255a9eb7535322bf44307eaa1988710a734a3795384e771eb776255774a6b66e96686006249540ac65565d7dc0e85154a6b45c83e5c8e3e0bcf69ed2fbcd36348d1227a8ba6fa65912b5c795d9ff6eb32646ed7c0c62180cfd5bcc88a6005d85c85e948fb0a705e214410483f063fd5bb7b0bd8032a3a450a8d9139757725c785bc36a38ee16df0512121a792ec59ae390855c910c8382ac4c8a16c1834b1af36eedf0cccb043b5ecaea90c6ba8ca6236bf58ce3d4a1e8d6a1467954e7e626733ea5a34cc182fc178d7a214f63a499fff65ec7023b2c5d61cc26ad42d4fee58e74c041d4908574a872bd479ee879ceb60bca367389b63b894ab7a9e4397c11b33f4f005bc4fc998ab92fff6bc5357e488929c283f631a53b92a224632098444c18c489c5d62b5c9e12b95bcb11bdbdeadd8973a5d881eab0df3db501abefec91d0f6ad9f95c2fff2ea5f8c619f869327f463c358ab35cb8f9b2cab985b9455247181a02cf4752d9ae72a48ace160feed69990f46ab5cacb6a5b3c89e66076a973512555435a3eeda96be4ba30c4716bbe945f0a631eb0ccc20857a08796f41598b43d642d6f7454d0f4d9cbde9e8cb05cac35685ef2c7132b8e2c58dd83440e383a5f38d8f1502ca56db0867c2c55aafbf24fbd425ffe685dc86995bae22e3d2afaae39e78bdb17b4a0d7ce2154699dd2c7be927e597bf3b05fcdb77ece2787d6619ab73e18c232f86778f02337dca5a1d16d8324d5cce7e2c79189c1d669b52016c5430a136e96fecde1905becff7e76079b7b9dfaccb95dc4ef1daa63dc01b5e377eb290606c646826045e3269a8a691de232c2eae0e6ef9962192c8dab87e22e88dd2a224bd6063803dd00d35a8429b1945319984f4ecf2d9432fa5faca388e2929ce4e9e620e3e0896164a3ace3601292f55f14e6bab705f9b7804c8a9908350556290cc1dfc47fa7f2baa48fddd821720f98bbf51e924476d62eb17cd622ef7ff79921962831c7f7b8538c7111d0579003aeb07912379fecb1bd8dca7dfa9afe80bfdf3c167141a217d4f6b3a0757735a2c3802ce7efae257708d39c7608238b2cd690dc1b42efd8acdf18cd722db7ce45484eb2d0940c02135433407202bc783f82daaf2ace6d72a5f462a5b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
