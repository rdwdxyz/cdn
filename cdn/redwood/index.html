<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01063a74ea48ab88e3b01abd3172767b678f6982d12f4c8cd390feb3264206864dce162dc8df842ac7abb47e52df4b9cc114fb5964572e404e31a5278e3494e0b269c989c27dd8a8546179b4bdf0a462f9f462efd76c6e23039dc1fd39af2d821368d183c8e63b522153b5e89d155d94ed3611ea7aa41b395d780b175cbcc35f582a62d45b59e17162bbb1859f2abddd7a4be4730997d2baffaee3f3dd7ae81dc647a9d3d0c2c9d1d880dbddcdef13e33de222296cf537bff41bbfb64da1342e7b87f4a681acc1e3dddefa1acd8f60c4bdaa63f3430a213981be536008b963f35879b294cee2601e7ce594bf3e784c094ac8f0363764d71c6a8726dcbcc3b931c79f81abc9a38f4cea864167e82e28543642d28e05917be5c2d6f49ebde6a685b827ad770b36e4e522012dbf9afaa4a9a18ec7490c26025bf7b17d1ad68c57fc6e982fa53cf7aa648d1a4a654e5e357a9d0dcac9f5f39f03f88500b16b973545fac79aebae731d4b727ac099e1b4b2a8a3a66ded5c6556fefcb8bc392bf46ebfcf928dabc8c9f46107a9653a8045a637e781b4e9ea939a409cf4834a0bb880a892b50b59f7fee2e2043428b978d8d9e3bb5c736dea977f8cfb8f1e3c4dd99d4be1636e681be8077d2254a8fe484ca367f891786a10da586504795f75000815b9b9d3ceccd8fcf00df9898c0d6a82f246767c3ce751ae30e881e0d8a71913aa17488a0be524a1ae153e79b66e5a38c9a40e308d763d8f041c1214c0b9fbad0de2c51427a65db638af250250ca888ad7e326ea0c52c0935075a33adde465586918c09b88595ef1c4a651f2d6c2b81d09fc199180208e04e97df408992995866c3a0d96d4e7939268b022662a93ca57658451a33cded059cc8d66f13e0546d286b4153ece4eda667dcc65e3ef6c16db1c8f40ccdeb39213a6ba43c3d85cf3206d4383a23a456ea648e1166e13d9acf981a95100a05943078a60b3be6b78204610575a9d9ede071800309e7b1d2f21a5dae54caa0c037c9546d49b639f52f75f9489daba95b2a6c1fec0fa746ff5acace9352996d80aa2e20d43ecd94c60b576ec15c14623d1e7dde1c84b1904ce3843a7d1309d21bb2966599fff6056de18d57d47b354911f8ec4b2b7a264f15867f8234342dd253f918226d14432529c6eb79975f1f1ec5ec9d8c21e657e8b4cd048c205320e3029397d192e2fa07ea0350e6a697d245d7766ea9b0d2d7a37395df1b1a4b655806db597b071b87877a09795aa9ec240d8eaf5367e14ff4613b54ea5be77697668a6f1e42f9403bb05c1744a5cd41b0b7b4c4eb17b39eb97c5b061dd49c13f15856d8be331848ec6101778f3a957cc048dccc6a81d15f8c160dd479e6eb61ba1b250d9a2ab17f0d4ada821426e2e9a022db94822a386563e993da4e32e2049798308c9e862ed563433f01ef758f45c7d99a54aaba671f5164949b66667b1078ea619a6ed22d093f54a12445130382c0066450dc31cd598619fbc84f3a08354a611499013851da8b23e628000edd0a75ccbb5568ad6a7047c9212e288d842c30f913ddb62128c1346f69f811f61c69f37f542d4d2b15c97c7ec7f853294c0133e8a582f68af5d6a7c0c8b912f556abc6f50c0c08a1b5a0d730f89c9d19c2225c8a0152f38688989687c69fbfc229998a6c42123b9f7bbcf91407aac4cb171a73ae4cd5e7fb964ba6f714c322e02d0059253d94cbd96f5e35667b3470cc730ee94f67fa92705d6877089a369211f58db7dafb30c6b3b5636bb9e4ed3ff1d99e0fd3c6631b929a9c59bc2cb36aec4c04febed3340a8ee2c476ac7782fb431099280632b4b08b423b12faf1042e6b0fd83d3732a3d49f09a1ef9b7ab532f9780171b818d2c88488cf1b6d6f9d686fd5e07aed5865fe13e847c63b22bb53774913c64d13877cd15d9ffb30f68338cf5b3055670cd6a8ca77b5e37dbe26fd88bde7fba384003a05b60a5a86d49df4a44f4b6123d8d3cdeb909a936f524cc7126dc961bf4c4e1f37d2d7e94bd9ed527a288809a83354a0185ee1caaa20b7b16fe04aac25110508fcf79cd75ae573830e1ceb6760e2f15bd543ca9c935d5bde3c8a512e6071a969ad318f7b63642b73787574ac678a3e93fd9875d8ea7a45504cbdfb1d0361ce4bb43d175d98b5b59dc9f14380b4d587282aa84eb2f1811f78693807bcec7930ded45e47230a54c8bba3c3c67f3f67db7e4ab109764cf3f2a6943b095056525b7a1df7eee30fb74202395aee93208b4b5c5645427caf25ce877c26df77e473323883e42072edce8274d62d6f2795f522158d561e3b2acf2291f3c3ebb1ce5e65e55098286d0312aaf3610835218bfee0fc671cba397cac7841a3cfcb733d08087c417cc08ed95b018072d0b756ca2ff78cc711fb08bb639501a0851e6c9d8ba70d89b765f73e54c5adb780192940efdac4bc80532a1f3c3e97b77212aba470721318868368e7335f9be51872e0dea9ef402841c3c12502b5fea8db73423c138c55f9848ba3cbb11e77ce747c8005f189f73707fa2bbce820ee0157325de6060368902956e378c0d7bc44ae142026ba8981ff1920a135b113030a208a6d43c74b409afcd84fed84d3bf61e5f27b3d9eff8cb48008744673301aa65fe20f5d29201990c81212dcd9a1ec3617b9bf810edd2fb4ad47e39b08fae42247e38e510af879b496f51d6cde75783b61ae25139faaf64d89499b1bc2626cc6bfc7535b29c58545120ebeb87f5d61db3e81cfe29a1cdf30e6b56a2c9e2d929e747ed2e04bea152ae8440be70c7262491771741d690ad88ae3e8083a3be543f01dd0c64554dc5e842cb6730efd21402bf0b76eda4dbc5f76f84600df1fd8f2b65fe0dc65f75bbf5f52a25beff48efcaf1b2faa6990456b77c374589bbc3d593c6f3108389c1cd37004275bd51368b2fdb5b00a3decdf5bf4d82bf0121dfaf0c0597d684b12de70e58e234d00567be562d448b7e0252ef0868166c5b837c6aacdcf2fa230ce57c9d50ae9ac7d31e41a95e73c0a188aeccbd2282fdaf8f98cd8e41ca0dde427ba0f178b1f37df1cf38e142d830435fe5f1518970a887764acb9a0e675e5239ae59c1b5a2c58ff9c03662cdac5ee8d22a4caf5f9da3983c609fcfccf43ff92bbdd3d6e4c7ba0200400d6f4f9bde9598e05a61bc29d014d40870d43956299bd29aa7789f75ab14628484dfa1d2e3d79f12345f4ff4d45d970bfe371edec40691d037c438dfcb73e96639e89f840621e876e0f301114f605b4d4dedf6e240cb9d50502133086a895e9d5d0c06e99178f79232b88a8b6f056e38352deae205b9e506f5f89d5a22eb1c7c5c1f44db27652bac860411979c85b608915f06b493a7bd6472d3f2b781e410d11a3e8811dad93cb73443f74312851b91b80ea0f9e9495352b23e2da4303c2efd777c57303d254f73f3c85657e537ce70da289ca25b569d31819e9201ce5296c980a81e7907fe7beaf0d34c0a6aa88d8c1b17f8e913b3882533fdaa3f24ed0ce8b6ea82909dbec4df32f8151fb27c72755e52da52dbe38ba2ce25fb9a1cb228bdde29961c8abe04a0dcbd7c0b4e32f7547a1169c53eb1734925da68dfe9f31a3411bcec50336d136cf2dbe10ede70662ddfb30739bb2745351d7219734dd4c0cf0aa4ace5fd3197a05dbeac41cf22e96063c88e0060e0df6bd51434850000bd8fa73eecbd13a57d9bc77d656a08230a84059f0fa89967098a4419f1a18fce0300ac52ffea4899b27973062f62f7a5ed76664387d5b8870c5201d6833b9e9c7255465af7f43f7d99e77d2bac334b83bcaaded84cf7082bad5b060066f0207c484388d12683692558b9aa8d04a9fc79eced3cc311990799d6fae0aa28c6e47fe88526f8bec0b56cb32a54f133459406c4e1b86014363837126fbeed220702782784b12f23095d945e985842b4cb5310c0e3ebe18f9e6bb97880739f3194e2883297afa1ed1f07b4b06b31cc97764dc5227529f9f33e0d717123ad05a20cf717e6ce100ec420d26afc0e65a46d879c88c7c74a0b321563081dbec3b0b7878e8f32cb2d70cd95471fa58654f91514d602685d0c316245ae96ce9d083157165faf36e7fa05027d760d2ab606c09928d1ff689a3f596875b8892a2f45bc0a5bf00e2083ef04d79642339371a610a5b6462efe47560120d165eac2a705d693af86caf9300545a6af4e286b18734a8272b5255ce5444693e96608ea43f2103183ccbe4f7d4bd0d29b78c4f044be58354583c1dc032f434ace1170e85a12fac4d662b0698b0d30ef128fdddcd62e329b40d54c14cb72dd10bd31c2ed48604eda0262a4b51febf7899a90673e6e441ae1dd997a115a0c73b7781c1e0b9d53d9242d1f127e91c9090dc9326e7c133a9e9cf6736b3cc0e6838f2ac65219bc984762b6bb13f4f09734312770e22fda9f15b700ee18abd28fd588a1695a2770e2d8f9d95d244e634ef30b1a94f8ea050743f6a5d17d40959f8954a1a12633d14745bbe9edab3eac9161b9954176b8b2b009b8ece6bccef0cf2648eefb524849d9d1d34f417fc4af8cf830a8f6c16141a5f880f8406c0fc4fa3a62b0d023c3846375b0ec4c0b5d3a71ac5eaf046e5966a9b900890f7b4065d068bb5b01bc579e791cd8fa041b924dd00616973892d4de0b6bbbc185ecaf94bc599d4e9128f2a5a60bf7d8feff4bea83b80b6ec4699eee1aef4aa57a55b956486b82849b64df43736f222436077191f5c604f0f513813622a16b25d94b1a25ab050182d3efe5f1e76c7686e8876f4c84b4e876d5be6d7398067bb6292f8b0050aeefdb3b1be8550858282a68a7a984db84cc3b5ae4ddc944ee39f9624db2915adf148753e85ea4e2d385b5a721f19ff659ac482db8f091bbe14dad743fc64bc6d908eea5486d0ba82425f45cc4b477411892ab09cac11cc7c2dc603fc3dfe3400f1041808e2438edf155f99c13ad08c84b6827599558e3925abc6db2311097d57049e03dfa69555b3116a0abb587b09b2aa3ba4913e9ce860ea5642e5936e77f8eb8e29ff6eaaca462884b7b0bfdeba4311a35458cc6e63e430bcef68f47be47604d86ad6c4b90b46b98a1c756f1d2990ed817e2a5a4d52fd52e93901012fb85ef71647c4a233867bad729fddbf9c72d4fad95176ed5f0b7ef52fee3ad56aa3e2af3ab0d82c193c592fdbfdd4c75a4477044ef4739376bf81cdbd908117cb3741fbacc350d25f24244e9bf2b06c6baac79c22ca5c3db9283d72781c77cd36719544909b8bb04e024d6fd50fdc69fe56dd5fbda32b1baaa4062c82190ac2bc2c107af331575c3c8d8498084cdeddc67879df3b1947a8364bccdfbd4c8647ab0c7f07acafcde3769129cb89f70dfdef2a7616af31bb233aa5221eea92b4b6dae75d7032e78167d8ff422b97b0bc84ba15c20ac895a580167b247a3f4787bca4495197da848764906428664828296297860a4052c7714a8637d4dc48e976d8ff92df3e24bba6713b00e6531baeda6efb38f91c7840b6dddb1793ac15765293ef8c075d2add6eda441e709452630bd161d7434492fd680df26dc4ba8d12da908eac7960bd7657ff4f95f73b8bde3070ac5c749d05b448fba0834405a1976c8981ac0a5f7539bbf453b17881f8a6642c2fa3f83aa1596f37a20177d5284dc45e65a264898af678b59ceca6a8ef006f576e2ce86bff6078c696279db812b99d981c59e4632894252a3d3207d491bbda505b545acad0afb1457068a51582fa4910fce872cb6867d869a693d3d92d3f75b4f331446c42149e1eb90f0ae5475ecf3b6c39ec9b39406b4a92bb4d1f2ee54b96c28d527f7c1147ce56bff2b9b1e3305770881e0d1744f2338a5eb35085fb7b8f1c2670e42e119f2ac70f4bddc3f2f389c308a542b3f2989677e40c2f5a4e4daa748992a112c58b5e2ff7ea4a4a38a76f1591565f39708b7f3bd620f87a822d1b2b3b47848cf62bd710f18f56c7ceba2d0dabc75135187afbf99ac94f869221274766cabc76e19920d3a01a5531394295e943622ab00c0244dfe08795a7cbda1aa5b663342f720c0dc35f233dfdba7717f7c35f65f2f8099edec92df45b2844c1a1cdb7935a7c1ce92b53488dce468c3e484adcab008489a35b7696ae439b107803ed1ed010dfc8c0b7f6643bb921609a81846cf9b958e4411071da2d6a9d0eb848683b6195b2fa1420154285b434de08aecd0611e0cb8f8bb112aa90f33274b2a333388edc719433d4915b6dd0398559f730b0cac8d535fc9f19466bad30dc5686742ba9246e2fc1623b82b9248ebd63103feaa2b9046dfadd467f172cab551a95cb325e88474f06d69f696a8ca560c693af22cc93610dbb47855d0ef376d4c142dc40b8da5dc1b69ad27a134666e4604ed7598b92977d209874a2271d69f99756fcd4f8ce170d33877a4ffb772774c75d8275fe98d23a95aa1fde6535121a5b4e137929cb98f61403c36bd4e53159c60ddd1fd3df2ddabe9dc5c03af92af9cc2709ea242caf269e91373358ed0862ac8aea7f0dd7215578ca24ec6215e1bb47609bbe556ceb18e8c30b7f316b994a8ad8413fb203f4a218c6e5a898d20b272f8a497ab0786dceb2547f918e90e2d6fadc186c5bc6fbd5f2c39d9b98ace316ff3d79a5d1b159f96290c8149f5fd494027b2c6ee8bfa61cf852b5278091cb32e9a6f936f94b86127627f764b543cf00e610673f4951f606828e511dca563e2ac52ed60c4f663cab2386dc379a5d8ab5f735003fc98e5de742d052aa8410a2a8fd04c6bfab8432cb49ad1fc03890f1cf47083eb59ae00a6c5079116e632f1b174710043584f43debfc1c5546a01dcb91b4c8e95f988ed74a44f2572749a8a8f40b8a000f9ac61038b4213b5c189c8714e0d8dc4f8d2e82650a26a9d9c2bbdcff592091d4943bfdf19ba1b5b3a7995cf551a00fa98c9fb370f1393db0d3c565617c18f6b91001b052a81b1649c1ec718b7e38d875064d0934ffceb851619602e32a30caa433ab1ec7700b70b3f017d654ed9810077fee6c4e3cb8da857565deedf03cadb42256471e5330e15541d21ca7d716b9727d848c18397b1ae408b71ef9b7763d2edc25794147b2ec4a5b578d5cdb1df5f2541de49afda6bdc58b4ed70839552c381d73cb11d30945972c63fff57eafaaa0c6c47a90e09c37b3215d9adca3790658ebfbe6e5604996e571855f550d172c6025a360cdd8e57a18e3e9817f9d948820902b279d5aa918af0d3919141d87dd2869bad66a5660474aa3dbe7a896c2ec1296eb2039d91ffdec000eb2f98e95ccc90aa5084ff5395c3a802f0c1ba15bef047556d22531ca2e64ee2e916ce8692e36fd638a106ee925c4af72dbc24cb5a8cb51df82a1d6f75a165899723144a9896d9404e58db5b744efe5b8623a277db8ab63d4c0a3f67077287c5c3b2f16c83a2ad2c6b24c392c905dde120658793e0abb8fa23c23b96a278d43ad3bf7958fde4ff6099952c99dccfa891aef90e1d933ce0cbb50cfdc376b601eb48d47c248048bd95a60484a58d7f034cea69f7dff5d6e124e127d9c21ae53320813fef9d5d51e4a57f6f5f822153e0a38849532818167a51b2fb689c468636b8e5382369bee24d35cd35a7a06f128d715c4f8850ba51d77568588997935f7d66cef2e834d2ba33d0e059663fb72d67472f1a587e8193bc672836c0aa4c593b2c8b44367aa2b1b1f720dc246c39d5ee0f3c7347b5a699e6f12aad67320026bcef6e9e3db54092bcfdfec3f79956a53332d5266b655ac39151844d7f642f904b6371c3894704e8631372643ca08272a67ee7520293aff0a9fea217f45eb62a61588016f69e8d28936e4bb986dd517bbe6631a30ad23db5be877455adddfa8165b7772f1daf8c31efac03240b86e75a1c0717a2297eee12c8a86e4cd906d25e7578eb716e1df7470a07bdc4e8613aa98d7bb0930ab638b46752c09e0df4260243629707709200c7aafe191f81d5504871eeca2814ee5e4b27f2c11bb8f4c39e7881fe3b2f424b7a3b9020ef314f35be146c538bc195f013c4100e56a0476b89871a6e3d4239193743fec83a10e360af44b0506a0ff9b8b83cb99c2c73423d1dd0fa29c78d1ed954c2a9fc6fbbe21d5bb06fe0250acd71eca02c9714dfa94dbdfbeaf8c45d714ace19d70248534e705e6c3e850856172e1260594ca84c35251bb37c1a281ac57b74fe42a7765248227ee09f5a9ad28476bbdee9fbadaafabff6857c6d8ce71ae7654c420dfe8d5e4c9fd8e3368865290de51af0afbba836ff3b8a999da3c7d63a2ca58cbf466f65fd0d220e184dcbfda63ae3cd877c817d49ffe39aa5dc50c3640ce065ff9a9cd26e56bfdb4c53bd3f84a7507ccba2edfd6c3c6f92b15c32d4e8acd575f9ff1fa31ac95de2b710ed8149d3bab9665431d0099b4568808899a5ea7858ea524a70e959dc475884641ac149f242b709a19a07be0ad7ecf909e312c5f9e7c4f9a405ac02452f57ddf959cb40f0019367886fce6af6fea186dd7ebda73d8783e95f892a215da2f75a6e7de944433f575b62d73deba520c297f3f3019aa39466a2f180daf2570a0eafc8bbc9db66d150257db509ee4fabb17c316ae01988ae37c2c5ee82f547672f4863331c06934bb9fd59636e7b5c350412f197fb5d40960782a58497466d42a16f11d68428e99dd704ddda037464be7b224e2262687fd0120b71871e67f971fc18cef6b5f29a28a4617a3daaa90ac20c1a5a9fbe7095314df83e964841c8d064e64ce5f3cb6289d616a129d28acbdd29f0e788e03269c757110e07779613f93af8aecf4b432e7b8addb0695bef3939e84cb6e042bbeac9462749b52847f942cde3cc60257d98dbb6c55845be125b347cb15f4729dacb2d65ed160c5aad7de0609f38c407035ea8e106153cbd5b59a738e2685a3dd09c9aaa9da2fb99e823a94a73403f676302592064f6d468de19304a0c11c1fec4052a0d1fb3fa8c0d06b65209bca7167cf6146c80e5bf2fa44da856ba4563eb54dc7b6d4e9a87b5cc46335bb8c37a6f6fbf1edc2f1668b743478e34be87df23c1402ee2b0b86ee97a774114ba2af9d0563594ad4577b76af2ad277bc7194ca3d4d664386f8f036877203e2a9d90ca81faf1933c83aac585007c72180fb46c801915b745ac6c96101c1e21e92b7e27cb460957af675f283e7f611e549509a4516221bd04b47c08effd6e1f561b419280ec779a7a1dee6e5be484e868817aeb5ad3550b4199616351edb050f4dbcf97c7e9edcf8a3bbe59d3a7c1d457b9469ab2030bd0775b4297b66fb8414e078d457bc828d57aeba14996d0499febccb1cdb0409b15d3de3ef70ff8b089986b3e0a6a13d5e3cb24f6e0c61d36ad26171f28e6c8aaabb41a0de77ed99d8ee794b43e9f2de93a9ef2e55475016c5dcd765f12d0ee83a4de2fd8560b956ba3f9e859637f70bcecabd48a6b371aee5bb55972ab2725621f78dd36560c2eca6fe887d70e0f69c045b345259c8b3ad5fb69962c2923f5cf03f10b59569ae47ea07b7490d16e07d32f6a9e8901ce1451336c052011c99e4f503175769418ded01078c0f2818a609b48d1f53284ebf8098606de61d83bac2bcc838f5cc9c1be162f8abd93679e8828fdfc3f93064c86919bfe391637c9ced31517f48448e90aee59c798dcdf3df80b7c853edc1d0e79974b0d71b4b62e44ae789bd14adb7bc26e8a0e39481fc68b958b81c7ba42f6859a2155a5bbcf5f885f7504e68fc0b199704dedf36eb9d3f3e99a1000e8e23d252c31da468a0f2ac99ade291a878b34697bb4f1e700c152eefd18226ea11c395f1394e74f06982af2e1ac91f707e46fab11d0cf1ec6e679516e9d3a5086ae2cdfb67071ac6f835fa3c360b3c9f05dd928dc44469cbdec77e18bd7002226cfb0172c149dc8cde2297224e7c9f3525f176dbc4091f376bdebc9ad11f8d5d038a69c8e3b7174c9097db1722fbe951c711002b7bc4bb4604f0ecb70841e9eb406013909244bb99bc626468bbfb5f5e2b9ed84e06eaa9203c1aed4cb0e6c6fdd574e9d610082d0c03be3d6b8ca646602315c62de990985edd5b14e4ed9b4f9e2cfa905e7b3abe0ec7abde7c749e07831872cf21a9748d25f2231c40aff8ad78860425a096bc5ed1efa627180d8539d87859d540ed1a3fb510815c76a648dbf318deb96d9c4c3d86fe08822b7d4a6fa4afc568da73598e8df11faa8e04f8f467bce327f5e15518a81c657bfd3935aaa2452f50feee9c7e537d0e1e125350459baf045dd3f53fc734a8180e5645f20508c8bf43268523437790399c03f3546dba2ee10c396ae34fb580f28ff45fb204cd1b5ef2f404855692a80bc7e1a12aa33ab8f53fb25990c35807db9468e355f7eebf786377603f7c282ca0d5437542cd289df05a319ed3ffc0698393fc2483cc1ef60e88b360e653a9859a430196c8f119935f8701e318476c351f18156cc1868b4317e1779d4b8d4accb92e45e3e0e6ad176ba954e364f0003709791f861d185fa98cfcadf819873898e4cc455a4bdc934a67d7ada916494b0bd66b991a3aa891af720b7f08d3a79b535d752a38878e9e4819ca428746bb02e11368e62a647c91f83385bd5aad246d7bbe9af07ecd0168c620d5acbae237b5cb2c48cc5af97e97c18620e6fcc56954ec1b2ab467d91b2a1eb936084fef63bb2d58f975d7fa89dc0bf3212af2ceb18b21a04bffa6c355377ff9000c8f43d05620acf42f877e1d97a95dcd91b2437bd4f42caf3b8a7922a1d5a37fc1f741ad42c0287d4d51ad05449dbee697bfbd3d128cafe92e5bee9ab556ff09d67dbdeae2a5e0a3d1a631cd3323459aa3ca473746ec8489083e1e3e438a0d995174295b4ef094f35e1df0eda3eae5b7e8f32a340c5bc763898efc44856414e6846c4126827a189840aec0d5b0592c2ea35aaaab0c70e08e5390e94492da957cab9454dda0f61791e6f450073cd6892c16bbb89df393c6127238f3e19bc9b79ece35a06bf7d76dea2faaf34b683de6de705e2648f738e6a8b69833fd3c7c1dc786c9dce940f7ca53cd67ad97eafdb6a217efdb2ad1c0b82b6b2abf37db0536368e927d4c1adf7805e687dd65a31539592fe3cf35f36d0814e472fd51deae96dca97712768944b431050c82d0ff86c36a3e602d6bc7f21e278b05f37d7e587b7ba2b8d4131e5f001fa8bf983bf1fe8aa6fe1dd5ea0cf9ce2efe7dae6a4fdc123fa58117f95beec2d2ec2d16d5b3e0db86276db120838e297c8930de3b12cabc45f0da99e90fe692f0fc859948e35cca5f1a48b164d44ed7edd19f644faa26a34577779f612ff92512bd0d5741c1abe21f64dba26fb831c667501b9f2efdc2a92da51b48ac33e3193043d4182276c57be586a8f615955ea311555dc99f1c09e016478fd4ce9569f1aeaccd9ebdd1a71c3560eba7671d567136f52473ebebfc2838df5eb3843cbd2f82502d623dcda120b0e98b0ac814f07089ba2a165b2fd9f3b9981939c211d8dbe95e0c65b8b18d012a1c800c8018bfb451f63ef7c98d5e272816bbdb4b9d671e620807aaa975731024f06fd13af2f1dd455363cdff03f39f0019f6e0b0ea1e39fe48d5d65c19d6921169fa7ee8d569d49020a6bf6baa8b7ab969dd9c57956e39dd1fa55af0e57afb39b2ad828822da7c4214735a82dc05f5afc1b5eacf712a27cfc60da2f7f7c0bb9924c5788ba0048c3dff3b3c98316c306524e308c08825ee265def2753bd0bd5a099b19ee3f7b39ac58bef5dfa1e4f498d70fe35cbb793ca94bec1076f0dc9f5429a6b4e55b9ccf3826d6620cb403e36fbb0df41ab8e839f50f548fbe74ce2f7843a030e5dfce7e0e1105108e128145bc845323e89f684df9c62fc24dfe967390c88aba32d49cb355750fe3a584e2373bb4cf02eeb254777342143c9e10673298d045a04165c9c6d8d2064652778fd6c8e1d6af876a78040df4e274b2d33e53a0f6258cdee18664fd177a79a440ed05bdab1c299464bec53c5e703e00db5bdb0591e811df10358f75bff3ff86f8afafe0b3207307c2b7369f2d32156d9b02b86bc1515506f910fe8ec91eeebbd63db4c364aa88a25f1346717bac48ede09d761341969a8e37cb2a28ceb95bae7ad421db28b4d31c6a03bf20d8d6eb3ed9f5445eb6adcdff8447c60ba18b182ad5f855f9f3ebda25e32e7ed03142d3de23ecd07c88b06324e368921e0bbd26325ba6e060fe81e8a5f96df36b9c1c8d7b9c99c67d2bb456ff2aed30945a2c3b4889f2ab80c89538faf797d4b89304f8024114204f288ff52edd5f5f56d520cdfd108a6532c1f18b970279c64eedeae7640f4b41387320a3ce6473f0fa11b459c61dfae6520d2d59957037927a492fd421f85e52f72173884351536582d60fb748f204d8473fa12d7aed9e94f39c99b095a148243c5c6b4ecc61706b7d8c9fb4e0dd64fc4c67f21d943559bd3a2248073c8abd484702185faa83b0e497833a4ba2fb34ba3779ee5cb24ac42df5edc3e0e9ee6a978d18cbd5c2fb19f7405541c9c18625231906a28ce5fca7edce743c793e4b7235aabb5039b4a65f07765bd48014dc83913486b76ad5f63eb420ca1c87a2204a880c4774df9ed4230865b02dc89b1935e4b895016a952b25b4f4ad2b3e7479b0ba7bcfe4a469ec33808a6c7573749935f944a27601a0389fd5baeace88a6d03ce5d89104d14c83f30e8f3b52a47406fe0c7b4ad4d8765ed2ca351558397ab8d1d893f821fab7933b9325914c2bea70c2d491db38e763f0694639829729e84c1ca14e6d177e935ea4dc90aa4f0d9456751cdde62c663041e6a237563a423556b98f44f02dc922ef059efe371e99efba4c3a0b2314f29b36643593e48f5e8eaefb7c83d13c7846b2307c4c2eba087f179d734fac3c3c5d4c837bc7b5cad10a831642c53f6669eac3564ee79aa95cc1627fa10dbae4b2bff7e5bcc3e5cabec98192504b084b340e6609b3a2b619fa67f1275acb33049955c262627ed4fb483c5ecf5c6c0d092a9ec420b2575c57e2b335125c14e04c37b2f297b0225bb9953cb01755eeaee724a6cc5d7d82ee5a3eb7b5d5867b9d598a39f6a4d52ffd65c0f47d204223d8908f2097ad508e7cc7c4c73365372959067415a7f0563cf5976b4a5210db3839735baedc90222fb83dca268d712842c2bb334e4534615fcd0b22b991f646e394a27f95fa7f9e8249487cf4fd54b7f4bc21d96121a779c6fbc2d8616d3f58281c01e400dcc817c96e7538edf8ed6dcfb41032c9dfd3e60b2f417b060f4826e03e5b8173976db1a34250e8062e6af5857ac57e179ec248a909a3ae88488d58b0dcb00c5ad84103b2468514ef34c81d63d234e2cc3fa63583f8e60846df3466bcb96ead4e8828495df3422d25072f7ae12bc2971765bfbe7f2c41a89b219ce6dd2ce62d73a225781e62af0ce43fba1ee9b881083217c9c4113e078894e05f11ab2e0f1fbb3fe16653712775300e0dd10836c283d62f95456615d6c412361148a2ce14b22828891caaf1973a1520fd16d7a4901c6b01d1a867952a3d02f00203b1c71f0068d64d484b753822937450b5ff37222512c98e79f3ed4bca553ebfe03c77d006b68f5e3c703c34a13c89f573ca9dd528176f56f711bfe854a8e955018989dcabaade1124f44573c4659dbec39eaedc9064c6dc013fde4e10e0207f492e433a52134bde371d1b080f491d62d0d1a52a4104735c4e08fc3e40f1f64f4e168a5139f15d707ce3b8173e40e9cb013ecfaeddd87c3129a54cf47feccd74830d200362d03462fb7f13fc7410e9c2142dff8d51aff04e796f0d3405ffbdffc4c2ad16ce0f94e913192a32f62d6695be3c28d1b5b6ce72bc11d2ed8ea0b0c5f969e3767f89739657673e5052b5739345ce6648d33b58c048549c1b7d6b912293953a578b3149f5b69503ef30782c8225415cb108787ed6270d1f4c80bead4ec65febb0f00a51e12f8963f0ffcb7b440ed6bde08f04fa61f4709b74402b0cf9f9ea39f653e785af0325902926beb2ccfd67db90b3ee30de70b515b8815279535e7a9529d43600fa65a2bd4e4f00c95e76e245b5750b6b2ae6e0c149a7748c5a63d3faa026425f53db0877d842874d1fbd257590483221d6aefbb11c25ef3c82a759ed29e12f33822e340977aeb67b2179831ae74fc56bac31672f33c674468d66154ef9fc607d41f29f770815a34a783379838e62b2c3bd63aaa4ea481bb4ba3f3e298d7ea161403260a8505ece517e03b4c7c4e89004d8a98ec03d8ed2ad0255489871bbc5da3a28a8e8ec925a1604811b5b361252f65a29293d57726c05195b1f7cdde841bc4c0806c975e45fa27216dcb92b2cea6f3aaaa104cc6215214d8d125f832941d9ef24b9a6cf68bca07a617a5f2dc2a1d79a4462744b4ccbf63a99abc78bf4ab74d97efbe5b2195c21dea76fc46a55abbc4a2f8519bf6118abba5d43a297335750cbb4d265ff105e8d5430ceb41433dc15d96f635c9c6f2d2701f30216d62393f332a953ac72a00355594754ce3485c25b97e4dec763352eb2b51c0a57623da8cfbb338595d9ff7050d7e466f98d8a177125efb374f585d2aa916602894528ff780120bf2cfc4230f46aeceeec21c8637dd56564a8979fddef8291a6af41af6211b8aa7d766318099f850e4fafacaedfddbbc74aa414def9555a9c6d4fdd39d87b1af11079f792107b8c432ba80b017d7fb74fb4bd18ce30159bf48b252793254c4bf83f37e489ef9fae990a7c87ac73505f94f8007af47cbf25ab7f5aa40c9429d5fd80b4385fd0e77e5ec2fa0c0c407138c45e9cd4783a47c095283fab8485ba1d03b5080534882055e4c50f5b353ae47f7569069e177094f4b4190d7aa7fa152cacaa75ef87f795e4a280ac00a70574ba46c6585fd894c2c51264fc3a1eae15cbaedd95d8083788dd0291324290a7d62574e7d8ff05ea7363a81747fb27c483fabb3b802ef646fd3f2edddfd6d9acd9aeb96cfc6f574454e92d8c2521212fa82fe928e75636f2e128813630321fe1b6a423151cc47d79b00a0dd0784cc33aa6db37345179d623e21104b032a07bdeb30620c0cc9db1dad7bca3b02292a97e0e666cc10bc957b2633edafd599bf080f569fd3cef78de4662dac8bfeadbcee6cb30da36ab5e46e6b18b59531065952d153676d6f19703330b293a305a9a69d09bfc440a79ab444f59cb1504c9441da0fc8af4f854e0295394522a757ad78b6732860664ddd621b040b613ce104c165dbdb690f40fb4e70d0adec806c8a2f152c59c57e9b616cf51b38e1ba390dcd60e2bb62aea4293dab4c50c1676fe55af527cde1d4952f8781f9042800355ad0cb52ec6b9bc9c6de47851d28d7829599123fcc55d14c25ee65c6de0919834c5d9a30d986d1bb1921da7d5bd7118607b8e20e85117bb43f5186bf16041802f8b2a2331caba9aec389378724ca00044a541b44ce6d67e982e914f52effa6095b2e0ba8afdb99cd9aba29b8b71bc5c9cd50aad6e677dfc470ce5ed29b4dfeaffa6b71c6e1bb7f9f7e6dd889dfda5efc06fc2e2b22ac947948bd3a879be8d2e6fb941d6d0ee9aaea40255893765f830ef7f06d670baa8ee10659d8f2d0526411889078027c4987acc730e653fd329d3d88b8e7c70d2e8dc1651cc5187078ff208aee3b8b4a9a335245d5454c1709756a51abfa0a23bf8e95eacf29ec10fd10d61cdd4398f63ecc695ffc9b7f3ca0d9e098abec202eee5399d3c16b40a8de92daf33f7a9e478a3d3c0de6ab5d004a1f5a83c1b69b449d970a5830116ad699fcd0b9e43cc7c0d682ca339cdcdf1c5aecd06ba777b423e53d46dc5c363b2c2eb5436899623cec20df157f436ec23e40bbf76185c1ae41657e5b9c28f22284fbe2dd0615594d1a232122ceee1260fee8319db14d6ba7647f8c61019591feb5a861b0856b50b45534cfb478e6e5c3bdf0df338d071ba514490bb6e6805e9ba4e4ce32c698352577b99871dffc97c30b432c17a1b43ca39207111a32d4d00a8b3b2a146e63c6a88185d3465475104e09be65231061d3458c1d744f86c7576d8210bac706ceb842c4d9c9114a4187147c8104e78042eb1f1d635f5d30e31dec2c776aa8ea2589e772ec5b0c6eea354022fe388aa635706ec94f8acd26eb903897bca55fe2f042b08befef4f24b15d3342644f6730b78546d9ebae64a78ea1e4628dbb4d2b39cfec4f8c60852b8d9ae217e9f460f40e152d1bcd94744ed1b9bd1be46baa2a13205b77e01aaea9ad6feddda61b7d49331759e97745a1d2cde32da54a94224732e7c547ff48fc69361f64e7cc3dd1dfd86eac4d974a1522aad020a454a19af3b4a7b049db478a490af5a1b20a24b3f30b9973d685d71995e10b91e1e0d362ff68a68b84f60d30f941be58e0c0a6c0b0b55ac3afd632f161ec9915bbb7611daba478e56680564bf6d7fabbab24759ae8690a2599f56ab6d80056348137305b0d3551e2e0a542696ab270928861789ac6f8af6eb5305650659b728101c697fea3e1162276320007a830b43813357e831ab0f08f2cbab8b39bfe5dc427bd9521d15045309d59f1dad2a714d697b42418b25db1af55e06c34ba877df51fb590fea8d939124775092a74e65a9449d1ea46b80e47a3ef6b5ea6fc33e1d306af71c8283fd9b65fee40652b5f5b4ddaf3f512ba585e26d7616c5c7901a5325e97fd654583c702faa79d44c680786f21be1a9f6cfe9d6ca3b63e71540b4739f52799ac1faa5331d73e7ca398aae2e83c706056a641e6c4ec210a52ebe66b17e85d4175b634b04a30383d46b6927f3869f8e1df9e9052b70627cbe405798ca301da0dba5e6b8925c2d661393076b69f18730a566956bc340249ecf859d39bb6486b0f98f10d63cfe8cbc9148fee71bc440c2449685d8605d6b265d78924439f5a47145c0840c7077713a0e3c273877a144eaaa28ae1e9e7fea23f1200e5f836e2d3d931f75aaa82f1f6cfa6638621f37ef200f601f3e0120d8cca1a7cbec743eca67e5810f72badd02fdc453e6459648816076da46ac1a4e00205f94225de9df63a15d1c3a46e92d11475c76f947a26aee5bd4ca64dbebbfefda18a69c0ca476858c4474d78e2d8f3d656bae263d7e7e5e213ddd05e094af8f54873610f9f20321d5c894f5957e5e507025a57fe8da57ac28af8b0c72e83b38bdc5104410b04349a78df64c1891f0e167b5f9c8c1288043cc28a0fdc651473f4388ac40e3bcf3f9adac15fe9a483be731c370a1e181e96728d48d465b3baa4c6a87e4a0f1eb5c18c79611cb48c4fabf2ce65cc5a9707bba5d3d98f2360c3732ac1d5b85c03d19d2a36ee947588f0084008bc5cc1bf78a95ffa56137b394a7a40c91ec27087499210f7cb30879047f7cb9c32701c247ba46dd6caeec033a8dfbbedcc912f798fc092656cf8835c939e92e3aaa40a9a082219e442da7743fc33429c67722dfd5fb62757ff05528ff3a93f9446018601d5ce0fe5f2c1c8808546623aa018b048ba0b2bc106154206b1778d607af08029a2852531f9e232dd3e5c6d8e902a26f7f959213e5450efec521828dc50bbf4a43e256687daa9a2b2d26fdc666e86736f1be60c7de8f70fafd3c93881e6cbc1996cac970dbed4d985fac3e593164040cd17c559d416649cd9c690899e6df1532f05454f9efb13c57666323eb96022b396e46f95f8221ebd325badabea5fe3f7b7424943019db3b82c34db8a44b20390b2161de141d7ac60c9c639bc89946bf4eed2aeafbc17f044587ee1c6f8777468f00d318fd7d14d37abd1d95f88ba5b548cd7e0bfdd3d7cdf170c98f17aa948217b68fa5abe4d4024f4021137901a95fcdea13aa553fda4244a2749b45aaf3570715faa9eb7c69cf93be7f2a199717f7f055209966042f3adb5706641e6ad5684be90f501940eb3c723b1d28e1f23886aefd0f94bfc44c6cf0e0985e53b759b925d2d84caa09b455d9c0268e687cc7f9dff64a0e8a1940c2ef2c23949b4a7f6fe9a918","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
