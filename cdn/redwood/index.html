<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7882eae82efc95ecb157f4bcd26940a7127e1551157ff57eb88b012b229ede1ad2ab885014fc2164293928be0ffd7adf3ab895f80857b79fa20bb2ee5047f4ccd13ab48857cb03baf4848c000d0140cda6e4dc3ee3577132883c6022dfe9d8988c653fd59d04a7490b0b94e0322604a6d70accff1356b472c3c09d1bc6831808ee230bbfc2d33f2a5695d4fbdac7e0eb1ac32a00699a1ae8865ed093011ae9b2f187c98de4b6be7750e0632ea7eaf615a0875a567d3d2ac21f594150182eff9f0239bb50ce94634872a1b6db231074e6ea2f34c92ae20db4ff17af86e4522b640d597ce00f75a6d44351d13a27d0d4e8f786e4d22c0e6a3120994a3d49e90848a5464faa619aaff1f55a61541adac0d0f58cce9dad0e24d9bd052193b092fa5c9baf24e05c43cb64a47ed5e1c51a0ca191756f5f56bd94601b35eac14b32aee923899964f1e53c2b79bf26acffaabf2ae6c44b10ea2df481f6b1b2c42f6d5a85c2efa08b12435cc1be52e74334766e557921bce8c333c57f145c4c1ae1d68bff9fe82684eb95d76474d42d269b6aa68e3c10f398b26f928f660394f331b2195dd2c81f7e9a2534da86520a5a3e6926d96b34965d19e4e24484740c690149c17448c963305aa6351d9c853028a5f70046eab1588db84337e280508b7f94bd17615f7ef1eed0e6ec65c7223dba9383d637d9671211fb0b3adf8c0f25a120cfc5f0ea4585272623aae3ebf27fbada7f4d59e485c67f45db2d6fa8e41fda36bbe9cdf7973094bad5cd5a0e600031bbce0bb7da33e205fbfdef0b4b66db36bcf2b3d2c800e046767e8003c32ed9eca5a598f59ae85083ef4e79f1822f8bcc7a3e9af227fb1a55ac69cf0f1fc5587b285301ff489d58a1b1a471ab69fbf934a76913de9d3943a63944dccad7a0fedddaf28da3549bc3f17573e2cb3ac536e7adc0118c033380f401f9dc9b5718bf7ba29b0cd84dfaba7f2396eab928e8d3545034aee8bab41669b9704ea66e48080a6e8ad0f5404ba1e69c2bc4be2b720d4011efac7b718d431eecc1228de0bdf28a0791595b49336867cd3432b93a7d1d8061acb559014138784b0b44ecea1abf94ad61a3c7af95739d30310ea4d7c4198c3ae9cb6db5b0da05abff6121b1cf56938454da327a93a762fdddcda1214717f0c2223d53f04dec6fbfcb2150c3b99bf3de853bc6d995d1362e605ad280c8e9aea08ba552c553f577760af63433ae6da3b522bf14ee31a0000ae2913aaff74d638e9e043f84e28bf040e075b88658be10648b9cce8296be8bb8fb070d1afbbf488c9aedbaa37ef72764251104e3ef02bc337ae62de099d456334ebf4071704949432d170af85894d3af01ecef9191985453ba3bd2a4d5b11db1d0e65b5f3b4c8e14b2ac4dd947f65f3dbf57d1a3c83666757daa6abd6bc9c9006ec0b2e2f21888a988bf7a22aa5ad5e3ea38174b72c4225e4442211a3fbd2f9addd119d60125c638cbb01dcbe8a697897363f66aacce1b14aafe41554498dd210ce29c2aac9497282250fc4c6ce086a00c185a391f07fdd61da472f75cd824c715917a38e2dc3631413718760db2c91520c73e2a6133ee37213889ccee86805a7c1711cac46cf2e136e58d18f545f40a5c73044a8476b8c6b98e1c8f8802d596024c981e2deb266122a7746f68ac61a69a5c65f1386f83bf609101978ed520d7b6ba81589b81fde7e292bfec344f2b1f9d60467bacb04a59058279a8e4bf0afe1eb0cb12d5156fb47c4e68faa39f27172972cf2f0ebfa9ca8df9d336fd2fadd6b6dcd26db0ee6b71f7522c982c08589e7ec34bf9236a2484ef22f3334438f89ace86294762c18fab44c64e9431b651720c5911eedfe1c38ea68eb1749d6da0f5d214a20dbcf9207598b46e83c7656b59aa36b1e286d5cb1240ff8023da6005bef92746ea5ade5e03c29063b1f4b490b37d0d079c2e337c80bd93c2e32deebf8725b8823b29ced40e245b15ee3efe68e8c75fc5831583787a90829b2387f5107df02f0e654d31c0c9b39e1a9f1b52ae445456cb8f48dd1ef6da0026e42349c91c2cc27dfd82cdf95018f6227d162d3ccc13b2c0573c0b34ff8900857fed0eba0026602d201043c15b3a8f7b021cadddd1df8a72d581b6eac540ccdbbc735addef94246757bafacdeaea5ed11e4d937565b18a7e0a579ee4ad8f07eeabaf6b59cbcece803b5d569e2358258d2bb006ca5e8470f89b48b2ca518b69737d2d3b798a6a877646c90f77acd2c8df2d12e13cf4ffcc4f4cb4d34ba395309b43c202d099de2df80173133ac736992ad3435e8d881d9aca8697516ce38f2e689170c6c9dbefbf5d9dc313b7790d83fbb077fb52f52045b0f44cd2eafbb76fc6e2b6215b06f46a9158c5c99b8d81685e9b5c414349e69ff804980fa25a6a036b2aa741309c7787e997ebf329e3eb5ec343f29564d2e67d4a73ee16a6d280476538d51c63539583b637b6eafa283ea24361cbc9f1c2d6d015118dc030797c0ab1661165411a82653294630b444ad683e2f74ff19fb14a6543daf51b4ee6fcf95889ed00adc858cdf0e5877086c683b0be1cda7a72d34c5a88ff1e892799c5fb80025a30884e061410c01957dcf16da559cec27e66e1ce44ea08065127daa6fb04e88dfa456055ee8a7815668e6285b0ae713717991e0842c5f8c6a2d377dc08d6707f35e368ff6b4efbeb72cff20cea7200a4024d8aff8d41746409e24d9fc4ba42fc126440ea427a62ea7adaa58159230f4d6b0b24297d71e1d1cf3afb3e8bd4a66712871b1cccee1de806085335e36f9709a7be86fa5f3e631839dbdbbd268128c9705dd769f1806bfc79e60dd6b4cd598010dbc52076df9f76e53e601190131ac5d14ce9655998927143bd628ff836b0b35125ab9126c30a7b49c93b9539a6ec2071777aae46efd7d27f599e8a9aed82ec44ce443b82ab96927b23c57a89557fe8b084b95e35bc29fd1494281972561314b184dd240aa5f619111fa05dc4d8c1c3f0e6f67246d0b961bcb7a9b3075fb503ea2fecbfc11b27c5965fe35b06e1ff4cfd33b99b526da98ada6ca3530534dbe18280b60551cbbb17e3e387f6bf9de239f8f7f00c0eeda70e7463f47d5f2390da23657c1ccbf4b6fa3695720ee2040cba493a90d9905263f9f4e5fcfe2e04658789697a608b203d8883216f6e97f5b8626f74981d2112c7cb07f77463df2e9d5b0b0a175f8e17c8037d235da08506ce414d060b51d7a72a7ed7eec5ce5d66e4c93a0aa1913431313dbb5dc777ce387bb134d6d58f536d926dcf1495f47e0d430319632b9d7d9ef0814f2f005bda55e80d9ae2cdc2ad324d7857079d3d2cccbf089f94f61a2cb655fce00b31bbf8ff7a7a6764668a1d122ee9b8ee390352fcd7534100d3b4d2bf130061877aab7246f3efaef2ad9e8ca1c297df1bc94747567fbc3b5828fa4196e8f80109256cafb4f05f4f4ea669e993b60302d1391bd26ca1a3c054909d733733fe6a219181e57de65ce0bd92afb2da13609477a8effd3505be5c9c1e65c37eefca79203f06156e310639316c9b9c992d79a78166e7781e8c3a3cc0faf85c82fd0f4c5ccd4622de4e2574e1588fcf9bbeca5be5af272255676b49c9bd728f8513a1e50ee5edae3053b9871b00368895adabd134617ae25d64f9abd441fd344eaf9f73a11e95562cf121030ffc060a9b6cbb756b6ff02c8a9c0835b5a282841fab555c0fc76c7317667c8f7851a98016704a1001fc0b6aee9131723f0223d388e06399b3f76c9cecf8a384225ce93e0e17fcd6c33f3926b43a94fa20f4ca4638047c5a485c459628f99a80cecb6eb19929f3b2230ff202f914beab68fa0a139b4cfbcac3fb7e84b917a771b5cdfc788bd27c3518ee9f71e3f1f708ae97d5f0436e2a80f1427f8f62929739713b093d42caf87ffadb1dab65b1c0f67c03fef9f3a9a9a94460ba02eb48b621aa0ce5fa8fe855b783f2348b21e67df185c37d5e463fec88ab80447127f53cac97c3d0f19d6866019596a15df975aba699d80c549f2af0cabc60fa3266d3886bb265c6201b3271df1b22885e92a284c14737989e6a0998ac6caaffa9b807be38855736ab5545a1a7bd0cb25a5e3b42f99c63b35981cc3efd49a889270cc1787533410631967fa112413ad13c778a5d05917795e047d5a1c7b8fc568606834bb2511e0c628770b816be53daca3b834fbdae82ac2472d0b59bf5c768a3c32dfc893a95bdba1e978eba287bd53cc58e60fa9ea7adea2b0a9ca090abb3fea902df024b891e3c8b6fdb2bf2d418901af905091439d5af7a71afa8167dffb95c52ab8efddd75bc5e010539a70c166858563078c2d9b83f6646734c1528639fa892635b7537b94a420921c5d5003cd783bc4259f0f281c3d86d07a08460f2db0ab4a44ff72f94f295c9f59ae94bd189a60cf7ecff59fe7b85a48db324e6f925f7d621429e8eaa90751059a3512ec1899de0ac1c66f14c77337852500c2c5877c574673f72bdb9f3a3dabf9d8f8c26886f2779a73a73777abe96b5235a3984242cfd33dc986a276280906cbb1d8ca15298df4a1ca5432e769d2c32327cc55c3e065b5432940c9f3d1705f2328a48351af61627ff2e6d2bf3d7d40d65eec0991f70696ecf065d9bf9e70b2ac238b0d7b9fea699703d4b447ef1035bef40e9192476f17d2fa61fb8176663a2034f3e215e63cffde6b50071ae3dd6c30233f33a7f85377d796ef60cc570165345a3c27cf1f235496fee8456f9fc74f3cedde6e449d210c0edc8adaf289729fd55352e531e1b70f89401a70f03caac4b1a290a018af8a9735670933f8736bf8b39ce9bd1be5a165fec473859e3bb337a1ad1f74ca480564035bc1875a2021358f81e07708c7e6a7e99af59c92eefdc48516e28fa90457ab2f539cc4adf0c00294fab57f42401a878c6212d30d7638094b2f60534a282332a89df33085b61403c3686205297bb91e2735628292fbb9f26f9a1fcaf67b97580bce458ecdbe2687e859c191a6996d30c59a29f30763bccaac5f9ce76b9537b08a8f8f3e31c483c41c87eff690609f4552e30e77a0cd395efbaf47551e51ed094199dc6db6db1d360d02fd9a39073886b439189c98810f6d4516d013f3b4a517348f83e778574e4a2b38eec77ac83ca6bd3fd7377ea44169a981aef7b3ac7fa9f0372de3da39df001dc918c7cd6f55c111b05dc51dab8a2760551ba104efb2905a4834c139fd23c1c2f99ec2e66ab8df2e22dacb4a4f1f1e7d1ef86432c5185fb8459e75ffffc168173640cffea80557fdd39d253f7bb70b8d8cf5a72497ebae554cd20d10aeb714ad4517889fb4f551dbf4afe04cba6b39b880b463a3e7388c980e0c536649648f195d98e02101d14a6603ff223ac44313e53df143a18831d9850c07916d5895aeb53a3a69a629f7e709460d42bd8bf3adbcea60b85c1113a0945c461c3be6e19bf06a62c651d039fc1ae89a6b7fd716f50c956f93fbe46d865ceea33269b0c79a4ac43c469598be8475bda9335401b63269384b8da806cf7b251c8974da11743366c2a51644ea7b8e7895841ea20e19a22b0e728ecfd3abb0d3f844f48633455139eff9336c6bd7a35626ee90f67550a1fb56703d7780bab6e4f818fbc3ac20eb308dd3771c0af151a9c90bae05ac9caa0594542ef31240be2cec45204fd1992b3edfd5c1a922c6bec5fe3df3bbd50cd2efa3b639ce7f6366020420c3f2e86f3539e41a8aba7650527508dc6e49670daecb0fffb8d869bab47fccb01d96558d744202abc8b45e72a7b2c27b4dbfc7fd0b2f1df67afe676486bc14ef31c192e8ef76937c1a10d4aadd04350207a8b2adf2a920b33fde7f610b781f608b17b55612fed543e39dcd31f5d66fa61b9ca974dd5d763110fd89ee43408ce8861db5e8d7f8aca07f3a4a578bb3279e2bfc9aae87866090bbd968195680c8cdcb95b1ff178a7da0123079b7b1709f7596b1a1c8546d6c800bb87518039adf997265d040ec3dfffc6a4e28262e04e70015220c6431c282af8bcb677912cdc71c0b6c567228b31ba2acad6c8968a7e8b52421d97bf05b073e3d8d06f7ec4905a3b01279628e154578624978f93f36be34d91caae7cf7cfebc864aea2c928b70aedd118c427371e5ff1974610f825af041322fc7af1f4d8a00f4817cbdb22bdc3fcbdc801c0653a976a077e5d4d01dcb43d1ac83c4a482bb1395fc30346adc63859ac69b508aaf4ee71aa781efb81ab667dda56d93474efe74fa1eecd5e35b191b4b2859182e4295e9eea669893cfcbbf8037a8b7223e0d0440e03ed9019ddc4c54d3d7c88279502f3151ce68faa15c4e9598f5169b73efb71eff2560b9c259a6d3d9d8faf264533f3ee4c362377988a822138e34bf019d60b5d1f86288c100dc0ede14b69ecee559db30d331294e8d1a6bca06a6cc8c458ef53b887fd852bb7bac122a1f084836bdca7776b9262a6e07aec7893bb3aacd5e613ad6046e55ae3274463b7bb782a64700df89cb8975f49bbf67a09de2057a291d0fbb8aeb3259a1242972c884a953fbb9ddcc44e8b3d85fe31325844b66f66e837139dc176d11b8f000e7b50a2059933c549cbc8192668f9b606596a61ed2bb6e3513f3ed79cd51aad0d6daa302548143773d63a8844c906ae21c628bef337e2461d6d7906e9674ecf603d80bd6eae96090421b9df207c2924b8ec0672d3c9b4a2cf684b54b942e7326dcf32c04fe0076a2a9bb7bf3aab6d9763877ab45a3fc0ea13ea5fcb3ecf6346b8efa2572b739cb42aa9b82c24a3968b5c8dab346bfd3fff4f75e0c4d4730a42be1bf6e92958fecc3b5ffc5bf4eef6ca60f783ecb7e8b5e5c25e28a85f03f3a602e6ab85162220e6ae7d3e020deb6042d049aac57ac029a8dd78770a263082fe0ba4f34762593708f26f931559ea4f5ed9d13d2780d6870a8df6b473f41299679b7015b605151712f05c91be71cf3b20234b1fdc7478b7011c4850545dc128316ee4424cd8ff2d0320e0e0d6e37613892c76eecfe3407bdd0bdf37176ea138c1f2f066fb336a74bc93eb8c9dbacede1bc3aebddc325056a646d47966aa24011cc5ae7550e62801acf17a1bef78209d746f3db3dee45204486a24f94dc1295ea8601c21fc293a9255955fedd94f58f03a231a0bc290c9ab800563a5c00dd8b36ed37d82a0a2dc3ed4403461d52371bea9f904ad2cadf447d7ea6626fcf8127c6c69ac329c3a7324240dc3aabb5ff0719048d19520818454c7c1ec5cc6676bf994312bd44eae51c6d2ef3f854df74f030e5ef5a6f2e8704504aabd4e219116aed9087983f4e5e9a1066019b627f75d4cff7796ca3d889593ea5c00d8575aaf3c433495c9e6225ce40fe9861276f4097ee8197bb23a254a2c883e2763c0e568ff52de1f7d35f53ec781dea7f16367d9a59567bb23931f168f8812f7f9bd1f5338c9eb30477a9363ef7dc63588aae57eb5c86a46088bc4604b2ff744e3b2b528eb40428a8008d7ad13ca95e91b642968fb84a66d0b69c0a94ffa993fd11302a348d9a1af42d773b190062c34d562a932f8667fcff9806700819a88878609f2bc8f9feb23c4e3c82b781f274b94e112bfe4ac2ef47a5746dc79d8a14a61f7cbb070811dc9e5dd70e103cff34d4815a27c168f490761fc046e4ddad0d4b7d6ecc8918eb36ddc63adcd5804d3d47b2877c2ef3ff678031d5bd6e4591fbfbd15b01d233f8bb37c97dd371f62b19e98455fd3fa83e8fec55350b163ee6fbc5d9c0685e9b341750d678b392d7c347b93db4819ccf7895e78679d0d67c72de2cb56ce7444f81e327d942c3495ca7f7be0b51d3643e4deb3f69019daadb5520a36557fbb60bdb6bd22974323195a6d927ea59684dfd0756abc720a2eefee1a13c5215fbf71d0e771ebd7a852572fef42af3e6cb91cfe381f5618b6a3faeea6b11f3a06f7150c806f59aa89efa4bcb920c41e7c0c32c866a01aef77315167460904ceb4c11e9f523de9b7086dd9242e53361136b81a3411deecc0ce477f22e931dde90bceca0a76f3eca71ca9b7b3da889ef91ed338be34c8cf5d0213332f38146e97acb9c1178fc97aa9c7dae414b4d6d4ee0d58c9bc6fd9b25d38ab922c8b1583d7f1b3961e0418c02dbae3160bd5aaf165b3c550afbe7fb68fdb91a7da91d6b703a2fca751744c0d61587d767ed6f9670928ef00804a3f1bfaab97f9163c96b085e32202b455d54723abf02f7ae1b0ffa978672e8808ec88272c191cd637c9e1f52fc5691716faeac0f1059468db5f92b2edf7998e2cb01742936e8350ca5fbdeb23f7e018445dc84c844c7d4c35f7afb33c6676fbe01d527372da5386b1803648b2d3980ede5486106b4ff41c889d11c48e304fb745f2b06e975da9c0204d1bbac657959913ff693a4d1111d4873ec1096a1eb486443974184d155801adbc754dabfdffbbd63a4b9ef968fe773fbcdb5fbf93aa713ad25f7f00700b46a69c54b761f635b92e2165ec38dd21b6e5b1461bf8d6ad1ce40fdff292a113b3d2035fa9f2f795499376839d360bd3bfe3544501a878bbcca5bb1b5719594362854ae1043708d51ffe2854f7cf1bbea2836a725d1ba10157d1adcf6e74ea4a6d09f8d369c059a757f4711f3e2377fef7c30a7cde57551c610d94ae8027a89a9ba9dcce7eec66f7c22bf9eea0dfece5149df76df4d5b984a5a6fd1c781956b363bf165159e042442233045d204ca9e28db803d26041b78c5c4bf344ac616a255497cc2f8513415683b07132f9bad7ee8263d34c74232a8b2d2b8522734d82a9d8a1b7d26a782fbf0282180d1f7ce2bcc7470151789eb4efd836b56ad87b65bbdd41f14cb5eec2e9656235869e4d2e2221df28c546a415a892b0f15260eaa347b5d24f4ccdca4112341518163057012396916191e2bc8f8f5ac18254b88491d06bbe9d009ec3ff936f3e9e1d1018e68891472c8dffb688995e819bea7289d23de988cbf1cae5091b58873b2d19c190e3ab0e1d2ac8236810776865ccf9b4677d903eadb20b44bba2b936f2e20e66ed6adfa588dcac988bef8abe7d3017e8c446bf45c616a2b530d72ef854d3cdbfa7652eb7a3c69c6fcf452fd3d61dcdc201ed43329df1bf81bf4da50d5a36fde4c259dad470a9a17aa474337745d79b5cb868be06ea84ec9756296ef9a08cdd53ed1abec5632e225c6620c9fec008987a995914a3459375988a109e8ebec7b4212b22cbc13da46749998b2605327c8149b66d324b7fec4623c23580adededfd78c4d853da902e31c7b707d39954295a193979457f73eddca2fc80b9fa420760d74841a7b8739b06f6806ffb1651f883a5ced56174e7243dcde3fa49db0284079c4bf5c4063c08869effab5a399bc9c965a5f41d9c7663616d22f9c906daf07017f95c1e655704bd71fb221606f75554a0ab3f92d226c90d755090f5dccb0696770fb83484c50e9a4e53903c805c6f9391c77cbaa114167196dae4d055c2637f4947951f2818dab4552b6f435e173d33bc2d77ad4be742c4fc8769a1df0c465573c3f505bc4c865986327d53183d7c583b066b4997af5671464fadcc4db3719ec9c75071a45cd314768c27595414394e61f1b164902d68065d10509c45cc3ced8f1c0a21cf39c4d6b01f0c174507484a561c1f6125dae5a222aab146c4470e4158e8e82e9d824f968b3b651db00849931e7bc95d21bac389a64cc5fb32be5df655c2d2d539aad6941d792e5c63babdfbe311667ec888284b43486035679d8fb61f051e56067cd5b05991951f546018ec02af2ca8fec28e4f962f86252af655e81b79d8c7d90e23e1da36c49ceff4a18efd368cd4d0f0055ad508db57d35b21a75f1d6d4742cb99adeac6858cf6a383c9e4235151f5765f290662a7eb3fbce6e24b6497039f681b1731f455dd9d21fb4dfad9b6b4f66f787ac3322a692523aff8adeedc8bdf6b6344952da8994da811dd1e63939a2340d4163cfb5beeecb6d5a9f990acf2f577e30ba5bc5455df1b58ca8d59c97a0a68a9eee5acd5f2de6596670d775d27823878262cc435c79f37ecb73dfa0cf871b7d336403505fce2646d0b9582e097846a228771ecc51bca2bf409e0bfd23f0833144f922a431b038b44a77754e1ed418bc2ea57b67cdd65ee65503af427ba7295e64954b50b70fa64100b56ee1a58ae58cedbae2f53c56ea2645deec6d5a054068325001e5bc4d63863ad33956ecf062bcec6297492f6dad9fca2b4e181e4c14ad00d6f66f8517fd392b98519c48d5696ad190966f4fc6d7676cc3a4c28d2876deeaff049cf76526768f634a2a00a7cdd3b1b695a8837c4463c880b024b9f07f06b705c608e90144f5530bfa50bdff13e11cce181ae16b94d52228d5048f36117ba50ffd77a74ba0f9c23aa004c16b7eed7039ecfc3e548dbd842d97a4d324a3f52ee9a4618e86c676fbe2e8ab7050a7440367ba3453ef83c065aadb3f62474563533604858e83cb53746e8e3c4eafc3adaf2c3ef44d1f74ba98fd69252a80d147f04839d16dcc9428c5da94837e21a2980e67c40c0e589e6c21507a49341b3414aac311e4d4d2b5606d6e8adecaeeac9417d9556b19f49113520476e559b186cfb04b2cfb826468c7d6e7673ee641b6bd345477179f783b408c187025ae476151e1151cda623bf008292f02302ba3cfdfb7f47ba6853e565e49228e777c242c94652f6d55b210c0cafd44a06e49f2ca8344dd255f1aef8fc57e2311b601bd34ceed2b384139f39b059c3a110e1f1dec6fd04c24735588d341a9877704e86e432172ee5ce608d3345e6d73eaa3a0c5042f18d2e861483f553f136fa60b7b33ea65c47f1969fccc22cb015f65c67961c6683239ae35349a6983e9b927abef5cec98b8fcdb23e5ee7bfff7d4a38c372a454060019016ccf21426f9dcf46d66d92125589f09a223ff75d0f8efe96592a57391037b2f5669fc1c705b67576dcd4062092825b0a945adf80fc3fb30d750ef72a9a225fe952b1540fa5ebf471b37925d79caf8a3a2922be7f5848c15501e0b35f7e5cdeb689ce44c16972b77273054be68b3a175a1e2aa75537a70795594e003f0f5ec90903062fb7785bf5686174456158fde42008b82f20a271589aad2d49089e62138f7078257955c1ba71eb62c23c2a21809e3b76a9a5a9495298caae127ba0da29d5350a44c2a1e46bba35160bd78758fded94facff417fd69c4aa556e0cbbc8696d8e1c1dde9a30183beb5147321be0ddc4ff7aae42fcf686d21507e77182ca1d932f44a5da9a3f31c851dc22f3531313ce1150a9af534c29c052427d035c3b9f0f23f88b7e22dcaa989aeb070ac2a491085e2d15b4afbe0d1982256ca3df802d2beb158b386213b08aa1a14bbe95a691911d79d9bb48ce5a076061db7328f7e10537e929fb56cb539e874a2cf9ec6f3caa4949eefbb5b9bdd25f6425d9aa506493315d36ce2c2c92673ddfa79e9d01f0555cef438d7406b74ca2eb52a8660f5d0781ac6abc8ebbaae53a1815fd63d3b43b13db55169569bf1aa1fcbc892a99e58ba75ab7f009ba4badb48e804a124051a94088a3e06680cea29c7c5080cde0ef765cfed885efe2a4c0dc472f710f77af5d19a49aee214bae9ed31bbaf365a39042321681b91970981e30c95b520e0b94473b51c12bdc1a990296ecbc320b714a541ffd83a98197fe9e68c4d6b3581ac14d403d113a22ef7a5494f1586df398e692876890b5bb9c3b17929fb4c702d8ae833663d892c63cca7c51e3355d048e4064bc2fb021ab8ff9957e2a6878da772753f927d9a7d25119a5ef96446955813562950b3c578a313259e625139ebe5e5cc68b194a1b5b7d6da30db673296d45c58dfdcd5c8eefd172780254e1533a5fe7764bf2dfed0c8b2e11efc0f3c6da802c06d9f4e21962d15fe33d97418b684dab8cdc79a2c29678379d3ba948e42a33dfcb274066545c066b35983a696dc8370fed42c5ba2a5ecd615e983f1f8d2d19736d35d421b998ab8ab7fb054cc464ce962b9ba8c750749bb661c366489ced6376f082e56ddd736116d78a975254299e0d40b721ab92a973f8f41670f44d902e3b10d0b5986163e5cbf16fd2920ef44d287bfde7807f0f9dea5034c4ad05584194825c4891616cce40f0ce22b6b16edfc1bde3cec399f7f64e9e0e5b39b4a3a587d9a85c53526635c71f41943281fb6f71dfec0d6c1ea13104830a9749d645115ff2f7ef2fb312f108a7e2525e977636118bb7e240cbc6985f130ecf88d97e9ce9c656d0e3b51f0a60455d6cf439c0606c30af797c7b390b7d1bdc5d9f74d1d53dc0e043fc65816c95b6635493c39e83da146654e8ef1753881bf7991f66527f2bdb50dfe048575a3e5418ad44dcf312d8cc81548e1919e6367cea6a05c848ef8cca9bbe44fbd800aae9f9d7ad52bbfb5f831657c439ead97930e80ca2238f67c5a6810919fd4b48c6f48f15251b1d28f9cda343c4ba338e1f9ff879a4f2936bf34bab3885512f0976f5053796446479aaeb6ad1a01eb8f4c4bd9842ef50b5be9cbfbc987b9792f54c453bd0be8be803263b652eaf3453ecd61dfb5865fd292efe3996622bf61afebd5d842992c1fe55f6f015e8ae245b3b6db0e9ded73e478adb3bd578b9d8e528529abb45743324f4ab6e1cd572eaebdd3378fb9a5159357781bf2d30b667fc3437df7ce32c751edfe7a30f168b70ea070adf99e3e5d1893697d731e4cae45d8367dfb767c4f5943f5289b3d8ebbf59e65c30c8f16a40ec184ff59611ae08c863b0018d7c235a6e725912b16de9cfd4319cce60a5a1831e6a0ae220cd3e181bb61415212f185cc9bb2466cfc8f37e9e11ddc779156fb17f9f01e9a3233cac22869c87e4b8fddbcd3765806563012c7c5771b5e020bc53f00d6b12f665288c68c9a15824d13a260c39968112a31412bde197d19b2f4e5928196ca5b19884c2c82d044fe84af36377a467a83a7c95bba25b7e33c06eac5b4beb31b6efc40d891ec3ed53ab52a308792cee809b7ec8ad574b5b411d9b85c16a7215f5a8d8d687495a1de032faabe474beb32310fad0c369a8812f6e148411a3f172af7239cd41d465937d1ce1d722c7cccde9aff23e3b19905e7f9ada5c1cf71338a41dc6f04b9b55ac1d276790f8f7a5279368a9a6d49fe45bf9b31b8eec4f91ff8d901738667b0da0219926c123dc7219dc0c99ac3d0f426e17b582b55b20a74060e483baf8c9f23384128f894f71dd2efe0c42ff330aaf5d9bb29d9c86672008e7c3210e48e7a5720f328131d76be94b64d97774583629144dc27f12160176f823dfd8ee1aa2458196bebfbb27c0e2da8f6b60259061b7778759fc68c7b8afd801078c0a87e6d1ee5504ca1416d5c419995ae97cf07bea2bbac2737521d0726a595ae01576fe08acd8bbb540975d99c89fc7ff9a8079b9a1592252548e72625e0cd7b487dbd4d6da79da6545f1b54c5d8fa102935a89d291054c477d34d4acc1ea1092b845b173848a2349233af0cd65441bf3cb3384600e69b0163ec0ac45aa3b143a97a2f4190466bd53a9269ce4e04935db5abacbed53645cbd6ab786658e0f573476c36f2e4c1f78d91992eb87b41f47758e112acf97aab90452ef5e3f3acb6de6214af005558c4a2b6049d203ff827c18709bd81b5560bb7d26674c665d46ff69436a36027723e412a49c8fbf94698d18a54066d024feb8852daa7837184d01ed678dbc7bfec8c444701c430ee63806e3c919dd035403221c0b9b186cd28dc65687e4ece22cca985d61bf7bcc289c693f94b0cc240dfb1ca1be013c099a927b2c081c4faad71d26076c162eb4c73838ca2cef001e499be0d2f560fa7059b2c8ca43b7b28d7fc920031596eceae72b96b6416c8cb1fe6ce2020623b58ce1e8a46864e9843521f8565a3887d6b8c21b10df3245509c4669ce8012e774e67b1ffe8bff87fe592b90cd0267275601b217d387dc8f613feddea568bf91ed2ae150bbbd9d3290dcfe6b251065a994e4a6ef5562ab7cd8dcbd01b05b9a77c423f41a158a424060c7acd85b10523e8025fbbb4e9b8c88d579a591bf42d0ab867240f709b1d3de327bd260725f3ee6f1988c86e751c4b620fde917b7d396bc8bb7929432fe440feaeded3cf20355b4e954571f339f6aea205fd418b3c038ee698b6a9f6b3fd85ffec49dd29384f2ade70641ca424c6351a1001ecd582461d9ff6a82eacbd0abb8fa6ad83ffb3809a058fbeecb89ef813ff8d0b441531a9a8671c95e5607076d0c4f72cc20f1fbe9ac5fcb1143500426fdc47de244b6fb41ed1f32685258800fccf61e79f5e71fdbe1bb863713204f748a1e41075fd754a52ad650bab8181541cdd198c74c291247c58905d18f1c33111bdfc272acc27380078012e32413507073c1e72ecb793c5daf94ded1f25faf45f1446dda9e00fca36fd171a61a64535c410c1c88d9d31007bc6a55230f96f085c9aabdbb482c55f571d7c1a5056487bcf27436e0426c7ce522e512a23d13ee25ba0d96a6997f0af2a7c390bb2ccf8bb51b4b2d808499212fcaf19b1da4735267f68e8b6981c20bb24f090286657c18eefdb119f774ef5fd0f41011ea9fa5143f5e526286272e2b843c6137702022dd9d3959f080d3e61918be506c93725f815926b587414cd6f15510bd62265cd7a2b20e1dc94d387fdcecc6d9307f39de4a90eab64fa08ecf8a6cae46bacb5e92205156bc192e1eaceff5566fadb7a9939371dec31d14235a7c6c669b9d01fc5e76260a55f0f483b292cbbbbae30ed17f158eb3db0380c35917ad4a6acff8eb795f8660d5683d79ca1f0db8e94b9c0894817403b416d04445b12c7a2a44ceb55a8708426149470a18e57ed8ff697fae4e6fc0a12fba63b2ae49bffe08a714dab9e51e23db0da52679042c9dc4ab8a09b8e695c921d6be83924aef06f7ed0cede11b45cd0e429e1265a7e70b0d1540ed43234e59e636de854de45001fa9d238c27e5e3cb7d772698fbefc3e00838421e36e475c7adbe1cba3538019600a5d04cfbaa90f79258e19d696646db4fc433d4552d39488b74edb593e678eed8d032731a6519b52a3e738a40916a7be3a05a26f697f8a0515a6a5a031e258de5f0a22ae7d8db0552413f42065823c4120a586087d739af8d2a3ce2cfed5b60d562969e21818b36b7a353e09612dd611a0205d9dda8737464196adda2a5adf12391125f3c6e904060b89e96727dfc3b8137e02ce6f1f7e898b6a3a821598d0e026e0f24fca2c993323bdaad54ae9988186a927cbc60d98140e076d6bf55e1244bda235d1fa977fb9d9a16792103fa787d9eac361a05e04f0882fc46198e8288a75e149ab04742f3210a631888a1b6b410177926076faf545c61ed6fb183bbd68c0dbb532dd8983da90c6aa5a97a5bc69ff05de17b42919ec892824dd9694fe1ee1852dea8829ab129a70b83d3c27f61cbe4075ebfd40ab10f3f4bb0114f3be63af1db0cf4a3d5ad9ccfb5f5619c9fea471db1df556b22591c37277bd4b97f9ec45af8003c8a040dd3be841e940cac49d56685659aec04689371cfbc71b5fbfd578fc63480e2351fabd0caf6e4f1dca6e05fb51cb92acc93feb72db33b9c5ca748b08d408f953c4722d5b449f95b030136f9f597325e2c370ee124786495187c1cf1a384fa3079c6e62277b10b26fd41956a04d1c81b7a6c80dad3c5d2ceadb9effdc8b2fb1fa6344d76a591eacb247d47464da896cbfc0fe7d430a1567ec014d6148aefe56433f2818db9e69a13ba802761554422efad7c78980c07c2669fc15df1627104d238db4ece8898f4cfe64e5f566a1d3f39729a712d57ea1f19b8d2705fae75889c9f7517781ccd727b0756ac62fb727850f82f1dec05227ecace3a2bee13cc07bc65aee94ed94142325ae804d5f75d6377fb74972d1b8a99a07f53fd613087e1e355f250883f669486c0d52764dbcf06e7636153b3696f4f19e5519eb54dfbb6d321512376f3019695d9bbf3711953f8943efa1c5c40d6301aa1487f08b7ceb13b9029b8f2bee71659c210fa8ed81e3e73e710bfb47257ed4b0abec33e1f7b46dbed7691c984e1826cff719c6de76e9f8de8acb3f1a74e465e4793dded2b41a85cd77b1b274581e87f1427de9626c57269541c6c8ecd5f8cb44f81cd51086bade2eb04733da88a6f8fda5149374a42ab12ba477c0a63c71c948c99dd362925bdf76a3a33b5a64bcef30878919d37daaf154f4a86ac506e9528f2cd9938ae52356143078a96299e3bd075cefa91edccce56dd0001ff758f72367bcdf043d91052b8e416b7c8e4e06aa350a3ac59802943987729de928cf783779fe6b24e437dff0faa682b4f61bbcd191a02395f0a77fe9c11fa4952f098de1485f3dc01231e3827d26f978ce46111ff82c97d8246dfc24d62ca9c46251c277b226fb58a7c7bd146fc0fc7a8b0094bed1b3bb992fa16d37b4228c5278632738952e06f4f4e5c877699648b1ad71007e028beb0ef151eedcd45287acc10f9c94d22f07c25d7a606070c1adb99428e3bd3eff590c1f794a1d100c8959ec5f7c3f5429f92dc19b481ca29e880691d2a21a7277b220a0fa65fe89d582a9a8cc32bba46a2bcbea163c1235bf5a9a016d0314d4e4f377dd2e7238b15adcf1399026a18b3be0aaf94e7b6070e6ff1099ef1929cdba432f453c74261fd656977924819339f8a86c74f051d9db9308dbbec692bce136ba6bd0d0bf341ac4bd7bc870e5cb9605e4017e8b7ad6a1f7d6dfa847ebde1d2f07fe5dbabb11aaa317518f98953e6a350bf6a89d35acdef21ea56cac5218d2aaa6dd5b4ec64777c0690d0aa0ee2ef1c2a400527bf5997fb4b43e010fa93a4179c80b7ebe57bae54e22b32fdfab46b71b362b2dbf9330fcba21e7ed1d072cfd5cd314a400f98d325fcba886fb9ea8b984ec8d1b0aa46c0950ebf86da6b8d3da03002f9a83fa0d6f2185ea5f9dce7279574621b3c8c3cbdfd54aace8e3c016e12be56d12eab8df9c7551838eb3a24e5a9395e6de422f26b782f92f3307681b81c83594343188517a758733497f65331935f100bb3881acc9ae76ce6439484ae016947849975f7dde2589559e40df9da949e85d45505734f653a916fa8f6c5ee596b5f794b928daaf480aba7e59c1c9b7fbe9293641d049ec0acb9c83c792e277643f43e6c534ece417f7040facb501c300df889c8611bdf3002dbd0034e785007e2321b9a44fd155132c5549df97649b91f9c60347cd6cffd342fcada5a3ebce1bad78df425c55c602852a03687f783815e71baeb99ec255352c25784fc71e91c002de93c30b2b9f21783f589d97907c5724c479b26c52848c6e616566b6a9e3ad797ffe19366294fa6b2a9b12202010ff929b3621508716a9bfc2254f7302bb3c81728dcbafba845047ccc5dd2f57762ba1014b833f6b3b261ff389b6fe03bc5a2e22b01f599e4bd498300895a8a3e4cbc99a61e16124613ad1b82767dd950d9bedf479752ebdaa26d5786c2539ad7ca49bc0c2d23a8d5702aaa0a72dfd153070a98ce5ce61053c3b495b35caa0e9f0855c78021a49e7cc4fb5de3257e8f5f58c9624ade09a971395ad908b78da936e0f9aeac2e38025b62e2e4b9daf7fcadc28a681b6c57b23b37246f4518a2afbe41239d48b411444bdcf5f790d7d902a990d92ac000931ac2dc6095675e9fea0c5128d2ab24a8357aec36c3ff30efa775e33a8b0f3d4f53222ef155e7d1c19d24a951dc0fc5a11738afe0d732c5337611aef73d28c8b89703415396b3ba3590d47942f2fc46bcd33ef3ce269a97a88b6837b1ff3bf01cf29acc3f2c6dd572e5437cf6aaa41d1f36064bd2e1dd7189e4049cf8c9ccfc067361acd420fba3dc650e577d28ff1d78e91a28d75ffa53fbe15ae91faa5ed0be0be3a24cb876ed38cbe3589a413df306661dd61b11b88bdd50947a8d96eb9a86fc595bbb5fc25fd46b880ad6d54bef0015156e2eb3dfaa555bdddf7da1eee05fdf7473b6385cd57c854dbcc5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
