<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d930c198e6757896fce2289b16b6f98683bead26631b37c6866bde7ed121d6fda363ddfb725a90c26f922dc91a2b4264823f342df531729b7f43fd3cd35813229ddb93ae0d00b168cffa7b357d69711b8dd4951b79f099f222c7106f1d96b585d0b0722f82965761a43fdf580c92bf9f7997f5b87be38a372c7195b34745a69b771d9ece2bd1e1448dd7b8d75ab841edb768cf64721d154b3b0a523606acffebabd35a2867240f4677ba1c563a134998966373fb9dcc5796b075e75559b1640aaab4c424349e92c6a1295deff9a4d06fc9416f34ba83f07aae3dbf4cb2a8526189c8c61dd5165b51107629d8c05f0a1da34d7d50820ad6ce647d92998727ee1aef71077cfc1b1771000d4cf9b046440d170473e171d75ad77a27f5aa11438cedc0f0c60b536cd205414c1796cd85a44c554750abadf16865e0f505d4a6a8955edb6ea10764583f21f48f74d35af1d1e978e697dcc66353319edfefadc9b5a4737122e5213e0bd2c732caf5617e1f13747edfd75deda4351da37ebf235e3cccf0a681495a10bdda96a11c499c1baa3cbf4098a937efbb828750d5879e361a17d776f38e590acf8c8db57ac596dc44323aa85c59acc861f136842c90d32625eb0c783b809e871cba7ad6dc68da7eb145103a36e67931725e5d4da4b1f77c5608429acfb2bdcd88a3f0b3b8030d837640bbf7197c0eecf6abc903b5e29996b3fb74ab926f468b7b6b0cfd35bfaeeda19b8954dbeeab7834f1c4c0e44b611f631263d2ec40bd2a1d172cfee2892bfe170c479033efb58a37eb5f9c9864cc8ae7409a8775b24554b6ed0e995cdf502f5d7f247a8dd0090c9c2345da9f76f7ad79af591fcc02c727b104194a9a4e41a3b46163d968feb75371145cd98c2ef2365b7617009aa9660b580743219b4ed7de48bef930483c9ae0126968c48e26b3323d6748aa2bf309f2858e47faf3963898848742789cf6febdd50cc52ca3821904a4657c2261c66193f59f01aefc99c62e3b7d615f4fa3596ced9f527e35225ee736a0a6b020283050a0344ceef7d0fd38401977329a1e8e416fffbd42d5c8c2324edf885d8e1071b97566cf8a731365c73ffda276eb031d61f37cce3a871c6a553d50d0599cfe099976190313c31c294d3ba545478b940b923ded3537fb7b8492cde8bbf4145fe3258e1ecd6d311c13cdf07e1c2cefaaeade8864ad35b66a49e6b17c6a4d577a5d15a021904da615ec19b1c53f8f13c489475f282b2f9515d10ecb1a5fc30f26e412e5500cdf5eb361576a5574888ef50b46fa009283435fa68cef22e94ab14fcccb5e694f59351d166b9834b988425d95b33a85f8f27705c5195e5c09b0980f210b5ea5177575868865933d8128c8c95fce7921ad0876c5bc1d78d9dade19333d88a8c7835b2b8968cc8f0a5c1a59fa34c86014beb3d22d2943c3435ddac9fc2a17339f02e58b6451303a7c5c3794f3b193ad9095104aebecfc20fbeb5be45d9153b5c54fa4b09c171a8a8608db9a7be374c7ff6bdebd51e58e40cf641c7199953587814051684f187855df3ff397b4962ac6cd6f3a86e37b57b4c58a07f29ddce70484ffc8816b4d69af68c7aed453efc93524a69d41c20a6aaaa981cd9342717891e8394a59ac16f936cbab001977c7eaf40c4e453651bb8fc2d3413b534d2393b9ce723cc1d727fba72bded0bd5ba0bf78d22e28f06b863add0f4c0dbc065a9e28e1c6456b312f9d09c6f032de12504ca1cef54890c2b7828a2a6f3ee3ebe30bcb41d1b21646bd2c2221a92626079c130375c79d86ab8db9406bc167e710be9df07bb850c1fc05cc1094d292150875581425b1792ccdf17c6b3e9581bedc9b09ea379fcc39accf738411e915e0cb779db58a55b629129df515ad130efab32a99efe883cacfd75d77b2f62b7c5df82793d67fffd99be89e5b5a02c01384b136c0b75b74da6d99e8cfd07532f6fc66f2f5a7efc052e1eb2e16a99598d5ac4ca316fd51a39664de61e28d3ee4fbb035847286319b0d016667fca91c4df3ca699a1cac3249078eca91835b428797c4941069797ccb02cf13c4ea1087facb0824b61b8ce5c87072d26cfc7e9e22a31f941b19338916db9417c3daf6958b043f800302edef5dcd39f6c5da1056fc12e2d3746afcf860dc904d3608b90ee5c513a1443c0489e45fb5c2b633ea11945a21a9860ec493e3d503344ec6311692cbb63bdad3f249901e545111b4481ecb13ed1e194db6c9d58e6055a697893563989efc8b8d8b067433940a922127d65cfbd87adb18c7b769633e048830e8e23fedad5b43e2195a6434e9690f5e6496d32c2b555585945ee2936ea7ce126d1f0b534ac7e678d3c04f5ab9b75bb84337268430da1cd9fd1c39b20ab44eed5199b1b1da4615279822d27f46c460a1687738262aae0c92e7bfd0b20f5315006081862c886ccdb207794524b6291238d85d476d68642c041d0ca71a99bacdb58945968332822dc6ce2b8dea70178b8dd6eec975206ab628d99fab7aeea98952aa7fe38eeab6983c50dbe8cc60fdf756fabe2b88e68be88a07b2e9dbf9eeb698c946f66ef5b3a6ee7028f4c63657556b184ed15c101e750e63d04508e756bca3ed0e3120a6567b52a6daca6980608a75891fe7c5cb76ec5829faabc56f7f82c1ca42e7eba43c86427292928a129eaf2cda1bbfee94310064be3d794e7a92ea59ff807fa5e08a6996fd8bff979ff3b871cab944959e20935b23929d59feb91d70480e8a0c312751f53843108012f64495f647414ed907302fc709cfa1ea92d2b30ff6a89743273f0864f43b3f9c293941075c53cfc7b77b27996429d90417bf116cac3a6a1af82ff873546d62aacfcca71978a29a2ed61c4afced438833827a92cb33952e55ec51101a9a2399d5e1a69458c8f769e0efefb3dad9e37e36a839450fa8a4ef2cb4fa7486c3fddde5d3b522085354f5a54858d06a05d56bf70be3e3d76c45219bacbb71bfa8f14c7add997654e7543f9ef052da23a8a67fa662f4c25dd07b1148e8da12bed69e5860276277c85371196a86d3497de602b3e3f31cb1c21eb009b883881b225b8ddfd408b72e5af8c8516e3117dc4a2d866dd8fcf5d4bce47c4927ee3b3d28386e1506e0fed116b512f67f26a6b2568c7c8f455c451cb2d223b19c386b2054d8a26904ccc18353992ad20b88a5241932a880f53c25e1e6bfd4db4abd33619068eee737ebc9abbdcb7dd311fcc71dbbcd6cd6dc5fcf0448316f5e34da601e3ccf472052dd9d94f5cf58e41b2c756d1e51f5749102ac8de95b971fa51acaac4a6c35982c172149c4f4d3b7d93b4a4101c7bb00d472b555388581cca8c6b4c0dfc713190571bead4012573745152bb493f596c53561ed7d1a6baf15c660b2c233c0acc69639f7156e9d114bc6d01338f4506b0daa508adde3cec9fc3c8940cbe8955e53d5eb6a0f144c50633efef03b039089bbb5d503b438759e0e441502fb5e521969a0b78810278664fa80de0c90509c09e17a6393bc8bc35e722a3397c9c6299b3d9ea20995deaf29d6661792a4ff88a67f2a89474bee618a3f440507d12a7408997138676b9bb4dc39a7958cd9344b60fe8bc78ff73297ac06190dce12ae24b8da4dd8918159a312d7aaea463449d0df14b971d9fcc9c4e95cd3e3ef06bbdbfe4d945199c61501a5d6c39371553145068533fffd3ce7d434fb6b2ef3245dfa0ab5d1106fa6b20985ae14663734acdc39009742f87fdfe89fb92886e06fadda56409450bbe32b0501c741a71baff679ad9dde8eb9178686e7e040243999ab3fb6b1ebc6afbe060ebb999ffb962239716269ca732ace6770019e4308a56d343dd64745f3a7c052b13e44a2c6670b6031a1c5d1eaa785f9dd615475f569d11ae88dfae085affccccee95e9f928286faff09d8b59c51b6bedeffc6845ea9a80276652349fcab5c51d39f56d2c7e2fdec4f116f08ca3a964861a443a51c762ed9741d41ba731e9ea9a931de155e09b5fc629c1c5f4f9d8e3bcacc68319a13b238088f2c57b1c1d883fa1a6dc1844471965a751bba57b35e3ecb21bce9b961813106c8dd42c2938d71d55e17b541dd56ae78b886ee9c7f4d81a58489d3e85e49f5eec063e73048a58e43e381a083b3982e8d52824f3a7fdb456cb64a45f475ced5d4493d9b22c324f5186528bb02ef148562ae5365de4deadb90f0f733fd6c56397ecb7c9da6b4b15dc25625c011e75f8d08ae77d0199df04e81a72cf128fbf58563b78e787c64afffebaf0309559e0bf82161ed7655663e50d6b903cd7a91a42a313126726c4413224fc2ebd965f9b003620f7f61db41bb96a3fa2e64dddfd23464c54dcb0a413883da347c9e01b3175de6a324e9fc1ab04912f312cb03ab1540fd768c4da075944c8efc88dcdad0ae0cec8631d57b499f0c4bc5bf63bafbe07a6d07527b62ba7ff9e28914ae5805ddab0664b33587e2763f9ac3557f807b9afc67e2062ac905907c0d955742a08edcce91210e27b6f19b959f25443a3723179ec965a17f2d4187f5e54f3df9136e6bdbfc636b5672d255391d17edc1c184c0ea71527d8306afdcecd607527dcc79dcb10dcc55e2e92928de4ac809535ab8fb4947f7d4b2dbadb6bc559a4126fa1467bda219a8c883513e8cf178a618402c0ca07c1b1d3eb000d3befbce1b0c50ebc0adeb0dc18a5f3be1fb725f91a5205533c85edeaffdd08cbf50b2409a9e778f1a0c925e7e3fafedbb3d6d661b5700d5d1f304b96d8c9134ec8ef2b8e1e9859e7f7b49a839456ceda390820745ce6dcd145a1e8e6f53a9d23f2d4694da870b9e4473e86a2a3f9fd1df18ca894e5cf9c734641aa18bfa2b2f0be4a84c5551b2a4270d778388088aac495160a9cec4bb616f8892b626d608a0633a59459d753812f9d943c76f896d3c110aaa70b50827c2e587ccc2585f1257fdea4407c0d55b6f443585b24d91b55431dfb72854a10d4ab57b170024a4533b83192d26e89a4033d703e9704548bd60c5cbea3040d9a15d9266091476694722f49f3c0cf14c77f8d0109256fbdc2d61705af7d750d2320cdcbb147971c1f33d9d35d49e1090ac8fbab9bece69f5dce9ab7d60d1df084f2e73b64702f45ef6ce7e0125e0043c35a81cda803fdbd98dc598e2173f3d71406b0f775c87005508abda2580984b8b31dd5fcc01a0e75247c181a82892c7b89ce1ca43ee9014ea3b936e06b50bd0a40959d5562852e13d26850e3128167e47b986afeef2ddbd12ff841ba23a3ebe14b10783fd6ef2229d3b1f42b572c3ab5c3be81575cd46c6af0a4104c37efb5ac31450caf17967f96f7739710d042dba50447bb2bfe71c976bacad0941cd1d1e60c7e736afe14e454d690bea421f00d8f2538ce8348c76d1ea31518a3d47f884bda592a63eddd7937c9ebe6cffbb9aaad9a2ecaf883c6d5c7098c8b593e5505f78e276204649009c19d1fc094721088ce61818d0ea265cce2f31166bd5a0fbf1d451d7da5e5a937c531bcf50e47c31c9690ab88cfb222d227c60352db2402afcdde0124141129dc949a1d8fb8254d676c7537063834205e4989d6259d2a9dfb487484d26f7b2c481b9decd6ad9d5274ea4f6bdf740b3e99497dfa897138908fe8568c260c49046626a1a4807669ae57d15a79a933de9cb43c47151c6f1c6ad70e212d84472dc331cd9823dd8e34deb8cfa8765c0c3cd6a8905030ee3de6ca9eac0fde07b062f1e1ea4930f6c8fde0a9532c3d1f549ee2147b56cd276a327362d568ff35a69ed5da895aaf101f664172249a74c9bdac217841d527d2bbc5a74ac9944f904ce66fe54ce329bb3671c3f68b0bafbb61312fc28d2beb2326c88d020cbb79702ad74e6f151e35cdcc3ffa8658a63e1373b1b799159d470116de8cfdfb71d66f7762d9f05f01526dde0c912ff9477ac1412e5d0f20f438adad6096a1d9f55a57893ca7e91de8731362ad74f5b36b56702e526da4bbfa7c79f4a3abbbaaba815fc9001256620e35a6d87739fe62df02233135c467e04531c423f93fb3c471a6c0296d92e40a3165950aabf711bc5521d867aa054843fc8a4127304cce14629a2a57487b67f697e665f6130af3dc67ecf3ee775770af08d47e0687028eb60b65e909dfc0d612b0e8166d5f8ebac610ba8ec1067af7abccd8a4bc6453a12859d21455dd49bee51d11197fc6a62269e72b23a2927e8acd355136aa6feed0d7bf55fd41599355713c604124917c51a66203ee8c981777a54ff68ba329356c87949f38cbaba46adbf13adf0a96067fa908f33ed923645502fefa8b3c6311b356621d854638c5f0c5701724c4f0ad6a290d140242d24228cc759f19a352097e903cd0b2c95cc78d9c5ad843280a98b47a1ceeb9abfb8e4f6aca3cfe39d9cc8f1dd139b9fc93446e2d76c1c2e4e528a8cafb2d9c79b4365131d285cd5f8c57ba93de1b7baa025bf6eddbd18af35832e19f1099d15ead551cae9cc382b42850a3ccb5fa7e8ef9256ff964b86fcf7a7492fcb0100e223fe630871629e1b9a2259ed57b4e33835188c45ae2cfc612726e8844dc395b6a2a4f45c4f42de22c37a2e3882ab9a1f7864587a58db4c7edaddd496974cf230b4960156f707f12e4a2472e594b531f637eee958a319a45e7b83727122a5ab56724dd6aa8bb31ba11b67503ff5df04561c6695b6565ad921295a387743c1550994b2719d8bf81928fa89a376dd5dda5b15abede0789262cb3fdec7272f7e8ac9e04cae33fc644a64ec038cf59e3c836386b4105fb8ab0d00dc8f215aecd5b8029349b53d0779064abe9897b485acde317b7f76651519c2569e8b386e7a82cae0f785d0dca068323a773142e96dc158db797fd3ffeb43d4f415bf7a1fa8b5e880cd9ac54cbcc2d4276750a32dd59a0445dd584e7298094a18ec328c388172cd8aa3ab2bc6f594e1e90607e0e72e1c3b65b7b566d4f1bf5cd36b9c20f8f0032ecd0194ccecb62dd4c195b906ce25e3166bd7cf92540848b2d9322bcaee4d1b4f9f319cb85e303e550298440a59ee6e71e6e5d722383c27fa236d1851366f2be264411a3e53c91c4e25a115e6aee5f56fd468af42869523942d2977775ce021b9cc41df20e007ca32c3d15e7429b9d0ebe5f123467cce3eddd0b168bb53f5a96fbb26401db3dedcf5f2c19e50bf7ac152f637ff150eec71f24426164c3d26577ec7976e46e286bf67afec9e0e22228d8ad0bd801cf0dcb1aab4dffc350620dff7e24e45e526356ac3cac0bfd7425078dbdff5717deff4d645af837cb2ba8de83f3280378e112cddaa78526b0c9aa36ef44aceac917868e8b88a3c9595b50895f52854f7cd6cb3d9a0546294975194419d343c73edec0881f4d047a3953d22929ebc3e52f1a9167f95bd0d58e75de0f693dee0c1ebecbadd4ddfc67d6667529ffa0ac3ed55f49b17cf617e91850ab78048ea0c3a4e6416b7a0c521012ac1a842eb927f466930421796a19adefe98e1426aad72ef83528799ed854ec718b4a53d57c0f8c35691efd084416a686fa0a50fc8026c6b451ef6717c84c63750c296d7955851fa5cd4fc6e25043391625db62d9d0d5c7dde3a45fa279205808c410dec9900a46bab62f9c2eabf1f7c5ca7db54c62936199d77fbc3651c8039c22c89d5397c21a7ff861f0e696211d4599f4ab5e40ba26d1b3c0f7fce7ea027a7182901c1b37811e3ddb9b5ac5e5ec2162ae34c1ddcf33ede1391232e3990aee47160c121dab0ba944324249b6797906e962736f197ae715b6a983d699c7d83f68b496f0330c60eace843d7cd0e4bcb824a890d4027f3c0d4b220752b7c39bd9b5104b14d9fb7fa960d89bd259322d1b19d85d8ce79b9a7a516499deee02c99e304fd10da09ecab3280f09137c2a90a15c137d30e91bbc4df2ceedce6c1b31bfdd6065897df17092fcc674b0451ccacf8de318cca52507f0f106e81ee3b06d9162d62fbefbfa3df4ebe98c047c37f94f4c5cd68f62a8f4ff56f8f8f6237b9ee1d2336f5df31d7a73627df1e4d5e4ae2dacd85960e573b0f808678fe2fafa70b952dafaccdea93e1c609668bc9e377379bb984c58d6cb45b54fb24042dd2f80a10fd2ce55f5935e82ab1ea8872f616a593d05ced64e320a63f4f8d0955f1b4566ec8c55b181837191b04f4302d2457cdeb8cdfedf16ce34a6f8cc28366b68f85dbd01d621a48bde06f6cebaa656a250d338b1f3b0f298c7984362c1ddd3b2c6422c7d290274566e69f1ffae2c167d2cc6db7cd3ffa492190b011d62a0f39dfcfe29217abc75c008325fecc233b945ca65520c3682677c37c0781067240d1ea7493bda2b1dc88c82c96fea12e988e2d5364c0809e2e925420b957e0dfbf5eca92687192d65977c164feccc33904d093c395f98a687c0bdd73f66b7761d4863fe7ff45da07e3e821b4a68ba63e8644c14c240450bf2f7eb947e553d3b43694c2612517a135aa4f9cb2dcdd88cb8934b9255075d1cf7d15de3fbaadb52245332ceb99e5e6b0a5515481ad4ed1e1cf940c2a9c242e4eb0f74968716d8e0d1b4f81adeed5de1e53fbeadc6a0629a14d9f832682677b0e2ca74ba3394f9b1e4a477916e6e8e2cca7ff57747663d7456c69dc0c5e8b4374f4327d916b52aa62485eec0b4536a9885f8cc8ae3415a5b9da579e7007c6387b0fc52287d6603db689ab7f9fe739b27ac22c5344964d6881dd4d4a50236b88949b8e7d6440845c0f5681d5af9915240294995aa71f93d4810711b0cae725a6d63135671b4782da125a9fce2f819d0725a16d21cde369e10081e49670bb9acb5c9e7908fb5c3ea2dbe65bff096e348b30c680c4dab758b37e55ec13d7714e3e1096c7b65892277d80afcd5f18954fece82528e4c8959a1a4f8190107b6831195c960e2f0ed2e9e82bd9e91bf5337c897d00ce97e387fe42745d47b4ae922990f9d317190940217091ace5ed3ad77a5116807888559bdad0c279562488a6f1a70bad9118b336544a1153e9270bf7f1cd27645f904110b323e5b017351714223973f2a83aba32841cb765c42eb76c971c7df567fb217625fafb55c460992aecce3fd86622306111b7ce77332dc0293cf93553140d628598e2682e5732ad542e22a1f3853089fc3f31b0c42cc915aeef0e620086429cd8d1216d1435a4dad3d007744e1db0aa026569230e8af1bf843174396b9af6c8d70e192f55163fcdf20e35619b7cd3449d0b7292f860d303943db8ee5605b01d2d2209acb2233fbf393923b801e11b1215c5c295d4b1f92b28ceab5f2d910fe45e713eafe06d117ac784ed69364bb4a77db2aab877089e776e2962b93d0776bb21bc480f16c92baf0c52567c1aa4db9f584b9ccfa0642db9285fcdda937c772d5772ef1393edf566948fb877e7b97cdab49cefb9d214a54bb7b26e3ff475707f7279b1c350ea80c7ce23a69703d5ace21b7b776e107deb6bda2bcbf96bf7ee6277e9852918ef429bd8ae8461f2584bf3d0e9bfa9d90148abcccbbd0dd265796c638473357ef06cbff59a09c63cc70520c039b6a8f86e498ed03f62ccd2accd57ef7c8eda314ca308a635568d4a03d7154100c363c153f191347ce997033bf68c4029089515f34e63963c6af97a2dadf1c16d2a1ab0fa262392fbc9033c7c566a618a65daba0e6df4686a63548eab12cc7674b8fb4050d5f4ebe77f46039d034cc44b332b15f585dcf20cc13fc7604e401254a81c22072a0956a93c24456246b354a56e4586bc5769ac603c53665ccff2bc25d061b667b4ffe86b6c37a4c0d6d0a332867d9bccab1dc452685f86f36e83af2b6f85aea6599c2a617050431f4b61d1d86cddc586c5206268e821e48d05ee8a864d2aad19cb28a588104c03a621a23baf8afec0815f214dad788424eebfa9822744d784ed4d1d3833a552e393803c32168cb9a9ab0991212650c3c978f430e2c962994cea63f4cf9133013acb0bc822371afec69cd8e4287cf7e6cc5d8b07005b2f8996c048e56ce402d08ae0509c0c456dc664ee9004469e39d8b6112dc3fea7e1712e27fc9aa388ea961b8b15e18fb30157886337202bb4d8d3452a6827bf29a5cd04c33e7ea358ff9ded7c6621f7c3e0eec282ca093e11fec02a54ae791a2fa59c37fcaada9a5be055e9e0600693f1903c55a6e5ee06dc4d179ba7b2bde1185615e188b2a2b99a13f0d882d3e6b816a6ce25b56819450d0cad6967dc88bb4e9bd3fb1c2cd1add4c21ea3cbcf121defb0babc173e623e842d8bb50e715664ed47793c5ab7e44fc156352f40ccffd9b4d3408a6e0c2455d956d90c338c0451896199e60f96b673e90e781c62d50539a2c194260f34a5f83e35311323b9326ca9e3255f748ef5e9b19c92f1a151e674616f45703da14968963ecac462de9cfa2304696c0831fb4cc542fdd82c962f5d1bb2b526f08175c877653fc0a3d55528989c6b86ccafb34cdea1b3e1d26d184784def3b4840b756b4b43f792c970e780b6192a4066c6b3e390c896db0ef895fe959e678334ae819f5aa98896da5a54ba9025d7f785a5a2d06acaef04d2e521cb2b7c4fe14e6512fbcfb14b310f98457f5f37a004a6ed2c18f5ddc51a26866e66f40bacf2f4ac61d62d54d105bbe7b6fc6ac946df139d9dc7d3867a87e1e7c36511fc1011909944424dd4844389eaaeec004fa4a16d209e8c481bb5bb96e6ac24360b90ab67f81aa83a7831ad4a3e0cc8ab2c03b27c4d2193df014bd6360ebe327330fb2e1df26c408364ea1ea9e779b26c995af55c24975d464d142a47b69cadd6717bfa3c02eed7aaa83a2d7f91c5a5c271a00bdcfbca4346e10aa416e79e7cb01bc45d1302afd8f75e7842ac3f7a402488c90f68947fabc2a07c42f9ee8bb72cd3fb34c9ead5204b64930e9e9eebe0fc869531c49eef3eae0b06277d4cbcd3ae73c917e169500ea1d812d205108d8e51010762be7bfe86d9df3ca36c3fe934855df3365ce3279706b6dca715129b4270032bbe7f93619d808787655368277e8527d8855760055b0d01080d026d414db50fb512b1dc71deb6ac24a5c461b2776acfcbbbd93257a48715f8109668cfb7ae7f6bc7f6ca875b44c671359b84c7d3b7f9278b0df6532f766c92278fb6d0e16adefb78344c571518b92aaeceafd1c0d1bf7407877e44ce22e901459bbf190d334a4e5cdedc9d3f91e0e5eb799abaf7fd3e5117460100155e32cdf1e7813e3973bda2def4987e05522b1eb339d54b74c27137e1f0a7b633e1a91ef2691520ed0cdb7bfa79078859627c56e810a4a139e16c7d2724ccc7fae661a1e9eb4170d8c456a6259c4ff1910871433893b943e94de43882825caa4165d6d48f14a8acf51d657e278dec3d21341d995b0e1efadaf95ed6a077a5a318b2dd654d94d05c8de572a5bf991535ace37cc21c1fb67fd31205201465f7b2dfdbe946910527e3773e67ba8b8b9d4d05bba9280fed933f0672fa783641ae5fcda7fd06968a916ed5cf9fce156d6c4d01c1c7883d20d3f2422f112790d6536c583b0443f804d984491324c95ec7aea3559b1b5900ca32bbe081182216bf05821390283e549f7b05f213d2e45913fe79fb3691b53436aa057356f7511c6a732b6b9c1da2e31e9227a7c1988345bdcc81ac0c029c71146f1532a66ace09976b829e58d019799f443d6c7747585345d56406030c07191b0dc4b6037a695f4bc7b68e381489fe59e9a399289f2d50d7596029202f2ebb1fb42b8bb8019486968632abafccaefe090f83fbdb8899e3190e529ad6189ea195f0ff497c54bebe9b60b3d21cac5b995e68d4968545bcba538a5cabfd3a419537719a4e56d21b39bccba10590372996302128960b7928569f78d505e2135addf7c81645db13460ab00e0035c11a2c1df456ecfd770b6c617d054b572825f74515ca6066013927040a694cde2d83dde100231f9a913f22b6212983b6c49c3a6b2a65574c969226d6a812273b857c9c21974ff7e22803cca7325a8b161beb38c16e8bbe5f9ff1612d2147f3753eed9a3019ffecabd2a9246e6051714a31f82a225ef04e82a056636c5cf83a116130b36e065ef5f10b64e3cd036941de847be9511f519755170b2a7169c1f3995eb50b046651f61852271d6ee2723bc1c42c42159a5d22f1fb33dc621fbf8f485485ef622a241006c3520c77644d1dca3a56ea69388bfa0d0df0856fbb041eb902cec87002cdf16e62d369ff6cafdfc48c5f371766f94fe61245baaf5448175592edf99a3b99b380221a497b4abd36f8e3587e58abfd65c25d4ba95689470a6e76cde2d670e3623806e08a31c682405bb11d7aeb7b00fbb34be5e81a08d36337f77e13766ce34d583ab64521d167826dd87ce49f09775a459db0a816bb75b7ab24ca53756c5ff15ede72e2a5f68ec5de5f764427eea483dc2bb57736c7278e0df4d22ba3a006b9135f9bbc05cdf5f83bfaa059f8783c4d0152bf7ad9ab92a0061daecf342e56baf011e038e575d505a328024a781ea94087524909c07b5ce99882a22ff8ffd6e744018249615b740cbc93b585bdcc23088d0d93d6b6a78221831d3991dc81e6b068a392c7824fbf473584dfd6bda9f7ee1397450392f8e364a213ae7fa56c8c84646f5e2a9a7a82ef3ecfa7dd7af91ddeea875cc9d9684205bb2dcaaa3308c9bd100868117c30605f872e0ec0823c63e3df56cd941e8b653e7206bb17f2fe08a80ed736b57ee22b8761d8ca377a44010fd468b223897af6b557227b8855dfb54c8d98652d9469f016896e24313c31c999155c715dfc89b2db96505e98e4e6686dbeca84caa2daf138ebc5f54daebb77b20a6d8f89698a8d64102021cacf1e3ba2ccf1fee0e9d0d08365e5ba25ec80a73604cd9c76c11412590dddb72a68ce1dc9a30b3251a6822a10e470cf3e505f6f20111df229cd2690120c4511a52926beea58ce9eee93bd4791050c8927622d06c990e60fceb24318bfbf4acc7656e6b04b8832ff711632755a94214dc6fd2ff62d1023d5198f1a621a3246db59bd24fe415242e8090c592bd17ddf45cff52180a20ad710c0d3c47a284fe165676f4d74a4daf448584618eb215954f984070ebb7c322c1d185f6f06cd67b469d959f9cee95b448d42227110dd64dfd4c4392a746873e636b54bcf3ea14b4d5316f44d2059bdf7aee969d495d9925687b7c77057323331643295e08b5cecf71662ab92d5edb90343d976e5d1c50153eb069800148174185df3b4bf0aee84e847b48ebf408035b7b35b6f6fa7b2068f797ab5fce857c7423e7ea70fc393b899d79aaeb04bd52258b99691c6f7c817a5dd970d6767437185f54a9055dd989508442594ae2cb004fc2eebfc4d873699ea4f081e75fe35729e63dd0365c486a525cd58cb6aa35d3c9f878d9d5736d48f35dbc2449f05bdfaabac84226504f137d2e454fc2ad7d1c610bf3eb02f11ba9349489755e92ec426f6a2646a1056b1b828d41b0d3380ff6c438bf58174b2114c3888443c3f071e4857f6f007dac7b31fd592c2e809a219da006a0df6447ee623192bf728d33a5352f36b97c41d6bdd3baba5634c500c124d9de039e4c9e62ee240bdcdacf0245ae1ac5d3e7cdf5260dd2969dce4128c60d6f5d7cf0aa6b69fe68de723c05bfdd398c4e7a5744d42cc6ff8148ae52da0a9bd3e542bba7b96b4fc99395a7a0c66146e7daa4647161c8fd0d56f7a7981de79058509ec2002ed47b17a78ce43edc2eb252561dcc64a1c19a702e48b5b4d5f2a2de5cffd067cdac92d28878d432f6d00887e4e312e4f0ecdf29373fd13276d1d6bdb550fdade37b9302f21eb709fb5e03a0633322f52b017c13cd3854ec76e4106aa37fb5b7895d3d85377fa77c834875bb01e84785165f2dd96c4edaeb7f716bdcbde756c9ba76d3ebaf0994993fcff8ea2df1fe067a17bef140f03fc6bea98bc8ae9a1a0510ae08e20c22cc89979bb1be9b04fd7b644e39728603ee050e1cdf2b53f881685f8f4da9495d45b097210395404a096c72bac170e734093b4741405eef85a1475ebb05df60397aa39734e3c4854a4f2decf689fc5a532a666dddcd1a56d7f52d17026e17310fe7a8b6debe61b14b1ad5eb873fcf7f261048f756bf871c86b8f05d4242833a923a7d723722d847668aa7e3dc45c92dd2729ac964c115ebaaac613f8564e09a340839c612b274248504bf208e857d37db9c7568a07b8ababfcc44a072e9d845fc4c6f5f79233e9d99caf9132e1c1dad5be379ffcc243442d9f03a7b196544bbb12726761e2f5568254b6da3766d25c3eb131fa2e21c71b9a7bef57ec8c45ad83a27a4dec7bef061428e57116dabbbbe7b1d92a0a24fef475fef98a13f7da0a6a978408078746e10aa76b0413bd4e32e314e1bf1c08f12323b32240b47638a118f5fc43e3ac49131fbc8d4cf2d066ef3414bc7eed4b9b997bb068fd3f0073cf077a67ccc36535bedc179fb823eec05adc03378d2aa160aefec7f5b59a8736f3c52f365a81a75240fa18c2ba6118e6306be2ec4483b202abfd44f166ca2f7dfe6ed0ee8dd914218b254ed12a5769b482fc808d3aac631ff75611537eb9e35592d537ed4930eed2904a3bb645b0cdd88044dd10d8fd6a04e3e63bb58a03015ec2376de1f07a95f6e766e29d5e44af131668dd761935aff6efad1642809f3ac111241572f16efc0dcd6acd0a0976547d7c55ddd43dc1e9a9530a0076d06a146c596ee1b22ef1520b54b5883a52adeb8504c4078d82a4b9bbd6bd8e95f072f0b31f6600a822f5ad14ea563170ebf7591770a143479071b1936acaa1d0f0d74f169598f6607df04fe64a773f3de27dedc30687b45c3c7522e1b44abf78422d157fbe3f7a7670c2e1e00e3df9e891ff3394542c60d01eb0be480a4915d3235b066f1947a711255134472dc2f30a7351572790c18e5ae2e15f85d1b14018085bb540a1676eb4876b80af173e1de92f90dc1f8c3ae77660f441eed809087ca2f4f7241ea478c2f3a99a32164c827c935febe38dd08d5416f954ed8dcaea5fdc948c0057a0aac7b2adb9ab0a5002e8484de1155406ab8636bf19f764d97391baf23148f864ec488c699cef58b3fc5f93cf5ac93bf3a3bce04a98c14ceb48137e574986cd90fa146828c89e09cea557fc292bbd8502aed6efac98ed67352188c3bbc061b0a8c27a4c41fcfe4d069e61b5287f351b726fbe22246f32406a073a0072435d7bd7ef608bdb35ba1068c7130db6c5bc07d0b6df96b7fe7a5902a532400f6f7eeb352651e1c948322b15e7bc54dad2053e866dc954dca32ab57f6d16567e6e5332d66642bba448b669619f78b09ff0980e04d1f9864eeaad779ef3572844617dbb882c1b46c331fc67be3c704f35410a6f77548e6b8f5b3b7a1f86178b85506a3775ba7cdf6a343b7542105b19c325484446af38de91f23b891b18ab6de0e761e2c5d843e18b228ce44b2f289c4675e2e45a87fc9c144d422baa8725642b61d1fd7a65b2905f7bebedd7a06df1cc49b4a29fb1c49f364c52002efb673258d58b07578cc8d584f968c0d025952d9fd6e231911a563b379ac6b9c84756a545551bdcb1a449bec3bb26b6c2461472b4f47cb68d8a40ede201279d1143a6d5c0c5ea2c9831b84e0f124c593b63e6c490afe410327cc868def5273636e0002658c06bc8c05b19a2de1c293e3d68e75a4cb59d1d62617e9413326604af1813621050dd7e133dde4db2394c456ee1e23b3d64731e9835b1a2086edef029188892d477698e2729f8cd8e76bfbf89708dadea609b86a71e3043dd130135eb9b6886df2c4751a51d2a586b7a2d7761a43093700560f820a6352b6364c790f6b0106eb062d93f8758f9266cb61140be35b1ae590e16de3b1863dc688e24bff792b30241175c830681687d6e1eceee9daaf4deaefe98e3d2aebaa26193ea1323b75a422d7d25784c797c493917d17f5fcf8c68147c91530c5dd69be516ef1eae38b79ce57a1d3423c2d0f42f6076de532cef2e59be89ef490e3e8bf53190501419d7b454137da6f194637287163e40a76adf396efef08e5fe24b1ff4b927e555dfb4ca10bcd546582c09f7d491cdb0122a4b4fb2076c0d9e5452b580ffce7c6fdd6c56a85fd69737c44d24f80536bbb34fedd45520a384ebc71ff2f6c0028fb8342be4f54a8f2df40823bce8fe0355ffd212410b493c522e8e93149011360a7a95441f476c6e6bc8c3fbccab1d55799cf6f00cd4161c95ea1a471a3342884c24b4525cecf7dbe872f99a31c615f9ddef322bfb8efb5d177aea7dab1f4aa8d410ff933bfae744b62f394b459955f0c8dd9df925293266e0672a8a931875f2101c404fd8df77c658277ded0c0af62161ba441ab50890d424dfe92eccc4984948699a38305f191b01465bb6a205e96d9d677481cf58d598ca375ce9152b063acf9c583ffde385799554efc99f9a0a067f7e7ca6a4a51420a63433358d53db45be7a1c2b1275bbdfbabee4e711b85ba6346bdfe70182e6066b4549b7291526914078ff59e7528c63f0cf01ccc3fe8c1529c94e5c286c079914ea8631def3f8a6a83e1410cca1f96f4d51a0113a1167d8068df29efce5644591633823fecb8f29a79438598ff16096bbf2b7fd2c978ee4e8bc84028e0861c4c1c14ce8bb1f5e28bba6a0023700387f9c4f104cd908c1642294549f985984080fa1a04cb0b4701a825da0cc7700ccf3c5b78834b04d7b237366322f62cfa77ef11b689f1cfeb9b12b7fedaf64558289bf7e870e1b8e67a691c7e418e362cffb7080d0a8ecccba5e8998891bbb9035bab40a9e3f6f4ebf9bc39edc82c2e092329e86359f77c9bbe8165205c9e0511d35eafbb722e50e6beb96949127fa2a5a26aff5603a106bb25c22282fe0cd0c1d450e3168ca6980452af62afd1a6127e8f850e7c6270501f366815ed7b67bef33fa2a9b7d7100818b1fadbc18d32600e2825c6e224fce71334d84e4660e46f3a33f591adaa9bb8571edaaf617f7e265ede70e7ab61299414e32d2d34e1bb90879591328321be5d679092e00bdd4537a8d4cf0b0f08a1eae738f6531ef4a9db53b58829d38b96aede529d1d1d9a62cac16aa368f7872699c5730b4a9e5d7861ebfcb62dfdc52d941d6575ffe5d15e3e3a4c8f230c02dca27308c1ad1474d59e01a508c3a911ef817918a5a6b37ef3323f9c5269697832eb2f3b6d7b74776fb0a3a338b43eb7edd95fc23526974ff65460fba174b62a30ec0894491588c14fddafc19022ed84387a8667f6b1b271e1733f18d22baa4b82c2a87e389ba5de8a1a64368efed75ab5241511d02041f9bc5d88d8908155d92d7dff46ce54755210e6cee7e306240f6b9ca87f1f989d0d35bf7eca5e786c9daf54c754568b970f834fa3789652c4d530ce71ddf786106e7007413f3af38ed4a6c8ea91a3c8a0842e21c25484d08840e740721c97d21f85fc523853d50917466fbd82b0bbddd04ccd46e0235ebcece98fc45c2449594d1c94b5c6f4626b12c3ab4545a526c69b535d645ad17ae0aceb4bb88317825f9a5ae528f0c1580799e2fefc86a6bb126d4e24a96e08547128bf3804fd7161888bc833b9637a877674bf1e295955e10e5640e86c0ad1bf2823e6e7410b1754c19620377fe22ea94208e423dd10d94bd36054fc5fce181fcde3353c9eea30f7b239ca8fa3bbf4bc749308f95acccc69d99feea8dc05ecc8239312e0661239a54403e6a4e63050e114d2d33fbf5b1e9171e209afadaaa92874da154dad8bb2e926628fd0e73ab77b4b7788a8f1d3c6501a37d05d5b6dd3155cc7d577b4df65b91c655af5a77e8765580d88e99cea4cfec2c99ecb54429261569254bb1b0ee412a32b51aeb456a7ce15c537ed4083152c07e3b3bc04fca5b206926128909cba31a39963e2b851ecf63369ab9e89be3ffc691854579067f74014ec030f6e3ad5a476ed28669e29258bb497ac441071a80f9f5ac2e0d67f834889e0ee0c9c56b58e95d44f5fd75600293d3b67f0b2e38e2dcfac4947f5fe3bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
