<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fb936f4c3aa481aa7c5a1632b8e5c6a6041a4033f247f4b263101df1cd33d65ec9371c2b0265ab44d9020a435ceb337f25f0599dc484f0a1e3bed34a4983428e22cda7de79c19e5b8d2b56690e48c62873bd21e92826eb3a92011aeee1805d334c1acde92353ee2d6966ab8b478fa29f79a2924801c855aec5098f0a6be84f47a0f157954cd80b601e8f86f8638be117bb3a6da04e74404be5e688e381495601f8c5de120e3a02d96f18098ab98a8f9a1197cbba5337d891f503e339ff4066462627ac41ff82de21eb7e7dc416c1409b0565ff1f3e46fe0d8179b9191aaa4172bb0ab57ad7497987cee16de8c2629e3275fd4a538b168ad0115728693cb2cc3bb86f5ba8d3b2b17876da96bc7132f16f91a035cb9ba952a1856522ae5ce05ea5ca354d140bb6e22b5fb0485b40dbde2e957ea81906c08bac2ce5ab4fec6ea3d4f4b18f62775dbf2e2bb5f8aca60eddd8ba4f7a2be45fa79b012c4ad17d62efd732906cbd87d63277c54113ceee476e7c8cc9c924cc4453e6672eaed5be4ffa466280ff2a63f8223965c2bcb24dfc11dc391ff6fb8f3f359b3a8e6c547274d446aa08d34f1383d0dd33cf54b2f4084ef4f4f84e9f4a14ba245c92296c34d2e5c2dd27cc353f7934e1d503ec48c828ed33197a14f741d5609e7cf897c37ced1a616a13e0b871882effbbf7d108b0be670405ca042b67f504127d00f867d56d96d159d8a85c8806ea1ba5c018d109acbbbd0c0f236aa5bad6b58536e9349c15a187a90a024ba0073634790c5aa4fe86079525cf69d88b78ea0870da046a1a8d472c00c7330d6248d20fa3efda1a6b953b016ce258ea691de433f579db40f7a4cd9305a114444af1c84b60156be462cb10db22e347a5d206407b14c16e9ca5e3e39ea5e16f1f536295d34e3935f66d18a2b1c82ccd5d0d6c9c4a336575acdcc94d2aeaf0e053c54611c8fbc835f6b72f4b9e58a230784da39ef666eb63af715fb1c3fb8cbe9062a0ee918f429acc93f5a5996eeae08781de6aa45a91146eb3cf3e876698e92a6fa776aedbb4149ebcac90ce98640ef77741ff76b7351d9f92b7a91953704ed9107abe3cc68494508854e8720b20de6aecd5393593d93b513fb7f2ff2eda21b3652f6cceebc4236a45924bd3ec147799682faef53cb8d47b1578bbdc210c1c08e82b5e65def5597f7b3f29a653adb0a5c674716a90baabc8093b4197f48fdd8bfd022380c0980467970ba917d5e3cb50c3ce5a45e61a3039a2735f8ab146ebbf61b8bfffe3dabea7b0f3c75ed5ef5ca48c15628e5366b88465b5a76fc2c2d69dd69087af131a46db99a8b5783d32006476af998d45c519d750602ecb76799cb40fec01d6c16b8cfa80736078bb566cbb709f5166af697c2b471b7a9b7c245b54461fc99d12fb2e369a6b9ec3d477ca2230bb088639657d6b7021afed2cd8a88498bc5dafe676944c71da7e7bac57d52a2b5cab7efa0aa209c09fe75b086a5336d1cb18d39e9275f5b6f26cab0a36f2b025b3fc98c5d80320105693243a1a32ce0d173f661a14cea8f1852cb8d2e0226276b13a977447e849617386b9827d5ab826fad83c14d5cc220eb3bc107b4d76a67c3d146d941997fe1c1109dc63f0fa61ea7c278565b7dd4f9361ed12c3946e94bba3ec466eb1d732c2b40d21d9317e16414b6d1f495e587f409df71b05fc330fb7ae240ffe3a8a226ec7fe32d5a5ce73a28ec8342c4162c7b8dc8f095be3173a519af717a1dff79344b99ec42d114f63f53705f4d4e6cdcd401b9d2890522922260bdc9347e17c2a5e64007e157500af8b40ae9fe919e0c187428725101996151437a2fb0d166fc127e34956e19b571eec2f9a4938c7c814b0475a24815b767516fc65eea5ebec0d7479641a6e4c621bffe3abc032ba1298e9b9d8d3e7af06db13699f4de0f466401ccadd846606123c275b729170ca563d4156788fead5d82798a014e5c3573ddb24398cd340b1022f6dbe8fc6de9d1d501b1b37a6a10d8c6968ec921a9df63f663a2b0ff16682a0e3ad6a81cabab86ad4e90dbe4cb252fdcfd3fc20f7b0f2bf7694e04fb5234643009421f6fc252650f980950ba1aae470217b779600a176b8ee98fc61bdcf98e33337590fe2b82d214b357bc0f4119039bf299249a658f6c3e3cd99787707eb0c37ddc851c69ccb127c9c949433b86fbcadb205298a89ad3734511cddc8453b868943645d9afb311fc31aaac1375f24929d717e6fd0c121461515fb2f8f92a39976e7ca02b7184a2223e0a158a88b96ed1eae2ab44eff742f4eb28af9b8583669e7f055e1deb264338c967f194d16f2a63067f7a9674702c390ee443adb161aad74829d75c8c7b83b1f6b413a6dba28c961e9aa59664cdf8e6b7a85d72169df701b752a3decdae105c7dba5fc85925bbe3560347b534aff9b6f4289af57956d1b67659da3714e516429292968ca6651341e669a2efba5f1f29075c59a540d6565dd08c721fe4d1ea2440c382311de21f0c25b894a8efbdf43ff8c4187e048ab6b1856b1dbd0bedb0318d5cec0b20104cfe909c8cb962a2e335d693643c704975949fb0f3d7178757da62f4a1f7b8230d1523242e6e04641e9c0a814ce8235098dadb0fe1dded8242de3d4dee6f7877dedcfdb02ca8e6606542c77893b6e59328958fd6e43efce97ef5a66ada075acd01de82fd618238b7010a2c81a9839610cecb1aa6dc0c037564b6319682c123700d0b4dae0ae9fa4e1f2f30f480f3de99ee042c53968c264c872037b0d3b57b2edb4db71e916b713d3e9d1d4af84aa74e87d3abd093cc0e13c999599c6eb1eb84d2210974cdad6418623047f2e7f321d9bfc5d04b14d1a5768ac45e8823297507e09aeec4f3a3443d56ac741d4de60365a330466de7c5d7e89c179e8cced5440894c6572e9a7c4ce3c07c6f501c3b8bbbb7d1cf13e0d2b6c6520ac18a527991c7a91f8545acb81bb868826e462c7f81ce3739055c95d21778759282a8059d2a34030bb36c582e60684ab18f12fd482ae611ddba8f3cf4517d13d3996e04fc563925d8b70ff226f656f10e12490b5f23ca943e22689758f1026156717f68af70ae6b8d4e2f981fddcad4396d62620a046bd5a4e43df4facf29d07e18b93cb714ab3034d2c7acf7449387eca3a103d7f0e6e1c643c464e158453f306241cb3d287f2a1f1871457e14015f4e6d71c19f9734ba1d3879babae9a25b95f09232dc6601d243f066ca1387f63e52304d78b16cfa6da54034d5af5529fed0b74c0f4de08e0d58ee746b9c37f2845b77b88dbf0fb0509a4a8361d11f65107bebf010e65a9d5d000b0db05978706d42b1c6c731f1b193a582004004f0db15c36df7670e0eb7d8e65965c9f597078081838450cf60c673aee363f282826f7dc062ff748edaaa25bbcd5f801e6287de7b55a6439d2955be4c6f105c1a767197f4482386e832b3f4790a4372898234b15d8020f4648074cde689e159e079352728fb03c6ad3cadc23746843c9678b693189b6ddd7c3646fc031f8888ab870f4f8a4b8ce5a35de468e6a159e727ee9419601f87049795d7b4236f6125ddc523ecd36205b78ebfec77d6430f317edc5ed16b8b65f17e46173be357c64c482f23c3c87c7439a35f4075391e3a328e684c0bf45764b6e193fc2eb01974570ff05415c4bcadf73a150b8504c633c7198a4154671113f7d3996efddc9928a48ad4b8c5b1b0bd098b71b81bccdd6b1401a8711af67a74d5cd9ab548b670dac05969b25f1db8a5f65e9b0be2172a82037163aa0a65ea3d10e2ccd6fe096fea98c4d1cb3050add04aa23560a6487135a74e4f81d82855bbcdcc799694d5882ed2fa248b38fdd444a8dce38998f97cbadc6837c255a47118373adc3f36e0b9124eb10c431bc903553046693e10b7acb205dcd0b5d699825232ac48edc5d6888c5fdc5acb43f0332e7d9dfc88fc4a6137417d6a74272ae9566143060a80cadefd0988017f43cb1d8ae0d07e6f63dc17fc43039a2751afc9770078fb26272aeb37b324747f85842ada03b3cd36ee20bf1c66f2fa8756e1775b5f3948adb0a8fa4b17ec6b58d7a54fb5bfda2f764ccafe77b6e9c600c73a261a117d63241504e70e757bc69a8f81d6e6ecd10e380fbd7c86ffa167e1b5ca6a1e252ed5f058a7fd63df4aa2384a76d3354a549dab7e747e11eab438c03cc332eacc8ab8e5eeb63ff0fb18ea5462a8b9cda409d26ce1856760df6cbc77aeae5bacfb55f51980b7b3442f2f10b0f2b8265dd229a82c6c829e91c338925e6fa3f3a17c02b5f1439d76f8212e72c0b415b154fa49fb4027c02e445633350f7fa6ed90ea8ba41e9e8ef0d7668aeb526b7f33fee29834a378945e5bf3eea1b4d30a0291f9ee2e94c6908d9a43f3194208401cec84c9079b188bc015d52d69f9d6870e56e5d92a5c67361ffb2d5f0c04872672645cd0129f108a0cdf76f8a989dfb04584d61e657351beea23b2063101e564144b7df912040e79e5f726c126ab6a20827bd2132ee3281068c18f1aea89d3f5fb8ead66229e4298903ae8021ee0c329e569bc9d8203567382010a5835b98cffb526237649581ea76f2dc594197a66d6733cea101f405178dd8f5e1a9d6f9b130e295a6911529b2cf819bb06e1e90418970429f96bebe0446034726c3d45a4de20b82e8ee55ba9f28b099b6b6b282740b888afd281964d73330de77d15d43346e611b952a670ca0cd11d53859c9c291d5b0e2bae7bf92c00650d80c329db9eb13d8af778740a37fc1f8a12429925ca73168001bf6ad1614f5ac1beaadee6992bea8876322d3f59f0e2ac6591903c609b6baa4b84677f95b7aaef99215062d91b5b6ac8c4222cc4c29fe2f271befa60fcf3d7a8bc0e03ee13913fce3d716491f7d884021d3ea8518c1621c6735aeab8f2b8bc399bbf3033922566260414065c44c0a5e53b636668ad5c6bb5bb6cb25534088277afbacb3c9b504c87f3beec71ed8f4443a8480f5b5591707e76904cc1ed38843b0d2c5111a01a96e001b6441f352bd44558ef9b55e31550bb109e5e57094b48d5db4cc349d42ce76efabbe27ef49b1d682b4562060be04c72ea83d29dbb8d13bcbdf01872087ca9d36f9ab4641774ef75e036bef95eb1ee4e68c36a9a2e595de2ba08a347f52e2127b62f296fa8b89d1771dc67c2ab4063679ac57bae51e6ad70150b02bde0e03a63615a24ef2060f7939fad2aa980709efffe42fb4e2dbfc8802ada73fad71752408dd4eba856552b89035b6b40b68bf5b19d4de246a19c6fd6d92764943c969d8c9b4093004b24d786a5364b21ea1b934db38093b2cb092c87ca24a25a0bb20631cf853fc9e58f0603d781aa0e6ce5be4984a0ef5ccac5976d2214308210f339a023a0618aa7741fe91e865ec129e3e06c5fac117d32eac492ea6dc21a33196b7e2d78138c640140f459285b152585867b5ef87b05fa3ab7b96aea09bd72f6893b312eb30df0bb1ecfc527bb047e549beb04ebafddeefa5c119784b0dbd37d279f750353cbb20cb0084c559f4f598cc416cfa4f1043e175cbf6ed1e4378390a9f2226cf966f94a592c57b6fb97bf5de5ad24b14f478f9dafb9f14e16ac6b8d55cae558c210ff81b5afaba7becd540d2e750b1ea63e0189ffce6cd86a4ad4582a5f2e884e874d9d6bb925f5eac261c90ecfaff607f95bc9a2a361506464c6263945d7674d07bf350b5c203e27aaa97dc8003d54a9944cbf4da112cab24beb0367b2ccd07a87f277df35ab0518e066d35df75bc01dfd3226fbc5876ff4b288557d2e67bcd14160fb503e0ca446916b8b21ecaad43b778f156762298c9414557d852adbe5402dbffd1784357e8aa252bf4a470b6198ca8eb8249f9f30c0713a7a9fff5017d0049f379d0c4211347b829afb565205d55908a0558ac6b6b18d3f8a14fd9aaf1187d60047276a155547bbc1b6309b4a80b337dbce4715fa8a10f8ef424d46728e87bf903de51832a706b6215eebde11e6e9bd8494546ae03493965fe637d6d5986b8d1876e7d946705cae6cec90aadae33d7fdc322b30777362d0d739e3f0d3592601ba5c817f35730579acf6e711e0eb0f5fcd00ec925b05867392090283ec315053f72cbdd520ad90256d032cf5ac78ec679dfba4d2ba2d3cb3d41e50f48d33f721ad0cc043e322c99ed452f2676851ae0bb1677585c3d5273b9942da6e1dceb83b339e4d3ea91805295f9187729c417ca58286eb41c1b4cbfd8afcbe85341060b3cded1117ca0fc22ccc24d7e51e36d9ee33b54b05067703372a9038bcd23472a66d70639698e5144025f0f92e93beed59d1feb207f6a9c97c7872d6b03eba6b2decf87d0c193ea0222c9d89d885705a6d5a5d2f0d110574df02e461eb204d627f375d4a56c57329062bd9ae3b2ccd35dcdf93badc6e07dcaf3711d9a13fc9676e648db4e7ede3726d43808381d6f7e0e0b87dae0dcaf0e076dd2f8f455453bf1c8635b7e07797d946beac3f8b77b0636829b67feaca1a96e6d0c714a20d0b214b1dbd5e852b13f61aeba6fd6ec4366274fd7d72121233c1e29432e8c1cebaecc382be45503977651d61330ba53621b256c43274442a4f340381ef1db45ece434ef97b8d26835f350a4575d4bb73abc953a70580a7e766172a685bf5d313123b72087c75a3055a7b9d9117ca882c543459b1c18eb91fa23a3d1bcae7ea8b7036ee138b14bd003a767c48108bda6e53e4bbe6d3bffac915912d53bd3675c45029610855918332ccdfbf77aa32deddeb009257b60c252e9db89f882d9129e623622c6046e1d8ca7bfc7cdb5775ebc04c84dc56d19bdc0541e4b57ea756e99b08cf2ae8111b455036f48fc17de5df0d622d7cc54606836ee613e188a79fb9a18cdab237a1ef8751018d3610d6adb7a4b3320efcfce27a2f78b4299273c186682666f939609971c019e668a7f3d86f44535ff4d0961eda4f1d56427e4d5e4e8f6d8f4f68a9e412fe318c3152787901b7416d0cc913ba266a7688ebafb9d8a5fb9015cf17ce43531371b4250808e61d1838bed6ebb6810049b825cb0ec2b0458ba8becfd0441a793c1043ee2ceeace92f27b0863aa6d842a5a54a24f13b6cc94d2d9070f5670e3173f38626a7d453105da3df1c7ec4702353b592dfa4239013e3345788dd7b3098f1845958df4c64a3a4446e54b4bae1f5d4a9afbde732600c38fc9a6c019a8f8637b42a1aa9bcc0808034737be17d541ade3be0bbeb043c2f5e986099277d5ceb3aca5c8e91e3382298fd25528b7ba557209a66374a46edcf9313184d04c6bbd415fd11f216440bbf6d76e436799ff8040e200e562b3c8c3990b725e4c60775e0b5637e54038bfce7cc85ce5f1514c3a825e2f9e4003db42225961cb39aa21efa69671a149e79b1e66319cd9af6ab60bd533f693a11d2c1ac867899b7498aa2dbad12e1f046dffb1f411bce5d5e9729aecbc019020877572dc9090aa9db4406c35c804650327c71939c940bae7662ec6f1e98e7db5b772ac282dfebbf5c56fe449c7c1e967400d8aa96e0bd4459ec45b3953ae7b39cbe9b2ff091369d59dc96916346ebd3ffb76ec95ca431e862d56c107c5096bc5cb8c9523c3110ac2bfc7de3ff560b9c3cf24df5ebbe036bdd032e70b57049bf3e03077463c1325e1d775c70d05418020ab623f0788139b18c2b330763b3754958c7cc889a14d7bb82f3da7987991ff7a4aba43d0338a287e35b690fbfc3a5ed88c9394bd04ad7debc84d9120d10ecf5064532fee32f4161f79f9f59664d33079ff398358ff81bb3db7aaf2595a740aa869918c9797f45487356cb448b2e38197e963445449db8042cf9db2feac1d9fe63880092579dc91a5939bc88bd8fbf8efba3917db51224432a023263626c9f9130624188400b1cd3d638772cec0640efd6b9e7cd32e4f5e679152ec135956afdeb6a2b73e32baf946cf91ea07bd5b3ac01301bc7d3c84746b358d9e76a427b4c91bb53a7f72f116303e9eb2cc408b15daf9f60932d12002d8c86243f3fa0956ca2d6df27f9864d0bab46c65dc715ce64e9810361e25cd177ccd7075b8c5f62b29380a20f9f73a8c5b5b265fd72bc23d785a8fdb25dca965fea708009dcf6ea3053e115d646bdd0f6b2edaf615d817298b2ee764af099daea323013bb71f48486f594b2d29f77c1ab84edbfa4b18ae40be1c5018d74e550aeb895fcf3c8f794054e4d30b06e93df9a31f11042450cf933ff2826909c2758b0f6a642e0425f5cc7f162aae6dd218346499757ba5885c7cf322d498dad3d91c60b112280a462808abff4745af2eb3445c1d24dbad8f32f2f45138126b34736fa93ff6c54342f1343b89a7df46459c8aad104d71f8efb3e45fada368a06d0b79fe94abf376f6e9bb25958dbab734c191e5af44efd4422cfe3dd3d987350519644084feae7c1c83f10128bb12fb53c0d6ac1b6308f349c4f15bda1b946e01eb96c078a522e24ba40e8aa7dc145547b919c97a44b48e6d84239b2b55cfee6a16705cc7f4c7ca512b223994ea4bc1a20c7eeb380302cad2db343a81a796440f4d11a3af17c97eaf29ded3c4cbf30fa48eff2088c1b04a74e9fa1fc620183fb34579213f54d81973e63f0475855021148f23886bbeec73d435fb217a464e11a495e416f565cc5fe2fdfa8d4a38717b9d030efed47b7b8522c87beb7e1f4578cf99a2a7d7faa2293d956e763731f3dcc44f89a73f3365b64cc8ed30fa8503d7b3986ce758ed5cb35a3bc15f7beb647bdff00dd02623281312bd17a487c2ff0f1b1dc06f1b65be33f61e08262600717b381f69040a7f121369cbeb816966b54b0a75fbae30f208e6ca25b66561256a53a364077668215f1f0d94d8146d296ef0705e58c30008c98089d6959b743acd0c4482501e05d5b88654efc88340a51f6f1a32562e5655d4ab383e460989d91c747ab0d2e61ca6bf3874fa50ac27b4e025f522a280425ea6d5201c2718f5a070636e8a19486887e9a8b6c6a42d1cc9700a80cff0b7da3dd21e3d372d676817cdfaea47f8a8e4b054537e81da5d679604066d074e2b9e7aa14d0661d21f5c767a4716c6dc886b57431b3425e657ed621d110b0afa7c7ab7d5bddfa31d0429c14493262e5f2f9571a6f948c22ec0cb5692abb53d0ed27e33d484bd456fe602fa0c3972f38236910d19c70e7e226117e19fa5e383b1b248ffd8e94559c814a2068437d98b459889ea4c05eb884c31c4827b1b1c8abc5b4c2a7609f3063e6c9aa7cd3cf23667a6e90333e4af04e9ad880bb09cfa9288b64335f318905b004900cc42d1da646681e3077b348426fc8e48115ff36d003e1c469e7a1dad134df2b755c1468928dec54d8da57101fc34ee3b4d43da31fe4f0818ee3886682e984557bc4551f01f5296a41dee34fdbe1a3686ffca72fd737a63578e17c776fd3eac498d81668294dcfdd254a7783ec5cef27d345fc044c64c163370c97ff83cd10cb84efa3987c4620fbbeda5b9a1195f12bc32417a8a1b730a82a79cc93a0b1b98fcf65f5c54564dabbeab0f87d48619e490f7af4d4e2c7545f18ec1402c12d342c84a6ee447a6c3c33a69b3792c25a7e923f9ed36d770bcd06865793ccf43629aa41d8650088ef4bfa9c3652a512e8d01b3c48ded6378153765a8518a09672a6314f9e05531dce2f839878beb2544e34ac6f2d2aec40311d80e9cfc2491fcb9c653e9b17863627d5f6dac7b84be5154539ce4d12185a14fbac9a9ed29ee7c006c607ab421463e534cf390626040e58df75b411e1dad586039a81cc37671bbe86ef2f4a9332ccbb3cd228ef03e7c5a1ccda6b73890eb1514d60b493f76658fd1200520552553d1abd5ccec104c5ebf5c6b44e11e18927978b19fdebfa5eca01bd86aca2249df77093e6dfba047c3a895694d91631f34a4fd15d89e19abfe6ea548d03bbe7e6e0fb8cf9e2325131c179f4d61363a52fe34efa5c8b1d73842325799fea7eb914699a277216c253ce1a1ea978a5dadddf8b68462f5ad188e3413006382541086a5aafd7458198580165aca6169ba93aefc45a40fe8d00359e105e1057e7c1d82954c27010d67a79cfc053e722e911e4b43772670f5024d0c6b40ee349470918cb181c619969a638562752a6b8059b095774df8d6268de3c0b470fa4a7d8064b2139e291cbd6e378d32e2387b9efae8eaf8b7f172efa6a22dff4c0cc83069fdaeb6b474657cd19dd760cd04d8c5349b48eb94e492c250258733bc3d996e376f5f4712186b9ec250675a86d458a7cefbc48e673b766716e7840b6b58e1f7598f1dbfd0c4caa2b710a7dd4407441a7b249ff24388895f5915b47308c6e505da9e39cb8eb07e7becdd1ae678a9b49e6b1d64823fd0d2cff5fb97c256c9838c88976a1abcd6f97a3b61247effe9289529dc1eb55f990084ebbdbf7d62079650198850c28a203fc08625b134cf27874a33876d1116a66fbf4c929f6e9eb682fb576fe5f81e2e1e2e3ac3b3decc2141351a817f9157c8e5d386ffc853c8858b449eb8ac4976128222e02ec701c73bd95b59f52a274e9b5611ed85904a3ae5b7dc15598e3cb8061084e3d9ff2ecb769f909d3cfebfdf630d7868350338f6cc16126dd6ddcf386a8ca5e8f85dfb633d12e2fe6e8d58cae447dfceb009f541bff18584cba789270ee26b8cd02ca0ec74dc8f0cc26ee343947fd24cde1524a5f3b78df4cd5a475f77d350f8df80b9ab2c9f4ba5dcb0446cfce95374d221e8e1340a6a3a407a7c60474c75319cc0a7bdcb6c6567e546f53588ee9d54cc2ba6813e1147ca758b09918bffd5f21fedf19e50465f10e66307c6fe67e1a4a6271cb2a944ae23a29dd9468dd894270037c5bfed0b29c0f853efcf47dea71ddc49b39362583de062f731b62718f8ed7892603c9ad07944373ec4dff840ac244a3101f5fa7f2c763368609fefaa3af1346bf88c4755a1d640e478544b5c1b06462309995a4e027b795f3099df4e2a7ca12f00299143be64cfc4a92cfad5a89e6d5df2c2e8b51e2ef3f99d4e6bac729551636f6f625a6539d2407f8a54f42d6a7f7ca62db5ca6636a3173b0a04efe7b97056651e41ef7f451e2dbaa7376873a9e65e8f4fab7725ef54652bd117d4d9048920675b4a4371cbdd5a12802729b6c8c535ec07ff439e851de2153f971b0729bd95e118bda40458f058fa68eecec9d67fef8a148a5e843f810a6a6063c6366fe2e75e739085f7a5124783113e994ed7a289d1bed13092424021219f0307e3ce9ab0c96ae41ab49657353e9d7fe4f2740b057ec5943178c17b28cbdc4acba3bc9366f5d63f661068ad934df4da660bb151611c59104416c46a6e74b0890e7e5445d937d6f2f52783636f1287e4758e3c7dffc2a4d04c968a8d0b27409d49c60a0cc8decb64d21fc8f517964ff67fe063cda90314aab7bac9cb5c9379138540e3be2a7e0029572e312024c9d5bc8bb5ebc5a12a857fb20dcd44980e1e277940c9c708bd33e5a36802c7affa9ff393b471247f2fbc8c5907d9f54f5836212a9c1e236ae7a031dfd263a850f58f5f3e328be18bccfd3a5e50c1539ada080ef024ae2985fbc18eace9e45e611cb58f6b8f55a959825337ecb314ceb6b0ed643008fe0703df423a9edc9b682e578a3192a95f48435d08bb8f76bbd30f7ec3a09b413b269c79cdc01606e334974e30bcb14f52e70c5559de772cfa1191fd48daca4c8a74c5c66699c5c00ab08d505d02388c67850b34891a7535d48004a4e49338f2e40ecdc0af8c505e838817497d30b85e221bf85b38f6f7fab57cd7b5f446bd86d592c304bb90af75aa13fd0135d5c4eaa1b1ac2f6eb305d47e0e2f610eff39226db3070462bfd496f0c2ddf71141d91db9b4c82af8c91307a614ec6264e5ebf4a7406b8df41b6a72a0d910f08a3bf6940521d29062f7b547bb1405b796f029918bc2afd94146e15e5e045f54c9c0ab902c88b7710ad4df30ff122d7fdbe312c80686ab0b4ba6cc863c724d2d655458b4d098fd9588675bd3c41e6ddd529262163c85fe4178307bbcdc5309b27060f8722c2b9ebf337217767ae37534e3acda05af0ce35a369b8a398e85b124b3e18e3fd88c12ecffac834059212145a0c427d462eff4b04efb1051ff437f79902ca8ae3b70719060c62a300e37ff92d67673fbe0d206de59482a491d819383a070f863f60f331220ab6b1480a78be7034754264b1d29f731ad9ef061a307b1e65c4737c59022b82cb7cd242d623f83f48a5d214b7531bcacaab5b0e09a9c617f142a3d280ce2c0b6c7a0ffe419e92451f3a1a29bd45f09d57797f0202acbc5595a9ad7d6bb5f15dde0c69e9bda1ea2cf2a1df2a408925f9af0070776b73d746dac2be5cf0641bf793d0420a70bcbd349af23f51643d4f765947ba756c2d8dede54a9f7ebebdeb50bf94d12fa115a4d8230e561af206fa028e9ae942852bfcdd1e7db277b3fe7c84cbf2dafa51a293ef317c6ed08cb83d486b0fbbd5fe0a2ccb846f055a4c48ff5452d7e7757e5e8689c2843533c28466d7cde4a78c2e3150b802bb9625e958f6e8c90f56f137d1b9eeda0ac019bc38843e363c2b545fc8e94c0f317b64c4e9ae68c69f2d6e4b05905594175c70e2bfe82637d568e66f9e34adf5ff3c7ff8a5bb013bad4a71b894adde30ec4e0bca1677599bc104716559802ac8d5b1bab20bc30e85b4dfe5eb502bdc70ea5d95b1e2ec115c982c02b13767782c7f01bd8e3c4e3b22479bef3ff1ce8787b5b01657dd0845676c678d33d03942398410bfd76e751629746f6d13a3b910945980fe285bbe12aaa3153d9eb4150dbf4a6c66c29de64b28cef190bde24ac2a864b0ad5e5ddd75f23e077c4a82f27c01bbe45d9e825159a33b14474159f0fdee062c66a9b8fcfdaa64fedc63dd4d42adb3a2f99a298300ae314b968d94b3a86f69667e502a4c9d6ab5779da10d93e852e106b9e90b144e411cee7e62f787bdd3fcf19c8ef55e5546e71340615a206eb973880cb589ffe5f91be218bcafb9e5e53b4435555177f0c486008fb9f5fe2df56e266a59c8452f02dedf89883b10721554c0c73e8e3b7f1a97208a15e5c99cdd2e119d7003f06247930bb379e8eb46a5ce5cc5218c3d2fa175f3717be3538fba4eaa649295324f37aa0fbef660b302caab732012c5b7efd778d07ad24b883e4bd9a9b88885277fbd2e1585ba49910765d6293f6db4d2a403ecae5929f94fd4e21da753be65cbc4b55992f1d39bc271201f239b06bd634a637c12eeb0fc7b0cdc628175b2652d495dd940d3e06aeef9fb645ed664f80c8b720deaddeb35fc123e8a228fca0c679062e36262265658f8202a8aec447993bcf83ac1d071e0f31b2177c1600d8c6a2d2a71e04c38414721ef9a1d826fc209a0dbd0387dcbb367ceb2498626583bc0897fb223147b7162b9ecb0ad8908bacb855eb3031e095e8d40d4c73d91af9e85c6468b0f4c3422158663e07fd8715b7dcbf3c099a7c7ecfbe23d09440c2a5d7490456c371785d4ab832e3aa7e5cb3c8db696361919d654bc117ad1500a2b3e6891ea177eb97395c4b65543f0147fd578bb406c14eb8e9ff7bcac1a22c2f72fba36c62e14d8ae415457111f523e9013d06d15da8663174be2c995904615b5633fe3e1592d4e7cf09d234c0e03ecd990f83453272b98b7f660cf4c470cf110f85f7c3a0c1abfbc7cb7899e0fd7cf623e7164486626dae8cce76409ddc211001036046c1db8f7b819453cb6e009e155fb83081d361a6fbdc3193e46e7e9ecd2945af69e0549a2f748f2299b9778f7c4eed3eea346a7be4319b2eef35d3ff91a603fb996e901e40dd31cdd9ee5ef45d8c89be97736a109f280151f4058bddfb77949b6ea30eede86692bc7da2176860d113df6cf2b8a1d2709ccb3d452276d4ef5bc00788424376040198c5c774320f7ace3cc4831bc40c25e56853a0137355c2b08f6a5d6cfec898b38ea38220a0772c74ed6865f7645a7352b6216945cc7b6b42c1a7a9c1f5403ef877f69618812667784934484f8439a8e8d0a4432395e0e3176e263d90d40c1b96721a1519876d75ca8f7a693cbabb4bf4009be9d57ab3856d5a8ee60db773ad2749458824f737a3291c42b0c654a49492ead98a744a1cb04edefa04c39c2fea07997d439de4c72a811d31033f562865889f8d66d3ad4bfdc5728defbce32bbc17bf8a8b321bc942b345ac6ee453fc96afbdfd464a58a623b40524a7a76915a62429b525f62f5e6c1afc9cbaafb48c8023073753a9e677330fc3bec80efe301754c90f5a992e0142247497fd876cfeeb989b691f8bd3919de1849a26e29b7b19c6ddbba3ac8e2a661d0bef14461d2bfc466b0ec23d9a27436be2511b5d12802a4dd29045140119146715ebe14268e10abc17abc3b107d38e243332b49a6bb48c1c28eba86a7d4619a8cf2f8f782e5ef8bb9632ae25bdc6f6cb1fc42c9ea8ad8cde55fa3097a1800dc26ee6761e6be426805f7764be2e217b625358708751d97b2c674ae31295d06136522da66d36f86dc3d822166a2cebe84449da1b50f5987653c10e31cffff06a49fefc800770a1158988779c5d16837140de4b1667286bd3740d7dd5e9781497a7f70a40e87a90d5ac5e2dbd13e579d9194a5226000ed00b943c785458f3e25a9c75e3a7f075acee965865a154ff72a7574b4a2e8f63fad788b3c22fbf51f32667587f262b15f27134e07cd1e9298bce8441164f12caeb9fd85ff8255c1a40cfa7a6950abacf2e1a087c84fbc2f1d175025d4dd07e4023872e995d0939e867ea04b5cb59cc866494e48924574b0770956ca2164a5b2937164a6e142d3cb525afe0a7847f168cfad95ff6aa145d007a4a60ab54a40bb42ab28027450c8f2f297fdf1cd1ef4d4b6b43b718dbd6a1a5e255f49cce49ad203ab021446689dad0aa4a2c62e6bdecb50b038da35dc896c3a94b5bb97c5a48f1f6f3b710756a8aa5c0f11f57656dd99dad8af33eddd462e846024b7641eaaa437ff95695953d617d8185cc1ba57cbf9909f97c235ba0a17675c9d1dca0bd3c095b351e8d9f1bd7e1c1574747fa877a43e905c2bd2d16d7c1aa6aa9539763074c0f79e98e6832385ecfbe158bbbcdc467f62ae5cf0b4c95bbf65009557bb958f29bd45f383938c7641e888d049f04dddee395d02c8820294dd419668f704ca55fadff6a10c9c8937f87661abd17dc508f97caa9085d23cfa4b7ac24768768248a2df59480794204146fbdc40459d9f379e1f23670660024f55028210a7322a54628aec75334faf29522f59f76ebb7eceb957be25a2e8d9471bf80d9c42d04d00dc20d3239bc210e4ef7f7b8f683079f5f7e4bdfefed154b136fae5de68881642ea26580abb2fc933727ce819482e47bc77986fdf6e245469357784e3ec98935719cb61f8fe995177f9d08fcd77b779fbb68840afe5bed80fdc6ba07325cf3edaf8d753369c4c7fa15c36a4e41be6240beb28f66d31f74329c3b109ed6711029f2fa1078761e404a52e45feb3867c3c4a5129ce28afafde34d44846d5b1d655fc13e71214ac472e055409389dc9e16d3329ea11f7ff06125d8bea93c69c1131252fd994ebd2f6623754a3f2f2ddedb6a15bcf8547264f037d6440626be6e137e7bb59361a60991558e492703ff629cd0d277e69b36b91e879799618c992d7c4ce1b40305be3eb913b5af98d60fb20c698a8e9ff1e028039b9a4ec3f7cb308fbf70171f243ba86fa1feb437dc55c2a645c640af02daafb8ab7f7d6717d1f77673125661b5619085676ff07298e558c028df93fa25656a91b990fa2ff9f4ed71e3360de0e78c070f8cbe8d50503259a4024de93805cc32b8743432f27ad32a7cad7a2dacacc6741bc27c5c4168e557796f2b09be4a16680829bb757546164a5aa73f8bb5a1ecf66feab57a6d4f562bc9dd82e8cd14670b61fe7048fc82a8a18a0c00c4e7678e0131bde05ad04cbbcf9108d2003c33f4c4e1ae9af8d2510d6d461fff6faf8f5090e2748987dfaec722ff90b129d39818b0cf3602cc7b0a064b9fc88ec5911eb464f3ab7e46bf57798f39de4489098f1cf2a8c3a86f025813940fc5227d42568ee10457b12847450a0abc069e1ac7e95581264816aed3341252c4e9ce647a9377e52a747d300a6118dd1c73932eafd0587efa128100e65e007b3497bd72962caf18fa0f590e135215c4b0a2e8c3cc65f226fa25c3afe4b8c60f80e536ec44136434185e5faa29bc7d222c06b442057ca37bd0c5e6d92526921595818f24e2ace7c16636f5b5feb1c68ad5eafc3572a30685b02c692fc1527e931d4216705907d7bca0ef9b12a8713c9fde21ca505916dceff2628749f0cce28ad3de04d75ba3924ce5aeb6dd5c917f12d126700c7f72dd00e5b4b409b00e7e115ecbe742a2c5ff734f80c7f2f1302e248af393651131cd9d2a88bc75f871d9ec5f0f8c891772340a3bfcc8e02530ecc20f7b7584b73ff3b78115ffaec14644d042cb6b16fbce7623fe95374fc1919b43dbbfcdaa7f6c6cc9e3d2d6d720d1a767610e5aa0eb6d411bd132dbc09357275ecac2c5502f7c7c7ea6ce1b5098ba9909b7a2dc1a86d668f51a56997b683fcc88485e7541ea48948e1be95369c475cf855fb53a7aa195e348c3dcb6a487e8cba0c6b78e5494b7a6e6c2bb8d7457fea97c8c083a95d91688d28fb238b7e794b81e7675e434d1ca4f2c388bf113f732dff4812fe4d32759d545bd1c25a14552b7294ad6db67a1fd14b06b8f3d9eb92882b6665c3a8354ed0f5036f424afaba98679610d623e5ece9dbcfc75a81b0268a0c61d2f2846c856aca210491ed2ffc0d51bb387db950394f6b898c03960c4d7922baeda1c0c228d752801295091ab7e1a32117c594ca2f8f395a05d070a2aeab3c3bb676989dd1b1db48ed79f9406556939d8b041c91068425d517d21a3f79ae884ad6a0bc0eb0d682de6e8ed344b91e49e6af5731be811009f18a3dbb7527cea0d823db1a8bb7983bbf69103b39051678ff949f085c0170a98fb516f0df05ab65d529781185921f38d72ebbc520d1fa42a6c1e8af0abf3f3a24d98f827814ebd76feaa615e390a9fc5aa315945b5f89a0dfb155a47b8fe4cca7d918b144e5bbc43af88c30f42d706e766a17ea722d30ccb1723f3a7e64f076b08b83d9434f48b301244b1bacf9c5617f5471e969c167f5e7a9a2c948634974b38d75501bd58e47f2e8b5563fd460a9b121f4d89460197f4127f95f94993dd9ec176863a1e9107e71eadd36342c661a97767c79fd3123246619ce380255369c59a80409bedcc4dcba88a3822b2c15fb80b9a2a3dd68a8f72869cc67eba4a826b6532137e03c7d5e51b48862c1863396755f1125a14fff81f28a2022ba42c4ce80e8cd77a815669c8692fb601db1647f90c6a01473559df5a6c2fc12ec256723bf82dd791d415c56a3e55afab3028166e72a0fb01f102ae7d497b0e620540988a9cfc76bec2a682e827e574dec86e367e417069b106231cd4112ae2099aacc1c833ea401d889d24d49bda9bfd1dc140aa8b5c63e05159bdde60eff5b0580851d1895152193f371db5ab12a9ea686c95f68fdea422e6abb04c380b14a1063899c4327ff455383c11e275e614f6bbfc26c301d063c92831d79e46f45b1990c1e73d119c05bb381dc2e4bf3ec3436bfdaadc397de2145067cd88124339d181e58bf8826a69effacc6781893bc0a5e39a36a262ea55808baf7b0927d7842440037d4d0aa3296223adfa912bdc617d778a63d2a0ba4072da3edfd354a9e3143d438210061c2e2a12459bf5d6552a066a5f5b45ba133536bf0a95de94a619af96efe32bd17a20d09b88015bafdab32e4c0fab84299fefd304f26048ac3870e17dada7ba666854c8af42ba598a605a3c0ca2b4909e89489ddb7842166cc8b7c5402d5a60a17b4b806a8913ff3db8204d042c089bfde403f18ed1de739dad2e044864629d8b94bc3c020d45cc4d8300549f768c44adc8d0b1be2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
