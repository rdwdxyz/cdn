<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4cca87ef77d6300d30f4f7438e09771c44a5b2a2b72034dcefd96b388c2c090b22f2a199edc5098b556a56db08a5dfeefbe4b131e752962f4c8aa9c98fd0a53ee2bc5f587977bb30fd1f5cd0b4d26d22dc0d0711e2307a6fc75dea86d95e51ff11071630bbcd69db1ed4520cac2889d31c6684d5fdd744a9f62ff76b3dd748e909a62afcd11ea8656c6f01a8a28a66cf36c79b576ebfaeede210b2ca35abab34de53c35884ccd4f049d050f077cf3a28c70de5dc953d4c90a6b7aa0877912e2b1693726d995b952e3cc2e3419187e9f255d91c8dece58deb4e3908482aa829836620fcd08325580ab313825ca748640b5285524e9941eeef496ef0a766b48f74532b536860429a182a2e4980e4e856e5eb2bfcb81abe335eb7fd416415db6600e6b55d5339183d8dcdd16918014ee207eca3b7b2a5cb4c086a8dd55e92aef95c080aa575ae76be273c10aa5d05db7d1a2cfe93d5de4df8e5a08d4cacbb428ad9bda9b82bc7e00aa5d2cac512f05ded5339d6928db3d1e96c89d765fdf6afabbd7fe0cd993cc9a13e2f6efc6c0bd52c9645cc82f6622b171de319820563d11ce5fe03dd241e96b2a5d111e4963e8ad83fba8a2c484b8e800bd0093e7e98ccdbd13e80f60a4523218d197c6e57d90f7f7ad0421ea75754963cdab334ced781f7af52ebc9b6d0c812e7fb651c40b0314886bc300cd25313d9082e9aa35e14e5feed28c9b827adb2ae71ad9a65e089a3a982d2b62f41284b094e702aec6fd8260068ca3dae3b5e6ef6cdd596c94527704cb56425550ee1071bf666614a29f6efa2105ce47fb1a3042cfa40a127fb0704a8d5fedfca51596b8f2c20ec6aa15725413d4262979497d33b2f333e99cd6484d79a211475e6fe456717e00b44808fd4fabd1203ff1b18e3c6fe0adac6294ad9590c4bb31fc19fd10d9dc8b0dd7c6db0f0919a5456374432ec75d1b9ff5b3653460716e6e51dd25c9df8e0fa964d566673b23c859cc16af08724f3daeb8e33edbdf8c0e6bb1f58647933987eda813bda67dcc67ebde475ae6eb22f79a0caef5a877860c10a1fd2ffc21b5b87849a259d6debf59db178952d376c974669c1e95a4694e63e96306aeef439af6358c48a14407f991f3f7e46b3de7ff88e16e066ea47a7a1f4790db43057274667a8624979ec6e06c704f785b977837b262b3a5dc00356cb30c286a9e15a8bd65bedf90e6b817a48f1e630c20a66ba5f9330deaeced61b07964f852e5643332b3c4ac6ab0670319a4a4f79da4aa87ca1c2901e11c210c9c25e82008a4889723d41c15a6fde9a208a9fbfed5a699ede1dec7bb0e8d892b7c086e04b0fc792633fdbb00135447fe93a476ab67567969c8cb7d981d27d3339688d9287a2bcbd133a2a496da2ecfdce778cc132cab6c493528aebcc6c145f556d80595c3f6b8fa675f47efa7c1be6a26c7f9f17101bf6d63431e419739b1db391a7cfd94ea8e15e8f7d9459f4c655e1293a0ae7ddbd22285c5cba5fcdeaa18ec24691a1d3f1015a762230eb57ed3cd9b82976fe968682e3ce78a89fd469f52330802ee1dff0e395c5f32a24e17b60681884821d899988ab54fb75ef7bd08e1765d4bcf8964ef73e232c08dfd3e4b1a0d08dc64b950f86116df4fd137e2ab7fbe6500e1b6427095e31e8dad0f33a02b9683156dc5c1f4cc1bbb275c2a2dd3ae04e2700f7dc854f8f3ad5f5016a9ee18cd28d233fb2c69115b5f1105912526a09f7525411f000f0b0fabe78ba8606eb31aafee655c64d092a5d751c547fd50d603efde35fa87d27786ba4e348bca74198df0fda3382a6081b1c591624f57d151266965c986200f1e2116581f8efccbc5ef88d44c18f7055ed06237c336abab0cb13c1716bf637557a39d03727ca2318deec690dc8b00fc735de4996e58d0bbd31299203055c844022ab60e9ed8abaf82a5d8f2dc050adf4fc3b84389d896a25ea1f9ef824e26268dd2f25877b92f3021778d0563ece86fa61364d90b44f867b4b60b60e251ab6140daa20acd4b29e7c61e6212dc3ab9627220bad284afec9627a65497c9cb9bb4b761a0cf8db44881128563c022fe59a31643ffe87dfb54a89cf005a658169a2c6dba2a240fe1dcfdb75717a18fdbf06a1054a33330aaeeab1efee82d5f109fdfa55d30543fa87d86a542b5ce6bb2ce3dccb5bb5fca92654d24844bf2caa1bbc506327be2b4dd639b322904175d6bc88fa736ac4d8c76cc9b78002f19ca2e938cecd43c06391484b377fca6d6878b80e8507e6fd048e0bec0d1d8b661b310af13e8556e5b300c42301927e0e891d921bc8cd45e64198c4ccb5c599fe4946ae8b96f8b7265fb95917453da6a0e45dcb5aee0fc24f8f3bb6c21503ee82cfd2f97284f081533d72ed5553ecf4846a2a4a54a3f060f0273297d6ead9a2f252155f8703c1ec0fce228f11aaff36ae1abf065f7b71a814603d6dff03207c944f5182a26fddfc65d267a3efca3b4ca07f08b2f9124d6e69e0764b2f8e70f8ba2074d3b3cae8cdcfdf780df2d46f16a1e35c2c20d15309216bd0a1119a8cf488c22072ea3ab39fd82cc77aad19bf05304a76c3f7ba454e2acee85b7c4999fa811a8bbecbd0fa963482e2f05d467a46ce17a4c530de94d57a745b3452271e7c85f4c24c5d029050fa46a11d1d3163ddc9e9bdbb7989efbf64e6b8a71aad26865da7d443a9d860bd4eff6df53ea6379a4c2e9d6b4c13b6323f83f8e35900d124a9f223fdf76763e5a80d606b2c52dd576842b937f082856dc1fe6c9a20a1b6416e5a10f0dbc9524e2c95acd15408eb22669e4ea46272419b2dadc68f2a662b64afb40a08f22d46368605d9b00c74e0b246d3f89300f8192649906ffaf46b7531d11f6a224343710aa86f0eb384a6eb83b68b359ff33e539d2792acbe16f6ccf3f293099a64d20b49612933583103aab6e0732ff9777d887a0cec70c574bd16a344525c09083e69511dc9198fcc24274e7359931a92617d3877125b660c0841266fd8b2b94e655097e8253507b325d2df9df8bf378d3cb0379de6df3157ff58c9fb7e9b442661d1738c1d4f774b891141aa2371d40a445642a69e1cc2c95e23ee03dc4a5d9853395fb5d687e3e3a93b96acc1508e48156bce7ccf86d1f54b14a4044b39a77ecced0376df3c27a97fd0c9e439d1147496f7ae74fbc971b115626bba62a9505f8026ce73e33656031db7640d08cbaaaf6b969a67856d2ca2ae297062f90f4237c95b34d3970e9cd58aa9da6885dbec2770e2db326056a156a52763856fc2e29dda075302a2f75e8fb83fb6c4237608e0f820913f2533893373b016ba71a74f95017540a20ee2ab196af506d5aa9cd6133b01bf6b334186fa110601278c68e2bd5b1f6109a51e80c88604702084191a6d19583a9dc863a0c11d14c211884598f40e101041757e5111016730b98f3fd26c625fbb6b287618c4e2c6a63bdb3794fee1f6fdb3aa75dee507cc2d95bcadb53539ad76cf165526cf57ac785c7aed00c18350d2432ec19aad7ea25547b6d051f17f52e13daf5721767cebf96c460bbcb98db6cbb764c39cd28e2f0d2745babd05714f6699e4f4449db375bff44d4d2b6dba468e78740eb658d538b1a9995216de890a774d03488e6581aebc1a6072e0f649aad3eaf160996aaa285fe79f9cf7216a1df8e57fc1c5903b72ae2e8091324c7e9a5e587f00a91bf590fbf0c5bea3347d981c39d9b5ea5f1f3ec6f09131eea2dba937f2f7536c8e28de0a9f66a06d047035968a125fb32d01294a7c47e204b1c731fc82a6164a1328a8127e3b595d36bc4babb6c9ea8dda2bdae242cfa8cd53fb1b8facc4535e90352b49e85e5fe80d1bcf137831cf2d3de7d41e90e54984af71fb482b004835353b350fa4acb822a4a267d1c28ca27909dc2b00c89408083fd83b7138ad126128eb6ee57023d6e622864ed776332d47a7ea24290dad8dd3a3b64698bf0d00c7d8679e48e3c7eab642932e5bc98680f52cbb2bb05ec673166b1c8b071934548c9fc76ef956a0c388157cc956585294ed0524e286a193863fd899211519972f1ad22eb8ad5a65e847e243e8bc3b7e4937eb0934d9743b819e7defd5f982991184d5d22b53c11734dd49f2f30917b0b912f4e54dfeb2457d83443e9c59723a6452edf868ca22e4b8c8a65f7aa0c18cb8f497c2c3706fa6354dc427df3d6c8981f41d6486999623ce64764d0d3df8cf7cfdf9e4cc03b5720b76fca01665ad93a5a45c62659d9a14afc468e074e076946cf88fdda92ddb9483d1bc977d75aec51114cdf3675436f73d134ea1620c1da698a874fa74cc8068b31818a007383cdd4ba71b3ff3d25c9803544a3efbabe17aba57433692adf0fadad9a963a3c80d2debed48050980abe619b6efb8947e4a3b83125269c2f142e389c36f3addd24ed373748bcc759d4279ddff0caec91dcdbc134fea7a02b763172563c4989374732d933e0a9309b9550f90456173909a11a02bbc52b846c985bb58e66dc78e6244eeae465cea36438e8e909a76f43697ae48f4a6588df2d76bb3b376441093c3e0d107130d35c7df844b155fb894686e98a19685d14c0b8eeadeca0a34482bc5ec277ad2e1559b8be6f92fcec5ea857e0cef28c34482e89ff8947c34a622b8c79b35f1a338fb38bacce79891922cad3190ecf6260d9a310c807e23167739913c42217771dfe138b5c04ccd6ca93f3664fd2838c0b6262eee0a1ee689802b03acfbae2488752f2ca3662f669a8cc1f5d8339a1043dbaa8a376e952e0bbf7af8deff0b6024b9918b4fc1ecd9b22c14ec50b32029d62c08c62526de46df6490c6ee2b3227fd2879cf101e236193c094136c4c3d385bd281ec5483b6f8691b7dcd8063674d09894a1f32a9ab6b8605d7dd4b82a9a62dc483e7fbd4f1f51e2da347a0fcd2de97f7b7471f083fc9dc88b769d1cd960f72324df8eb695463a23ba12f4ec7db252b73f1c5eabd0b223bf1b84b98973bb6da34c3ac5da9963d30059a18e4724978c0e9ceb9643bd25ad6147c413d3d7fcd69972fb7e136fdd703c8bb9725080a984f06eb3a2d1dcc83626d9b8ae7ec457a5c3334dbd5152be28a4bb70658ddc3baed806182d8513e8367787e2d7c2daae692059878776308fe2ac1a7bb8076d1392e859fcfbc9e6096b93c7d360a19a529659ac2d271d04cb8009fcd616dd11e11e4b2a502e1fb19229c00fb44289411ee466ca0bc5d7054e43e742117adb818580ecb324b59f5726af2926794b9cf05c6350c0215665ebcbde36676de4f33e9eb8846fc7836ffc7d6b5ce5fdf07415d9e4a4be20d892f7454919c99e3049c11f92a866836122f26495d7465e75afef46d1b45f712c8332ac21e600d5bd480053237ef8f5c4653dd3ffde39f40b43342253c0dec0ced937a812fedd385303c1fa845b1bfb9438b669bd89f163b56a13a6eea1a6bef1f265cb36102bd00d7a5ebf66605491f0a45ff4a69197325fd6e7682c9070c4e6f24b571754eb1aa1fe229ca8dd0d368d4dd85906b1b77d136776fbb8fc75097e4c35b39be8db1de5de84ba121e3277e92dff6eaebad1b42b994fa51b84ddaada83c47a1bb789329bc6473fd08b48482362c2fba896090882fa64615504586564c89eaa7b0f0bee7bc4ad6daf160c5830575d46a4c3770a9fb74ef30cc122ba6d60187e9d67e4f470a49f62dd23b94c345a19d9b959caa6be6f9b46c0a93b2371476488fc3c83450731de9558e65ecb1f4f8a16fc09edda2994728c5e71c104cf509e633bb2bf0f4e4fc5c29062f06b9ec70769e52e986c368408bd4125a5f6468c96edc418c9b1029a22781d5fabadcc28d29af4854183c3fc50f926af2cfdf6b9101b374a58dcd8edd88f6eaa79c14d9cefc3ac9658f02e04303719813b5626b85fb82e89897b7e64c19b8cf827d7717d3654fc31c7a7425a33f2477b5b222e2080e8714020c52a24e41044183ba2127bb434b4cb9b8ee1c4b8c0477debf1220afa2ef41eefda676cf18c770e0cd3a36e590c1151552457f0880a08f1eff0bafc63348ae360aa06b88d68c3495114fa941b5334f5c0e2877c62d20b8a6f6f8cf9aebefe266c4151c113945e19b3fdcfe24ae7e12e58742a2b070b90bbd0132fe0bc8adb8aad4877df3616b8f54dd7093712c08fdc4ac1b53179ccf47a78e7886e10b3b4adc05dc975e24845a488914472c5508c219e5dee21a4e4adb02bd9a779cff72e25bacd22a0fc9921a2f30684c01490a64ad07e4a3924bc5a9509276315154c2e512015215d47481eeeb61e6716112d5ce81557280e27148e27b36544a8dde794e4a261272a41531fb63dc670dcea422732e207916b0525dbe5993ec002169d9228a8f13733d75f918050dcf75e07551747b8761a83260b32c24207676103952990db6a4c29e72d2058496e212ff5edcbec5137a63f4f20f3d6de98d60027d09a3e82f7be2938b82ea4842a1e0045af6c2514a16b6eb9c79e47019b771fafdb4a1a2ac05129950e0271125e1071045251b026c566e2f4f62ed9adaf0864214d3e7647eec897c03f925ddb82d37def7e959335c1857cf93fffca704c4ce87448d5d39cfa234b24254ad8823a7119a93105adb17eb9c3871aa914853a521c8c47f1c67f0bf04cbe92d83f293e8f7a9e645fb7a633f1c7a73d0a2985247bb3b8023163962c94a3e2459c99b4ccd33e5707f3d82c0240e56f6750f701bdbb652280109dcb224b97840a82d6ea2ce63cb71957bb598130d313975a40e77467cef3890050abc19957d00f3e6c2aab76c8c2a2966330098f995c6ad3280bb5657492837f9786931feae7a04ccfb384c9c3e3659fb8a515af2f423997c500ffa0e090248b9ad22af45c441db6a4b72fc7356d6acbb8b79d07aa2ff19037b5528cd2e58d83fb140d73c5c88c36e4e3034a5e5bb353ba0134be1e73c6925e18f1316ab8df202407f4e22fc260631f4447e1f0564898532bee3fb4ae2fb0b01f7ccbfe07512c9868e341e37cc270e02624b7e84ca5a34f75e4cec42c5935d32547ae48c014224d52e45a8f0e9b2d75dfc3775a8f9f0c418ebf281a5340eb5ca417b564d4fbc2394ed3b420340ef4716937e23c25dc5612b7ddf62557e4f7ec1d69b9a27ce479d5c0ffe079292d081b0ed765905004c7dfeb3b81774dd72acbead1e7bb8e1b79867454d283b856e1e6b6f36a6c8275f01b8252a8538c0d727ee2b01c5659b32d12c88ae6ea4ab5312f4a1b80146fbfa472367ff3ed1a1ddc9a3cde44811fb0c7f3e8e2fdd043324d583960ac945a6aa84f9c72d018de4a2811bb643a27aff4111973ad3fd376e5be51793191fd3e57dcb41066862abe20713f86bcfa37a19c6a1ee3df33e6a0e7d561dd67258c1292660a7db3386d175904f3446088a362eac5a637f05e6092e3d0819f0291291b2a50399ff25ead4ffc9bafb89a7be16b7333140fde5f382bf51b01a4e1b6fa3fc388521251f3dc7bb350d5e689cb2618f301f762debf8d84794a8705162367d6d4f48e9e3592a0c8ed1f294eea289e77456c5faed2ec399de7c8471620458b6a0f9efb45100122ccedadb619415b2f513d954d0663e3f7160ffb0f142aa34b6e1aaafabb0dcd41571489e689940030ab04ee67261677967c645d3538df98ff4f5d9d5a5e1bd3e1a25351f7fe63a8f95ce78f1a3a0e83a8bc3ca228ba014fda889f2531103d4ab42328a2402baa82ef95e3ea329e3b75a56ef948a7eff12ccb0290028bcebf2f2458bab9446769e7d609523adb1fd6d5ddf793705fef916023483662b6fb300e4e8626a02d17f21c78af98e419cd43414db067ea8520f32883a553615706d0d5a05f86e4ea6a217a142bfefe7abf13b72504ab17b5cbceadfb84eb8cf7eebd022c984279b0c88a7119e3bd0dcd6d5ffac3b6f1a1a42f28f6d31cfc07af15fad51eb78bf51fba06ffca9c7814bcb9c968a46117ac805f7367966f2ac5c92b337f05f831e56e47e9487a213bf5d337f0a2eecf471f6433af1efb23a6f27bb7799f274d541ebe9957b2bef5899793578b30f5af5ecca7bb65bc84655cb522b3a25eba17b1a5ab7f42fe9ede7f02264fbceb1637ba928e93ac5ff48309dc251d46484edc37b7ba25a691990a559d58a8080f8f1c1a7e9c5a1488bdcb25a0655d2ad1de2819f55a3523659a045d33e9f446a41f409a23a163fa91f5044200e1c1600f04c2f7e43abea224c5e68e93efce41cf924c77ee71d0869c353ac9df55580178f41e62d111007720d5a6011009cad0b0a7872939df762225b5fd199e7018a979a9a46f70efbe5f4e71fdb712f83fb6690427a0aa99b924f9063deb3b9122b6cef06c7607c6afa496a397555fb970626adb34bd8bfad0f05744ae25927e286d3541899017b71b75c30e69362716e704716dff4de4a868af622cca11bc509cf28f13b75399b7fac2553e3c4e9d6875ab11fc2f5d1333d53b78101ee07077261f987d73c020c9a7206a5cf15854da2e9eb6121cc9799afb121413b2bac74207463eca117cf4236bb6fc5b4e07127604854d03b5101fa78e0bff659fa86de4928f4cf5e648170eec3aa5b5a37151087214318966559d94ee5a5b2125204889f1ec6979055f5bc5c7bd03f15537724fa9bb5904800a13c1152d6b6b771886f26b4043331ee1fc85205431f1ccd86407245d1846b1ac921d49cc1a3af7d79125c9716077ecb4a2b2ba259f3dfc6177d7b7b9a33208f43abc7d0160591a6d9afc57588001789f26a0ad1d86d34fa99ffe81a7e3fa2a00a546517a8538e10c578d5cae62a43e0ea2857380d252d76b25edd313838d5a7063a6d5d108a98c3c435a2a3ec8ef578c5a15a83741aa5e735adac6d412565e8f7f9c31dcc2a01fbec4d69d5522ac4786f124d80744b1dc0decc73df9d83af2f48e20dc45d1860e0261a9b74aa542d77b620c2788ca8016de08f4b60794bec10dfbce3dd78f12aadeacde4d1cf89b5d62661ac11f048a9675c5c625367b7421b5e960f33f0ec69421f53aac6fd54112d568a2ab10c36270cc015487735af340ad574c565350e28cb556e1f5fadcea23291318a5a7efcf0a7890e2ef1d4b1f63aea1dfa7faf2cbdf0dab3cddbe069153436744337f8543ab46673693577f6efc2f682f64c60b9f6eb7727af5acc7efc9ba6807495c846af352ce9b99bab730f6225b50dff16e99cf4408f2f9fbf0b2ef0cdb27c273f75a619cf63299ca76f34735a93b480a1e87602850df2ed8a18e04dfaeff7a418821d557c02a7148b4b47f74d974606e03ccd1bb0455a1dfa0fbedfaeec92f48c403f073b8695852c576dc76b4ba7541d7551496580c8090da38abc98b5c86d92b4ff21ac1e952d10432b6768c476f8212a4e1826e007c319dffe2f91167e581e8f423142c05335c10c89d29120cd9e2683a7a0c178f6c1978aa5e0a09eac7138e681b2adbfe6008a3d717989e67e4aba217ad41f05dad13643304ebc1b6e55f87f2208caed661d24938da8f86d7dd5308ed12a1b8ec67fcf6c42e1100cfeb040ab6d3d720e548879512aa49837e3ae7f4d87b6dea7bb12683217b80ba231689c4ea9d12d50553e06a4f8378c9f63e932d5762e02f32e0e847ac225204f4e33b4e6560ef428a6830b06a38f268bbab886eaaa95738e9b7ff3d81e4d1a7def9b8cd60bc1683e599986204f4ec94943fd8de9cb0fe82f996a81c9bae9043fccb96b1e794e138c407fefcf0bd020aa23ab05908ef8715773e55112bd2fa226d95d09bd216db4e70632c95352e210d642da79c7fc3317644dbe0e4d47c0866c5170b2c9324d79404250feeae36039d68881b43c83405b06d3494839d3992c90a993b8b86d19c3c44e2da7166fe1104f70d1ce59c504525d6a75c6259ba7e47251df784d178f9108af42c39abbe8184681307e7c7a04bc22f072f95b8f85e36044d000a6cfb733ed6dce40aa0f89630566075ba3b7e629efcc559b7011dae9187626d8bba902dc708aa9e3a1e698c40c4317b35e41cec0cca50b8ecc80842e8198f014f0259ac537a52756315f7971d7d07b7204782f9b474bd0e52edb8e7cf03554e7ec0c75570e5c6a3d5ab02caf2289ab19d7e3d4d4f625fb1561c0c9a3d8a4f7e57632f47fb363e75448b9dea04a744a5da1881cf4bb9e8cda4e6707967ca6bb1d94cac03ebe61b404c4b8a63fc191962a0740f344c3e5e05cbfe415342af6a6995826d062c5470902bbc8ade1bb1f10133ce09bb8a8b33913ea8019f11d5a3f1537603956f914f98536fb7f9830f17367f05e95de561912a7b3696b51f347b57684bd90000ef4f9073d159114033027867c797706b2f6e9543d03204a9a6dd6cf479b4a1fae5f86ff8c1ca59d8448ec07e25118654bcd5e9ef884aecaa326872aafe73b2aa0e034b33fac65a4c65c16fb5c7cd94c4c276d0057099535e0cfc5165fc95e252b3ebb2cabe4589f653c3168fcd277c4a57f8396e5bd0e9e257d3dcd804ca037b045895188724d72119cfbfeaa1d645df72889dc23e5998ff3de04a6f66fbc64f6e05857f6263593e6d42f38e8db94985a1e283498b44c4548b2f2bf0e28b93ff8e9cca2f5c5bd8faf498128328443d616b474a42e9a8dd6e38de7d339d1f4473bc308b41dfa449a49c3502d826cec3b8dac3e5fdebe638e06e3ada7d77036f2be6d4ea24e4160d6830b625fcf61eff3abfafb42d0d9716822eb4336cbae0b22788eeaa196b16699af9b72c97dfe898cf8759dec6ed4ded8a70ad2900b6f02686a2ec38bfb42e7613c1c2808783e2afce3fe71933acbffda56789fc3222664be403e301f4d78c1318da2c33e79483d15d5fc54e622fcfb69feda7413521da320f7c556c87cfd371a95739228a6ee90a950abe48944ba66dd33fa9e18b49cebf7696f175102242b49c0f0f878d646c121a769276957782301589dd03988ae92039ea2aa167a840ead6785086eeee783f71fe47d79c1418e1d94e4a52926a583cda89f6fed2e8a56940321146428e5aed9f7bc6c24b7ce63afbce5dfbc6e6527f7945407c66bfa9863c22dc6d85653aa041de7276ea25c99eac8477b429af7922d1f56285c9cc79210bc0c7ec0b21255ab3c54bf4525ac683183b08f5af380e03782f628e1d05249668f1dcfe22671b7173a140f007cebb2c8eab0cddf96f58356b7fd6958fbd69be8fec13f158262858c2e774d78b89bc0faa230bab20be0b890e59f82576a49a6f2dab6a7b2891d78e5de636a7d9194db1132d73620d50e47db4a040aebb53c7297cca242f793188870e281d8c6abe7ba3354896cd4249d997c8d5686283a4421c4858e499e661f0a5089b5f21e7957052bfe0167caf5666093450961b8f24c1e98650208c684c7ad906581f22b20f22fac48b3d8defe529ec67717c5b4227fed489284e8ff06dabbaf466241e7dfd0401fd951d75d36d2e30d0e590e53e283eb39a435472638d08467e93146d78f7d037e2c7df07c7f303f4f5e3eb1db50010100efa37a96925fa45a2ae3f0062cab219212e0105d8b1638c6a12a36fee7ff77478d23fc8fcdeaefb4d719e9752567196abdfc6f6e64d803fece726a2cd1462294835ecef04d544576f9d2217870fa4bdaea3405086c59216c183733ce8b9f69fcf941bfaed40fc4f1b83222feec13f83219b78a727cb475b7cd5bf5f179667b5d5706759b6b5e844e7ce8a2f4c49a4d607e005206e7a5293e6d09f7079fdd8f5463ada8e8105c9bbb42132d5ca51564ac4c5249b23f0e347005d995a09eaf35997340c24a24272d8a05083902aa870940bc946dbd8cb084c2c46f99b1b0e21616014fa1d51e7c03ba6773a7f7a24f4c7d12079eca956619c07a5e39ba8eed662b8e27888f6357ef14ea0df5e1260955abb1bb003ff0536f2f845c6c3c0eb13086334df1eba639bd6df2dd08fbc0845406d22978beb2a8bcd0f8bad59471100234e3e48c1d1a66ca533cce93d771c6247846046c69e1a140feb5c229fd148cee71d23a24aac59fd9dae51fe3329850c4e1fde06ae835a27bf3f83d4805cf4793ff4d0c9ba3c58ac2fd055abd2a75cd8f4902b50a9abeac6f339a0a58595214c21211ef8d31e044ebb7962286c0c8c7db1a550ab916302b962ed05def4218f81472e6cc3dca3f32337a4040aa73af0d1979d46cf5f2cd4dd2b4b46798df2f9e7fca4b630fd4592755388a64596f591acd5de128679a109a4445fbef689ca5a96478ed7f0e4dd00e33abbb55a82c60a29e2c8e497bbb6296f600fc076465c3f560e3ff91eecb360528f968ce524c8cd7da2ef19d42ab7242c9584efe5928490ad5a2a46e719b63c7b87d9397bd14e09d5180110d2d10be5d3be4b2314840988ed28124d67bca941e37f977b442bddb69eca110e525a266a756665c7f98d11f256022bcb3d37cc442d14f731325993dbcc57a3089c83bafbd015d0e0b0925d0160375ae64be3e7de8d87717bf866b3cf71b1f5eb26acd185be032d9e9cda670f61f63cdcb72cd28f143b1d46e6b12b3abaa9603f4215ba48ea249931c5ede4e08cc86ee173adf59de2209028804cfe1c8233a8e201daf91ea5d10c48564f6c5ddba1f942cc82f8d74b6423ed46b91c06bb142d2198d7e92d944843f53873e9abaf56bc34733be6b6eff1ce9e82aefd09cc47cd496674dec3f6f33c562e4d37aa38f232f92c7e8375cfbbf65a08804bee7c4ec79af9f1bd6d422cf2288392470d2c4d0b1103705a4fc9bee18271883137bbee6e7e4ac00448edf9ca4eb60cf8a82a30ec29778ffb04fe260eec20526dd5ac0a9493a34b06c5dbda0d3f96768506ccab78cdc46deb4f8be49aedf0235cfbaf8988694e55bc7e0c6fa845bcda3dfdc340e70bd7138c8a4e5490fd463543cc2a8667ef3f153019087df1451b1dce62729209231c966992148b669d2085b22d54d97451432667f24413fade0c229df795bbec46e873eee40b9a2bab23c09dbe10b91eedb2b273c09ed0e049195cfdd89b5c6e18650635b5ae9d00ae79162441aef85861688937dbb296d3f6adf902dd6aa03c9841e557723b448227b9d5d87243dd1302080c5ad926639f18d90ebb009ab2ec494412bfb2fc3f37479a88ce8dd5b98ee56cdb08a1982fd81031a6ff87507741ebe662ed6f32cc13b71987517adb1bc077b3a26103cd20446c19c15f1be42f166ff70e63b5229ac7df2f94b7ea823a4afe5af9a76f8de8ac410a32a1de4fff8c73f2c5098c0fa2c178a26518648baf448f186311a5af2751a818b9efbc04cba1674f6dbd144aa7483f2c471bc0c7c80e932cc394295c3cb8f68c9334868a6c8906aae4e9dd28b55087a5bab678fd1e9eb56bdd9b95cb167269ff42043bcb1cc3bf9f5004e2bc5c620b6ebb9eda1064de7bd2eea0414b81e98dc8ed6f1d17441dd19d12a6c353b8ebd00a954dc517f80f3cb0b9913dd06a73ad5988ad471dc68aeb13725f7daa20b8843235ed374c7c6944dbc98a93c7b6a53c6c04e79920c4923aa3619423aebb0a1a14a62f4c036b49f80bc26bc51a72b98213a5de13af70d36a85608245d01e2ea987be6c0fcbd3fff8e30ea3b95a6468bb66b14bba24b49b8c3eeda774ca1ff1e37e3e1a7bd75038d096544f5ac393bf0cf3aa1699f5066302105bbd0cb5b90ae658623207c1b3d0a185516acc473d7167e8ba269acb26654ad5c63aee7176494aff7674dd29d614f2073c492c92fdeb6dd66a60b5ae1848dafe5dd750d1403798b105eba0b4e3521e1bc4399dd04175eef9a4acd7af71733127ea085a67211e06f804390d1851f813d87f011689f42996bbc5dc625760d088c8bcfd35b492fc537d4d3a9f1437b422c98ff68c3c3d6a2d04c739887455111e9097f600f1bcc90026fa19b0138db705e505d395e30a0c2a157c0aec8edb7cc5d57b75ff526fec38cfcb505ff157a2982ea7296fa66bd01dd0c91e7e1b58974f1410ac0416e7919241281f09e965487b40c1dff69281e9d1c1b5e4fecc2d438c695af687f4e364701187ef9aba5e295a839bd33a040068ea6385c1222fe15a90956445936fa077bec2f6dd48a9705d8c189f28085444ed5c481e7e4639ba7b363827a7234084a6f1f096fb7a569f7c47e86021709949286d1038a7b2e5a20cb9f250e12de0d04ba129bf2253ac56ac70d81ee454a94ef18776f84f47da0c97f45eff2d8fe56d4378ba9cffbaa01ea073112d4d1feaeb04d1c5b49697c4976a42a37ac312c588e314712ea56875e2289b0cb996074babef8d87799777d6846ce8dc0e337b71d4cf1b4610d4bd34ddef56417177cbcc1d741b39e11b868ff734468dae24522d5f760a52bd2c78f2954292286321f2c07f2197317863b43d6c370b684a9c8eec0335b2a581b78e97325056108691298cb64074dd7e04545bfc73282856a3f3d4c4e4162fe05427d3f40cb1198b2836e9a3a7c044cce19ddbb6d8fa1477742fa33368c0d23a219c527c8951c8508de4ff10b22822e75471ddd6c8c70c4566d4881688cbf3b9a8488643b31026df418b11360c59b0c0ed6f0abc9057a1494551b081ae93629468bb6b76120f86821ea81dfae0cf7502cb9869acf43f512920f0ef381ad2fb0aef6e6b5bf85af95514d8faa6399cdfa475ac4f0dde97961f6f8c12434e44c4679aaa3a3ef4a791116f4683bc09f97b51226198d2633b148aed03c5fb476af1810e1dd1dc50932cc8496192bad0bca2dc6bb21f2fdd5b54c6924f59bace5ade39ba45cd861570a3820115645dd0bce4d8cca01a721628501c74385eca833fb09513dd178085afe850bf7f6d1fdd275867426d4bb7872574579e9566b4e1afcb4ede027b008bdbac772a44fec1442a19c80ad10576e621632254a2b3d938d2a9357dacf35e2bc7dc5020eabe9b8dffb3bc1a4d3edc03d5f134e26de2920141d128d2fd0fd60a72a69a3e87dfe14b9145b0ba476613ad45b143246d1e06cd5a2bd044d1ae5df1e2c3c6582a143f8f69a9dbe249a7c238016d58790fe53f20129752cc2776057c3ec4c2f06245f0fa82f2c56f17523662f10760f611a97cfcac16ad987f35f599b9e740632304c7624397c849f52ef53b10338604b70e3a3948128ada3d5598999c82809627bc9d6632e339e140359d95e0af2ca87adf0e90f01ed7b2766548ddcf8ef5ff1faa1b4f2426add0baa81841853fe62f5210aca489af79b2488c32880132ac11ba2fd21b22b809baddd83a201706f136ff97dd4faceedcb7bc73d4cb5a929a553c3d6bf2da570b18b3eb4d48539c5028b942821e0c8b77d275a55e83028a94725ce17d342610af97c898403ad2c26d0eca6e672d16350266df09b60a7b3cea64d6e081edcf6f5a0e2ab9d19d88bfba629c13e1c21d3c2beb0de664375e2caef18ab8fce2a5b576720ead303372afc331ef88050537429829418739d932db16d644647671d446c111cd02fb9316993f94f638d97e40a5995dc822e1b993177f94c88a8eeda00889d4dbd24ae904d7b4bc5b41af9db1225fee68d40fe6b2548d5e7d814abe604873beaef2e069d58625f58e250e29007554e913f94c7536b7e63c9b679e6e6836d62eea92e5e16c6ceca4cab77c79c68c4aeb8159c984ef22f04149a6ff4c8fc999370529ae4d854694786843955584fc7458fdf87538ce0165786523c0bdbdc0cba86c1c4a25afab21604cb9baeda1961f493e8a87b4e9a97dd341226d52f6d51377f84043ba0a6ecd489250d883762f11dc73765a5acc1a2dc369dd215180388706ba4ea5f266a2009a18e95286c153ecc0a4d026fba5ad89da61f2171a5619f9aba09b31b05e6b4d04824c930008264b2268a266a437fbd4d4378f86b2b7264882d49f193c7ba78ee465ed9ce93121bf9adf822f4156f3b5e4c8f2f757aebaa1527927358b2a3705e3a3316352c538b92725341fc44edee4cc0abbbfe3ad3685fc2e885582b05f497ccaeba6c0630c29d4eb4c2108e76b2077c51c7cadb064a338f6fce22ebefa2428359eb4dd80bec5b12a161ff7d9bb60ae729593a7591d4eb13587c29fedc8ee7b5eab5bccbdc5dfc05302e0735227a1762b1fa5ce5b41037479adc70715790105266a97dcfc7f660b55329a4b28842c235ee97ba260a8334d5b6562895ef430b85bfff710c8dd6f9699c8b765ab876bb6fef7bd35ddcf85ea16ac092812d7cb5cb789bd9e0a626ceaba2ceaec61b842e3d8fad89144a9e5e0ad78b6bf282d9179fa5687f88842501efed4e4830600239ccf79d58fc660dff55ceb8de98ce4dbafdf0575054deeb3257694fe02f59acb333d101169a3a7d581695b907a84e44ee7289484285590e07536585332521d20602f35ede4570b7381d85179c2a8e021b0110e6bb5db2aeaa355016bc131d99f62950cb0ee080b582c6980b4c87f57afd3251e681a45d7b35f3f77862e72b918eed1e68970176814bb62372bfb9c6e0b2a35a86ee395eb7537cf146e09c44ba169208f348a7ea64388b2dcbb377339d4c8f334be74eb27a7f0b15a4b367af47f169655e25653d534bedcf9a8dc96c691ccb5e574852b60c6ccc536704b62729f141dc9346cfb9cbc652e1a001494b21dac7d4b179424f79fd3f9875c2f95ee997c18c14d550ed003bd95c14268d72526dcf14f16c46caf418a42f743e0c77e59ef7c140da40188af7d69ebb328bed9e6910595bb9bb887fc9909493b074bad739f8e7625da950a46e1fac3d5281a585b93be710bb82e01dda1b83c04c471cb95f6ab0b31277070c72be58083e87ac736f88891ebc7fa453ea680bc726392ba6e6a4ae3d83995e4d3fc068341cf866a1c1e2cd3008b108bd6a6d976a8a19fbb401afcc270dc65d0c864eef59d99195bcc79f62ce54d929630c149060a483d56547b1c574967802a81abcce1e8c7a325fb1f6e86699a89c580e28b4cf6ab325ba1ad16be9c148015569cff00d10d21a1085f0e1e9dac9a7df00c726ffca6b44c44727fa39461f4596c96e4ce9a4e4930b5f56b7a6b4ff136ddb1dc3b2923cd9ed82aa4393a8a5a855532216783c5b146ecae36880d60a9a87ba4f477b4c7d28978943b42fab571a265f4621b83a0dd845d9d348af6633619a691f9ad834ec0f7df39d4c2b34ae4a878e423cb57e58267671152cc2dffbbf2f9abc17873134a4fbc0b929fc6b4c0ed8cc4b4380ae1de2282351e600a44d9d70fbbbd0e9b1d888d9a5316841f2326b97c43768dc5d289c40d9321017474fefab33bcef59ca30ea1203cd451dea0af7e3a27bdb1297200ab4200aa01bfe37935b92dab5fa1215040eb7f0469adeef3651c590396cb6ff72973f7e0e000f02efe0820cfab6443155225addabd3801ea74be521fea1c2c734d3270d636506a587c1d9d3bbecd6f1dba2738fc975a64d7d308abd80c3689fddcb2ac0e5ba5c15705bd7dba721d10d68791f34f46cda3b3d42ca487bf4e9774f4c81a203de29a61f55f97fcbe1c75f45d8d9a99d9bb4a62c9f437e1d9863b154e8e809fd13cc33cde5d1487a73b65cb58fee70114995d0fd3cc28aea6999cca8281e6c126ce04ce99fa16648177d0445d8137882ff778bf12e020470960e13abbcc0a414a3c0f1a9df10baebe310505018d6cad3962aa21d2cb41f513dfea468e93738fe745d996e1bf012280dc898f0484b91c91bc8dce31e711ab963708a8b5cd8b9e17b61c7660e6959b323bfe888613f0d61ca079469015c3e896bda44f4fdf298bca574232776c23e9d5445251866ba5c9e2132c07931440ad2a4cbdb511c64f6a1fad9328baf1e9cfd95ff805daf783c29a1f9291a90bc10fd5738cfdb8d6f819c9b23b1ceb929d4377a8cc14628db5f2e16f8301c0f23c9ae683882a1df6b60560263ef7e5e7e39b969816a90aef32dbea70e04dda89fe1b73d5fe56ccd6429d09df89fcce3ab2967a5041dbdd96c88dc3f869d0374209fdbd40052318a7453d39461f5e6aee78db562e06f0e50e9e297fdf033c0773cbc79b7a985cc77d91bfe975571e091471c10f80c6527c84f911a47c08892386befa1ee5c312b6f77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
