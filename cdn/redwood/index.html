<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cadec5dc53e11402ab92d1bd2a2de2300ff61eea26bda7951f794f694a5796fbc656f430dd68600f3c51d0bad74929c5c8272b06024c01428c4a884c6aeda586613bd987026ff87c501f83e9198c8bbb22bf950acca4d4d95719c5c28ed086ad381d6b730248937e997fcdfbb1793671bcffe0f0da5e2171babd60eead19e9e6e6af13fc16549ebef7616a956f4de6ad27a97fdba945e63085db9362e1914159595492ad931178928e21569b748aea05ce315cb74c74f689d17a4044bce1fa6e5e58b9848f9093433de42f04b9a91e5133c4fdf9789c6ce231bc17682ce4a16d644dcdd9557f67b51f26692e25164b9c25835d6fca516afc3a60afe9fd1c1a8f409374dd25c011e8213f444975dc76964ccd704c5512014413d8d5747abcaa2f83afbd06424ff04549cd26c028e02147eeb56216c669149b522bde5b10b1a2313a2745a1d6f19660ca1673dc09a2fa09338962aa12b5c5e35e9bd07a17e3d322ed83121cf231e72e5555d929fa96425267e47a1c2d584a6914111d6f4e1200de6514b4e84c6b70e2ad7761c12f1b511fc8a2e672636fb9d374eecb5f829091e513d347e0cc71204df273d917ce6461a3567555f97c571a1114a11d3e28cb164fc1de482cbd5ce3cebd5a95d77c023ecdb0d62b6af8bbc0543a1f5cc696bf2a6ed1f96cc424d0983d53c4a356c9cd8b101ff145b60cafd91814541af2b2652d10a39b5f62b558080816dc5c84fb85b250fb9e5de2d6c60ad6de8d644b9ce341436490f752542cba43cf51de4e90bff40cfd7732dca2b5eb93c01f18f7ce63fe7662c10d457a6cd34663cc2aa4e9e649932a9d0bfac598605c52bf1e056beff513e56105f5a8e0d4beef93d68f840d67696e2240a70e171adf4bc2f4890787ce5dbb3f3846275954f6c3b4de02cdb56895d20b446d4154d16c3130f12c5a00daf9cf87b45cad6b23f79f616ef5a695d193a3fc7e2f2734a4c39f33c5f962c1ccc2319614c7f4e7da98c268d0201b7af833ed298b964e109651b3f51af166b24734ced3d4777f2d081a1180ba7e60fa1b583d0315ff3a61a8b635dc5bfa2996ab0491a2349571e627e3aacc2155f74400883824832584189b0469247999def1ba5618c2c3d70f63f8252729ee4dbc2b9e3886d658c34ae18ede69f875a981540a98e8e3bbb1cd09947a560a9bfd04843a2fea82dfbadc1e46746e879747a7be9c7299c7d0ff4b208ff68b5d72991b0bc6049eafb566bd3af8f679bedbefed58de7401e07e736efa9efddb4baa4d56172dac4c0a75f92eb313bdb37d35ba049b8c83b33e0f7120d4a147c478d400096f321d560256358404307e2ea03ce3fada1bda67ffc48b88b64bb095ebc7fc53f47bdd61948be1240766ed4125419cea14d37b6a3dac747e5beef8795caafdca1f01410c7edddba0772167381cf33cd8a2a3d6fd37e01b6eac17478fbcc58f4f049c941a9a0c73aaa60b86968644d8fff0bf8e1fa561538b4f9c9776550b7696ad3a55abb60142a22fb6ad45aab689b1fabcbe071d632bdc7baa01e7d77376677b41008d980422f679c639d079bf33138c9c45cf56e8b17589f368de3db5d81a74e7704b2564c7c7f7f88ff811940cdcfad75c9f13ca8dce57c22b10925fdca939f6ad3561daea1f630c60a0f0d57acce11c8f6fb165a5a9192d1c3c33c187d3c6fafea5dc2ab4df9d81e8bf37b6fb50ebae9d888bc99dc7bb5cfd6d3aca4352fecbc477ae69dd0cea2543daef7c6d591df3d0d897fc414de7e72d09e77a0eb34da57d37897290c4eacb53d75013a43acbad36d6a2826aebced85db72ebdb836e13fb86415af1294c4ba2925883a89d457f0cb1f0e325a33344462faee1692c142d26300babab49a526948f71f154af5ef8353d99e4427aaf134fe8e92a1f1f6ed63f106e9c92827338df4ea0d83a4faa619579467dc327ce8eaba04b8e8327d3cecf0c79e61c62caea48c283c444b3852fd0b00c75ab16d466b1863c698e8183eb8f0c901415ea067a442b26305f7c1e921a6639ff7a73857fbff9d6075ff41e651b1459f9511937add3312175cc511e7cbb7e79ea1ebc7d59847aab5c415eb8a666d7193f7db49dea4d0cf44baeed6d35ad671fa78feacab4400ce435d517030295ee0b00d48fa163e50bcff6186b185ec2be873d427bc05355b861d6f72e1bc190fc45d96025881c29a6e76757d0292cf71ef2dfcf1ad7291898ef69e017863a9e9603805f712ea6b20807a3c5efa042b340fa6fe30796cb5ed15a529d50344fb8e256bc893df137c9b252c427b23cbbc883c4170e1db46af70bdd25fd454b6fe6ff4c6ee5f0640df03c03edaa9a52f53790785c6a0c1a5fbbcc401080dab72e30b0e0712c5c7b608f963c687539abb5885371ec1821cb8fdf9ac2fba2aca6fa1b0a7a774a0a9e70b5ce808b3b6211db3efe4fad516ede904435d23cdd41646848e749381d80457b336a13a71316b625f436079c711d7b73f9c9054140e52467e2f8c0c79edba28b720b93ecb61c952dbe6aa3c897a2f891ae5f7cd885bcaf541ea15b72d75f041ba4b4cefa535cb6b8c984f88625a3bc4497cd2f457a045a1a8e6caddfbc1847761d7ce252a49c6e9eb53027068e8635987759d17647d8ce3d82d3e5aa62224a5cd46e8d1645de042d44ec6402738f0d25e074ba27fefc2284105541efa7b374891b8ee6de474c880aeda45bc43e8f6659c958fb1ba5bfc69cc59a73fa7cf7d143604c10585befb58008a378a189ba9b676e9f0a2e230ef69187f6f71b2a4be048ea3af658b2dcddd785d79b94d84983b86177a55da20bc0a78014d22b97c551c4db8a03dd205aa98759441229a0fab4fe1a66dc16224361e7b69d0b90b46c4acc4b7fcbf12878a59924f0a14ea5233ad36f0b3561932834bbc661b8b4dc5971bfab7c3ea57c6cdae06dfc244dee681780e287f1c51b66747f8994c7495e09d6dfc6d09dc2d15a771e9e02ef35606eb4db842952d114dc94203141cb6b15fcecd426b872dc0ce8188d95a063c311b8500f5e051a51683cda56c0e2cd0c58c29fffa4a2b2885d17902e2ad8d2cf27c8f140402b888c1cdf8ec8c3689c249695b9ece29e17b21e674519a7e855154584abeecb8b9a20c072e652532f4e4744ee025ab8ab77612a9b8b75bcff56e61af4ced5153619a66c21ef46a4913006e59bed956b9b308dd3540b768be72cfcea55036c40cf7725edf64490c1ffc276c8ad8d5fbfcd1f725d611f5cba2a7ed7d42c32609ac9fcdbeb211e52cf2bc68bdc74352fc6b674c000d5ccd51ce48b0c1abdf88d9b8202b99e779ee2f36041add6d69cc03382552ba282756b2cc614e66e159e8921dedae8b53ffa7f0c8040d7560648031ea4876af0fab9bc49d701a430e8ac0ee9f02048e6f9ffc7864dac6f7f50c91a976338b2322e680592e03797fa25e1772c1802a1379fa0f90487a1cacf504260116c13a67042fbf038323510147365a060a53272fc3c5257baebaeb84679d550a00d1ee9bf3f80a3cf52c1fe76b294227b53c33def40437d94d7a75e2908b37165432b14800540c91f5e1a4eb59b8045ac399a095a33e2e11fed38052da772a1b5073f26c5e61d0cd6d24cbf1d2bba9fb65cde596341719ad6cbdabda160bfddcf9203169b26994d78cc2ca4f78551ebf06e0ddda016859fa776d77b53d76e4af1287bd2e08b176c2ec1b40469e9b9043862ae1858a9352134f847df4a496b0bd1521b19a018ff997b8bd9a91a271dc19c1b47dbcd3278007b893daaae1dcdab7b989d4a3e4fe626517a872411cb0ea7ab044acf8efc96fe2d37a84063985ce8d2f3effd84ee49b6ed514f8371a426b8d92b09dd0b33c0dad37099c3ac5864d53ad2fa243a9ace13145b7d74c34898f08874c244c782909d7c6c5f0029fdc38801fd5fafc5f7acc80e69a71d384aaec47f9d22a7fdd80e6db5cd0c2ce5255eb15221f6bb494c67daabc1f7fb0aeba27e53e1d4f9f0ceeefd182789426491ebb9d85180d602f45912828f031833f43d27e12882eded4ef39f06b0e03aff7e7585c56f4bbbe46612ede79b34541bc0f1b54c13d096831f38fbba184358f2907aeb8b88b2cefc4aa3094bd371cb78f8b9eff15de3f4b9b15f0a3f988212f7c16a859397bf4b62025003a5ac4e16aaf6066cdd0787f41767fae46b604e57ecbfc9b28cffc5b4999161c7b10cabec9d9545b0080bac54bf8c1733f2760133630884909e9ad3f95a6a6fcf3140f884926a011505d849f0bbe570fd903f38f4ed1dde83f487f1e5c07eae85223f293d992fbbb6617bd7977eee33470a9e4f4560039def3ae455bf2b46cde50287fc1e810ae733c57811fa7bdac691c73d383f3b7449efee84f233ff5b150583b7e6f44d553498d49b67d5228250810181158d93667d055bf787d72b54dd7db7d648a8e20c477bc8549fd6b8829b4af6dbef02dbca6122640366c34fc2696e2d4d9c89c568452b07098f9e5427ac6c2e86d0a8f95d9ace8c6b585ba0fb3018101c14fafa0b4ff6e2b1d88f8e83be727577d6509bc4b9b8359b3ee770c966784b9f1d41706d6517b57364638aa593ea72fa5dd890b27765567a295c8d0022e092456592e6bfbff819ff5a7517871638d7d4bdf691498036184e76615a0a2b7d5fb90c41c3d1daa7be0404fd96e4759858089a015c2e20d4529818fc544b3b1b564e8cf0ccfe75c5d624e2dfc0cdbbf4ec1be45324df4c4e497a8b3883fb117ca2020fdfb64e1a46ca634e84db18f6d827e1d7b99b7adc89839420208c99473cd931ff370cc1a86ee9321d224a25359ce151c9b35e6b71314fa1ec1b6102a411e8b52d93ed4fc1fdb973a5969cd009116493ddb9835e8973ddfa32bd6064ebf21ad99b00062ec3b349e36ee74f6b53f0ddcbf3c81eb6aa82c5e6b4fb0350dba954a0477b3b1b0c55ec0925cdaf47b77228583029ec0ae3f52cc248f29b2a99b2df1324c2cf87235901530074c32f18aeab2ad94be682937cf6efbe86a6972dc8dc8bdd45a132f505f5928cb83884135df2ff7e58fe7352d87a6188e536ba81b755be22d00797ff8450fd952c9b2905b1b430e4c30fd579f5833b8791643e59176a5b561bb5f97ee1d8b68510b72736c5b6d7a37c66289844cd5dde5230fd826880e51c926559e8fb44f3590e4ca8e7f9884d31891afc7b64d9f622cfa7f75bd75316ccb04b9b6b548c7a2648d93cd8d7ab727a52d468bb6d382f2e73e951cb5e4bf61a644a3c576f7085233b441039e0621f06209e1540810e4500fdab562efc86339540403b8913baa46f1a32a30a3378c7d5831869d3ea575fecd8dff8b56140f0228144e1e26e1cafcb8bfe68f317c850b14cc3a2af3ac7ee456daf0d0fbceebcc020ce801deb6f449d311841425eaf3c029f150e3a13d60835098e600e84b2319aceb9ca8ba72f152df40b8f4299de625f28e449aa6fb214328cf1a575dd9bf1adf18107c026daa2d450ab1a439081d22cff0386767c907407730b81cd2c5d0d7678b9298bd00d91e5695863fde8362ef5830174ef39273747163ef480cb65659ad37ee7891099228d13ccce1541f872d03b63e26890f9f0444b58f21130d4b0b345289ce1861499376cac1b3bcd652e1988007e80df6c59567d4c22787f8493277221d16a370e1052348fe908b288b925191e7055523be61b9211859f17fa8d1d755193049f9c531a53133ed65d398d92a445291fb535659d4afcf6cb657277133eb18a7a2a8a95cccf7bc61f959bc8ab2338041e56f8bb4f8f3c20a0df5cc315b94d2167bf1514bf90f580a635b2d3a67bebe9bc06ad78ca254e4e24b1ec27e740d1f33ee3b1689677b72d4507e53fb034481455012dc0031846f22903c2cc6b5fdcb77f9f8c418ee87513a89bf122cbc1e4f59358fb36d62bd35710f4be54771e6e93e316de60f179b2f143d8959bd5a82c7aa29bfdf3b440d638db336271ff9120de4bcd0585a62c3ff02f5da2b05625f066b0a35bc45384553acb8b18269dd0fbc4cd1922b4674401976235ee6885140e68dcef2bbd5b5aedfd0a82876bdc7fadeb88be58c7de81ff216922d20ed1c5a22503310b0a3112fd1597f266da3131891c5cfd9a5577405354855440bcf9d36df8d5f1e4853ae8ca3d677d7c535187048ae5839e3bbd7f0d2bda74b8d5f9a5946f5c3909530d81dd4e035bc07e48d9ecb4721e1e57eb7855e6ac0c1b5839f644ab72ad054b1ea8aa311c37a7481e465eb42e9d4cb2c8a3df07ee128171badb94f2b297c6f57b6e899fdbe4cbc90e86d27ccdcd8273703a90be82c1a71fb864cad3c689aaacb9a3a3c69f8f39fba1867f2464c16f84b79d4298e83c522035d8ee118f330ba0c9ccbefe7fddffde05b812d45fcd3db699b7c160468f2892c42ca1135f997d5849d35728f4fdeeea1260c8add2a36d28e7f7d79fe1515604632a4d8c12d61348ebd3697d9fabf65eb8710914792399850f6ffbc8ee7ec43b682cd27919f3c49705e2e9fd0d015652739bf8c7cbd5239e76f19c004ea01d91df5266346695491fd1bbc15cb8d9cac83dc107e0c36f61a18896b2e83af10003e92678ae36a359fac6dab9362feca09799e7ed8ab39fe56de1dd3e13459fa4c81bbcace5c0e8e24f2749d2d6fadb4cf8191feeacbb2e9b67366c45d0758e4d9670378b1cbdb154370b8bb3416f00544933e8f6d341dfdc8a3bb0994ce9e115b6b33538f36aab19710d76d11765047489111b4663fce6acfaa89d590d9ebff809b4efa6ed551e3c58dc03b37f3c8254c46cbe79220f981a1b53075b0758fc75a5afea652fc8813d809c7f8629fa8184343f6e46d91a737869b2873590c682e6fe79574b18998731a5826271af53f6529b7fa7d26426c1c19a96f9b49fe95cee02e00f0b381d4b9f0ff70b4b526ccb4da5c9cc50eb421c533d43ad37311985794f6c6b121d69adcf740bb650953402b2226d7db0981897bfeaaf903720efacbf6649cc5f53e3ac75109ffa363888e53073bc9788635db39ad7c087fb9cb4ade446c0fff1daaf61b8b65db0e084c6b8e16497d8f4f6b77815ed4d55f6e1256984cc14c946da36c5ac095ae1077ec4972873cbad0e3d10fe093216c35b29b01ed6b31afd584f024044fe9fa1b6ecc17445c39419728604be171faf0e72f33656dd986c4c31111af7a121a914a31b693f25b5ce9426d028e1fa6e7af1066c611470efb8862938a743ed973963545832b9e121428882c004b802b74a23bce336313bd616a7d709b16227023a0520044038f228903fec44c83cd329c54d1cb39f59b218bb3edd6f6dbf17ba12aa9467a27aa3c1a0981349cb0be3d61b575956e338a873c8f61a81ec3e3299b8b908e21206d3bcba8b052af8557a55fe1dc080d147d756b60fde3b2da8c747ebae5c0a4ca3ae35678eac31663d9c87ba6ee258a1b45c3ba70fca389172e939731921f4f69eaf6ffcbee223953423e30c8b355520639c85429e97cbc7fbb7e156ce687b6a79375daf429bae957e764a02f3c4961f3a1b0b1b01d187369764ea98e5d6f2807c75bd15a81f1decdf2dbeb054f408c2d24b8d9ba4218c26946e3c11e5b5cba88ecc21a445f0057f5994fe900f5ed20d52c0fad1488b3f822c7d7cc576181320e20c603fbe7e0bc2046247112b4feab82f4032cf6d71269a7132fc76a06ea12537a283444d7a0cb7b175d3dd8b8e6f48a856d081819175ab54550ca93fea640db37fb0cf7a7b1299fbebb8727587144e5117716b0c479f386d3a78e1e8955b86115e1fbeca89d8787ce622d5d548b5a43eb7712373b3cb0a930e94e0fbe92e79126c35675d6ccd8e961dbb17134f5cf21fb468a7f35230df9c1a9bce00959b74656cfa8b0ad123900fa7f7855b1c5e83ca70773e93371b307b04237057ce0ca7f616affb361beee4a3b1cf5afacbddf7b0b321837cfa1c8f0adce6bed14a8f1ea64159b3c92a381f89eeb0fea8b6d479001a75f63d928f29b7c5e59632ab494a3d1a5dd8a823973d79010e5a6e7584e069e86b80468a24e5a1a47121b1e3b8285f889a03ca99d98bd930fb8eb7402164202e9b4d3dd8cd406297f852bea85a5c018fe09b587780c842c76ccd56a9645346c5bc84f0c9d0e02e89418574b9af2b5b46bc41249bcb257afcd24a0d25e751b07f6abfbe607b913be8ce258068f62b72cd85decd17030c4b7da61bcaced3d3c83df453b356166ad3b4ec3d9d840c1213e8e14f19e79d16d1e0dde929421ef63c97287f090a655a35ba8c2f17bb680babe9adff179dcd4333820cfbd346c236102b3e6f74981a128b12712e851e3addec0297a87e28a5b9d9a7003519c19d42afe4a872a3117b539926a1d1fce5aea631f9165324cab855f0ffb8b9e5fe18cdb22d7484a4e30b87f04928f0d3745b6446811e4757ece6ab2aa66f9be47c9040b54fdbcc500cf35350408bdece8aa74da3d7d3ac4f6130424e9956461c7b2a7268e40cf5433176e350aa89b6d1e6a742563f0c0a6f6de7f6223dc109afcc7c369ca4b6d3988efbc4fe6c00d38d43c6081ab405d5a807c911a2a3ee2508ba9e731badfe4a0dc3509aad838a6efc8d966b24b6be137c70cdf53df8405b05a667c8ca1b329b23fe0377da2d029acc71cbf75b381dbe5fc725e88f2f82859f66b2179131ed5f20c56265f08d7204cd3b91e66d93c6d6d3f34931d92c44ee880f764fc4130b1706dc79ab8ca0aae68408d15b434cd8c94b609a4530215809be47815f7f3bd36b8ca2d17246a73e4a307e85b21648576739c63b41825b6d4488f11c7b1f8f2efdafb5330d5655c4915214a064f5fd40be5a0d4574a7f65476f4e9091a8da28e3350ae4c5a6695ac06f6f4652ef2790078f2a5927998cbed63bb941774ad142b02de1d1dae6e86a874161d3168883210e846ef33891c6029c0adff6d3df4addd00dee4fd4a9638f6a83cefab792a11141c7a8011d453d00df82b826587338328f18047b5e036b3d4ef4e49849ab1fe1dac5d2d808f2a28bceaad96eee501ee1758e345e9869d766175e47ef8847533d70ab253f722768a037b5b64c20f22475d7d360770054a449fc3c3319d6827906098880c6b042bbb6b83fd0a4ceb89ef08f0f487a4f91308970a5cfa2ed9ec59eedfa31aced8e46210284ec9e249dd42098e256a33952d0e4d1ad88eb88ab3473d035578be3e443722fb319e0c9da8335db5302199bb8810dd8b61c7f6046689ac7f20265041af1738b78b97cb32d7541cc8c0f9886704f5be58c7e91bcde4ffaf18b67a868c1430fda6aad629275012ca0ab8fbc7a9c94357b11d88c44fd2a05b14a0d3fa7e555c541885c90de1f810ad67b070051fe7bf63aaf27f36c20442cbbd00c1b662edaa4251974fe6c91d4d18ddbc44f903fdc43bb915758f66cf2b9d56dfff6a3fda2ff2e1d013c2b1de35f6bec09d91820bb00a08c555903489417ca1fe346d52995f0669e640dc1bb480d29c6208f7902dc77f8ccbee3038681abbff90a836e2e495ce701509a8fb471eeea06c032ca6919f8538c301bc6125bb6bd2be96104a2826ea99c629623f33b14903bafc4419fe76fe7b991e215178223176c94f60a71b804878e7d6979ec0e1b566c72835aa82fe955fc355d6ec47766ed4990307a56711f05eb205dd2a69a0113ad2c7333e06c4aae2c6b915856bd869aad150752120db9fdc0caf1e5aadd786a576b3cd8ba1824739121bf0cb03988a2ec42ba9d282eb383afc13485cd2d66aaf57162f2846f599f7a858c7b892cd2258f624db0ef4ac8d210c3fc0961f514969e69480deeb34e8f61cb38898eb1b0b381057583c6bdb978a246dce1aa340dfacd4c445e4c2e340c3282f40d11a3fa03b95e342f1a809bafd70a681ab1a6a15d52f70499a831f4503c2fcf2fd15eadfcfa03e385b809c1b2aa19691f3d438019ba71974f73ff4484d096b31a145974c5519349161470f5003a50498d45d7bb4b0d24a848d8bdfd04b5a89faf68000071d3efb49ffd1dfd0f38055077de48db6e1b2d622baf734308b44177b2b1cb194efe7befe5fb8acdcbd2ff72711dc84c25776ddd7aec0460de24a97c7f8a7ad8596c4f70d1ccccac2a5e2158e5d7b6a5fbe48422ff32bce826eea0e655b9eb40d4e1e319ff966969e3a0577dcb9baa607bee46612110eb3bcd6b119150affbb36d905a7f6e8f1f6419985a1c4b131b56eb05719190ab815ac526adf15bd8bb939855ffbd80aa77d4f4cfdbcc80f317141c9eb5dfaab4fb6dfe785410adbe868214a4365421fa39f9dcc341596b332e3d8d706e825a313c3d14cf0c7b2d2af73c5baf4bbf4fb3e11c18dc4155c15e0202ca7f209aba839498fe8c9f0ea62c83707099d278f600705f2c4fb25e0c5ced278f874cb7cf129bbf62b3cff60236c0d6e2c8461c7fdbf6c52873224dec69cae0b8334ee688309df4a84450ed6c1b980ab9a9e48a893b0c7681ad58cd657eb0726614c4d8a402385a4236f5b47876d837eb722a8e2cbc882e53eba2cc4892c4c89add921675897f9850c784ef7c4476f270b28a42afc04f1bb2e653fbeb2ce2ba7aaf6f1b436bb31cb5612a33a44012aa2e908a36961d1ed33e0d6dd58aec93358e400cf092f954bd09d0352552d3ad0ab4a855062720a20a2582bb697f299b0cbc7973909354f0779b56125211dade6c8e14a205f63291ea987673c5f42486e87d2dd384122b066707106dca70f166351c821c26b0dac4ffff73f95d348419276db56014865bc6c07c2aa0fd33f167f65447f6a29d5c15851fb14e2d97fce0ce370f2612fe0d311a27e6d2e24feacc5b169103157dbc855e53e2a41d009df47dc39357f26e1b804a9907c899687c5bd2e3f4b13311ed607096227244c903d15ebbfce9869be94af9a1890c58d5d69be696940d95bfc5fc8c28844a8e6b81593dd7458fa5eb5aa5862c0138b74b1abe1faa3ef7ec5b0bceebe42951247ad9bcce3216baea14c4fd768b8b131d0eae972acf0929ff03a46dc8939f225d54b78dcf137c28e64c534384cbad8e3abefa7e63d17846ad2061bf94ac5ddb423a8a66615fd5a8f3e13195aab412debf6a2ff3ca784332b6ab15577c1f36ccf65c810f5ac446b8802c82484fe9d97712c84a7448e03f522def04d25b94d233df13aff4db5a28615368dba0e40933b72f4b6b9b2665411dc74b4c05448fae9c5fbd629b64db0ba4ea3767cd0e03f5f8cf45989ce7d54a9f7b539568a2011b91bd7758226972499bc6ee04390ee8a1f348f9d2b3c137d48fc72d9bfab33c5def8a37be3f048e3aafd4a487aa360c63c906a774e5ac5755d8981e0ab1a994a2d7f1ca5a7fed99da18a6ab2b42b682b69d10a2446a6685591e984701d7dac6b2eed685ef035617cd16ccf58417fbccd6d8be295d64302b72d7c3b2411bafe22dc077eb6889650a5a6d76a42a9fab0ac3fd0816976644a84a8aeb04f1ceac3cdab25482241b012c21d82d66d1feb1558e6b71d5d789ac533c3672fea587a4a7079f3755102e9b867c2809b1004873032838bdca9ff8aa963f8d227cadc0db816cb66af1485f6b8485888a073ed842bf745038a943d57b4dafcfa6b91b85f9204171e3398566b954bf0faff35a5a2451d82abd3d4a360468f3f481187c03e6b4f11ea629f6eb414fb125b29223c436993828554cd2158c83fb9b8346bad0cbd08abd3a89d30b297506bec81e3f2b147775119d13aeaef6e3647d41735b9077f7e91301224892586fa513cc43d19b90308cb149cbe376e0bd0608207b41c917fea7ba1482a9bed3c52ecfd3365e468a6698d20108e3773a280878c846c480bb96b684034bb16456ce7ab1d41d3dbf59c7e5defb656a68e147028db7886695983e59f5980ff6b2420d8ac6979d21ea7873d10e15a8abd869e03ccf7ea6a7a50e249aff2bbe101fa5286291ae5aefddd75dd42302ca9f22f33876090bd7a98071d7200375eda307cd023ae0da68e86ba090c1a54f310ba4a663ad9011fb29f63e1b999541da25d0a67f88345ad54fc539cc11423239bac146f9c34a4a6504f63ff8b74a8f7db44dc3f7e766ebac1f67dfbb55c5a6e9a088d0ea1a4fc4d1682c332dacb02e5ae33ede637cb3c9695f49447d9c2f164733aa8a6d289b21d15d13893fe678950893979d58fdd39454a8c891acaf0d4727f3983a608bc7d0214e7d030ef909f0446c4d58918e146237bdecbfd5e9a9e9391a558da209510f01691e7abdd65786b33f79bd5b474561ff4c182d8e723302de39c161d1438a547b4fba426f9754aff2ef3f752b0c532225aa7eeb192e17e9ef82d861d484af9eae3b93104be90816b6fdfab0d3e71fa181ecd66ca03233eeb387d80d9e8a5753d39909c745ce12787df23580336572912963c0e420d7c70f80d42009cac7159cbb5c251fe3297d0fe2cd0d890629dbad77d04435d2038548c64cf807ea7b4e85e599a589622d1a118894a36b5ea58e310725e8293ac4edaa5ae904a5333d8bb6a83db4284f56649f197afc7b18cf83f82a745ea45d750db940d05aef950010a60fb2084ae81b863e7e3dca7343326f4889ff96cd58412ea30ff1551dc0658c542d9e4238c9ec448e5cac45e23a009311cb8c1aff80d64ec55386e52a62d4422f63cebd1e74695c6359b22ffaaed19ab80d7c3e62ab6e3d52e5d703d46404648e5638df35aed555cee49e9da63a53d3c8fc23dc4e63ed3dc0f4a49258a9ffe86344bf1ae7b83ccea51bb13677f9811dd7f6072daad45561118bb14309c3fa6d5d3b479510bcfa92380d3f5cd23b9d8a1ab553d63eab79fd03b2dbe370be0777c7e0e19bf75493697cf53a6bc8fd5c6833b776dc0019692e1e4043e408f191ab51ad7c7877673e465f3c3266e5f91c61b52ea9740b92709b5b3d3fc7b215b93069855521c65868d944bd1c3fd91dd3c010afc8e023de2a403027ee7e3b4ffc5d407276063fbafce57e2b2e9b470b3a48e320ed236d15773f1de629e7d05bd964e12c69be6c1d07f8b6f3fe162ea62f6da2d8bbcf876fc0327abfca283da8e545d633aed63e399f650770c0c88948c08e680c47511257a228cda07300d7c82e78284d26886304e2df784f57f11871776b9d542a34a0624f53b4634483c1f579fb885a60679e30a01d025d6e19414e571114531dc07c1f071fc0aba8fcd0867b18de09188b2c023174edc230208d8b994b0101eb57e85dc02fb223f26594cf40ada217fdfacf43525c5ce3fcb877b4b70b2b8f72ec9c6075720dcaad8a116a9a3f7b66bc511016c0e2e6551f4552120e988893f99c428d288da1f3a285d93f91c1eaeac6720554c253f397da524d624cbc1b00b749fd6b144ff024f6a7368f13aaf41edec0960245d85e272f593fd859084e2a0c79a58acdb55b1748281588bdb8331c38b49dc8da85480360684bff1749953df4c90498bd1c229183c5df47fda74533def82481b3a3674bdaf6be0f61013b1128254b94c41b9a8b9e0a5d53802c0dd6cf921937b7ebeb9df84c866568ec2780357b87ab7c9c90a3fc2c0675eb6b477bd91667553c35b6cd04ae39f915f683a7016bb0830fe5db91b443c422900c0b2bbc61f2cd52498d26a51c8aafbf1de91b2cfe7292fc43728944f55904378390a5bcc788f4793e527409800ef4bc46aa431b3f850f69479b0c7a4b89faa436b94f30f5ed1478d1d18357cf474f043b7b1fe308ea88b001fae2afb33f36cc4828400cd38d01d931d406b70783768d425ee484ae79eddb34ff2f975dab029b22d3378f13e9367ef5fd4025b0850a8cf3961bf92ad8d8ecc60aa32528d311853dfa9cedfada04779d952197c89623408f6747832b88cc3422e3d3325b0283f9b58b1f0828e0d8604fe92e8000578d49e7a844e94a9628d47f0239f3269d43df130af961ab5548468526540f4c8d071946c34a710fa3ef016d9566057deee4ef4c8bf843e6ea2d68e6cbbd9f71a3f7a364c59e113f56570ca0b09a3b7456868ea57022af4d61a75d31811b455d21c74aec35b51bee81f27ffeee19901832b27798532729a65e1e0a4e49be36e4b2311a53c626915826a4e669e11115d8a143c509870f852ea4d53873b01f73b216b7f9eab1f955432e6125c4c86cc1801a3b927347c502a3387a3a8adfe92ffa0ceefb2325e3c4cf60e3b5ed1ca54b80a85dd8f5889224afd268be1dc17e82fd15a6e5fea47f21d6f2fba93b340219e0268c60ac860a1df27e5a19eacfeb433dd4d44bc5f30d786fe30623bf3dfdc4d0c97130e3f6ab0008bf0b0de0470516740f3ea641d13780157cc9ae76a0edd05f557a5299527d164fe4d3af0e803c64b6dddf04807d697c0a3ccb4704cb747cfbd10588f2aeb11f083d2b2d8b0c33b3805727bb581b5ca6ffe9b22eae49626b74e63a35b95e61b12292079eaf876bcdf82b183d0637a233af99390b592dbb390df4498f0510d3fab7fc5c2dc1e250d38b83901c4f20b0b287f57ebe0fd0cb8995429fa91b780c8d7136c80c41540e3559eb7d1006b8cb03c15c74ec6536b970fde2dbdda916eabf06bcd58ad7c2d6c9499b3c90aee07a6f77b0ac881d1863ad29bc2d72a370702d3f5ca47b101d1edb4a31f566f14836edae1920896146f9a911a35f1e4127793c8b01e2b1246b385f88ba0faac717b36d070e2bb623ce9099bd1117d0b8d126eb1aa49bed82a33bcf5a387d71c54e9606fd578d869d9bdd6a8d69006a2459e38021fd143ec455ade98050357ea858b69d10bb0fb600ec7021543765e6edb1d905ea3b891f3dc6267bb748abedcfeaabb72e875aa58c34d62bef5f25f5d59f269ef087a0baf4c45adc01afc456826538e4e3484c2b99957304f2cff4441830780c41f7962786b6bdc9ff36a578d3fac9a9f96c195844ee5c748e38ca2e242945c1b9b0b2734c4f748f2cc6d8346ff32ee94b4b3f81f2d4c8ced17b312d830fe6619a816a435b3ab8efb2b35a685898ab1c6acabbf72c091e95a9fa219864bce7d477924ae9591eaebb766130cff8a152967d1b425b0924d9b22f66aba83a4f5bc1cf4da37bb78cba4940a85958d74b94ba6d58988b7b253a0949dd37f27a6fd44a7eaa50f1499fc75fbe708e5fa23dc98df821ce22c9f771e6122a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
