<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"209a0fe11f74087ee6c3f7bf8dc85679c05301d049077f09059ca85e3346f24967be3ce78b5bab5f7d4732aba7c1b6bd7030c13d07f4b38338c0d76690630d5b00b97d27482d1757b70abc9870e5d43135fa8dcb8b242ec0bcccd36c5fd703061cd46f7b6c8a237ec69f5bc45e70b69fc6b3e062d5ad6e97c330b053d3d31929c058decde232b6747147b4cfa3d6de4999ae6aaffb23195064334c3223481c2a43df8b6468d757c32195a90ca9dde4faf1316424a4fb68ae048381a842086734c822e4a3c44487bd6962c2cfdacab9a40b76ed2045a530b609a587babde0c1ad1da8f19721c43415d0d86ccaec6cdfa754ad8a69fa1628e81969d386d9548843f2f0d2c3d226eb6920a22bbbcd0971923ae2eac6ff7ba24817222a3c7563dfb206dadf390fca6e15a8f0354efd6c1518d545a251632b03c701bec11cd9a8bbf492bcfc7ef29e3e40299415834cc2a5e4d0a77ba5742a7993da7c6a5092ef93695a09c301429b5c3223b157ba75c035665e8e1da992333d4345a67ff6886603ad49f76bd6cae91de66f3f4f27ce838a13e5b0b9a43da3e0f0d1d4ffd610efc5f60b0bc13b1d869758f7915d9b433f16b3e4ed72c91f0eb61a153eb666c7a33824cd807fca83c0e2437bb0dee6bc967d6b777bd5a61c926ad54044ad0dff05b82872f459c90b4f85c2cc1b076fb4547f47dfd1993f61a63e30340040168af643c93822621e6d408665bfe3438aba35049d6ed1aaff3909660a523bc2dce128e5fce9416721e238a67d214341a2fd1825105184221096150ae0049781b4f58ef161326f90058bca52471b507b3e27742ebc1ffa22c0919e0a43418bcd5582dd7ab1344aec555be0645b0b49e0354c2798f8525f9985dff032385f17e6daf9a8e2e02f9d819bdb88bf6bf024781983e78b814024b985e027d104d597a0dc2238a20f8aaadaca1c1cc9f705b69409856ed5383664ff38a851de8ce55dc3a695a621fd425ba9c6d8ff0e23cca132b72223d9c20cc44d54c0f4bdacd3058791f03c11977e74413393700379d71f2c2157e48a3f648d2ea0263964a6e7d14b1c87c170f95e6adac39b10b027f6414ab62ff4f6804131349b62b3ff78ae734f3b1cc2cb6312973e2d5dfda1adfbea54730625d83ad2cec868a017442b19decec209fb3d27d2f39aad213c3f978cd3751406e056f23e4eb352f5c2af2ebb10bfc66c5ed5255e862052adfe687c78d92b9770f3ba1d2a6e76a258823d134c3b925e71a63e7fa74c5bd86274215e6712d760fbf13d4fd7e9760f885fd741ae070810752d734ccb99d4a3e7f46ecaf87b339d7f7e039f1672cb38fb3011dec0c88cbbfe76732391861bf1d2c29a571626dfe644af8ff583667b6ee7c2e385664631ca55cb97c51f758eacfaad1eb77ac6108d81a250c4e28a48267cb407c0a7627e68a11afb045728fc32dcf9661f79f0231b4484f50a315b9269e9110c233afae42646abda0e1d3c21f08988d06575984833265aaa3cd8063dc7df71346ca7fba137707e0854b398825d745616246e37ca89d5241440fd3d9cbe9f30b1e4f4729417fac3c36734cbdeab054539bbccea4d44606eec3f7dbd12b03eb974f5b5031b6ebe91296576ee188580890ee569f610fdd4713718c452cda6da70d2fdec5f572ca1e78e3a450ba7a225cb7aa878b56db5a541e17cd4e276af7d264a832589c691310782ba7bb306fc726976f4d3c240e32627ae1f16e443b9c053eceb3c4d2742e414dc1fe36fd29cbf3fbcd06c0339ab873eaf9b5fc5d068ba0b117cf706e6264a195dc8f8318c1ab54c58d217d31f4873dde439767aa1ce20ff015e39434f023870b83c6ead115d998a71b8ad373a23294af0b0f61e5a7356963370d0aa2bd5106d044f5c59d15b7c66b27fb786947ae726bacb29adb6bfbb9512dc1d881b544315de954336de93b3135b8727cf8f351d69a715ac344cf6b25db6b5e0bf2fb25d13f66f7dd844a74baf59a3b8dcc0b40b37508bdffd7a517ce0a003f0b64b56a29bf9dd608b79210ac52c593566cd3d4478118867a2764ce6e032968897ba5bdddc24c0895c1877c28bb9d6b30ab8d65cc5bedb8631a9f7c1b98348853d538b7a02a406e7f2ec989b212b65ff59d37ae458eadd3d934f3454f62451735b9d6c128c7788b7274caa527db4165b585f050d3f08cb1b8f5a18e17fcb2562ba0a6ac9616c8d18211b4c4d0bfe5a3aa3ea0f4b5b3446a3e1da9c83170e863fc00037fa2e4cd27c6399cc8244d91b68b364e1762c4344da5c59d95c282d2ec9fd86af1930a5e7645a2972b17e792a5aa5b087ba4c9816385e1b3d3c443bd68ab775c324e61f1082dacc19257e53e3326a2eb4afdb01312f0fdcb99973c1fef3ad3b9d8cf55d9ec95c1cf7afa287a762eecbd8f9e64303d265231a63f61932ebf5f629f33f962f56213a143c5b4bbd6e8b19cb3f4b0ccb948e6b281774302f0d13e833c43acea5ecdb529607af0ed419e2b5de15b0e1e3593fa4f9c3eebe7028d07f929caf1139b6481885ce5e1bccf0b7893de02d160eac1d7e26b7cc937818a6c63c6b956e68a572a9aca0153ccbdb41cc2fb3b4dd10aa93c567c2b0bb5390a913aad3974eff8d2ee6df118493a7ce3c310289656b017184a641a863ba49282ee87c7d382b8d137b85d2e169552bb0867c6662059f5aa50fdda1ca18eeeec3e6bfab71e8902ca25377bf4ca12248ad2fb2a38e4ee1daa06d6543472a0a63e6dd678b93ed692804d16c72537548be3ab4fb0557c5805d608e055d038f913e826c9326dd6ddf6699ee93adc95704f62574126f231b24a32d9cbf89490de31c4b78b96fc70f23e91a0e88ccf136d20bbec43a0c30325471a611e208602057fafc5bba1cd1a9292a895787512576c8c09fb59c387a38ada773a241cce260802c5009a3b96071848d940cf268e25b85e3c8c8d94af352e6dc950d65b3c9d002e86380236dfd45ce3eccf5229e795abd417ebd34067ff9672af9b47e35645c06272eafe053b96d7f5056b88c48945fc7c256dcacfeef32e2689a51a670f545b93aa261449e650bd11b9840440dffd97dd2f830a0264e4ee00af16354e6944850844610aea20cbb07a52d1d2c91cfaa261da42b611ee18e7ce03f53395ad18de5efe6bb1dc295891f78cc0bf5064164545dfdcb8f8d962413b04193db390f5b4f62cdd2f84305194e42b4a2d97de01478df64296651db333666625ba961cd790eaf46b3d6e6e2f15189724d056344a8087da71cd71579b4f55277067f58565717ef6e3705e183c5ddf579baa34a803c50625ec09852c4be8fe5c398f957fca9d0d406c8e35d5eeb9174428c0ccf3ab846c7e26793c52f276fed78a9afac2ee27ae0673fa4fecca8719b14fa7cfbdee00c91df1899beb65c1fa2760414941f908884c32a2ccf735a6f10f8f610d2f12f2657d5bdf0038ab5c868db50a370e0654157ddef112d7c71eb423006e10cc59f5b03b87191ed92c07456cbd0c0ddb2490de8141ef0761c218547becd9c909a1e6ca5c2a57a19ccaa8cbcd557435e41013061467f8ea763cc9e86dc904cd1027c8bfb8f5d80b5418d79472853b91ea5a28950a85ed5b5e02d08ae20f01cdf164c8898c3904cc90c95c05ad7a21f03636dd60bc0b37af454df72d8d834c7e644fed3e17aa6fc47866a6a0d1c6f6a16d641808953889a6677e469011aae8827666849a9d12d9f7861e56ebb4e226c73ce1e82639497feebd8b692350834c8b2f1900defb7ac93f8489245584fb288a6b6c1d151d1971ca7be8b57cc163b95b5366dc541455a33f2aa85d8d21820d844d77d5b26e7c190fc9f75a4225a1c1291f878d3a8a888c67088c7a3b0cde70892ec0c183ed30fbb1e34c09e9bb5a469c0cd4363e5a6cc438fe420ed39faba380253ca1c4139cde36651ecaab3ef8f0e91644da687c59548f0eb833e3cf3bd1b9de4ea3b8250d9d0a33e4ab746fcda3bbceb8b6bf4de9bdf0caf69095a347de967c0130fc36031ec1420364971f7154eea4697d4f0dc91a72e4ba4e0d1d7158782b2eceaf7e11a3013534142125af353b4319004db9f0d5d801a4c918df629b303c4a3bcbbe9880164fa26ec799b8cb8136392e16aa5269ff1b741af77e37b7205af5f345091d5775ba1ef6b076ab8b4cbb7a2ce9ae59deebec09440909fda6eda644dccef330486e3406c922bed3fac1831852e32af471f512daa722c893194f0bf20f4e7e3e1917e1c50bffa5219274db72217923464d789598966a0b15e2716ec44f6148c36f5baf11d63b4ba5d1493af23061ba4b74c68ccb61f945980532d375bca464dab018f471b7131c5d1fc7e27d207092216d6546962908e51c949da583c49fc4b7817c547b37b7735d4bb61acb0338d98364699af0e835833e7eac04712bd2ef9895a41c32439509786c723f0faaff2f177c975c40b092a190ad842b668223e54d3c20c7a3a023b801014a15e622720fd3faa05be9c0806502b4a9fb5489c6b7c3344191e7ebca8d37d7fdaf56480099925230c8376c9bc9240fc27ee2e1073cb63a153e2d5f95a4b9efff8dba953463df7fb83787c6e77d3f99d591bdc82cd68b264400af67ce37489d8ceb4a07a5e7d32bb37daadee047b041ea6c6cb1b39872bdd7191080ffe4adf162f31919c1e1d9d3e883811ef0321ee36c79f8229a4fa9bbf4075cd86ad18f9e2cec60a7ff608987fc416e9b05d85fed9e517ccc7770fbdfe6ade548c9828c8c9b248530f9d6dbcfd6212df7048560a9d2c5a9e3ffff83a8a7fe2c3f21df4ecbf0d9d02207efa885e5d3f355b93a8621f4b4b9239d7c175fdff348b2a05b117b527f191e85e76e1416a6d8d52ee66eb895029cf3ff4c53422d7df85aa539da241ec2bf2d6fb91bebb52e00d7837c339a01a02fc23ecab2eec78b5b42c3da745ef2844188a8892d356fbbf547ede565c655ff55caf8db51ab114890901b29f2d7e85da857a322aa290ca64d80d8d7b41bb618120ced05e83f7ce95604af675c179d26bf3b7b03a347ed290a162bbb5a0cd88edaadd4c63ff69e0f7f21a77aeed8844a6640d9175268a3fb0273cee647640b74b3078b8a7518e1cd83ed8c9be36939c195c524de41eab1514363394c758ea0dc463b6e106e72330e0a3838f03124e341c2fc17a229f73b716fac08c9f21bf7e6bd14570f168748649791879e5df607d2c8e0d5db248b2e300d91fadb9c6ca16b75b2be6144f17d1424b90a1290b3e9dfa7ca97d05e4510f34fef9dee722a67bfbcd96c4902ce00a1e824f3c63a0203b959c8e488956b4942cf0b7cb1c06e92ea84c23ab3473dc21cf8e0d5a0eff8aa7f1c4e11ceb9d88ab1f77488948bdc7c8684ea8bdb3466103aae66aedbd2154ffdb30b9ceec196b3bbcda106ddd08249b7e72ec2fb541b0d0fb7953e9dca92ab5af1d12f2257b6c7400cc201c8fc09e57bd3438aa553d01d3a4d18d5b708b6e465a3d465da74b2b6b36cd5c45898051a6106fba61efa91b38c863b7829617667cb814238b76898e10dd72c9e3e6cfe174258d8a2de2b352adb01a3ebe3152c06871037c3b50aacfd411625a8d47aca8a602d5f0aa4bd9b61ad16ea079fd43624f5c4122fe2db7bd1bff5b53bc6b4180dbb0fefff31edd7a446862e5530ee9195eb8661ec570c444c419ce8efcd7915dc6f8db5b7165853d4555860349b0f813a736daf7bfdc166756cee3a4990a64b2712e367f8ca2d1d2ce81032bc82ee31d9ad03afbd21e10030ba4ae2ca8e3f67992b8023a788d6e7d32b4dd03d7279b5224f0931ed8e520ffb894efbc5ef73b6674d292786634aa90a0c770858b3e8160f82b152921c887956012afb265af5c0caba6b820f830ffa94e7074954c0db2b8097c2b4c7dd6ee190750a590145e258c01a49f76603fc71b475ff6b0e59fdf75f46da306048748e021c2e1e927878d06562115e77621af9c9fd83e606b2e7c71d38e98c77dcc99b108c91fdab3cffa2b397062a0b7e3826076786919bcee7cc8daa4e14d6ff9d835847f84c2b6cc429c593bda1be4a3795dd1cf7e9d926d784b2118618fe893ad88dc884541381b1ada429fbb9acdef525d05639663f3f75c65497a475e5f0b9e4e99049ff2f4042eaaae13413975c7fa3176a76c1217c55d8679f086cf77ed917b5df1e992d39ba7b23649bcbacb2bb9c90c9f15c7b11c54ff751b19b9122d36c81d74c9926797a36c4e9b27b1e4576c136db4be86d2bec4c630923c98d6c866fd284c03818ddad2fc5bb9b2b83b0382f96a5eed26ec5c64ada34183a0c00cb6280eceb73fecc53d6ea760bc5480d240e52bd3124003958380b32016045e3831d4fb1ec916c0235c4c5c948380aed430bfde5e1a10e2d979c2507c555acbf071d00d736250657f484f8a339b990a828489f037036c2a270cf886f3d09d42782eac21189be83123a94fef870c99cacd1948b482547b73f026d7b8e183f58f93a47a15a4b0dd82ea3367517535a30efd0e9710ae59aa93b3502a0c2a6142540320740346f712fb222f72188f1c772665bd9ac1a7b26c92955e6deb39c2fa83199e872bc5518335da94e8e6e851b41910ae74674699fee8174fae4fa139718c923ffb8529f945a88b0655aac87bccaf8ed7dfb8ab87e48e1c55f96d92c0c1aac666f597ea3529731a1b4328dd0f89dbfe064f551e84f86e4c25e80e7c523f6198fbfb33011933482eca335122944f4f3e8f753e8c2b188e55e5683e8132253bf2cf68b2787a71ade48297f56cd56dc307d682ee7efba1bdc92f14774f7226aa0b65f55262ee8030352c88f09411cef4935e40c912a6d383aabb581de72b19ac63ec7698aad827d3aa1a0caf3aac19388c0a21b48b7a23960177c018c1105beb686b6e7379e6dd1c886c3a32736103e34827c1c097dadc3a6c5b87461d09dfc484f8e5667fc079849d649abcbdf4829efe0d9fb54b0b273fe1b6723b1ec50284b0c1decf979f1651ed9caa773915767861308213af10bf14b0f0d667da22f725f609984bcf6997efce273917b9e1ac4e84a8b59462d95f6fafc1f2fef1a8acbd0b93391566cd23e02240e2241a2cf863236efebe155ca4b578a7d5a59fad8b1ec2ef0c8acb97b59b438b4ed8e6eece754d64664e5899a209a0e0513dc3815ed6926b960f69c8874f94a4e6e2a2b82d4e05bafa43dad47aa074e5ad993e7d96b0343dbf59a97ab16799bb84dc8a52dcd1d1c35eeac612ceb841d0b272197d722c86356ffd9174843833d4c0ff1af6f8ba5f7f8b3006842026e311153219d863bbd4fe948710fa3531d9209ca72cdc5326c22c09c88f30488f0dae16d3e3fdd3da9b0408a54d2b58cd58a2409620dad6c63a672b4313d11943119ddee095daea6e26305140a22e19aac43196403a156ae60c6830e913dc6b1f0b77178d1d19d985e16a2b68e8befa7cf1ba38b47e03365f196a0b7217e5bdf469e01337b2e16904d2491715549f19f0604d23ac35ea819333e8823a09238cc97af1ed6fa0856949c73e9acee3353e9bd3c297f106a4c27dda9adb9ebb7c5e1395792ebc3fb588f4a17793ba5574c29eda579aa4c6f406ea6ee20e1bf2ee813b44a609d65129eeadaf4d2041d066616c1403bd3fc5277a49ff8e786824c1571049f5b044fafd43f22905569734cf0ece18c796964ca0087edfc2b5f190c728469cddae47729a00df4c933d1b5ede2a4acea9f45cd1f84c020ab0b455330430e1d8ae70ab81e2d8da98006878e41f420dda2b210c955ebb3720393a2cb93f79bf808e87e8bc3294b3f923f2b47ab37f11b1cc3aff444b5d2e040a9afc62353a4d1587c18a616ce215c12a7a5704092ff35b97797271c381f881004bd1c66c9a818e462411e89891bfc2f54205df40f41488e1a4637d66c3be37ef7e63fe4e0ac8d34688331f959aedf282052d31840f20fb60b36546e7a3321c493b6eae18d88fb54e68244f7f4a8894a9d615a989f27e6e9600212dd10c81b6f36f72d4d5aa41242675edcb95051c53c03abf3cdadd5e7178cef8a51a6670c96bdd6b2b69b1f3be470c201cbf1fbb519587ca257518d76c4b0e006bb0b3d707e71b218cfab1157757a3385516e54fb4970f749d65c4f112295278e254a20f5a7618a08fbbfdf5c46318ae6047da69f9373f6c7f918d946ec5cfa604c61dc63cb15453dcb1d86f66b7520db2b0588c7780d87b48744fe3af69c2ecb65adc990fc2a304d2cc3295baf59e149b8403ffdf750af9ad5fe6f9d992676e79859be94181468ffb10fcebd86559fbc14bd534a57b8ea7963056f014dda6906ba7c6611a453957e26459e0e95f675af3b2826dda8a1f64a1a3b3e6f2e61260cf4b6145af30cba62f0ec38ff637022da1dc1cf170d9dbad46be0ae0b740f139741b2d5520be3371b5d9341cea37d1cd36fd79bcc75c5258969299d40969057aa02e619b994f733d06c9571176e704813de8bfc3a026034b570c3a468e017dee466755c598ceb0caa6a980019e2011b23600b0133244aada017dcfbd183656e96f70a62236fec313c4d00a458c0c6db0fbd406f925f73af93964957686213fbd4d44a11e3b92e547971e3ea8471d2f0d8ba69cc24a8e5a39ae9eee0b912f69461d10c144898b436987bed6904481320387639a0fcd7eaeb97602beacfe0ac1047d47c629b57f1162772a685b5aa9c107dd0cf64bed90efab9e16ecb6832da24a12a16f1aa7f1a20902421d49b5cd6130c60fb72a767c193e822408f6043e46c6a9755a271fec8ae7648c6c715359dc878338528982a0f97136568a63144a8457740dc10405436092b623d8a44703462a2305871a6d6e6f1192efc3b73d6fc499c0b074e05560b59942ef508523ba5d650982beba56fe04dec94521d41fc8e07dc4d83ae31fb3f69c8cadff025befac808504fcf260a092f994e63a5566dff91ab9859b929197ff2fd5261f50dd0ce3349d55721c883f38eb96bb92e16470701df667b9c3f47aa54ef26b4a5bc3b6d867d8ae79445004162246be68637469a5b5983af608935b048dc1690e9839bfb7e761f58bfeb8b45c2b162f113a421d3607bcf08a6be73045f5f69e3e4cf51ca0f12acf01dea93f51dee3d10028eb01b7a8eed2b23d66ae6a645ff76d82f069ed081b4996843546ce1f69967d70cb271f043a5917cb979ba58cdf788947a2535ef52f5a7587b7f24ae22619b44db0b37e7a9a972d98057fcb7a7bb166dcc9f41cc19bc00bfde9984b9257ce5244c981af301d8595d0c10557c5994045329e1da0abe240a7347afa1434e1a942e138bd8533d2d43438c400ade576caacc3934552245a9ae346110796f7b1e5c9e55be0ab8eda52d22d448142f625887f358294e771ca7a935ce5a2f720fb61589d5c4e713928dcc90603581fc13b730f3827e2635be31c3582f79a9dceba0b1d563ea885e13f0f2f56d108d7a47710efd985af13d2e47640e268cff5482edfe8c8fabacd841accf6cfba143cfc151908364d94d96961505f202b85dbdaf5f1956173ef0eb113b0ca74519efb7e97e38030f019bc10ffef96c970d03a6073cfeec5c512dc5a418a0dcf7a39c74506e908293d980b5215b7a60e88054514c06e22f7bb347d79bbe4562c65e09faeece8e05a74097946d046e493e4203d2243f3e1b390d47d3c0c581027812a7a5ed6dd7014671471cea6d2ed98b53771712717157c5d596713e2f73d087cc28e8463ff7730b6eb07c205e2437b782359ee46691c7d832b9b9a7d0fe7d8faeec67387509fe519eb88c7c1620326a51304ae3e4a3d19d9278ac771d025184cbe85537325259bd6fca1ad5951af9677b369d26a08b505330fe589e5c5953209f0f37f3dd01981c9cae7ab794e9b919ba715d69b744dd6c22b03820f24a0e73f981fca418c476ef3e7a1cc932ba9f1c1541c75a2f7c2501cdb6324120d53d00a88f14c1ba24878c8a8cc1319f6e2fdff9d22cd315e0b0df9014c667a8fdb27490a7e68f37494ef4db27a1c2b61472f40670701453c35624f6fd116de466b95ed035675d2b5ac4ec73294b59198e93dc96d21125171d4f26776dab38f1dcbeab5da5147af0ece0b3090e0901bc6bf13e20da2b9aee6e87f949d2a3856228bbc3f866203fb5eff1325aeaec8458e4868c307786f229f234974ab042f27f74e4e41ca014031848c0af620f3032f85c004abe038758cbc2c43251592a9b60e83252a27e5728b9982b701472e4e2fe7be3deb9b6dc3128a944d937e90b74e71202640bec4dac98f60fffa074da9e60bbd9b28d495f5e8404836ab6d19123bbd551da63865b88002a9124147501391cd02a948ced09aa13f809f628b930cb9d95ca38053489e43080ba189e36b5e34bbe5c63322a04cdbaa673ab97114c10725bba67ad38dcd6503cf657a73202b9035537d5b35289f3a86e91fc823deff6a43f6defe2645f908b681e5ca53224a4fdd7be919f21b4a48da18a68dc6728cd0ced8a56444c19d479e94d0c3aa470342683fe4928d16f7e3a5603c9d96545b82cf6040b2f4e03fc2e33787745ba3aca44d12ebcd99a82a47743c0cb4b9fced3453d1ef4cb59687eff1755e22ca7cabb1d675a28da0e159a551f7ac5df8aab9e23ed7ef40601a18467e1f0a4ab1e7a910f0232faa5dab59eee20f02f063ec5de2f105e367b8c21d91755941f6883d990751154216801eab977f2f26af2f90ab731504bb0dcb392d1ffac80c758a73b268c8911d164e658d14e5564c00215c749d0f965c83654f1f7dacd3035785737f8fc7c13a3bcf9012a9a3d212f6bb0c807a7ddad7757ac332d004ee096ef2608b96b210b90c8b1b19946d5810ca72ffbff1ba6aa72916633ce7159952757753a1556c871469448969455e249099e3b38047e496e55ef95ae16ffa7183f189fa062ce5c3e7c00d19acf626d15ff7b048ddd065a2ce0a626fd3f120a50d5e491718d4662b106c4ecd4337476e16f6091482740762852a1e889f570b33d93dcfeaa4dd0488e3eb94d320d1d4049338c29cc1dddd9f9418c4d876ee7ab9602358d92d5a2035a2ff4a1272916c54df5c175afa98ff55b60822cb1db96878ac8af5bb9ba6cd7a190bf67de4aa037e67ef7d3ae87f601b3d74e5b8bda1f9636c69ccb374f25efb4606817d0f70226e94ce179e8042edc1f3f90e8af1e54474d675d6d1159708b0bdbb8d24bfb15e0b8180f95467564c4bee1d697b2a72839dd47f6ff7517c5f86735cdef61736f686e71e479de72360bee9b5a58d4e9e8047c27a0bb955b0380acd4bb88c6112ebd3a62434c5070f4b5f8c944ae25cd257b75b9f56cf329769bf9c88cb66410047c55d5f755b007931b1299d1e081f58688e396756adb12ac9db3c1724470818f1b989a33c5eef33e2d22592d06e906e38b44c28a9db16991d5f6437645a30b7ab1c6ad8b3f55265a2163b400606ff74bca7278ed9a7f28c6741221a01b2f596ca1fcb5abc3fa2c771047b38b5ae9861efb6170786f3ca13d1ad930ff8ca3f717ee760fcda51f867495ba127593a3638baf0b078772f3f6043f32c5eed0d371d0dd444f46c3fc83abcc6c5ab8a9fd8ac86e383f455a69c5c6c0385bf9ac7d321c6dabffc5ee9dd6954bebb2d6e5f9b210d4ef447b8a3177d6b70bbf223969b96e7446e8a69a05f2883225126ff404b65513ccc607d7dc45f0feed157a05e667a6be8ff2136049ed805fbc26657d82d7c62a2b13bbd4d0f340a019952dc45f3f675e1b963fe3709d3eeddc9a215e5ed821a70acb6ec1d2c1ba1d3c604cd8ab16832f6383938df6be0c138cc3c98abf27a42adbebcdf37cfa169fd291ae45f61ca0a25396d291039d6597d92663e805ea336a26d11ea8cd4933ab71feb1abda04f6204f2c12c2479e95f86d06217f21b2051744b231ec6357b041ac9335d4577ab687def6c02742eeb00114793908fc6c4939f617cd651af6af6b862685405cd0b56e50d46df82a89e778f0cad8fdeabd9afd24f7f2e0071b6b0117cf2cf81884e6977966bfbd72c0de530fb2004df041aed03f7a1d7f94bb7b39a0bfd994959c21a0b0e2c610180f1ba4390121cfdb6c7b70f9f302ea51b3585b43f30fe5d62eaeeb893d6a2ce5da08122dc59922efbd2bc127724b37d27fba8236f43939173ff33ee0deb7971a950f4915e2a366a187d66bcc1619389c8ea84e1f5711728a4d96bb4b155a60184bced2e5b9732b1fd31440cbf882b1699af9193e206a5926969b984644b638359a37fb263d16b64a421204da6533e707416264f97c080bc0b960abf775b5eeb5d831c23cb73671d288745c406f4e410352eeea9880b17b1bced8e168abea83d016019fdd1646990fe368a80d1f816ad1ad59f4bc98a8c826cc5ae5cfef11d59113547be140d6aa19f1bec01075b5b4f0dbd4f8a762e902271e2913973990c6372862e54be7a0a1dd4d173f54a1b138d72c20f91050731a1b7c6f66a32957e514ae2787ce293b74b0a696afdbb93f4dbbfbb2c89057c44043cc6fe832ccd4b9e1aa38b0bb2cc8c2bb883a7b29f72e73b80f8a1cb1f01f9a20fc96348a7e74f1ff9e399c498092004af7e6346664574242ada6d764e209022739f3edaa5066ec2b63b502e70879c44a398c59ba4c1d70056914527c9bdffb2613ef6e9ee3eae4991ba7f3b7f42f2e28eb4244d45b1ee4dfaa2b5495220472cbf7f68fb4616adc05f7828de51a86ef492f0d54063b174f3d2690a4d566ca6c284d96c54f02c1a52e7003cea42619b7bfcf28c45fe7742d0aab00fd1acf3732d234eb9461a389b860c39260021cd078d21961d16c8cf72571a29f6ede45a075bc00ac86cac06ba6e50fc6d32b62e87e2bf38104e9c60205c354483cb4d943c479e333706bb62185d91728c9fda5ba2d7df17cc7d92bf361fed4d4375aed9eaf7c0145cbe6a70f25969c341f2a04f6c9261fd3884694da3246d68edd8607001b2a7405f410e0a0a335bcda0d5bf2d4316456b03b4cee76d456eb3c5d3bb493fb667256bc763cca2d74a9a153ecb6c24c4bd3bddded274c60b300e3f40c89645697bcef0b1a742bf8c68ab28b4d2a3eab92ad5df5fb87179c63c529ebc1d6747f46cf69a5d7bd25175920bf5a48f2dea3f728bde087296ff22e452d8bed61478fe23b166b38ebf950bf9d2e1132232c4db514fab003039257dce4e2d8473fbcd3d1949c802668e7f6f7b8b4ce4f2ccc7baff119e9067f16dfe033feaee270769446fed6da556f15b336524abc5b823cb8410b37ebd41b97efc8951df2f94f49021f46a2962198ae9334f3047c60806c4cab155f50b29b7c072ce0abe6d6d8b069872b9c5dc95ccf0455f0b605640d5bab25eba3dc9d2ea523baf6e3bfa464efd4e5804a4da83730f8f6cf45943d3749022ab38843b53ab4354f666f7e09dfb436119414fedde8014e5eb78e2a97f0cd8b98f1c243c40cb0e15b725716da6983fcf996d8a12a47a78bfac5576bf400fdb7aab8b29c056482e70ee66dbaed497d2df8b1673f2a788095a445342c905fa6ea5c59b4af2bb0749447d886e5dff58b5d394988ffa30a06591d05ef4b3763d4987c96dce56835131f5cd1df2d7da2962458945eac5ec46993419c712678b1786020d98996a50de34637a8681c41461af70450cbf8a3fbbc8c691672f228977845d4e87733b3071af95f2b571ceb58abace0e5effbf32aa0ce80d8c729319c0da6858234e8c2dcdc86f13661157c0969795e0001e3798c878188f9bc30e2b78f5d96ca475e212842cdec8b5ce0297f7b1480b6b36afbfeea069d02b10e69d7d5b1edf1a137e0a8c0c74169104d4309993acb7ee8862e3d32099d4f59e904b6b5cb851293bbf87ae4566bedf769c734808583b6fa37561b99db0e71666b80dc43b3cfef014e5299940c74f49b9417f94363b8e658c491351710f76b2beae1d5a15dfa91bf3561876ab30c77abac55e12eb0cde795cfc96a2c76fc4aa3fbe23be79a7c8aea1477cc0a280d766fa8afb6379041c7024845d262855fe69a2eaef6adf6b592d431acc876be9460ad4ac3db853eff949a20d8bf7c9fb1f0d7cdf7eb57e7c69d1ad7055d2735fe97297977e167b5b95625281d50a6813993e7b7fc124068c19a0691ce2d354018178ffd898b2f68f2203b6269a86377da1c630103000dd1917b1a87bdcf8513e30b72274e9560d1e2020514d5d13b4dd2d7f76a3ef3aad204c5a1dcaaeb66ff7a3489a81653ffa903521eef56a3f4f7f1c55bc2ab048c09047ed6a254f68de2daff0997284707d076967391a1f7c1307839e570d32ff1d97a218c141ef554408744e6671fc0ef62fad523231d12317497637f470b4eec008419a21330d2d13d8b6a70e107b682c595ac5ffd1476070dd1510952ded0f05f0333f6205e86bbc95ad3c05eba6dd845cfa6185a4c53122f995ded1fc79e4ee5d6d8a8994372ed2a242ccc9a5e7856e63ee9457ada11977e0fa54614a65e96c37c00d00ea072ed8077b29974d197c2013e92d0003cd6c31220624d3c621ee546275225155327b0ead6ea3cd009a5383b8c3037aada31f2d488b0aa90b96818342a4ee25db6c8c266229966405223c650a26fb3685fb7e4e7459e69fae2559f67e2d2d79eadce74058e641d07037141cd3009f50c5f294a4bb13176febf105e9ee4987eef405420e339e2bd6b5eda322346a1f97a39a69666562fe0e7ed05f2ee950b9a8cb4bc27025a41f2942affab0aca5aa373e82230c6402a8addf9d6a7424affac4cc0dc8bdd5ac3ecad394e5812a423f305326e4cda6e33b9cd4321df8ef682612d656f006109bd6f8d6302a85abd9aba82d57ed3b0c8a669c7804ee2ade3c60f3af68d174e4bac00980dc3468a18390bb7b65970ec9d0bb23eace7d15c3721b33d86f131d42d295cbb636b3fbab029ab018e263b79c732d2d4ce2a0926a230466069d5bfac0434e50fc5b9b2a206c6cef650f7a96625c61a0465cc9a53921e7ee9849bbb9ce831be0d8d61ae715d1b9e144c501ec5468fba73604b643baa4f257015d519d76a759ec585a2fcdf0c4f14eae6dd8785c61ab46d9adb03aff85b07f995fd3d2beb31bfd6fd87855e4af9ba9fd55b8e25dc0400028ec888e48fcb148fd1af7c1f2f04b6757798377d0701b639e2929c0864b54a233b859d9914a2067344900d699efbea06f235054218ca58c72e2498e6102a092352be07d6bcf9180939b97ae6a46a4563b57840e571e00c1db499e54e7e633e0b97db39135c82cf362b18ac214d1f26bc0bdd0d700e9553b401a52ed35060a1746a66a3e7d1742cd0a79bf7c998306bd7dda98b02a2e850c94d23b13d12b8dc5b43fc0c2217e11203e7d20d2a848dba2eb5539d5bf87aa659b2b1577b9a403aa7763c433baef39bbd51ba7f6feee88792cdca8c5cca23c806f74a3f3ca1451debf939b13fa109bf434d279f0326ab79383f901ee6e12dd745fa5a2e9c3e6ae997c0d70c49bf1311882a2f4ee718d8e8319a762a6c96bde560728865361ad80ce72164ab725b4c4f362ae607f926cf2ac5a8802ebe101d4486a6deb11e3f12965d758976de9dbc1f905fe7db2e5c06d631198e85d7cb91b0bfeb72761550fc7d6c26e84cfbf88e1668e205afee5f0e202b06a60c04ff266b842b690d8f5506ef0949883e5826852e31868d9110779bd4f60f98fd31693b204b4bcd363c972b5f16961dc4a439fe50eb612e125c44fa3a20a6ad5888fdad320977b7ad0744917a3c3d19b1c12e1cd9124f4affd30d57b0c6db1f66185182ba3049e56613ac55d27d1b6b374c48cc10243625f58dd00a8bc02d4a6d09ad82e9316df948be34227b3153b92b036dcc6a705188a51aa8f17ca87f8063979d3343cd9edf90985b66b54c6a4fd45e09bdd4b7a387c0d60e33202fefc986e8634d776e0a760ff4f0ed78655b1ec79b6e5db7bae3c43ed839cdd044dede4bab7ca37a4e96c0ede36d596c02400ce9a567d7dcb2edd92c8c9751e8ef7c244b342128b72a22c0c2a34d91e73737308fbbcc6bf2b5832b9be822fed924d75b8b399c4984720fa3bac6aab405d04a9e52c7f27b6606ee011b86b7767dab9737e186e9dbd9a1201ab04951f27a78ef3ec10f9cd87b35f27a9f3a835a919ba7d863463b182485045e6a6f57c289c47d823cef5009bf9aa8eabf5329d51ff215c9e3d869b9329ffdd07ba00b2c6ce34f5e9cfac275e0e73f30bfc6481951711ff4a8702ce9d6fd54d938b0d63de09800cd335f289807b6f3a27a287a27f8e550225041437ba18b6c3971555c8f12a03e4091d2ef342db449f8dbeb1f23bf4a296452544c87e892d93e4c664e2f09d87efc3a265da53332a5b8030e17b700cbdbf1b09eb0a6765dd4f87e244cb01d414a1f35500f6248699645e04c0e379dbdaacd5ea063a678c32c9e7bab18fd6f1b19de7752df8983aff8f13c65c1a98ae99957b3276ebad6bda6f45383fe7b2b9ed5f181f92d2c7c327a899b78486d38afe29e4115caa001b46ad768934af6d80ee7238b2ddc83a823d9510929e1ab9880d88d5c857b9ffb15c005593aa5e8c40eedd66e13ad41b73dba1960098bba0a17664a04ba2eaee756c1f86ff1088e468fffc823dc713f6c9103d29aff107d11414b46ad396c26434e802ab7a7408a95ead5b5f822196c1c5cd9fe280e55e4f93202db808a153b6d1627df4594db5b1494af20ba9d952bb6cfef7cbcdc701690eb7e8b39c2b19cf093ef8cfc2184a05b613fa22903644ffea0db62962bfd00a2d2444689506e5e83bf04802beebecab748302aa0c03063fc932ea3361a4fc880e91b14ee8637ccce631fd8a7dd061d38126e3b41eb7bb8ea5b315f918e941d93722be624c0d7db449be912a5a95c7fb26399c74d8b9c01962202d255a7db8c1c98699e11f549c8ee96c66b6a5b6c2efd141364d2f078ea29a568caa55361b50b63a043f2b4f77d61beffa05c2b5f55275942ba66d66a8022f0a9d5c8bf4dd4c69a8e253d4f92d65e0657d2267d6bac89247a41acc537b025353099c82810db357a8e9c0215fc8c0c99f5ea4e288de2251067c355cbf75357c29c9883e78c5cea89ca083502244ee50e2d46a4386fa7f4c9497ea7e216fac1039df7ecb3efb9006161afcda17d71e96ac49d353796e77f947a51f4a4129ee56ef06f06141e92ba9e8d2da2f1d61c5e38385b0f5c997d972bf16512f12028b757d3deb36440b3fac6b9442f932398b0e0d36267a54df507a5f78ac382cc405e3408f907b0e9d237d5a38451c30ecd07585417edbf0b0d226ab77f2522beda043388f908b064aa05c53597f705f70e76733005421d9706e317b547b5e7bd6f0e2df6a85386f82c5e7e9246fda5ebca8e0bf77b26a2669687bc39e357261c077bb40389dbf76202f0fd904c8525a4eff6e451056d3083e2cf0cd681a5defa6bbb19c1e5b58a487a1e8cd2f140c23539565b8e2d9388d6ba5244becc9e4f1d4a92b733e7815bbf10124b4184c15b4085149e57bf9de15e1686f3b899c27ec08dac38308887e61aef186f3151b9afcc64b007d5e252908fa88ed6306fee5280797ca3229b6494b17c236d1c9d4b8273ef3f6d3fa03316763991489e89911d12f7ec08220301d30d410c2bc4f207500993b249a8184f2dd1b6f835487bb3a8116cab3cbf430ff0536849700098923db90df2d6e896054ec0b6cc76e3c6925ae631338014c5f2024592e0e0b252ff2a890666fbcb0b648e42fd12626e7746662c9b632f5167d7ebb7146a430d7c057f509a6d15f4778846236aaf52c1b1e15b4f54e607cea424a0347d5a4c81aa85140ac0d268233a76d69827dc40f80e8dbe89b5b35e671d02afa469c147865e687439dc6ef3b1ed4833295700c350cb46b53b21f13d31922f58a6a357e2af61099d45f17ff3303a7acc80ee7eec064cdcd0891c60f9111e289b5ca793665cf02f60a81a8fc7b21ba5b2b4464323140db5af4f5fadc96614d8c839c814b4599ebe561c6cdaf257be01b785c18a13ea80a1e8c2bb5f25379","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
