<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbdb7d501f6aa2e2beb8384f396f68803e956ad3389183577220a0338809f17fcc7b0e1b7017fc7ef4bc79a137ed6367462b41c7b97c4ac6ffe5197bdca0f725b19c49db37ccdb1a6878ff34efb098a27ee45e04bd3e73e0cbca8d904d57019bcc01219036ba07490ab97300d7def98d63f10ac10de03e98d096831019c7e2cc88adf8bfe77cd778777c66997f4731931296afe4eeae7b23718aa6e6fa32194abbcf6cde5596afcf45345bfda7d8cc130174c54df24ea0212b64376a43997c2816896fd4dad3e94c4d9158a8aabe3a77df0b76b965ae0e325451c42a5cbd43a1ab09da8c624d52c6ffe8e09d0264f9bd1e22cc389dd010e33eab488cee680bfff6066e0b82e5977b9dbc4149d899b931a673c21bcdcc02dc2ff681f3feb02524ff84b5dba5c00e605e07bcf6df1a348ce5f3eb1c6c22a3e26178dd615eafe744f1ea6a92b7b5114ec8d698a76955c92030e0aded859e19d1f94a08043162d4c40a48a5ac1df0391c6e05dbdb2e92c5735b62c699fa94051bdc594a70e7ee4ffdba18ec851565102d2367998d4af0823f301dd783f52378e6a71cf296d5c3310fbbf7b150d6bcd913ec14f43e477853853acbb34061c6f43694333051cf6df22bfc9b6deda7f3d42414ec16d172a51d62f623027a3a59d985c37c071d5be0f749cec5f66c92f27b241b73da58a9856c66ec801ab9076ef9ee00cc98b21e5a9b06b5eece469b96c982d21ed89b92a56d6b671a698e378a3decb0fa3374d968e2d6d7be18be241ba6b208ec68bf6fb5f735fb10a3f0f34a1038de699a866e68885a1ed071c5f51fdc9c38ef64d09e23e186e96b019e37c5346eaaaf8ad47419924e37d40ecb5eff412b7ee745bed81e3680d2aee7e1c8ba911a72ac3cc6d8df62cea7f313e4c1a018ea3ba2602be2ba188ccfac3ea8dfd3ea240450a5460867fc0b9f57d50c1654af05b672b18574b55e1644ffb6ce3b2da4937881b73af29a956cc7066b01c62e2ad14f779617a56e6495121563d2725ffbfe8064d4667a3ef91edb756608edd00358ad22a8ff2377aae87a763611c1a186bb6869e21ff4f93ff7fc5b0853f8a5676bc4bdab15583d2aa5c4db6c8afab6a63e92de2f968c1fdeeb21c7a4cf2b28cb3aa6fe9d28e31a0be03be5bdba02e8fb14b3edf971318fe4dcf0a2e926056cd893b7e92f8cad314a64e88a8d315c5f39aff43a5d75716c49a1720694c3efb07b4e27062dfe135d99a7394e042750639c5a79a9a51fe3b081b6e5c2a9841779b02fa70f26bf25f960c291fc7324b20bcaf3d96369f077b2b637aa962f347b761a230fb49ec2f7a275dbef931aabf223c7ee45eee924991cd2d18770b0449c1440ed4b1a2205773509faefc8462b9cad2488ffb1930e788fd80edd1509b173ff5a1b318ac67f4f3de5ff242f019bef4bae3b67b3fd7457c24c2062f8a1bcae947d27218d3beee5ea42bf60ec3a6ac1fe7764dc00c388517baefded2cc51d6b387114cc137d0056fa4b639eb8025b0a3822e37b8ddce5905ad284e10907bb434e8970156680ceb742e660048c5d4cf045267002e09deeffb0c67e02513b8c02d76a4752fd6dfc3173d83042125b688e086edb823d4b821410d16f40a85a8ece212eaf015999cc9b7ac6ba8dfbdeb96bf13f0828e41c84f80092c7d7fdd29ef6e580336e084040676655b87418e04a7c0b16cd788d96ae8e1483467e7411d6573e71b842475c00197f49e23955e7e9420f00938f9858325a5252be5dd11426193e1550622973c341c827f34f38647fe88c864f17479083ddaccdf7778c83d6455bf897f9a34cb49ede5e90c1940ac4533654fc85d1a6e9819f6b3c1db18a4a317b6450ce9b4b207af90369174bc34414a76427a81c2a6adb41066c4c740e761dfda4de733148c8840f677f108231bb579fece96a51ab9c1911cd747de2cf62b55059fb1507fd186972ffa8f0587c15816209f1226e27ca856688a9cc28ec5b9b2a3692dc0eb62c391e1a1982e875e94307373a6142fc19f660048c6a65f1dee6d84a461dcd82e0d7aa039335829abe92ee52b6adb91bdb9675817cdd645fba7373c284c9cbfefa1ab1cb67303617f444a8a2a53282bbffed3cfed2a1a0d8d3755ef58d21166ea4f367596470b67290fe12be4829d2c7cd7dd947a137f0194706e37d673ac108a8d9d04b2fa248712f5a8af24e27df6b22bb8b8c22c1f94deade3d8b1179d1d292e577da8290e6bda9eeee801fc2d46a488cb061239fff36b5641bc747a42eb531b9307eeb2dc6bf0a84d07f5f1dd78d4f0fb7134c7a90305b8ffed95af19a2ae4376eea85112fc782eef5d05fb024b5f048990660aa86dee77d62c8a9ba5b2912fee2a2b96683850cd89da0ccc0a956fadc3223aef78d50e5d45dc4b3344c68be0fe509121b5b6cde99fb7bbcab0eeb9796f79f988030f5c72bbfccadd11d2ad5631a52cd34cfb4a60726a2930cb36ad4aabef9de9ecfd21b12a64f47bacec7249d8022bc85248a7c87c1ff30f066a3d948b75f1301d6155a1dd2a12ed1bdd4634321332d5ed6f1840b8e919191f4545a56f34741976b6ddd9496dce6510f6521a88106743a6bc0b5f4fd4a8a58d3298022f3c955b38c024a0193dfbbb700808c866f8c82adbc51b7de4ee279ec39ad02180a3dc1897d3e524deffa8f26c121e59330daadc764474ed8bbad01aa394d9005547db5b3dbdad7b03a00c26a35fe3a7e880eb7b4247c93af1653b952d9962007493426e5f23e8c4f207d4b1bab30253381d5e559f69e9b882f8c8de37ffa9179af266fdcb4b2d70be17bd3094a9bb7b3d6930bf594e843e80a247a5752fd7a2df2d99a6e525546f73f3d21db3c6472e97159b78e2f6eabd370123abe8d5f3bb0643756a71935c49205faa105596d7d12d81fad6b944e1a85f91f4a85799ec40ac087a0c3d169452b5d533fcb406b9beed9b62d98a483b49ae807e59a0569c349f328391804489514d006661bbdb206de6ea21276c932e848ebfa47c5e1977e1594f23aba7df46d5a804d22cbe35dfaee9c45ff5728bc8d8ffba6d9c8a20b9f5edaa6cbd39f5786a0b564538cddb0d66c0d7ccb12b530b798cad34484a71390cbe693dadc0105d9a378e571d5b6b9c3acb7a751e06cbec59f618232023974fbb6e79f352c922945227fbe3ee4fec957b60a4c260fa874a4dc53655634571e0558c1c22173de5cdbd26253e3171fc18fe00b71ccad84fbafc578859456aae520756ed122b5b4a50f6147d19016288f78e43eb54cb5802a3984b9b8513dc310f8a2eedf74e96376dd119094448b0d5d9f02970f6901c417a6c26baf69a811c3cb09d73a5c4f8d30b82213c8f228eb78d1b8242787c38aa88b9206eb215da458273f12872ef29ad47c518a5144ca04b6e012c66779374014af828117c3cd1ea8cc5072425d1977ead7513783b413cdd339039ba6f6899bed49093dfbcdc66bb5928b852fc797877a864d9fe75e8df21df29d8ec7d47e463cbce641567cadaedc3a2d999ebd1424920a3874d098ae4a9c56996913817cea0c9eaf9401bf8191c59fbcb0d8556bc3ab86c912d3ae5231746a57069f3e5e4a878e9a596706293319bde408fad2f5119073df2a685747754edd10107d08c61fd3149b84c3ff157d54071b5094df62b39741aa2c5f2f96f971c1138cfd0ff0230eb71729628c554ab9c07cd837617e6329cd0f81c48d862dec0fae7f43733146ef83964f33288970fbb836d408a617fe3cee36ce8214f840bd6107f90e0c176ebe1f55f4710da82c328ec25d4749f9ba4ceeaddeafe6ff09b383a5d29db3ad509135be857d72fb45aa8393a5ab250152e5462967df7f4545f4d0e54ab7c66bbb90e46ce36792f02ed5596c19980f978b9a8a9c8138ac4e01edf5b4b41b74f64bd47d7ffe195bcfb4ff256dffee0639c1dcf5fe74f4c1394248b1de5b268b7ddca3bdb1536432e3667913caa7ee6f46e22cb15deb680c3e3ea9eca92e84bb507bb32be41861179fe3e344ab105ec3f47ee5b527ceaf6516a80a9fcf3da0f50231aaca57873780808d81ce45937ef43ad40a52ae06fd97fed0de93eaa74d89ca6ffd4866cf62bbc913084132e5fd25fc17924fb89e82b7b3da6f46908dd654ed2539339eedcb82d59841a02c751a8f18ab9250976cff922050c8b5ef0f06d1b4709c183830405162f4388cb03380248e729c0d76d6ec78cb3ff20b44df732a27b954fd97e0a490228ca0b764988a85a3bdebd0e3b761df6b454a272fb53cd9cb4494121f4fa27bae8707f1151e4dc9273a43990e7617580cc527d176d570b59a0ac409a5eac327acd4d904ecc4cf118795ccef1a7e33ebc4daee11263a989338f2799550337c33d69d8094519831e488f4a1087fb628d1537f8124360dc18f405a033ad42aa6b07d727f2841632d6ba0dc3b2cec6795522f2b5ee9cb32c7ddc31048fa569d7577e0a0f2bed5876043652f0fcfcec8c45aa7577fffb85ade682dd15981a8fa8d36114679a835baadee2c9d8dd40f2a0d7561ac34c1662f3ca6df4a5d6aa1c55bbda735e9eaa7527206f9df8c8761d752d12a12d9231d5bf4d075e5cdd6c5d7f932bc76ed4b19a897b4efa728bbc6e6338c53ed868ad9d5f11006b0ed9184efff3d7911f7729e8155dc8a479c77eb676e0d24ca539e9e9e1b651da08ac03d6233ae93317be4f92409ebd7a9fb8230d96e9783cb0c30893f14372eebf2cfda0bb60fdedca3b8fb577452655652b93904b4e36b18872b32074f8845fcd8033b999a4db110b27ee485c49079ea3080608f867520804d018b7af4af7886aebf969fd37762753c81682dea11e174a824e61f0840aad7d605f02b6a50f50f1a47a7da45dc2d069cae9a334669c29ca6dbbc692de037f5cacd1bd9effcf1c2a5b0ba1d1788cb221c2579651953d073f3702036f83631151666569ebc67bf8bcef4d3bbc17e74f45c2a3f5e588eb4a71833b2e870f71e9c4c77b8cef3b458c229baa25a5ea8bfc804b2ef033ae160acb6a7659a6463047205d8d36c1c490f6b2c2794dbdbffb1597c0a107ab215237e8e6d5737c708150e004d24fbb2f09fa0549a111c031927dc038f8ca421a287a449163795f2098180d8400b6a7e568f83e13f35844413f72a9f913a144ea2749ca87d69cd5d76667e1b376195bfe8ba8eabbf973835453367fff88812b48d78aa0ef208fd47e4365bb405969f0d18857147a27565455dc52027fa8598e99ea54d4fd66c5c579df44bffc9b42cc9715c8f21dd55ef35a25693d2f01f69e22feb4fa1ebe476863ed605ab956915e9dc1b01328adbb9b919bec520c479f5b64220b7b84a6108bdcc4a098b851c7511fd22c97388fd1cdb20caf67adc22946263902b04f38bda73dc9512732672a69fef1045cf961b5a7e247f0853c89e3e71aec1794cd10519b98ec9c6e07006f92447ae431820b35714ba3e1fe208de766885620625d2711210472847183fce84b219d3ac9e7a79167d339b55051f5efa4dece35471457ac57bfc5b94f730483aeec347f8514282b892812ea28b79e00d562a2a8847086e66ff061ee79d56414559c819847db36b08e1c8e5bb30b7360a96a934a46498b0962464178a28ee04e2c8cb748edffd981e72c037fd3e6010c6b89580a67b15d75883852a8750a44d982b1e072362e2b137d620c764809712180117380154017e4bc38e6d406e9d187f5884b54d27116004e784ef534f9c272ababe69fbec8b228e41c511655004bf73cb02234e31787cfdb41935a5f57fe26453ad4e451f8e47b76235101c742a8eb788042ec98993b87cfd93677d60bffb357b4468ab7f904b996fca241721c08ace5876171c85f4e810ad6f177014b3997cacbf27414217a00d5587264b73f49878dbd62566ca7a7cb08134e9e49aaed1d5faf7d7a98c51c583d2bf329db239d2ccdcfc4fba0d37b2764d4d46a7d7501df74632899a35aef4c8b4f17af9a0e99ef15a2889b4ae2f6ab1250382282d2a3a8289f0e1362d3cda2ab6f87b976f3dbcf60f6497b62e2cbaccbb9c6214e7c0fed0e07c46b35f338eda02a36190acde5ae62e88337b229712cd92729a6b6a5585ec5b4a35d2fc0fb15688618f82ba42e8c9d49af76faf3fe007fde3f61dcca0f70830612f0091a630216765d4ac19be7bc1b07fa15df71bd0989571a8043f4ef092fa455e6ff4be4fd09760543505605ba6549e9f4efc614162b9eb07de6f4a8270e1b6a65c1bc5afb083728c7acf69f3b972294d7d114417e1450dd0f870248f7567a66007a0c2d211d5cea992c31c72aae17b7e11dea7b703378b9174c140872595758497ee0b1564b1e2cdab41051ff35619642693afad83a63711acf4e9f0dff39a7ec62c7d707362abd57ecde592656269b7fbddc3cc22b0d9e76c0c4f83af868662aaa65a1de7ec5d62dccd02f0beee6660d372d9d066727916a5bd43426b6605a80f80b2f4206ac861bf2dbba1c5bd05e140decdf776aba20c4710011ffc82c547e6452fd8d6aa455a2719169447b37a1c2053761e5fc4d3660d3ab15699b914deb9f4c751aa75bb6089d02af3f3626f0dd9fb40753590055098efca6b282ecc8ae6db089612fe76935d6f79ba388d2aca091bca38defc88ef422f5636c9a6485c18e262525ca39103181381e77daa5f6d7068ce33a1933eecf27748a946460dc80f17c32d2d5eba086e8c30d102a2e080fe47c3afb9c96b12200af6da2360909aba757f2ef116014b1fe1cbdd69000a6bd7cd4987e82e8ae79dc9b36a37cdc4b3f64efcacf173dd7312366eab5816e7dbec3e52a07d465dedf958c3d8e711597d8b217b396370148aebb0cec9e99f40c74a4c60e59370f586d6cd26b96d568cb6c7299a00655490f3ff0e0705be92ed19f8a4285bc5232f4ba88ddcabf1fd5a3e5e14fe9b72902b0837485309c46d9c410b901a7848703e1eb21f4ef0a1c21b8b5e51f7617b0ed8f5f6288d15ab42d6b12f96017263fccb32a20800ce6de282e88465cb9f90429a3311866acd3ba67dad9d9368e48dd2ad63d9dc5ef2ccccbc5b12267c5dc72c2db9a624c5cb6d8fbd0dffb22bb855f589913cf3a4c4ca14722f61dcee1714aa7e6c3ecdd0dad95fc567ab7ce722084d23b18dcf9f4cc26a03de616c637f3124bd689040904ca7c03d5d04d5f22fc57b6525f044b990b8e15bbcfc9e0d165856a5be1ce284e97cb26e60a6269839cfd7b261b0ce6a114b364ddfca2e1938a75c359fb56673b21d8be51fbf3766d7fa48e7aed1bfc788c8a7d7d012333a8b3b04be450a7fda4b78839c04703d27dcf6b5b95c61985e3d5f22302c89b15678921d3d469022e708378a8f4e13055e4696cbbfd37fe2996d3132d4482577222f991383bfc2acdd42c5609bed215c8d58051bd90502010642d2b449eb22fde320740f2fdea3361d0ae6ba258bc818eb048a25b6522f22d2c7b3db510f428783d382dda9035092f71fa06b6e45ba9ff76602e74192f2cc659629ebf59c3b9ba1523650503375ad53db39308d225a8a6ea442327f94fbf98aa6d95ce4d4a89d9f6e0b82ad7b54874b608a730c0cfc23c4c99c68753a0e20c90ee55e38aca223b6a2fe15ae07dec55a16c1cbed2d8bc2f5353de2df77310590e04fa41aeb22abba049fadfd43c18820dff178781bcc9731ca07d689307eb96094009f73df40d8c2951d616cdb62b22e8a7c96ef75abb9a10c1df334c26ad7f34533126c50536b3226495a7e9d4f2f128404ad87a0f1fbeeef3dd3a432d2ecae444eae287c240f92ad37b8306b9330ab75c7e527af2cb6ea6efe740fe3e4037503ef87e7a10522159a0161922895290843f0bf57b99092bb5424c179f62bb4de506146adb76978003ea5d856fc7ab832de4c77a7a4d8b068c3662d20337b36fb867bd629c57e4d20f634be62f4298dd41fc03fd27ac3afd9ed5140f350a386ea96883c8da95291e1e58cb3dae7ec14f54819dd4dc2b91900ed00f47071390a572f65ec7ee5925f8d972cab14be420f2e088c7511e917b2049a6c6afcf79ebb452d1a09245a3be3e8afc03a9ac7a48a1e62a2007d756c02b1e83476377a58333fdad0995bba188faf86a95086aaee02e895178e2b4e0ad33616af9e48507eb541bf6da21b537c1bdd2a2182a3c476d0448c96ecdc42b1d48a99a838e0e074ebeb6d38c85f148efc1974a5b088a5bf58ffd8e66cdaac055a8eda53a97f11fa0d0e295d6f2c045ee015c3e0b1f2e0ad7d52ca5bb446e06c717e20f3a2ae5916748f137ec7945740acebca92750c6452cbb13ae517f00f84570c6dba151865590d401beee26d803b6b065592fd2b66e561f631e436fb510a66a8d68e37e78a44f75b1fab47922ff78fdc9c6da653fa338965628fb3ab87759819c3ee799c602a5e191e5472c82ebdbed0e2faa66c2b013717dd5e50081b7b11c44c6827fbb90aa02c1801b1158756e9e449aab1a03adb5dc9984bba82baf20b06f47c59065ebc19b3b1867c73f3d4057f50a3a600b8093f08f97abeca7b194b2f436aa2b3a4fd8a9798305f8a31df7e3552a3ec24ba4ac8c21f3b52a59011248e128469babebb56a6f70b024d2a317d3c630db603fd0a2fcb636065520f23117be8c976257c0e8120e648bc5e9db4ee0340064abcaddb68641a11bc813497e3e9fc382102f32842e030a14dceda294564de8980bd8f8d4657922f23124492c4274b4650716bf721017341e470a81c9befbc9ee62a3624e2599a299276da02e5c0706b064d526abd145cd37e2a2f460a24113d4ea79d5a53a9881e90421e6529795319b9ff1071d2d21d1ba16a71a4fe9ba3ac9a95b991b3b19c84efb66784f7219646d9fab3f9d3d06bcac8a4ee3a7442fe7c5e301bc524ec1eb030aaddbbb63080635b992ac2221f0682816339e9697b8192625deb26f7e358272f2ef80561ea4a077e1f38c6318b29041121736b090560bb7864a9a3427de4afea99d14b890e4dbdb5899ce6babf57fd93d5483ecf4fe7a7a1b8616e528ed16c254a34aeff24790efd0c73a6aa39b50312a884d0c89c3bcf6929117d33d2e98ff7844f7b8bf0b0cd43e19229026f516af6c59a5ba1c4cc8c1ad4dea06e579a739342e09c90bbd24b0a5b8bca94217342e8a6163f16b3fb435fe340079d519684e8e11991cfcc4e5463f1b4e64e0ac0630a41cc58c36d7559fbdfe90a54572ad85c5bf495991727875978fa58f2b7b71c19c3fa2b3aebe48e78ce876b11b9ee31d6442aa8dae0707a8bfcb9193182cd6b688d9a435619c27c55ce299f771f9392817ce5025da1d22deb15c5e715e2f560a5c77572d96c3ad037ba739b371a23b3cfb19e055f0c37fa331732172701ba80113ecbbd35bcc1b3ab782166e40c1fa70b756d646cb7d0ac1da8631e33eee3726e610095283fcf6a5fca1ee0fdbc4dc168ad00d37f9bc0566c55ae5ae7ed89383f36f11aa932a129de5a2bc31c364bc03e42f9ffc6ede5a93f95d6a4a7004f7bc0e7ad1a52e95e637a3287cec02eef464098e96e9f82b0a12584976bb2a65aeb71d370e0f3ea3a1c7907854581ea52229f647c42a2bd300ac303f4190ac0b09151242a87424d8421ddba5248515c05c0f2b135a291f54ff72bf10bddbdb9a68924a48a9682860fe64c7f14554bfb7a82dd386fd63a4aeeee541e77567b8f90c72a99f0711d8afd2a4a92c1b1ffde92200ea941c657927f93ddf027802c3a251cfcf0d140d6b065116bfc48d354666d91c354976660c700d16746ad3dc59d8ce515d95d7b22c4e2e09c35c1c7e51bcaafbd009dbe887e8d70c912e3291f0594ba7bf387f80cc0b69408ca61b02e02a3d0ecd6d50f768d4b25c2d74955fbd7db21b30ab685f4bedb928328bb539593549db8ea4870bdeba9ce04d8232e5053052ec93dce68b5fa095b0de75399540672d819f257400170b19836c3ea13c3ed96ef41f0f809017d47a59865e235ca5ec6816a1cc17e3ead6481780a1e5759a0a3efb3e284e9377dab1611f8225abf03bdac5e68a2da208f6e3f517c5ad26bfe96dba3d49d3d2846ebc0b53748b08304552c821bc6b9080648260a54e5ec863963fbcc4a24787363e3678f945ddb3899d0f00d2230936a15d6d8d93cc6d735ea985d854d88e2b165ebd4bf25941100124d349d252542ce588b2680dcd6429f7d47990a80f3a4837b9a78abaa0c13d97bf21805bb9e5a7c0b5beb1fc89c4bae1938f9bc39f68b0fc01368c265ae1d98285db9fcee0c8db2380ddd14c783a8f310dbebb07567545440bb5e141ab63e1bafdce6ae5046d115d55a2fcaa7780e82d0cdab1c728827b5bc5df550fcbbc85c4f04b087cdddf83dd855fe5cd226b82320769fe2c3fd353c4ec0d454f886963af6b1053670529cf7b0fee85908c778514bbc00eb59c106b9bb7b4ce539bee218e3ac4516d6e7b2f3a5bbce797aaf306c02cd9e10ece20449ff64aac2673734563b42b1a6a4455c53120d1526df3428c00c3759fc1ee58ad1a1a2e310b3da28dd4a09bb3924ee42aa5f018290c88848119b3fb985c1712d93cc4a7c39e8c8167a46d7b527259ea3a936e7726dea5bea8eb3114cda3225b8fff0c76a0877d5f1d865774650db8e75aec13f190d44ed70ab738c07530e3a45876af5aadfbe2a0412aa423540fa634e23d8cf586e5be94eff9b2d4bb02ed8525364848fcf58af89765fd579f4d75aa5071747fe354ced7aace3834c4b40e38fc65d924957aa59ca3c664d08a9e67dc1fbc3fac9d1c2ee378d90bb291893344ebeb39af62ec022fa1de5643eaf7b06bee19c9b273726d5620ad3e6c0b05e813c0daa28b78f0a68d4cbb720f287352fb7fdd89c21edb5cc33c7a1f3beb5ece1744ff84aa0bfb45becc9bb88b9f6605a5120818e9af98b4679a70198575e33f9c8d3f1cf3fbd938dca4a72341326d1f4a5243c22a2ccf0f8de7a313be4df72f14be404a1ee7d9da0f1657198a21dc190495d80f3d31f47b6af32ad5e315144df1cf4dd6f8ebae8c5acb1d0516afa70d74b06a2bef9d1f44d34c2efee18fc3e189a64199107905e66afaffe43c34408064a2dff048d2dc2950cd8a852dbee8c112932a915f500627a054d08c9b76fc648be41608edff3d849d36d4519c99529fff6d875f25f9d02c70bc3ea2e67c74e2d018b44ceedf5ebb2be97da90ed31c8e4c951f2fd9e9d201cf395c7ab37f5ff3b9141be81df789cef1a3f30173f4ea241d84a0cf40b3e8e4ef8e09c1111604d4f00d6027bddc67e474b98e06dfe1bfd64a3af68c7c24c6ed7421dd2d353a53c2c53c3934befe2b8a0280201e4fa5a49d5ed5ec429e1902fe03cedcb3f79794cd99e8e3b613cb6edc637953e64ee5b559d3b30d0a46919201f5ca9827ae43778cfb2d8e4d26ffd463549ba42a5ca3c5ece9c609157237b895628142bb9dd73db65d700149d67e58d977f7e553701f49a5903450de156829080e57e3c3f09336a3191f3fc8cde95f54e4885fa9b00fe72fd62ac06cabd6d9227eb873c560ce742fab536608af3b5d3ea2d35377b6c423d493befca9353cc9b40d5bceac919b00a40efef16792b923e5899ec4ffebd3c576b2ece9aa7d27b81516bce299f6adf6594e64bed71f0f1cc2cc3e1e3dffb3de1164f2aaf66f6ff924e75ebb19aff91e3c8a589781e86f10adf4788497232f042cffc6b43050958bfbf8093bd9bab7ee9f682b655c1654064b2c0d7790e8597e8ba1bbab7c4792a8757c9acb8f11cdb7e1d16ebb07baa8448e639a0ff94a57750f2b5f0b8dd4ebc8cc7468deebcda6a70320896afdde4448c590b54e784a2b19bfa2421fbda3dc507320548ab9f4603b1c1168e162afbfee26912f5c0012d11e03437036b8cd8de7c86b6ffd32b6b113499477d2ee21a94b6c3619e976879b5410ff6fc97e3570827758fed610cd35f5b7ee5295517a006e7c22c44d1e551e54c30f9415306b8b58037c5f4c2127602a041b64608243bd676dbba7d0f37052da422274f0a55b8321646a76f8d9732fcd9c5a6bbf5ccf6ecec3bf54aef058a09bf39a2c6dc4c090259c9e0570ffa1d3b1aab304ea276e4a5212a9049f00bd4c9203071f97b317022895985de52338133a5e79d73b5c1ca939c4f84d7ebbbb2ebe7ce9c35d8ee5fdeaa9a7f7cbb7686274e604dddf36c0488094482e31376a33db843d6e4519b07fe03811e9ea1257ca07e221ba5138c657ce64d9266c1f010d6375ec479afcfb586f402e635a3ebea278f4c64fc5f1dbc238cd555e5ec4af7017a0e9723652a34263c489ee6b592f3683e82dca4bcc331e215d8c4d7a8278ad2fa0128ca6bc604c989a8f95407a57d4bede9c91ced68116c84331a69c9356e4b010aeb9c93cd1c201868eedba72188c48b0a34b5384877ea50bd000e9acaa099c15c86eb90eaabe523bbd832f06b8e66fa252f4c91c02098e27c05fae4fda5fe0cec42d4603b508d1eecec417701178beb45c7e2e92dfa13f07fa3e6c8e7056f8a7577c5657d64a2b39ce871b1165f06280bb2e644ce2a33c92c1ca3cb464ecb92d78353ba9f8988fbcf7ae00394c9664aa7e72b400e644645e119308b7fc4a4e3e73ced79d4f82fdacb91a3daafa7ab7382fbb85d2e08bfc80437909d4ef2b371c993e3de540482378edb5eb529f88d742c29e91d73d70b5ba14740c2831a3a441da118b13bf805e4d1cc5e4c370478bdd167a79c099a45e318f897c6dc3fc5a0df20c695919a91dfc221a0e583facd0001e4bcc03740564cc94b8e19e409ff9d274bb575b2ede419dbf4b299a295a62580d70ca88ceee58d5adfc57ed76a13462c18438c7ec1048a4c66694b32f15c05c9d00cebf9cfa20a16255ad8a432ca2b350e18f51cbd2982fa45c054b28ec39daea364797c03fee97a3d068d43c15fb3cd40a5cd2150de1bfe5cf73ec298f0d423df9b8ddb64e084047f432f360fd748cdabc56e8a5d62eaa8bb61df98d40494b61b1b43e7eeeb18033c7e982e2e5d92a951793826198fe11b71da997333f4e72fbbdd618c0ad430a8d4acf95f1406ceca278babde5bf027a9619a8e470f493e676bf84a08597ce33e7078a322b9f2abe9ba9020928d080027ea8c87235c4260d88dbc495bb73a5f85ffd94a1ce6b17bbb66a420a9a6f6c39a9d19bb75337254e813f5cf24b5b203d8ab7b2ce4757b1c29384d495daba8aabc4c9e900443f2b9d88f02cc67d0a248222670012fe5d597249c3ed261fd56fd7ba056777c07cb4e873ad663f3cb4500f06c8d4dd95c9f3742c57d595db1b38222598dba36ca57f297e9bac652dbcf045c2c8344770cb2010bc0235bf6a684290122ad9dd99a85671c78be0234e140ae09437bbfe882c857cccbe0723c0b8970420789765415bd493f4d7b93c1fe2199e4f84c93ae306df4ab53f997dece5f63fce34803a1667e877e3ff2b1dd673f702550efb3a772efb73d3ed5da52ca105dd3b56968f0ffe422b2b6c80c13f2a15b0ed9ddfcb5057f8b55194b61645b8d7a3ec1c140bee72befb78c3b69b7bdd82a2a8aa767004d08044d29ee502745a2edf22c3f7c9c10dcbc0213aeece95b5caa91b34844dc89dabf58f92c1365f7b3435c99dc7c6dbb93b3877f1299fc30f218dc4452bd99d63763d2812d5f2ac02a591f47e60ec19b8d089d4ac4b3ce7fff41074d8e9d9a1a368eea51f3a6a1895b42d5a6ee8e4892ae4e4fc1287c6238c2a48a0855b67f1265415792dee461e6ace3bb90007c1690fd1f6c554afc6b9a8eeb9e8a05f8c5806a6a6b2181fa8b46d0835424b1c8127645d19500bc0e7fb324a56f0c8866b1861c6d12a99c2b6aaef7de4b08e1539fb9640a644fddca282362afca269fdd72e650cbfaaa298f869969d250f8a2e06e1df93f881df4cdc9bb84f8c10bbc224e458bb22e863dfbf0ba4062221d7bc6c5390e183d775b712a70a2b29b73c5a021b718f5861d987ae2a6331cafe597ef4499c611aa7595d83e6199cfa9d032f0a52b1ea4f692b2adfd392a51ca9006ffec7831315803b8c11e8f0b36dceb5d53e1efa286f6faa6cd566973e8af2db060157f5b0c82b65ea29235f7a1298b4c76e1dfc63d857b785890cf0c7c6c08d2c9b2a717a6085fd2524ee68b4cd4a5ad9458dc4f568241d640322df2efe496b21afe97a55356e763b1a3d0498c07648cd1d6d19932b1fe751ade9a87ebe84d94ba7686b854160ee22f9fa37ecf2371e4d970addba21e160985968152ef32ac75f819a09bf49180e8621a85e6ef8096d7ace12f76c1707fff4d357284c7db27515e6a6b07d6c7e29ba1b4a05a70a1ab8b9640ad12258237a3daa1713799436b5edf8021505d77711a509e54de9abdb334e64e31bc37fdb6aa100b838f1039d1fd628fec001928bfb43e694ecca43b7946df08398b3efd4368d33820f65bcfba69bd0cd99e02ce73caa2c0b7e636cf478b62913312b6c5bd611bc995f68c7309f60431becb3e582d6a075327482d5afa82c05f6469abff4486ecf0d65bcafb4fe77b45c0b58689e6cf3ce77a6f07a0263731a8c5a33f7686c88471e369befef04c9ef052e6b77e2891602e30660428fb023f9c50bd3319cbc15864a27cc4186930ef79b32332847342ef0bd96658b859994aec1e2ffd65ab78544676f011018723ad5d3e78038533192d33c86ac10506987fef575961a97712fef3c60fb03f1a807ff8a4e4588e0d27e0d082664b390a12d3de11314e1838ebfe3096455705a2d1a69904ec49ddeb9fe02c485189e2cf98a60cd4ed5967f1ad5e1b660d7e156f3a67d831c25b19c9c89c92c468e7a7eff2b6c778af9b179857a853adfa60c7da349e564aa4c57dd2e3808ed9861c13d91568f2d5b8690e6ba57f571c2111e43e65391a99e294bee32f57ab026655478d65c2ada0e16b4218de6b9f0686fd50947ad6ffebb13004daf5d12d2c9a8777eb835ba87ffea2d1bde94d14104c63e73751318bcf5ab39d8a54a28d3e6cfd537387c8980fcd810d67aad8e7c159d9a9690235981260b2dadb53190ce16535f7094235f646ad7a4d7f906dee58d1b1aede9790c1205af583a3bfaf901acc2579bf54ec123834d2893b85537c6920dce9c7ca00df74d02f8adce7caf6182f664f558c6640b7fe45b3f4ee8dda3fe65821a2c9454a651bef1ea96e5404ac0cc00cbd6041de6bbb878eaef70d7e7dbad2f81c849046072a2679eab816fb20c58e9602f0287b39a70ab47a7dcde195a8ee7632e4c2d3d18094180e0d714b2989af320fe0b0ea9b385a7c0193cbd1d1bf036d5af962a447f4b722261185361aa99c7c1c7782f4f1f908b79e8c994257d8db9f73ecfa2d51951c3711427564fa2813700d0f31183cd8d44fbfeeb9716fe923703a5b6f1027f8bddfe990b87e4fb4bd25b65e07f71096b76700a24ed591c2902387eb4a6451f91469e53225b60fe3e40bbdb49d14ff23f4c47194d0542d8ea07c823f32708eb57494540286505bc92c99a98ea3989550dfb7ccf03c64087f45678e63e66f2749c761c72c13a287d7a9dd7af6253faade280ac5e08fb771da57043e6c9ea8231ca687446b05eaa5c6fcabf40e3048f0ddd14c45d34d916b5f46275fa6e218c92f55b8ba8770efc750f31df4a8ac4bbceb8cd4b6496191f8db4f74da22ea5b5ae24af2f85feb4eb8a8b8126dc72f652cbaaedb59830a6f6ebdd1ce9664cf3dfd7469db23d57924cfb504ce1fc4cab054861dffcb6edab005652e5eda3ca00a1616c890065dd0a2380d069743628402f68c0a6b58f6eff1f1275d945c91fee5b98a3ef91bae4368d2e4d2aeec73efc5c1be81b351c5863237b2ac3f4272ecab13216286c5629e6bf0acdc5d5163713b6b7237e7abbc3127558d0da06b7a54f9a68c06576cfec02822f7387909d82d14a8461c4b6234c4d18bd6c7940686af5f814a4d3759731cbd39ee80ea012f04a5b55ed9a74f8302f60e8ca7abb3286647343088f58a54d5c804adb597db70af7b5dcb4ada297325714f1036c972aceabdabd4d926a43783e4f2de9c8ec53b531fd1df6726efe26cf054ae41cdf4aad34d9ab310cb6a6b0a7256839c6316ba8d174c6cd3bd165e46f18b741c1132de741c9d9a73980eb42f4ca7488c536905e09aae42ba0c5741c6707a4f9e9c709c3533a877c33c099f2cb0e1be9d487033786ecf3476928a3c75c92b6784930811e7d4ef13373768afc4f179da33efd4b46a73a1c04ebf43ecf72d80bfc02c0befb82df43090644836e4383352ede1c74c6a0b127730fe51ff3c34208c9cdbd099127a9b4cdb717d8d1a0971d80163ee9f6dfb6c09e3dcd8143748f5468ded89c4b7ba24d4fb3ddfccd3c7ec8d247ca2d5067931cbbc983383b8a29c798552e5dd232388e4b161f2b7f477c0261daeefb90cb5fe5b62f38de91e3916ce2f3a20c0820e6ac240b6b9d8c7a71b3fe2f6618ce281f2bbfbeccd4228e4f9234dc9df1683df6a71c204a4073de1995b13c97f1c2782205dc6560b986c3b5da45c7d5189dd20c1f8fc5dd0f627c5a047994b41f3b0896d9002f7c42f4a4cf9f8dd1524b0819a5706bdeeaafef5b986a91185d6bbed76f627fc57d3c4dbccb7ce849848919d3fd8c94126abd2e0f2631bc354fe68c88822af358eb13e244e0a47413be2d83b6275760e1751af0ead3722a39f0c87f6f8e54b6819aac050e129d08a14b3ad81ea8212eed4bfe4483d7c9482d045e431fd12a3d4d7a16165915973b41b7e47d735c9dee96d48055a027d3bd34132a2bdc6b36d6063ef1bd553f7d998968740a9b41ae6d818d521fbfd379647ff627a06a861598612fee7106f59a5ee03999b9e762ef393e740c36b5e19d9dcfbdfd6b4eb4bc45618f99b9df08cabc8b8c0f633beb5f513ba08595d0fb7bf8c61ea43846e79b15a13f6d406f79474d807bb5f8d33afb5deeb50d5bd9a885a2a546a73990ee2ef719fa788ff053d54a46bc55ce2da27271c016818288d43d9d69c3546ccfd18dc488e1dde42ba8352c7d0e19f46ad8c4181f41ac2fe56fc2c8483154ed5aa068e83424009508aebe841ca4ff983f22731ab90f5e3d81cce1216dc5e7249c804ff424e7e36da53a2d7f43545bd6fbc06a2a9846719ac566fe630c6c2f44c6cdd5c1c946aa8a7f4846fe85a5c1324f8beaa5c9565bc229eefb92b83841ef5b52f307f9ecda6f2a3e6275dd80bb88260f0d937702e63bd97831aae5fe9bd2287d90df82cab7e55e3f05ffca7c9e1b283d4c4115b91666bf558815a737242d1b2b88a62663a31ee2a72bd5f282ba67f3fa9464de86b5c8e5b1e94da3bfa1ff68aad4a2a954b81af196ee53e85c1c0ec887b080ed84b4181e107c87b51f9ea37de0a839af9ffafe62cbc68450d0513ecbd4c26f3080a27874e6435889a620028365f3bc7ed0c255807542526f553b42637d1022404aafdf2ad9c6e2e958c8c055322953246228dc6f49135285c8ae451e024c16e2ce3b6d23c9c2dd901c8cdf7e02ab9f6e23877031ec146c77f4bf01ab47c47ce208b5c80754497a7b7e4c8aab83b044c554f7120b4e55444b871fbb88b0c574093021a4a2db2a3a75d4bee8537e1383305be231e85aab62629dc23dd8072410cc1be69a85c85c686ce33c923b64ffb57b41d33747f95dd9a79c54b15740c5200c05c7591df97ad4873ce6a7d685877a663bc1f8b4b9a4b5be719f0169147fcdef1ae62511c35fb30c329a3c54b113196c1eee8b7092ad4145875d437c9628645f48f853d8bc250e6f711e9bba4d05b57d558b06acd51527fd6ef49e10ff310d377c8c82c401cc0b7ec7a6b81da76dd1cfd119d5af98e4ebd308ddc59970bd733693fe16c32eae90e2bc5196c5aa4fdb8df2581fc4c4930bfdf3b657da728b151477aa890b23637c533fcd82a6c468747a02d1fed9be6096825a620c84f14b931a0154376f1fd8eb7860f81628fb36d72a0881459cd362cded9a289cf876eb7a4fb2b2187f78e6e4e270589ae3e0d913cced54704b0fcdf8f5e91ed05c6f6b331365350260d2c95d0b434ad23d140e97f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
