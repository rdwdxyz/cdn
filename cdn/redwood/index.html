<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd25d05878deaac2b8f28ee476c5f63d86007a5124ad17530f1144f76236d38e6fdf307df3e0604059dcfb2a7b489f48c0723fe7206aba7e8b510d29d89964047fdf2f8fa3659902201f3e4c12014c4c0fef403ff7b8f63d064c787eb2b45ea47e83c41508520d4e68ad6375b31c613b49381575bdb0591f7bbb302c37d9b5871140da419dfd9bbf030a04cabc4b827084f8b990a4f15a12b0d0d65a5fc7e272c8beffd89aa2d11fceefe2dd4943528ef88875254ecaaffa67d4fa742bb96f7e0a6957b069679de60ab2b096376e3239be90000cd5c7b4d89abf25c56251ce0e71b4e8cfaa4ad80d1c4f9c5efc8bc16fa7cc6e54fe56e927632e48edb59b3130629164580cfb12934b178a778cb0705a4658fdec8e3c8f237751c7a09a2a0ba511a8da19daf3dfc9d10fe066ee74a580713daa414ffa57377f9a3a15c11ea5c5416d8a26a1530e8ff04c6310692a5c09d19eac74e68b2c48a828e6dbf8ced51a3ff96e0bda8d417b61bb89eb0b10f93d01e36929c4da624b2406a8be093396319d94f4044df189b75d0d70dcdbe6ae71d1499f40fdd8f5ea1fe6a45cb1f730c85ff1d8dedf518972d15f636d85aa361ca6d0e27413a5c0b7fc8f3e5cbb6eb12d27f81975d41a124b0aeaba847a310a908c3e8bf9521ff2869c09479581fa3dea92941b2ec3a450878770c3a703abe81adfc0e6bdc0001a85bb7e24d3c8f12480b6c2f39f66cf6e7e482094518be69a0bd9ee1296fd132d259d5c8c7bda1f16c0b86d1d3341e3c98e683ca5e599dc04862778fc5a88e45e2acf62063877c5b874c6cd74adda855def2cf5d9392ff4d5148670a540a86d92b1b4da5fa07b42960ace666b2b991726b9af844b94bd23aba5d4327635e1e23466c2b9e048936a2c9c5568f46c624cac8c9c0b2e3da87befd93558d16adb5751e368af56b18824c3e3847b6a9bad9c07cf996ed45c4e0d2a2487aa6e6f4016b7602af598d23a8cd37e7eaa9ad0972047fe699455e6439ad31975814abd1fa4d658167ce5432c4ef47dc9d219d5b4365b52453d32691ee9e34267f163b547005b1c98c707dbe3fbfd44cda12b76251e1b6846478e74a3b284dff98c04d17e0a2d8b648eb3e64d47e0a86690c6584250b89c3d72f2a51024affd7916fdc4460ae99aacc4ad86f14d9c9e53a597608701e9d8aec5b5e814f31c9afd05f04ec4b2faebeacf1fa4878ae3b6fe775deb31d9c449323c8867051c7603c7767dea61f928c1bfdf42ad7816f315ea9ab208caa80e68c6a09ff14f32d1bd4ff66e9bbdfe67c92c73b0c3b4c67871083f8fc8475e3473cdc16a3a13273405db918bd6964ddc56376e689396f87afc11c08c0ef27d04e2bed96de52cdea3ba12906e9f365dbdfed05ee72f68dee176b7e304e72788cb4606d0765060dd689241dfabcd8e040a8a5d9682afbce19f495b38f6e9136a5755f7853f9bf692ba586a7d82838c3bfb4a78daf951ffbd062acc7d9ea202f474e457a366278f8f8e1d099baa2ca233e82dd28052808e8ebf1ea6bbbae28e074dd12215b92ab7fa72eb3a54c3b9d8d65866b45cabd49cdd52ec98c0dc3901e12c08a9acd79573d01246dcce21de8c06392cf013c6d6af8e4fafa7c9959e899c7bf9d5c984df4d003faa094d2f97e1e14c6fffd20d135301aeaa5e409339d4e610095be1896fe0b2bd1a9ad258bfe3c002661952d978f314ac727aa36476f16c89e93c6a712a9ecd341ea7bd71317342f1df474d13ff042489631bae907c1666c2c0f7d6eeec094dd6bc231227bde21f003823cfafc1c15bfc1e6d2116c7f0d986534b281eb4990cbc066bb97cec273c30ace7f85f85afff7e5a2855981201b4ba7fa86a11df49c8cde5c5fe9f6c081617f83facf7bfcdf321740d4f7149fd436ea021e7bd71e77be190dc7a742ddb788f5a8d6995598dde310940bf4e92279d07de9949db951683d3eb1d40ec3b4453ca22ac4b9acf9fa08afa6624f05c832766c260443c926f649617eb155ec22d75b39378acd7ffc27ecd8fbc6d09003ce5c30ec71fbc8a56b63130de7063f513d8f25b3eb81d4ad6d60f44898020bf49ef3f6d9b33341b14c4e41e20dcdc7cff9642f49b3cf68f654b44982c3ffbc1160cabe19be116e0841e517a2697d619e39db62f1a2dc286b1b4258657875ffc5e3895258a1b4980247e808531e087bd55438227629b140b722a52db3f2c08c9c8c6fdaf4ef3b42b9860d66fb23fcc48d5f3066512e4e12d6f529d5e60881018318dd58e7a536388d63585efe00f22b31a2c9e7f98d70f777a450492b8579589e01cce86ada32fcff059fcc99fe9a31a4b383b10d55b8e13b1a073a3edb95ec80c22f6f706a08779d7322b09bcb02441c87d196ab22f215365746b8ad1a21932206b5b507ee5564e9bf3f78cbff8bd257308f9086e8e46f69a5ce462c563584dca052bddbf3956764c0e36d799538c74cd37d64ded215316d276ae028bc24d66bd1a8518290ba295c0afc95dd83453f72c3b4c596d611295ba23c60e1f949d787ddc4627843d198521da76ae805970d75ef9641c765c2e62526639384c7de21c17627d0d3dc228a4948e77620289c340e8b50f43009f5aa13aaeec3655b23e56c93de4d5ad648af39460aaf159af3616fcaac4e7ea223d3906d86217e99279c77586ee2f81c6b63628d90a737f1e3bd6ab099eb2d46ba673bce9ac6c07b6b7c3da6de774d0eec287231e9d1b94f9cd8b46b123df223607cfe9e6b7cc7247a3f7679e24c2950cdb7be3d3c5ddeacd4ae59ed46bf7a61195b6991824ddad6cca579a052f4ddf8117dde8df30b0c89c4fb6dcc67873f3ecdac5df912ad94dafa90b31f78660c732bf4a8521e70409cb74e1a364f33937f451dc2d4cbb44d448f0ade2e9523091ddc92038d3fd98ba2a749c051b94618aafe18aa6a45e21a45b535518e062a30cb27b9af73adf67fb2e149c1b3a035d730a1238e3e7a64f3b9065694bdd9d35dd9aaecc8de586fddeec2b781460dc7a45e3811895f3dbd00c5cbce48b71c8ba20b79b323d1ab8ac95071afbed0c217ba15b0aaedca6dc33793c6e1837548c14049f06223b63b8d9a50ddb2351b3fe69188edb72a0afd4252fac9a981930e4b0bf26e74da29b7c36cde3505407ed70ae351ac677e5657913978339b1a92b265688403ad14f3193b4cd95c348168348f3de183293b8f539235b34f9c58387fa0bb7b98cde21f609caa225e4892fe6ac5d05b9041a4b8e1d8aaba5dbf8cf83aeedd666c645e527e8eb6ea015c2484be764c1b3144657431f3b1df167bc00348560f5c4b877d78f1368896e9242e4e369f64d299be242c04eb383f4cac6050cfee828bdf00a9da6233d0e2e5969997c79f3d63b8df8fe64381a1faff82267adc28deb11c1375535c65e4004a032e3b6d0394718f4e4925ce17c89a80fcde4ca018a921ddf0270b3da8c27322d1b08a70a536f4953472b7b7bbd571e48fcf32d1345044906dc1761ab13d8a694715907c7c6663e5fa6f35cd394c815323a75a4add11a558de83f82728453a2dcc8eb0f6862315f1346ae2e4b211918d207b849fcb93263b18fd1c3a33e0cee2a72216da5f2adecb06ad29c071413eed9feed2e9f81716466aef2f19d36da08663a0e0ce43f5d634df610393f71829540ce04700293a8ffcb06ff2ee87be29c3b7b42d1e6c11c7f188c02455a7318b264885fbdb4959c3cc59796b6a84d13d19a707288d044297ad7188c63db6a523ff98e4c9fd55342a49b9e7577ab14044c7eccdb3c86a2a82a663b6fdfa815de0fd4e08ca49bb25ddebb13a7f2c5c991d68f46180c619b1799f59231aa15bb9ed324e1697794878afafd16e5a99aafed150cac25b98a1b1317c65d8a77a5c817ec6cf764fd2953b9659876c898b55ab426927e6c40360b9ac22209195a2d300c528e876a2f70d4a0d0b118f9b74e3c50b7283edd1f8239ca77440a9d54d8029df47cde99d6052bc93a32537cf06ff6e5c54ac46f24e78363f5dad10d55446f4bdb5b04e6f55f68afc2766b0f0a56ce5e52683ffa1eae7c218634780114d01c4917c25952a6e9a3c502d63a41fcf2ba98317fa0cb2a65393b7503664160c9cb05f420e51fd439723f250f5c253066b9f7bc37f1cb7d78074898d7a5b975bc8f6a11e7f5ddd6d062040d21431a11dbd80cfa8bb76ad9afb126e7efdb60787cf41431106afa0313b3c919117c834769c2d4f18c217561980aada4b503abd388913e7e4729401f104b87b8c6bb5adc399e58d0cf3ab8d5cace190b88a082f759271c0020d24ca79660a5313be42a0cbb9ad8a3e07d434801f53d1894ce420fb7b022d1cdbfde33f46569c48920a2751662152aae199798861dab5c7a628cd2eac70717f5b4158a21f16d43f9643529ccc797ad8516fb67a1765f7fb8117e4a062a109f8a405b5fbd6ff3f33d5c4f33ce0c2ede815ebc8727371c5d9ac8943bfd2d92ca0c81cef7db70f8921ee164094cdc6c381c35e7ddc5578267989caad040a6786ea4f2a8153ec4bb2ff6c7f9b2fb1198bcd97956f8114493aa34c262ac811773195f7317d9cc358ae3830f8cd631d118c6979d341d57f0b9191b2201ece88349aeb161fd929ab966552e455b986f76077c879f57256a0560d9e3efdecdae6cd82a768b031a672a60b5e92899a4f668aee53b949387154bddfbd793376810b0ac7149b08f9a6a041d2cfebfd15ea94674cd93764279b5333adea6abbdea58049e99573d0b507f08bc4fa227875cb24a6f9dd00ea5157115c65c2d542741daf9931f22d24b2f24573781e8482e0b639aa82da7bdb60a7d04e0266b7c853f3e1efae8539ac683c15a3652be69c9929de59837bc04cc505be32b97c25f2a435c124b0dc3503d36d55a67fbf9c25167ddbc216bd467173e1c5de0c8efe81f65ad58388da519c910e8968b790dbcd40832d29cf5cb97c0acd0235fddef1e566913cd0d9d1221fe13f6e10f5a4a57d42bb9c1d4c3a7d054510ab470ce1124f4717253117c4824d28348fa7a0be875c074ee7f4eb4c669eb35639c177f3d54847419e1a5370c910dae6be24b1b7f61d310f7f44452f3fbcecedb3517abf3708d1f364c491c546de9deb8edd54c28ee7e1f2256cdc15af0cce0315e99cbc459e6054d4fb3aed299ab9c5649dc8379b73a9707641f11e7e633f68743b386b35fe068a54f42af012081c82befff7fe194cbfa8d978a83d78475bc82d194c0348908da2ae9b3fa575faee8b0e7e9c850f7ab31b6eedb46243a522446c1b68e3699887484f6b610b57656a921c3778a7fafe8a1f43fcb015d1e97d25e1f472ce75c1e2eb5573a22b7c629a93db07e1281b77d60162d2fe4a5cccf87f1f98508c79cf97a3d081b4af42c34d28db3cc2ceae26f0d9b80f6e0e26151a09a306514a4cf4baa937195f1b9aa2f18362b5973b02a11b4c046fb2a2f5d998968efda958cc8b3c67b6564e642cee72c575a52b6ea75b50c9b3253f0ab065c648d2e40b4049dd13036ddedf2a045be9c4859e1368067d076671545fcf66ab3a1f7c5ea1ad167251caa9859e95b39d4917d650b6344174d52c7bf069d100d42298013d9a38a30e7fa0b080caaab7c8a92813ba6288a2af9fca30c76e799ab0a231984ab9be9d143c06afb98f642245e27eecbfcb63c2fd513b0022bb2f39aff6099656daf26fef0487fe4ac5fe6d008cfba0649ef3249fc02b591626d8e88c2261f0ced97da04ed41761dab1eb79c154390f89a4ce5689d336e5753a7203a5ec98a2cc75a0aab2b73670f215cf0e0d494e3951122a4fc123edd02ee256ccf725966eefb8685230766a6318b3757d8a36266eaddbc67bbdf46afa1faec6344f52c03809f3283a085de32e11f41dff8dba55c624aac3eafff7036bf18c0b7e1a6003418aec474b15cdaf6755b335f93c135684af59f6ef72f10c8de791c4f4e4ab56534387cdb93d6a9de7733551e35904d6ccb9d6873f359625a2ac81be33b77dac55bbd52a22396fa674a71e24bacfad3e31ecf4b281fe92030b0710b9e1d1568ec846873b6b060c4c22d8c29e2de12a59b0cf3655a1e205c9e7d28b9f6bce57dda1734b7e76913056ef3c7790b29842a0527cdddc3a3cf693a1ca842afc37252d61f51d1a4f4741d3c1ffddf1f1abb7e677bad073c3660811108fc815b34f64360bc01b182da2f8e024d662b467fa1d9bd7c6d73cbee37dba74fc0844c0367931b05986ed34b8452e6bf13c70d577be6d0a63be3c2eabea28db6e0571f53c4163cc83c10eee0d037fad9ed5e5fb42d246cd7e77cc432c3d0489ac9ab5e5deab86e0ee8a636e50f6d05481f44a4361c5958ef759dcfa258b7567a73b2f5c25120829add0b2a0d4b9384a905d097d516ea788bba76ee4b7540a72083ba99867cf05802166737ececf729896268a23c8ffcf8dc52c2025fb9eadc4a609803cd91d6fa586c1406b8a919fe98755fcf8cada6ddadc538a3d5b4428458f0e10693eea816c12d454f50ee98fdab7739b4e6b467c45e146c3e70b88cf1c977b8b7343d5434e1f502276c9fcaf8c61d11d4d1328e8a387d19e33e11aeb6760abf1b29c26b42ab7297fd0efab792e5f76968341b7a752d49f05919f3251e28cdcb701c7d494888f31fe37faf6a3bf01420d5b275803cc2c8354e99d7d6d3e00d03366c375d26af7495dfc6ba4757e7e6a78a63bab9db4a1459f689ec6d605b86ae8092072da87fdd1d9c1146fb8a6293c8e94e747f3cc92cda0c63fb5afc1cea59551ac694941b59d69e8d0548ee07e6ddbdfdc53e4d9afcd6e821413d286945884ca36316e409eadc8a7517026f4b4fa3daab86d83179fcde9f5c0a41a6b2ed2be63c93e0fc0d72ffdb2da858e75a1c151f5bfa387dc5c84d21fa8e50513abf9e710e0702e9e2be72432854ec4c1815a035e85e63a4280f99846d10bfa4f703ce1a2f7884c9f2f13023389b2f01e6a2c6375f47514661a4c78b4883457d656d9b406b292bd884c5093a148f59b8adcc3be2c8e34955211e2dcb4918bc7b9cb893bd755fa81a2df0f766ff8b4632af0f77bdbee6d236b27c412b1daa7e27ade0b1385421f74b9ad6f2c8a571184ca8e9b1fabd0385299523832eed1eacbf7ffd9143e9d09ef583ba03fbff0995b192869562c3046c6460af9444251d6c044ce10332241749f86a86bfc67d86533ef9d8fecdee0c71dd95e4a13464ff556e905f28f7cb9a50d9afd1591c567699250328f6934de65748cf22ed2ee13c46ebc1b70d8a57e9de05b427a029681335d5aa1d00c6ffa0bb4c23fe20844ad37a306de6117c656b3373773829a2ea2c286a2e1707bcdf5c38a93ee7b6393bf14d31dd31c6c0822ffe289b1d8640fcb4b32e6650c5a12c2ca350e6d1183eba3ce87970718dbfa6f62ad8081e3975a78a6bc3da6e2c4217d6c81d207ea4f1f3a0967b9cb17cd39e177cbcf76c47e95081169d8768556b09ede510673a2a718faeb42bd44b27edd1bae73f3e2913ec2b85e76a89951a130b25275b7167e8c8f2a761011a62c21ec7fd2543cc1bc3c16f09cdc98fd1a96ae0c2103a97e61b2c8965a2eccdb4b318f68a895ae4f154a03f5e43a1f0b2b9dc013dee0a4520a640752d94b5367430ea9271656ab26bea1ea67851689fe8ede92d225da1231391090c88f0023072261b1f962e9b24b23c8ccdfb1847c2b8758cd54ed16b153eb11b68005a423fe112b3c12782faa15f8b33185c5b9e62807fb14f88bbd3bb77f06a02b6da247e175609a6ea70992aa687f3095cd62a83bcc5a0753443ecbec5fd11901eca96b754e2ed02d95ec86d21d1e2e362019fc0107d280894f271c7744e35609a6ef53ad155b36008c01a81d38131db2856fd786609aaf0e5910b3408feccc1def9c5e1d4a492d256521ad4ceb46f9ea3cd52ebd4c9b496263641ff8ea47dc179a5cf26ee65c5354461d028de13999edf76655115dafe18f7eb3cf8b7989588903603c7ade347bcea2098102941d12adef021a2b0b4b7af72d9230f4796b259a21702e4cb8ccaf9a9c5a577b4f3cf59dac702ea5fab681c16f09cc5d8412066be831192de2c8a996e0089997e4cac546faa344026925c76008369eb298c7deff2cb8a037ada4e16f464c0494b20823815f159c724c607edef69b5548592cac2a854563e0fccd3898de793e481417fe82930efb6a0938e11f40322ed6c827f75fe3a863f408544a0dbc91ca7ef04b0d13e5c60b722843d9c485e63cbbf091cefbb06d5377bf778753c4c4101fb60d59b5f2046d6ab054154718183c62e683506bfbc0347fcf91ca58ee81a6d8e5f48f050b2ef39eeb4554eee5b5101fd6404d3889c00d6859fb535ef74431eb15c8919ea93ae04feba6098206c9dd427e3e33f95c8518e0cb4c651691edf7c6305b5ea2a2997b83b60b213c8fa35253656e54bf86123758e4e95388e7cf23adf1aaa13ce3960f41db98962a21b853176a5a76a36c74b3a289ab5e1bac831a23ceabeedffd95351a9f266bc3c75a6c8857d201ded93da147c9c7d3c83492647974de1bac02eefa7bf5ba15565e07d0d0b2c341e4648ece5d9713dfdb9afe37aa3e4670b4d14963d025222bfdf4b81e83400bb0d5fa82fffa2810329c03b771372ceb5634ac8e4660bd70b0a1a39086b6afbdb90184910497f85c53cc33b9286b9e29f7ed42d929c01a80ded7ee98fb754626d82ecb04d562ef9dcd9069c4dfbaa4a5f2e23668172b618e279f6df828879dfdd04b9ab44ba14ac51b232acaaad82b42f6d9abb849bc744d96aed9416e45ceef1b0f3307b57a37123979336ac68519bc3bb2baa27b8cb3a20ff47027f04385bde7d2e1b126dda7565496e82a2851d86348f84405ad249df0ff691bd9eb579f81d00262a42bd576e6f9841106ac624efc4128ff7fc55a7f498bea8311b58306532ddd4ecb8bd274ba5c10d6584617fe31559cc9d048e1da57f812a054edeaa0579a60c788dd66d4074d6d2b2dc337384015de32bd82abde38b9547b77373c3d6d8d32d416907237259f2b723c23fb18dfce3c9aafeceda31fd6829d90f4d72620878c9ac90cc9cd84828a10645092300a0bf65aae78dcce527dbdd807aa87a00fbc4dc230f9fe22392435e27da88508ab3ab366ef6662c34e20679e9cafbe5c05ee0b4ae07ef1f8430e3afd94457f6f92d5b28de92d8e0f53c3d9f8def2caf3c2dd74e16efbd96b86abbb7656ceb26092d806d511b04524844b5931f2403f4c6a8748dfc7db130df7fba878fe1f340eb763a930036bef800aeefa0e92612ca3f027667648f2babf2ab955c3d7cb28832234f04eaeeb4a3d9f21aee6b9a1a3f9b0e9c6c853b8cabfd51dfec2cae30ebcdc013cf5333daa9db9c567a185e1d21349d85be19abef1b823db490acfdfb65c2063b49918c929fb4e97b3cedcd2a0baca2c4cc7f354513401a7d2d58a99e52c338319067e6f47866ece5b411b1eb206715835d870ec9a236cc1b842472ec3c5aaea5dc7b214c8356f548395cde152ce2da9ec01e72a56e6f8e4491089a1e86ea753dd7ceeb953ad940f7955120b0c1fc9adafa9890684a63563af00fcf4a8342d10d4aef37f888d9a54c4b056860067181c9e91b48740f005c1e2149fcd055d18e8f47aa86e9fb41780b85115d333f59ea93b1c4f8c7f17a581994df6be481f58ea5b89f6bcfc3d5f2717cd6128752f03b25cd720bc1169b259478d0414d55fcf25cbbdad14dbf472be1363409fc0bf4ca06ada56f0a0c63be75806bab79a0094e98616e7e6b933e55adae5f58ebf05923b179e049f5970052eeec02e08b821e2b5ce0182b89d3886a611a15677a61c877c8efadea849976c6356fd433538f65390d9fb71d8340a570fe4ebcbff0cdad444578cdfbc618519194fb5a2a45bea0b2b5d0c6406915e2f3853bc570caa3952c480faca3d1bbe0deaf9a0add3d2bb3cbea731dc349329862666e8bfea41940d338987844f30dbb2c7947a07f4a2ed75bad0da71e500076efea5b9b67a3b02ece2465e3c27705ce582ee9aa892436c9df9f57194a24d909c3b5a60cefa3bd42a1da9301a8dd4af3a2aaefd24edc23be53b8123b75a1e8ace32f863abfa78872601f730617a40d65856295c78b5db246661de8764180c3db911be4fc378d5dceccb109b3bcc30de722023ba75e01352b1edcade9183db1598c2da6465616e4b82fc66243ccde4e43d30079a5530a9a815cc4ed9a7531e8912405bcd7b8c48c31ff111ca869e75e804d9dbe82cb29c51a57951967cdc97a978b8368bc49e867b9dde5fe910371ae8d0777c073ec7cd7200d341360ea21ef6d3cf4e9c49cdc0f3493f073b6528bd20f78098c9dc81d149ff1a610203d5fdc6bbb38c6ee82442d46b9c95d95bae46c4b7c7f9e404bef0981f99b374043a0a78c2447423cb2a400274c1c2647fd8bb885389a3ea84397834f26ff721971026c868df5fc4e0f46cf31b4428d8d7fb13aa6e9bf0e72ab2e8cf52767c31fe2c426f58ce4a938ec479b70694c8b67114240187ad6ae00758abe0bbba08fb8ab86c21788a693693d0b839f194bfd06f1787dd3fa8b9e572b7572397a538aa2dff0c05547a7dd233325478b9bef0dd9e0b8daa3d91edf44d98ea7af3d10b15c653631b86683f8441e5137484784a43306c333e7c5f92219e4824f2730572a8a216f019a6b761082f27f5d40d5ee283a607a825f5d038cac791ab0bd19c8e77058a0b22cc31f09a6c7a0df719359d180355705935793c8434df55e42b0232f938b756fa14a09a982f9175dd93dcdf9998c050fd8d29826b3cdeee6df920de680f2e76a6bee28efb611ef2cd140ec60e988dede2917a11ee9f42eee14f8c61e0fc32ad1ace254f93dd1ba858fbdad476e01141eadff4502ce5fd984563033eaa18df48edb30e4cc2fffb076d52d967eb3bfa7c617df652230d0dd908975ac772e6440b92df8a8897749770756f646c6438929759150a66c05c515639d4a909a221c3a4d1cbd2ca69f922701d1e9c2ee18a56b0682e60e32011fb416ae881351eb25c3f576775f62f2c73bcd70f781c8ab51847baba498105fe50b540dc410485428143bc676ad09e81b94ebeb9e70e720f9f31aff97b48d545579036176639f578de3800e2748cea0c3bc252197326b76a8aeaf4ac0acb4b9605452f27f7a14d8e9ef0ac254efd446e36a6713b6e2351466cd647ffd298dd322af7854b4bcd0082f51834637e407095b68c161f520d4e28b11f2a6a51776e81aa189b352a9f223f25bff2b82476aba67cba0d9b91ea3d3c178ccca1ea62723683c2782778f66f797be69ca8553b23b135c615a4fe33a4c8f80153d78c6b9af25918cd7a6df86e3d07b089a0e8cebb6d3a394c74f7309c44b634bc5a95ae006941b2e8292cadb6944358f4519457a60e7e6dd60179980eea8b67264b9fea1d03997d1176c75d380ae9b08f4a685183e2fa757ff8ab7986068ec264a31987cca47ccbbd93d1751850a50f08ed2e77a3ade3783ebb00e8666303e240b5c146b744ea58a2ebff8dd411bd428cf6d47f9fa54a8adb32fa11f2cef23c3b73e7e162ffff44d0a1b1c427735222d6e0d6869014d10702d99efdb2f057d952070805331f6ac1b8a5f60e09703889a3422358f50aada7555d4f026cbfb51bf2e50cba8821cbff09901f122e93f6314658fb804b0d1003dfa3ce10e23e7632485eda1cf6a6479c87e95462d8cacc6cc513312eed1a3851315a75971542408ed2f0cef69753bb85282d7409e3eb4af5c8383df57a35b52a28c62c2f208f751e47db75e7a8f7cd496352ffd0da709e9899a2135ae16e0d691574616dac2ade926513ee25edc2e97786038e446ac2a271308785b2e9bc947e3e8eefbfa6598d6cb94a1670d0fb03cfb28220d0776270c7e77facd59b2cbd28cb96905c4876ec310879afd6646187335fd67e0a9b1abd0903c04cede349924c01fa2c195185f4d15d640f95eed34de05ebebaf333701cd682d9c10e58e9890c0fa687592f471558e6950ade3ff9531d2c410bd2063ac6011f5fb58c22c5c09eca71ed86d124f8e7f8fc64c19d99f56502d6c68de750ecf5e99a7a9fe3f8fa5e2acc823d3caed562e2a4821fd0828e0ad504281517289295ce358a0ae05188105f9f13fd39c846efab2bcb16e801de1a5ef96bcd581911a2c8a74b208fa7eb11c8ae47c58f91a43fea8b0fdb542b7754d5445769246970a857ddac55df0da00ebafb50066bbb015d11085b7056a8388b4238d0361614a3e289bea88a0bc5eb37e61dcbcba50e7030ddf659d005a630556ed3f0d14e3ef67ad0e955af13fe214ddd5f22985900f64eb8fadf29b7059c784bc0d16ab2b31a5b25ed153ca213819165bbe591013872b3621bee0d54404645e362a1a3925b6d5501176e5916d51ec9e151009a684441314ab3e3ddc51c4eed6da931ba94f1a78bf5b0f9552e8a83846d6714473c623477470bbfea803a58180c2f3e0d3fbcb264ad93071b1eac4131b6877e8555388092aa8b56b1bb8447ff8b712cf2bad49561e5b55a6466ba25dad560a5089995049772745ab235ee06a72bcae3fa11745f9b27a925e741d403adaad9fc6d8035cf7baa42a62e7e87ab61eda0a49b6880442ddcd4399a7d4fbb73b4a4a06600432e7a49575ff9aa30c7b585d580564fb1eebbab6922e4bfa1058399e357c457a244e808ff526825d6a84f28d99a3eadc2cafef964488b7f351803c9e94986b19a2f206bf5718fbdcdcce507b5d46006bed4ea0522f96f010241beb1c9ac5487ba7a26d084218e35dc5a26315e8d8dd9bce127688aff85463f94536e53186077ccf4efa156f4721f4c4d32fc4a83528d7db68aabcd2f532563ae3cb8eb29bcd0de855822416e42453a04238149be2e4672aca0088a62eb116668aa9df5eb1533579c379474361e9a36fc6957ef2f8a2b097431c9a985f2cc02a90435672bac18f57b5b12fa897bbcaaf4b5108a263399f00809e81f61e50ca420ab2eb8ddac1601f033704b3f022065a3060ef186cb8a558629a685b38d8591fcbc2f5351445ea8f7b4cadf1939883b9aeb3466842fc6934cea70d95541e74f9ec5bcd663f8c31a64021658d4e0e760f5ad4c9db6837ebe55980b092ff6a9b00d7d75d8a86ef52b21ccc9219c03756eb85a08e5f1dea45e9752797704db4d09cdaaf2d489b08cff5b8e30083c27472b9bf324c03adfb20a06bf7ac400f3b1a8b300fae96fe7818f2760e9d499e2d773d1163f7c072b9489e0d35620766395632a3f32fd8d4463d2147524c16c58678ef63a4f7d851696d50b2fcb66a2306a54bf426b80f15c27abb49c4e72b1c271da91f97bcfe8202f92ddf6dda8b01812ef4e12132db5aaf678e15fa3e34f2e3e5ac0359d6dba464557a2eb1c8bc3df72c77881a95bf7718fe18c1c931975fd7278acd134368f5defead755cce30b214397cbbef682650605734f78c2dbe40c09e75474874c2db0905a4857193adc919c4e408d178f10b4d2fef1507ac849515e357c863a25fb6361cd94ff87aa43006b05cea714af478523afe8cd0230ea1ded14d029c03fa309e4a784e8e03d2fe4bb9aa443598ef548d789a41c6f92efd90a9d19f26a85a59d2d461d4cf80f41d1ac21cc8cd93b23725d52ec79f9b619e81f87b6d3fafc34a4f4ca1104dcc3c3c26a5ff4a444caaf4c23da626ffa9aff49caa4f1ca359adc74ec6bd1b47222c01c763989037c2001f2ea4523126fe972938f8218401433ba8364216dce4ee933e32bedab6485271a4fa55eb5729b95fc2b822c26bcfa0f25183c87bb882fdb9143790fd4877dd4d09f127fb2a2d9029ff5485217e4c390407ac5f137dc9819dc9576376e6837a0f15bf54967d420779fb2f48461eadec3ad54079bc3d5499f8c13866a45fdfe6347d586e0f46ee4073f3f6e42d80bce8a9e5da352b2a00f4cbc311f72030d51692d0421f3ee12881cd4235e4dfc85bcef8cf33d08b845c21a4c8785be0a8d14c8fa1365aa07d87330c1f8e5a88e447bea8ef15c873d61fd2ec0f420fc4c4a035cec94b0bad278d1bb86cbad36e8c839b5b7c9a9ba9a5e16255de143490c41fe2d02df5e5af4bffd08b4b6efcdf72c585de20ebe19781c5ad05de1f8c8f83fb4f2efe2b6256f30cf56ad50914a36da5d5b98648cb695d907c50e82d6769b0cf405fa34f3e72e88684af76679ba2dce952c7d3af5252b6c02075acd08c78bd2cd2946e86e4faed48d406d5932705d5ac3daf95b32e4e2e53fc145edbe23c35b39fdd2dff1278e052f0b04b24374a8ba945583ac9260cda275c73de71df25896f20f5adf3efdc5cba8c947d11fa19f7bdeecaf2b4352b31674d4ce5b2821e3ddd73aea23c70c6f66a8913e957a5b4b4dd17045e976750421ff6109afcc6bc170aae27378c89519c89a833dc9e0ac3f5b854f60265b515694c44922e85280adc30dfc36f809233786150d55e51fc9a3c75c29f5dcb233bed88a0532b1da479d35be52b87324c32ce4d2e6def064e4266693283dbc63aea2657558713367b912dc9bae0a416561e696269e25751684ad16251c2b13c334a09824cefe95f6f72cfb3fab9439b6d1c74c325530a0b3a5d353b017b57c06fc5233f544455a2e3f2818d256f4298f23d52744ff4a73b7b3af04d5d41606db0fac2b8c4ebce39d2be8ef1ea16a797db6254407da9efb00b5523283f0b7be2af065ad357b465b6ff56ae1db004ed2c88d8cd8cb656969aa8afe878068515bb34d50bc2cdeec1dbd962ae7c56999d7bbd6ef1cf7ed8d769fa4234dcf633a72897eda35b3aea69c8095abc6fa6400dfb287d209bf12c615f6a39500f3b8a5cb62dcbcb003ccea4d5bc48ae3343baeafe4cee0201ad3658ce311bc24f0c460fdbc2147f4ab899d2a375631e0e1ee4c547b348c7d2a5ecfcdba1ed637ce71ce5ef242382f54d7a91fb587c75bc423db61d21a7720d80c68c50f255f042ba0d0f1773ccc0690bf36623f894280fa478597a1934944f8393705e35d6f1cef675a0d171adbc27621621dd5448ab8ea42258bae255cccf3ee3bd4f9618e493345f21d8697d47ba718ac1b83127f4520e041091d67c1be830edf22bb35f596557bbf47ffc78fde81490475e5634befc4ffe56ff4dd5003afd2c800667a07aad525d409b50b67db80e1369c93d36396e309b1d00aa60ccb7639857a72cbfa5386050a652a0e20ce83ee61499c3b9653cb0552472f8dfca3edd824718f4ffdfc9e2603d62fb9ac08a7188cb7a2aacb16a4565e15f93b0ecad63e4575cbf4e4b389fabda3e285fbaabd8d6c7f0404cd21eb8af991f31b5d49d2e3e5f9674680ef740119166f02b3a99bf032d934b300c140e7ce340783d7982d8cbe71895e949abc45bda8f6b670995aad7de9a3cc3e9a54fba8b3964fc28400fa67799a8fb73e1d8e09558266e37c95ae2b1f95cd6d549255fb27807477cb88b950a7bc2a2b9459950500fe7e0c45c27e0fa8d4b05d1db3a9f78014c47959e3b9be629b878090b5d45dcc3a774a4a6a591e072c9e402c678ba7ca54a77e73fcf334b0686072cd62e70e44bcd9744e8b5b618ec6a378803fde5c00fac6f589338a0587d9123f0bdbb5ba9b195410be60eea57550f2e2b724b8de96e2d9cba7f8bb33497b4e2d9f358761437a7240b2892c7bd8ca11d66d6e18b022c9a4f4ae0c8574f0d694c942eb07c5087fa0e8023967e816a40d9bfaa35bdcea33fe61af42077009a9d8e25bf24255935f4ca3087f931e9f67bbbb7e8923ea5232f3de62357832c22d1ce9e2e693f0ed7513d48dd80ac1d71560996b4f047869d8c1cbe9dd743776e13e408f78eb2bedb59fbcbb2e29a55a504ea416181867f537ca0230cfdef58974c0b762fd95039385d9a73c05e0b748cfb9e54f9cc1e69aae8fc6ff5119e3fc0dfe1a81e4d47605a40edd0afbedf6abd1b4decddadbf28bc22b51b8d45cb4c91991ac13991756fbb504b74e174374d7808db3cc2455bfea32ba63d4c7eac103f98f7aaefb8d7ad873affae252c2b644eff42af92de6ee56cba288d5e825b8fc3da7a5dd4182324cabde596d4f4931f11fa07f6f3da948a540a4d1e4b5afe8673770f2c921211e7d4d5b638ec1d0dc8de9faa8deb2447f9f38fa1605eefa60c18fc3a5d2d0c59e2e2e75d0939facee7eb8eaaa47fe92a544934effde3b23c05c8766030b2706be13df61fbd5a9eae0b3e862570eb6e5652755e53005206ff46436fadd7a5db2f6b812128bb207cd726bbec6e19b6bb7e3b5cf8a5d42598f63edf0e6b7507b4e475838ffa71d6930524c9c1e0cab4c0c1320e2b447c2fb81efcddcfd5eed13a154bf7cf1b293032a4d115008ae9ebf10b536dea3a559bcafbd0c8b66cef69b69a107a9475efd18fcf5f2ecdff36b3d737bb9b661eb1d138c477c5e7aeaf2ba8f1c3280aa3134768db42934eb28a47170270a2ed18d3dccbabaa2ce68adc6566c88b3abb6f091e75391c36a6eb61158c524c44f6a3d2d446b3cf6f89715e4f0251cba70f9b2c032a0627aa28197c2c4f90bff52d5303e7740071c56b07e12a0746b0fd0ebb7cda790b9d0f1799f2f9fca3bfd84638ad709e23786d2798a5dcc050152ebed33dd05cc52b70fe45a94f489580032230ca0683372d4f2f731ba8314110e9758e09a9a271f33f98a8c9416776d107a306a5befd638fd0a72ab2b8c985df5844afe616770e3c40bf5b9586c91319b87e3cf9d35924b479a92d1ea3a1f0047b92aeb7d43e4f97ee3aa7e86e39ecf9ce7c0533f8b6decb1aae3789e55614d4f5b4838599036113288f2ae8457039b29fec9bf0276040be60e44f7a15bcca598d3d70a8140786fa193e274298e196f0b22dc59fd92425e0e3a251c20779a6392f29f651253c4f1562bbd458c859ee1597627c8b55bec32cfbb63559b159a07f8f019d7bcde2c632edbbc0ac6a5dda0da537336b0ab1c06210767fb56b59a99ce881fdd981696fbb4f49d3690ad2b5e869635a06362effa9a0acaf0505f22c18bb96c5aa13c238227ce48a8007591bd9a16772e2a82ce8544b2a5c55e786c18348d116bfc0ada3b78b806c94767e71514c1354fc20cda003b2bb5f1f07e8c8618ffd37730c0660ef6186b45a7ed30eef5ed70d38bff7e67d4e989f6e374a9d10f5573e8f04ae97df9ce746a014f0e665a2b31406e0ecd8a3cb0b6e61b7520783980bb2f485a0ffdea179fcd45ae0104534df9366435b1a1d0ec1fcd5e5602ac9bec807fd53e2f1f5d3b05ae0b59eea653ced38352c8fe110f4a1d73073ecaf2dd8643c552353e56398db269ece9c68f50ce97413c89c1ff8c3463cbd3240b3a4611d9e25ab5aaab6af2ebe4b0bf6789fc4b6382ebac7dbdad055c9e12eeebcbdf2c85cba7c3123b5062b1fd0deac9ff71ebb4c521eba782ac6b3015ce35af92dff6e153f7f2296d32d5e163b21f49be9373e63b74f0d580dbfd3469019756921537389101cf5032f79eabc26fb62930aacd86fd3804125b3f80052bb7d8b7cc3d4abd932e24d3917a7cfbbe10abe88f3716514829ebac6ee099e3de9c7ed3de1f0e1d6378385d2e3b035ecabedefe85d507d0994c02282a905e72935c3c2542f76cf68e8b53e761525d94c8405f01f897fd0b22bf634209b1843328aa247a2edbcefcb0f62e8bce36c72400400096703b5d16eb125cd822c73e40d5ad62e82cbad9916d923b2031c9e5d61b60f8c71deea2f1e2afc0403888505488dc29957e0cc786e2331747fceacb6115b8ce94b672b8422f8aa9d3f71ed822ed86f74ddf61fa129bb75d8b5ff7c925c3a82059b3c559ed7210685a94a30acbe099291299110649b80f5f5425d0c590232ec86b814e94af87aa629c5c658412e62cf3bd4524303b07953791a518055ed68315186225ac91e82607807547892017d96fb1285691f396029a93bcb7537b32598c95c58e7012fe30386f2b5aa8ef74173bbda083c86c7397295d5a1b1a0d284472eefad2eb3f40a2196df4999683ae87c4ca98715c05517","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
