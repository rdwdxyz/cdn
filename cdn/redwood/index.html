<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25837b679f3cc68d7fbc9df7a65f7544849dec84cdffc636cd93eec77c1e7e352681ac2b6908b3a9c5e8314cff13dd27529732bb26b35b07835ba46462ef61ca9af4b200aa400732e172a8204791e70154b6934dd9a733f6c1c96dace8faafdc0f24261f02f84b81209a0c68dde48d694af373735f3cb771f2ec4ae05d50db1b08cca6ed3dda29caace28fc1db84c991ae73719e9f172f67f3326a77ad260b516be93d7ff70930328b86a78dd2ef2d2585a0522fd3931e9a917f5baa38fb52fe29445496b7971a436f867805133464eb0d2276b27627b365261e3c40c5eea0d45f827cf7ffe83262b8f9313c8004f3a28a08d2b1685b28957827176e9a0b6fea5e284fc568d5a4ea6e0e6efd6d46e7e9292020d9785eda2155eeed7eee910f703a6631608d00d6be244c88db7391b2576cc4cac611a94a75345970f55d4c31088d726cb6f8da73fb7cc125bd4f6655682dd9960a246bc7b60a9a23ace1d99622caa9cc74c8245109a0a40f56dfac4a9942612eac44f407327436f0f6bfda0a4e28143a22b570a6cabcdaa1d021ade9a6b03ffb4fe7f44a68d00252a67e6c19b4e62b16c283b75b2bbddcf237997884d111acebc3c02265f753b273021c2e8f1321cbdd79ff905355f74f65ac56824185893e6caf91ea21b1e2b4cb35b693edb752fc3aedf1f18dde848e7c2c29b3c977e4bf8e06c0903cd4365faf9f7f521b0b559b9dcc7d12ec1bfe379bfb8644bcf025ec02dd7679175164f07f92c1e197ad38728eadd82de6aaf9ed2fdb44f752103c51323b5d283032e0ee322a982133053f5839e2d1ffc1c11df73f03e442b261cbe3230d6f14d559495cb4fa7fcb9c88a8bf497c4d7c09253a03a5615761e0bc5ce8e9aaecb1a723ccf5c59043369de126ae13dd78ccb2432798074d1658648cb74e4306b78db8342c7e8c5c5c068641af358880f58dd8892440b41443859fb916e1cc2c8d00cf00eee6161f8d93a61aa14fbcdc62e3978e5a078075f76fecf998886ee6a00f8a0b6ed3c74d5419f85fa3ab1091c235fd2fa8d0a9b46d77f6bf540c5af1fbfc37a7dc6d81b41776b644ee3f4bbc2906316986778306954c1884ac4ac7e6ed2ac50b0fdfc9505f461d2b166c23a438ee1e9e10111c9fb421665a734a3454fefb8715d45e3eb89228d5deb75f63f8855fda73a3617e952b8ca0872cbbcb640d2feba8f093f588c6775feec6e14d8c546698d15b40433ed3887f82f595415bc00c2eb1599b59d1148855a6176510f663d61745d8c0fa11c83594579466dd6189da6a5e38e418fc5a777970c9c9f35a58899a89c31116c0c93ffee3571514fe2a2dd418bba1b8167af63749c7d4ca75e24bce6ed621b89c5a9fdb523340ce5c1b54e2d3f13986cbd7cefb7ff161b77adec59cb86698c56550eae4fcc11cdb7a1a7996af02f69ef5c6fba008d803554bdc79a4e30271dee518ff6897d444167373bea2c8387a9703f85eb1879e64792e8131592c0a7d5594c8c7b81cfd926c9ee00733d2d9cb81fe0628bb6cae5ed0434e5efa94e1ca16c63a6283973972a0a325d2277ed45e53f6e9e99d57be4c27258f7b499c39a6d9a7b6ff0cf92ce96bea21b3c5865d603f2ee16398754ab5a128dac0eed63b174bddbabf7177298f918aa552cf3e7ca3cb819b1db03ad37b8c12ecd7340a4caa5dbc57336aa66200688c45ce563155ec5429d2258bda5daa94d4ffa79b181173216dfda71ddfaa671ad689050afc8cb9ca7de1f152a6df9963436b2061d3b8bcaca062322958e6f8b4de1e07106417c1471bec268787e7a1d7bbd0542a6f7be6de74ae462c6bf5bfb30a59e24b7e30d18b547b53221b141b60d6613eba37596df2badf67150353e73374b2a45465a453139dc30bbf45ec6d7902d767b0f6496df675d122c406125ec6b10126ad8a16beec049dc98b40753b926787a6a0d3be80f9e8dec8b95e26988f507ae89ade1d731d759d652cd2457840d98623f781deba0a151e27c14f5fd1999e1015151b21ae5362d1e5f89654c47866d44f85e33ce5b4298b1348065a384d74b7db75a5b761cd7b1b95def21b0d7115ebc458000cbd681005901b4159827b826dc276cd4b39ca86c4809a14e77bc7730021f508dec00ed9077512580bd50d67271671ed53bdc7192de31feb4ddccca3b759748a8a11912f6266fbf320d2881e23761e40dd9ca7dbb6e6d7fea9b55f70b24f30a3434b11357a6ba9d923b860a1bb5e7aad1d858b7324d88a77d9b2134b3c6c0e049c95c4ef6a1d47c19a0200e684ddcd78ebab670a86bf3fc824c189088727a7aff257829330618ba190d059fd8158e7feb96ea06c0cbf0ff335285780e5970762669bacb40f9a6477d7678dc9db6bfc18bd076f337a0b5f59305dc71867b58aa303e23ab63f8f3f89659237053f1992295a562b78596d8ed06e73513fa0e7b4cf30f1b3651dedc9c57cba8fd0fa56f30c769b445bc1fe4fc7ba4c66dabfd1c804ceb293e3f9672a0404ba1ea0038b30b432958ab7bec7675aa9cb91e022e10cce9494aa1ac2acd6a245f2af76be808f90dfcd6135f09990b724a0cd5092680f2a54a07ef426e5410d574c392fdf9fe6048752c8d4e00274e0ed6583ae59674b84541fd6a631e4da5511357b855ee471136ca3c2634b5ca5261f38582da0f2b9bc6dfd214ac3cb908358841fb54e10198e83f2acb750b38feb6c2d7e9415d8999c354dff979886d508f87c137d38a4d19d84fef4f35f1b225889b238d9434b5487010e27afc1948558147a2e565bb4f74697f9b4ac497046aaed08d1dceb595a374529ab502d7ff3ab6265fa70e5ee475d0a88256c573f21d5a98041e68610cc7e29f59691d3ceb30c6c1a548ef138e824d64e57083e49d676ee9280e5ef2c61e996caabcc5c9a894fc20b1634f8bb1d4d8b4073ed2c3537c79d71e8cbcd0c4c25d77964ad4cd36f234dc443ea8d07115bf1cc82d82dc03bc9a9859b6a38ec9b31614beff984be02066e5d952ed3d55d0df3cc3f53317ead3962f3016ba2f41494bff6baaf026942fe9313c2e9877f2da84cbc9f181db694ae45d0561f8aa8f368c4a14cee2a6de31f442a10027df21b36389e1a53b2ee86d46937d601475c50d37eaa4ea8ae22503858847b88ff96975ccef2b8a1b9f7c9b39b605ed5c5cbe59db3b90dc41a187e618aa8f9de7b98cb13a916bc28c042fd3c03816a33f2b43fbbbb56d306d512b7ace9b592dc55ee636acfff5db7747c26fc1bd90c63a860e98d29706c5ab866ee7f2a73ed690e348bc854974337f0f5d7912f014ce2988ec2a7c3168c43854fdb59741a1e1e641528f5cb9ccee29955d4a9fef8a1ae1143ac651503075b0267aaf7ab3db0ca049520bf5082f1ec72b49b85f2ab0f15235b07021b51d41e560fca65eaccfc02d0e3c299aea1ba9eeccce62af566717073b308a4a87816669ac2d895b9f5e30a8c11efe7582926c1b49477d7dee9db0597f34a8979875a263fc5095f9ea7fc68fec6e34cee5fe78ff44d2db75760c49d6c90ab1969c108488b484c37122fdee9456ad46d8fb54c16524fd9f64debed44985ee2cfda6855fcd8491200240702631201bee78dc94535e8b4e86bfc72886b6d2e001e2acd0061876d91faf387b654887aa31ad7b5dec470482a9a79f6197b00388a0356cee5a1791a383b9c4add2cb7525f004564e773deb68b020b4c6be9ec4d30f1d5b1b09276e7a0cf065a1dc8a808c2ea6937acafa67e264d34c6d2522a08945cbf1aa097b97541029fd53fbeaa15931ac68f6e42a5d0d2aa303bd85461ed983ea2e868cec1ba164aa96264f956fa380568e390f76697144f69f15bf99f1b7b2bc933099f9ad2ecb281fcc1e8fd4f457c8cd4695a66865259dbb4005ee8d6e5c386870a5bc6bf323eab4c10ced2e36225a2f306fab51b80fd1e20cbae6eb5cbeca3e02f7da90b2beefe87c6854cf04dce40634200f416091e5e2fb25fe159e3194e09e6433e375924dfc923a823775ae4830e5f3eadfad74766e7ae9cb65bd7ae3a08eae51d6339d2480901b551075e8f6b600456e039de69b8452963cc6d72a2ab70dde8e1e972de651c39658a4e6ef792ba82b75296aca43506c25cdc2c7cd6d24fc61b0216b41c5ac9643e37b3a9f7688a94cb0e7de2f2245debf16d00a5f18027d562c1ff760e1225548b41ffc97f6e6664504934c0046a5de07078d26cddbcb1a56d68aefdf2917f709dc3d6eaebaa84242e9b30fe5c2dd8244805aec5105cbf21778ad0e90a8aa14a6eb776113beac7afd610ae06ddcee38365ed6090028af0b643961565b3ba1da4180be7b4e6e03b6a8fb35d94b1b00894cae458575ac0884bf910de50cf08ddc74072d4977cfa4724a2f2f1a873610e6ee852a4420c7c1d807ec494b7aaf005d28084faa078ceb23ef525feea7cfe87d4f6c616eb7c698e60b9d33b669f5823b6aefa53ab2969b3e3deb7541ce9d747f5d8bb87297e4db14d47fed20619d746882ae231282bfee973c2f91ae24a66e4497c69465a3d79b6d4758c2b60b4e0a7c68af95d0241e04440cf86b30e5d0375de395d8d1b768e1e8ef4ac6a3d7251265661240e94d7a71eda24fc09b7f1d35f145643c4779f0a2b72fe7c04160db8211793c4067e67c8b59ce39a4e7869b4f28f7dc214a6a6ab3c919b170af251d4c2f31e4231e56928e7fd80aaaca63467a95efeffe62ca469a7a98548b2d059a0fa509e96b2ed5cb1bdd6e99d3fb2550e79ffe5322fca3bf7003cc8d03b07ce33b16005f1b343262763d8885b8094430ad9cfbb987646f3163e71a4538e72ba4e3c9f137f3f8d3182a1993637a8b459c67ca0ef1f3e779e50d2ad773612638c8b7ad680cf304ecbf7d6136141485883ec3e6261560ff0352474014ed280b9403012a707bd940327f5d5752bc6992d9c5e1acd5344ab79827987df3ef13b82c595dee2ab8822d7e421191374b43591afdf96ec8d79a56e4a8471d0fbf92e12f3c1c4952a451f9397f5165556f14a16362b11fdc65abcba34822cddaa8eda4d5f04db642e452986aff41c07e4fafcd065bf8b4195f91c6a8943aeeb2f5e1cdece0a97834fa1cd018211b690871d5051f5f640548f5125797e4054ffb1da3fe51dea24fb192fed089bef856e1cfbf4979a4c242ee65079bbc9dde5660bdc8203b3cec664a6db33958d1f3766b8c1302b263ff34d75c6e38bb59d3efc5b656a1c4d79bb8a303481aaba5a65c872c463f14a63d26b73a7f152e7f9e4c2e864ceaca3f41b9c1a42bc5d122c85567528e94a7d9f624eadb810e0de2f74125dcce27bd44383ca4bfa093cad9c603129c95c0b476480a7d7dfc3b868ac333a836b944b1e0ec70a26339df312593b5a880a582216dfd9ce2ce0e6ec3980849ab95620a3fdcf5a9af144139c48c4c4fff51502fd959e17cfab9b2a007bba0b4a07af0d216937830d6cf328e2a76977e818e1a3c664638933f2d266d2c67562b9ee86e18b7d2534bb5cd73b44d32910f76aa0a7373817da104efdc7a1b22937934a304fe344d57fd1593de4777d54189fa79b13e19e937101dd1d0f9ca711320e209e17cee9f152c07062a2f263ec7d9c01aa611869bd418bd7b779304f718a305ba55366cf0d01c5e12bebdd8af9d4cc8398171bb0bf254bdf7cc78e0c0f339bc391bd41d38bd79ead96095779e7c44d659600cb9559d27c093fc660cd0ba68ff6e5504dea6c6086eae4a0b203d5726ee5482738ed9f3048f410e2bc0430b2f7c5ca360741fb36b14f1344c574f5795566870bcaecab37f9a939c3d2398430b9c7ac44f0739939d6827d0f57f23c2261bba3b3cd327bf217d7e0b98d572fd544e1961a18bc3bf7406c4faf0b58595d9ba3aa40cdf434d32db3459428dade963a8206b87412c33295cd5587dcd78f7708539d62e5df16b6da2bbab9e12a30c1c00fe866b8ab55cb22a26f572a40c747ceb504c5221b6a8a856930206aff72fa0e20e48493c10f5dfe014772e7cbc50e5bf80a09fbc8fe52d8645377bd2ff8ba499ac8fdef15c332040569e63ed16d70631081ed439651423fa6f4f4f1c759dfb79c537057e5e98cde0fb6a71a4871071b527329ca79b73bd4692e40a535f0b33e75824e49a53b6acf96d8a5a68de6b5eb19af087f425f85dd7514efb9da3413f0e3e02717a1910ceb0323b43779e7269ef9d07e3e1377d19fe1cdd746261c3d5dc46629506e38cf56b76778567ddcdebd67576ca613434083ce6fbcc71b04facaed9dbc382dcc898d0c1807c27401115d4c2dbf6cd26115fdbda63ba458d7002a325c5d8d85b37a1d2caf43720df3f1253c4832b10a8f0a0d4272e0fd889cd7e2425c8be68813599ae1057ac7a1ad75f863e2a17140b42ee1eda50d66b2808220d12a23d55af81a9929fa30bfc0e162ef60185905fcc78e1ffe03ba6e0e87a5f7a37fb16a275d309ba947b977cd4cb10ea26951890bcf11567c0dd63bc6332b1bab399f13ffd08ec9b5cca532f66b989df9b8574a48d21049831361625b9f9acf461166c16a40ed5773bc219746d5b20a5642d764780f32dc7248694c5534e720e38eed973c0c48baa75ffee4b281f3e20462ee082828876b2f9eeb034ca1529f8eb770ba0e0d10042329105a2d91066f8d96a08b010ec71910a55daee44685c37d8b503bba920c4347fd42a6fd2cf59474d904a8da593d8e635f1a80fd27c130679d98b0ff150649b7d5f06f43735d25fd4890a17ddb977d4451cdd1927f8c5c495ecf9d970e4dac065adf3b5148d022151270c8458e0bb87f5d87a7bf9b2fa8bf97f02aad8e0339ca0963792bd949d4aa1b3a63d9c988c9db0bdfe2f8254394e29b8ae2b4ba028be52d50b07419c5bd6e4ec3c503273e2464558e14d21e56ae9fe7126dfba001f8e9c957ee8d9ca00a8a11ddc766588242f3cbd6cdb3601407ee50fbe840abcba9d1249f041f1df1b616ff258b0c0d3de738fa141ba420a50d13590a92439a1cc08cf69e3276aad8a693d874406fd24f345891ef3cfce2e42e123f911d9576227a8bf90e5e200ccc4f7c1e4d84038d8291453cc62970dbd17823ccab54cedc853e5fa74534d05d21a507fe6a055012a15f59d62d2f40e82665879df05b4ad08c665c68ba93cd8ce728e1e84573cd7330120439d8f680f44cf7e183de6fb3280ee45baa5e1d8d700b4d0f04aca750ed926b00c869cbb8500b36c98c87a7df004661c4ef7b174e102126561a0b91f365ded8b7324ddb8d485167c8be554daca072f0d88c85739b1955998eb384d21a9e31c4f63b9f70071ec45ac965cc5fc8a5035088265c7cc51427b16c9f51cd44268cd3926a561c4a2215e300f4190c9b395cb42938250b1757579b4494ed03f55a6d1b38239ad42344a09f47a3e2d82fdc9bfa0d4f93044e228687a1cddd615ffdf8807454f49cb17383efa975f2d91e8a101828a22320502a756cd8a73cfa26ec0e3f8f599d90a1ccaade58850460fb1f93d7bd2ca05b6903aee3aa744c1ce2914fc543d1c8b36fff348655ecf23c5a113b384a1e92c09abfb477b36791ee2d6cd4959c3d4a62d788ea5b37e5fa812a2e2a5eaafa1a777d9e7e18110aa69b7baef2b1536fe3682965a4456e45ab54410a3d6aba470b0815681a8582046cc7b1ce2f10d16ed9d3e58c0e1491b6421f03c239b3e5315df53e2703059d783c4dca4c8d7f23a8866af68e27d0083340141cb922ad25e054ee5c3a8cad82793976ad09f035a3b41ebe2b58efc8b8adc510cdf7f736e49845ab953fc6c61b90731ea7a9f5c761bc1461f6c9fd4223e4c29203e039c195ddcae841609f799d8ffa6c816cf5c6c7c986cf6a46881fe2b5fdc4b542158130e263d4e7fff86072fb8010cf255534db66cdededd8ba32b0f03babb54a3a5d3891ac9bfbeb62217e19bddf34f77f1ff929c78a8bf849cb40909f3b8c1d67d031ca7186ea7262fb2b95cdf6c58ea8fa89fffcff3373c11c8a8f4becbf2169eca78df609a9d21a3f3a0be5f876e9d571811f5eed1edc2740784861c19cc2009f785850d8a8d1549c6d4fa35aeb7e397e85d9df86c8a1e9a4714b533cd452ae7b3d972ac047d259e2d97b0a5d5433601efc9da90c95eafba3475ffc01fb1fc2d4ae9313a3973124007bf8038a43f08cb5f3b1d9b8e85641e94c1a5fba704afd5593ecad250a6cd6b1468d992afc3c1229fcb4f7fe11b91de27b087bcf758c7e3bb1d3b3721320de35ff06abdc96491f238a4a3f25c24bff56932e3c1f2a3ba551ebbb189b16bd99a916b709bb995fc5911008c6248dac7c9da913dba5f9253da1e76b4d02b662dcdffbb5098c387bc90b8e800b45e798d0b8b3a4de4a563629a9388ce5ba01d224a7c37be5f07731fd99a3a288d80356a764c9f216ca809c657a04a8c9754472c689fe9787b4a41f5ba11f575c6e912c7494db3485e6c9f9bf6b088b2a072e7b9cd71114057e93feba547fb5558ca6793662ab399a24ac8a2ee716b35219d66773aa438659ec515e364f2284b5cda03e850cc82fc9741273b8cb272c9c88298183453ea767546c175f467f1de48d801d0be193b411290da5a71f42676fa20c009a551493a34e73653fb99eab65486f7ed1bbc159bb875e2db2cce14b31361504c9fd982393b7234112279621e7d0022352146fe07c9e45fc66110b5a3fe8172f4fa989d9dfd6e5e359d991dd4578a345f28ee01cd522de9c7beb3157fda77eca25ecae25ef6cefac758ef7ba46f0da57bc0d76ec058cc77a56d96c2f6829e21a86ab931d783666527e76dc3f9f2585f77e6641cc41d6d72571a59da940f94fabbfabc77089d446fe606aa201fc597d6118e6579a1b6818a51fd403e784880a73067b139f84928046502724dedbebda3f39827ac3c1df6e596cffc350efffb87d78abe08f899d52b3f3b5a59586da2b5b8132b95e5ffcfe6ef766825802c97a9340b0d0a6f5e8a68d01d2c437e459e260066115d3e32874d37e5f09879176b5b5215f1d6261dd7a1e29dca6a78675ea6232a95cecac794fcffc6d10f87ba7fa8e40567bf55d9140990531fd666c97f92d356ff4601d445e632955ff163da5d339c3037fe13141e5d99061a56ed132a773b4053ecda594bc64a5b0c8b2b67b8b0fb57d9b68b97a387230548f33f92deda971e4acadf9e340152912cee2ece8f4ee9163566ff42ad65652d30eb2775c1f3942f135dc70687a7c26a7296578b0406d66d5f1821d786ce19d2b82116bde3cb8998d86b319709ec23986d392575bc1243651ae9a032af68870bb72589d8647ff8e3ec0e25f2c3b3a12c4293c68a000a4f0df491cea3db21f7f216250687bf83d512654e0a9432c8badf8fd7b8c95d03738ec55b376fc104e9878d572721b1f6e640bd1882a5a273575b64ec071005de55baa1caf1543ab98a7c39c78c4bd7fdd0358ab37046c253397e9674485080e0f99a4f26bd8532a0f57be7969131565aae927e20f902675634d0e54ba1b0fab2fc59d2514e2ec4da41072d2bfcef8612247b9c360928665dac81d17c5d3727ebc383870b6c4f2c5caf48118ef8cb04b338cd5d048a6691eeba5e6ec088dbce459e52b58d71a7e2fc40c723909ec4cc099c17f8c42d1796e4e353dd47895b5c1eca550c8e44af86d2ec94514b4071321c3310499532c88d7cd85922945168537d1db0205c096aee8ed931c2949a27245e7f54489d2e278a55bad073d0f4621d6d7d11c9cf5b327fa9f982da20e816e694789d11941028206022a867658d3eec7cbb1ba01613714652af18dcef088bdba3dd4af2562f2d8bc69a62fee761bf777638fefcf63f73514e2302cc98f82158a3877ac71bfce22e6e27e1e9f7c9d5b770e3926ddb5aef5233e0b9c40cd6a334dadb16aca71ebc327fee4f1a5996cfb023b2811bb3f3692cbfa35875e2dadd5fae0a0edb29651add6b0638bc3baa88e2ce9153b74e605cb9decc4a2fb63c3f87a0d71ebebe883c194350e61397cde45fd27b150605374b5667e193dde80ba8f78db2730edf52a93aff35a5dea7020930b9120beb0bb049a988e1b8c4f64d2cd6c172590803248c30b4d87d4bed5af1f31f57998e51686f9d0c4b3f279010dfa13207a708364153b8e0ea2c572587ba55e2908dfa4809ed0ee69fd3551d2f9e806ba7c9285e310ce9980e6840cd2f19f8e8d497bf2a09ad86c52f7de0362758c4e52b7ef48e13e5d36cf4ab72aa5b38681390d6172336f7aa3120cc6f502e1b7b759f4813b0f128c6961ddd6fa8b1e5a2642addda6d286263f177ba0e98b949ce0d0604ec04a5b0ae6c415f3428c4130f7487a8af7a37d98be2e4bd18f01ae71b26a048e97622ff38b1f1347f87e682816374677713a720ae9b27ab525537b10cbbb46294c197f7edb7386263d673edb119bdaa084e7bbf785c16f3022c2195e1f9746232509636aac29e3bbf05590a5b0778c2eab1bdaab8e2462f1867b0bf3a159bb206ad9a4a61df338a1da5dd971f15c5ff932db4f3795223ed2c4629c69fc65f6c8672303e98a55cb97b9b627fbc0f4a61419774e56c94b169a71193168b62fecbbc55d2b36946e27c2627b03af253719620ed2da2497a75842e51279a6172184fc8b6919e849d328dfd454a039b742202cb3b51b9008c447ca26b47cc1b59c4cb07804967ecef0c08f69ef5bd260f89801e961c4f0d443004289577e14efb8de9ae59f020b3d718b63ced8d6007a399c5b22d5f3ae6f0886b2ad3c6c5c2031f2c8a44dcdd9c88e3e153f99b871c5f4369b67d5245b8826391f24872918a68d5fab4bc9ef47552e324631a2a1d780ef24292c3068c85d7e7d05ea89239a6f5b70a1063c6f62b7baf86af11add605d2f2fa03e7d33985869070f558aae18056d4ce9f115de3eaaf6ca51a47bc6c68489b67005321b1bff9f8f66e629ceca61d64520aab2f1d942ad73f4374e0a226213909ba04ace7d1ac550b1a0721f1c4fba34afee901e301f7ad9e7b863f3ff182dda92b28a8e77c778d49707404d4a28ef88242acbe328d84f1b14c64f4d5210dbe740bb347ce3a729687552a3463f0ea77732d0a7438d7668cac438e6020fccc0983c99d213ed6c11606079d0a17a482de98e7212c3a4b352184df0cf70a21dc0e73adeba3e89a69841da2d6c4580b11089a46fdffb9ea40d97c42cb6e8e299f7bd11c5359fdc0453bdd7c9cc46cf3869ef9204b41efba17a54686218c39d8a6611403a12e4b805384e618333c0df2b74893ea4c32e19b56085556654d42832318cc630f9573c337a9001148b3892a727c4c287f4fcac13aa81345da1c634f3c063ac367697a9bd4afdd5027fda8511ac440cfc88ae51aded7610bbe30db99d56af33800fdcf4b71c14a95ab74330aa8d2a273717d6fa7ab22fc2d35b346d76168ff92595f3097cb84a9ee6562be1b92ffda9fc828b738732fcc806da3c096d458df5a264ba4b13096b9ecbf8dd6c7814781fafd8cbf5da700ff3ffee9e3a02be7be5eaeebaf533487ce9a502b15da95768fa6c8ac5117b22a298d9704cb62577c314fc05e1763774d47d2ac87b6647de5a596b893de61d1b210ac31331793bdea384304e29287a45fc2007eb7c851d7bd7d46e9db70c1c5af6406f98023f7180cd043d4122ec65f5d3bd387ad09721c18e39b2567e61a08348d498cb20be694110f7710de06ee71c82fee667b6d150e036b2650ac011cc57eac682deee4bdedb0943027ad2558585799688ba27073909f0d34c7714c4039283b0d198ec5b804bb3abacd5d771a5b572edaaf7fe6a28f1d8789c3d4d49f374e06fe5a406c83d03d1e4b5f50106c1fd871cf21c7f3460a9d1b126c19cb95e63d7ac6aec0af1af6734438dda3f4873ece4a7c6d80a424642183b25c1a29731eab0e727dc430a47a06d2aeea8135074d2df0c40352e7ac803b18e4fd7324f554ca6afd32f5f114269e00c6b50a196c4f54feb9195316256cd25a49e6d6355598cd86bffacea0036e693fcd307a612e61acbef291f88b8c94aed28ece34ad587c26b3ea299238a1b3d1be4300a7f450cfcf99a416c9232c2f8d583d97ba97488ca34fc50a88d1c185b2e9e183d6465bbeb20878e20272976efc5af4431b6954aed106ce5d87d5487c5e1e3684da3377a39b0939fe2dae57287f6e370c6598db41448760eaf750591f068921da50b7b915d8970f6885c6a20fb64349bbbda89e98b835e10399661ac2562fe3b30c94da4629f2a472c8deadfaaac36ae605d078c3e1bb9800e0f0be04277af06949663bc56f6e1529ecf767a3dd6b823417e3a9e60dea013f3af85022b8212a0e885024a09fb4aab3c47bbd2e21375849ef318889b25c25eb3e67f5ae15df113ef45c9addc870028a9991c502bba1d603a82aabdd79372b56e1fb80d76852c409134aa13cda887eff104fb97cc32d8647ec0e5f414a457912d773155da38b52bc3dcea100736e0b78ee12bd450bebb282d87a521cf2d34f76992e49cc525181892e89826d7d2a7e78ac686907b941b4f11173a97f0bf674f27983d1ca3dbcdbadfbb394dfa7b58d4e8b829df456dd9a90c980c11bb844abca87d5d2f272423f15346b062bfd1e1a05e5a1190aa19fa686034243316e4a5becf966a6893eca277f8c3c5025cadf516e6304e6b65f2755d7507dc1b3459b919d28eda19e1bdc05eb48c98edfdbec21345a56d9a1ec153584a72ed8af494aa315782d93d1bc69ed5e42300ac7bf26ce20d0f57232d67d2b2006a431869b4d8fb5d656b96eadf69b09d6ca7a4a9335fb4763652b62f9ebef08faf49e1b47976441dff216f723296a17570c8631a4002d0e06f1b8d58cf0f6541fe02b45fa2760c8238792ea1f4f22ff4a872659c9d26dec7233dd9a5b0a6a4fe61653044ea158688237d30d7433041fa8637c298cbe7c87203bb5c59059e63135d3803498041b1ea7b7901eb14c95fb2daf620a8f47f959773de912565c6f4b26d45fa388edff09e59bdeecb74482b9db0b9def150067b0e8dd1c7734f8da21d2f424ed72abc5d7a5a5cd08a1085b0761bbfe970c28737f96d41dd5c2a424c9d658d727be46d86f6704a7e8539af7aafdcbfc4288051607d437c33835f33e61cc63a6069d47aa2cc538bd855b9b505cb0a0bc5440135137bb69f3116944a379d7cb833f8218b5b93e731a68b92e0fbbe7d026f037defe1b72b4a9776e4839a49f6c8104e5df3f6ef6c9c5d76902a80f263dba3a35c5bdac2fa35e3b88b231d689e271779c8705c037c116d8488c762a8dab5e5c1e6db6efb3c32b5f730d72af524788776f649b1243a5ac6e778684877508fe0e67f34feb08f718a2aa09e1b3b130118c8f1ae43d41898eaa0eb07cac73feb8a7b4c660f9c277fde97be2493441e8f1e7094802bf0ae2c833c94aa7333a497d7af35a16453be58b53fef2010684c5b1bc7919b2ca1a489ac53337f74f8b4b59e9bbf046378999afc21ea5653b55f0d4e974ce17a10d3fbdd54f41afdf3d8a730bf1f80899c6e6db2a212d29032efd5f2c658ba7b31a94b45842e38dfcb7f0079fc1755ef423c83c55afb4b4fd6ad37c3fc693d5697d46be103fc5d8a95060e9281e14fe5eb0359c6f0b0c45bf874ffa521693dd02acd1378b57c8ae80d1433e50d5a5ffd37e643f75d3e8316f019b878c4751a3b7f03799144bcbff2099d4d0a8ddba94b856e4f4a76ea9afa8d8356b32073da6373f5e1d13a8672cacfd15a6d7e6256faee6b9cd1d8def7b529deee09a986d73c0184b09d21b2a78818bc1dfcdbce4d36731f57eeaa0819dcc79de9387ca2a9b847224c475de29865e595d3bbb389243ceb3470736cb522f138a6bca7f70cc8205c5501c7c0280bb9a3fdbe8df18779ec7cc84182831566da5f2d35935d46d717c4bcf88684d7af528b9aa2c27481ffd7ce31e67af974615dbc8395d87ec9bce983e93e37c21d38c044e7ba0625736d72e74714f4f6cea03136aec853fee3d8be4ae73bda1df391a4e30ca4e5d0b5ca7c13ff7672f7ffa517984f32b8da698ff750026cf7efbb5ad3b4fd77e7032e9f578642eb2f334e0698fada078dfbf80d8c77d79d386e8328415b42a2e240e8ba3c252a8d88e979564c0c0b41f689f94ea51faaa75348fde2d8ef3fd957bdef2d1a0bc13f853c0fe58813da7c250484281ca73ab6278174b795093ea6deb68cbbe9b33e6c73c210d5eccd07abc459d18addd80037ea438d1578e1d86f5c896b6945ecf0b349bb6bfadc18a84865120b031facc8e8bed18ab62f7bbd8c77b50949cc1aeae1a887bcaccd23c37208f53940cb7869bb22e443deb63c98899b1b6acba1866caa4429fe22489fc24df277bba64c639c8ce4efcbe948239c5afd111d75b53a01f0abd4299afa0aa6cc17d5cfe8deaeb521dd8fe8aa81e4838cb39e5c6ae064d2f08710d62dd7bdcb11fafed8e6b8d165cc7b817564dcf3d63cae07df6894bbd0e9f90b26fab7a672f0ca0716f1f3557afbaab9bc781dba7dd4a7f5a7698ed13e773f3e6df1dd8173bce08989b9118ff4fa45fc34fe1386029adb7feea071b3aa83f955cbec98339f88b328395e1c39ce3c6607f8d68eaeb4608949271f0da26d9118983d8c5c956b0560969e77da2a23ce4b278fdf47541b7aab918ad800bfdc661470795e86f2ee4d0c3101e7e90ec4eadbd549af8d5835a0bcd151755084c490cf048945597ee71b4db67153c85f25e1d56391a3de560ffff12c964fb1c3b2bfd147cfefef03e599b6245a9f051de9ed64eef974713b5bcf4f4edd434235997dd9b0d0a4638d6c3a7a28ddaf8043a7dbe0533f0c37b659b99dc7f24a1f08e25d300608904cc4b430e8d5420ece6bda400f7e95f3ce2c9c3480291b19f8aa4d15c9c93873f5bdc22cfbaf95921c26cde63d7268f992c2e9918cafd9c7c78afb62ebd1e47d59a28ba3d776bbeaa1c360d7b6c9f44ca67fa4571dd551c540691f24d050949c48b24c693955710d9938f5ad40d67dbfa79cbcb3580e7661f418a8b11b8734c23397d3d335e6d744db0386fc8c55844ececf10fbbfde3a606fdf106b0510b766f4fa7c97b169343a7576c097955b3cd0b3e6c06dca67fa8cc4be34e6bde790db0d95508c8b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
