<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25ebe4b70d481804dfdb66da685aa180fe9ec1352ec6f521e92c962e68efdfeae408d2665cab98d70b2dd7aca14adceed900eb96af9a148facfefacf548d01242624c6d864cf90dbae9a020709edd569705697bd7b27a438e9dc80cc09c4f7a681346ccfcee52379e01a486faafc4a9ef695dbee7c3f73bd447b4d344ccc768d9a4c86bad5e6378a4b682e537fdf1660d91a497290396dbf8a5156f4b5c70fbd22322ba21ec057114a3951e1c2ced2ed97035eaa80855c780aa5f91e6541b34b25a9aa047f68bcf51166fcc2a12bfaac8c973b5b1c1af38e12530225f9237cc468a6db734638b3c6c731ae73ea10eaa04f8f28f85d145e662831ab54d6567a7963d19ec9f4e3e0623150f2ba3ca07621e876056d09e2dc1e67f8c738108c59b5d755fe8084d829aa1c32c57a70490d147c8b919003f3efa00faf4178d681aa3e399f4c48d9bec1b96c600f0cb50799ff8c8825219f8ca8c9e7df2a538949347ace0d04dcd1797227c24b1b4763df15c2d5cda25965156428cf11c4402418944adddacf2e8f8d849edc728281426e813bc77e04b08a1667d67ebd6ff333ff02f0bba1843f3193a7afc61e993a8dff4166303ec5e78068246a5da08a39cb82db7d13ae503fec6c06e50233a64ae34408da34287ef32b8afb37ce5391c83f284d6dde132dc1ce074a488e76950b473f94473210004295508acbd9dd2765903768f83a60a442eb8fd660d9cf7703c2751f278904e0c8a2d214157900b516b1c57b1bde547a2a62c3c93b56cdfa2f76e138a5e35d176f48d7f26b887c76b2c38b1469398ef0cd5bd4a8a8f1ae7135d17eee015e13c5d46490d9d4bbf9a67d0c70f29638c7e583d27df79b0c2fb65f42b13a0c83d064ca03fc6e8e85dad6ad6417670baeb47b35817f0a7ae6a7d92cfce008ebbf7d79cbbb37589d8ce9f7535a9c8ac42f5df4d414552aa2acb402538b11636918149ee0b1d1e582c8ff641f0105d80f5091eb3115bef03be62d81716594d21e8ef6f0ca45e712a9bd0f227320fa7df90cc3e8a0d4798d5adf59d00e30e1741f17053f509074a5a6c015a8859bcfb60dda55bda2c5b98b59eddc14c53cbecea3e19c3569ad1654c4dc039bcd89418788cea21bc1fc35b3c531c7d96e14a07b62839288d6f92818dab3b46faa38de62fc7e88c9c6ef0fc1b70e8ffa0d159d1779b14d957413d6b31ab877bf6ff46377a9455ef76681d4543ca3ed6ba26b9aacd287e2ab1099ef6fb0be4a5545023847d46a8c16fa6b95972fb3c721fa59e59281f924145ad527f4c75825de8a3d96062c20774baba30d1b8db42efd28d82977f0e0d1b6350fecbdda3b5406d9a2a00c764cbbcef11c518e42fe66979c4b36874b42e41da23908dfa85cdca5343e687ba30da30ec36c3c52aa74b2ca05ae401423ab490fd9ac5e399b4257cb6e7b87d296dae72d6c06bd740a31b943084a29ce6558f49e130e226086ee46fefbfd013e779cde534ada6a02e8e9208eade0bcae7a99ec4ec633a7bf58cb8137ab9a7d0f1e052ff9e7fb35e92497fca8f4dbd8301bdfa4c68856a92665ea522b0c5618c329d0aa543af3c44c4e2056ab4ec69dea664d18b25351d6e0395a7a0dd7cf008bd95f98a19efefa17fe851c11f8919af460d56ea7c626dea15bc2adb1697a1d2edc6017f89642ecb8e66bce4d72480873c66b1b1072b63e099e16169e4b1289bfec71632da1deadffce2f16e134aa155e0b2cf5768a60674bad42c9a9a5a280fcda6ee4905a82368960e6be1b3d4ac448b1abc5dfe0b20a2bbdf7f8ce423d0964a6c0108fcaebb42742c05ed2717578ffb2e27646ff3a9407d49470f2f1d07c4011a500c81f2e79e187d72ea9d751caddd7a02f219f101de0e514a1ff48c156687d58ce2f1172d05a6ac112d4bc926820438484ea7c2b385f79e90a835dfcb9e83d589fca642389a401a5355d73fd1c3a21c9b312534bb82a3dd34078e990ce724b606b16045e55a4b045b193134ac7cc28de2679866f375543d16ac8cb40a83641499ecab3d478a4cc10041b01c0e57b603866c87c5309de3ae9b741b73748d41573f260305bf6fd8b4453a4215c06c9a891c9aa2b71e46f2454c6360a4069d53cb2871e57933157cef9133e7f28aa139218a1dcc03ac17d532c7291717710466fe62799a7c9368ca6cf6ee196a1ca8607c7082035449c6d9f7d2ee3a26075d572652dab942e5455359f66170a77a05c0b622d28b28247bcbf0e5857e5c27782e813e92d526923fab050a44cc9192358640a37df2e068c3294dfcb214240a8a295d18eb59e7d59c3c15466e5c0f85fa329684a59362b1858958505b75182893a8edac2443dbada63652b2cc2a9e1d4ff6054218cbbfab85a8d6971d924c71f4485b7cbf752621cb132b7069e5666e08f518d3606fc50e446d3764745d5f1505f5307bc0f40b2ba6c9b3ac17d7995a267b83fa04568700b99f39721fd517d2613a5602b41ad15900a0471a55ad61d28fe36df102c5c82f2220fb68457895d25efd97d5a8094be0556a95ebef4e2ab3b8fd9d98dc4ce2fde032adc93dae9daadc773559273291b47f75aa4b6177775cc6ff7e0ab40b04bb3617fabb288d6655c51cd0627cc194235c2e025d6d387cc5622c5a01274617a13aea256bcb73e8a9d7ff47ae0578df90a0a791eabbf0966dd777d646f8ccd6708dc2aea361eae8667e0c411201246ded9eab37f266000fb2dccbf1cd837912922950550a2d16edae43818ec26521fd55fc69cc67be73884618e2b64c84a3dfc482636845540ebff2566a3889f0481267c4368cc96d908d213366312ce5b5935d8c991a748a56ffef46b6f5d84ac579bd3090051fb0af328f32582a3012c6f38c810ed56f935395133b30591a513b999363b09b8e9816daee87dd540edd4b0577f8d27d769b621633ce43625680b79888d37156603e65e2f016eae1f574d0176c76f7a067f7b758a64e03701e7ba340ca8145327a4d4c0f828d0dce7e7eed79071ee090fc60f1573417bd75c5d3ef92df6957c23f1640b1149fbeab56390f1f23ae6da96f810c58c52e50b3e4a6c00dd76265e796994ac73ed0a6b760e6865d541e8af5916c2300c8535abdc2fab514f58b332cd7347b388354409548bd6a789ff101190108734858310d795a74126a33b5af4f9832ef3048418cb588b869065299ab4b978940cafa781a85d458756871a551e2572b578fe1d30098ba3a619aab27c1d722cc67e2258837f454077400c09ba34787a82f0302ded380cb7c51e40011028f056a56c8f358cd54f851cf5f762ecd39d69c5e1e6dfaa012a211a38e4f6326ac6aeccadfcccef76bf3789d172b5d8e20b181824406dc3fe85c453b3227d5a630fab4332c872f9fa4ff215acd6018d104276086a41aa223230af4a335b4b2a7e7a225266ed63bcb079ccbaa02f8e31401db6bc09225810776e96eb1b454211ffe5d0fbc5fc9df147365c7ea2b1067f161cf48f0c1bf33303b5d09e921331cee382c990da03f3f19a72cfc5efac75dfa0e28e9f0103d2d7420d8b5840c428f6b7e363386fb7bc1dd6cd71bca201814f25d692859bc85afbaec6d332d389f3da105caf082a7417f994a81ead45f5fd8910a4278290564d189ab7d1e8d16e1206672104bcb923477e7140a9f34f0e9043cdd6ee9e267a8b7a31975e6739237e37b80dbe1e1bd0af38a17f998042b40abcfd3e39687ff90f7873109c2ee6c6cc25dc6f984e8655758e9711ff7d8ae6dc71172417c9605cfb146e813a90b68c5a7e181b3e6a8e949313b302686768d19681211acae048fd9db44efd3a4d6ab52e442f8e606aa099e32135cb77f8ab045e8a3e500657cc67aa58667f10dfbff91eea95fb25f8156ab2da5f1b1ac4ecb6d14a403eb7bf47594ae41f86ed10080dd5e62721985e8a3ac1daf0ed91021f1b687bd06a902cd74669c385a547db020c3d3a2aa84ddb5ed8b5629f3cbb54189a19c685bd53f8976bdc5bb4928ac10a251b94d8d3b04aaddde3256007929fed0e406582004daa5c2a08e9b998e503d5ca5d1e333ee24f71107551b14e4f6a1cccbca166f4b4bd3744885ab4f8d9ceefc0e8a1c902d01919c71ccb4b06e9b4c167ac8f89c4435058aac29be2ffd9b3ee3dbd4331a63d5f70ca593ac500c5f14f74b4597768dea379f2d5d52e3546f05d6e9f15c2c1ccd148e4533ed6ab0c9259be7717c08737c0e0330274b8aef25394b8eb98778ba04bf09b7d65413f2ae6d0438b0054b2baeffb779701a2c6f9a58f042190722cfcc012b59b993d4315987d513b914cfdcfd0a372f4c3fdc18426e34d3e6613d616b8ef4a4b15bf9cb7b9881500de95822c828c83b28915edb2284b7d855a8b931a8fc01991cac2640b9545fdbb66909b3065931450e8c9017494e218dc3abea80cec5537755653f389ad4240e7fe8feb2a7a91f9a2088b5687bdfbbf47043021d448d941edc6d4a332e988f37c8207a4dbf04b5d482555c5ca7491cd348582edafeb216580987f89ae2a2cb3afd416a47254b8027f928e010dc3844a73be0b7e55394ff8129ae8b2bc940ebc984f0ada4ad15b27f90b7eab836506c72d9ab291d84108c786a420b6593e46c3c0984c46354583f2a74f0f8e27c55f060e8a431023d65d00deb3616604e58d45767f863a2a1703f501d32aaf764c64b17de1db0c22512ecfa7ea01d5f65833d69e8f091b751533752cddc42949a5eb10cdaed5f44ad8e51b5b6363c519b436bbbb134b9053325b4c374ff48d7e8159dd7c9386833e6df25a658e94f0c724a0b99a8e8a42e635cfee789e61a94161fbcf4c4dea7e039e5c9c297b92eca1429ea32ea3b65f0d7d11f2a01f2d30648e60c9de82cd875db43585aec7011661e28a807a1cb79908028020ecdf20485ab092103809e2c3f4000dead3e2dcf831a17d8f240c8370abbb38cee84796606a1d18dbf7c270aeac4c06a14a705dc7e334057f0e70a82ecf512dbf43a2f2eea4400cc8f79190ba11af8067ee8648fd49ce39da726c4f7c8a132a043500a1bac56e06b369d0690bbd4bf11acfe816cb36a1525fa45b3e73e73d1d11b1a626c024c5aa7485bbe6db4bea394cbe2a757fd186482b791cdae97bd6ea6495dc0099f9221ac9b4e3c4ec07c01fcf5dabe5c2dc2ca0267012ae4ae8c73a8568e0c0df9077d72c163f6446794ff578befaa5e748bd126d587cbec8a66a6ac4dfb359f1cf8dfc6a6d6e1d091c5fdabf951b8361d471c00f2c62ec732d49530c8c991409eda3fc7846defa09dbf2bd1ed0f7d1ece5596402f988c0ef6460ef19000f469bdb23d00958190bb61c75ba0d4b8e09f69c5a5f4241c6e8ab34dd8f242cd1740d1458a22d8aa1e2126b7abfd62e59214fe4ab39b363c7c398412a31d799bc0dac2676ed3b99874974e92dcd68c8a7e6312ed0d914cd9af5f06268c06780ea3e399390e88e222888499315d7bf4fe3378e7f88cbe0e8a85ad246a4ebe7346b9f5cd3ea1361f9c6aaac93148ed035c9ae0a904082588f9c116c903266528c88bcd17db0d224bff9ef8e8a061fcd1acd90e2e5c61a9588efab9099df34d95b4c70a0c522eea088ff3faacaaca421f750949c0a0a736f2ea7ba98dfa22cd470de3321befe604f5c69e6e39f37ca9bdfb14398ef0807c6c696df16f2dbcc482a7372dfb4fbf1eef424f6d377195156b0bd63d928c639e1f039554252588fa3a4f36f4257729e98c5a727b43211cd434ac307345cba5f541f9771ced8057b7f55f4842e803be25c368ba2763c76cdc45cb62fa3f6cbe148fa9ff050621e2711fbd94d3f462a8149333e9e007938a9e787fe86bf48fbf21b175b6c41ab641b55361b54471a0ab7a157e26decc0770933b1b92e84660581ed55a5b6a502db4c939310000311756db1f909597a4491ebdcd52b9a69e136cd454cafdf76cab4d12e7c43c794d62e6a2eb3fb73500d8c888732149c194b239cbe871c0da2cc51afab1cca6aaaa136e8940a5ea4938a3dc74df218bf16f1869852163e08d6f5764a01e853cae1e18ba06aadd1c2a7921a90442235d36fbb1c398d25d1584ffb67ab7961062db6e070af4938fa08d4cdcd1edd2f76e3e1bb4facbaf087618abe1b8faa056b18fe55f0697ba41db0da4edda65e255468570c66a71b1fbce032fa92c1f1bc4a7bd6b545a6727fad7141c7e45d3baba0f957518a9f95a7da27d5d7febe0cf3e48301af327fc24c3f59d6bcf4ec9a9b91715247c9a9f7591f965da88de3b5e3116d16ef76b05e22a75f350794352cbbdf4644a1a1f7bfe527a3554755325bea3bc78dac3412197a294c07a60766d88316f817a5785c83b58b59db64479dd0663cba39221ec5ee7428db1b9e8a9266e03244a335d87281ded88c0cea92da1fbd8546a4aaabae7489c611c6afcb8e9cd5ebfa1f7c74bab28c2a5c9016cbc53afcaaff48ea3b5a8ad330b4b01c927853e70a1fa5feca773a4cc5d920e0e290909b76f6161226c427133032387c23a1adf3aeee157b0e7b277b858f0f827ab6ea1dc675a2a188c6567f5bb225762580cd46d92f98d5edd18a523be2d8092ef531eb14fa4f9bd89df69224d787bc75c46896cb7277e22f93755007b6366374598944aa750a5d7b1ac28baa17022ec5eb167355f57e56a22e38c0fb89dac36182255b2c901e7ba23524c308552451824b286b7726e09fceef12f30e5de93402be02a6d1366a12650d47ffa636681f22bb837d8c335d803a55725c14f27e0a2b0dae7c47ebc3ebdcbf5fa12ed5e7a64c4735761609883afa35ce3a9c11ff9ad03dd05f36709108b4511ac13b8231e952a5a24e2d3864fbdd03d668e78b0bf0f85968f6c7771e1369c65f95dc3c2abbd57b675a80a6d93bb231ab322d392ace1f43e6284afd596e3b55125734cd1a8f351a987522f88c369cd64ff1d3bd481857d19746d37d10e906ad50716d6364e5d7298d4b6b05c66c46ac43a693312fb2eebc7adfb20298a9ccd6c983fcfd9228ff6e333ae924216fbd8e7da95d40f423e5da0b262b9582329d008c250423eaae9e2b9bec03a82c83a6da31b585699e4b0b92d8adfaa15c7ef6eb2a905a1e2e734d2ea6ab830af75c2271234f5182db8720f753059cb79894f874ff98059d66f5fe83e0c2013e7dd267fd8b3b1d738142c7aa0c9e9824121ca3f6176e9405e1a7eb359e13031cb455d86d7065f45da0c58c019c00d6a1112955d8c1389f3252a0d8b453106e6b7b99974ae56b1d92b0df5e4e63944f9697943b04ff2c4c9ea71334ae56a76504b771b1867704719a6d17f0d8463d364cf182c7dd1ac4167981220b15284f9e8c45f654649d65acf3cfa9b6a99fd55400d934203f6c3630d9abd38c72fd147965f7c358f40fe4f7ddb0bb46cb473c78138d1385b9348f85ed8fee2b0593b634eb141a915743547da4da6267d3297711395512847697539bf82b227cb3ab0214733aef2536e5e697060816db8476a0c14d1365da8b4a4fe2a366d8e9f36ed4110e4dfd4e8bcf670029a503de4c250f4c96f2a541ae879d45e64048a2a4892294fd898e2567c7fce92e4de79544227d429c0ab8d8717d12553f2886dcb8d0fbac70bb4d034acddd8a1d3d857246b20fba45c6767bf9f9d6e3c9ebe2263286b82de1bfc87a59f1b8eb234bc757cf9d9c16e2d01892c91c3a21a2f2a1d83e1e4c8cc4bb28420bb89d683b2f82f4fca77a25f60fa15af1b6a18f1031a21cc0eacc82dc367016f7db97e5a958afb7dfbbd8739bca63c1bd6adbb408e2aff67c38823d1a6e89c8a30f57f9b4462aa97ae6053a5b246178bdd66810fa39f6bedcfc720d93017c02f3a0837b1fb9ddc42ecc479d8261189235c12f4f3c2c7128df22e0da7ccc3930e54c46c51ec1bff6bb271957a6ce0b3be127028820ec74b01fb3dd1040154c60b6476e202d4fb8267e1d765c8f6abf6cef7f71a6176f68a554644a4f4d1f69f450a63afd58efbbfdd6a87e4b3bd4a772ce2d4d0ccc93881e48ef92e10f892725a1b81b062c10dfa8cdf85b4ab0c99783b7b296fdebdb4f2f5109e4907d0b1b35187458a884568710dad544193084ec451151a1a95928f6350d50a249b32f7ee1c413048d71a617bfbc043d3eb0f4bdad6d15a830cfa7d09d4482b2c728b3cd7c715cd7224f9fd2d182cf17926d98c4c18262a1d3ef3c2c412bfb99e9e918b96ea84a613d52efaee1771902d8ed67d8045afb7dbdd0c9b05415bc588e912e001ed2bc9b1a4987b66110b6b751fd12a24a1268edffa150958ce73431ae56816da5950bcf050b84b8e3f9be4fab7ddcfa4147f5d6ae5ccb03774f55f80e6c68c3fd3db357d76532ff7b22f556d076a0d5464eacf451a416946215305ff2196a2fdba2a89dfde4c4582d2dd36099d0a89c5898a48e9931566b743d2622eee853c5030e4c6f9cc483f1d4fe3535f624cec8fcf7becb0f4a94e5d1807fcf696d380932abee88c4f9cba95a76c9fe5e240a33889e8c7ae960f92099a521c8e6ba63730e98f2a6fff913d4f083c0bde43229182f450c2c7f19926e55dea28370484ac35d52911d8d82329a4d230979c8b8324644529c66b74f7e635ecf5538e990e3e5520a84e2b6d07dd4765f0ade2581f2392f7e39ba5c97610cdda9d3a4b266804bc0c8c19013d0957eee1bb94e985656806871dc089c451e3047739ce131391590327fc3132f92fec76c21cbdf253f4dae46dba29481f636cab5721f84fe27d7f113550d8128a23e309d16465e1ab65817e80a5d9d23158c55af9f488603865635693c66f60fc9344a406f56d16de3c6b6bb92472ab5ff6a524db29bcd9ac42487befd34cd1e0082daf9c282aec1d18a28721770ec6c93d36b8c32e1f87e129bb7b33d58d5221e24eccac13c2dcf6eef456965390969c893cdc46cc198458e2f2792bd7ddb661c77fd4cac5337cb8a8774aeac4f4f372129c5c332ac4d0e63b2c6c54200124b3d1d1be5ab8c67ec6777535ef3e72d29d2f9a95647bbaff648db3970d9287c810704ef238c183bfd512f7d4766f134fb85c75b298355efc686b6b460103769af9c8cdf1474522fdd8baea4c0064b33e54ca5ce77e1d62d58f8cdb3553ee943d984b6703ea70c15069720e5b689c143e61cc64f25ca98e24d489ee192a535e6bdbe987d5ec7ea0c8b1fb53f5210ca2ff12e698245cec69d35f33afbfd7f3bee629c87fc05ed5f93311f63cfb66e077e6d5cbad4b257cdf162fd18a08b23e685953b558d43de04eb9d5691ad553c561c548d6d9e140afe6ca5898247fde0bdad0799cc6272c8523170a61b136c9ff34b06b15e6a387171024c66106cf0b08130afb46ebd8c68cef7acb75f1510bb5d5e700f7691b935c7a932d89f9bfc6d68b5790511d1264f34090638771557fe335985dbc7b37868848d7668abb268e83a5b5b0e47e3d5efb6d4f1e15e9b00b69baac5270e20bec764f76d4562a8a133aedfb7f868ddbc33804906db22ccc8ace381906d16f8c29ac331aa0eae24314f8ff426dee98727e6a201fb093bfa696294deabc6d08381134a14a6e76f70edfa9c73b379255fd26b613e9d361ebd30c2397f6e0a0655d200892635ed8f9f838098672f1e9587db86eed43e097bd6a2b2a5daf81d426ebf4bedf657f1849e1a165d23f5494aa2ff7f537d8d14419980a060ec000c84b001b42fdcaa6bb230542237fe957cf296efe138259ae7623971f464aa0b58d84dad7df91bec8f0f02ab662907cab0f90363c88cf6a1b30030b1152740d1480d1cd3af1eeb9abd0f80e39d28ec963c7a5f49daa59bc8fe66f84f256dbccf45963fd93b9600e3784b576a80c36172292a451e2201346c58eb0b074962910cb7d249559c96fa9ea8138f9c4c323dfec279ee219d0d1192cbcec84a058083cc987bd4516b3cf681661ddde53046c282e1b3e232fca31de98fb62bbe4004a6dd6a855a0125b65044b87f75f35560bc191f4d52b67442dc1b6fb88af7bd4f29b483a3e005a7960ba14bce071d0d288e1b0323a411dc97fd8b05423d1415e910031d13c246d7e64f5d8e737c86fe76f1a72ffd4f568d52fe9e2da8b5d4893f37c513f627f1ed428d7751cae44804d9fcbbef56e8fc628cfa362cc4b537feba5aaf4276f5db076b9a739587029ecac32c6d279e68393ba87f59b304c33151a5a858662fa3255bad77a6ff03f35376f2a4c380b492911a074f7fe93dfbf7fc664cdf462ae5df5ab821423adbc1d84c5b9e7eb25f62b26bfc5643be74b985723cf7835d9a6b63c86c85e7e9122ccc1fad026051f10e99961d684f9a4c40c734e91bd9ed09d0e0a39ac864b3dde5833d51bc49c50c9c3395ee45338287f4ddb3bbd20381d9f19e8ad5607937a55562fec5742247bd643a496d4b946a76b33a4adc527262bee45dc56cd5837eea8a2a2f46cd23be5b9360621ddf825c2928e179c0718837f2c4f156529095581c4cc9c3fa38a6e1a682f855e0120123de039442f13eb7d954fdabf5582d8101ba2ce76545348536d34a9f187affd9ad40d2e2fc481fde08cfa1876883a3512d3339c82420ba3729e985baa513395765d9fcf206c8436bb6aa115f3169ec1787b93219d75cbcece994c45c363acc58104c604a7ecd942bd4b0df169f695ce376f938a9eec6a5e30cd7303bd5de2b28aa4192bf8051a1d0eade6c785ea05cd56f1563398e33a921601f2089a3bfb9ae13a6e3b5dba773f562b614358acf2595cfe2d948b6fe0994c55b65883497e7102324811959b5aa4a3bdcf283bb38b20afdb3cf8887ccbeb288b925c0d9249ca42c9f68d91afe203736ef2e68577b7da71c8e9e1e884fd75569a92392cc389d5a91d96192716db8267aad56bc7773b83a8f11c667a455ae4f571d92dbc65972eddaf17f6085213695e1a04cd0cd3c8ac2099d83ed903f297d5bcfcd6e5057bed9db0922f975420a041ba85ba67065db07b933db993330495604b1c2ebbba3a91fe7d08c4ed1bad33bb362cc65116666c644afd578b873f166e67193f66b8dea19b2ac19d4ad79c25354c170ea8d20be5e88d205fbc0f4d8feb13afb976ce9272bc75260cb767ef23ad4a63cc40e8ee0a9a5d8022bf77b575b1c3da8323eecd58b3415048b97f353e6d51d942567bffb8ae94fe8728f7e8015820c16109a391e17578592bfb09e87e3802354504759d36d83fe0d23ccd57206a8a5efb668e0a10bfb578a154dc1386e4f43fb3f9b1e85ef304bd427db31e999edca5849fef6bf6e28a51606b6a47ed10036bf3f6b9d330ffa515abed2c1e9ed64c12fe2740c61d3870bb093efa28a8c32199e6fce63c8eb2ce27576657770046360bdf472f198aca4e86753945d90be39c57f78fbce11de411b02e29b2635693a856812f4da8a32f1c732d5bca4d74cf5f7914c59a4be861f72c6361c5dbecb03adcd71c98f59ce2e8d6d27259f71a2f5753957c0aba8b15faad811dc804dbe55e748144611e17a91ad13a42fcfcb636d87c611a26894d48d598caba5c511a25419ca11b894224533d59a62a7c141130bc411f0b5422a75ec7c5aa3632e4337f3bee661c70485e7c851c716c028c421167d79c2037e1469d08cced1cb3675e5b39bc4b973948e96881dea650d77d1f1b010c5a968f7e3f9d939dc9460634edaf1ce24f4d64fd9e3a178cec6850e6e946946866500a73b2d56caadf53dd9c43ba7abb26e7dfa364ba0729ad7af33b65a94a24550dc28d6aad4150b573da8e1822f555c6e5e7f02cad94cdff03bc6813808cff6e6220e2c78e99f4635cc0afae1a72d5e9cc1fa9b02d920375c4a55d97c83aaffdc8e6592f61c850d9fc86ecf0591227c8e0518c7ec292d81bf050ce4b71a3a6a648b63b243e59d2a1a685560ecb49b1bce9d44011180bce730b57f0b4174acdd0b0cfe8b12f0c39d98af3a470ec49f212ae06a1bfaacc66fa7361ace2b36c6da060b3bb2f9a3b21bc05c59a58132a2a1d8b71938f6ffd21b20402cb6977468ed78806ffacd970c87b4d87d1dc15a6c2ff82a7eba35d2e5ce64355d96f666bb99114e193ada08a9069fd68f7d789118c94cf67890e66f9c139d6b26051b5818036b30a6ea683d8cd46e531237f8bf86c87772bac589d464a2d07d6367ba83f3267fb8dbe33f4c615409f33a0087e2773a4fddf0712abd03d6d1babb1034e0a1acc0e003b964cc0fa5724c41f88893d05782b6bbd22254df660906f2746cc05c24e9a1379b1434835dbd787f5500eea7fdb87008e38f49628d47e5ed686fcd3c8ead8b32d4d53066604b463f32f15e7a8be0343c5f7737c8fb7285fd5e6b2c18f5bbcc2a00d2be3af0cf4bc1d19d599852f5a68cf77621980d14ade265b72fd457750a3a06fc687bcd2aa04b7aa58c7bf306818ef004657d501d1403104e536ae51024d75715d2d7040347587df6870a241b71ea68d445ac1f1fc78e4b9062d6cb76c707c0fb13bf72849bb9f8ff810661b2dad61c3f4be1f160a6d4ffe7fe85ea2712b6df4b66eff7122826c1fcce7aa983aa6b7c29ae47703cc685c7d77c0ea622e35db79cc494336964b7cffb45efafbec71fd95fa16367691b8986227bf80a36f914dbba39f6777b090a64ba6743ace447ee3c9cd69f08a06dd00bcc6b181ab39001bccd7048c60629a6999ec24f0ed87c8b6ed1ff7622ee9c7eb3109b08d55577e1f77f79d4e4f14f4d6de2b34bfa44c0bab5d0d06fe808c0926a31c480f2e78feceda6c7c21fcfa82e42cc63f98d3e8cbdac324e5c17ed80ba14a7b01278e97b7636953f1b90250be3410aa8bc45abfeee31f8f5f891cd57421a17dc5c149f4dacd3cb8d872f9e7c31412ce4d798d89544ada06423e3946d4c3de199dbc0b76e496861f4d21ef6da62ae159909ae1a03a6ae9b4123d0e1e1a7d8e69fbca24091f2e22ff563bc8276fe19ab5d74f22e090ad0e935150e408e1a8a8ec7dfe594913a8a10252c04ae36f85bdf257d324e97a6717f1ef71d5c5056cf8635f2b6f61380a6a8b05d3b040a319ff1bdd0c800a4c9644b2ddf2325f6ec4a6895e04ce661d472a74ac09606f1aaba0373ef2b734545e810d7d9352ccfeee886651eff4eaa5d4eea4bd9af96ac8ad73633e5189656699442501076490433d864b14aab33b6b7ff958da95e68f15dc46e9190a78a8099aef1e34a95d021f07e69a57fdfa91a5bd834bd5cf806fa0631a1142b14bad2680bb0bf840dc9a3dcab368f9863656e770766782eaa673aea231e660a79eeb0436ba4491407c44f6d50372ac799f0fee182fd9dbe8a0b5f9ce99c478a3787c9e1b57dca33be3b1673f319ec2ef05657447e096ce4e32617f3811ef3eca29e15f71532a3a312a8a280f9c65528de9363142070ecfddebddf38ac3526639f499c17b52740481d2b7664c71f73e2c5582e62ea09538d34c0cbf8a3d4038b80489aea294e5fdecac6fac8a1923bfb2513b616213045291bd5cf68dde049617e36139d02ca5685f555558f1d443eaefea6361e30ca61a4a49f81d3c8f528e19a5f35b44c4ade1edadade731b49c284c306fbeffe25fd3a69b53709fa35184d1580b0a60357d17bd0b9140da133e5ca34b43f7ebf62e296d93939e05d5e06e7de1f09ba1ba501af812dbb43bea8e07b55d37fad62ebb5ac40bae43b314370a674282f358d0ebad68876b2565ed501732a4f163b0067a4ef3c2a1d3a98522f49d5758d76a3809fe26d5d8274d31fc17f4de5baa0bbcde03e1526952f03a19fd73bf3f4029e93404bde3e91c3c52d4637294bbb2e6cb0a4ebd631dd5aaac240552e2197e47cb909052018bb319f62e34149f12e453379431eb2949489f2cb3b75eadab775fb23bca7418f3710bd7269330688800b0c4ee6805aaa3c4efc62f1857e5a81d3d50e8800f0f47eb608b60b3055a61aaf611df450f2443778b12981c2626833de09595b6f2a393e634477953108f8ac68d2ffc05d51524bcaa9181e18d2a114a8b3b3544208f165e5c0ca73133a403c98f8933fba8b809da1e12dc2ffe8e8066dab9954ad411e351ab36d5d0eb73f9c7fcc343fa6985087ed6ddcd767371f7938e0785d0bf7d506dd2c160e4f1527ce8eb460c165bde25dd50a4bf51bbb80dca98cf7c0a11767fc1bd28e324ed6510856873275c484c58e5ee6197fdf6299a9350fdce4ed7ae022e70a2f4dd45c41c82c42f5586d0884fe226a6a78e3be5017edf9bf4101e53ace3e860f50055e5e081b6ef616ce4f241d0fbae2b4278eae87bda80fe0dc0f3ab1b01ec985a8fe79b76dbc32849c77633a417c5f3dcc1d075203460eede533d86f53b62ce16d46a3c61754c2a5f8b8bcbf9ce25a726e8a0dfebd440a7b0a21b912d683609f67c8f86628d46e477d076958876caa026aa4fdb8a1fdbeb75d76a46667d61e2735e720d8ccab14844a12c6cfa4c3e0d0fe293a9ed70880a9b1cee2163e2e5292ad5adb9fd1d7977fb5bb076bb2ef26658540699421da17f56c06e047bde4387d4803fca0c2ad3eb5cdf064778668905fd084059242fb25f882f835d824a056e89cbdabc5dca1a57d3fedf7564a880c3f5749a3979d56ddcc1ef7019dad34f2b5a354f80dba9309170e37ece735da69ded4f7f89ed5d9ba2b594291ba0b8105fa797c5b65468b5b5aa20f2f6ff471a85c00c668aa537e5629273192c46765e602a36799f6e1c47b6bf66d38419877a2f9fba41b59977ee83eb54024c83cb460c7a82a7f38459c15991e2d73190729e706f7b04d5c19b0f1e71a73550ebe022aaca923b19af449b8ed052ea3f7a5eb462cd82db4338f36dae3649168271c02b25a54af183f220372564aa2f7f1454b2b281ea09d07f7dedb5e418e699a95b6fe7a2209dd780fbadd330d05b4a4f4ca8832c8bc3e4d910ba3a954e8b2c8714995af101565154e9a16a0aa46d2dd6da96404418ec9190c287ea6c6cbcde0d8cd4c4a2891b63a6a5425e95155b1418a5a3107573b3f0ac93b9637dd37ef614208bb6b6fa30bdaec3f6304884fc09961882001faa040c149122d6f1d8b12a8ffb8f46cb716eddaa1beb804192723b578790170245e4409dfb5a5a6f6cbe1737bbe63556e205564a3cf6f1b93dc9690ef47ea4b3aa10bce75c817048d004b4fad205a7f664dec8a6b37ec227657d896062de0de7ca6190fb776020c18486d8c717033ff33a14fc2ab033f4711c8ed421dfea63ff49b36e0733f0a87ff6a0095d2033c602726972a74e88f5f259a53ad3704a333bbec0a778cb7d95e0911483066be9ae293c7ed9c06e4f94cb3cbce17cc431266052da43722c1992a9e837e1c564c01593b755a577ff56bbca53d5f684d2365701423b95de46d09447585bb0f99fbb10236fd80280e6347796214a3cb291a93da219a19afca00d03748cbbba0f077dcc5f682ca5d9fbbf67c64e626bbd803d4e703cfeec97c45647c3d0e6a9bf39a563548732abd153e1b271da92e8f2717053488705a6c50337e80bfe01a08224529500be927f7d264924d9c3d1034b6767d1e871b9acba083419b953b151a310043f5dc4453ca1d126d2a057eb6e84b7b4a118e9531ac1c995fed9ba32a77e0d34a470c96bac92e8261625abe3e13c2830071365112542465631f8809ba1c4bb04126c2f083682389ac21a556603ba4ac6109c071e2ee2a36f65bab7ba0888361bb066371a7e01275b8b78b11216d66754b879452d7e98401ed5522a34469637955b26071cedb2139fc013b5832902ae4d37eddb52f5c011403d1812120d5c8353d3c7642c47e6de8ad105f8077f7445b093d371e9dfa8a823bc800ef699bba3499da25009750f0fc665744508b5f40c75dd635b7c20176b62de27dad6fa6ba5177d1bbf75af77efb03a1c27478009953c3cf311d33a67bd34d7e0fd44c62017afd9c8ea0b04bc516da7568ae81065d2ea5452d69fc15a987d87026e554c2a74d7afef6e1af682f233afefc22257d4efd659ccd411ad807d602cdbac9cd9051dc5525e14745e633944b7d5319dcac945a4a3215b608b91afaed3b0adc7db0a9edbdaa2a30f51f2db9a0fd78c5726b963fe25ccdd1f0210abf9a369198daff75cf7d0becaf40c189399162c2060d79d8059b742ad0a5f6d1610800c4c3353ede51f6d58c36d9d04c453f2d2bdb1d8cbdb2a878fe1d86a3a10fba1c4a3f00d627032f5e1a7b1744718d0835550eaa352972971b0b2a17d5a48df9dd9e1a6ccd5da20797d01ea1e8223f0c393410a4c259586859196eddf21de8e8c9be586ebe345e2e5febc650689256ea44b40e86e99b5f0f42c02b0b5e05e64e34b2e421d66e133ec3c051102bd7a88a5018ff15d9c4d858e26b744ed0fcba967d9570a0288abd1ed8cf224b8e9d1fedec5043bb4f47deab4dcff049de645126ef2292ba9491d8ad39eeea53a49f246f5b641bac022e1d3e1e7a73444608b4eeb2f85381e2a2493417aab7fa95941399d07f33a1fafcd91b4c40ba191b7a928edaad9f72b292ccc0e8087c2893eefd9caa412060e1d8f3033907524f7da086a98c93af500ce3db24431ed458529d56e3961461e111ed16c5aecad11c331ea4bf913b570fd47b31a8b0d5393bcc957ebcce52dde57c90548f0468d915561110c9ee6cdd8f5168ecc7cf6271318062b6fcc9dd186966952c688d2e2f117c940c6714f5c7d61fa08474ffe0432ce7225736b3ba3ed3649abd3b2fa05fdc5549ebbd3656ec034d48cd4c8f84e374dbe046c308ba29477fe03e300daba893f7fc46d5ca1fa29e0524b001c4230b47fa663b37af484ede1742d9233974438f5ae34c8e1103ba3ccd598235ea13c9938e64b8efead5861e264537b7df431b9bc59ef3de96628f850cb025823ebae1e823177598fdcd47eaea7a62170ba8ffee8f8820a5cae4c05c0ee36c7b04530f9c17b9584f48f4631a7874cee1e5a5935ad143b19453acaad9189268da3bd2dcc288f50cfcdba8f799efc473abd9141e23e86a75c5b6401512ae24774d8b855653caf2146aec55528ea84d5210826b5dd0e543db559f62bc63a4fd5d951ebafe301cc1878c184dd25fb817ab77d417ba0445fa9433b54c14ce98f85e2c3c8447b1deb824b1b69b17de1b9692afceb57804633243e6c880b5f88fd7aa8166bf63c7c580081619d610a4036fd90b5daa248e585c671d54947a9062ee9b1124df65ff0b5064106b2914100ad75b4cc0897afebbc0edb0b15eb5be5a84c5ab607ad2a710e9ea876b44cd7b8a195bce0893be29d5e76de798872ae17d81dfccb2e79cb45efbf6cdd75613820ff9e7fe93235221db6bd7586cd9b3ef3c80134294c96758190b1d76fd71e5b85e7fd223f285801081f7ff2d8ca9840150c260d436f7bbecbba49140315e6d509753ea8731015650c1eb5e79966054271a0913e381b24f6337173af591eb570bad43438f0839ba29fe03197fcd70168c4fde2214f3664a8f95b784017ca49cb514d0186c9e8830e50adf3bef865af177ae313aa9f12452b47f6c8cb491ee02bdfdfccc4818ab65c0ff0136b598f3bf814fa81c8c4104207aefb4d9320cbd954e61bca759d9825c7c733e2f5f520ee23e92d2aba18d53c2809ba85fab071069a07a42b6efb74a3843f794a746f13f3a1b68d224e90a9bfeb7b6dfd83952324ab7ac38971e399f69746720351bbc755a0abed5096d8a1bbf028af5bb9bfefe6d047530f1473d76dc210741d4799fc943ccfe47c0ec1265b32c2f891b43f44b1fbeb663bb9d24e4084648333f49eddfc8bbd0ed8b336c492952ab243119fad049255f039c5562120df07d05f93c3376d8d45d635dc0f7c0fd0415939281a628e800bfa0ebfa889f275629da54390731dbe28c2454c22680b2de2c366a844021bace5ebacb56f972c909073f282b22806a22ad52e433cbc348f69e4006292b6043f8a0b1c90afb78debc268d69b66fecb48a0c603e3a5d9bb0c092c58a039089956a04f457351a9273b3796c884df857831a5b7bccc6891baa28b797b05dceb0e25cafeb5968bee0313b0b704121427d84cfc1cb9772f4c17a87dbdc32ede9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
