<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb8eaeddcab05f764a68a0eb7feb02ed2bad1aa768dd3a5b6f553e3f249179ffedd75cb664d6c53cad8eefe6bcfbe684e2aa2d03c1f9416f7428fb11eba67566d121abbf8679439bf9bdf7f82b83aa0e1311afce45006ee0b036c007b01256dade6d4346cca7898f94f3b507f615c2e339730fb9bd903503f9adf7cfd19245bf374a410938bfd502699d25c7d6e18dfaf52eb312f394c8c3cadf9bdfbaea16dd4725b41263b0d6d28dafac480a65e95cc558f2f8fb09cd2631eba87a643338019b816b1472389bec9510f2db07074c578837ee1af62b6acc1fa63999e0fcff0993a935f70a327ed5447d62c926708e9a17743b58ec0c578f9bcc91422e3db70ffd126e7dacd9a42c4dddef5135155414fa34cf81f14c23013095956da6f4a0fc4ac4619db1f54c85ca6160122536c3171d05bdb39af9e63672c69a7781f08c30dbb371ceb514d6111f4a63f5838cc2a581d4ca25c6811ee7adfcd551f1e5c9a6349b9721b6cd940549772519569af53d88fb3ee341cc4442ee9d9ec34da686335cb158a3487057dfa3aee6d77554bf9ba60f06d8ab4e89e9d9218d5a1a82a87a0a89ce537af115b64b8a8e541d2d76e4ed507434e0fee98f25ccafdab78fe5ff6d3a728c6d3f8345cfb6ab7bab792bf1da828c189a1a49297844f742ad5f62b2f29a62d5057846ea7b7df7969e88c47ea2e458b68895d4732e0adff0fcadacb7da35bc30885c85d094011c7cb30e2bab9dbcfa52e529b0d44f1a29a673d1360e697e58f685d7496577c590979821d5da410471d7631f5d0545e791924c0c2d626b7eeeebaad9170d8c564a418004412cd3ca521658b13606a61a6825808853eb135b31beca2b5ee8f824f1850c3438e039f8b18566920a6954299dce1af15cff8c5b1db2a573f1a9bb5ad92bfffae06e4d5c21f1483f7cf75700337e7788c47f0e070b82adde85e3ce0e7aa7c92bc8b5c1923badb7889b31cf58ed67d25bca95a5851be31faebe53bfd064b3ab2481b8974cc1054ce80c00c3a93eb70a897f5101bcae2d6b99c39e0d1327fa3cc74217b5325b54ecd9c9754c7bae74afd9e4ddac57f3ee3e9d73072dcbc02eb8c6227248332e483c8bac4788f380a4c8fe02a71d9452449b69195dbf947996734b7734c9dd854c5342967bb21079d551ccb8cf0535d024446d934a40f77cde0c0b2f0a8d262e0700e2dac838dea50d89e15f44048f15292471cec3b5d849465e814623c432ef65915d296e38706b5fd91924d09a6bcb28d8ba1ec30a415bd7a89e9ada7ac307451d438f641940c425f76264b314a17d2dbdb7cff5c5f64ba2fb2f1f79fbb6cb618ca89dbe114cc7747513b49bd390f353266d73f074882a782583f95df409ed917080fe0954599d1a522b9ef3600f824f9f89a9345035ed5726db4c34c7d170fef11db1e90464a4248ca72636f52e13b70b82ed6675f680fbea423f0b5b74646ecc23ca065bccbaf430e8e70f8fab7ca08f0dc2e8db8fcd39afdff09567f7258ff2a017dd55270566175696be58174c41de57cc5973d447357243df6012be0d96e370944b83483a5be6918c86b3991262eeb1b2d4a0f55e621ddce12e70964a2611f54858daa3d4befbd7706f37fbffba5b57cb28e9b6ce699ff7d109b8ba8f8929a86e355086567e5e325625f7011c6372fb045cbfd84f24d9a23876747b2161a4e5e38d583e4a793de17faa15acccdc6ea8bccfc4e0866bfb8d83b3cbeb5415e0953aa28c5af10067fdea90bced48553bf56894a22540d3743d2f0f5b9a30192639e7e366efb81c508dd085ee863a08a5235ef56154ccb0428c938bb07c37804d3b8197942377ed9d3a9d3a8fb6908f481a07b3760ae2abe6d28afd00db48032e0ef06b4a40196c21d3788322ea0a062b1ee29056e999fe27aee61e677b50397356a4163548bd202dcd64aca891b54abc29405cf45c4c8d3d703835c7a263569316e6697e72188b144a67f05fb50f791c874c8908df6b538be719d61de5f5254557aa69b5c89ee56c3e58225433105f6f2486dc26769c1d9759550065565dd8a63f77ed047453fc18021d6e24f2ca8a3c0c43b1043e5702b06fcf786c36a73e6c7a4b58436569fbd6e69988d8e6a958035ce31a6a2290e3a4d3978f662f4878997f6aa30ce69c437b1c373095c17f2f96b2bea4d6a4bba35809656c89a2a6966650ebe88346d2e725659b11ed3d9715cfed98900407c3b5445847d2d7ed6ad43bef6791b9f0e3aa3532db278d58517289ed2d5a50ed34098eab6710d1b9fa3c23523a66fc23571084cc1fab5f1c60d959fcd8759672999d89d623fceff3b3fc4b82e3a95490129d96ba6c16d0900dcd56ce64c12135de4cd26ef52c8557a89697a59d17c473dfd4758a44977feb079a1aeae461ae5ae254b7fd4f1e3f1c8972c0863d2d667d6bd808950c80fc3337452ee0ddd836c2cd8cfac604786cb12e884206fb26dd7b6f60e7fc59ab681eb202c000f7665a3d9da1f41a4143b6ad33003d34d44b653fd74ab5f6264ee8ba8549e938cb61efc30555e446513b20eeb514f4956821b1a984ae99a656f860d020792cb17d84348e40836607a2106b8b3a8fbcabc05c91e7ad8fcea1d3d34e1934291979d00c95f72f6cc0e9ff9097624ee20320f903e4d014f30bc0060fe5bb3c503bc79b483d838e35fe408a5f0a94e09a7151641f5487bc322c0c41f5693c020604e56153650ed86faa4a0300707eb8d89a8b4f313659f79982ace12a92a443f1cfaada883c48edd83ee286bff74ce3d20d7d42f40ee7d2bd57e963ba96c4327b0ed0c43b6ef794d9f82d8af99200f6c3ddbbb651af49bdbecc11ad6ec17c0b0929901cb3867bdbbb98bff65e49c9ce32472cbcdcf04f882f38c53e7d42ed9a471b23d0fdde4e9ef09be7c7875c95c10b0e4e65ce4f7eb03a28693dc0cf15a9cf88d76a878e1f1a56e9b356a6437f053a3a2640abb3067d193f0bf495b2da9127ac81ed5c354858db7e1cf2c4f43ca54fb842a04637c91b59c649147099f74b2d256668dbe9d7a70d7113d80253584eda4a51423e832b422984123907fd2703caee0f14b44e45af07e0a597035fef038ced3cf533ac0c208fede3c4625a353f9a5a496e6fd9f8938954bc2f8c1aaf422ee2ed2ea7e63629815e22194734a81694160ca86b2afd63d13add3ad19b51296d082596ea86620bdf840f559783e22b555a82caf6297c7b1ba8d5d065caf26530a2f9dbc495512b04b452e19c3fefa130ed5580a0183e1bcd932b21d36569bfb2956942288bb6bf47986df70b3619b9598de79c739fa20ce2e7e25191bbd6133e4b7f6cb4e67952440c48f70c6908c3353d6a19fac568f429a87b090cccb28697eb5ddda769ccd38100d36c03e47cd2f2fbd19cbf52a18ab2c52f59a439f7d3595a2cf9c049de23843f4eebed8317130ef3c366ab3d9306092f66ce49c21da6455fc5b9ee045b1909b68224b675d836aae61bbf0315883f10b427fe1a0867b4a2f91d0ef2f2451633ffcc9ee8d3873560b5b5e69b33a4c497c2c9f7f2f0ee5b181eda3b5debda0aa0803d0e528562193b2a1bf6010b6615a7b03a4670bf363dd49822666b975bddca1e99a9c8cfcc14fa53584bffe7258c0d25c4533500af239e235295ab49733d6f1456813731d10964b90ef21ae09bb581796c47e6f49910eade6a782331a4e2f187dbcd45a5af1e2bd029254f4051929a5bc3379fa2f07ba25ba1973303017213a8ccfc83248fb24b23ebf930d4c3696707a3470fe912a97c98c5695843e267f8442383d1a25963809ede2119666e999b7e2aa56abfd802ffb3a43e58a2918ea89706dfbaab0130068b00c5a955ecf34c31b09bdbaebefdfa61887eb7ef7e464052573c01a9d6237fafda5b3c20be42da56179b273690db86859ff273dca8c6fe7e8f1c5ea170c918f94c0ed9f149b9c2e7bb22553e02141cab80d8a199b039a4cced5b5a1ee6987137bbeb4ea6cae8fe86141145645346a2b19617425c679195861ed24a63550a4235176e76ea8889e0a41a9d116243d94faa96b0e18983d3e26c9382a0075786d20ea0888bea59e8941f4ad0dcded1df36c9e6a2a3c61bf74c8f50aaaeb853fc251594d087a81b17d6f75b45e6d8bcbc6b4d9d5c83352832b99c25e15d129d18768156e8ac7e18353a5acd6fa99652337ecc7f6c21c3868aaf550c6e496d5c6d3c6783abbb31168173c65f88c776fe701ab52907facc9a367f16c6a3f718959da5b9ba4a3f7eb2db47b819da83d96081ec16cc99d100f48d5777bd1acd11d9fdec192d2ec9e70e7aab7fded234752abc2a2816e80b0de3b33352f4007bb67804b463c4013bf99332fdc948ae6f06bc3bf542b3403b16155290fe7e38132e49662a621f1759ff33091f8b88afa19afb8a9512b7c5ce7197fb3193902250d1a7b3057879a8e9488eb8f74234e0c3fc87966c1f22baabe59633aadb3e238ab99f793a5b49a62e7b477606ad4ac425e113d57c21843a7ca035b857c4a7c774ff6ef5005f1928b5972f97a78f450b12f708fe2dae4200ed6e1cdc6b25a2ac652c3c50333bd8b9ac7ee3efadfe82b3b49bf3de4f9ef2646e39bfd63af976fbc67a8f1ae4c2b9460afac1d7f44817e23cdcab45b7ca633656869526d2f77afe1aa8de91ca894e5e7ed9ec28d8e9b3a04136d757007efa5244b7502246123b27095844400ff0085915bdbf0a7d189f0280c99db9f3b185f22bcd17ce4f0605a3d0c0f08d668a5d25baab7fe7a12463c3a1079740ad47e3ad267222d83feeda15065620fa82e4f7f3fd0cfc1df4aab9e5ab509291dcd9d98eeee6a2cc7c0a544ac4fb2faec43d2ce4644187f76c50ec5daba7326f18647c1fd98c6ec80a80d14fd38f6bb4ec54fc2ab0256b7a968a7982bc45238a3263b6c94d6890da4dc3fbc931e8607124d7d1cf9d9a47c09416083951f6c10c628e8a680ea2f43c8b6bf27b675e37bd054df57d0e676fdcce68860596f54c74e8bdc5da1cb886cb26e771a6825782ffb8e637add06d04467dda0a279d4bda13bdcc37497a70b3c1c90003e57a7ba911c44118f302443de2b9a181d7023c57ef635da69776ec3dac4a4ba2dddd77aa940b0779d4131f11f0ec643ae8de9be9a402641b0c152e1e1eee0e6185fc20a82c87348f3965fbbb8d9273b7f6c0a85bdb90e068f151990e92753a658645ea8aac576e88e1502cf593eaf46cfb50dda5f26500f1e63ae0e1c6fed11afb73b4f5c11215740e5b3fbd9180e1b9c59fde8b90cc8e10cdd54b37bc7a9964ea96b453146cc51849dc3852d84630c0f01427159f51d822a3298a011a34cf4896627ed9b270628e8d733c126f0d56a7979655e225f9461ca130631227773967e4b344d610fc0086c39c7b235b19d9710f29f50169e501cf25047e2b39107e1b222f8028fead5156c2b26df3cfb69f803c1800c8e62ee65d91461ef9df25c297f531b2c4a3bc7d20bae32801343840be2f12ebc27a1621d93159466b5c294b3f3aa9075a1dd471cdddd4578941c388077cffb2bef9212450e8c9241b209239d86d41b7a427b374844dcbfacdaaa29479485165c8892500902d217a91fbb094863aae6beabac8793f0bacc29f665fad1dff1c0365d2a0909077d7bf3a72221202d11036d8580e7d5ee550e34fc13ddb25c410dab306ee68dae020e32d3e092ddfd71eb1c08a06381712dd07b111a76ded737f8e85d60144be4c926fd1d38b79cce3b18baa6ae39511b29a5618a2e37c4807f48cd5289e6bd9dc640d6fab8639fc3149f785c6c0ac1259d00c79d4332ebe80156bc0471b09637cd36753c6e3957f7863e8a5384de86f5424535c9c4f332d6ce88555b2169e5bcdff24c169bfa8c1a666fc6353f75e5eb0ca5def81d9d9e35148de58bebbf7d8b99d40fb0cd86ec0364f8faf45d78d09c751e29ee09080e9a9641fe6bc78ade540e5ca1c374eaa106aba795a9e964a72b6f9bc4fa880ea7f5d30f23eb87fd7b0afcd1056079cd1c751f85f467cabaf9b58d022d782fc427b5169a3f6dc7ccbd7ed38b258f54ece475e24dfe519b3cb63ae98c766e0f6a1c7092533f6493dbdae972546467aa0704cb7a41a4fec4b44338868fc3cdf278df051da864a1090da44297fda7ec37f5986a72c1228a034bfaff8c45d7f314dac8df24f4723c7c1015b8e4ff8e0c63aeb4ced328fad3aa468d175d4be651d7897e8b3a71db16439b66ed63873c2cab27245239652bf137a7ed310977c8bf7dcb6e22b1bd5bcafd951690250e099e952d3de0c94640bfa8966b2f3fdf87add25915114de70e173530153853e3422f05f1ca68766c886a11814a160530cb6cf2056013949a4fc3d9c0ae0962871f3ef6d39244463d320a341ca04038bb82aceb43c4322e47fecb49a05db58a23f16f4ad8387ac7c3cd736dc2da30d0057d1cc24ec7e262345fa40c09617645c6cf6fb9aaac6bf2b4576ec95cad90d2cc9bed61f73f23da80648a2c843714db5a6200a65048b624c50092b02397651fde275ffc163c93fea117b59d2926a7d89b128d278d618a9f3f28ed503143af0ea470d6183dcde706093a5ff9d22739a68be331d76aebdddecd673e8cc02a50ea3b1217d817fe4dfa8cbc57826ad5876c42e48ea3a92c236cd866af7cce154371bebc820ccc0d54b05dc0436dad7b91961b934f6fdc51fa33ad03a5fe3a3918e93dd6dc96e669fd84621f8e2f48f035974932b32f11676b223de03ab4ef3f843bd36d179e67fa438371fd34bc7855f20cbfa4f168c376bb762c73be596cdea409d92422bab0798b636b0c829a6ed600c7376db2c65390588f689e2cb7968a6c09f25d84cbef1a23ae4ae49fe5e7ad390418781474146e41c0d1ca0c750d99771d2797c31d15bb80491c740e5d7b35ae967713013d73740a6a0b2336805342196c35badfcd675499238ff81c962bcb29b59df06a1bda693451bfaed9da350445beb73fb166d09d7f678bc5a52ce3a2f69cbfdbc625491bfe26000d88cb66d27b7b607bb9c921a0b4cc13ee97cc764ebd6f33137f8ca8f59cd6dcb8962e5ca53a975f661d7ac8918102488a23ab855dec3e84dd928aeaeb4f3cf9d7a9d3358df03c1af77963e2de1509441501912ac05d63e0c09e4471ad054b5f18448083bf29a84669286dc77a348768ac282244668c7cdb16522c25d30a8cb60251f45cde250bdec2dd40304415e3d9a7b646ff63e7f486f7e34ed0c76c2d3f1f47691d19b83e08833e17c4f63223aad7fa850e970a6e029048d3aa067ffa9f366bf64dcf5b914cc1be883526becc7bce6eebc4a6a3c87d04de2fc073bc6662ed87bf375686afc16aa5a542b83b4895c7eb90b4901c8d6712a9b1f0af2515d70d70a9d8967585b2a646d23a1b405b1be2141ddd43baea3c9b146fb50c4fafa2a0ef8c3b7d53e6b933fc1278660d010a52620d32598fea4cfa329fcb881a8d138bbe349d3df8028e60d8da882417eb2a75f19466581afb1427024c2345ded3942c84c9522e1adf58785cd2f2d93a1fcf60d24776be61f7bf6eff30dd763e4f3b5719eb0470a332543fb79d923db4319f4690ba1afbd839d4bdc8d314651b1a457311577042fd3e40790f157e6146ed96e5e9eb33bb70eff676dbd5c4d70576ebfbc4fa1d5b7555d501daf3085d7264cfabebd9efa7f33e4f5475a54ff3757006a392c3cc7ba83a03e73aba3849618862769c014958664a0b860f2f53a6855af3c020de045b0da71d017cdd545850cdc37b48ca60027a810d25a7385053768717014ddf390589437520784865fa032fbb430a6e42ac1242f820fa7e6e6683f3a774fa7e2e0f7b8408ec849e56f002c1e98a6300aa7d926416e24329071c31e0ca741f10c5eb1dc77b92889c7c8ff2a1cb87732d89ded04c2a093ae82c8cb658143cf79d002f0e4ba9f6df748bbfdab19b48f9b21a97a16928f0cf223c86d3cd84f18ed5ffe05a901f9ced1bcd37a7caa2951150f903d2f2952c730eed25a8a48ec24291e6dbd00fa3560410919e295b5cca2025825f1c55ce4050a4cd012e8d6f98f960a858a939daa1a0ae788c56eb89a0ce0f7b6b7222e7dfb0bed47b7db2bf296cb6e7eb690656b2e7ef77660a52181322bb1122f493a661029915433cc3a1d69d0c159b889607c9352042b37ae16e630e356298e224e141264fb6bcac1930a7c9a4994439a8a08b395c61009542556fe4eb7a9bb16dc63454fee08b48b0de6d28f418d19929ee89dcde4416c2f59c68b5f172da84b0ac61ae99affd4078ba298db13417574f64477ac1de76c906b10e1562a8cd00470b0deb2ec61523cfa904fbfb1dae8b662cf19947ad6187a707c533600d7f8d8584fc984711ff998417ac03b2800872bee5f834e69088764ccf96fad4334bf9ebdfe703d590a384de539560a3c86e67bd75d6e2ec1f73c5f41c4dc6feaa3d3aef7bb30dbca57a0681640c9d86cb420dd10eaa72646c6636001f107d5ed05dc35b474da5575bd1cf09ee5897e0758a93bfb168980a0299bbb350fe13f11135054f405f3f43743474068eec6b1ca90a23b72800efd38908f0e631ebb4e0453e2cc33bfec42b0f63cbf6edf8978a99437de9f7c1ed115ed51bfa278cd673b9d5977a0305d9b29abb8df8ea9212690d8471c3dedaace6f3755eb52f99c0b82c742a8d89ae4c1de8eae2f87b45f8731a268fedc61dce727ffb5d3b08312e20a61be32b2875bbfc80bad0430b9ea445ed19f82d8790a2db1501f860d31740756ffdebad48e749e438edc7e83594bf999ccac667a242effccf079a4f0b649ad02ae8900cd2711764c2dafe4ad617b4842c39e58b5365489343e8ab90c63d0384636943dace4c23bc33652a5edd411e3c307e9040eb7c6c797f07856c759ebbd5fb368ccda0c2c1a39a4796fa5c6e646cb57961e9152fa351d55fce38c38bdaf05d5ce0a54d09e563be1532448bedc9449a0b6343c5dc66c1859a2eaa0ccb302092e124f9376365f725845cec1a70353caa82406e748a40a59f2587e6cfdcb74563b27b19fa73d44d11bb9565eceabbbf16731da300871b572d8352a1e59b84605fe21ade74e81dfdf20494d1eff8a08a6b68a7a736f85ad1fe3f8b2d5cda69f50a3e45e5a214dd378f38ef38d13007bd6ee49f7dec86344f9357ecdbad12e9789254fbd0dd9e6419021748a5c871f795e65320c043bc9f86cc38b9a1d69535f351acf4408d575514e601d21947fed566f85d281890a1dba86408345d0c1c88a6ae5eeaa273b319a110c85c4bed7d33dbb22b2bed5ad793953350add0943f575010d31e8914c27ce5de24efc04ee518f76c3762b141a90e46f9a551b503703ca4b214f130e1767cf403ad0f1033f1665b036c124aa64e3b6db396d6c69afcf787bf1c37c56445f5dd6afd0d4a5d3717446206ab949cf78b951e62df70ca1129e7f732d4a1378c19967cb80c5bd5b4b000b75ef69da80d264a0c3477f4ef7f899fe523fb627d0304885323b32706b31950d92bc8055a1972d437aa3123607a0e905f1e969884cb85b48a14790685437778a0b22dcd129ff35d6657efa8fde6c7775137e7126c76ad3deccfe2b3c643e817a30e0cb56cf05cbead9183d845677d6be1eaa320b74765b65de757a30364060ea1ec0a3a8fb77029476c31ae710f5b2f84d9ca80c70976646995231cad368f402c87841ff8fb4eaf5ee3396c483a833ea618f1b195430d80f0a22c9bd4bb78cf6a93eb9b736b4fb6c4afaddf8593bb0938214f1aac1d22f2b76b802635513ec2bfcba59ce0ca56546b5c98a488b4fbb63092fbe25783dd20b45a4f2d72511ee868f751115e65fe5dec87a87db29dde6d50a6cc466d04bba4cb39edbd4a43b21915a4d479b3bda5ef0f35b5c72fa5a5837d76e86bad96e6d88e7b27f2a088bdc54ab020bc9f11bc853aa787bb1c296a5ace2f5c5983b2e818761f1d75d584caf8d1cb00cbaf63f5217a44df64ee4ad2215ffbbddf6bd42d7b9b252d19dca92e6ddf88f39dc691229b3e8483d943b6db5c234afcf618301750347ad0d52ae95cadd095a1f97347182000016986db2fe5fada686188dda852b58c4f82e136cc915d963bf384c4eef4931c8bfe80f0c696e94a78df8c1e45c8863e0709f6db491f8d3e05ff00b73b466269634eacd0cf8788dccc7d34022eebcc067dc1a33a056355605afa01c8b18d91b2392cc2c77c5c402e9d0f97022269b5bba30b080ed9f1a06d12bfaca278a097fc44baaae6b7331c86bb3b73317ebddf40cddea91fd039be56bb9c6b299442bdb77e3c4afde88d45d59606a08950f64530adffc9698ba122cf82ba11ea589c27878cfa902231e9cebbbfeebb81c69d996df525f6d0890adc6a93a127f9a3d2879498380293df3b4333d2480a85090ffc1fce2fff0554836a70315a4aaf5bde9bce5059f0cabc4b93e0becc0b46f151805aa10787f22c4eb5daa6faad223bbf772092b7fe0c783e98302daf5465a2073abc7c4798eb9f8c26f5a5e8d15213bba1f8bd1cdf83bd379493384544374e1e84f7223482680490753aae2054292f104019336fa235d411cb171fba4252ca7afc0ff8f094d00c002a7e07fc7275315b9e958069e45610591875b9cfdfcee015c21cd67cd0a08ceb0822367263fd62cbddf1ecfa5361744be669c65dab6f38ae8e9fecfac983afeb3c8ff384a0c6de1963a6951f13e6e106327540605900e5d240d6c66fad196aeddf8763494f07ff3758495f844ca9746a3f5f22dae1ca3a38b3dd47d6849d68098a452353248595ee2c03f0f5600e63dc91fc8e7025203869c663354ec622de3a8c0e519145a4dc0a58b782cf5d15011acd8891efe1d0b52053d1acbaad5e7b4c60c2837ad84bb5014b1694a46273859d217e601a7761ddd076d270ecb49de4f43088507a532c714959071a96b7583ca8015860eeb1415cc4350871021725080f22dc2870fe8b8fc21d7684da699fa64d783efeae1477fd418ccf1696d6960fddb51174ea0ed0abac23f8d4476c8ef552bee0e1e9e1ae9fbb4d915e7627b8eccbfe20df801617a1f187044902a0f90993a043a4ca4db60e9252bfbb68f8bba7798ed105d75fdcc7d7cc1adb652befe480a76680323ccf5f69cbe762cb05e5c98185f79e585f5e94fbeb00fee82cf15d222fbb5093c2cab149825e313f684933af68a92465d65129ac62260fb7d5d131cd094421dded4098d12509ef58500a1fcef2edf52d546465fb9e5c5c522b40280ee7f3e4c5c50be3e50122570109fa9d4613f300fdd7c6eb22d51c314d288b88758b81ffc381376678fcc2ec3f00421d1a6e6ebb3a1d0dea56835394efd8816fae5f17ebddf102eb73996ad42a92c2585e16885581d40727feda342b68e49b5b8f4eea630d1f90924f9f923bbc514ffaf35f2ed7e6ed469176a9e478827267bb48fe5b45c9426488ee397eecb48b55c016b18ae0df61e06bf9a8ba77e2611121d67dbfd5f9f3ebe1bbf82fb118af383b6010f1647f1365c5f5871a16c9441842251f5adfc274d51ae1e73e97c6bc6c3420566c141a14a2e9c19093ff713b1ffa31731f35f6a82abf7868e78154881f969a46f56e35d9c1802c74d12cc096e8199ad7192e04f05e06f6d9d910b154cb57824c92a4825145cde9b836737581becdf13da7d5efbe3660ecd481ba67d53e6b276f17ea29442cabb4366f3d54c0f9e6dad5d95746fa2e45c36617664f88a434cee3b7c920e975964db6208b535ccf740a078d34d14bb9f4ba51f908e9126c258074dbde88b29ee66d64c9e16d11929c0faf1cd81388556442e23bbf762878bca155c5a884d5f9701dab1c3e987d3497a8436d300378fa8b8c937a8fc74eff647e69d002521089bd93a579b40a7dfce5872ddd1e234fb2ccb3776a4dd16154d6123b217575c07465e8997e738f4b1e0eee08d9f8ac85c4758044280f41ad7168f33982bdb7311e49c4236eec6b4a8f635baf66d5af2548f3a07888ab92c74265054804bc4d76d6f05882296c36bdf4d3f2e7d6929b695bf6f194aa2c0c232b44a2aa28825b7f1d2926b14f034bf98ed6fc0303e1a9ea0948f29ff4a9ee5260182d8b63fc3c9da6c2a7fcf638bdea54d87eefeb7f7f76dce96a218495b9185efa670b359c309722a748347a5034a02a370b09f673afcd4712db6b59224ad96d63a4ea8cefeac18c1e4af272205ab59faa6a9eafe0ff03da9521f096606f1e705999f6eb32e0b4a4b33444204f9218f10bcc7ddb7a2324740f8d55244fb9768e8bc9d63008e83b9857b0fb0eabe5df1b530f9910bd3ecef30376b1983ef4dab4d1e29610b2cbc68a9e2e6c9f3cffc530c1c60714e3bbb862321d62f7e8d3f6c69757bac2de029807bf8d85ac8b976b04375301963d936355cd87ea184e9c5d5f6d518dbe866ae8b626094b29149071dff027691ff365a73a41f245e285db30e5950b4a5a2b536deb7020855e2bd38f76d53d22b4c5bb66723bd17dc2900679174723b2f82814cfd55ed9054a16ca7399e542da4b6e8b210f84fa65c342eacfdd3f43d24e020435156328442a96b03cb57f2da52183053f2620714961a378fe0ba70b659aa24a564ea3a6a4ce9d5c648fcb5d9c61357fbe993502f49b56537acc8f2575c0b1bba5f5a3178ab6290bb69ca5d54b7fc68133a5e970ea5c03b2e83e1c14aa953d558a824e317be233d7f04def8cb8f87efac13a5f5dd633813361ae213e784d6f39e876043ce0920afd4f752b20fcea88f917a20f79a61e779dbd1552c66a412bd81e604e8a29347261910063a8586506d392302c42b47260728be4c8b5ec67e00e04cd3ec60d9ffece206becc47055e15ff62240f41ab92fba0fa741b6c2437bdc6f15bfaf2532df358cb737d8a2742c1b9504fc61740791f9bf7ee791f576e894e26e7458a6e28a81d87b732d3a47960967880ec0e559667c01b13a9c071e9a51919feb147763c998caec79e5bab6a8baa8b45d6bb56aa4d49a874059e3bbabe9246753df3eb3e62a779e24cee623f3a7a5923a6da6a08517f02da6a77f2f7e56087ec6c2bb109096af96315e4db9a599bb4c54fca96b23907cec74e75250d0a2ea8603ab4e5cc26a56a6d69d00853258346890eadcfb673d229f5290274a3a62d28c2071fb4c1c49e67ba4f6b34323bb3757882db6671f50c8a88a257caa7f97d215c155439ceb363708e9e1f9617eaca5f45e420683e84afe8f0bde1c75555b2d56e75279f241e72338d2cf56af925e6a56cc2fa7d471a1cec32be48f89bb71187ff0c88c711571f7f228ae49ab7900a5fbcb7fae9c71ef69ebcff769720d0d23ee173b8ab7e123957ed9be70d62e9a1f660544074b8f1b9c5b34c3f581990da0724e9c72adaf9f4f9f155dc7c2319aafcf1c3dc36ad92157ced46cdb9f4681d408fdd5d21e1cb0a3b643148c252b1223e53d575157ec955718637681d8c1d32c886b70a87c7a1d159f6886792293b0ec63c2d9493fb545f63ca3683495955089078a3b9dc32637fa51753f3f867cd68d256e7fec95e46d6e3e0e39e731e7114564d8ac0e4f7e669a1a9f5456251d77b6d6cd7b9454351192ef289770afd716ad4d2a1f7c06596a0f740b86a0c807772233f039c3db87e0449227addef90e796af3b9997401c42c971ffba9c5a953d8e3c97a628666c8ae73d0ae16405c9aaeb9483a67387c8808062f769696c7e9982aa0a6faf4b279da3484520b812f732ffc5f2a7feef51e9bd73f4ff5f4442aea285e139a8c5943a102fbc09ec4870b0764ce34c76c33dcb9bc17041b923ae2c32576f03981afd585783670f9f946d5d32942c2c1c18856a9296d63a3a3cb8919f4e4ed9274d57a3673c700fb6a80dadf76a5cbe291b64dec73a5cae68bd46c5519a0c567d5ce3fd083ac489d8aeb8b71c6a04cd2055ec4da378f06d6e81c4de55045cccd15e8acfd2977a03e1c8243cfaf237e729310ac7e4f7e2bbdeee4291154895ba13696d2029bcdd2760e13f46284d28b476d87c3ed27cbbd030eef068d21e43d578e8cb3ff00c463377643e605fbc5959a4f185c131006f78e8379d4f3d86b947c848a9ed5f0cb3c275fd3286657a11cf05fb8ba4787bd3e24ff28b6d1435f91c65586c2f9fbe2d47f4c55a412e67d3f8617ce7960ac339bb59b427b91f3ef106b9a148b394e5895a184c20779f9b44b7dea6d45d16a47550107ad1881098753d66a86b93da4263e6f7b39030f59ef6d07c8ae2282e19aafa6c437fa09fbe91304f891cf5f602511b9750434559a203446753fcf832ab715aefc018dd70170527867b025c334b994dd5c413195b8456e2fcdc0c2db9a4523ac8bd1f32efc5a5c64bb0a20dcc7a79c89e107ccb2c8c37e92483ade031bf6791d52ebe72c2ce7b875951d6008926e59ca51861e810c08eb80142fbc660eb18aca65f2c8e84d755141a8059745ab6dcbce2ab71fc050e58f49fbc35d03bb9d381b606d021640828baa85e7e197bded4cbeac19070ea8f264b4ce62a73446974110e5bd157d994f32077c08df2654e2f27d62b31c0bdaea91cf4dc2fcc7e5b52cfd168a077a76b9c03a6aefed5563fcad24b0570a35432fbd0cf175f1a6ec7a31deb9c014c881fd8ad156b8f9271d213af2f5658e0f32c21c07bbc69f49bd211f4b4bf600896c81281d8dfd4ac893ae99b3d8a36a32526be7d525f0988c92a36d19407784a0c73378d49c777799c8c6286a6ca5223a4e2254f13165c219252ecfe9ffd6e940f774722fa0bfa12ebadd86f14954a1a80f63e6025fa1a6a0c193a31ecd147ae712aee8c1512857f9cdfb4a3da4787277c09bde17f60c2ec788f9df5a554ea97600ad6502a404614e9969c50fa0c37d1217297c5069a98b8598eb2cce6c5acb8686766786da264c13b9bfb2a1a64207b0b7fa65eae5347b0e3683befacef614474fe7f4926d682489a78bafba8040cad83758367cc5cd16393a36169cc55b1d6600215309a74ed18c8d1dcf6ca975409e6fbdc154c94e2269197ad3bcb755b230f9c963be6a5531e08f0300f129218851af5ca61a8ef64286107728f03741a61bfc1bfbd0cf39048de2b5ee2104ead85007272c18c7f451fea514deb6c65bd42f1f41771720a3b6bdd193ff2e898bb7e4b29b6ab70bff25bf726db183833f9a8638784c9480d9b7fab79571e20c11e75d8ceaf7cd1460bbb92505ca67e3e18b759c488f5260ad9710aa66abfe4dabbfe002a568b03ff85a2ad027662dbf3a7e57724df535e2cb54969a1ac269cf03736fac6a601c48426b4b6bba3450a6540e77bad2db6bb83310a180511baac14c41bb858a3f0e579ddfb2aab368d66235944285ed301e1400f9b786ac66d39a109952be76e0ca617c71a15e8f06b831718d2b201f99b70da8ffa6eb98dd2d57faf0e660f9ed7066bdca1b38664bd53cd6f138177b52e04735bbb016861a981e5f531d1ed4e0963f6253d4efd30b002d1b8b7600045c26359e9da75929507161df87f568d30a3e2723864ac43589f896486bab80e3973d1d3eec45779c89cf126810fa83f93ff7c8a52320c1ee5118196399780025211766b41b6ef84836e7e28ff6c193c4962f05114713f658476791e81d8c8871c037ca9c9544b3cdff52caa4f466cd4ae5f9af142916d880c4f07ede5f5dc6b1d0a9fa4492767a2aba13f82ebfa05fcc02f145e2fd151ce8ef001d4f55cd5b00b73ce19438ede9db772673298bd5af90f29fae3f9c6db943dbb0ad12da1e5bd4368f8acd17fcb7e62cc9b709a5f359197252ac0cbbd2b2bb4237906581ef9ac228fef7a226c7efbd84d403692c1a74d64f7ba590b5b34dae4243a18cb43881bfe0c6bf0410ddd68428de80287060add57ac181151e7776eee599749cf6ec86e5399c2836d93e61d4b8d954a0ce2577040ad1b9857ed950b9142b3d24807069521485f419cced2d8645fa566cc22ac90ab5a4a2920d40209db1ac460089cf6935e80edb1de61fe064455ac2bb80a26c275370cf48570dfd76376396179b0a3ddb5cf0187ff1647aa64fa70c5363a83cbadbde4edc7f79013ada28b35b006c1d009a19b7b6efb27b3f4adcdacc9c3482480807dfbd7b782fc138d7d98bcc422ea34e265da6f77ef5c71061164e88c1d21ca82fdef0bda614e383ef2b43a2934f6ecaeafcf61e73320c98a73a8c71d3b4319314b1aab26b804a48e187477fd0b46fe04278729191708711e7eb166a251be2a695c2ed392ca7807dce156c5bb2fcf6161f9adb4bbb0bcbf016afdb968de4f13546f3470ad1fb2fab653f7b34356cf81838b0a159c4d199f661b54abee738595a7f004b4d447234dadac8008565f2eae0efa13cf0cb9c525ec937bd98a0850b7efb5a53cad2a50f51727523459b877f563390e1b7757dd78a1aab85bd29e250ffc09342a4fed969d00ca08c66887a54cffc08ed82a2e3c9eda921b02f85110e5332061efffb570c2e0d9a71c71c72599ddf460b50504b80e68d32b141610c1301ecea63523aa2940474137a34518594698bb98e72d043c30dc474e7121e5e17326655518467029ed5ace27bc3fe19d1ef843410b02711ba133782cb78a334ca68e0cdb219bcc818b1ea3e1c3c70a7f2f02d2cc222c29f6b0dbce30a31580f337db3e811c37622dc1266f7cb011f731b5561ada4b92c31627643d6e4c353d597d3a01a5891ce8ad222f3b87ad29ea33fc88f8e9d0bd743b2fad1ef028fc2ad1c7a178cdb142b59e340bb834b39e5f90e74f9c8cfe598ef285bfabd9374a94c89d4dab7aa52bb635280da15465f410fadd3abcb71e5073e146c0a1461b8a02907458cc8a24b408fa03cdaa1a95146c2e4e15f29056f03968fb1cbd47ecc333367bea15efffa8655033ef2d38923b2c6d536d0ef331c850ae4239e366eecd6fa67a3f74186b14404eea78f780bbda86fb20a70917ad791116fa9f3309891eb04e7d667a4deb5870ae568f713664660d759a34b6582e79de46b7f9d8a68a7b0a42fa69970d2ad2877528b1dd1789b5d5afcb520b179ca428152e0fc4b991a9ee2bb4c6fc617712e72289c409d1c5dd5652cbb2af4e691376dfce28913d324655c8d4b89822ad68fd14eb9d5a523a00d4598256d6f4a3c42f6969a2e27d3f6c139f41fe40dc1aeda01dd09786696313e4cc4bddc5d4c3b42c4666d209c623932156d3552acc8dd1e03ad7c1b035e396c7a4a8c0f378c7c0a1a39fda8af7fb2223304c99f7afb08b00b2b8525a557f5683867dbc48e2ee552fb535d04356c2d396ed1eafb457826d346e29116633c5243c3297999642ab700dffcd464baa668ba2e14a48cd63497642ecf382858a95098e176f531b1804e7bded64226e441024af6ccddbdeb82faaa02344274cbb971d01c6ce3c51707af93e907266febb2a522c4e60c660592bcda053129fcc8ebf46ad9767fbd4e98b97d005039e3573e920966382b7b86bf15edc450e9bd19b65ed12f9103c5bfc47499a35eb739d1859988cf45e4acc4726a4e9bb8890ef6659ea98c37105ff07d39869eda3bf53dc0580851080457ff268b7f548e67b1c0a7f1e17372c693bfda6008589d3739e15f53bff3bd6df205c9b9230a1d8ec03700e50b3a358bfa5066e6cdde672b466d7e42fafabdc69dfe609545254194c740aad558da4096347f454b2b62e720bd20c17c5be7e151afc23eb595a650dcfe6aea30ec5797f034962946824fcf6e63cb65ee2394d4f8f882e767e88bc64449925ff5b0a837a57f30b4a53f6e9e8c8f31d0cc82a12ffc2726bbce6e6913344647b47259c7a5ab334eb240292081e05b49fc72e05fd5d9b22434cd0086467d2ba933ab1500171d7f99aa287b35916180f0ceb63dc5ff27affeaebdc521762b708ae4ee539f144f89cdc770e7d0afcea362f3cd97231beab20beffe42830da879042d481f3f6d2c52ba0a2bdf805671210ecfb422f1675968580f554c4cf7563658d3e60b0838d2369a3da8241f4543fc7911a3fc5c3f56ddc72c177ec3d9e321b52620188336067c205e2bfb7fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
