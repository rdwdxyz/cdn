<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6037ce92f4d5215e47addddee5b49d1b123ad2a26d18d03f6d7ba0bb99976df38423102f7073d9044df7d075f8a63d60928b27c3f9d9d4ea23b3c8b0ae453b3fe18bdd51c19b68d47aec2c86f7972b5e25513a10d7b380248a6bbb40c33c4293fb7e7d49f06e21408205e25309e36b3b1088abe491a6037abbf6abe736a8da9a28acdea892f7b7114c9200361139b42cd656d9ab20c17bb06b817ab8613d6ba47cb06b47b979fb1ea6ec1f51687165a424a65d400e03c73741c672707c4887af95a7a706d271c9a7719c105d15065048b836a8116cff31d17f8428ef437ede8a1d1e60bb5e52037e5b1409bc743ffa0a8a71a905a8c2a1fcca146722f3bcd00d799607125edd596d2011ffc4b84c45b943e5cff3ace2babfcb820a05510ad1fd1d92a720754cbea491dd4a594319cddcf5e2bef68f0632a67ff80a40d46db9685dea5b98a44d9c265e0b74ddb3727f3759f4234a8509137a7b2a5fc24c29ff43a43f791f4f28a4d4f9acd3460c1ee8b522cf709ba37c6afe8b494012f9ebf06598bb3a271e89117419e3482a74ae61b7432446b568c6ca7e13edeaf47b141ba53f9a76951a5a1b03926d26b28a07e431bc3c5e72e0c304712474818108386505c980a2c50d97b2f81d667a6ff1213d63612352a2959182f0f20cbb42aaf28759d84780f5b7bf3ec81bf272bc788299cdb3734c6004f13f77f5aa68542808e055f335867fb07842cc5b0fd377a9a004f5d0c9a4a7ad14b9caa893a226b353f328bd5e3ee879d78f0428628cbd12231356758b868c6e410fa707b7484ff13937552979e3d235a6606b7b71ccf514de806c03c3edd14ebecd4238c08c54c8346f926adaaf1f52c700c3f3265d5bd5ac9a8e44aed7e33c976e62c5efc866bdd83e6dbf9c1202b721a65d445d66bf5dea1ce38aa7906b96ff32e905f8a873e9e8d4d5d8f51dd06fb1e7dfa994156ddd8695651748e1bf7c9913fd42fe7ce9dd2845815a1b680275b95a221e66d6c95c1bd7ab4fea463a918f0a17d7386b93f7a4974204244e07f9bec8561c548c9be600ccd953dae326efe80979e835cc49dfafe104f16135fd2c622629538a94fa6407a259ef7072961c9803c8c1951ebbbb48cf3406c88076ab1c120c2ca6126416a3158db9f52a834c7a5f76f860aaa83ff91ad14f2657dffd9a44fb1137d1a357e926c2a7e9a10ca5b0c2adb10018ddab337b353a1107bf3718cdfdee610c82003e5bec5cff3f8576118bd2cc1fecc86d100ed74bc2075439b565c0d67e4f1b6b0c36e8e223b7bb5825d8bcb6e173820734fcb119249a3f36d7fa466cc00a12c83a1b9a1da4e65e7cd9ef407addf34b25b9891fb937435e89e013521db47e2c13b50ddae3390a39bc5589078fc42ea72d179e4b962353c7d2c6c23bb8dfdf83e5f2eb0bd399907d02e05a8825c8f83bb5b586485a493b90b81befa3a8162e9a6e207c303da5be94becc3dcd652b1b8bfb993d6faacffba6b9bf595926677b5548184781d3ffcebcc08e1212060863b410fe7f444a47adb555b233ec96368a2f1b3ff6131cb97967f8985ce1321d3837689633f94ac1e1874e8f2bf2ad2c525c6276f52e0d3208d379adec6569d6c09eedd0795a7ea4eae08befcac2adfde4e881b6ec8d329d077e58fb850887bab3ad7b34375b9b7f4595334341de4bd04d2d0dc7b975785da8aa87d6ccb553c46e16adcf0520af30a09a28d1d8c351318455ee9bfc1bed075345a1c6fca55deebcfdc589f4ffde2454cd7fcea1b97d222de173460f831541f6ee3e0dabe4718e1e94e855e89d3a7c9b5d9742533632434c6cabf327e8f912edc7a88c724330d84ae23d77d84b63f92af5cc9cb53b046ed3ff1b6d947848f5d330a1b432248162947e89bd41b8539f872ba46ae92f711575f17ee75db56c81b1cdcfaa441c865e52f11905c5577a571a89b84a648bebd491185a9c053d06a9ea2223028f9f2d2c7f42b39f7daa3f29d35cba9f0d89efd0ad17201b296b09f708dd1f52fdb460e0693f05b70b23e6581eb25579d3cb7d6640d6128a263bed45e651b126fe2a1bac582bbeebb59f1fb1237fa9ee85e985d4abaf1ab82cf453aae3caaae3c7fab58773a2491b3ede40e9851cd7e3e11188dcb926b74b6ec6fe5c61ef947c8d013596c7c3a61e8556b33900f509271f24f1ac0c0a35d274d113243e508376243134e465db86e79a24eb1fcd1f67abc97efb8ec395c632cd48dd8de4a48d996c75f0a3146e13e94ec241d1f7d7bceb45c7449f5a27b1046b1d1cc5004b44f58e03d03fe23d6f3fff7ee41d9f567b2cd9a16294fc5962417f8fd47ca3aa00d569129858a3973362951dd43d6933207859186d4b9eb67f0ead67d2a2c0d5b3798969bdc28e0cb131ee91df4200a239f4ce3a75733739472fd67994c3408d70f000ab1dda68aa48546bb3f79b904219e5180bcafb34e8c22a90bb6a5fd22431834b6033d9981aa00fdb197d6c87317e739bb62f8df2ff1122fe0af7019d085827871c2cc05ca06157e0ed8fc3a8b9be601e91a2ebbea0e78ce55761ddcd5beda869f385569f60898cf18792e547fe73d4c3a9ada9dcdef424d9840d475e1c1ef353afe7509efebac16ee21f3d5eb550368221b6d79a7790c41780a30d03ff070fc6bc0715484a6e108f30b37f5f110befd9f3b84e5aad28c4e2723da71c187221f79ef41440ced29dd803c3c38cf811ba14245225e3cb35e3ccb38ce57efa33ed76a326ca20c84d5f3dc4d60fc3ecd33b42af76a4893bd8f04e801badad927e5c3a6195f1f1d9bc1467a371f88403df508b79ee048d3d26c16c2ce9eef397f1cbd89a54475334d1bf23f1d17a2100583e86547f40f2c52d88e2627bec2001887fc95e5371b8c21bb32932f0e54f19a2ed80721976618138830caeade0f9916100ced6b2aa8e7b4dac32ad3a07420a379a6815c231a49b2a28f0afdd60fd079a139ba8e24088f87da52d6f8e274f8d0f11d8d1b33aed66bb6469d8aa4107dd7dcec4483b30531f213c66aa73236bad05c7190c345c9dd6d3ce2a3e9eddfb311ca2e3aa241d0c6890dfd8d313d439e2abbd793dd5cdc4c56c5de6d82fd8e36dffb9c362d1686eabc46c848346f563dbc87a43da710f2c442775591f6c308e41c0231c5c209ded4f02e8d9af3008d96347339844f93ac41da559e72ccae227c5c5257e6a8b495a3c19597d71207593bbf904b4799f406e84f75bd620f52bd4e4bd439d44d6d2176bf0fcde044239e6c419515ff243a9d0f76c1dd8d27a4d57354c4b29da13aab83e5adb9014099d04dfadccbbdfc42aab199e93c24b2dd3401cc14507fa2cd53c96d59eff47c0495906f78b428f293a195734aff1d1076c0216026c692ee68e21a01efccb71e6d112ff993975b741576e9ebc651d52151e1c55a890c036841a607d8fd1ed28fe37eaa490cdc8606c34d88c9bdb9a691e9c4584266afdf07c1619fcf110af9b4dcbd545fa64e1d918783e4d03ca952a214dabe1892f4e14fc0e46be3a6eb7ce040bbe76022457666119951d9739c57884e17c8f4379ad363c98c2d9629e1a0cf391741541a2d7657f4e5ecccd6e82fc6600484cb6df2703f79bfb43203fb92bece5bc4ab9aaa5ffdd5f7af5cdedb4d416770ff05d7fc64c14cd01e594a119a3d3efa9ceaf1b3d95a79fdbe6826dfda68b80e7ed13aa21ff7a3fff742a3268e3180e8bf993ec1e134701e855625f9c85ad4be9c9810dc7c63b0e4f7d0f8938bdfab0904491bfc8eaf3244d2bc4b3fecd0d647725bf0e0cb57aaa327231d01fe95e79a18c69dac978a79c53ac1ed85714698754cf4a0d2dca376a9e78c44d38ab77b7449307b1b7efd5c23b71191c301bfb8d96880a6a0c248d2408cc1bf359d52675b02e146a70cd51c31781885c2f917ba8fdb2d37b2a601c06e2c98cbadccad0abb1a2fe5cfc8b7473099beab7e5d1db42cc1d9db3e5163c34c57d2ec503a760bace40d1c309307e28c78581350e9171548081a0637e1c5ead880500d7275d611a7809b0c69ffdeb0a5b60cfbc6b816b0a9cc83cce80ec5afc23d218aee4224d1ed6412fffcf1322790b055f6fcc5c52912e58bbd42cf93f2b7e10c3caf96f62da090d29095c58e4175ecc676c6f8c3c8c116716aabe9fdbb05b69ea80956d52a0b45ff188ed174c4d0bf42b79f0a686306af1da3d2de8c31007b5e058897b6b674a5ff830985ad048538cdea5db724271f1e4e7239c44c3cd32973ed38c2d51a068e0aa467545afb1c943d19cf6731fa2e8462d14182dd2600c563e89ef56f6d769883fe17678dfff550e8060128887a38555118bc08e9bca037a8e34ea3a16d1229191356e42f1face5bbf693ae800d2d826a8c1912f65cfd5ee7728ea5bb4e2e5ba6009c4269b26923c81c4808984c57ef4b582ce42fc1f9dc6ab11ef14250af1769d11f4bbd3bd8ea8c2fc23fbd10e30f6db9c780865ce410d4399e73249089ca4936a55ef0f7db1ecceac7b5e0be92b2a3bb3f95b0be2e32e5ea94705be940160d61ce5576ee9257e09ed47ff31ae74e1c1919df56d12aae3efc46143e183fe59567395c0fb86be3414da5892547e4fd533acdf319c12973e19d9094bc4a1416b06f99b8321c029333556e74100524e7d6b75e5fcf9ee020ff368674ec49873f61b8fa0ae1f3be9aeeba2674c7f99634d211115b60021960990aa9e57d6070057aead65ad1305501ca0ad2d20d0dfb2c5575d2fea50890aca0f252cb9818d0b4dd2d38e77f7bf15bcecabe8d4bf2d920bd5471b5f5894bcc568a60dc7ee423be2a663299a0865db926251fd6d17d10dc1e513f48fbe545713685048a80aeea541d53eb0f0fc28c69f4754c5e19ba02d762572cb5b6ff01601ac646e3af7fba906d0c9ab04d2de618d9ee3e36761806931dbc24ba360267124ffd799c25824b1b17a9a1393129554c19e2193ce72ef9b57c2d32e4b75e4ea9581a381ac827d400109fb9830231e671f6e6c3222d73c07d3c420017967a74becbd96a6e928b8540d05ff171bae184b10ce3958109e95065055f48c3808c1ac44148538eed00eb23b2044916d7c88fd8c4ac5171636c49483455c783ecc49c7e33d2504918ecfe98fc1aa05f9a964567137f07fedc6ee2bf130e870202c587978456c54115c5f2fcaa732f8abf6ac655ca630d719482de5ec1c6af5cb68e53e4e9a12af188fb614d31ddeae02a8d8a73c3150fe762abd93c88d4076b0e8317333b728c6e7f02867c64cd7c413c1a660b3f7809e6eae5ddcfd00b0a6a1816f2689d18a36fb07a7d8a18888f1f02da833c101ee82c5a57dfa97d1306676cdc503445c590b047551868285c87d02df7733a0470cc506b3884b49b9cb8e6e06fd2f0b004bd35df40cba3ee06c0fc53976183d633686340c0dd937c946f8aaf60bc009836f4516ff5ef162ba39b1990ba9245e65ef4b29f66d66f9409f0645d0c5d09c1f072d1153a3e54c43ceb96629ac8326cda23390e92c28a594604120ee6f4c14902e00a41ef3f03d35cb28b02ab04babe4a48705a9eb03bd23cf44a4bb8ced919fcb1ef79e9d65bb20dfbabac8bc69c98b2986bd68ab47ae3c88db3e7a578eb6e6945d0f16c28cc9ccf5e2eeeff3ffb0ee237a095255021285815a01805cd32c48051ef940ab27a02a06b0d28aa134a1056b95ba646eebce15d3d77db298c1fa5c334e68cf418dab039c76ba195bdd6391548b3de97dba645f143437a554e855c3f55e83ce8a758dd940e857b03bf6e4478950373e9ea319c67fac50cee2c7c49f9cd9ebf0847676d6c9d3bc27d6f60a137275bbd827c438a6394a74ee2995303db5216d605a8f6cc702dfc9a89c26b80c12fc13019adba96a948439284623b2acc89183ec12cff3f969ccb29955aad404933dc70243ce4ddc260869eb1edc0839f4808c2615a9c99d1ca5d3464f8cac49a5f7fc526434f9e5642148fdc8c7dbee7998b5a37c1c1352b7789ba5bfc3371b9e29e581c1395d4987e5bf86563f39df9b34348268429015c08182116cd383f1433bee26337adddc2f60eff389c09d27bcd4ad332484d7025436200db7ea248eb44ebdb1faca59682846ce2ec3dd75815ca695b90839549be4d4eb3c6e6a14941595d7abe78f53bdcbb481c9a1d2546c268d3db2a4c48cac46c1862f5c77aa55f4db74e8e45997afc38728c1bc8beb40e5e504c3cc281c1220011c38a36f84b887c8804a2ce3c40cac6b30ee8e320e7c0c3d6060585ccaa35c27f451f06ff7ec9a39384387c492ecdfd4300152ae9b14ec138d1c5d5172c75ea9f6e8e87d95e250ca6a415f6427a30f2b5ecb8be24dedf6089c0034ed4aa35b39ba12751aa5602e4e227fdc4ce1af0878b86bc0bb22290b1ae1f252e4558b02a4570045a1ead27aae186b37b6024d36803f8ffb59040ba835004891e81f38199e223e643b8c4e71c55a6b8020eba3176a0dd78f65abd6583fb0130e2d2aae144082c3e164c87f0402de55aa8032a5e658697a0f2e5183690fc5fb620fc3569d37ecbaebd76256ed8d6d36cab1c6b64e38e04ea4b964773cffbdfbedf5bbf0a404efafde1eb016641405fe9c452b3c3c574d12fb0c81c9c2b6522ee5bce983571b0701cdf8d3ad144e60fcf627f188ebb162861d4509866c3935b3e0ebf903e19dc78e38c3caf773103f3ba18a7d79398b623b0c2118736d9176e0f43e87dca291dd8200354e2b5fac734d704351e641e5db9ba76b8445299e5f5424d3400e00d5bf8ca7ebe4fc3583f09b37048d31424b6d82e798c2d26f2ca9b5e7681d36aec915deeae55ac5aef79a622bfde27f48ebf124323f70d60955f13c9a2629d1948a568bedbf8224a5763162e7f0eb2a3f115db476e5c0ceca27a8873ea25200221480bf3e012869091807b059cc84dc6f6b68e205e8385d86468ebbd11affc6717f2de6a5f5743ad8c6a45bde650f42a0ac456b3fa67878044382081d51ede47ac265488f6b793c84b550e5e92dcfc33137cb7fae460b0907b50a3dbf93fd2db418519e8dc6ae6669747e9fb957f8102b04dca4d68bd6e5d12b4fae8d0ae6a8522fc019e745c5e255a76b270e8c5e8882ac37c258239549aac96b08a127468c7329cfad28c184b21d8b833cf67f715e32b132e425356016b242d245aa3b6acf05e0aa44cab47fbf77eb67afa522b7f88154e06aebe47cc4d8546790a36cf355bfb68337705424debbf1efae124223e87faf045cf8bc845899d27a2cdb8aac1e1337ae16449b5251b4f7355434a0761887db1e4cc315ee3da01a54b274ee03a76cca5f6e50f562ab4d808da558fe86dd68804ace3cf122fcb8875df93c5839e2756b7451b750b8217e89904d7a0df0b82b5ba316f4cff46b81a28f23f52efeec9ffe02deacf9318d83469997ef6cfeb15838850517b0e5b6a8c67e604b7f53d218c05e4a2378a016a90f14e2b29fe7dd53e69ffda38b6bac069d714ff7bf5c967b3b0ad08d38828a453763967cc930ea8d93c9777d411be9893bad2833658f0d84d05e558c13c2f3c18ac24dced59bf47aa7ad8247cb3f368800e9aa028b03f765dbe42c7f088f6b3f0565ba9ef2bec839a193287ec94761856d2c1055846ef7cede26d7a1f16e52eabd812c1323e944c507e62968080acb1d17fc291eb081906e2f6a7122c9b8d632e2ac95d4a4baa064842a49393a7d9d7d58f2a16c8743e8b22e658ce69accb17612349b49839e4afe511db589834ea3c667183368ca9312c95e77e81148b3bd8f1fa972762f92e70f37348a4a5dff020bd540b0b2173649ba33447f7d40d3dccd2a1caa2f26805dfe1fb93a2353cc1dbdc8a1da633d41263b9d654776129e543dbb405986db4bf67679764ca5978f2975491b239d8a8f952e1416b4309ab42eee7942391e08e5d18c35bc57ccc0310d57bad11d7203ecd3fe981de16ddb79ef9edd4d7b2ce0db291c8199a370fc70b3ff1bcf3fd01523785a62e5ee22d2197de41409f12b0119cf4ed427c596845fa90f7785f8c35bfd0c5fcfd6bdfdb41b5957d80da22ae510bcd2f22c1adbd70a6ff318602b4489f29b7b604c2e6dcad7deac469c343c07d3e0c3c1876672c365e6cfc6d2fdb44bd40a0e62d6604b8019b1385924178a9837f431f748b67d22d180859cc80b4c8393174a317f6c9b8e518290ad02cdcec91ed108f1b33476360a8eb2d210544d8bc45c2fc133e9556b8f4a2510617a2ec0f9e4bec70dd4907fdb5224991caedd0a9cbb8cd9f01f4799f9e18836bba0836c7ab60de06b16528dc360495ac031e282948b8e6301fa63d4a4d41e67af2550080772bcf4114c884f2118aaa48168bb87a2ffd2cf80d3aba617d02fc51c67a44f3d4e705d578bcb660c7452616c09df39ffda8f333658e5c838bef0ea018fc9330303537db048cfc3362924ce6239f5808c10e62caf3b364dc24a9f89da8541cc21ea4cd0006d6bfe9dd8a50af4976f638024b8642b7e19a4210f7d737be8a96777293666c78355ee6449e374f67d0b4f32721c992473be82a2779db4a895973538065e75f53b5ce195674e6bca93398bf5da240f17f60d25ae827e174a211ba107eb85841e93906048568775615ae5376386abec0a79e86e322876f12ad1a6a3337eb3ecad2dabd8bbf639bc7cc09e733043e00b4fa7379b713c1db2353a88eca468defcfa17c35059e9015ade3e51d98fee3aa841f70bcb8b7a847066c62b9ec3f99eac291604892722a69886d7b595d85a2b69f6efb2633fb9a0e9b6438bb9b8e247759eb38546ed41aa79b40347f64ccb1a052cf92ec210416e36063b41fa19b411c33f19342a95935135263ef34b6777feecd937ffa410a54ff61a08d29508d493173ab468cdf15d48359b7282f0601a46d97868cf12a737f69f9f1b398b29e62c0900585fcb478ec84171e2e080613dfb4f87c83265255d19aeb52b5c3c2c5313e7cb0104339c60856c195a592b97eb78ff24fbd8621431b02977540d18517df574d972866f84240e0c5b599872d1a1d4c5ca21348b74b4c2ba6ec8b71c6f13d9be7e1791b32f16f9f3ae709e5bd7b899ad4b01e65f241438f8f74c2450c25582d6bf4c7934b59e0d360a4d5c3b83173161979dea6cd2433fe982d554b6087dc479b86f50b783a505530f1891a3bfc0577bb9f0adb5a05b2c6585a9f2fd56bb19311445670a61bc337785d506a24356c5c9b85848ef3f976b38aea9cb45149c7c5fd0d4952d03290e2a85c77915e7fe02f1afb12e64c3f42dff2f09e40135e6fcaae55ae2b50ed4a4242c086e0e1f50c5ee7f4d79166b90085e980ec5ccc94a2a7d87cd368850434bd478253c662f22415ce38adc5d9e802ab6d4367c0db80bf726bf5208a93243c17cdfb63c3ae361b8d1f6f403d403bfe43607bd7f162d3de4de33a984bfe6cf2dc755051acce866c5ea54a7e45a279a5e5b7f42ee567fa62a2fe6b3dc2d211b0ac25b55f963de66965cf28cacf366e27faf1d9d44f1f7a692ddbfb7062958a2363d6d192bc099ba1c16441fb6c12273f0da770444302dee347a4feb367006eb71b00e947a9194c9fc61e09e075b105ab0ad5b668f7cc6d488d55c9d755063caa0a4eb42b1b1f290a5095bcc2e472ecc47707c0d749157cfae9513270145196dae2314eab0835d072a0f87b281ea50f81fe55300d2fa69df2381a9c0b1feb445a0e8d3d20de32a7bf883a6b7fe82d5ab8baddf6dffd522e30993249e1227e54e46be27fdcd3d221e04bc9d5d07877fc5c574512d74099636388ae106fa4d90ef486d65de428f78b484ed3d9346bee3b915b04655dc900f6c1c5584b1667085f4008482693597ee5f3d716db7651377833bf1c28b0c3c9392f364b45c8ddea39ca7ccca6917e49f1a6f08db7e11b1fbdeae077b39232cb3c1dc8592ab39b9808b571a1b153b19683560ed1daa65ea27b1740537db2745f6a1563705921b6498b02de1884f1e0b5608c9cde393085fc090fd7021efed4dfd56c03716fdfc4c879f58b1411ac9f1252eec67e2af3caaa866e3d3684315affcf90f9d8ac511959bf9b7a3a1c94f78716b800d836e7f446da6288e02f17f85cfc3911712bdab3efbe661250275aec131af5f4c8af7311110205d7fc6827ceb61bc5bf94d9884b112cd1db27b02d48097f4a6a3c7c80ca1b5d3d090b4abb020e2f05d8927556561001d7b2804c0fb9fcb0383dc4961c9a5085ed449273af50755cad4d5d7794a86d25e19f3b46673fd1d51df1192084574bcd2f9fcc011281c0eb97e5fe2a36c6c1e562cde4a19604dba9c777e03c3de74f0af8b47b37786cf012fd52e15f35712d1b9748de128517e3faca798f26edefac80bbb5e2c217446ad749ab97ab9552d59e09b93b0dbace6c059563f159bce0104c507fe855c06bd550e69b66e8c64ac8a7923304248f493b8817b3ae1aa6eb64de9f1e43b24aa3b235c6c72502d7966f855d96b0436d6c1b8553b3fd94064d1d086b6efc0b064ae026997fa03106501f6a527a08976dfacdd7e35fef8385f336968676501863beaa0444285c740a3a5ee7c706dc74d07580acfc7d54c7064b3235d4666569d89bf3405e5c3961a8191a1032e6de3c1268d404a294976c24c9c1c5b513b63e48582b4df7f4c863ce53241abfb850f2bafea63d804ef094644b25e0283f143787ea626e033ede3c3d02acf82eee9b734fa4551bde00edb0850223ad212e0b4ee59cef4fcb29a1005abf2df8c8ccd42e93896f060f71d30d369ee20fffe8f8f28b7cef50963c1f892f7e7942f5935b254b5ce66e5002f8bd32ef89bb244c0025a3fd3c0226e568e743c059d868188e39775accf31c2557bfc272cda1bfdb0a56fc0770e9e8feca279a19b4a9dd36c81a2872e5bccddbebf930afa2d4412da92ed345bc18f4314422e7f3bed4cbb72ed355e3490c4259d663b2645e918abd92e119c03746de01df51e61fad1d6d65e156a3ad42ff5f0d89c5a2c3c484c36cfaef00c83291b1901e6315604d8fd7e889413d4112eb64fb9d0201273133da5f3ea4f2e89fcb3978ec5987f5e6aff53676f02ca00f487beb6e6a11620b537cb55a7584616f048855af75b2b6d6148273e54f5cf640ad5eded48a1a133cfa751d36d0d0c538dcdaed06e56847f5506783e815e31c5bca7fb1b189b8eb42e705b420948df35e26a986be32f63f9508a45930478ffbfc11eb9a5a04c432ae9a7f5643e3ed0b4b207cdbbe5cb7ecd1c6530a4cfab269d793bf3056a0cae133801d1b4838c5e1313639b5cb827d4bd2fca307853042fee46c16c2a2df25d75ae2656d1660c223fcf01b04e547b7a1bab63c8a7f147a3722672976f07bf694dd6f795e8eff82aeee6e64a6a25bbbf3bf6fa13c7fd35d91e9307ce95e0443433f987c8592988c49ed17ea63c0bc6a8bce2c5975b053dd93e46f484755fb507c62a291faf661591c3600c84565aff98e916d047235407e3b5ebd9b20759c2529827ea05e3b1312e0638e141b44632c3f548b99320665661a4711e97132a7d49965a6fc803a44a9c46ffd17d4bbb7a1fee1ef7032c98fa0f597e02633fa9bc09626e55eed3f221a47ae3306b1f1541ff009d704cca01706abed3f6c6e5a07aa081d0b4714a0ca1bf776a745817ac639350ac327264ae19b03aac86205d9d349e7622926152bf698cd0ab2ea605cc0ade31c2e094dd75029199233504bad94c1c27a99fe13af6cfe2628bbc3be5cc61b6617ff3fd018945930d076731de3cce156557ffaf6406fd916dd8a0b4d37c3d302eb8c4ae0c22e753b6e502413327eee8f770628eb997e4ec6de47da6302f445b4c505e4bd6109de657f329353f3ab13066b50518ae174c5e45607517aebbcac376040ce6cb01cba8065d60d68c61cc77a86f6da5993ce90f9f7eb50bd15d4130547f04cb291856e58d49a978d82677879b2290c4de967966d61c7bb0baa5c568b7c66d9597ae81a25b8a1bce7f207d77e4210fceeefc17e8f717a5bc956faafc67b16733ac57efdf4f47146485cc6f573919bbb91216310dd52ad0aec786661d4849cd7a6b34373f58b9280de205f4e36e2b111c70016d1745eae9d8fc2e8e141a388bb2b3532da306631b0c865543cc3c815315382a1ae1be0fcef24f51da8808fe8ab1db6131eb2c6f9331c021541e4eadda2df3f3f94fb02f5afbe0e7ea7fc9bbd562329485ba6dff919dd0b1ebdd403edd289eea940deda15dee365e791a1d1f093a84f783e2cae7154a373d3ec0e6f23afbbebb97b3f0416c807032263a736971db9555ce008391a90e63dc2aa6d35b478aa43b83d27d5d0513f84451c700a894ef355b9f11e8bc0d08f1685c5c62f8fd9af5100e0eab6368749c292765cf7fb01876f8a2a48ed1bfed2bc9cb7c7bf5904caa4a004d08bdee5d837b957cb6295d31661bcbb7af742422eeb865d4cb3bea86685d50116c22480189e461750dddd11998433bc294cf909fb9fb2a4f2f5938092899c328cf52f92ba26c085d25683d646450149484929ca948e0c4eb33f95f8174c4bfeb5bac24b6bd06b41a4269a7c118cbb30b69ee7bdaa179fa7d993654abab60b94e247e466f9e85a64daaf0413b1f49c55f9f1b445784f38d2faa52894542f71b5d7cc8b27bceb170226ddd926db1e6f44afa6792c8adb2e02139b6cb889123fc61da69778cd379c80f387d097f039d4d088aff4d62687ec162aa676b3d73a94621f9e1ab91ed7abf5568d3d24413b41dd15d3889bdf82aefa726b3fb97890fbc3d4b451b0e657bcff7f1028d06a1686a414398e862c7dcca9e8de25f974aefe2c4c1c6d712fa601fb81b57891bf164c5615870db8c5dd0e12cdb714b310e60af5cb738cc7ca55ffa9afdd73d80df575fd1582ad9e8a81c2814fc386ec79f9eec86c2edfc98f1cbfa678f8c36f6ef017328f98e822e7534c9820de05aebc2778c560b9e1ebf38a551aee665f6e0a0f4b358b211568c6341693891b2d6b1ad7f8a9aa8b5f6168eae95c52761e5dcd95ed8f33751131768fd45cb3f33e35ab50418b4485011a0010a138661a8c56fe5f16964ef2691655993dade4e68f4fe34c53e2c022f7482d311defcefc4f817c38d2626689e01f36a4170486a044be65a379da85a3880f213449f1a2b189d833394f6d15cfb69f759d8f99539e7193e98749de4ec9f1edc326082d109fe08aaaa470cd47f0b0507b72ab96ffea33f6b5e93ca81f0d8ad1c2a9a64cd0c84704a870bece293e593f17a76a51f409068c6321a50e734b221f66337fb76973b98025a6b7874ba8a17efcc5a477895e3b90b939decfffa473250fbc21b8144cea11c9eb8a4be9e9f3a1a7eaec412319f953eff18d2d8d12d52149916545e32421ce2c863b47bf44c92fbbb939a2ac83defeef43c0648ad7b0897234f64a371f50beb9b8f71b9b91e513be277c963dbed4980d02c0329302828a916b79f41b114ce0fe1778a09fed7008f1555080693e54e171b9c76bbd9b20b0e53b67fb55dcde3432163c7f69620c7481e16459ebf1e8aacdf11d631b2a54dce5c645cbaefde8c53b2c77c9167aac9b4ea8fb6a22f6629c409d421b9badbc21c513fb4fb6d586652df974472c42a455909c883fae1e22ee5a08ef38dcd7190ad37ae004b76ce154ad0c9f336874c75d3cf46a792ef96dfe66dcf33351a1617e242e6e7c622f73a6ad4d0f0e3fe3d968a7282fb68fe00d0e47a9ba7222dec9bd7daf4f5733956cd1cf3c9b6b66875492f4d59c3935ad25ff72ee5874121a6217ac9fc49678bdebd6f7ef143a61aa0a494c89d519c6d7c48b9af98ea9d1d6a6b773e32da0823360c5094347025d2ff22a9f58580ed8252b0d742fcd8379c1f5e0434dbc6c5f33b5f01ce681f6370987316dbda0b2063a2915a6b566dc99dda3df2f451b909f2ca8b8263e084e66eb78e7d6858cba531b3a6ee3cbea82cc8e2671c49f1c211753b83f821ed3ffb6cf68ac5d3d98e6ac1853327f0ea0692dd4d021cc7985e26d0478bce4bd2b08a5e90e7c4539043055bd74676acd0996a8cb4956526a72a66fbcb3dcb3d9af4e8f0ed795df63c1cf2d308134230d9d0710dd674d1cf51e6fd591d1fb53a295fb42a255a0911743a8dbe9d71802d6e0d5cd3b3ec6c83ef02e85121ff4b7b2f7d830a03902b888038bb5c58241c86650b6c1dce3ac2e0f13adeaa5262ac98ecbd482ebff832b61d0633d069b9d605aba11108c478298a6db94e453649ef32770e6001fe0956c2a9aa80599bbaed700a1b51cab83da653dc0423658ccd5ea1c48414146d3acb39fca7c3919cfef6379db337ca00ce1832d1d5ec1d48caab9e90d5da2ad7481d1b6c50abd38a6dad72c2d70030b709d705daffeb0b6f7ec8251a23ac2e3c721a3862136d12f591fda071926caa43d679c7fe2f7d0c3c0cfdef4acae1468cb5540dda3718705426ecf07827ff1fa026f83e510a5aca93570b877f796c37e885451ba3d8682474fd519e8482516bd90a52fd39674344aa4e496ab6f55c55df5e142dd11a8edb8476c9e23a32c74d24b3064ef2d88384e77e6081821c95c6511936a18aedde2e33fd6aebfc0a667e49810b0d28b866905bfe3537284be48fac633ee97cd4d2b7c88880559d6cdd2755c1dde6359821404d69288b33398650f959c48f36c60d78b4fcd4a2cf53937c253b797eb39246901ba6a75d1cdf95357bfb33500b1f8fd5712b51f50f6396b5ffadc40a988dc90eb5a190c6e275eebe8cffff2dbfa665abfdbd464180a05b345643ed415661b50bc5f08b8618c763780782f72494ecc4ea65f53d083ccd850d2e1bedbdbb5133260016c593435180c4cb83d6d9e43fd4bf37000819f93e091b2ed34fd5f698ecc673e4880d7360b318263ffe75266fbeeb290357c1cd2916ad051ed3e9cf0e7bc772c1b5e47eb5965289acd4a074ab57bf631f3494755b672d8da9cc582b7ed930f9f7a47f91cc194b9eea1122c05acf438ba0cd0c79a064708a59dfe9816bb3e57103b183fa250972c0742e2611872e59e4e80740508ccca1fab6908715b63d6a397e56de25b0eca73420a1327aa10f64047eb60c67b4c053e65c30f25447375e7bc28ca8b339a8004e7fe6345360752db382035f310de7db9737ded16aa298fe21bdb4152a4e7d2e990569fa763efaffb98e9388f2236914ef928549bc0e2d951ac09180249122942202e030f5a608bd4c3972ea102d17237cbfac87b5ae06c31ccdcf68d1bbc74ae02b8b37de6d0a36a627f1eb8e74f5941ebcdb1d4ea71721cb450230cdf4f91b39f3a1191c6a543c11679a9ab3af670162cc696d16c0e5b3d954210bc4a75f4a8640639ebef6579bac23233c4b13eb693704284da5c6208af3a218726c922b76566b06a78020fdcc0ce339979d75ea3e66bdf036c044662f75f19a9f1fe60a5a1067707ee304f458187a33a98784dca798089a4c756a0ddae9759978c5b09f90f3128ca9d8ce851db0f4fdaf132e48bba133e7dae93df48f4040a5d639c10e539c508b4b5ffe25b691f5c926f48fed9b8f5ef7dcb2c85416890988967d1c1823089d834ba4a0d7a8c4af5171b4d7fb5732853d3866714d75528d80abec06dddcad9843d70c7b3686258a8e99dae726090500c9db417e969e224910ea8df22f358c78d28b4c791789176d2669e27db6fbfad7e2bd753cc520fd762eede7ce0b82f73111b6d584d2a2aa76734d8564d199dafc7d0f790371b676a8c7f06219b1a8035490070c538927d553708872e4630d2e4f156d4b745da4e51d988190e482e2a7456178a1d0de8cb53f0214b2fb7f2eaca5270a297c0b08fb17342dfdedb8437e1d3084539f4feb047135d316b149e8b86692818a78600d0a630d8eb089ab9986db2a471cf1c0df5b288abb561afa14362c062c46124b42dad59c224c3fa1e5b002afdb744b3cd4d5e0c7f904a375e35a1c886510a5a9882fcb82db9a5da96fcabe82d8bd4176aa54310d73fec75a390e51c00ef8d06f0bb6f588cab6cf8ba21cd1213d96d362234a18d6400b0a11844be19cb106c5d2819aea46d883382c3ba01bd555aad8596b5acf6b7e5311968730c639d7c1b63029436dd1be700fb44009c982c0274d9a5ff25b19b2ab9015cb16728a8d8457228cb6fff799af55d3b379aceebefb9906c95918d858f5b903c719b44143bd777013ebb8c812fa4d36009982c79454223389c785fb23d1629fad8f14280fa81028f84dcb693fc906ccf63cbff3d2184b5331fe033dd297154dc91c3c6535c83fc40e099267ab3e78ea9f554702170e42a9f6a73bdecfa903f62ab6feb71613bf1fba035c493ea5ebf2ebe7133ef5e9d772868aee3f54a34847a7873f80d60cd7e5deb77a383cd5d65a337e5d31d884141578e312abef8b3f70ee35bf32141cd849a792f7b6f89f56d0182e7ff10a90ebe6f0486e0832c8e975901f2c389b75ad40cdd68e55aebc6c13bdf80c6859f7d17ec54eb78b9b4ab53b7f56c71d5e1e05621f79a45e76609c264b3fcc5ecd174dd02a2f7457677723a9b5fef9374d3e3b21e82839fdca637aac05aa80739ebb6b9561b739dfafcb981e97698c74952a35c0932fd982b4770044742cadd0a2d55923228701f1c0cc1bbe4ac7d1b9b907e6e5c77190f958a05f84dce67c48bc0eb66685ccbdc8c0e488a585a3d58a4faa370632ba4148e374819a5e0e00903b10d65a0a51f08a958ffdc63ff138a11ee12e0cc20ca8af59306bb90c9347cdfad2e827099b4e3f9a73133e959652113bc09658db0438ccc432d387083d50789cda8fb1bc4830b0273b5471c7e583af808cbbc36a9de29546f2649f337b5a709fe8a747fe2233628b7346b1067237e571c25e3bc4c888ee857751e3587f0369d83c3ea047635b3d1c90d3a6f814751f4f4025de0eb5b598ebc58084fb1eeb4c1502ee05613e9666cea8c7af0e196721f6da7bfce00f3c686ebfab2cd0f2fe663e0f6eba1f017f65d4c8bf46ff95f9bb2c2e2323e47ebc4afe1fa0f33784329b78adcea8ad6e7ff1c5d1b810da161b7d09a0596830f2f3b66c501a53cbb33d016cdbadba2a75cc176646bb2ed140a17d0e7b3b82c572f596112769ccf2a91fa6d04550acdda8d20c7c98d579e4300f94b96b6b5a885511fa29743465b7b193bc9fe2fbcf695a3f580a4b48a93d029f666b5d1a63c653a0a970a08bc59b5ea14d75cf1805aa7730adb45392b0858ffcd946288bbeba9fd21136f43cd680e2dbab12b9906be222e9cd91394c45003adcefe58d620bd559b4a9ff9f5a57a6dd6cb50ae697a264225e9ab68b0c91087f29f8947c343ec92722a92746c8e3e68884693982d120666dac3dde48a938aa869eb81bab9539ceb1b084af5dc00931a03a7c76c881747bac0a3c82b232b88b39555742a1ded0d758d1b704b853420f35b97e00f18a1eb0a8724ad75d809612335111df2c810993a58931c2ad668ab61f16657ccf698c8d21519e3f21923da75232fb14449bb16da0ac1b426651b0eb0f60778c7ed954a7f3a5d775d9f868361ea575ab1783a75a97601ebe0dba4462a2447c038b89d5a7716a8f5e414e048f0652f2a6edda1ad92eea104e26afca7873fb327d4766db2e98f6f3eb5e5fbdded5dae3897e69f58d752272e42a59f56ea8fb6cadfba4ff7d4e0f75ab708e80eaa29f0be021770183b6e5a7d0cd3f92ba181d156ba978401cc93641d051aee326dc24564a9286e940778b6cdc114f5ba5f060743c845e2575b03c8034e2d0d8f324f29171b34f3f63a64a6f56bc7769f27ec2b1adc031ceaef729e138ee4b44518ad444abca7af850513583b2422dd2c07718f966f9f6e0aeef9bb64b2fbae2328c9005147666b7ab2730437b5fd32715e09c6679ca1a5ab1787806b1f374f0b4e12794f22a03d78ecf587223a0d4ef19f92ecff5630469200dd500eceb7c2dbe17b4766d741d50afe331f3c54b1990c6d5c842b4491d0588788236c949204d4484e954d6b857cb9d572dfdd22b5a33a1d1102e1d93037e206f68c13356039f4fa77f06d4375096ffe0ca0e70ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
