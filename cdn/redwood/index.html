<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bee31765648d25dcee5b57be134ea2cb690a429cd9e4bd495838d9f4224ed9cad9ebd002779ac82d619f39680bebd5886ed45f812ec348b37c22dff048f07c3164b26540c88496cd847a9f20d8a277e951759d0f5406c7894a7ecd5dd6d3f9baf95aab81cfb767fc8d5a8a435b182a2bf341c7de1beb791337d3f5ae94fdf2bbec75bb81e1b52facc22f2137323ea09f1a47938dc7543e37f9249752988e26b655fc7fc768b00ef90693bad5eaddca981cd33eff3b654655ac786572d4c3730279f47d59ad2a12d22e3fe363226c16c46b0144b6abdde3a6572b72d961c3e57fa7974101facd2ea89abc8c785f0db1fc3db0b0c1056eec2b0228d074090dfeba9e2b8b3da26b74991f8f081ac73708cc305700fd703b03e903d88c498690c20b690c1768abedf8cad324262e00768acc9b9cc24c25ac9d3282268e98fb3b8a86f08aa525f7e1edcd05dc528590c611c55e11896205e17340a359808192b9b2635f1af243bb90b6e0b0675dec75e853660a1e46c26ea93084816310ff61c19338bc877a4bd317e5c43e853c80bfdf2a0487be412d7e9b68a1457cef2727256e63c775250b176dc174e779eb03991b995dfd901af80c85c9718eefa5829e3184e8af31d0278217f71f1d3ddee429275837b750cd6872725605d3d43d92c8298f784d07330adc8df82b0c317741977049d2f6901da4a55587253d742db564eec26c4f1a2f393a118330b0f0f714181207654ce6fbe0d9d6c7eae37e4742c13c0bb4690fea2ec091e9d71e597f341451c321fc3fdc04e113cdefeb564113b5714cc23a7574b6c7bab75a8f157edc4c2a2b3758a8a8854b16e6ed5ebe7b1714ab2eda6dc10ffe67256493f3e50a417f55a46d59db0b5d8d4c6c27703e61d7a13ac28eeb45dbfcb876cd9e128b310cadb2a72378bf97177505676d1bd1d341d3fb16de63dea1719978d2da78676b59bebd1407e5fa4a6ce1a41cbe3bae794478b4b1d279d717134ff9241c0e7aeb7cd7d84c9a2b1c8a34a70e77a673716bb9c1e1a73ea81ebb39cb99006a1d9bbc27f5d2dced61c7997511a26c8b7f40ca03ae55e0393b7abd8264f04b2e89a9debb0d79ecb59a43827c03fbcda4e50f7f8713410c22cddb5ff06c785a07426b8504ef6f7e86e8d10934fd1d03f345db771e68c25f41a59948318a0708461df2c2ba7984be59ebb5ae4fcdc4da4ed817489d5d6c9bd18f73867342745c072588a7182048240a7edce0c9cfd14608431c03843fc6794cdfa56ee6284073736597c4555ff7329d0bde0ac8f7040280783b8acf3977f318b0e8cf61b3d2c97bbb921259dbeab114023be0d922fb09d051521880549239340d26bc5919bb6c791ed83bbfc283d318731aba7a68ed7a5e308330f3e385df8f308f1f2df6119b21f7127f0ae585f4a0f9a48cff65261b3f4419d25dedacdf62d008f427b6ae65607b130c73a2aefc570348ad7f57cebee00114da46174653f7e9c35bbab7533fc28d93ae43f36f539a8b94bfd55b56c8c00d04e500dd84f047bddd8d97b35c30146167883eb4d13385db6686e5736bcf76e4d72938e3e337ee386afe52e302d000f86a026d96416b41b024a7e9fc5f91472365e9795a5a30ae2312a85c490e94f4748f0ea195ceda2f901d59e72daf9dc89d595a67278b946be9e994c30b33d39addf26c59f74be0729e617f84ffd04865a6cf3884965a351c2cb7959af22ff4755eb6e096ccfc27ee8a8d9f2d99cce436bdf8d91996ac90acde58843430ee5bf3e0620c4b5b700dab623435bb0dba605b77c7b48544bc781628a00efde2b09f273ad320f4a6f95d1801775d27e621dd13138fcf2b1dbb8afdb0ac9b1ec8569c8b1a3a2fafe434127830ce88c3a8666e898a60599721cb5142e38b7d2b7717b7e79679e6638b195272836848350c126efefbff0caedcbf915455b03cb0c1a9389f34fcc4488cceba0066ca9a21f3b0d625bd7dd6e93385fed59bdbd9009b562b6d2e31a11aaa5861d5bc8ba9410c5508eaaab0e1eedafddd07719545bfdac9c85c4959725732b09040f3efd725fb92850ecf39960ce51e9ffb1ae1f0d1c7c9d4d1a9119c18208a7c8dadbc994c4afa228c928807977a242535fd9349d78f17daf8de87b08d25fb46d690bd57e5b61dc9a7847d7fa77526772fcbded2c8b58fa5f60677eb3e6972972662fe1676e7a4e69588fec22aedf5ac8b9bf49310f482adc6c6a37a400a50baaef5d5b8fa505df67569145f986d18dc00795424a0f69441f0b7a55423b081a570fac6591eb6bcc16702bb50d1dfa14a6398025fe951751c2dac74666f801c7240d8323b2c31901a734b7988d06db21f72aacd0014aa8e8c0dab4cdd51f9d5ee9bb221d1002bdf0bb7fa403f51b1b68cf20f5baf32b1297d03daf72a2424e89125ec09a5b2d7816bf780a6d3f73b8d25bf377f6878ca1e2d3f0b5218ffeb950f2b40ea0aebd5275c04febf22990ed9f1af142521ef7bb76c289e800efa55dadf02e11470f070c595ab9b2faafd586a3889009bdcc3cd113556154cf838baa80551f8fb403fa9df7e12d96bb47b042e90259b14c2521d6c04d443fa6df18405b66c653dce64348d43d73539127cde8cbb050ef8fb4cd8efe20d88b5560fd602c39dcab9ba307ad0c1e502b7db6df6121814749925af97540f40eeb7d3e84c174f20ab6f8c1c83adce8805ef206e42951375ae1e8e4ab8ffc52c9e309b23c24673f94b5eafaaa6159cccdca9b8737d2cafa145d384d9037b641e5ef936662127a123c85962b81877f7520f326476cee7ae0c618bb34bccc365c4f112c7ecae19ec22d5c2d136ffe7bb7e3bcaeeae76d49dec67bed25ab9cca782bfed9bc8afc039d3df11d970ec0ffa430003c62dcf116e7ad653498d1d43805cda3932872bdce42b4ccba6df2b00e2bc453d964cc74b14a8b37963e9aaca3f0c18e64d160a571dd8dc13669f5650618e95bf604446264cb376950507c92ace89f8c8e52a5579e9119d1631d0f60e2bf6a4d94e35c7413d0e5009f522fdfe107484df90ffd1138624513c7bd562a0c0b2e0db0d949db4ba583d9b69216852416df6b9bdaf85db4f16c26659c2b6ae2bde5730a918ceb0bf7203c1af3897f647a7f86a30cf1a25307b7d72eb07ee0e0eb9044fbca0bcedda761986834c1245a0fe11e1e434fd250897146580a4b6c4211e78d4c8593ebb617e0e90c61f43aab314f09351caca178be30ebbb312fada240a65ebfe6cdf0628b224857caaa928ada3736e8cd4cc1ff42136cba21dc240663122ea2a03c79cd3f58592e4fe77fea2f26634aea953162879347e031cc69c67857a02e252d5294963d4c15c9f801a1a6b9ea51a124a96492edb9c11f87c8660b17fefee6430d7f14dbe63c34a0283704e4b79d877e01a06be85974e2a29730bd2ba2b4ed05e18f4cb09c72a54ba47b9c161dfc44fbe3d11347243d18845c04179dd2b6e3dfa8baa0b90e85d20b321a4a1342086e8c9b308500d9a51c2af08a4c23c47f3f17ae646963a30bd32883cc27cc8a1933973d35351dadd3374ed4365c75bb0c742ee94ad5d4554ed0e290c43a84edfe67e69b597569a158f25b39e663ff659739c0d50117843f6c24fcfab37c38ec557365c34ff9d7232c5ac10b456681f7ea780ed22a0d2aadf8df1c60a2a3e77b4313bae02d78afc915fa12a0a16c2b701eab32ebd409d6ee3790ead0cb553133a65ec0d650ab4e08786318b1dd36d757a6fd0b3fe0d0758d80c2816fe0bdef49c1d709ba2957a7bfc17a0dcfc3fa5712e2b2a58001baeee835ae3736b40f6237a2f74f45b4149776ec07495413ee0602f3bb3526434d3f6fd2f69fa68f98d951bba96bb3ffbb074e911f1d4615de001763ce640e0006c91cf0de305264d636584d9efbc943df719db330506ce949d5427e471cd517180272b206297785df249d09b319e9ea853458f905e01495e9a95770cbf1ad8a1b8d30f1f8127cedba94966bf8e65cf59f42a4f588c297c34cf6ec110457a361d2142c0bd4a7adf997a292f3d3bb46d53af3e3cdf8cc97057e71b2015d1dded4bb5e13d7a57bbec12b833e91bedc7716b12a44b97d00d3c4b4fd3011501c4c8e436fa28addaabd3724b9d43f36999db9a56297389c29ee66b9c1a94bb4ab80b747f802205fd491ff4b0f84b343c916e81e3a756859ba40c179eea50cdbdc9c1436c65b6511e09b2042facf57920e5ba47c6ddcd4e64dd0b0808edf378a9a706d540fb0222ecad7c97b46cd9ba8c5f4f4915b2eda237aa78dbf48f64fc50d3990243746c0f483fde78eff15ce4bc885fcb0cbcf11482ff8acae2e1ad0e9ef1c624a1a8563c08d6749308e6e9ea3096568e7f8d8ac9c57f2f923383ddb7aa2543c25347860fab6dd8afcfe10b68ae2ad3c86b898eeff83065121b0a8379e90931100a88581e45a3f8f6cd9597cf24d4d2801fa03e1089fdec439c014612c8667cbd4eec261700e563e5e9619c2b92e0a85b9884aee5fafd0a744201872749aa631bf7f15df6dc03be976f191fbe040f1c7d7c0323f7ce7c1fd35afb5dac87497d2c7e5a2a2046ffc09d24acbda6c6bb1b791e332b1223e2d2af5e47ad187eeea8cb795e35ed137c44d9c33e1dc7724a34b0e69f9e74180f500b0f61763066808a34685ad1dc284410cacfc0fb8724e1fff2057e01380e3660db37938b269c3cafb0101ec7d0151bd66334c868260e71088542e09d4f8a579c7fe7fdcadcacd3eed408c8a3215eec3404673bb8a5844e6cc67f8cb10cc1a6c0392aee62e156e016f3943630b4929a0c11e4d3b5edfa26293e3e7c5df1be85591de0fe8c0943b27c93ae1aecdf0b1a1586d68864354bafc9c7600c5e5466b0e2c0b29508a78f2674560eb0485b580c0542e1536437d9791f067dba8ee42ebd960e0f091e28032d3803531701ebb3f96e03297ac9825eeb35d97cb2d6bea572f4a05b9cf0bf8c8e1549ea64ba87797e3ea433a17f76467988298f0f56445a9a2232065b44f7c33c8737d0770f51d37800caf96f5fc2d96a21b68114dbcdd7ecf9f550c03f289deb70af05c7003322428384cfe590c7b3cea85096821c97fad665990e43233bda6b7d1b5b476ff4434f204cf6238a0f05b3869cabd77aac0a8ef32652013cebe7502b60fdcacb069aeaf5f5c2c373f8d4488b268d53e9ba43bce9f3172d32f5b0b511d559b39554176290aace16436b824cfc88dbd092731b0d5cb4171f2e359d41b39227e6b8a06cdc9b8e5a2b6a3460bb398e55c1594121c77fda307b448d86069cd34e88bbaa52ba3bf1fb6349a10f1fe2b555447aad2ced5bff0cdbfa331433a06ae5abda4ebe1371da2e016653fad2118e75797e448eb6480687da92cf4ceae31d919b7067fa82d903d089cc82e3ca4dcc249b2df684a9619efbe0a4bda3335eae8c9071916d0e6688f1a0ef9ee051ab68dc5f83bf2889f65e23fdaefe90630177d15421c0e42719f6c8363055f03f5759afc94551a36b7914be3601895c10d1601a681dbc202a2a89722b6a357f5b3cb6d6e0ad8e4572306e047db652790920583aa224d3c82a9eea27f50e7669149c7d0a22df4533e2c401bb1b100aad72efd51bb3571b90f5e0774be8ec2d3144439171fa8d12db95626866507fc5deb4fb5ae80c79097f6c787a0f47dfb6aa8ad674fe578091258f4399f5ea404310b5820dec20fe6394f1fea07307f5f26291fc24c3a8ed39a4ca2c169774097d1705b48b86b169565303eb87d040e2436d7954cff8cf2b78a9fb9a1c11ae18129adea107c51fd022e86d21ea49d83f6266c398a9bdc51e1f6797021ce608b96101220030071e01352915a3a4fdb45bc7029fb1d6349353fbc1174e5c8dc82ce29439daade58e1233684648d7c5020cd4d883aeb6114968ef1d0b391480c131adf0dc416515aebef5cdabeb8e4ee31c2db78db9898a9fce40786994bf11b9ada5d117eb291148fbde4cf5c8ced3ef6a99f03c8c536ad5db466409e10dd72337c73aef1347d88fd2a88c138fb6586411bf7034135d7cb082a9ae6223efe6f0226759961d24819e672b4f485065e7f25d94fd53354fc0b386e319752f93d7efa79956d6e8f7ee125de3ad49fb3bca2bbc25c357d7bd2670ade5393a299fe63c9da53f94ed6bba4a30706151884fd31c08eb43839eb4d5045674e29f7695b964e2e10a9216424b2ff30bd5c46c4a4361b4179ebc97cb17df1fcbd6376fdc9463939b2cd28ef3e13d1bf60baed8a3885984c651daa1741c969a2c730cd5bdefb384d79602f32bc9b6535903090139649b475dfe3ccd3da95d62c428c382e70f4a65f34fca7ce94bb14bf216833c9b9359fa41feb1c07e3a283c21cc49ac42d73a4b23ccf6f1e2ac7b09bd22d411066cfff9f2d8dd8fd5a91dbd678a6f497055fd2863b0c0f1ad910cc5965fdbcc264deb495eb73b9145284794ac13fb1d626e24d009d1e3e2cd48909f67d4b5c02ad9869dd5d148174f0f21c2c79c6be2ae33810c96c7ab5c6d4788be22a443b409086d88285f954107433c677730af70c743481ae54515f2593afa75fab4d8e3012b69411e145c6a10c233479717aaf671acdfa001c7f6ab1ae85e8cdabb28a0baf16ee86e8f235419e5e760eb3f3b9c077686ccf01ef9fb2f2cdccffae3509d2fbaba70d58328437e2e2bbf5926154b699ecb9b81ef7b0cc79643cfbc6c0b7906f169bd0f6e6be8d2598b292919d2aecfe918f58b7bd5de409b16448581531ec4fcf92004f59383c9a820859bd4558bd0ff7f1bd62f0cd3bc9630b15fb1007ed3bbb21327bc4b9efe79132a84c97ed4aaefca0fa8a60ed9583f2874a3da1dd05b25bfa63f737444774eb1eee5fbc4217b5f565d52fdf96d9cf226875f618e5a30f1ea55d5e5405b29b331215ebd25864307cfcb8e790a64b0c080eadfac071a4e0fb5e45ca844210f766394b5021f3be07bcf1b293e8f9da369c2cb8697bdd5e8ad512bd4c959d598da906c85900ac8ef991a78598a715e2b8776827feaa569e474a64c2853fa40b48327f71818bb08d91dab7b64fcfc0c8ac20256695479af8afb654128123ee3731c2de71cb46cd561ec400801c07b735193179670bdcc3a50dfb7aecb0a14535499784bb5c55db41bcacb4ff3a354c724ea9c67dc87074dbea370b1ec8582c952cc2ecaa645b431b83b45c9b77cba6045a0877f67b713a603076bf9508b6539cde7c731e524275655847d5060e7d00951b6a44eaf5208d4311905f8c2202db89a5a0d3686a6298e939b76389ad4d84270f5d7eb05b1384facc84718654b40e4669bab8bf75c63d17ccf93cec3750854d3397fec8ceeac555dd39f6bc117f1ca599dcfe406569e6623509df96ad09f795daa1d5f228e64815f299f27b21f9c936d57929ed7484a03ac0ded4bdf80ddb59d0f8879c625eeb18f3d190bc0b30f5c07677aa84a13fd19ad74d4fa579b7860e5f0db589f6fd4a1abc5f070785dd104436f31b004f31f6c37415e812711618b59f685246d2e2966c99611fa8bc94a1577f91348df6eb64a711158cb3c9a7ca5474759136440b8cb9c1d787d6d47cebd147867b75aed29b5c636a3d191385853df1e13422cc0a9fc0a8bf252e06c97c860e53df41ca21aca1ec786ee98a704505d72a34ae6636ce30995ffc80727fc9e7ec64f05169128310b555672eb2637064922ea63f6806e1d28aa580cdb4a2794491df743940d798b88947b58ba6999089cd6fecf8a0c784120da8b130f23f854cd0db25a178ddfe5785aa923f422040714891b9fc9afe4f208f965cffa3b601330016b2a2709f43c9d491212b200733be67e339cefe9f705fde4727433232ea35e0eef87bce3ad49d0dd2cffcecdd3795079cf6fb4fa74b4f5d4b1dd2ca11070734036c9fb9ae2e6358a179fa575ab05d919569cd2ff7c84da41e7fb064737412ac96d7a78c918534814c3512a32f711035a68e2166d996b384d0dc896e864353194f535c089d27454d14c9b47ec24000f2a33da9361d8b457a7e248cc1ad6ed8efd0c8193f8f413ca4ad00e4f3ffcb25afc1748fbbeece0150e2e07213308610defc0c95fa0acc8b1286f8c1934d445fe9e2504ea5ec877f4cbb5cf602980e93879a8e18bd848b976f4e419506d67f14bf46e8e595da932fe167bb4e5952b5830b25d902620322ece5d341d32867e2007e9efbe34b6040fa3ba48cee38937bb4cbe720865c923a761e111167376f3fe2fdd36a5249cbb23eb3cb5c9679d9349a8d4e0a4eb019cace11fdbf158a859b05769c5a47e37114b09368d9ebafb3c63c89e05acc01a863c30c2fda99ec20350d63996232f665b528ac60e7caea18875edf1177b7684579e8fb4e8aabfd7b1dac0bad9d85af81d02a1ccf7d7e2e7b7d1714440f6792db2c05d250ab09af2817a5140b1b771a60fc98cdac1ee287a7ec9fa3ea80cdffe2b5ca62f2f1e07a9785253c9cc196e6a09b377b56fa0209de7679441a1d2538f6a69d0840d396c33d946cdf169fbb9e15800a280e3ca5640f92f435ea021a62e608c0c2cbf7fae9f3226fd0fef457c6a551c2180ee5f760c8041be510281c7e3c839dbeed4907c6d886b962baf1efb6f79459a5c6b5ef5c4c118b1e51c57a813bcedfd4b7193621585a87cac107ca62c7b02c4c29a9fc0d2b2afc27d729eeaace1e38301eecb2b42dbff03d37ac868da16e089febb640e61bdc0be93e16b134003a38b05431e3c38fab2c99c6248343d80b4563456c98449e3aab1b782c02a390e8ef4bf3d6fd8b500dbe3d0c62366abcc7d423483374c9837d8781e89acf3c58a7998ffc66fd45e5100ea5fe91dc43ad0bc14fe4ae9e41b39e42fb8ef09d7a4634b7dc65b14ab8b9b614dee97ca7c56201067e976a424881689bc387aeebb87fa9c9ddc95150ad6f4a666ba892bdd81e8550f29b574be59f555d97af28e87f8dc29379ae4379521cca09042f485a83c8e4395e96731de53fed0b8f5135365e56688cd928929f066e009ff8a42004788c2523c6d22bc699d325b3fdd3df93c4f696fe5fcc702ee63e9ca4c5704641931299c1074f38e30769404711d83d95dada8ca47bb0fc58c2d90955ac5f77f1a84fc7ee7777ff9e240548b18b3f7b8f007d89df618cb1231f3f3f0d1efe89416aa1b172cd672391adafd771c207f975faf4c7d65f90cded28697526857c8458cede7f6b7507e96b22f7ffa9ffcd879e92b212f0b9c26fe4c2bea12f5a1ef962c8230f65b80d4f13940d35d54d668a578de5abacc938fc1b7e08072ed3ccb8a8b8f2bbcadd67cd6659f12fa9759ad1bf0d8b5c0ec67881c8e0bdc945d4c1ea8b03093532ec41be6f6cfb82a3b5607634bdb66d219b17dda89b778983a6ab98038a8e30c0a7572bbe90455c742de79c2d9622f505d31ca983f615788b77b39de670b04d56717e602f187b7753d663f944ae385dd226d36434e02af76d94de5f6e7e8099ec07ee09c663b72e610068a034a1d5ad7efaee6e53bb8c1f30cc24a3cf838c766836ef3d9215599e51c1b1dba50a2c3573d0abf48cd8ba2caa27da4cc5b5b1f607d5cbb5a451cfe0be680fdff1e711a59dbf8a0d5fe84141511ddeeede01a426df70f76d7497f32ce9fbdd9737edca70c3f40d87e4f17654bb665a7e5e1282d3736c85c3bcf6bc8938c1f67b08b3771894fec93891580528f457773764461af32d269f995c4f64a8aa4d35df1ebdd702284894b09406da101c9a67a3dc71ca5f54239d7f8373a585a6a1e8f66e6b3deb804a18ec21dc57458255e2f240903ff3f6cf0e8f19ff28dfc2bc3cbb3d06e893e03493af1471494de4cf08dc8508484c20700bac46c7b807b9854c09d1a0d2e76eb716a5024361a5d9e9f23517a67d2d8d9aa952821b68dbd2937b59bac0ba4a7af513d40adfe7dd4557606fb8e561f1c74650378463da8e69f471dedbdebcc5354373e40c68c6131639ca7735bc900871bbf0813476ac3b18e5564ec6536fa35968e6ff97330d3e036a7b2ce36d4d7b6ae04f11503ad6ea8f68b5c6c51def787b5f3b72e32e8a04ca93a217b9185fba22cddbb4ee020511532c818d88ba62c682523af151185fa01c298a7e603455466c2f77e1812527c000360ff61754f96f71b19bce135a47c06c242b592cf32174c168ca7272e7dfab50387820f87d3ed4f988a2ae62264cacc16c9b92fea2109c415aca0a29319247ff84fbb4017aac9d1af68cb9f8e1ec8cc345e0997f7ad6a62d328a91cbe1d2e9df86f0cbead157ba816d3393b12267a3cd6fe8f603e014fe4fbfe693c2b7b92ef1becf299f79c0691c05ba9598df1b8c4a2ea0b724c72c6aa0cef12a01665ab3b33b6d99a86fce25a0471e6a7662317f0ffa859afdf35c531a9c7ebe7d14b216538a3b30ec1c2fd5494c45b8441cc230c0c6a96a4fdf3886dc215cea16b53413a530a315dfd63eb2c6535b888840771af89b702f92bd0e7036604fd873493e7a205e4505031c2c0b545e1642f3df4200fc936619ddfe957b4c9937b0395e1980b81f66aaf7ef05eaca20f52cf9e20c99f5eb7b753f52c7402f78373c6c7f786d87561c4d7b3473c3b07469bbbdf36514e4421bd0871dcedebf0e2d355f63f0f995bddcda5e62e31a0183cd6a68497fa41b9525fc815172882d3262dd6217989c0f529fd55f49b58d08365677ff7eab8c874a937ff35da75c92cd4e363dca34ec7dcd91a2bef8ebf2e9ba0a96bff1d73a9bcb52cdaf11eb5e372819a3b5832afb4da74de42ca6befb02ec50d97520befe0b80aae38443b68ae4e737e938fc63f4fe469bfa2fba23839befdeaed7533950eaf1debc88a0ed443dc43c3033d36175f165dd5853617a9c3d887921ef0699099ae273fdda34eb4b54242051829c0fbd0a311468afa98d41e32d96868d567aa35b5b7f5d644f04e581a61d6bf7d398e0f9b8d9d0cc6b82b111b6f1050f20e0947974e221922d6a7e4e6a5376f1c9d11d488a4aaa72aa3ecb78693c2b7a9deeea07473ffb9391b36785d2c84ccab705b7e19b3c55780f10448f75728a9819e7bdd042380d3a55cd4b6d470acadf66d7f06bcef75737d521589096a25696bd2d57f451f9922dee9f8e98de12f4d065b3291ff8a01f9e37a67958599be5005320cfdfde0cfcef59f02c5158e98a27f7e446d73f06959d9149205a4e856e316baa354f807be76ccb9b0557a2323569f695c5a39966cee13f215026150fdda81776c9cf2779d9bbabf971140551a6a635f171960fc4579dc0e3ec53941ecc85055a2a75790117de5b86ab6311663e4a8123cb121799279bbcf93abb32ebfed53bd3a6109023c0c9165636677a3e4a3f3c739dcca19fba0f38fe8919deb93f2fc8d5259afbeac8c8dc25a51ce2d767551867c03c3e2c18433d953b382d1a34f66acced8ae59595b357bc114ed89ba19e42aaa6f49b85b19a9452b01760721a25d25873a8502b4da6bfeb724ce32e5da216935440a2722d104c4cefaa9dd878108b59db88134cb6a72d1110146b6cf4d53446de64eb25e09a6ed6afc74e24d03c9b0ac3b0ce44ba1fd2c67798e04f1406352b90c8f663332a7440401324150dc890562c9acc0d116a8d649dba3f2f2fb2e73f2779533ff2e94579e773ef594467c47e01c9f29c84f586cde82e41b57beb801931f728be4bbe5905bea434b52ea13a5f5f0942729b63b5494b312505bf864bda62f32c78578897b1cfc21a058de6710ee9099fb565e2655320c266ae7463dc8d6a67631d228111805516d3c9b6b52e19e1d2c855c4dce739b3ef20100fc0c6e3d9cfb4935a755ed5178635a8395a664f2a0d69531814725f49dfd362f346531c5acb1bc479c43ce6740a9b64a2b01685373741a2a3896280b27b82a62d0472df1a6803c81e5311f1bdc5f5f76e21406f3145f14b7167244d6bd0cc50c49e89e62f2a0f47cd4b6f57717b52e0b1ab60dc4f65cee27d3b70a7271cabc6fd127c5852992402a4fc989eab111b5f7149766990dbc0ead419ae65392a6e57b7ca18970d670bd14be9a8494906d8d90807015501966026266b1221e6d2e72c19e001863e6231410ea968f64dffc98e3bdaa93ffcff332900811196a3187a4d9f42d592a8df2dd700948c6bc7633b7e32d8d9edbf9e65d721f819925c0f6099f2fd95aabaf5d6d7ec78c69c21304c1c56820b31036b1922bc39658dc45dfdb2be3908bfd491c28ef11e6c23656b638cf824a06975666c9d97c47aaef1c56f9192c2edff5d5cac428dca71d52c5638b1b653f86906cec0cccaca52f1b8490879eb427e6c3374e626a876a810e14d02cdfd5da9cdefc0c58cf276309b301582cd9ec58b8995e675877909afc41e184c40c04a6ec5905b069c40916fbee47c569d6de1cb10185f140a78b84782fd44f97998e02debb68b1af13cb9daac1b84abf683b3837481d0e1dddeefb282dc411fbe57e55fa029410df0603c85f2a625935a29b17909e645145481f7f5fb038863baaee567f71dca664cf82e7859e620bba00f49c117b9109aeb3d4036b4dc3e15f19ce17b37569d85053644a67859bbf241359a57e42f3df7732834db123f0e0d92fa469fc28d2e4ecbffb1eb035120ee1097e18fb55417cbf60217ed87fc17facd8c060b53ade3545740d44012bd9ef3fcf0e3b49c516b9276314d415070fe49059d4b6fa9dc20eb8e5f5ddd72e8f8a1a88ce3c333dddacf94ff7715ea1dbc2381a91b37b0dc81884df6106853d090ba89f122f46d5a387cb99b7d8f32a74369734964bc31201fe34cbd479caf35ec6dd73f317d5038259fb6db730df828c521ee43938f8aff0643e94fc3a57c75a92fbedd19714186c4c52cb1f20ee1096ccbb20d51bb8bbac007dd86ac7d40708a1f43230b2d0ec55c6d851e36c3d19cab97cf5d50fa550dd59bef08dd63742d9cadc3d2da6db358dd3fb208a20c72c8f8aabb5ddccbc831b87cab9563e9c5876c52c67b9a51e895a772f2901b61c00925699f0be120bc60b2481099edac9607a79432afe82f8e2744c2201a2f7213456c25642f4ff7f29ff15e01f73a97c2ddc9040b4ebd57191a0120e4391f39291ca970a00e6ad3b873abe0a0ec4041561001f2fcf48626e1eccd3662252ea3c732c132f63a43d4ae169203d648be664335ab09a9aa1f19c1b752967720431d802806f8630b0306705ddb4d8d374ccb6291cc91d14d717e3becd1fa90462a494a99a5ab9add86b6ac7a9b3624cbfdcd12468917f7cc16aa20f7a92d660ff68f66f7864eecfc898b28e7aeee05497afaa828bc74ceb59ff847e225d6888977721472c3db62e590d08de97925e039c379aff936bdc33e5bd914cd3be1fe6c18fd5a7c1384468fafc869bfa70ef83e893bda57f4c4aae5f8ab01d68e8fd31587ec7d35463c66c77cc22dd9d99f6ffa3ad89ef3393f9e1229638483437c0acf923bec4f2bbd16c86758dbf77b2f939398f5b3e7ae4215d337ecf83761e5572c6341120258ff8d920cf83e67086db8cfd0b81fd057e97635324190873ff31c4dcf42bc4c5b67106835d2574fea616911df62c784f1b4466f8358f23d2485f90519cc59033ce530746459dac1b280e2b8953a11471bd60d42a3cbc28e0b14c9d5b9adfa8074c2e159b32973223df9022e4c7b4b675367e301a3593084dfe9a012970081dac08e5d550017cc6f0895d083518844452b64e8c0d20f6771adf4fe5935244b52e4666851b4adba2ec5be05cebef1951f7a4d02682e7555f93c0155131c143f3bdd3304eb8d8f04bdcc42074c041788390e4302a29def531239c6dfd9f3d39884607807c83933e8f81528f438ca8554596a5131910b37f9e66d07038f777123351455baf4a88ef1f24c8d702e5e7e5ddb59159f75dc4c0b6886f515f2e69d31d27b9ef441e81294ee93e3ba170531bb92bd29f2098abc0b174eaebd6206f4d705058bb4f3a7c095d5d03e6b82b6ad25358e365a2157329ad0f7bad075a63a512a0139f8f8158383bb3bf6deb6f4c4724472b7efddac717d82c229052f6ed85db6c1c2fdbde469a665d946713d10c484ffedf281d586c227f2c7faaedff74d2e77604b676d4b31534e8b1185cde7cadcbcbe94d0db69e08a7cccdf28cf470ff9f0ad697f5b91ce4b483347fb0ddac846869cf289606b04e76b8bf39bde58f67f8282140faf2cd61358f1d546ee96d24fbb84e92bdd7f136d5428783e49ad5dc22cce273849ff8e2773e4cfb0c6c7b57a4537eed84b9141d2b15db3d2aeb44cc0dad127caecb56257be782b586e99bd15a0288735eb91dcac0b04dbba1a19440595ff01eefe167cf05cdf76c865de64909554fcce468c080bd24cb7e58b0eda18e3e5fbb20943fd3cf1a01fb421b8103dbedea2dff00da8b4373893bbcc83066beb890ab1af6358c74d1095b8b775be2318de2e67c7918a80422e6328d04e55d0a81be6ca972140bedb5f616639eeeab77a43d9227295eb82bcf94e7dea0e465ce2836d0d5f4dc2a4d467e1ace71e823fcb54558d4d6ef8af7ad4c912b08f3765f23fb3aeff3cff338e1a1716c7176dbda7e7ece7e000625c5d3ef904f71cf4ce64eb103b15063f405f77ecff968d62656965b47c570710b923ad3b98a0bd1669eb9cd44ee22150b6c5ff6c8b91b0a5dbfb63c863c34034fb79017f70c35d70ce1568abc79d257df877dd90e0e05879456de59dd04cb94c76a2aab9b9be9abd13ec0241048caa4f369376e8bd90e52a44a9ef4506d2578755b7c9b3715c0baf5f639c497fe27f2c910d3e7103d4dbf3af8370a58c7151a9d69c834af7606f7b3403e0bb561a21c7acf3dc77397ff41c5e61d0fb98e447bd6ba128b20cef1ad987982e00c025fbdcd31ecaa27734def778ed50add554919330a2bc3d7c2637cd4bd58e5dc0d02bfbfb34768587c8a05d19d8a563f0f8e91edd4d1e88a1eef9c903953385fb0c1f497a87fa2087521dfad11f3d2f552881bd843a72a938c9054d074449bd7e6f6dcb8c94f128978dceaf2656ad0adc5064ff6d5d50438e8ebfb0d1761ca5f7a3e5b23d246cf6e2a54e2a59904d90fd5d5a5048342e08e65285c4b458525cb2b97633303f64f8667a81ddbcf3588f240860e6043c5cc5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
