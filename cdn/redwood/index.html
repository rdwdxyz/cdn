<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"125250151bd122feb3a4e78862d821b3f8a7d8d92b8d78f3c509d43f8f9f09d3deed4e35a943b90038d723eaf8fdf2492aa301a44f83943c47fdd56b2b382f0f68eb71bebda81c21f565d811df7655d7393edf87d89f1e51b016c4b0576184f749c4c63acd016a7871b060940e8b68052a1ca11f6c235d5c7353b0684b241061a9e8d3432e6237d2f2262de588cb314fb1d86c2b2ff7cd05643135bfe211cd692f150c7b0b4b86efd79382cbba3f04357d5ae2788345074e9b961df96b529cca30bc473772b21323e7b0a5d2d91249ac4d3a84d1d47e59e2d1c49baf995e543ccbf030ed812b214d982fa4d2c0173db19fe8bb68f91a7b0c1ce3b24f97513653c9d22d94a9e5d7e431c9312f6453880ed1221039a0c665e5f1bf98cf3fe09e9f20d08ec83ff9c6655b50b9bdad73840195dc6c77d1aa2274301e2c916ee6d57041524800e485067cda1e8a4679f5b1971a4920a2485b12098bf7160c1109e37299eedb79fcaf9ff959d32e85ce7dc588ed6fb99b309bce05ebfac6dcdabdcc6dc3af2a009e76604e630f8ca894d8ff5e072fbc8697ac88e21eb08c146cd95459dddfe37dfe2c29bd73d4bfba2678ca685a4b7ba2f2b54676b506637695fbf3f46bdc97ca7e0eb848cfa46fea562d54d03a6041734bc50eb1198ecb74f7a977da7f6a718479d5eae21734751f413b710c8734dcd1d70e85eaa5caf97c5a7cfb6ddca5452f298a5565a8007775661d4d170b50bcd73480576d4ed851e765db387c764ee91d41548ba4350e7ffc70c98ccc8872303d6d9f208261734b8543c0782edf70045eaa7db0cbc31865e597dca03258c7e1c0f79fe1a96b5c402c4c3c260e12b6717c2ec1abe4d81f041afd84b23638fc8723fc24c5319c4ea83b880875be6ab200c7c8ebf7a63b4c3fa5b2547564f807b11fafed230383fa079ee2c1f2dcdb90411abd1a6236d5113a242f1b7c0657c8bfcb6d22e6d5d335a1e4575b2a567b2780fc1df46a1971393b5df1d0e28e52dcee70cc4a92c492000dec2f7c6ad95fd0f6a38e963f0d8fa4d8436fe49fa4e5aaea58e97a8662685e171c30f319708eda437a75acd5032cdd23773d0663d96400a90dd8ddbc785c5fd1165a7266c50aca8d39e242014ff62137d1c4d5f2662dc4260141078265ce1ef8eae078c9c2001bb10e88054bf8f9cfc4d55c18b7dd3dd97793cde8b5f51abe0efbb516a5401f647f2e21272650b329e8f86f8cc7d949307b0e45f1fed303c1bd92de31cacca9d40f87c94cc569e0e78b62159150d7dcd2013fec61c6668bafa1b4349ead8927f8240feaaced64f56bda7505f7a55e86553a5db01df1412b8d7244595f38dc437eb44375585241e0bec576caf6fb1f000c76fb145cfa1e7323e936dfbdfd75f86ff0a9534aea4ebea187b53d7367a4bffa440cfedb915e375eefdb6fbe2c19df48a1069f1dda72536816d9feb6db51b2d890f8066c0823b3837b68050e165d05a756dde39d81bb1797a5f4f8f9c087dd23c1b430df815989d2a34793dc0b7b75819bad0778009800c4981028b8a9aa320f1bfcce8fb341fe9e337fe93e6c44cc033516abbf161b33ccc48ebccd3ca67bba060571695f2c8ba56c3a344c29daf31125cb804f80a1c45cc513bc4195ebd4eaf98ac78a0f8203c7f6550d6b4eb7bce209d5fb1844240bc8d3070db40b8f25d6c53f6eb6ab9074044fedb191bc9e884279ed510f35fd676140aeed3454f472e19fe3907ee374590406aef2c50bc1f96ff75a48da6fcd9e7c1e4587488d9661b64b273baf4af8d4f38caa26651344f64e48965affcef6219627daf4ddc40959856b2c043e471b81bb48f406be091b4bd2b8ae112cfe21d7e7ac521b996793e60b08f6214a0ced1c1a49b98975c9330328c70e526cc698b34180a34b9bda247a4e8b056364fcfbab6c86f82cbfbef1101936ad66c1d65ba2939f3a6233d3b85340694e2d4dfbb686c11e4d27d1ed3d047cf9d47e24301799fc5801fa0ff2c57bff40d970e2ada4ccb6616108b6f4d61c41b3ba872553d484455b9b4826ca6f4f7c3aca2441aeb28eb594f92b35d64c6bd019972fe416a9b8e400edfa9e97454c0d499acfee2c8e9db60131100f34a33b50f84ce0046d2d5c25f8a0e0ed95fee51adab1b3828580c0ee6144573606bbeb4182a22b79baa279af4387922d60b71cdeae2716af10e347bbbe20258f944cb1e2eff5e2db606ca93a68cdad3043d7624d6a8b2747cf18df89a5dde5ea8063a96b3887dff783541c5b536e3a15a4037cbbbfa4deff80eb85edff0d5afb0dacbed83e8556c16ad57f2fa5038702dcede9f8d332d7137654ae3f9892e695dffffc84871ea8cef13ddaa1b2848f60ae92fadb955aaeae2a50c4c3cf8c0ad4e7aedf772866974f714274237dcb2f8b15247b2841018626d8cb2211f574f21b394541a16e224133a9b71558db62531c5a29c12207fea83d36f1a0a202ec1a68a149c5cb2214fd93c6dfa5e11ea668a165af1d3e5f9f6ad11b92d7687bf7a77b92ad107a191d6275439d942279fd9b30ec4a5efd45a922842f57ac8847a0821ffe1e53ca23e0c3049c43b39b9dc9a38baf08f487902baf4632e225029ba94718ecca10601bb9de88847d704bc0bfd4353cba5601ac1a6825b8f06f2e8b952e90bb01e4bef6c86bbcf44c7e78791556f25a682642820a797a4f0d7d134fe00b6628d1dc12f10ba87ac5e7061f4bf96142f6fbe21a21fd3cb6549269ed70deef4a2f3db33195d4291e9597b4b3006118f25c0ff0eea99d4b0eb03a75c234d662889f1fb4a6a95058bee46931c9bd7cd84c650415424c70c70fe5d2e6c993936fb1b5b7a028ff741aa937af25f3e8ed966841a7fe6eadc0cdbfbc8fafb799c7545039795acc3353c3cb7938b0f8b6724e46a2450f4a8a25f70809fedbeb561233d322b974c714b9ae88a36bcdded44ccc976c870a00ef19aa20945f89c670b813a6e33d4a67516ab2d7ea36fc1abbbb5fcb9d34e44179303b3e40d5db8ad6eb737854579c7d78fe05e530433186628a0bb96ad5a9d09380d48c8cabe6da4ca392e088aaa245b38230b8e8ed8986b43c48b99afa2f10f6dafe8d5107e692a66f244191f12a8a7fff5d70b5b17ed3c59fe60a4fda849d5daeb8a76c2369a55e8d9bd0c6f081cbd1f6cf89a5c4dc2151f87243216aa56fd125942346c10fc2b98b3d919960d98aa3c80c79b1862d06ec8defdc8d74f67499bda51267ff2d6ff09f3ad1c9b701318690a21c5a1192135e1ade862dbe9306f2c9738af20056c47b73a15ffad2905408cd1cb0e8bd806c1086643816ea980a9965f8feae0fe66425d311ee973c0aa155cff3d5424107de188331d49ef4892493228398f8fe18cde73d60408be5ef40e1ef39f975901fe309ca2b8fa01af0fbb5878824b926b8806def9fc74e50aa633d3c2aa01f9b62b7582b6b70fdb83ea095f48b373add0a25badd999cd1a4f9c2ec40ef0ea5bf34ae7bd9cbcf0010d84b9bcc98e9a0efe3822c5d88fda8e4227a8db0928e7698cc8710797e4801d5d3fd521b1f536cadc0c71d10ca6876c150d56320af082ff4490b54268627d4840d3b4bbb1911513ba9a807a247b87e0cf6057de18aeb25d9d4b1cd080bfac3c990c55b77b9677404e130281b94f78e0fa37bf7ba1644f74a08b0fe759b3c66c03cf94b3a3bc2dfff865aad5764cb9b46c0edb9b2dfc173d6dabb62d1b78b0a8507a968af83ca3719b68bfa6b2c199acf52c2e440a86323d4ed0f1759884bcd2b1983582200b92e6d8f9309450d6709aa72501e08a56d1376cd2722e67817791ed53fe5bd523cf96746e486410097cc800fa6be4614b396505d6dfad8cc0ec0dcc3e6ab7049d4c53bad96ea5d1d35354c94d9241619a35dad027157920798fd70003f1ea74a35be949844386b016e1e74eef32352bbbb7b46a32d212a889dcf33f0e97fa26eb03902e3e8eee9dc960a6d60a5c52b624bdc4bc904546382fb4301f34a2b4cdcd95ce0afbfff2b7a8a3cb17b2f66e760ab7f37de3da561637469865ed9b6e6784e0edbcbd83025115c61445c0e7d86c9e79bab2dc69241fcb7665c66f241b700ee9976457da1e435fc62fb022135bdf7f462eb310610c88492e84a8a5f484aa74005b7980f90fb3632b9bc636fa09cd8fb81eaec8c15475155ea2dedef01c28d026abb86818fb55c14031f5d8a4c078ccf754d4499cea0ab3be75d9ec05e0321fdb5c1865788a476d4c0cc69ec26ce949ee9c4b6c3a783cc45aa2b3439028ddbb4c596092ccdf06ddd9959e52c1c0e638342264a91b89ce6cc8a5f11bbd5fcddc7b9ecaf4a162a547ddc25d6e71da5d02e758ec94c0fad6ca615344421f82731311eca4badc66f5240396d9ed8574127a503348d8d2d8bf4ec19429a3ab8cccda7190a7369903a45915501c5a2fc326ca36c0cad3949c553378aa1843953adcd83648f80c3f429bcb2fec74da3ad2e9a60a51ca30844aeb8e521cc3bd4a65366b150c7071a278cbd6fe8746588eb3aa26816cfbe300c8c6900e1e376adcbd648ce0fe1abb2b154cba74863232eadfd3b03164d6a0cb816fe5658c6ffffbf01caa0dab30273cb04ca51f14d110eb749888db6a2ec44f626b87ebadeda6d2d686f942955a9112370f73bfb666b978e7815e91ad0ae6bb8ab24d695f61b70e85724cbfd1a705fa2b8114ca90b359a4c8c1dab0021db08e9181299174dfc8bd40a0f854a87f53d9fc8739b3a3c5355ebd903b6fa7d449e5b717e08f8f5e5385b50c3b72c4664628f3c4fdb63d6433078691558e8875aa0c132b86926c586d21903e5dc411504e065f5ef725bd9435a843bd337a466b8b83dbeacbc00322e95b6ce36b700477f21c5a512fb1ed6c52aec005cd07396130191af915ccf1c7c59b2cdbee360e50db14b9049b4bc4d415a72cd36380074485e01166909d49c781edc4e88381996441a19de2e3880938baaaa1442320015c5ac2c6809c96c395c57833dff8cc06c3139db6b6899b208a30b42979df20be4b4fb55d3232b921a02ce6ce8179d3433315a0446495dc86a629e4fb0b1dd51c8a5e8f331a11bba0012da98805c9241430bebf7ea24b7560126052d5e17e97cbf3641a2ed367f80744d2533dcfee244d350ce8cfba818d9a53234b3ac497858546861e44f7d69d8a10478427654b45707d1c3b5ce29ea7ba93eb0421894d0c25fb7449e49af5aaf743c82e235f3c865b4f1f8c39f6e6198d4e803ba839f621976d07b8b53c81fbc465040ebfc5e1fef9af30a128d9f4b68f8ffc5f04810e72790ed64292d35eb042167f2cf79817f107bff02441b0523ba1b0fa2d9937db715a3f86584bdd7a1405129abfc783273b3b5bf35b78fbb53718707777a1d42099c2fdedc5cf56bf644af89e8f122c08c140d5c4b7fbef98466e158924ac4b1e4d2b31d44e22c91f1e764e81197ad31ea7956aa5643d5d6bc27cdd899f6890a83d6891fb7bca18a49eb70cab9fef734f635af8f4ffb4675e69e5f46ed06be0b574669b574dd8071761f7baee01d8a9fd82b1b669db2e31bac3316a2842487d2d5abf1201216740530692f04aa87c1dbe21dd10f707a3a426b734dd948231a0a56cc725aeaada63d35a75dfc1a76f1c2aec6d35f29de85a783ba3fb1cbfd04f5a6ce98758da345a806c0fd7e1c76ad5387b9f033c0f84420643f825b4136527e3f9e1040630f7cc636938cbfdc08ec757b2909ca28d0b8d981b7b5a909278626eed5fe1e7c7578d4a6a32a071d81559ff27a153e8ce48cf39d3c1471f240ca9847db13b2227111dcfe827464474dfcfe8ed27b1905283ae20efcfcb5a26f888bda6633093a64659922eb91f0584828dc15c724554f35e4a07fb337be3b9d374d3e78b77f2730f7d8368f9af3376349b0138e3894417ae023d28606c4aae9d8447fceb24ac1537f5a2b6398cc1259805835c3496126f989ffde04f814e2a9416f58a98da8057b9801e33ed756af9b9ff175d92f3232bfc3134db230776287041e1a1aef7f8f411cee402f60a48dcfa858c797ec7715a9d64388837cc7b6ce49ce38f374340517af6005665191a4e98103a0ed818e48a5034bdb6ff839afd8bbfd5595e2c3eaaa62c54389beb6a48ece49187a532b9c05b594040f7c8179f494b3d7c0adf24f3490ac0c9c6b129632a0ef1b43bb1a419fb2890e8556182247b3f74f4e2e2927bdad5a455c9449aa7fa823abcf7a3a13eb1f0deaa3a145f85e2ce7de481efd6afadc68971be39d8084dbfb260338aed6f08f6e00980fcc9246e823c7413df848e06ade494f55646bec18aa3cad14c60ff81748f411f9fd028ecc25d864ddf275095c69576ab30f5670941b8bd8c816cd87d8c84057d4527fce9260862d02c908887d22ae72d9ca2d59dab32ae23263c047de65450e3c0d7e2fdc31bba0f177cd4baa68fe839d5573333dbe6b707145bb1be0f899a9d396ffed5f3011638ba1635cab6e1888e887b127e3e03ef08975873b90706868fe81eedf273bab2cbd5990b9caa91d9ba7ff889e9933c979721caf25d7046cd0bdd2c4f8dfdf5fb2f7a867384006d3a4c5b74fc657281c220760c2c53e00bae68e56090b5128668dce43205dfada7b49ea9cc50be4c85189c664d84b147ca4806146cd1469879d16e95113dc0c0bff213560ce750a1d27672202eedfd68a766612af574ab1e9c918bb7ea3f42cdf8106f5f6a68ba6eb07afcc8af22e0d6f826debb8c4fa76b33fe05b47694be52eca6263f4f99f183ce428b2bc52d2b05be3afbbcbb2eddadb03d90880776a946136c9bccbffa308a453c915edf440098dec5c96094b3cdd9bca70995ca14606eccbdb9e2f6df6b3598401e4ac91c5e4b71dc654e2df4502245e9f63e636479704172668beb7117bf380a4a60279f0246aed64d30e0842fd4df375d933cab17a386b2360a86379b99b4bdc90a357696cd5ef7f4f9a6f300caf02933919d2b24b9934cd8b27f9955493d5f54f963bcab8a454fb54b5d8ad4d236930ada094de08819c9941d93c947e6627eb66d8ac4681971184f3e26df0d0eb5d5f4a333da4ec16c026c366fc122729186eb268c65d88b31cb03c4670daba7ccb80926993c04fc72a1b13858465f18ac594d41ca0325380d1a7f9037838779466e21ccff1690d03844fff382cbaf349bf6efd3bbd0f47a6b0538fd0d2ffb65d559fc24a12874c5105ba39d8e0d33456d301658adc6fcbd30923f60217ee5b47c899e176d2d48a52455d96f21e2251032614e57e538c1a17285d76abfa00a892878c09e3a14cae6190fabe9ca7495e6d5e3b7747383a25c03ca5eca777d838b43bcd150a44d614a2137df766bc22b047247d93bab7f64882505f0812cca9bf53fe45f13f8d991c29333338977a9d40a5e120bb4a94eeb6e2e7ea1f316c7367ab81e17afe28f72d26aaafed87911f1614ab85979ad8b35c566acbc6b726803e5216d51ad9b27266f2acf21c834e37fa36f6c056e6d8fd13b9dc96c6afdce69c635b7464f8bbef47c38c0c7a8ac57879a27393e88d70f65ea3758b9f3329c89690a22d09b6ae3f62e272afac00d550515e241b3a19cb1241ec159afd871e33570fde53e24683ab25940b21ff4b566007e02e8e64cfbff17ba8b1fc50fcab99478ee2e1c9f0fc6258aeb3eaf87c775eedf4004eaa70838ec4bae291fabade6e2f66eeaf315369fdf55f552388228c4d5e2e3a741fef90c60ec81aad86ffac6156abd045e36239c2eab0ad085d0d423856391504c2b7d87b2534f946ca7b2f0c711bbebb1d695b99156bb5645e5d083f837d9eb7ceb9bd4718a22c877c27b8bf80b9fd2efb21bdd2b3f10e83d56882e4027ccdb9e236f5471b50ae5290b6aeed6a78eb81e75a052bf0b592f2fb7ee1e54afb1da7158c6d32b0614f2d7a79171097e853b4967630ac6ee02bd32247eff3c85decc7821bf4ea4ba5a77b4355d7f4248cdda4085e7aa22c85aa34df89e2dbd339957aa824cca9534fa72166ad36dc9faae5bbefff0d016599043a90dee17f1a802c4eae0a882a1ef69a3411359ed07a265435b281c6750140efb818f498a0006b6487de194a3bca6fc10f0a0905e18de74b45b3b60bd86f0daa28034dce291044fc400bd0abe6ccbe04f950f13d5d0f468597eb021ade957ce6aa502a49eca734f9261e0d75e9b95d5ecb12fda1439020c969e794a0d73db04338a694831f9af27c028de7066e0ac02a845d5fcd0ed1ea86ae59a42c36d0eafa54b236977d13f053613dc3df46e6c1cebdf9473fdebce4c087364f3cd68e7b4e4bd6eb0117ce8a6c27ca45e4b3c2100a8868840218b094b15c5da3de370e3c369abd8f84b5b8be1ee4d3011e5c1cc12f6fff2dc411bd3e4e6642084c18900f03377b67d7378577529e38cb22b57ca11e51d182da7ed19ce97412fe83d31fce35c446571f745113326348b40148a5904a896661dafa3a8e73ba15701e87a440fc4efa9d6c8529c7bfdefe70a77e9d1259da5d7aa53d2a537d478ecc756f514984690f9f43ce6f9e9634d73b7d4dd3120ce4d7426d8ece7a87d54ef2a96be659662da90e0b5e037409e69842e6df1c227d8bde647aabd59c1dab47a7b45210d7a62e1953e2fca6a4a3d21ee3fc5b5b3a98fc96e598da27c5c6f17d878068f01073bdd593a3fd690806d6ef92eff98cc1e76c25d74503745b49ddb3540d51462cdf7be85a86b697191a3df6135776ab75b6d8bc33af89f0c87b8728bbd05df592f5d054719dc1cd9d02c901eea9007de250d16b1668128705ba30d0b6e7b1add00efc7660fdaca8e1874d72d0582765133343f0e972998cf1a36d56516068d9f7ad5021b9a45ebcbcd01ab4399753189e67515d937df6e61698faeb664219a682ccea7e74b804dc5109040f85d0dee3a2482375736f01910ed3a4b8cc327e3420876eb6b80b8de52aa821af836a1c2767b3cf049e05d21cb6ca9f723d0ec89d95c7986893098809114c0761ed97d6543bca66bb3722fc3a4becc308dbe9eb1fddd165560b2b26b6f0e42012f3e51bbf215fa9733a6c5c592c2e9d784d0aaed46cabc5042e5ac5ad15a9221103b46fefc17071fa740be9f2539c8fc3c377c7d92f06568e707e62fda9bfa4836dae0afef6bc51e17e124968a46a8a4983e30c497f5fd6f9bfc64d710af03fe748c044671f498d3ab1487ad5735fdba912bd824f5afb4697d003d47f5e4ebf175383486aff29c690b446e109c7e5731cc419faaf2e3953752b721643a836a468bb1916bf3d7426e77b40b2f2c3f772256a44bc6fd3e9409f803fe1e62f1cb2101e72ab72eb72b0ef09e5493d930998fde084f80907e80c9003f057ed8ffc90ff99d03619076971ceb1e0539812add6e0321c00bf00b49ca8db835637b92c28aee8b278003b709c82fad906e57bcc93a96ef7d2d2404790e3c11ea8f2d7a7037d72937a1276439323f6c14b2d3cad625114b436459c7361e40006015c503a0fa75dc7e0ed875e08365bc99089446e545a5f637980a589c1e3aa27e5bb8915320205d1582ea59ee24c4792f5577633d9c49c122e12d557f986eea75bafc2989532cc4d75280f869d428c1ad85180416049c0580391d71593a6fe0c069a57f3578778dffe36223eff6b6128f80dccc0602c7d10038bccb495747ff0df68f8d6f3d5da12d7615c0fbf2c8d2eb15b2db4cd47883321fe7a344bd4f4702c2877cb19214c1e22842fe5f67b4553b1ac3b0a6d5b21a87fda929d25ce8688c16c18845ad18cde5b05fd179d29793262915bc1dda91cc79276045f288da870438bee3b2f417808e0e136eb551f3c0727dc4ed5a119935649558d578b0c7785d687481f3e939ef381bcc5432410b6076638056b746f02a14fbf5bcbff38b994273dc8706fa0751137bfb5d69b073ddb371936def925789762e80d37af276765a5cc70436228e05979e753923a6982af0784d1cf6217477564f3b183dc43e973748b26b73ef85cbeea4dbc2310a46b3b3027a6b1286b293750da78cfbdb9cd5fd093cd2d9f62a40ca4acdc33999f473ff59ec297b90272887f88800acaf376d7ee18e7b95ef1d8e2890cd708d27f97bfcb1407d89f77dbd9d0e17bb87a839297ee824f53fbbde5a939d928940b64473ea0e5ee4fbcd60b6802fd4a35150a80e414247038163cfd164c19dea093831ae3c9b69acbbe4310cd1d365df523fd99ad4b2333aab06b16929457795c22eac8bfab16673d7d4dadedbb4be0f314e38381f962a7de12f4f2fc7e17b5790880d13b0e6753953f850c5fd200d284bf376f05dca33a284897e1a49a40ec1c21a7436a8b4848491ac2f775d20ebcddbd797ca3937f281817863f65be20a4c67df62d865718c465644c50332f574fdfa741880ae4303c3b2825506e02a6caccb1cb90e823cd1ed503095c75783961407dcc3576ea663dedbc1616c7bddbaafde825b51aafc8a2498d1faf84c051b80c84653eee7f6ff5a62da062c3144de4349e92d56dac563db7c40c0e10320eee819748d4af0c9f9da9aaf8f18ee0d37e04d97333bab5fc11ce157d03384a1f40f89d90dd9ee0cf86d504d6177e12cc5e0f28d21b028cf14a00c6156eef48b417e32e5deaf32bb91abaded7fadbd1c848059850bb40cf620b226eda1304ace54ff0773d07a11e3e473ec2f8ac11a38e261e2731d77dcfc8a208a03e1780ae2bae31eb752bd9868ca5af2013e95ef59e7a1462c612f04d8801e351cdd4175f1aed978cb246cfbf47ab2486823636d8f5d16b52b13af2f83c9b81037876fdd3aefa08ef1df69212e4bd45eae38b2696742348526ad8fd279a69aa20dfca33a119bd14f462a5c18950a8e6e286e21731b54e8244083391fbc4a8184db67fc3c1c93f6e649d32042d67a69e902717538cb26862f0e5e5d426f34a977148495a3922b51ff2df1089c8d2c53c1c33e869c164498c2c3cd0e30a3774bb8543e61f130afbd392ac9293251879eed607e622039225dd311e52bf5f0027379e02c6fb521a8edf7cea9712b48a98ee3cb0450de3391d49e34a7b8366acf5ff0efc124776181a00b0a877ed70f6456603c040ab1540c8d9d1b681a39f2533a1bad42e06c45146086d2d20bf26faa962d31c78f6f1526c63989d84c3f7466457040eff1044427fd7bd14990477d6368b44fd5ae6bd559018ef55c8825cf90dd9f73142c894eac9dbe6f8a83c2e785c85a0a11474d8ed6c4ec0a13c614c8811ddade9284a9535524c1778cf4093cf3cbf1312be9cf6538c2b43e76ce759fdde7c34a3b8bb3f1fdf410b7e63bfeb9c8e5b6c0559c425243a0c70e8c336c55fe16fe0648f6e12c9abb0a225ae1203104bb814ec51f9c3b1861be88e5808b39e3ddff51c3a2af07dc1e1f424c4e6ebc462bf960bb79a0ac4710598e5f5c3daed06cb0619e549b16dd9bbf550ad64162bee0208519e20df90921eee1741e989c1b78e416babfe629dc005d4d13b8cba465e1fa4c34e46680766fbc2912db6d6e28b42b49b798a4e4d62759647b6db41d6ef208d51c2edcd325f46c97658a9a7c57bb85ee440243c5d1ad227e7db3b38d53865ea7e69584adecedb972c90d1f608d395ac9a5559366b625fa94b8dea0ae879a330cfd64d5fe76e59339936e0bb9c02190c83ba4dd43d2a71663adf86a4de0b53f50c37537bd3753a5825bd3dbe39fe7034364aabd270ea455bbbccaceb40a34c51aec3d021357778fc249327d27a34e8a406ce9ff63c537091df27c5e59e3c9558f7363e33c3e2b4597659e64363806271eee84bc911bd7334e0d0d5bc3db1adcb6c4a03d9cb463f1f67a73d1d7ec535f6270f6744b8cd9004be514cdc94a5b45f1764bf2c27ca51e77dad225bf2cbdeed7b29040c136a5cfa11d21377d4e0e1ff11aaed48d0b5c605a51546640a1798339b6d32229ee9b6870fa0d3b29406e8fc5c9e0dd110d81b52331a45855181006b7bccb5cacd363944b1464663d4bd1ac2096f222895aa15c35b1e418fe7f42bf169237afc4c548b7294c3f8b2ab5bef41e3864e0f6b3bbd930174387434fb6011fb13f1ea36cc1fe83b832c553d0f6dccf1d7b52fb894d2c7ff3c3be5b802579f8f8180621f6c72529dd54c94c90efe0ea0528294b15669b14fb96c803239b5e26c24ca20f2d332988a958b67a3efc060d0811c3e29e17176a49e9b7f7420d9fdfa257fe2449c8791441c5250e16dc02d5c20911e6c5d484c2547065f25a10e7db18dee57449a3115bbaccbb9341da699aa9f57462a1744d4cf1ce1d3a3d0270abadfecf0ec5634bf6d9dd0de2c8dba860bebe6f19305e76abefd8eea01a081997bd6ca1256be926433991eaedc6d9b2bbe0c9d7c2533454124517e44a8390c156f8a578f3124f30f42fe252f2e0e14e021ce964147da78e9bb58187065cd1ba75f91d5cad79452f80a2ea0f5abf192d1c21976e88929c6711f3f8498dd7fe34f3a3af9e94ba3f2e2d6450010b12dadeb71cd26d4ed31860db36797f55412ea887936dcf028647bb836ebd38bd75a8da84b78ee9afbbdd1647ae382b858c4eb9860a6bfd34d3479c517781ec4adc43076adea1799ffc61891d509548f68ca2396bb35816fd371eaf9458e90f3c636481fcc972f8642464ade3ef6fe1a1284a1933b881afcc389c94431490bcb69271d4726654f64958f5fe31fcc66b1ab4044ca36a329262d453328c4efc6c65fcf4e3919dc7040b438dae7da279f959ac4a404387f8a2280d61629081bde432d9b8975b2dfb813d7da3dd55dacc973d9b4bb9dca5a78a34a07206ca96d4b6ac2bf764741e6a92a5dd27d5373dc0ac54fa5cd694417371418de619c6a583de7eda26df1bb1b9eb615292fc56f7891f02cfc07910799703ba8096bb1ed6d968b0f2285c6a8a32c5c1e8ac36e5dfc6ec87eb8837994286d7a80fbac091dfc59463de57b52c1529860074a28c71e9726e7ee59c720551cacbac5d7808b48dc91e3a9d0ed8ee4a0ae0e22a09f4ff9e9208de7c68890c70b0fd759237bf8ef91c13185fbf5d48cf48fe089203e7e53308abd4dd5bf07514b68be7b4dabaa9b56e000389162760cb4e05f0fd218badcc224b99cb5161784b395fc8268e7554ebaff543e66a7e892dc6076f3164fb834fd0d6a15df47b58953ac16c8d53420cc884351812a2e544f45edbe31e19464769215572cba926e25df6baaa19ef9ea4f1914e9131a537489e936701fa6bcae89ae08c03da2c2ea26b90d9f3236b1eadb807794c1090cd43133149453539045b6e39347b7dcaf303a5324d1cb9c283faa9525c8d69fedf2b542aaafdf3f1112a2a5171a9624646b1988e1ab0b5664408a71cbf1830e825987cb7ae9f919046ba858e5554bed4c9b0141fac6715b1102be1f0c54fe56666d3b4b398f95752bb90718fc7a302669e09bb318ad6e0d0ebec14e473a9ffc76a3e1282eee05f425e5873024a98b20ea9a9cc6c6b83950728f2d1862bca12f73944b4e75b47ca6b6f253314e91058c5318287b75c483215f69a528444bc7ec8e2fc7cc968392e354765d03a4dfeb11fd3c8cc63607d5500a58af7ac938e3c205b845f2e76270c1f2b6dd86ccb2b8ba1a90ba86ba9514ae5acb22113c32edd8a0c5883445b3828b10c825b73cd147512521db9daa9a8f03f19cfd935d2985ebcf96889a47acfab26c3d87cae9e3650818c301e9ed8b16da27fb7064bc9ba825920396f1fa685399cadc48ba70915048f5f07451f415465ff43ed3b298a5b79048151a28ba534c3b0d71b13b39041414e0466e9a0906c657c409f4088620991ac6dc8b206836306ddb82b1ad1fc753db1361dcbb0f63b7cf232f17580ea4de06e7b0bf132832332b790911bf20cb6a73192996b75d088e665c77db4280bbc1efce105818d46a9cdf8828c80959e13f39f32eb76b56e7b382e47936432f5fc1ed7f0fb21864e3c748779b45bd1dd46aea2703f1f3ff621c9baf6c681e43eb08bb110f51af611ad5a2f203334a8cd9e8c452dfd2d6d1e2a3ec07e2f3dc45ecc6502f1b63f7b9817a212c7f37d830fe2c6f36318105da32edb69bb500c9db81acdcff2f318658edf213d0477a70f02e72b0270ac0a4ffce6c7424bcd55b17cfc478622d1ea02d44410fda5fc8eec97b8b05e5a30c9935429e980b31a3ebf0004dcf2ef3e663e706992d4009d25a9afe9d8ef5e79c3bbed5029460d32eb7b18f523ba1b79a659a7048a345d68ddac5abf4549c1031f1c05121d3c7d1fcbb851bbce4e303cc992c7acf8a4b0ba726771692ae930967903a1b944ca01e00d98737a3a6bc4875f05c4feb7d4f263f4d5ae4d940df8602b898a9c706f59320dae3391d927d2ba867f1afd4107143a3a64793ab30b832d6ccfa0fc5572a54ee6e63934b91dc6f69b21fed7e404e873bc65797ebab63c90e1adc50e7660343b52e2587b4a64341dfd59a3fe26ac6a0a72c690a65d79cfaa8782d527245ede48b2f25b03be3f89bb25426ca08ac43875b6a309425a36485566342d1449f8e2d303bd7eec9cca35573f50823159c4134456fec8ab07db2509665e26a5ad3118bad4d63deba0fdcb96d98d8b73d4ad55e6fcf91dab15be39a314706c0a5acfb9586bb4f600c9fcf8e24118bec467f69717fb75b2fad9d7f9420d6a2560c23bd985e97f28ad6a58cbb2ca620f4ca839cc4f6c9ce85cd7e4715b55d72b9551f61dcf88dc2ad4bccd4627efe75d1b0d3327e817f6da4b9b4678ef860cc58104a7963880f6d376aca6d0a18bcfe6cb6802d44a62644dd62414513795e84b2d0e79b4d7ae5a89d91a9ab8d4595388d84a1ac809c1fe5519207c153b62d562e837ef9e76eb16b6b50dc09c00f8e2bcc69ed403d445516947f49ca949ce28dd481c86f7b2a6274ccb9d04afeb11707d158ae865e8abf32c1087eefefca54e712c43c0add6d8783f0cc5d9716874ed2f991becfca14578fc491c53c46798c3a4ea7d7a1c8894e9268a9580738e3d34a7101880beab81670e36b6aab681ca7d4a30ec9ea6fd91de48c818d9778d525e0739929979abd3f0ed05c0c2d68b03b577fcff51708f62a100e90672b2910089b931e5db80217a874d0c381d02cf12993beef4578ed4faabcedce8a9ab7356862d480a6643119","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
