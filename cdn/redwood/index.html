<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3154cf1265420fd57bf0af5d73eb690b74f2b2de18da12edec72fd1e7bc3d5d8a0a9600c7f4c6b14cdf109e3456835b50001b2d6158883c0d99f527c37fd23770abfa36bc217383b0f3b3568481e08205a58491ae3ddc80ff551f07f856f2f4f253fdd24182177d2eb096dc5e0f142b9192e1d6cc13e54b27daf276b2f029db1c4dc5a15e1c1dcfa399828881f1920a2672cf86f377e9599b24df0c9a33b3b30da282d7fd03f298f8207b7a7b0f6026d1f7de54bd5ce7b55e1e49bb5961182255b82969343d63223dd7f7468a398cecd964edcf7db8c7a10b37ae9dbdc021016174f7d5da296487238979e560ad9927e58dc9c71c899c5c3a90a51dbc98f50304d639ea3377025e5ad8d7a437b976c091035b5a3a8a320474d151a4e45540dc978278c3bd37d00c1eb61e81d4ccc3370d960785aa55b1ff0d898487462b75bbd1dfdeb4b96d1debf5a68514fe9093de3dde24fca36244961df4004a7b5f7f0428a10ff7ef5a3b2a73c0109e4847f68b988fb1752e21be1ace8f493022a9023059e3d98eb683a45c7b8d3a27ba26846cb12e27c7bac8bc0b695629c5c256d4fb5f3d3fd00aeea266963330b9efbaf57fd06ca36d88bac2161ef4acf4da5d7252a9be5220d54f7482fb21278baf555cda1a26e22459641c2cfdaa8dd9bb987bdf3ae0efcee810b7a89ecdd5f49fdc160c1e3deb2ab74f323427718e87720e8e89479a1e8b0535d13c560027e25d1af155ee52e0737c55286bee00a3e1cd2189dc4e8422a6cb79f2cf6b236e2599def02a7bdb9b1bb60767c414addaf3ec8b2dbda280280df81bc738f3c9593a92b1d67b392cab3af10a3df0217dac2565645d1a45d3ff1de4faaa5e03079a2c1a555b9b0ecb140f235206e1a2bd74a6e1e60fe7659f910deab7a4d4d2fdbd65999b5e47393320a66c1efbcaa799afd2f945a444c985587102dd2968b25cd9b3e5cba164d96db98ece71da911cf8707907ce358694774e5b405bd38320d826cf2763c79aba81e2ba2326619fefdf78e77fa67783cef36917b64dcaa95e2ef49c1ba4b77b17b7c8cfe12b06595ed583425623a2e218c7ea7ca4eee839af990bf0588ff0c69cf1cbf1be60a2df3f82b738600a42426cc7ac8332c22b69505972bd558c144bbb04102443223c575d8deff64f9c88f325c21f5184e3e9f7dc1f5e96b7506c119af7da00a368183f4d6082142d6837bee3badaa9902f891d40dd8f259deabde153c9949f571e7cf9fb1f082dbaf8de3f68f6eec343ae3f82ccf30c8e045c20ff23114df89323b845af3d4247f35c3396a747a78724a3cc59cd284a9cccce6db9eb0d9434812938f47cd1cbc67c984ae13b65296f855f38389af5f87b0e4780b5eb2d03cb7eb60ab096bfb8e988b230fbaa38165661ec618bf1471a2d42714ceafc2138eab5a984d8e2bcb13a44f00ad1885501cae7c77487c244398874c9d5863812a4580b21cd0c490c338e1f017f36193f7e9f328e10d3f7ce1792b4ce03c01dc14d642fbb232f92f14d968d3cd72a3f4871b509417e86757b6bb789defa6a59313ca78b8f04a81657a2b3e1fbf913497cf63327dfeb0df29892bfd98856cfe9670935dfecdd53e47bb2aff3410680974b8db1c66bbae0b321f4635957d97ee35aabcaf89452c36b73271119be89110e5647d10ef24283fcde0e774a465985a50c8d883edc21245d56d75def61ab000a30dcf64c987b2e03f8056de2277856161f26bbd746c2830f3d04fcb391eb3d6f7d2fa481369a25432dc708c4df2dc0df69cdbb7a83a3e7d08a5c9f67ff8df5bd7ba7b68964174bfeb015bd9efc945ceb0098bb86388e1343ca8b6cce175c6226a955cc57e73c98cee555b8a3145da1ab7f80d552b5217dc9fdfe114fbf9801bf32178d62fe0944e3ca3d040fc0ad15384df995439be232ef54eb559a7eb4e919c385de7fd26371c513cba4cb1366a915553621cba5d5a897d8e8ca820c73f8fe24f6241b02cde25bec61dc89d1d82297f411d1c089839cfaf21940657676852ee5872a0f0dc334e2a49a07b53c1b1c69731473ff3e528f8b4f659afd2c2feec3560c3764b76c6321d2e8dba856c75ea3e2489b53f454868d65f89a80d56033eb6a5860be357f91ee5cdae57110588f8c0572ab0585993ff25863a64b7403750bafa3610da3db92f44684c047babcda5b53db66be91a500581ab8f3abe42d0315d7b6de90df836eecd87502ae9f6df58c29297027bbac1593ffabe0ae3fd4ef15a643e00fd4690d582f0ed9c7fdd07b89f88391f762a0df6c72528a0addecff80541a5e1042c18358f9978ddfd254d18a986da32a41b2ae460ee303400eb2b7c8d89b9efa3e29c3c51e2d8fe76f086b21cfc9ccecfd19eeb9813bff8589ab0523ee93b7c0f09c08645e62a562baf17a741b497ba47807931dd0a3e94dcc43d85c02f6a6b868e10a0e513a649a801b0ad8425f7db80ccdf6faddbc20e6e32adbdbbff61ff9f4791b0307c5cdbf1d135601c52214c31ff69669105d5335aedec7c1c7b513d953a79350b7d84a16cb6608739f7d0d371ee232279eb312011e3b9db856d8cfc7502d6d6cb7856d37f9a5c9a1470e163a3df2af10dd0dfe9752e5a2f8baca937e2c6ac1f1611b6fd27b96718b90b9978ed732cf1194cf88d83ee9d1f74ee42c7f53644f414fdaba870a59ba630b4bf81b676c3594c805bcf8f43e2c4e94467561cd7ab9f7676913a785f9858e665e9f0dcc4c8ca55547802c391534bc7c383c0741fa22c19e68708f32e4a0f5c628ab2f155b9a68d4da4bc4cffb3044b3a02885736f22d582d2c47eb4cff4fb9da60c41139ba3ef59dac92862b98458b25d7f0f044fdb88b12f7102db1d63493e7bd526b64a20bc59d1ca304a71818c02c553b916a60ded2fa085d9899174931b3582a22ea85b0e274cd40ff98bc5c2302dfc67ce282a50d366ab810e506a7aa679c3db4abd109368c80816830ddd27ca577d9b8da319e91adb2cf29a6ee3cf23028813be7e060ed498b8d0da500c7c3ff2807ded1d8bf318bea584a83d04f03cd2371349cb9262237d6398c0fc30d78cb186c301a89bcd26b823189db9d9025fe82c45e01d77621d76a64092307f06c2f2cd243a9300bb4b02e38ca3e3a5899ddf8b3841f11d3b861a1cdd5fbfae1a359fcb056befd0ab1d3bb7551b6efc2663fe676addbb0e2dbbf38026ea66f79b58af2220c2b3b28560c0f49be053c7f86bce303ceb74b39eebb382ec4bace6de2780c035ea3d305dec17b94672724e526341734b76d7193d056799e2ba223da16c1c5085831bd124b28221f471ed41a89dabd1e2d50adee32370420c96c2057167c16bb7602f85ac9a0c8da586fd34495da061365be664fc08b59df2865378651dda0ad466610fe95b2e675a4e8e8446ff13da5764a11927b5d44c8d0aff3e50f2a89c8c241d2c8a173e801f7622cd34cc115bceed5df5817e3012b448771970b00d1143da4eea930df284d5605711531806f288c2d656f74976464d089b8912a08000148886e454f0d91d9eb6b9cc12c6ef3069bc44249c825488158e26a112e6ad14477b39a953fc5fdcdfcdde8cdb61a3ba3f8a326cb6f63a5b0ef93c5c62b1dcfe34faebbe3c969792d7168884b2e66134b3867e2df4b926dd5204988b5c78b5fc0262e94a2d67c013592e5295910b4659dbfb9276bb29f50f807d7f5bf32c8084d1fefa1a6b2f877c03b032cb6d269ffcecb9fbcdb9a1daa4f9e88ac7333bc48cb13231b4daad52befa87abc1eef6663a3503ba5468246fd826ad922b94540f95dddbfb2c4d8db0349411d1944cac5b115aa1b2f72f727c057680f942dfbb31a1971b4bf552331d71539cd1c6163c14c5d4b4696f562827958e5796a9bc85cecd4a9bba83f1e9fecd65461a7e01944cb958b6b46e4bc1ecd5c0a921f86dfab21957d7fd9a41d8ecf5f305013fe62b32e90c8a3b3b309c49a8803492e58616c18dd6a1109b1e7c191f3ad081595479e900b7554342acf4d5cce87134cb6e01a6dc4f1949b338ef5734d3b2c11726f7f8cce5f52da8418cf14fc1304aa47c51f3b3217e0d365dcd6256821687c7e0d8d56695fc93d88029758cca3317731e6ed520979635ae137eac6a2257a8a0e7d02185e92b9371aa059f9d29876821ba875336510b48bb8350d546ac4ca2bdae63945cfa70ff889d748b8c29567f6709aad06df20fc76d6ff12114ee1809f47b43536732f1fe090c021a6cdccaefbb92adca37db8016d29c047b247652aa171e001b03100a3b68fa61a43f71fca2629f4a35f0defad491171ec28029d7b8f9abb82e7c271ad5604dad66382c1b2bf5a65c2baf261757af7fb3e09c54a6928663adc7547cac9029550687f92fd64ed2b57a0fd109d20630e8ce4b6217e5395732ba737205761619198f57dbd3633805b7eeb026d33869455e2f080ee28ea336a980ef304b8b11d691ee3b8de34b0018f8b529ed3a2cefd8a562cf4eaf748226f4c91e7fb3f76a6d0b5edb774c35832be5d3bb6a97daa69894f0430928dbe21b49f5342922f8946e21349934c350d4ab600ae28a7f5a1b3ab447b5b3a8006b3c61b234d08723d0d156a7bbc6ebc2e46465214a5907a8f847658c1c8c523d693fa7adf2f1d9fa22c07333255b7bcf2f9892bc686f7f4d1d99cf55214a0036da62dfb2a8cbce97b32482f4b077ffaecdd428f947f3bafcbeaa508ced31002f9226a80acb600895a784945e45465e467256e9d3397c76b720e9a635777d8dca0330018bedf0f1dbd263d4d468d4674df303471ef7c217732aa21701146553cd9cf3363a49eddf32b2b4e11f82c381c14ea1fc27dbe27a5914f55c8fc8fdd6d901a91d43e8859baa125ada1aca39d3cd668d02deb2143fd21fb7460a93c0277abb17f76f4ce960609b067e7c9c3554e13c71be0b6370861c2e5005815ea5ab4b0d4ff38f2c29eca0fb071ad0588b59f00ab1101ae45390b0e54737d2dcdc8bea11c5aff3ac9acd7ffa6ebc76414602af10d7f8ce5c0d2e617a893bb1cd13c8fa2854e3cb4bc28a8a8e12e665d638dacb618b9dd81ab64a58b84c965a2bda0e8e6ef9a1c87be25962e1033284ff48d185ae339575fb4dabc7bfc57eb540b9296a2ffa767ecf5a21f1033e8decb352cf77e39c831cc16d2fd2e660b4248e46ff122830f950b21669ed42cc6914e983f10eb90dadb83ac23c70abcbdfb4259f5361a12c2132e8c0c6508f4155c7cde3839e45982677e383c53ce06e3685aa1a084bc120bd2c55d86b2fbf16231dffe22b7bbc73fab55fd9bd5a58dc5742c929bf3996a2e3cd5ebaabcfecb4cf31a112cd86b1ed37eb3056e280a451be5de9937e0960cddbe3e400234992056b210194b978b0b9a4ae889be72f5f7fae05f67828a15c11f212eb713e7032085dd3e83601d72dde5f060ca11f837d2ea8c155b74fe2fd2728f9eb06fe90b1eef424b88ff4ed25bcda126ac7271fd4aba4e29fb590ef940b466e36088fa11777dbf6e374a5c35c97071b95d0e5e11bd1844b9cd391ed223fc633b5614c0e267694f46f347b4c14ba40e405d83c8af96fb2014e6f055f4cb99b92f08f69ef56ae236d0384a1591c755d004100d617913bbb48a8772c40648ebd770a3391f27dcb9ff9abc00545e72bf76d171f026dc35e85eac5ea1d90898791fc8775c314c885fb21907a11dcda00af536291d98976eb3082eb4b65d94aa2d4651502682c37a6ce1823a2feab954d4add65f79e46b4e6918cb5c839277aa7b5c4e602d17b92ed57115845c7510b842eebf61b435945ebb233cf783348517b81a59294ee7b1e8d292e25e95b239f29d628f309dc48c488904a58e4722356ae7b1b1f12af8871deb59aae6e02b57847a79974876653cfeffeb851d657c320c07161eeef22c46f19d253aa760909c79bb8bdb213d4fc04637e7f40ebb05c90ee720b261bf629c697bd9e93f6710ac3c7d48290ac1e42cf7ee9e3e62e51e4a2bd4d32186823ada80abc333903747a991dd3df6d8378e2a8e45c26ff6ef28950ef7b695e9656665c300c204240d194df6409d4f2b3d00540cc98d11d718352b04c09c49b69aec7f7d112a8238d9892e712c002a2b452c8dbcd7e3b93298cc1131e3e2568ccee7defebfa74a0b1a8bfbd42d140146a284fda9f6b7881536deae46ac988f9f0d1d20a4e4893bfed0e27e671afbd61aa792ded997f9acf15fe36e70572f77b7a0f57a2701b653376189d0a68ac9df52eb6c70b25ab71f335e4d4cdd9773233742276a6dbb735f6f83d8831227a6759c64c34ad723e17410d244225e2c5ae4abfd57b81d5881f6c315146c729e1c9df0c0ccdd2081bd47cf80e0ae90771ff2d87587c266b4945501eb77823936bb3ac2da606f16c3da0ee573502c3cc0ab14afb5ac459d00e057f4abe9dfa09d5cc2fbd8f0dfb0188115f915d2efeffa9b7d26f9b75c5e64f6aae3916741c4127dfb02dea0973ff3059c1dc695cadb8bd95256c29884663d52d00cde173a7fbf68bbdc6ad6db29c9530f7f7c566ece9530353dc81cbade1aabadb785e8cf83ade8e0ef7737c791c01a921945259b63758e02268f24f51b204f136243e6bff2855eff0273799789fa7e1041b6cbdbc2e8534f94c878d46cb36e0ac7565fcf07c7cecf37ae0a8ca65586abf8df6deda152c9a0ef29bc68ff4301e03a061c46631810ebbc2f43c6a2b002ab68ebab876c2359f3310903c2d18a639281019ca992e3ce6a8b4e5b02a1d34c9e83d705ae8b6087511fd244388658268032671642248fa443819767650726c7aa01d5beb2808216c2fa6950c14a99dca2a1440fed9296a4c53f1567cd73efd60e11cee3e116c093ad9ef527e37a774034a57336f011db37af52d13e278b564d79aa97524d6333c279c1b824e6c4ddf18166a4ab4ae88bfc016cd4c151cbf4964763833c91a98b0ee3b6108f21e143356204b41c5ddb05bbc78cf90186952f22225e6d3883ab76308e452fdfb05693728acf24a10059b587b298b99f42a8e219a01549b064df797042f38df32742c1ac530c04fd20a27adcb5aba577ea17a903a16b19941215baf2c08fe3038d5447375c8971272df62ef7ca5930bec9748795a9bd7f41774a97cee09a04b60d5e7e017979b379032a7476f43d79f4b1229d6ea87909e4ead6765e393b6fa094d5c7ba52b0a67d0b5e949d73d5ce1487f808b999482709d01d42f6a97499ee6afccd20f71c860a5f5511cc8225f96da6d6663dfa332957df6834936866495c7ba7412c3109c637a9a540f5d059c6ca7545fc292b5be3b0302191fcfa5add6b9e49a22acd213681e6f4718b52bde24014a16ab438566739f6da62a88614a223f6d28e4afe27f04c03a92c456d6cd9da24dc28bd7061ffcad1f9e4f76200a9846cbc890fcb29fdc74ee54047688f11ec50ab20332a9391e345a5a45a1990382279af08acd37f938c22088a896ee28fbc8c76cc602b366fae31764f6dc0be8803f7b1b18ca97feb880defb4d0a9ca7ad7c1d0e09390d512587c6964abe6f303c9647785c10d303da55a568034208d15a8516796650956facf0b54bc00676a5d4f2b6657a22d10c68dbef3a367caac326964cdcec36f6478ef0a3fa389f7ecff7f755dc6338b184ddade540da70d40f05a5579c309d297479700a4e3b1b4087be5bf2dd7fa627ca8ec732bbde888e54b783927600242268f16047c972540df24d7e2fa63959f5818829b9658b7f944489bc1c8c574685b2416a4fb4dc85ab7cd591758a30ef5b286dd9d341bbd84b647c36c703f3d8979f2c08c57f000240113e43b70543a156c44b2777584f06aee0bbbdb176bdee1088a2b5aee2fdc8ab0c0aa0ca70a2e109069da2dedef79715b9e67e1c0aa23e4f22cebbff3a8d9f268f2a3d68e83fc66d168c490d36692f9779fe2e3c33ddac960b4fa96f3f842cfcaa102b176406c2fb2443665b580ca4e30a3d887438f0fb1b220fee0ed66031742f47f4bd6cc6dc570810559b09c45355c1d03665c3a19e936f82a81e8324937317b680c391c61bc4b689b7bc55568a14984e3c9c0eb585fe11a8efabd34560a0696f26194207eeb6e2fd3e83e962f265048b442160bba300ef8814d7d80b539304bf524bebab218cbeceb188a303d69c815ce144d0de64d1574f8bc5ec2c067c0796d81607c2090027a0dc706c4f3e6c82f493a2bfe56799bc3f05e2158896bec535f1c6cde5d3f04a7e0e1f349755e8ebc0f100efea0f77d05a53be642275f9257fda738b9e1cc35de15316ff2f8b4e6f72dacfe27f169a6985b6f8bf6875bc8736561900012b89e3971c1ace1d612834a974e2012090b0a609c8fa5dd42ae4abaab0e9ae86b0483f268fad149bda0282efe11e30a499ee5e1aecf5c6ce9008390dc638de3718c009b1c50a1fc6d5b0e806850238a3feb1c334c57b8f4a978085dfc1c90d204b5210b0cc4d093f69b5e1ca2b904823a387ea434a46b4981905671d36829ba1537d24a14424bbd4f5c1e80713dd0b9ffe37da7cf611a1b1512d31d72c594b09f323c1be55568cb9440fbd7748e048381076e11e8d1470a2dc8307afd1a11f706f7593ce4bc7e668ba314996a4061d64c968a29f29d635dbcbc39d0980de994b8eb6a8b1944229b3131d7de6476e184edd2d93d4f9a57d778f5b3b6784cacc2736e52254f405c541c1d7905acc28c8cd27c69189453ddf95ad7610a0ead419c5f8a8314162278ca3572dadd3c68b970fb87411390025be1dfcd783d614849138581c689615c5a07fcc514293a246d75c014f6804a94d19f99915a582019ebe1bf133bd7b0b2059b9c421ccfc93839c24edaa4203704f504385bc681164a2281012a8dacfcef052e9923dda3fb07256a849972219474a63825f37bd864f62914b39260b4412b4dbb73e64fc70219ddeaaf9c66549f57b801e1b1a0ba9b1075d62b78cf42c947ca98159cef398fa9429c0c243c350b7d6dade9a2b3c448d98a31da67dc8cc8c5991974f659d67bd3bc4c6e01ccfc623d64abda29bbe8846e573a59acd2460c617fda7b34cd92a51dff220fea21c6066e81b8c3bd4347554e6647f5a33f053608dab89adee5e9fbdce91fa84258f71bad81d166c365c8a3728a9d59e1abf37a89ac7409581a5429de529537c1555815dcbbf32bd7ec88bcd4f660eb6fa78d01aa807711acb605eb99f955433db610c2ec6a1934777af96bac93bb198bee464813c36edeb4cedd9eb4cd090232f23f144dc57270ac3f693ec626fe9561bfe3a6e76aea4ab7e2c5e2e9fabbcda1a742e12b9b762b03b4cd04b1f3a16947b29484b35f8140c78873b2dfdb5e27a44d1932d95518a077157f6ada7e2ce9ef18cddfcc0ecbf716973ea3a3f991289ad177d03837e9cadc04c6ecfe3978a61d2e0ccaa4ee70bd2d1862eda365dc9eed5e3428155a3471f5d81f9eeb524ebadee1eba252533c6e972b52ac0001650286c397f68cafcb7e243895454921c9a6204056d5d139d5a75068020986b53de9256850283c8779c15f3d09c3b08304d0ec2083e463269096b3c488345412713182ad6a4a825e569ec1e62d2e6862499410a5946cbde36d27e4f3f0ced3dade72e53070c88e1bbed8cc220b889bad470311f376635705ff063a17656bb5629a76f51edc306b82df172660fd952d93ad98603e0cf99450792a7a323a937659a9885873706b28444f0975a54fbeb98b0db7405add3ca06049d0c79ac42fb5cfdd9fa3860605ef9db016c7958e6ef806cbb6f8cf95ca0fe5a6a5971f3c58bdb3cff4c0295ccb5e54c39beb57891cac3d0b08ac0bb0a22243f94e8743be5d58070e752fe97635b8cb07cd7d2b160cfb85465fc64189ec8caafa6d188ec82dbd9637087902d7c8640248d569946926f876bf3d40dda7ef1fac5d12cdd03facfff6f5f20f3227577833a4471bc33d060f1a208823382b2d892f2c6205896c4665c4d9c83db501a711b075aa418f0dbd6e0897cfc38549ee826546a8d7519b8b41d63509686b5979bc2642966518f6d7425ff8bc266f9d34229e1ff732614a4f5b26660d3aec55cde1197337323e5fa599fbbff49c13499be0b0606a60a1568ed14ed0de67acfd6d8de2b0c7eee0969e5530303d4672e2f7c5786d19d35fb77feca44695383ee92d6f847efed00c30668f880ca96382a02d5f7b3eaddeec2dd8fe6ff498c16e89ec6d9294eb9a1a459d5cec8c5b57155af1b1496cd85de218c38a94d400b08ebfeaf220750bf503a4d832224e29e9a35ee7d6ebdb990fefb20d74eeefdf893cecd5b9579c2f4e326666781e025c4c2f71c6cbb518d58e87375012d5a9e3fad0d80cb3137023299f80cb190b100d89ef9ccbf15716628da7af54065b80ed2c7fb312c28c2c4cd75f1c787f84faa5e4872bab7e15d50bccf792b0765172b94533d9ac6638720fc9a36b368cad52c77379eec913cc4a2cd995300b9f58d030c610088a01975051ccacf89b938c51bda0124f3c3835f34d7ed0c51163ecec8d2c6dca83e91cef6fa3a0e38e6f17ad1c8d0647905409f16a4f9613cd3b00a1a4ca7be26941efdd1625458858b2661201f057c5473db602d4c226b513ac9014508e542482726ab37e9b852e50d3f05d2fd69349bc4dd0206a8aeeba315cb003a7d9bc5ce7620095a0b04ef6e580d93b0f8650f97184984d96bd72b26afc82e219288c7dd4612a7ddc2e08976ab3c73582de3b3c0e12bc10cfd3a414c414f5fe6b42e50c90d825b74ea3bbddd2100898d77e2791a4ec67d545403c847d9008b25843cdf3e1a2324f2ef8a288539141eea8e8018810ef3a3f18600b99f750d04460c4bd62f478b394673958473ddf4753f1ec373da350513d234831f70714ce859dd7c54a942f8dac8899023f269d8a89fd1b075a2a14a62d0072f8ca7519333700fcfe0b2b85f77b81277199f278857735f8ef48fe18ff59e98ac86e8c3aa25b9ce7dbc50d8eef000b588792131ba29247c3ea547edbb0dbfbe6d5cd2d2c354796e3df8b840f60d3f58d16b5a996ed8a744d48a98fc144654eea2e368110090af6eb962f376123f9f0115164485e0aea1252ad481f06364beab6bef327db16ffe321075637226f0a9169ba3b76554eecfe7f242486a2c9c00d4ff9d621141657b3685487ca1cee1b760cc9da7348188ee227c9d0bbb8ed83ae7613f163fd5be10c7b92a4a934ff0e29e2fda74ed14404d3bafa06e2dcb075add9e5fb9c780ecc5aa7efb7169a1833fee1a30db4d07386bc6034e8f720b7eae400def69eb85a22e7fa22d2e030b9c1c11d63ef7a5aed16fad97b274514b5fc561f2de839870b53e565e8c902594188ceceef27091c8b6e1622a2012623ec877194a0703458a3d04883e5567e1eac5c1b241a9b037a062b1c0410af47b6550a4783c7128240e6a9c0611f16da3a6dc1a9b4ea8ad6ba10dfa7e195d6a891de2753154b1be62c8c402941101ebdf247eeb17b9dc0d7ea817166fda1411f17a0a2ebe1dc58fa612d8f1cd08d8406f7b69165a02788e3a10d3119e826c83013a6dc581dcedd5241cdc493b36ce96fb3cd2e233d6486bfefb2cf5f77c1c58608db4f1cf20c173be96ad08527124a1425d920a49aab73de5d992d1b673ec987cc93a8152a2577dffd61a765d2ea70c96666f7162697ca03d6e4bf75ac0b1e4581675eb95b43905fb153ade7022d3dd79145d85a5cc1f304758b1d487506d476bc88296ad8649e578eb25a3f319df87b6f44a98581cc11708141a4f6281840e8e8eaf21004a31f242a49a3a16c34d14f7bb776cfbc7888e3d3b8a5d148152a3f6dbffc22f2f1385e2117f358fdcbdf9df9551ca365acc08d906966edb40f788c0f8a63dc49c9275e0f00ba7b20785782d6a75069f7d73142c97179a6bb14479c0963af2ed32163a3b81a70171800f88eb5bf722629c5370faea5e11fb324440e4ad8d64b69d837aba45136c79bf2ed69de4c773ca241ea1fa1fe073f0ec5bfbae05f8cf96fe683ea4932367df831fe3f5e0f4ce17961fc4b2b63d19d4d736d4d4c8cb83bb09491e8fedf7a6dd4b90768a0cd58dc81dfb33ff6161ad2210916a3763ce64dad8f25476da4adcd0facee6b1c0aeec9415e412f33ba34e82c180dc39177cb10aadad2637a33671d5464b0efebea61d599df2dc0a6e234cdef48321eaad5451d6cdf5126c3eb95e15e7dd53c06ea518f7a82251ff0ebfcbf843b4f5807269588d57af8e9eadaaaf6bbc621cd1c79301883e773bad7f73f185c973a31374a7c22b0944b9912d9f35393357cebb82dee0b712e519ad2b05aac136e63373f7981fb6f5dfbf5a1ce2b6a2b150257e18b48a88b34e1cdf9dec3096870e91c5cf94d798178862f3a1fb41557acab910d9cd991ff7711dc36be1f23a1342108e6b52b5f142db8bde5d3bbba2f2376fa7a08d784c2ab44150a075517875448c7323a42234562b652dfe34c654b0ccf2c09786a83ffb8db2272735bf31622d8040e37f0b11dd77cd1fafa164f8e5089337cc967ab2d624a496e428b89873bd641496c9fe9dbe23f07efa4d6459e00103ccbd70d48fb71b08c380658371c83aacaf48deac9351c2fc79cf6f5ed3f02b6533362383d25021d314b6d6e7f379f8eea41c7646644096c042d28c1ebfd65c0394d0159fcde26836bfa6b4958d98a54c4ebb60e6594c61654aaebedf646b47f5a6851fa1950c8b377868d1ea1c38ca3d947a3f0282eed1f147a08ce6edaf92c9544422d0867ce6a64dbf0c4e83f51559f559b45469aae3e32f6b50523424dade42162709a1b45ad6fbe9f24742d14aa2d9f34aee45fd5eabc6225ed3487953a197613d34ce3d6e4ec95a76fec4ef1a0d9fe6d9ddd79626cae2df9d784c07b9dbf762d94d84593acae75b73d309954b8c79f5c5d88f8c29cbb2ded2940958cb0bad9bcb986032628bd06c7a49534052798e3992be43303e03033f4ba39af38b9b127fd4e341ced5bc8731c2d7ee0cdeb41521c1e7eea4dc390eb0e7d87cad2535aadd81e434848e71ba75ee70a6bca10d820a7c31c6affbd08eb8a516fbebe7e8d7b1e57541418bcbde5311505af07141fa8d2c3d4ee736c9bed2e2b17bf747b9a83896fd702cbe4295559a2f66f0a4e7412c90414e14db5a3567989deff5b52661a49e42dfe007a2a55d0d47789bd635e98c6ef7f0e191fa6e5b844ec18ca6676df488e77e436afd515f3764b5d5b7682049a4293161165d1072ebcb6e5b069e3afac35f8b3dd9fff5123060bd15d6663570659e7ddbaa762e2d9c70440e9c3d9e0c902091c8c375199aa73ce0bb1ddf74bb0944af7a404feccbe2688136627290c0fea2b86b5607ae6c3376e2954a65923874a5fc6cd40788b0f3eac4f13d241adbe3ca04fe59e9827d578306f0e1453a0468eba8e5899a569f3bef02f126e45ece05055de4544563843b236bc125509f99ea1297f1cb04e440ac4921fe3758a3b63789a238c130b3d82ee92c7b7577a070be6d3ca633989c2971c120d923151bf0ed8928302f08d05073149154a895a9f4c9f21a8f630016e8a23275e9bb86aced8b80a7739341f4ce58c2cf2ee11d31c6109ef9c69d9f3ccabf5eaaf7848b8c52bc4375babf1696d97352f26f2d5b95e69e10d0ce443e045d80afb4cb2004d09e61b34a2ebc413c837961cf44a63b332fc41c0bf282c172427db6155e44dfb095632cdb0f7b5f3b6a225de0b10ca0ac413e3eaff778febb55fdaf7a226650fecb6e714829f224275b558cbfdde049d15376d72837403090c8b66e324a798b20668e1473f8be977df8ee9c5371b837afba027c00394078f38ab109679f234f1225fddf595f7c21549a88a16a396fe2a7bb67ba0c12f262deea72e036b4b02e09edddc5fc041ecf0db8ba11548015025385e805e32e8cf91a18a462ebd9c6e5114571954dce9468856ad90c5db0c28b22acb86213482e6cb1b5b0da44cb647851f0f4e8330cc470f307d8b2a35531c381bd2a06d7843cd3bd000cb946af02121246f0fe2034c1ec8119e6990d2c35e09cba4d70df67964de784a0aef45f40b1e0efc99a3642c9006e4618a8cee661fefeedb103687633ddb03c2137f1cff77076d75d63d7529ccf31673844a20f09550da5f3b93234528d59e3ec1ead123c564905b5d12a94b77b050240d2eada6ef2e01aad097f8b7d2383dff97ebb83094298a2d617591a06faec93b1f7a67e857f843233b5d9bc84b8c43b2e8903d6670eee66599ae8a82f72b524cf20e1c29262f8eccc5dbbb03adb9029914ee6735a5e48d142bca5ca5b01d457a64e0cec1e0306436646e988101a8f67ef70fc5d1dea5d6d85aa99c5429918e3aca87190cfab0534354fd45fba34e6356dc3f8615138508d643253cab108e27bf69914e19cb88fe9eb755a322dc2e9a46b65c28f8bca3c436a3b9f0fc717ade6f15c6a75b104c5ecfd735e3de577109c718ddbc5c385bc656e4c60d76c92e6c8cc947d2592468732589d73c87b03a25f18dd29422b96c1663597420660f0b3e99a192dd716fa518507a6712fb600194be0cf1860a50548f2cdc0e1a040336d2caa29e9d48eb304d6dd5c8d1c449aba8a561c044801cc98d21202bbfa1b45c98cfc13acb4b884134dc28f3c1ad9ba0fd85d6363bd2f98374b1e6b231b2d03c725bf52e6063a9371ec98e2e8ffca0b1f4680ba6d3153a45abbabbc2d6b2538c879069be00ec353b85ed5cdef7737455d08d1e51445f1bcbea219d789ea026722786ef2aed65a2e734ddc936dd18a96238696285f3671d475c36fd503c52b44dd20e0e64fbb5f010dda1660ceeffbecee5ccdbd09080655b684e8c0e3772cd419da95fb7595d61b66f750c443bd88ec0c7e122ac65022b697fd37d4bb428df641c4c6ce136b4cf1145b371104205c22f016c632ec154e3fabe9d0001c328c9e983197017ec361b06b6b694025fd296efc0f5c356318a0e1fce6b270533dc5e545c69fe1f4b68bb6dc582e2f4a05ee5bfefb2d2d1520e3911969e0403843160071cc64fd4ed53917ea3bcf1fe3a020e43612b45c74e875e751e53a6cf4a4b4f0af2812f88fcd74c7b9334b0ad781c82caffe8cc5f6d8cca2945729fe3113043d1dfb88d2f228bddecc1bde1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
