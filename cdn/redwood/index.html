<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44c59c9af4d0ba0d0e26f040c19a150453a59fad125b9a4eb822a61ac4105968711f670df47ee71331e64d40acd601ff611dd18c71e110cc3c018599b0404c31f6aa2af1e067e3f5fc0bcd783a258cc351578d73bd286235a171ce909c4275aceba5485205c64e6dcd55cbd1bef484f406dea35ddebbe2a2bb4fe6a0649376753f7140a9f11cc2b1950af9511586c89093a4b6c228f5831186a6402c1df2379d2bdeadcfdd56bc90963e18847f97db3a9dacc856759ab36327ddcd89602776aa561e3a02d4be952bc48b61b9a13c25eadf390ca40b2b3315b510792dcb58b7709b5bef5843217163742036a2a24244abd4a698f115f2ca342bc16def2f91dd86147720becd8446ffb15ef867279637819a2451335daaf32952afea54ebb6a76c3f6b2e2f8c46e5361c2b50c8bc7deee490d438f2778f489c6e824bf5d58994e33fdfc22298a515a4c28c2c817cb366910113266f199520c7ddcae3d16904f83e6409428489452d80f18c6ee943b97f9b2ef21979fef083cb539100a3ad7d2d810bff882c3d58e114dac281c3468ae67e443aba3b72eab9897137a566fead3ee3ee50832c15a5fe190b66e79c9e0e203f224a70cccd084274db5ffaf411d270d2da95eaf3d499f5ec5c7165880e422218139e9b8a10c8a12287248b73dab3881d90a5c877059dc310765d880599b9287be96e889fe33d986d8f07fb0058b827a53c98cc78b3dd4bf5bc73c05dbf534579948c5158bd7dde2520c6b5350da06bbe0069bb21fba2ca42f4194c135f8c91f7f75644ac119ddef9e1b6c27bfba61264a25aef2216a3552fb9ac4e14803962baf07c2d0862f0370e75614aa0076716a24b533dc5f809b784c1cd2c3e8304bacef04c764ed49b9242da283a8fc141cb354ca456459f66f35b75748ed92a54d24cde50eef7b75e067cc9cf531c3f5a7573a58b4c673605f5a089c29048dc27ef8e77ea0df703ab4db025907dba894b79c04aa5d243ddfdda6e08a834130a7160b4db166f0935fd9a2a3e7bb541347cdcb777af6f197a548d9262f4c9d07b7927f696b911aa5c7cd8972b669960ec9136adb1fe3fec0fa20c6ca14942082c2397e56ffbc6dcee496af0bb4c3cfc1e3da0be2830788defa7a11ea566b73a3417144f1425e80076290d7c6cee441c869552e4f9e6b4cc205d64ab6e95e1a01338e02a1c8f00f083b7b9ad4c9fd88e18999317358ac10e99ae603fc8dcd3508bd982b5ec3dae5450918ecfe3c8fbfc1c4df65089e38384a9ae48a18a56f6d6d5b66845f8ab09cfe5f4e7b1fa0117bdd58e28efab93259d3594e6fc1839d134e29d1e545579c4758be63238bb70e19327576eadf1597b8edba9955e27dfeb8e8d0e3223abfc552df7a6dc55277690a1278ec33e8a1d1d6b849e5f7ab058f925db4987e9b4b68e142b5e3fe1fa5e677389f2a753d0d625bf0e42436a21a9d7ff9de45f4fd373e2f0efb631039eb43b9c7da9736857a740f9f82af2d946756bb12169ddf417dc41a8b7f48b88e11655e9662a7c5a2710d808c57068f59e547ea086d31e43d2bf26df1bbd19273bfeae971054961d656f0962c530e82d3400f9f227f487dccd708796a7e8dd529466f943056aea7f80c2510fc49f0e46e7e940483fb74170d31ed0c3be3947d755682cfdc1a3a9bc6a2578665722bddde115b40c94c0c05b326c7b8f9cbd6d53202bd7e7923ae9768bbec309d33fc838b2f381e2b1e0a74d97b30d86196767a6cd8d872d356a731ffe6a9029d00057998543a8a260845151da413b180f05ff1007ccb12ff7c2a0ccda03229e99de7b2526ec9ed5aed1cbfc178e9a4cdecbe96ea3d60f3ead1a10fa6634ad77c69c4ec63e41176317e06e4161d4306f20fd1b362695a127b8d19f89f2517261ee2b0c62a1dd82165a946605644501e14a4aff9c98f3c873dd1570a15d51a3376c251fb614f70cfcff9711455a8890f37a69d55262fed6633a9f32b46d75b1aa51f879bf43a5ec9e969bd81fbc9c395fef47cd51746e89597fd8269ecc70b7183984d2156b0aa80be35c2ec751aafab7204303cbbc667a9b6a4dfe372d69cc835b3d8acb83483540e7466d7d2dbed0ae5f6a5705378a6c640aaecb43d918a375702fc2a8eee519568577c77bc6ad692781a77d697b2b2b7ab14133d076fa9bf92a34c83a9e0e1255dddf7d0dd0c7f6cde99bcb60cd3f9c9a95a86bd4ac233d9f074a517dac54c5590cc7a0456c8936dd5cb05b8fac1f91b452764dcae96f1598dbd3caa765a1850b3ef333ab857c082abb458b0203692d4b367c28798cc4035bb719d74a012623b6cecfc0f8ea6a3f88ee2b622ef384faf654e18e5079914f6dad2a340d17c4e3f8210e474b31d0993ce149a448137aa02816001c2e81d5ee194bd97681fc25f2204b9f5021bfc400ea62c476d9bba47e81144e05564767ac9ebfd1f826da0a9a1f03c27e350c793c7d50dc22033992c325d0df4d0464343b38139ff5b81fd808b7620ecc88b6d76e079ccf6b708d8044abd94c507f860d4faa93fa7b9d428b075deea0255616775c431708c4e0cee56cdc9afcfee4dfb22832118bdd83bf322991e35b66d568ae4d72960122ad5b24e153b864a067b2c78e7dca07c2761845e0d9608e6621de863874e662dc918affda6709c9b68905192bcf685bdab29c19180c6c630d5c3bccc285c89931e2bdc88df08789438f60fefb3dd20d9e84a6b8434639b96f54e9f23ef0e2fc3f5ae69356f5bc00c6248c537752c40941c088c2d4d33b11154f140e8b0b8bab66a59d7daf12565bcab58346c0b5ff181f9fbca4de1246544a90b236987fb6bb8afef586f3d8392183b3f75855c90cd817c1018f90a3261d834e70c8b135089a3edebaa3dffc429909cd652bdc9aba878c7b3201833a8458f83a3a4c9c153698c96c65931b92df3dab5d2b91984d2fce6bcb5268aaec55bb19cbc4dc5e335721b84c1d1195b6e3d7dfd7e545460b5dfa46230f0b5d33b067a3a1857f9bcdea8e4d845971a2ce9f9c2ee17f6fc0a21a16b43c8d49bfe41e0e6e50f29707d032fef911181c311020cd8d01f0a07669f47e9668760e8780212116e5a31dfc9f1ce889f2ff24cebde5297618d78c44b38e95242bab8c96e2c8eee844a2f9526ce3ac6b029e9b09d097e4624c0e1a700ed5ee0e93005b46c6a6710424a7a0bc6818fbc96000c6175392efaf9d642ae263405835d48d76dd790620936c7fce8e54893c913139b7667a47b09017a17510c96d220566e643983a2cd6416506aba8a550a9c641ae39476a398d2983b9bf164f8eeeed8f6593bdc9cf7161b3faf4388a61eb0e840790875a823c65e904806e63483bb0e8cae463587b0ef5da8cc45a3b84bdd1828d09453b9bae26330cf2b253e1d7c82a7d20db4afac58b791215c4c7f3ab06737c40750046c5ab35001db4dc1125dd90b3fe737807c92e8a3143828a6f101bd284a253b79293a802a60a034714ac5e91d55e7ea3342ec7d9799254c282730c8e30d55ea5834b4044751994fd0fa03e4874087cd4a9db4f4308b9a52668daee746fc3ec710d101842f372c12771a0241c7af67b30465d49e6aa246e9101f4389987dd23e5477105434158853b916af2a5bce4ec16748cd415cff07e65082d697636b525c41b46ba612cd292db5de946fe737385b62f519d22aa16a3eb4cf1535f76d66231e4a91946504c93c3c57f7ba2bc0193d3dcf39fa47da6e93ad896f1b05bcd4bb1581536dcce46b88bfaac39cbeea34ff9dba3a49b229ad44cbfe1578d8ebac390a7e3440fdbe855c4a03849bba3d1c75337f2806b07efd0953ea2c58c299680235c1935c462835e3ca3cbe08401aaead3e6b2dfe0099cb7d8025db122d388a5ac00342c08c880687fb0663b9fb02c0186074fb1852d2acf7138171f43e49321d4ce491d572764115775cd1192f2305e6cceae623df9cb8d0b5d45fcc7dd1ceeacd7dd7c330ae8d387038a296650779ab529b1f8268b48bfd2e32d1d653d34725ba90948b3caac40ad32c3965cbf03f0afe2d492a6a77cbd881413f1ca0dae35b4bfb148468a6b781db8d5c69e058e7f0f684c8806e178857f5d9ecc9d9c6d46c21e361d2f34f69d3b39a53d677a85bb88670818a97d14fb44bae34ef380ed50065c2798a4207b93e3899111cc217a0d300461f8d630d2390f6d4654c50b191b6336f7fea59a7db3abafc06b4859fcb90cb16a9b0a4cbd7ac209f3722882db78938155e1bbf63d9a7d54754697305a4cada17f20f7a941f284d110285c37700e88f7cfa01f58983f36c5fed1ab4708b5912a70e68ee0c0ae015259b0cafcec2793960714bcdb3812f04684bd0611ed08dfe966615e0787d84737e9bde7be1175c7b2ea2b9cb35a2525494f1709480ae191cf877e726825d426f3882da1f0732aa3f70c7adf5bc23b9beb4e3ac31cc25684d556a70f58a8008686dfa7defbc74528c0d55707e1121b7b76089c007f58c403c35f9637603f7e0e02eefe9d0d9dd4c891db0fe36c3de8f54bbba476c9daad89ea44827ed99cabf8c45f8e72e920b6d7cd33a1a4927946924fd46ab2b34f03d1dd545b33c72b05246c899d952a4b1e1a41b03691d18bdced1352e17bcc7039f41897e503726ce7d3444d71c1290ff44e0cf2b147d6d8e7389ad5d336e69d88c29dce90b5c87cb29cd799d1677cf74f2327f52db7b5228277cde935251916c94d6cf0c478f32baaf292a309da546e1dd40c7e3cb11c55b7bddceb72d34fdf25ece0379019d66b9b7dd068173b38c1afea83bc1e3b2990cca0008a2abcdc28f7d440da5b59674d9784908df2b8b1a1544eac278dfae864a7d9540d782bb20c71f9167f8974c81f3f16356470c818daa76ae30c8a474b6449921a14eacb55f0b4e579902aefebb9fd2facfd273bd490b899d50d6434d3156f9c6a91b66d2f725e504b7034f89072be76e679f098ce059389644dfe2a09b709de8bdcb104ad0aeaeda57f0dcdf104cd88d89a710274c140c09a666025950290b733c450cbf26ff800469ca4b0363531c8f73b31b2250abe2cfab481fd15a34804d488a49324c528c7445e8ece24dbe7550a5df1df0512095a90547ee3ee8b380b0b71a8377656f8fc78d388525da4aadc16ceec160b029c9438f60cf9e9f59e74d3b3a10aa50aba21fe6dbdaceac5753769753ebe5808dbe3ba5c6f0e7cf5afc0909c0870537f099e414255ff20d99e94cff382e22b42093655d0e273e1ab3ef4f470d27cad8a8ecb8de8f8f61d160380f7157d7a11260635e3e78e62282b494af3e94d347f5681991cbbf2bfe6f8fef1f7544a65755faba3f1acb502d6678ba11a646eef0048e1ebddf497d6e2d85c41ec2a6605b199e822c8e88e75e169d0e55d0751ec83ca5ea8ed1c7c229164e832aa36f5be1f5df6c6e00dc2a01d3dbcae3293e98dfce79ffb0a8e35470f12c884f7e55d983ce67de456df8e8dece7efe8cfcbc87afe82709a4f6ccc51a11a6bee238409a82187d45cdb240b14fc29f0c21e3ece2a61d0b0b277c2a96c1d263ffe68f6b13dd50e61b95f8d72ed2e60e7bd9560cf6b992992d989c143f82162d7504ffdf350cba84dc0675ab158c775926d3ebe7416d28ce83b80861c073e3230e73013aa78bf760ed6f1ee7d447c235abfe7e28a79d7bb93d6434f6981372a9f7b47c5f857dbf920e0a4a22f6472872cb70939569636ba2731563b7b2deb84c947b3b1b979af9bd9640adce85081964fe7225cd3cb90185345ed94f75160ca20a75537feb7e0202bcbd3d37036cd824fc11efcb6701b107281ad6e20f875f8a4c55c270b1b127223f972debdc335a1efd16ce4cebd7f15104553366302c42e9aa895d65d360a1d06a1e020a3fd65a3dcf839e173218ed799270094d22757d9f9f69c78ef6260883f63e6920ee325528df462579066c71893062bcb23a94bf47a79a1bd873af80815c6de783d6e6316878efa36e3f5fe01690894fdf33d97bac15e9019095411caa0944a604978d675cf60785c1b0f62b7b5a72ec703b9d10b7ca28d2da3f1772160887fd97e7a078d84801d48652b456c62b8948395b913dd6ac3d59caa1b794f7f6a7325833c4e39920ff4b30d6081b7d950755b7257a68068b06daa6c1ab5fa95d30bdee73c12aef3cfec58ed85a75924c151e1c8de2567d6b06fd7ef5d6399297f2549ebf7a89516b8990b0bd95dd668191d79d5b09e4d9090f47e633bad881838bf566a767bd3f5c042cfc08bd9cce1395b37944cdcc8bea260c2ff8f166c30739d51f31d7c00a314fa165a9dfa79ab361c42e61c19a9797f341874ca4eaa164e17599192349edf30c2bc1282a980352cecb267844c4f0f6fc0ec4ee2797c2ecb69278b89be9d7844ca4fff57c75103715fcd42e319e22cf76d3e670cfa649103e05131476c3189b7010304f91fc9082c4d2e1bd73c06b4a71c1d419f2fb50652f9ab0d1e5547d08ae1721fc16beccc523fbecf8938f5f7712efa78ad81a17c81363da598c9d71770a82ccabd709dbdb82e395e9db251fb553c397843afdc2105e56fe491aa40e0db463e7e09b3a68c28ba6c711bda5db3aeef3b0aef22f52384e336a087b39d43231bd01a98923490bd5b24bab808d18feaa8f9215ea1e41ba973ff834a52fa69490b90772ef75c9ab81ceed6956c3962a5262f1a048d6e0fb5b25fe8ec3a53b9576824734ed027b5f9fc59c3cb309591b70558fffe2d8a85170e04f1b2aee8fb3fdb60ab66923a5606f6aa8c76fea4491d8a00b5a45dfa989bd2c0b11e3e1a882aeafead50408d91fa906a1f76b3bfb1c95f430e16ddadb56f62f091ab8e756dba68583797187a22a1095755b198d232596d08ff50efae16dc1cddab3dfb88a57a27064fac996f49b05b5731c8ef381c413d44f4eeb4b9cfba5304b9f7f04692560319f09c58fd16b4bc595dcd464aa6067daa02a13ea810aaf44aafb7e37d5936a7274190efc90527614cee4c92bb438d63f428c375d4b481d43ebbb3806ed128feab0d7e50ecb6ccb4672d4b1297e3e0b34ee9fbfc5dcbd42a9aded272a432b373f302e558b7ce85148cb5ca5aa5a4d26e6cfc5aad6dce47050259b696ec53eb68e7f7d1b6124e668d1b3fc0f691162300eb43ded8600ca20d1724e2b76b84277a20b1bf63fb78f8daf23627dbcbd99fe3587608315582cfc58391f1319583a67d15eb9b6b23f86a009819fb32c3f479e32eb2f3b0ad4e7ff1581294b5d08966c9e93a6586ce938a24e700601f3edbfa518e5c1b9b7131a628d3a534fd9c7599d03baa958b9328594695cb36ff4b6fda91008bb228eb06b1106d28c633ba68b5872c734c3c89c6faec012efcbdede294712e2f2bc31fb3d4257536cbd8101765f31730839aa69f609e6711a63d3f924e886dd6c058fe4731487e415735abbc2c372db7cfbbd9ef8edb10b74318776084eda2d373c6e9f47b06154a5677272226281d8487826a06e60f1eda9837870dfba4a529208c40ae43acacd41460ab5d630e216f255dca36bd463d81be8d9448049f2b8ccbf4c212cde09f1b8862e3f2b94db6e776e7ad524880cb3575148bfa6d16df449bc72997247d8938a5222e39be867fce2b74040b279e84c84753db3b95a931fa99d19fa58b94db2ace8006affa0444230b8f14dc34588544e3bd86a66a67c73cc3aadad5318a4e2bbf6b6b61a837b8ace91a0b83c0d82485366c9bb193ed75c3528a31bd924563d2ddfef7067367ca5936827c5ecd475d9a72f8e2c689657ce9702491c6ea6cb8e2feb3ae51b4a345f6308c44ee4ca832cef4e295e11d37d57ddf99b100d660e660672a1843a44d222730f509330d4e1d6236c022f9bd2ed8dd8afda76914e504a36cde5bc7bddb94d207a3685a5999fe6b1310c2d3bae00f9357d2b937882053866cbdfdc715c0a858abae83a3d504f2b86da616e30a79e2a68cb2a5d61b4f6db6ac7f5ebe257da95adc724caa0b72a6008913487487946986ed611c5b524049905d1e84e794e539986f41e2877a74b93307c4e4b18c10ed2606f912523018a618c111f67d46fe398ba66330297012fe3cab0c9becff7028d670c0990721fa1ef9b636463b518b607f9d3ccd0802fc9068bf10c8eda684b4866676c5bf083b3fb6d7dcbcb3c9b672a3c94624de1cc0ceb5a1720dc958724ef9181264db7c4bd30a121583cd097cab1e884d38f0e0a7138beefa0894dca7b22a395fbb74a0caadaf4c8d5c4fba6abeeda0f3e1890ea698833f3ca90079ec0e9524a181b6e3f2b1bab86249cca5a7e92e9dcb686438f02f238be0eb3356695cdbe25caf91b326e89bd8a85e0939a46c1c9a55c1e6aa48bb12d6fd3740b77f71e5d08e9b0eab1886a9bdf6b42dde08aefb542db11967431061a7d7f6837ab1242b4567e68d2212285332fafe01977cc7e0f4ed32a0735172a966d04bc7decebcaf0862184e5c24c178735f9307f3d42afd020a42fb2b5760c306a1e2d751ec7ed1e0244c97017efff7c5b92707429338b36ee48efe128e944548c9f035dc56e46c8629650be396752e6ed846a4fa96ab00464d327538964ad19ff8449ab8f5ab8118850d3b68c3f74d1cbd2584561f0773fcb86e2d88a15565cdbb30cef327c541186144eac2e27d9eabdd67c20bd74afde1f87ae1b9fbeab008e23553d84c744bf82e74a34af859b4a6b5e9496911eefd04cd882561545229eca58e96ba7fd650bf42f773204eb9272d880eba16ac498f188dba04465602b03cc6e8c358a20087721857c895f24d11ce57896d303625e46e933980687aceb61cb5d63328e39bc212978b0aae2ba133385a1244c8b5a35142dd53f0f2ff8dcd156ded0c005a987fc369c38b6945306171464d0562f904b0a83749b50456b189f8062bc7f4c0e7e4e1ec601f01de479579df631b1aad78a80214dd5e1102c974c48132d95b47e9e8cb67ec92a6d8a95371532440f0b3d17100c810ac1521505a6b3910f83b6426468be7ffd3cd4b1c7854864e82d5cdafcfe58fefd21ef9075bd64b193311febd9ef012d64c482919605b15c8de74ac5d4aff30bac3e8a6782ae61355c477da6baf8b15476ad6607618bf4ac198264999244ec56fc72615cfe6e18ea105c4ca7aed44b7380eeafabe72bc16c02e8c6ed7751bc36a2d6ba4c5fc1d087a19147e35a492b54763d50043f3384323c6d3763de1805a26bda3c67fd09f4308b6d451f95fc9d96bc744cd0443de4abeac9f9a410b194491b7d25d5f27bea81eef75d368416af7f3c449c7966b7413b45b90265f08c766da4ca244007c619c336f20cee43055131c52f8209e782a152db23832b12b06300bc0a99241e3e31d2dc590a1d856abedb2fedbbe2205576411e0bea6ea141e76744b2382b0a1d69cb198c9805668af25829dc147ccdc0a972291aa318f4ee05a3fd28578dd3a6927e1fc3214ab019ace829726c9a9a7f682b997badf2ca531f2bd8131848253caed07e191559e4a89cbeba139c9758807469c1bda117cb0f901744ac9efa155548626b0fdbdb7680361121dd4031d1b45610e404359a2970e5adce477a3dd2bbfd71e3567a13cabce4156d1460a7ba8d429456b59234358a90b4ba60b40e435791bf6d50437c8e0de6c701f1efc71e84a291146b111f864147559a4d825357952d0fddec74d98a951ad4401bcf0c1be6a5d16f05f1d21bf596f1711373b78671cb9fbdd6f19d207f59bd662c0ff43d5bfe867e91b4d7ec7c2e43c6147a31a836745d644d0d9ad9d7c2e4b7f4fff7c9d237be50c94ad84ff2f97a81103602990cad909d3c9011115d0b996cf753c58fd7ff0ec0d13eeecda97d1841d469436bb1fa306245d5f329eb1a3870ed304cd0cea1115b071d3bfce75c619b8cd55ef89d2d5c2be7273a812f87507f976547876c9a700e7424f25ddff7b01ccbcf20fcc601259c4ba534bd10fe49b98de4098daa2c7eadf7b4ab80dc81b783707976c6bde53bbad424e4d33b2f28c400c0aeeaebae739501b1cbd201cd60a53f0128bd884ca409aea1b2a3355c4cd5f7960082bc820c007e74c6c6baa54d8cc3182a7c18352f8046ccd4cab97b5e5713166b0c090bc7a31e08170b5d3562314da52a9c373a5e9ab523fa44bb89ad274441632826a2eba960827f2bd2ee67a537b4360f66ea0cd6bdb5f8bab4a5d90d168b759c4416ed3d6b3074c5f5b3a534459b86963fd170314d65c8c7d21f09116a49818d2d651d77770e9a561ecda95a277d1b5f58c9343013635b559afa3045401f4bc00c8dfafe577d373a47521704eb9f8379b6b53efdd2ef3e3c10892e8e34563d8b18bd77f784e191afeb199650702ab4eff739ff7e61b7787a7cd3c5c4bdc14285e33c3468d2427bcd1e241a6c0ecf29bbc337376ea08d47d2b710cea89bbf6061050c5346071a064d2ee300e25ca8a6f25201fa0fb3eb69da904f341550c961596b34bbda5de4cb7d756c4731ef9e4ee653a935167b22c54b85b2fe599d91b5358f887a9ef6a39ca02bcaa23444ac1dc90589c65f7b308847e7feca35fff357bd35df361bd77d6cb478e1eb4e8e3be0db124c3e44eb7b1b15173afff1e5af297ff54d497a79f6f4cbf52973ef81787172dab7a0e0d60ac2ba7c705b4cb375f59e56953f1bd0e96811b222904ce8b0f6f671d3c1c6336762891d5bec86976bfb3ab93f6b45d8bc34be81a39d45206379989c59dad4bd14af13249678302d450d63d2b46fb9edbaefcac3aef067c73f20a5c8c1bb6c585e129593d717ae5805452b5af0dc8d0a785f4ca414fb6cb53388a62a02b32076751434922ea20a9c468810ebf16271bfcf7546e74faa6c165e6498a9643923d351e1ef98b999d2dae5daaaca447be7a0a32f1ef572d7248168a16f2a99240f0bda5cb7199eb57481f436593b2fe4163525c4283a68c61115d5768cf39cfd97c1cb8ea2ea74766a9152cfb159aeb2ffb87061906d67ec04147d14aa47caf167f354c131068003eb8bd58b0ab490c19211a415e0e3ed5205bc3bada494f91f6b65beb3114ebe76eefd62eb924ce103d681e71a6b1426b2bd79d554d27245f7ddca35b97ea7c298dc026408b050519fdb55104a352c2c3fa9caba48f50f26ff99a3008a17f0425e1398036e8b5f93a930a56758f046c9fcef07ae215b45d6d4d1b13c3177d136adc2cc988b1874f954d37901950b20989477ca4c30336d3c7dfd4baea57d80fd73cbb06713809615f4abd2a78b9f7e7be11969e0df5a7455905a9a3262522932d67763e36d542a2f40d55cc273a668edbf952789357a9f67ac3ee412ff80b690f1ae1bb918dea7a21a55f45f89574220ebad02190431d6a1023509aa7735ed7a569a6094d492cfe9f0919024944dab3aafd7229bc57bd5dba4bde2e38b1f3fb0c930e74331df0efbefee941b65e11fa58c81b87364832e39c0cc27bb0b6c16020ea3861a321b341bf15eb55370daf82bcee7ee2d96f9884f2262d967563c88b0f2e57f198ebdffcbdd854bc5cbed718a621858bd5d0d813f3ca0b0d0bb02dd9073ead9079d7a0a324c91b409f633a5949b37c74ae54413b183711c887a12fd47b07415d251da0a38680d099e548feb5f12943deaccc2f8d99535c5779f4c876fa89d00aca41ad8d43983398aa039d31763cb2ac29842bf3409741a466f5b9143ed180d9bc87b3329fc72772c07f27e87aa7dd35c521190a638b2b5a0a8239aacdf7c4e9c3615a0c29fca76e8bb1aa34a97214039287768bfaa78106cdfbb2cb624775774e508dd7a4bf6861db939df326d0b7e71f3658c0de323b954aaaa2e097bcf883646709ba9540b30aa8aabe33f3f72d697bb5f8b455e722d47b9691a2540b9c0645ae78f636eefb6cbe47101e5f571d7e9560289b3256b4b2bc92d34c6c6b06f11c721fec26e48bf334db2fb04ab89f56b921617f396a62f8c2903217f8c17f6e1f45a1e66be32a74dfc09552f659e60fa359957592d83af4775ab50f74f20847ee5e57bb0764da7fb61260931cfa19e8fd0278b41781f4532b0a30b9623c12adfd1aee204801dbd8b266c09e66129f26d690608a8f33f78a4eda42ced38215ecf78cafcb331f84de81947d8a6f30163aa352dd06636694728bda502a820aa9a4630a1e7b6e62696d7da1a2e89d6392b6deb86812a772d0ad3d24d754ed9e656c85f8156070b3ef84bfd682dd44e6602369effcb8fd348fe2f16d375de16e426b1ba10a0bea509f38833888771344fca91a75b2a056f070c8d8e43fcb6ef213a3f795d16837786f8dc7442379a519ac3e6d106b197db125ae5655936324e75815a89eed4f74f975276b2a80d5f441ea707c6a2d3a7b0b2599afefc6b10614c8bebd2ccf91202020acda540c64a31e272480de1109458ec03d8cd4cbdca4121393da7e76024fb8e135d960179dcbb14e4e363221371e01dfc451f2300fd167d2e557c6675d7e6e948386204cbb8ae16d0637de87d6609f57365af18ebebebb2115d0d91c736817a68cee47d16f7cba18381c86de460630be3e0d0ea9038d83b07c8f915183e8603a063e1b5525376cdf83029c9957991d9d213f66a581ac3c3d5623cc20339abc9447b9334d021f536146ae0112c576ee9c4f658f8805f700610a85283b46602af292c63f2a6a40a47de9d7a803356f3be26839bb787a48e6c36f47b9f1022fcdc75c146122de773b15ea7f73ba477b5377c5d3dc3fd3bc6edc451a28a81524d2865123c854c240dbcdc134fbd5738fd53d565eb692b5fbc0c97b204e9610e9a60043eefed4b7b919a5d2f2ba116a5aa7c0ed7a3f97c26adfc351f00d6349727438e7a6af5270b9f447d40c9129f2847152298be602abc35ab08132e15a5dc8f9358bf8187d782a3eec026b991f90187b6c55f39ea1cd24f967ea6543d24fd89e8e12f49da797bf51d6e5a2d4541605f4a755a81b9e2ee960c299cf831ca81de67e7e4c09fc595b7d26bd481da8c53f06ed2bc7905fafd72e241a113b5633b40131fe674c024e10ee607b69f022466d5c711b693eafd9ffff110f7fc84645001ff68eaba065390ee86b3f5f00d79dc6e706d832cf5e84e1d5e7111156b0d0a73e2b5ee0d9178e0d5e7fdb68461caa32e8bf537fc521bb816d45d5dff79c387dfbccc7e4dc1d8aa27a556bc76f52efc163c9217dda14ef35a09c794d4948222a36c616affbd4f001eda18a687aacfdac911a93b1a37717cbdadb8f4043c14cf3f4e43a14d0fb2e2758d88992d40c14ba8a69ef87c9188704110a10490338df021bdc8fa2ebb21fb17f5fed00682e8e95a19ab33562ece650617dc821ce38b435f665cce1a950a0abdf1b3f7e7491b92405ece83a2f33b2c7909646b48be64eb0cf17fc52ab14283a9d84d64ebd4341f4e5c2248adad5f8a39e6bdaf135271d0771816fbcbf39db36c67966770b936dc63ae3c10c2236de93e7f77bf3b99680e6657191c8f6c826027aaec98e3d755eb4efeadc694c46f3bde15f12ca3bdbb4c14111c87ab6b0910aadbbb02eb4adeb27ff54507b3c96fe78a31b7b7bf133cf4e6716c7e40404733b0b9cfc4e616674eb4883c5c87fa86a9ecbf7007c49cf842a9197e070daf98f61910257a2988e961dd9cc0cfb0ab0a325b11a59128b432b2d029360abca3ae689709eb6a76ac1414f75249110593815b26cd294eacafec20108e794679742bd82b3146f826f0610ef941a613f11c279a60759f4f8002797ef4c9002bacd93df3bdc8189d6af26c317586cf35d82a1da14d3988e3bdbdb0407187cb7038fd539f8c16c5af23c9d92a7797328fb4945027a380d90248c0bf748bfae77a14722eb7ded2635d086a1a6a0cb5a99aa44ecbeee7c9bbfdb9d58efbf4c2bb2bc51ba93c20fcb533c430c64e91cd166a56d60e18a99187c5b5bc6bf9d4b233e24ba2174b775a0a48c8d10c6623b848ae8ea07ccc5050156ef20848193bddb2ce15f7d12b02f4560fedcaa893fff40600cfd1e1d22dfdd16ce415a3942d9495c78fc5cb03567359e5012d1d63289c314ad6c1430861c4a4b5381dd1b65615a2a6e2e4960c83c9c3feb0586c7825002cea17ccc93ef8d9b97679dad2a1f6ebb43fb294a1bd969827aa9a4920cb66ded1d469593ecbf4ec66253a4cab3dbde0a04b1984afe17099aa8dc3577a44f2a2ba7c7593e9cf183367f3678a72a68ee4009b100bdc53e1784be1a07cdf5d4b21b400a1fa31930b131d9223f7393b129966b0c84c5635bdd7ddf367a3758078f0d2891047e14911edbd2f31a3c4e53d27433f834d8aa26908dd526db325975b0a81ebddb5f76ec6ea43a701a94a0814fe300ec33f192857eb9c9e8a8dd7fa037271b1230edcd8226d12b75b7fb7d4bb238b350c62ade9298066d81641b232c950e50f6cf866f84bf6cf46d932bdcd502c685d06855bbd3eeda4db558f3516251d460e10c00f2ffb1bcd2873b5cde2acdfb4d7cd64ae55cc8bdbd33cdf54e77d1160609153039ad3ac617043fe9974a3c79c0e9d68bdaa868115ba9630f68ce112dc8c72321f6aeae2fc1f8163fbed1897854199438b39167c197f31584935d3a1e25df74ee6417fcb3067d180353faae36c672d4c8cdc310712ce61d252934cbab87d4cbfc00ef82c07a2f181af50aef3f5dc4ca2d1f5e715ee917d798c9b3cd29fb289c2209a57aa851b6577eecbcefde3733a5e7e93adaaff26571fe696372e10ac2e6d7335dc5849da05b3ff6ee36ccbbdd2863aff12fd82a26a68aa63ebabd76029f0bc4523864d8e8e9300bf86310c59126178f34341af486209cad69ab337d54183635365d50047da1fa6a80e909777bc97d4cd3a0d328f07c8ca8a2625f1f521c0db64351a7322ce0c27e010b212c32d95d9ef6b1f27be8151a6a9093a68f3208c91ca4f4f8d57d59cf1b8931363a05a24e35421cf0ed4e9360966c7866723900bd7879cdc0a17013d669763409258c83e4b57f0e42b7f7cacb478936b99033dfd16ea3f4a7317cd6808b8fd25e642e6075879b0f2f65ee50ee5bfdd94ef54ea8816d54a7ada6049c86f9b424141c9efeb100e22601e4af1d91595888cb30027be5fdc3665e75d021239580e95a4413a1b45893440ef1a04e4744cc6ab5be95f285111b2ff4c6143001f3c8acd0604acef3a66f7936b5c1ab10cb6d007ad818976ca326be96c320a80eec065313f35f71cb9d5f0e2c71d39b55d6e82d167e6f2d4a94300a514e3fb31e165870ab001d853bf043492305944fd3ed1f98e0c2d5f7b9035f4c42c6656b304bdc947f70832bb3ba062b6ddd649fe41a429fb767b824ba5d44df2d9c671a47795973f22d85f74c79db69a1e49d69dc5979caf835aff0394e5cfc07ed6cf582d6c8642fe03a77cd9d7da1656f8deb25ae6d705af8f17bbc1feccd71ce43e727a5b6604384be97fafc5ffdde8828def87e53c0e2b478f6ca2b20c9b7a52f98b659d36a88489d62dce311f53b8fb61f3c1b3d899b281d133b09b22935c39e2b0801ea4a649c4a206b6ac99e6cae2f618f684041cdbdae3fc1be4d9cadb43a2db900627c24196ff99510b960a88c189b82f05df8c35026e967fcceaded3d8c4b4820356702d139cec41aa13cb7f946b9231b6a6e563b62f85dc104ac4e01adf58c986feb991ba7959a64b08fcee1e5de81b7def049b0431149351eb3eb9bdc1b0776482d5f3c0c985cb1b19e3608f431c10a74b1dd7e25b0a49972193715dfe6bec2162a26bdce695e301c087b243d7db2711bcc7bf9798d88b34facb8fa46371750690f393f3c264f3a599ed0c627164ccc1ba3726eb594839aea0d906b98814d52cc38110ad4cbdc5c633fc465b63ea816f3759f9fb5187cd4b6127296ab7fa1461033ded18d247d0f6b3dcf551eaebd0fdab49306fcd0d5b459b0548162dac28515de7567416b7561ce497fe0af319192995c83d7ee779a08382c59298af0adcb85fb87e77c25bd101b84fc5d8b1d80bd93e7eaa8c13db9a018a0e757a7d75f0d45c0ddbc265cf986b3f4a1dfe4e5ec3a858a0d1b920894fe69e5b35bbc574dd9e401b5139237fc190c5ba9c8d3007ebfdfb603f3bbaad3dde67b8d48d7f976f8ea8df28a226383ea19e899e15b16d783c5c4a9c92db307a5283a980f686c0c4c3b309cf05c50dca54efcd91f2f6a3a87594bc4b5b042fda929dd59e4ee70ced6a99890e3f01496640146113914a5a5ed792b1856c4c3affc8f4637f8b5702dc81ad36f88a2eac429b54a3caf04bc390e9a2d21dd62c174721e86b7351b20c4bd3d480a69a953ef52f4e6e316ea36d615828aa8e509e5599cf3984906d2d7dc7dd3e0174d5292ffe2e85bb91dfb60af743a6919ac748e832b55ec313f4aa5acde2a9741494ee8fcb8dfd1c0fcccb10213fdc3a77f5894dae8e17ff28637e07f6ac1109718c644fbbc05aed85518a765b6b5c47219fe4a303fe5f81871355b940a50d910ba6cb6b882c21121ccb208d2d9a53962cf1c65ff2744cc94ab9dedcac878d89aba54cd7747d15385daa04f3a6f9a4cc0082f8d1c2273143dfd2e5d08725f806cb90f6fd960d13f4df53c46656ba225c370b602e0a683c8afa2adab33d8d97d1c8845edaebf61c8970fc3ee4527f004dbe9fdbf2d4daa584208461a4a75fddb43a48b60b331d705a43ca953f8e64e49b9648af59abea3f364cf1428786ac0166a967669edc98ee3d9db055a700add587ce922161056f928b158c8171db6e9a4059ee17077f40d431e66ee4d086dcdd52d7ceed6d7f294ba0066872e085d8004dfb23c8070be610b2dd64f3abe0a5de8de61d426d4d479a1d807e90d37dba71414454875c3293064bc6c34f4ad545c1348e444c948f14b64b8ccef779f052d3b291fe672534727fd8f1246fd8268218e1122ae57277550a47760001bc8c89015cdd8ecc17902447869385fab66d0e19f75c8b3cb33e446ef40dbe5bbcca423e09ba4b09fb406285c55bf6f699056d9e3a74f3b05aa8c6ebb6fb0046bf5aa913b54038728bfd72f0b7bd8be9ab27cab178c2c1d774f9d2072ff54aeae83443c0e78edc9253a8c82002561c60d73549ce2c08f9c20fec2e6655cc8b087337ddcea891709c1ec0f14a4412b6511371eaaa83ecb22f073fdc8f9c623896cf67c16c71478bfb7ee0d36b60961a1fd0b7439e08e0cfd49b26856765dce71196862e4a305c464585bd6d26a14d87555b2b12cbd6c4d531684543c01c60d9752fca83d9213578e791fc3dc1b5225ffc37741d3666f8abf6cd287da5fd397d19aec5f89d684a8c94fe99f6fc40bd9d11aa37e59cc553c3fc78cb68a18b28bb3f7fedc325d4ec229838bbf4bb2c68daab0613544a2d2c1405aea96b1aa469e8ffb1ffdd5a14e077252319a21a10eef0a98d56523306ab027f86e938f601bfe4ae9010984e83a64bb25a4b3461c50ccd8a13d2806dc8e3cf6fb829731f7fe8d9627f288f79c4a6bcf7564c463a38480a3a4cd4eb7dd0cded56345b82f03080594d50d40b85c39d64f9c2b63ff9ef8bf6f462557bd7d533361dea3a564f897922af3e538aee494fb301bce1c4cb148ee773bc3e3f6c79f7fc4e87ed6bde8cf65dc20b1eb2399dcf71e854bdd2d458ca40e28f00a83039016aadf308022d3d640014f304e22ad7bbc8d9e6fc72dd4c5a36d23cd99500b0513d928db5fa2e1cdd45e6e6202bd8de500e37245a95f03dd59e46b6b0cbbba0bd459de18aaeb5f9adc45a3217ce6471a47aaa16afbe600e0719cc825997d0d42053b17aefff86e73e4b0fbbc3bea2ed9d3b83ced00acb02659794c29fe5fa0dd407f696f620aff59f7ad05bc3c97cb515163d94ace3406d7f724ac23d90c178a647ced04f87b4b8199cfa0ae20d6ab6a5f2023ab50523dec2980845630d038204dbb4a11a2df95a40befd57b8ac12ea186a35c4b89757588a0a2b3c4a288963f51857ad3df6bc77aeb8a07f72c8bb756ae8cf1c2d5947dc4d7da66ab960097de1c386ea316fdc997d024fe748098a77c6dafb6aa49852645b616dc02457842466b4889e0db560ccbdb26570069","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
