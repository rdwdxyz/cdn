<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec200d8f09ad1bff1a4e1c4803fccdcfee18d78818e93c5fcdd0c99370833fdc536cac6de23d5341e2bdc73b9e85c32e29f806f7fe3e54a8b0858879908502b9d2e2e18d97cfd1abc668fdda37473f58755e960e649a02de223ab0fab7834312c0095910e029f3098320fad0f335d4794d8b3b596412e0c7e49c7d0b08505dcb5c5d79e5e9a564c89c899f73baae609439943be7d685b3db4491073ad2e36033677a0e9294159d25e25f1394f0b4c207d2808057bbdcf18d6d0caaea438456cb8c7d2356861303657a34b919775bd3d818b78d5851ae7ea8ec7519d4ed046e124882094bc3f3c072dcae2559d3487e430e4ab7f02fb661e0d52c03077c443d1e97d6839efef0f0453d972dc201afe75aaeddb90d9a26e7a6a7037388274fbabc2c410359f7924108b09e7f6369ea076576d1dfbebe37f1066868a9c1a366dc160554dc65cc6608ad7db1a4a3ad786385bc805bb3d053e4a6ce20b1ec839e89756d2de6b73a5ec616a1cd1a570086adbaf80f6ee1d40484e270597030ba30ae7ce479648adfdc127525e6410012bb3457dee1ec79fc2f7ec58eaf1b415f056a1e24395f92df116a0abe1c16b59153da16f83252f444a60a0a9882afb5e618359df1248c5a507e606128b4985e9f0661a48cc4ebdc2981716415879dfd4bf09775937b73471942ec768def61236b9bb93f69c5354944f5cbfa3c780449bfe8bb136fbca00534a55fca9f0f5b5a3d6a24bd0347147441f761d1c46f778355094daca69c1695dbb246006ef6f479215eeecb3856a593843e1360b8591ad1995eba0d40efdbd1a0185b994d764895e7abd44adc5a524df0edb22837b23c5a004dedcf8f096835c4c1f159ba5d42b8d5624c104eb95200dd2b538ae58c7850ded75c4a869d6078cf4c0f2d04f59964bb05e6439dc8e6f956e403af823721f15044a0de695daab154a399ac3e454a8e1ff35c6666ebc0c7de0dca31c91b3b172e9c181cc77b3e80eb3dd1db5f62d4f3fe3fce8c7bffc8b065b7ef98516567de6ecc55e83d6bac92a2498351faecdaa97c958a3821c56c1fd57c2c94be6e6c0b0885ac797db5de728ca963915a5aca9472c1de6852c3d4be4308e26da165dfd1c0e63298622784fd4bfe032da9fb1944379de4956dfc242124d14f370e7bbea516eaec7e06d013abdd8966b89ee522e0837fc12934748d083f2100151a4e865507f29b3313747dbdd831cb66ffb5bfb63f7c43a5243f92da1af0fb06d85251b3431bc7f490d798ab1ae5792418dc4e9162126bab31306a53b6fb4bdb991019b1e61efa39329e6a081ee4765ceca99d29e6299a73ccb3b85a49a3cac516c2eb668270cf36f674b52411a85eaef6309fab9a5f2cba529d5a3e2e0e04a08446eb780016b54ee1ae5b5eed6c5626d4baaef98bcebcc812b7393098aa74879f518a254bb1269d24b9daa6c109be5da4a8f55e8ff24ce1d8e6c5b34c7f5960bc6e3e37475ac42b34e3ec57ea1d2a490dc3ffd4b0213d80c633d7ffed3752e22a3cf75210f5e0e77e6ca2187a8dfa76b1bb8e7c760bb5843578be992c1763da271d2d617b658a3cf78e4276a14e13f41a0033015acb23ad8f897e9f7130b62ba27477bda1173271e6de9c9bbaa66eb71c8144caff77234cac4e0780591239cbc33cadb805295377dcce4b50d2edd1ee893e41426ac57b62e1f374b827115da42c493ddc5db631f6d16b357dd2acb3a608eac01b8650ce3d209853554069dde98047c895b841aa768a5226b917d4da2e3f146b039daa47cfa7e222aa3af0faa71b9d8bec7186204880f5df6a2e8525f7301ab53d040df0f8f78028c90e7dd4c5b0fe9fcb72bb1e5d9378699653e2500f65e1e05f71d52f96b26ac0ad0cb117d59cb25aa189278d20770450a6cda6e3130f0246618ed83f670eb5e6da7ed57210063ba41869ecfe160501dfb50e5ad2d34b0fcc2077a9de33e016de7259a887ab509e53efb38a56ff0b3b75f7c4b45318c8ad24f3c3432832409420d2b754af32990237b363d9d6fac5e2beae111bdfb6fdbaf526cc46cf443a9a62272eb973301b50d8159985d0255f9de7c0db5b253b0554563496542bb28927fef47af12acbf8aa954f61ebc7380c8498776adaf8c43494b2f3b3828f5c0126c27c2856689e4996381c1c54a6da827645ee18df290845590652f72d4fe06e08dfe998302e7894ba4325f4f1117aa60012278dba5c02ba5067ad68b05d3e2d92337b2be9218327881f95f20da0d7aab8d26a71b953a8ff13f8622fd7174a9b915386ad0d5708688158d8a9aa9c4858c450d6436882a2ed4256070a0ba24b892cf6a75448e9ba197683b0417eede21b85543652b192cfdcf4196f1a9cfc1fc6a75eeaa018e2269427841cc45be54aae90fbd486645d827dda1936932665c2a7265ef18ad411f159b1ad559b447f9b7b7abdf29c2ad73ff30625e2caca2927933d862620bf2871232759689a2773e9d34ee79ead86cd286cea261fb8d61db4350053e59854cde140ce00aee6e8a8bcb3d6fec55611e7f47962f3d35bc85fba85f87e3fe0733202ce4103f4e26af9f426d4b7d01574635b28d824f9b53ec5f980cd4611d75dbcbd9d6ccc1e131395b857e47174998497d615655fb4d4429fe882ce096a3e41fb12678dacb7a6f436321074be6da6242e3ac35276e7218d9bf47a411a6cee886c65dc57851962dcdaec15988bc17a003ddd8c95f2d405f0a546bce5e6c916a0fbbb4457b22acd36c0d9dff03264a3efa6637dbaa75b74406419f3e44a34e9c3caf3d1357d0ebcb9ab73babe71aba0d1bdd565efd3bddc4829f3158462f6fd57aed93b7d718b0e9c219b3acb5f5978817fe5bc92693de29cdd223c59ba90b8b8391b4f718b749ac78284c43e00d9e31b2531e89a520aa43b5f226e85219fb2fd9fcc2ff018918323a21424f0d8fc72fcf9cf934ea0b74a68aa547e0356cdffcb205850f927823c12d036c772bf9f36b7a9054dc051b19188c5ea5b92165b5eebf0e9b37904dbbb11ae1f2a4ce4c5125287ca85cdd14a6976fb6e9e51081caa2941d58207685f2fb8b5c9e98bb59c2c1e83e78b341c71990fdf58b358aed80f5ec0a80fa7024cdf839766f871a4db199d2d1059e61133a8ec757f4c14e0281c7c1bbc9bd3781b10c470456bb2aedeaac5e37ba7afcb8b35d689db834725855cab3cc9b70e282e312eda89b3a531ae8bd6637d3c7e0ee1bd61e77c795236fa06e1e711f0455e959b38892030299fb99407f34e36b49ad07dd1f1abf667f961711230242351d248ef7ab0cc95e0fb7ea11f7e5d4fd0fabc3d3a3b4151796fac16739d4c2133b8766c262c6cf2bb75246fe97e5b49e14c935bbccedf8c8edcd940af6b24e8d0949d9ee108181d54f4931e252a5898dc43a2d269da44014e5400094b9eefd2a5efdc1c582dd208c4a80aa6dd58886259dc464c1cf74021852c27154b5e6929bd0412765e8ee12bda3b4725484bc02d4023489c1c0223ca160e7d243bee797c2ed5b236228056b146ac7f8a0f9a4acdda0974f0ebaf1b55a913ce503585f4e71799d92b077b86cdedc3e59d66bab41c04c52582fd6eeb20c020a38149011774508dfccb001dbecb99c0e6409d8f80a2582662780ca3c9b3ed41f55f20c0971910e2629a1b93e23b0e77d8ea313838189a75fd92632f0f5c11ec509c5d99185647a53b6cde4105295ab961a732f40ca64b44bf1d6f425176061a3a77c57fc3c6cf3719ade21ab782a9e727b2ca396507abd9968e258292dfb620aa980e0c9a57e187bed34e0796958eb40b3501a70a24a7558e67755aca4542c51796c1ffe633a85699e8af113bee55ff2d9a13aed6ad1c3bfdff792402f38162818052a76c35ac857ffa7ab48e0f4f73a34c2666f4f8e617b182776448ef3b047c16ff80ae71ecc0ece15b593b6087224733cd500136d07c85ffe258db8740b7885f5b7f595b7bef4bcda4c29aca9c0d4186902f66a769d64c26902f89ec682005b45fb7939a499fa167eeb9f24179edb605e014267ec76fcdfd26f7100fd7f4b9a12d8660a6abd2d43605a6516633046a3a5c2483d3d7ada54c73d642300a4985e5c21bc8b9fea6277a26aae4b6d5c962d2538997783a37d7bfbcd2ff81d21aacabc15df511e0bb30ed578f1431d64648a65ba6630c4b91092710ffe4c695a32383e41b7ae8846cda955065d91da29356fba9474231d9e3d6815eee189e4a2dcefeaf3718c35f3a033b7d53e9109be2259ff1c1ac6913a08109c2249d9217bfe0e269e0a4859a8e9d659b09de02bc0f77be7122c34d87a9e6755bdb83910fe577c122651b146554cf35255c6942fbc35dd9cc5dff26b06cd7669364f44587d36787c8f9c56be647efb74fe0c0cfa16555c7d45f615370faab335f0d14ec9ce7fd3bf1290c02760f80494bdf0862d15d8be8232d4cdfe0e4f61ef8010f512620b09827ccfa2858c5ff15202b172a6c8df3f96572746053b1d8437b7d07645f2f4f6d03c514cf0fd07f09c1e75d7620715515dbf7e2978b27af4956a6c9f76802394fe57b9ccc73a7c49e0bfad0299058d425f63ac3096252e6d07072ceaf4d73da0dc9bdffa59035aff3f5c9de7ad97b4e8d34eb948f063b6fee035747675b7ebf822a444d508686f10ba21eb00847e1d673629d5580b19665a64a21316ed701015616d0a11e34ea0c88577b14de30c1161927a27b088c317cfd7b54e0efa8b725f3acd41d7a848831e2186b7b38dbf7b2182760cd274e4af871c39f9979fd14de79e8cb05cc59e867ad9dc32972833a94792ef7295a5066ecdf48db20e15585674176bf34f51488443370079263416ac5a3d4188e392d6d1127b5748a4af37177b40d19cb39fad8f297e89db9e5d7b9a27cd1e93c9a884eefc59a4d147f963a5f60edb2ae8cfc0330f7922ca85619351d22bbc6ae9b5c4236c7f6de42fb127f3f5cf1b0112739fc0112be1debc2bb7762e041383c5ab84dff544dc9f02dcd5ba7b207753b0fd6849dbb34d48071faacfa8719911020b77210172d2ede40a1798bf6d1691f8245e39bc78fca67d07b3d657cfd6b62d6b793a0073f2a959b6a975cd0d24709d81c00cf688d3d587d04664f750b543fe9a0f1f3ef5b76eac6f31b34812e336b789b5f6735911b8a6ae260ab2a80d8f5d172b670c570f3285ef62234d76fb6935cfb13de78c27d830a0b0672415c8673dcf3c092d915ea5e828e19ba02f81157aba80fac73d9ba10c5341b231395989904334bcb6f37b3814fd867dd116975bfae703bbe7b3629f817317d4503e97fc5ad746e7129ad50057afbcd996c887c548358dab7738d7f99ba8a61e06e61c6a519f87d85ccd837bdaefabdd1d6023d74847557cc827da215d5716fa5f32c1d2c4ff8af53dad5eabc4234114fd47a4331e48d78764ddb0adabab07e8449b95fbe46e203a3ec292c012459267f78774c32281860f73f03d770b626e1b5454bac3998789330351210bbad66f348709cc81cf6847a3890d2e15f99e5002997fe91970b607a9cbb4b9771e871eea2ef4615257ef85ef563dc221f51b6ea732e4a1ed5d25c4d4da63ab143a4c5b0717775512a6b038fe8f2a356b242d98aa860959fe3fbbfed318c5633d86dad388dbdaacfcce1d8b786d975da65cb6868f70634561a4a07017efeaba9f5ffc15acb3807fb0dc40f46f8a3c2c40135bc7dbe62d11c5f0e6f46e5f2d29a0fd28d7f4e86112e9051935597e980f4d64dad73e36b3df7519856119228bd588e237da665aa71e9ce7f819b2fa1a147d7b440153ff44ec04aca0d479a821831ce3e34c4abd901f7d2530f71f956ba7ec5c52c1932cb3f79619c5da2cba4bf781ece5cf374f818c9ae7b37428d7d0ea7a285df08bdce5964bd5b4058ff7a607eef658c53669b454e7c2cec20479f6f389a9f31c2ce1b43d43c25c6f3ec53c180de49a390bf9ee959e9e16481db7b99d20b7d6960db6472297a8ab1421888018e71e2a05578e97fbdec680343c38aad0adaab6a4085099357dcb198f62b692605771bf9bcee50bf9e6f256ba35f5094571733cf298c48bf46aab029c9a10e0f2ccd8720d125352b753b097afc4c0b088078fba8c092f4ea42975dbce39198fd7b757cce16cc09c4c3dfdbbcb3c10e491517ee2aeec36c70ce3b33b58a467b2bc971fbe6d20093d04e0cce31a6cb587e43d48502dfbeb16a819f8502674c9b3e5ecb874889930d0ce21181486e3d15ad2cc0588877ce11cf7a10e2abe0f4d9edde13cf6fb9c240980821b3d4a74ca2e649f6ff4bb9a64acef31801223290bd6c31f1e87a09a6c6706de3b60c633bb3a909d1f573105e7387a43299a239b1e43262e31d3f45f0a7b4a4c92aa1f6c54ff772e10882ad2c47a0fa1d1161e1310aad625cbecf9379047ee193945b94de67eda2c1b3475aaebe1f78498659051c56af06ecda6add00f5065fec703f0abaa83307ebb22f54688b0bbc3bdb20b3c6454be976ad56eb4292ac80e7d2256d90797ff8dbc84e4f470da59b1a57013d317d3b6630381ba177e3b7a09336d42d3d02e09670fc56febd7353f46b9d4c47d44f894e64fd4872d5e114e95683500fa7d618c1799f9a24a9c05e26e4b50809e37917868d8bb2d6c23a416a564595ca8920dc74dba86d4bd08f2bef6d62faec8b30b7f0fd221b66f512eae5456abe23003b8a49aeec0c99243096119474650dc3dc24b488011effc42c19447d12667bb5e878970024ba8ff5172f2ac444c93fadf5f2a5e7d8e95fdaf2921987d3de0887256d3e7555eb64142088531196b2af947ec4ff2dcffb71e181a91042932ccceabc691584ed789a5be44a0d91ec68ef1b7a9c4cc35f3404f14139ee00a95b3aa0bb7fda39aefcb46e20aade8602f55778ea0fcf3541a26048a3244dd49aad383a335efa51ff836afb37617b128e6b6d62601569c648d440bcf3d8904194981b95ca33b0a9eb523c421d836de947c44d123f499d17b98136603217495b75dbe9fa01b546a15992e705cf29cbbd8b3d2ba814f9d5348d678a980f68e29c8570de5eed0cd454e20b6121bb4e8b77ba5e60295eb082fac17cad05253743a948882bec01c5fac3c7e4c46f0948701dcc421b17a981a91968b21fd34a869e0143fa6e9f7eac8520559886566acfc33cfa5d124c6cdc35388f47445b81925c937e581225e8b595326438eb3ace391a6e07fa0f43266f65ee839a90c3cc1533c2f4455ed9f9b4537343077e7591958d585aa0f5756d0edad16936b48594c101387b0a3b294030441acacc670a5c12e47555243007c61b7f88197ce76039621ebaa2619648347807f249752b3bfef44d2e53fce7aa156879391d0b6bd93a3352fc23afc3baad715ae85c86c90fdd492c095c9074d9f90d63376ef8b0db661aee65e039df6067fb7e4a323c6e1635113b1d0c1ae5e5ab8a8d9e3d4fee72b845ff39c0a2220656bede6f1f6eea2e4f106508ee0b4e26bed731f14139e90e2f3c12c77e1178c6b96f9936ca6c86e5fe575ee02121fe4a1b741886a78af1f3f2feab2e967aa5837f6a99d879087e3d9d4b4cf2dfa0e6015891e240c6ddaeab1f44d945bbc0d2bbbcef8020cfc42f9d0853c78e8284c7fbcfcf4c1a36cbeb5f76ccb929042b814873954b669c48b60b1c52e26e079683e5b4212d4c876490c96627fab37599bc79c4c4df2a0b09b027d249bbfb323c7bef7a132024c78c607c2be136f3031a68110cedc7f617e4a6aca4a7045690487f7c1f467d1540f0bed6d7185a8f2adedf68293f72234f9230e3d1cbb312ae5bdb5524459cfafaceedf6d7bb89da46a2e399081ddea3c1806db260fc6c56534091d5653e8b26565ccfdf165ac8ab83fbebd06fb400be2daecb5c461a2f742a40c202a6d9845bd30bf2cad28d40a4e67fcdded98943db27047bb2d1fedf37bba13cd7d686287130e692c2c2ccc253567197ea39ad33aeefad031679b1a7a37503694b8b94323b985a9e59e731f05c98cbe69d7e68ec10fd0fa83fab9d83b255f38f5874ced3d09ef71d48fa8e2e60d0603093004eaec139cfb4c4061bbf20bc276ea71356945e6c4ec5ebbd2a405ab9f66a654c144186f219a68d388d152f86c9f82b2ad27a08a8ec0d3c6dc59687897fdd2fe038390fadc67bee18b86ad64a33dfd49e738e9517a5f94a942b4336a4df221cc2c5827f50e76c170bfcdc01ffb2594287611f4234133d40caec1ece32525fd5ab3592c565cc55aa9b6e82ff1952b87eddfcd5f3bd049c110cf29da5d2fca473cd9654968e5d07f2b41e34428573f3f6ed23648e252f3665c76e084f546aadbb44023f9ac9ca479706b76e3a3a38f3f73eb0a3ea15788e37b968f1500da0eca14ea145470280d7e35883dbf41a04cf2021e9faf05f9f3dd13e572976e2c7abea7d6ae2a8c003a1546b15258b269921627a6fc6da5e97645a27e393ca1fcd88acaf1f4885e0000ef4497ce8839e61bc05e9b534a53851f27b1a060d215342da9e363b6ef2bc20341c6470674913cbaee9ad42afff00be912da6af4bb3bff1537d4400102534aa753189de916d602ea4af0fa00c17e5ef095a53366f80b2a3238b920f3acb6e666d120a5787c1863f88c8267ad0429dbf75d95c414276c765ffbb4e81cf1c1058ae7765080a979f8198d62ac912a0037c7923abac39b2bddd524e649a0b073c7ca44ddb521fb17db0690088748f56381657638cbef9cecc5cedf2993aeaf3f1b63cbcdf48b939ae828847494e0132883906246a4c63ced1276950b425d9a522c41ee85b9e89c59e892f8dbcb18f044ccff45bc37e0636ea9fd59552dbf1bbdeb87808bf38ef59c84d2feae77a34dcd337fb8f1471a9658029b3119fec0e81f536fb11a0645e516e04887249cb565364b96e6df02458eca03b173b4bbc7b2dd9ec125c294da6a01b2fba2a2ecce17cf7f4d3359acdabd63ca485c213377a0a071b558c72ab2e7aebc2184c6534363b30662a663d9e73808ae2095c08e02f8974dbee2cedc64b86eb2b69c826d51b8f7fa31c59a840ee3560936c183c0471860b74e0476e256cf9616fe79924e057d0cdfe484b4fc60deb391c21b39e754a69f2cf8b51a9b69cd4a35cd4fb18393faabc4185b111d584ad6b8cb7c0befeb1280dd04337ff28b885e9cbda9c200d062af46e8e43a0f422b54792367fb16d566516c320bbeb590d610ad57f4a9929800887c5d62540ebf315feba63d768c95d30f964599136aa59b383d744101cd50a6009c0de95c45d687b10f0dd8acacfbddd1e5633daa9b02cd8cd6cd2ed7fd20d3d14cc3661da684df4270ac782b73632f3a073ffb53f0d794daa732864089ca4855166331d01f191da4218d3cae032d608b78f460894e0af44c02a0935d7e876fa1bf39d9767fae03cde4457a89f8c6202bbc8abbe27fe6242cef9eda9c261b0810e1f61fa5c2b72256a367b9aaa085ddf670f29d5579b77a51996539df505e40b0c4b3192b6e1cf47dd9010bd13ba22e5270090ff1bef7a3a732c25146e46622369534deb2504a86c724b163d40b28a9cae6c7908b455e774d7cb7b2bd3cd96751704e0d9b9f2ab06be0b8ad81268d27e74682adf19c1f85e92ad39b976322f65cbe601a9007b339a9c26af3605ed46b17d0c2b459034f163888b0033e62c14c459d19ab50e9002276ed23f7452784f0127b51da2d595702768e97f6c0c5984279f698d4710f7547e5cbda5176303f3a0f211a705e3e539bb21d5d9f4a333677187dba6bfb7ce2726044e0443b96d91853dc73aab849451d631fd72cd8468608c6b3fc4e36f2fcb2c0a5f30b36286272c66646d7113344b8c8656723421baa9f9c542ec95c6270b29c5ce54fba616c22f93621a476e67b8f5971d9cb3e718eccc48082eb4b033fe87fe1ab76cc500b301bcea6aa438cc4cec1742bea2c4d565c98c19559458bf2e8ec3eb137ec6334cf21472bc18aa873add8d6f760b662e9d8b9ba14b830322f500d7fe589877a16b6a4ec7afddb8035cfd3b0ff9e1b96fbe92a3849820077b63a453a7800690d1b78db8f6af8802b3efe569d17ca01492af553a3d319de7126d86c67c8bb54b03fd9ba9fd0f6b1022bc90931706345ed9f6554f1249f76b6f32ef7d6c57899353f4638db0753b10eb9f1c0d89534679a3d3b3d29cfd4cb689003ff7aff07dc10cccfe3b0a581888e3cf15719752a78b686509c15333b1f823b67a1c8ef171a95b4e21119138a2c38b7c7c8cb74f80e03d0eec00f736c5cf93dae6be6727532f4fe1fed9f0efe9a45b4ffd0e86904ca26846c518ccc6c9545b374ca71e243013376d187f14881ddfe702029c9b469c7905239d5bdebfd0b535d14a60cefc62e5e8493c9d474595dbc13b1b1c8bd8c53bddad2695d5d7cb533181849723c67a130201e0750739e21ebbcc80d2ed06e9af46309ebc89141e3c215bbb056771dfd1163ad95a9352b8af4b72b519bcf00818fe5a1ec12ed3eeb5bf4240ec1afb3f1f79ff95e5bcfde672b7a991a54d4ed6ec617db40a935f02029e38aaf0b55b46889d23544a2a2cb9b1caad40432d2393e01746d39d1ed25453548be091dd7d6d35b73f11323481687e8b99fa1b2728844b765cb85bf8825dfcbbb43e4bcb73ed49933b3cfc041f139f234a1711f8f3bfe0754ccd68481a08b88708ec494a3bd166b9b9eb32e166237c9b7905849934c2ea4b056c2ba1aa4e3bcacf848a29852fd0fc27af327927f6a43cc2403061eb8543c09c208380c96092ce4fea3fb756eabed3f1c7d2ec5f2300219f226f090bdaca844348c4b2e2a017de428d51745a4a0a9feecefcd946f1c737197002772aa56a22d768831e0ef2ecf09fb2749727986cc6a2c2fc0aeabe44d84e1151f26d613872f73c36998993ad9bc0911ae047ac534ad5290a337c735e1f2d3b216b7cfe6694b144e299b42102b2c68241ff69051c8906945189fa8cdc67eee20ec054ac76fc289426259487f1340bfdfa1144232a70a5922e69bdc04d0f9b9f8556857e8667982f3a140976333793de222cf326163c9af3ee01ada2d4a73a0a063631bae5a3fb89396f89fcbee023fe23359ed4a2275581fa79e086b1352386f8e604ebced8a8937c71068b3d474b1b5484c97cbbbda2be614a208ac8c7d19cce50b6ee77fc409bab56af622bcf398a1f61d06cc85026df62da076c67fdff4de7065e88b829e05e1a9022c498b3c349e53b78efa62982774fc1abc347c1d1477c90465f77f3e84f0e4722a3e8f73a99fa6a06c2c28a82be9c2dbeb3f77ef6d61e84a6c60a4c9eef0e14a0c19aa7d72f543b3f20a0ce4b918df43e1b3a9af749f1a6d72bcf362598972c4abcd17c7eda7598c5d9ed062daccf8ebe1e79e2c6f220db3a5aa93a1d4e53b1559279d5f8c2af46ba7465c48a8dd95626b5f46c11b42600968d4833b92d37e0171d361e8ee5461f5586194d48c876244f3c4965b1d5d662476a988087b354789d71d578e32c81be7ae32081d221842f78809aa212b27553e0035c00b584651b397be0133be095c753d056e2216ee0d008fb6c26c3c962ede59daad24e0dc59f4d9c194b2ae042e0ae47a703da1c51a56e2a15107905db217ecdb98327f4f5b2bb81afe1ae09ec796af3683d5246158236f93a3071c42d760e330c6694ebca741aeed94d3073f1d0c98fc8e109c7e23e4998ba18c072fc15e8eb9a1bf21ea919c9f1aa83e3f582351853b94829db890b228435aedb3ff6104eb03b598fd78caca3e926ca368a0f515e87152b43c12f3cbc8d30bca75f3fc445187e06a3ed7addf90c18586715b7455c1926fd89ea1f58469df24accdaf3e8a8d0cefcf331b90aee5f33b5bec34af35e7910301ef592231548d81cde6f06cfd1f075ea66e4f3b854acfc6a0ca910231d959c9332fd9ba8fdbb50c29529fe938de2547af9107b980da2f1098ef228cc245ed9c54953f189767c0c9e2e6f3074ed5be5ed8755f2d1079fc73f2eeab5bc89ad20867b961dba37da1acf9ad1294d0e82d861054ad42fef5e6ff7434e882662ac42bd8d0d035dd2e2274ea3f6dccaae3568919890548357f98c5509688211d55e62304815f7eb7c2b42471df6f2f5bb4c0e158d2762bcb48d8cfe08f34b6eda5f7c8d69b678341325bd25851b15b7b1459a28c23437a92bd0b801dd235a23612b689570afb324620bc4df7fc3929ca04ed034e3fda5cab0b40923c81ed84c7f1a0098285bcf13cb685681c24cb544e61be9dd4ac25165f6107cd4f0e0000b9efdeb11a5d18ee1fdc2db26a1c34dfd70ff4e61460e454d6c3eab99a522ca8fba2d8b6911a1d6b3e91d9220abc81266f429e30cc1ed322462b4b6cd62e7f100fe9a3b6e9f0a971db7bb1ca77ea74e60f6a8e997f997fe3ef07e6fb2e6af2079242866330f33dc3d871462ea207a77a9f76c5f40334fb9bd30717f2a1ff8d66fb4c604ff9845415ad8f4efeed38d7525c5f250b33b279dfe13e29b4b583fd812faa490be57c446d33607f600c5fd99f33721ef841b74639ef4845323df29e810196eb6219ddc77e46801e9393c03f7dbc7506a34b0f27930ae0ffb587957e800db5c49ebf88a4fb2160cbbb3b7746b541d29915be91e55cc87a1605e09b7ad9a1a9ee7be94ee3d6ed970c7f8854886bf454dac887e12a9a11a780d4136e3dc51a007fa776cce3bbc4496a353262ec82cbe67de369bf63c951530c4ec1d3cca8404a6f0708140774cfa15b91b3f04df432b1e5b02a282abbda07c90a5def1b96a4e1f9345c5a2a084d1c83c1904a26d7a25d172a445e8f2a596461b061204f2f8d985c09f16628d7bf3531832ce6d06873afe4d8b3ca8a9e52c8617c3431d60e664d024a679c3f3fdaa6bb5b6fe7c66d1f56a35a3cb170f359ba4bd35e9d540a1beb3e15dc6a12ed7200c51b2dda9cfdce122ba1e3a561ebbcf9412bdcafdf71491dd646d94469d1a7d4ccf6750ae3ae6060731ee4c9163c73d2e2bb7fc044fe074823041c597877dfaed109afb8cf791b40d49cfe14b730f05afeeaa0426a994a7b82bd73019b4ab8c2d3bedb35e922302e3f9e9f5a4306a67d7fdbbe56b49ae7c5447a5661efde31708b0f56ad57a9916d034e479c79eda1934c18dee2d4bf1711325854db9772ad15c4630bc20d385616a9fa09f862ad440671a2c55613c88267185a5977a0cc1248f9cb640e50ade4c3295f66df879a6e0faff036b52a597e4e22d605a1174bdd18e8fae2f36114ee9ac5fd6ec252d871ed27fca85515213e9aee24ce425797e20c51b6f140a29a7eacb3fc6900340797d37f3a82c06636166287698e5caaba16667e89ea257cc43f131e0f35578f901c87eb85265ff8717e4155a6d51d7b49927aed32043b4ee468384c4480575eb8ea1f32b0c0f84e8596936f6adf7f8163a01a5883f87f7e2bcb6ed70298489a3b87c3c234ea43989857fb1b98c6b33879c7785c994591a6837a3d7721566c2a7b8e2a99ee30a598d70bbea52b6f481e1117a6a43d2b09e7c55a3c182f1c63def16e672fedc7b97c81974bb64229c1dcc5e7546b28f8c0058b74cf6fb4c02e0dc8b602726d3a6b4a9d4fbc6bc7cfb3ba60adc0eab7a1eaa948aebc19eb6c40d148d6b61713dc7c30e35e17e852751c0a6d7c1673164b97e044944551ca1865b9783f1ae2f0560272e568cc3b6dd7049ba805b0ff3a313dfa3d7e5227bc6759762ca1a195b650f3b325790158b5f513dee9430730ca8940db57ae3a59b260b63f795508ccbee6d822980912ad33e2b282cbd164918e3ac1a5639e4bcc94ccfc8f2e3847ef3ef2115d3a8bbaf36ccb6210fd6319a3739adac9926a97655659a0246464812b1d916ac4b9fc5757a4174ceb23c18f967d1e657e495a1cdb5275526d20f10958dcf750c2961ed68ef8cc6aa7383babe091f39b4636784bb402fa3531be5beadd1e510b4a8646d0da411e506a6627e39dc5403d4f036df0c2f926c8bb8d0c8b9f48f94ebe28f6da230cd52f6483dfc9211259053cb0ee675a57726bc9308e539360deee29f13e254b947dd1cdb2ac75dd68e8a15bcac1cf951dec81222346cd1014c3eb4c17f8e31a79200834e1ddba21296ac799c5716262ecfe7b41f900356807b6302d40e30dd5bbffb0aa8d0ba3355984b70a738a4058675eb0e238bd145abcd56d8e151b9e9513e112fdc37f1d792d5beab5143e3ec5642a9eb415002d57da8b02c522312894159bc8f8dac25aeb0cd2c463a599c8a310105eb52dbb4365339c93e83d97bc13ae7b66d6c0dd394e782d842cba7f3481adab09c7e6dd86d0193d6cbf787c8372850aecb4b6b5468360868b37cc69f4742903bc4f6884112f0af5c728b50fe0072688ff91256702bc02c884a81331243839cf6f6bb74f6311d5fec87ba6304922d1c4a0d0b144c52b5043cd0930b77cbd99115d8058ebec606efb7a362f2ab70cc23b90a271cdcd122f703c0ac15be2be0229a1435a10d8b02204beaea3860d9a43b44fa938d2302cd4e2e605e9a04096b1a54ff9160cf109fa6b568cd0c509ad69340e7cc4009a9063598df294e60b4cef2b2256fc0c89e4863928fa84af48c0e96d12872cb1dc042ef07df54d7ba117bde9b43f7488f6d0c299256a74f03655c04d3155f004836618603640a4eca739174cc2ac5a8e4e8aa2b04a5ab503c0fd5687a2b1197e751466128ae74655594f72a4b0c56e1371a64fa0c27b81620a8f8aa90010f310a40a7329c54c120240d4d9ada15e268a384ed9aa24689c1929d2b1336dae67bdca363678e443bb298af9fe8c8a10f99124526e9dc1394787c4e7daa4afbc83f166e2481d60cdc5787c224baae5ee8d902ea5cf2ad7b46843a434097e05468efaf596e96b8e133beca3c2a7f63afb83407c0b3a07947072113be9d355458b72143fa8ad1fdf97013c868c02d7539fac7cb2655edf97d433734a3e7f71620337db8a635c3869371b677616a3fc8dc1c911f32a12482d58e4c525763c09cf9708ed2cc574364f906031e89788618235b8dc764cea68167fef9e7ca4ce9a07826b02cf9a683623bf7826ff961b244307f8758bed8005b5d024a60c772795a936f41c982511699006834607d3ca5bbd0229df99400c0b5c0467548c2a58bd559d1ae37d9aec0bd03fb92217340ec383908dc56b9c871a0af08685a1af0bc87121ba0995f5244b9ae58ddaab273c83b6dbce02e44fd8ab0b048b2603ddb2ad2b95a5a8ca625e47fbd2183f4ce377414726eb33f49dde50a7d2ec979aae931c82bfa9d17d43b0b3b7104707a15dfd4bfce3602be94674155af975394296c554921075f3093cfc70e48dbe01044f8d4c8222ac19b1961dd66621767d287de50bf424adafbdab48bd8eb834601407fc4f708a99afa172072991fd6c8b3ea91f0a0ee9554454a10f6fb01882944c7b01c36457954055b7a60ce00ef24710b6b38d0663468a0de4953257cdd7dd0ee97c264cc5f318f2ff1178bfef8a264a87c95745ee6fb0dbd0e6c13dd5f604c2c093396873f38e85df949ce6834bf1ca6d790b9ba2c8d446d1cce166d89fa4c39cf931626acea0707f9f468a6a37b616d39f2b703ed23483da9b4663f1f7263e2b0428ff0de3c466bfd0cffd8ef4bcef583c1aeb2e14b445ee6c7b47b9a70e8b2c241cb3ad4b4d6af47cd08403c3b91ec40e0876472eb57a8f0a7c3626640e1e9c048acd5e98da6955858f073b284495063305703892f531a155fb8c86fc6913b369ad585ee985159d9046a4da3364e656f3e5d6912c5f4cb5ebc050babcb6533e2958b5891b2d4cf3d2fcc5541e1faaced485a88a570349a1711a44aee6b6cf6df5d5a0892f295feee514ae97f0cf0b560425f56773bfeadd729fcb42f88d45ae336ea88a8be8148face538a6158a1e80111d0b8adb72b4d90d60a611593218fc762369435ed8c0603ae458a16fb386c4c31416f11f197a913c955fe003f5f1a9f486b7957729c72671ac80454a7128226658eb3788c63ecf51c2783b5c382c5093a3822ed502b0cf6c67bbb473e165d54afc93a22fc1e4ce6536875ab852b3618b6f69fe6eb1b402d26cb834fd66f1b3ec5d0c5a54dc14c1819c44a7e48595b318f9d0a15e65f96769f139a56718c6ee39258c40845b7d07fd6ad554027539a8fc9a1d26275fce5824e7c419b573ec4870533cc09b0b12b1a002769a45e3399feb5e184fd3dd9f185cb770a3e7c2a0476c75c2843bd65998ac899c56bf15a67ea25f0e03f317136750b1aa24c58298dc06695fbfb418da9fa2fa25b2e04d490b188ccbeb9fd0cfdad625ee405abd8e17f94e6d02a9c4059664342101e8137aeeddddd26aa7fc355db6ec57ac0dee3dc05fd982a61c560b6cd76caf2c38f6a8d9812e11254bdb825a0d0af5982c271602552ac56db6ead067961b4c9542d05c33a56d7ad23644dc58a6047b74fccb1db49302b3db187928653860cb67903e1446835ae00d50d95e7d79fba848abd14ef9e15023faaa19c7767e82045aefcc996f75c2e3c6985eb3ea9ba044a5580f16f89f099706723c37846eaa67fd3535b40837c5c257ebee4f47feb8dc62323c6e8389af17a5b775fe8326fe831961f6743f3f6a382bdb230a045a2480b4566dab1926dfb1d3ce3219fc520d4316559ea83276ce24047c88da22f1afc88f38a24a87339257e10f8688021fa22ede1a5e1194be4f527057f11b20e70d5b0b2d7f17bdb02f90c940e893d3d8c43ae4db978888177f7047855c56d6d283020c6ba7866a9d7855b7b7d46106ee3a5cb8830f8379bee4afa1ebb84a0e86c6cd33fcbd39a27cf92e87ac93fd24633bf4b3e52d24e036ce7fef9802b6047e30d951d8b1b4d72cc1dbe005f51fd3a50fc4405c766408b79cdd47f0c59caf9d49753cd8844ec9d04acf4c28575d5ec0923061a82eef1eee41b88e03ab7d58640ea16099d984aaf0739517dd17c2d477fe12b59de47d1f385965d0198b629ee3dc5b893db25cdff13916764d8e2008be4ef8376f10c1ed91fa17ef09676665580a3548462cef156c14ea1e4deb45038752b1153f391c7f215f1493e408fa1d284196e25f924660d7157fd6570bf3a284efa3a968e964104312dce17c614f7c86218ca749b8126206efca0dc9ca27364eb2d0cc8bedd08fc66bfc254b7c41ee5bbb4c57ed1859a51b9fcd3b182c4da8bd0ecddb01eefb555bd4411c87a17d02173aeb24596c39a8738a6ef1051448b818091668664c40bb1cd5d5076cc0229dae0d73f428732c88cb79e5264f59b39ee4e14e6125376c81e3b76834f182dea9ccdd31da06a7e87985638c9e8fdd2fb064653762351497c6146880bf4bb4b2f808ca160df1b9c21c5d56db37244bb017b47bbec609f4e68b1bbd30956be31a9caf837cb40e40510585b6f99533303018b9687827ea8c475eaebda9c8f65e6f4de0cfab3f6a52c5cdb3c1889a269aea61b17e52ca2104e5118bb7cd6996fef596af4faaa9b103f86c4643dc6af6b1e5de964cff1348f06e80d46cf374e0e1f49f55d25d35a1aef2afdb72ab15b9a4c0bc4d1c5d9ad4d02596ae73b5515722d85993312a9f8c4453fbf901e87a6b08d4f9c43313ecfa5cb49f972810643bb4375f0c85b803f3e139c51a621cf9b9fb7bc14c8b39cd3f8c06a736adbf17c8dab3edc0408aeb1d141ff7315b0a4b99ec1692d5b31d766ae7875ad3bfd2d28e67c1c2be3cd2b2d27189ee89413876aec4f9a05a1683be8a41a744a04cd458e2fd3703afe2bfb60a480eaae2e8a6203c048757611d2a8e56d006452f3bbd8d88ad132ba3d7059f6f50e30390b5337e1de910bc3da2344c1020334bf2ccd4fc5a387537bfd48c0f9ce99683563712924e40e33d65ffdede1404ce802a9579261b6c5c39e6e29d28ebfe243bab0b3aea2bc93f6590806dad1440e2772ec8886e7cbe32631a056c22b016c71cbec5e5eee2bf798c975858800310bd690b20e374ce6c35cadc319f861743851c71a6a03c84977f05114e2de317b7ec5b5149d83a94de1ac7976870cf2c541f172178330","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
