<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c83bb01b0991a92dad855330648addb3de688cc4d0daed6905b749562f6445b459d6e1b955f0b86295c57863c8675d8d665152403b1dc297457f66773c16f5b289b00517fe2c22095243cbf0d17c84d1baa8a355e8a83064866fe111d62601879ec1a65435dafcae2c0dbae541d7dd688005d73b2f1fa9b136f7cba3becb1be1cb5fa0f58a97df75a04216ddfe5376907ecb3c0a9553db89bf7fe38ffeadc8412671404962ad2da7ca8baff64a6898a4b904604964e26bb9ad292f7e1e7e59db3b44003c4cd8604f76365bc7f1029d535a3f041913492de4988218928a7748c1c3618112f31f3e45ab6cc9fe58b4144093d3da5562fc2655540da19319035b30f03778645178a4472c5d00768114bd39daabf7eb74eb1c1b622d7897c101948cd66b0b92d9d3108781fa5a75fa76dd53c8949df478f30a6e930aa77c13a3abb92713acd5b1ee257616ba86cd1cb122b761ca7d2feb4cfb4623ed263610ea1da0dc0e91f6f47b2c5eb136f91ce5de87a4d2e8570c29bd371856bd963defec5d9a8785c4b4f3a3132b25acc526e1f9002065dbace498d21f659c635ac589911f6259b44652eae2d3c0fbd1d122725b18500d4532a1f889b13adac02153a1f32943a26b963964db6777e3721ec54310d8d543e6d92c863db4675beed97dce25dff6881b52b1d3b53fc74648f7b7b3c70ca39aee3847c0a631e2645c1687207a459e6da3bb17900b10d20eb68c7852e2b3e21da6ca4f1095f78a1c91d70b904720ff37fd6fc180a2b0117c272b86964089e7885a37801ef8cefcd202de8f327caa86d9e479bfb64219d65a006a95a5bed0e9a1d0dca064eae96cc888b2a4f05af20f6ae6fb3d72f22c9bb66784973e6961aee70b5d15c4267e417652a794c1fd421ea57e43e2cfbeab3b260ea3c52b584024f16d034d6a36f59fae660dac60b3875d192bdfeca6f2a86aa899a0a2c7878e6636af8109921f8c63a54c0ba17b1ed8b72cf1768b93cb17c6c075ee959b9db2711d9397e41b609e3c361e104d1cec9789dc431827f5f8cbf5f26ed99b6235f57f52bead132043d07dbfe9476a3197f3e0bfe13075c0a13e14998e5cdb0bf797964132947b37a8d21e27d6283016b53244e2b9e4a671ee8c5ece4e27349fb8493e51ce2ed44ea7a12185c05710a5d2c277de228801ea4efed96bb4088e7886b4c93648b28923aa4e2225b7f7846dfbdf11d20ed7ca9b6400b10d56c10ffc13fd11fb646500c0975dc700a2313431242c769ae5b8f4568198d83e6f85a36480e35d446f5961a5e43ff677063920c75a30eda076c8b9bd582da12be3aee11b012fd369c313f81cf72a270f3372e2651a8ee76ad4b84e8692ee5ed0a8db7266f352796e8d8833b8be4902e432fda9fe4195e1a6543022fa31434b721d58650819de4ab043fed77fb198382a0aed65d0135d520ec8c44463c34058c2b3672d521272d2b492c4b1de96bee4a9be93fd553e43e1a30eea8cf0ec0fb82d5bb2f13e96e09f054527f2822aaf156f3eeccc5f5d1a1531ecf6b27368d9e68e6480bb6cc12ba41481a503f870253d1d749a4c6c8907e175e385305d1adfe135e69260b2de0ef34e14abdc9559ace92f4a4f8e70992d57e7f07505a143cb3bfdaff466b5d8c7ebde91aa9637f3fb54df32c6f3782d847f22b56f5581e7439bd95edb484b2fd421b5230c915d7992bd00757a91301a98f79fe353758ebf0b62a594d816e2ada8981cb5a669c116a5699aed7a26bbfb4b2ce12ab368e78cd1affc0ea147a49bde5e87416a13762a2161d1696ee8e77a7e4dbdd8ce5a9851b1a5dcd724348cc4547f5289d86852a169b5faf8b8241442b441ebc734eb33659b39c0a2ae962abdd01f35cacb66e7b2bd5880ef879bb942ea2a043936c29717b9a17815f92a9316108905980a80acab6c3c531bad3ffbe027a038b9cd8115f06f5cf1f139a078d8d76656186db2deac7e3dfe55efb0bbb61a8ff5b262f7d668f874ea53be15355b79fbc39f0850a3acd9bc5b5b755e180c1a19807cdd4c802b575fc379cb5f280e5d04bf32535af16523073ae10b463a5920a1af63353cbf0cc5755cb3053dbf016bcb45d3f0f5d763aecc13f23da755c5e902ff7380bd4bb86a5c973fb509e7bca8d65c51f8b057fd036ec2227251433f11485f1f4c5a6f405b86d6ae26be9993b76c0b87a770ac51f881c1a6c450cdfdb9e7991427b9ce0211c01234cd8d58244086781ea778eee63ab5925ecdbf399461b0c6a81db4f303f28e8cda0bcd75fc3937577a78320b8b4c755f5e00c79f6b7a3dad227c6bed9c565a7428a48d7578117897b3f0e17a3d9fd58f96bae505a7203a40c7f353b93a684b9f7cb76c3cf6cbe2be81249f4b505da156cbe80fd825e4febb6286b3204a980964d3a36a971098010c56d8226f3fe78173f1e3c5af645c7e9eb701efe7233cfbfa72e66a6c4ac55b583e36047748cc91621fb0bd6253986a05852136e524d76963a3a1fca62830db9083980ef022beddfacdb76b67d98f940270fbe73eae30672caff546d8e2d77beb53bb754efc634dc36f012b5c3cbcc8c035c29a293f816502f6746061f43c2c979d2c81c41df0b81b0233b0ae56dd15c5341f960ae08b0cafef45045f92f85cfe24ff0f813526d2c869b6e858ff3576d20f62b450f70fc80c91c5f6cdebe2c8c5d78452ae2eb89e42db8f6fe3fa3110e06f0a3331c87809fdcc35b0a70ca75019f588871e1dca13cab38bfddce39281f3ed83a9b765f3efaa5765cf8c29e5918acc5191cff945ff9b3759a32052387f92e76853ddd70957a211e1a7160d9aded9588b4b78b170c3d9aa362705865066876c9b322bba64db4e78ad8a000e5f86f8d1e20c7c3c32656900cf452a7fe30d0aa2c11860570ec00a73369280c3df998bbb4d9d4ea285f991da3e43a67029cd063ee97b8b8e4c01ae072f1be75ecf786c71084c7a498e325fd53b32b02e379f8282fb285fa9d05a411d709631bd06cde52cbe1600233f36b9c45551af943e616848acfdf001c7f89fe6aa8fc0835fa3a36fa10a8be008e7833f6ab1b589a4765f1818595a52b9dfca010853c34b0b4c707fc4ae637becf66cc142ff817e91f99242e99222dc2364ccecb5ea5d74214ba08ec453578fed372508830c23b92a89475326b327ccdf4bbb750cbb8ecda86e8724ce2efcdd9e2a993b7c391e6f8af2974013fb1c0b58f659f7f7c6b334091348cb0d61c8d3f6f462cb86c56a6007c2ec07716276544817385baafca7be7e37ac21a56da0ad24cc5472ef17ed13da8d815333ac90d30b6b41513d3c3694eecc17bdcd774d9da2dc1bc251d22102fb807a1ade70c4464be94a1ec35f5fc7b78fc17b2af07895e23d979c4d3ae706827bab305a627e1a4ceb7f40c702e2083805b5a1a870dbf2d5c1b251062ce5d2dfe4ba27dede7d5c695ff904622664374301d66af9de80815b72ab84bf8bbc9cc05a9daaf776505014f647b5ffa471e8f0183b137739462cd374214f851ad68c39b3b567121543d9844fa68c55261cdd213ad308e28d0b7ea52aff5e555d8a5e775871a35b020c6bf1fa323f1a76f0fe5023f60c4123de7bfc7b6f612a16131f4a2d716810c4d16916dae701336daf0f496aa880657b0c95c0e35e25e499e9d1b43571a8fa5ed3939ae935d99ed30ddfb3e686a4f75b0bcbdd51d7dd67f5da46e5d77428215ae3937ddf7df374aeb3a90536fce7081f8c1d723b4846ba65c343f2559b948bea8ff904a759377fbb453d21cbba93b5919d8ce193ad3056b10889d061cc453325e8623a99c6a5902d0551c675e7249c8ec67c6a06ef02b29e0f603aca6ff6466cb0e0deaee820ca59da9668b55459e94d0b6c1240b98da32ef7b0de0c0b04d9f1951f402708900e52c01b23869c45d18e3dad479000e7df0398ea2ef6e2612a743b9acbc3d459b23cc5dfb44a2c81c3cbdd47a6ec2d6221c187df4d7e4e03eec5fe740d86b8067648892cd5a47eed3bf6141ec73de88a4e9305f4f4f0a55848b77a2af9010de173889525a72431630dcb461750fa0dfab6e752d54b09009318a40dc135cf317d344790a7024ceeea162a7b06e43f240147d0400423367d46625bbf787c4ba70d420d64b460a8ec2393f2ea510b74378ea2e8a1bf83db953c18655049cf5dde3af89ef0025d4bda678463c69b67ccf2ccd5aca5831c6df3af3425f9b150a60b97c7c6fb6cff97578390894a625b60e6d8ff658ccf4ce866aef17b53638a0d5f8ca9e986a77ec5fcfe29c6619287b241ea361658ddffe59ec0512639687e8949a8ca8e3d8b0c7f2e1442c26fab5f3ef6aac06f8f6f9bbdebec9b801cbf220c247848f2a7f2b5acecc1f72f3c87337a213aa7b912093fd2409332cc340303a3f34b864d85875299cf81a1d77ed30364245c2d19e674bf70e37f513b76e9d8ff837de93e9533c4008a9460dd4958b9541d9e220987e77968335609bdbc4e38d1f46ff0c3739c9f9880cc61a1a24114bb451d4a3c77ed17b72fd4cf07d7076d0ba8e894929e366e1aacefae75e26e6e214a3e3e3a1faf409f938fd1aea2774af6ae6fed6417b173dbade561481e5bcbaeaaac1afc51b75b987590493a0b5d248783defe70b10d60152188dbc529c44567dc3b145815c483bda1bbb0896ee1e05a98e5f87a424b905ef8d1c4b4ce20f019f0b93c4304d9e0c27e75957e28f48acf848a46d7eeb4b8ea069a80da25ab361b728cc5802c602bf4a20190e3688cb12facf97a87c1aa5d914afb221d91698e3335f23ac1c247c66f68c599c26aa2191911b226cab917bac11442e0e501bface6935833dac770d65d91fe8da37b9f7c6b11528ed07b9e9d2ffa4b0fded9286c1c4c27a617228236d18a18f37acad0378bb2bc0316cb05353fe2643ead872ed0a91dcee19bd069b2c654e893956ff1f0d610880ea6103e7d6697b231179676b7082a04ce6bf769e8cfbf6a8a5ce3fd53da825fd79a92e3613e75b25481cfe3a85afdf85041a84dc3de4f2e7ff3b1e9ac1d7556692eae2f17b9989dfa3f837ce80b6a2f7bc9d0b14046be21e62853a5de6dc1971da35d54fd57bfb4ea2bd3bbab96a8e77d91c2f945d11e7a4325fd95c847d618230a11f45976b2e6ad20f914945af60975162401887c26c17b2e0dab275510955960fb17668f4f06a4486b3486a76718a2ff1a384132f8a8094a5e979a896e198757e98b62805b4e8a0358bdaf5513eb32b6a0fb601ad995b6d35e511d0b88df7e4415d1bc6f4af0fbbfcad7b1452164f2779d685e4f8cd24e2951bace3dc84a98fdc8140cdf8cd5368e56e81e8e07f109b16db322eac346319af0aedc6ba3aa3891cb2a84f22ae5eaf6c68dfbd109abe36a6131432bd8a3bb93838a98971814d4cc2bf40b5cd397ec9d150510ada0f0e5860ce07328002694cd6463882984f05c37597de08fcdbae58d5da109632bba7061d075a2ef355bf6b95cdc256aca5ddc701ad614bef4845a36fc603adbc200450e4c11193affbcd821ebe1bda6c3cb79e433bb3667669f1ded77a1382b3cebd1c2617cf98f41464e0705c7513715f79fbc7eb20271a4f5d8e47a2ee90dbc5f6983faa8ff5793d80749673334e1fb18dbf613d7c1f76a91bbdf262960bed919727c6c727ca64826f3f1ffdc985aab0a21a882b44d2046235fa159523b49693a9aa60a57809d2575aaf332b6636496ac0ed2709337901a28c46c0fe89c86baf5631dd3ad2f6a07d11206b5a4738b24351d70652c38935d21a77f6cdaa74c790792cf8986ec76b5eaeea3c61f16152a0db050cad1ef658f6b359090fefabef46999499ca4516acad97b9b14e1468c2bd1f42d47dc0f6d1c24aaaf237cc207b5c61cf322514b05d83abe950e275b7979a98826ad6ae3d3addd3d2e5f38f9b238195756709b73f2866f66d9fd6e14235bced0ed62bae89d16e145ff378e3c3892e033df153c73feb5646c575ce986ee9c7a513beb9b6713ba9c4f8e7a9f34a113dff3253d62988341e375667c1efe7cc0e1c1b0d5c551374a563e1227656389427195f2012e55bf867ff8d69b555cd684814e6a5d42b5788028929c6709d07715805aaa4ade6bcf399713e16ba6f06590030b90886c0a3e9dd12075ec421b0031d7d629bdbde421d416d8cf072c442c9dc4af80d299aa8f36cda3933416d0638aa6b9faa2c76dc6ef3e39947bdfb4fbcc4a05bc095a0beb90388a84d3f9204e0515ab01f820475f27f3064c632c5564738a4574fa706567f03e7aa5d709d735bd3d0738c44f62439e4980743b687c82f96d4dd26b4124493852624a07591d6e78b11a37ad48849bd28046931f7d33397f361926a99eb84c9620be0724f16c8e5d8ffcaf1ae8187752d75b43832ca626c41247d27fed26e944a0e22593b74db33eca53e232781c759773f17e22a8e43e18865e91e5c31dd7ad7db641edc4746177eb0839d62a077a6db489eea621f5005ce0dce5285683dc7de79b875920fa9cbcb01f80ca3356b8e88932b298e493559738dcb6e0eea849fbc33999bb183aafa9eee2f63692ec954ba12e02db65b96115e33b7fcac6868b42c465f15049df7e5a868ae7f33e7c1bf04c6a5023513d4b03ca3e3fd08f0649e8b6481a5c721f8581a4fc5de9a103f81986dcce846829add0a581471e167e86ac5a375c2af31ef989d574eb6d770bcc345a13721f7b14726eb78dac1fdc276056e3d534abb7a5737fe7f8195842e2f7c5f49407f8e4c0f0efccff57f062087185f78a38d2958f948a29e5ea2c6c9c84ce96246cbe7dfbaaf0781c97bf6a111191752d7f11e89741d0c7f169ede679c024e534f59dd47f371f6a7102609904293343079e90dc820308466425773a63789a2fcdb16cc0baa345f0016d449ca670638b09cd658b1d84332fadd9acc0f0c875369d6c870c65c0628035684fc07b4c3f15caa38c1a4a27bf09563a501ca9411b43e35a5bca77f7b1595efa8a04564a945d4947b40a7e65f87ed5107a6aec96386ec998521ffb69ede1895b5805182b4107806e7f0bc2d2f31d2d273a03c785867c9a51ade3db89587110e2516cc8cb04f4ffb82176a63e3d97b40d76db52812517c328c1e6981a9e8338061598d141c87e16f0313e1909905bee5cfd7b687550723266add430d9471e4085d918ea173c006f58e9ddddbafb1c8c2161bb899ae26b22995b86219d253e6bcdb35f5786592098df6aa14e828db2e0095c1782da40ba0b314446399e8ef01fa5354806922b930342d798b62f38330613783962732f4acc5c1ffcddf973c098eb7c59edd1aa2c450b29e363119eeb40e1a29364b16ef7c9817cb026c9dfe35e996b95e24c62ff9292179f3577580f161a4e55031e1a864039c4e30d2dd5f4937b4d31f43dde9771267af20367b64a8c79336f79c20d701f7507147db94569a4186e95cbb7880f313ed4bc788be548af0a61bf51e3538ec1ade418a56685307471af94a8d1e148c4f6c1404848262c535d999eab6cb639f38a1f5a751b1a0caa5397aa2eed0d097d4a32335371cfac06d1d190efdf234593b1276c37cc9da023c3f753c4ba52b30bed700f21afbaf902e3b5eb7de228c418893d063b472180334803a8d8214585bd0a0ad145f6c591ca6c904fd843a12f3d821b135eb7468f6d412cd255a97045b8906a3a18644a6f0edf360a156511d938f20fdb6317680775feee024ef8abd0d24f14c7c26e5983fe847c19fd0ec6ea401f46b3a1ae8b8aa36339be23dea7b88dfdea79f83dc8e8fe8eb25015f0422d9b7ee9958831e0ff87585ad5e2f3b95d202df13d44669ceff92440661d8861e151b9d4690217b58b77764eb67480ab81b48c4d794805f5bab917114ce6d4b68a5081aa10a9968f900a9cfeb37b253a92b4e7b433d0cc363da03618cc8c5426b046a7ee84a5b165b9d2adf2e6ec00e70fb32c6c6e25d797618c45dd7d1312810d418acbdcf72a124bcbc73126d477f15fc85f31f1fa17f7bd7a9d1caa70316afae97e973af4edae72d3789f41cbbb69ab2c713c5f4be3922fd2b480bc3435c7507461a158016326ce888fff150e31a5cc1c4d14100d9019794fc04bbd4c790ac64d0bf2ca3fe1bc7b98b7d00d253cbcc9ef32e2285159e45ad09096b6b27f393305ec170b73a304f2e0d2fd795abb7c3fbd8cfc5055773aa923a4b9fa8f40abab6ca666b76c867db280e643da52373bd1175a20ed6f2f6f7d8b43d899f1dbdae7b2a38dbbee45ad5fc9aa9058a6d13f310cedb7f17c46d55e77eaf6df587b51af0a5fc11a006e59c02322d822a2e78690e05df6ec92f5ad0350cd5f5d9ad1acd238433a9e1039240b469b3bcd7f696603cbfc402f1eba856a863c894c65a82aa5582e811cc44fd09c15f2c142ddda0315a3f496dbdd849d8131185d139a9f8c06b873fc7484b086788a0dc64fd2d3c530d8967eb7cb06583e4bd1481a49bfd8dce115842eef3f5d772dda6bcbe803a2f6f248d195acd9aca099a02b7ce3fe6aa828e28d5f81fadd1cacdc624211fb00f5b77b01f782b9a23e7d6233688ff4af864a836a97db49585abcbbd8b01c035d1a90dcd482812c42d2e6984d8e9014f7437d4284cc945912aa7e3f645e71be0710239d421833316c13bdc4d79fc038b32b41b9b39801bdff404b5a82cc987e68f081b6666835984448922b95263d668ca447a1bbb91c8fcd4831ba3151096d7351a9d657c80ff66eb2c29fe6e6a4b5fc3d7e425b2c386883c5da9e63878fb07a31510632db1f2531d60090d1432570f43d0a616d2e862b56ef0b5d0405c84428513bc79487dc712d28776611f792b4e1ada36f35a472264e6ebc61b871e559c60e07ba0741059717082e59cd4495a3316633e5a972d4f13be71c9bd4d07f2bf1874dfc88569f8fcb991708666703d1837f83c01632cb2594f299d731d5d5cff5ad239c6a9cece0ace3df37c9b3523bbccd8e321eea7c0506858cb1c65f460bb1ffcc3b638ee0f8daaf8e4323772a5c9e6132e0068513dffcf424f2111451ea99baffd2348c3a10575003b2fd2114f726b05999ebe6d9942395cb56045622281d0dac8572b3d1d7d721cca3bee0bbfb6fc6620a99482bd9eeb313ae4da0dc773fd3c7b3d0ac3ae6a05c7bb6e83d3e5f95818ad618e9add6ad38ec37efced55c62c7e2cf5bf34bc67b024e8dad8e7f5f05c6fc54a9bcedc7cb52a25c38b1379a8f1ffb32d0a6b80ab8c1ef9c74f0582446c7bcbc83e569bb18ea01ee79d430dce802607dfd995bbe9d6ace9407100e6a16e736bdc6ef6151aaaf89ef2ea2e8c4e3859bacd264742289efa693ec7387c867a8f92635b31dd4302675b6ddf5776c0afb58e54d39801904b459a5caeb1fed3bfe0800727b1ed668e51a881bfb3d83b57e8dcda44d2c3cdfa0eec5a0340587c0eaaaa4bb7a06ea3bb8ae2ef26db9d4c0a3de2cdacbdd18303c3dead13bec7cdb62f3034e0666344d4398a5d992c77ca324f9533700202d5f3a7d118fe75508f3ce28833c6d76421225075c7e97b64582f7a5ff8cf5232016d2ab5feb9b9f3dc2e4cda2ee92c00013a614beb22f9edc9783464942b7e8803576d70f10eeeed83aabfe232fb915d510eb3cf50d6d06fa154011b13aaf94962338f75f8ae2543fffd8efeacaad9e2a753e77e74ac30660f1ff9e79de9876ea31178e5fbc405c61c82dd280e35298572a71c186a081313ed696cbf5b5938b58c29f1aaabe8bc9cd73b466cd72cd4bdf13fba9df0fb620d512522a23507642b1ceb5ad08166b5b39b1685215a516f422693608da688716e0897fa413a0f46ab8338e067d054c8f205df78215d9c063bc092fa385ce1ea472ef316bc835ecfb6ba3870c9065177a6acdcd725684417cf31d7e67ff94aaab7f62c6ed4bb5daa8eab0d93591e75ac2ccc5466b5f29c8c962052b11c8daec639a9a0fc018ea70e13dab1d7f5ecbbbc2a4e1de59b84e9af010b085cc770927a7cf800d8e52a167c41f0375d1d08f8f0ff3731505f91759c7f995aef517a7a632ab47bb8e03d67bb2dce5594c1969c5767c2e4d85d74d9203b1f92e31a025c1b515e475efb7feb13f16a3fb5b039e92aa25eafb2a44369af91557ba7ed698d23b7145a815b5698628a619c426bac30077d00a25b5afb9a086524482185dfc6de05d19d44602526a534dd4dd43735023116f995a1be124a6ec14eed3b800c5900d46755639a33fdc92d0db753db92ef864ab46b904e096fac31905a9f3021e1ea1bc9b7b037641b490ac3bd59e638d847fdb1435a95f8ccc4a04901d894627c8aefc7947b5b46700cc32f47c421c61581220bb17f7fe36247b62c61b9b7ea705df89694443cd8a262e5abf2be90d234ddfa35f9e87825d6247e747b6cb551c00742a6f6e078bf6a9a789bf57fad528f6372e90373b639a2795d9841283049d471ac7aeb92ed49d4e5cef5c7e24ca7d441bbecf8765a2b6b5fdd4b82af9203376331aa3d55099c9fe2f132d3f0778acdc35c8cc108beedfae37549b815857e3a0ec6125f211fc7c9d2d76a844206105f72995a72ad4483a2759c8024802bdec44043bba947cffd24f1f184cbba69426ff72098019436ee8f855efa8f4796b23ee432f5ce09c99f4756a7a3026a3b508a7e2ababc3cf9656ffdf28ac37d3784489e543fa9eecb65fc6745536836f794886d77cfb676806a2fd92d54eff9822eefcef79e74f91fac0938b8c4f13828cd13381c304fac068bfc528dab17a40a8563272b513a4c1f7519766a2a87e95e52d1de636d0003b57819936f2247d50a68673ad9a5df452899d5b3bb6c07b8fafc7a90ddb68afd3cc75d9cacfeec84255e930226e856bd884cec97beeedff7ebbe31471a68ddafc3a0975f2515b6e751f05c7e7b7b35da65133b879d7c6fb791f1ab6fc2b1994c4f1e5cc00ef91a7d967e15d622bff107d7e301f6c1782fe155fe2954c392d89933fec131ee3b2f119cce7e0cb4bca12ac740d1545b61ce6c5c653042e19027e06b348f0510bd9e93c8a95be0f5ce2a342fa5d6435495fe2bbc0eae96dc38f85c25f9e93b4532c8dbc426b79253731afabd27d5d7b73827db3c06f1a13a7514bfa49df8ff275e66412016934648947810030eb12472794a27c80637fb55c9329323464ccb03a783bac900422a7e9ad46ca6137b412051b6f2979498513f5019c987750b14ff458a2289ff03537ad5cd56f12b17c3b2a672e55ea40836c5bd46441acb5d84e8f8a56953cd1b7706c3bc40ff70d86de0bdda44a1ebe83966a46f219c82a31a99501a6922d0cdcefd984bbcdd59140e71e17fa80e8657263fe00dd8ff0d166d91386f183baa3847ebeaf7b4442ad77fe11bf06c4e740bb5152c66dbdbe8abeb9d1ff4f9a8b207ac50f3c4993a4da6fa49e2c5df8674f4492b2f3a78cac618ef3637ce82c50d25aca4dadf0ad27541e51eb901c57134ba08cb1954c9836ba5e6c2ef06160cc2c3117597ea00b810344c010da2b46da03976d593fb7ae07cde08632f00ac02d17b7cf1a062c9516e1f47aee79d683af98c22bebdae3b38424a3cafe5983b932eb2147c29584d81e84ddb04fb3180e34116772bfcf8153da1a1b464bb5bc5b93582ac0bb2b0ef7a1989a6a70194eaae8e37c8a0f3bbdd26e141375849215051352da343242fd7dbcf884a494d1795c13dad902b531fb2ddb84cb68b9c4510c66081763e50e03cf388ccdf682105b6e1bd3bdf5318763746710ccf4c09374e83f21f61f0b5b26fccbf835137ef82d30d6c36175bccfeb0600c54da291a8d5cbeaad711de5f24e09261bc15de17fb96da64f28c947e4a892f601ec2e137ba643065063d25118111ca36e76421fb6f03ae4195d2fecfcb4537fc08e70511c3fcd58b33f65737804e8ca2b0a4b6ca1163d829b8dce1d36af71d3b4ab66a344d4ae1d0b149888050b9d5e109e0c551eed14c6cf285e80ca87112b142e0738e45d1d3616a3640eaf01fd87e4873b0a46b9a99a3f5e469cf3d673bfad96410ca6c528422955d726ea0c7b01ccaf2e80cb9ea44f72b3b6cb3044943d04ccbfe8fc1be4f225689c12d3597fe6f9e3e4e139d48c47245947be11a55aa4cf9ddfa48e1fa11278abb78a1c6a364aaaf4c79f7c3bbd32650e3f928d221b67d611e14f1dfba5bd3723fefd47a43e641b9c244909d70c8d9ed110f47e4a4a7d740152999679b7a04a8edc661d6806233facabc839390dff6ce908782807af04676884c895c821aec1ea1f5c1ff9051aff9f966e88a347f3ce264b8891b1791dfdbb419a0c3d767c35367a3e85d467477a0038f5f4f8da9a2db2f98f725d4de9bd275913b95f93f7e10ea3053a6f5a5146f8fcd32dd9080569fa04213b169f51b1000602f58da0de898c09821ec5fab17d0f76cde807b06fd5605f8e0774d51e78593c23e7cec2b9ffd53205a0a7a5e3f5197466d7cff990777b6c0dac74aaffe0751ec8070535731a7b2dbc2eb618b960a710560af84e0389576ac45e6db158b892cc1c44104280c557b71d9621ac8b70898e89e46d4de8ebacbda6e03f2ea07839bae911b3a34b880d4386e53577fe7e301339351a123971013e3b44b1261a1b3a7300d74d442ee5b5e9923dee678fbe41e6e98e0adc1ea0c434bb3b3f7d56e0ac9e4c71c4a32e3c63d7de29c6a49139ef28abb2d63599fe48dc5bce3e796bd7e1fd9d5ad615454452d76a9c8fa60ccd7a2a0732fd86a7770be70e87156af0259ffa024a82f6c3431ba0c65f7a7e6cc437273095b7ad683ba1f5fd88bea496096f09b912b8eb060bb7a47bccf35f8fa3346e2509d5ab3b879ecc3f053098f6d595b7d863f473bab315b2659f1ddc02d4a5cbdf3d0bb7010f45bebe114e9b7ba119eb0816921505f91b66577c5a3e03dcb1dd8c4dc1e3848ebcabac2ac02dbc83d1f81f73eb9860e2194e197a4eb1fbb926cbcd139cbd57344ed85fff58fd73b9db57e89618f1441c1626c69fc38ede63905ec1d175ec68f9c85320d73eb935fbe4863b10c16ca6f3677d77880075260cdaf308d173dfc00020e6844d235d17d6b4c302972fd2c6ebfa417168f698314544771ad41c4d37da72152787f605c84e656b3062006205765942b9ff9d388353594b75beaed35f816eef0c672da4aca9abfb4ba95caace6e391c9c91ea02d3b463a3d8488e061c69faab27bbc0f7bdf902c638f8df005fca04df853ed7380784849050b90a9907e7e55aae797d075f1b2b0678f8eafa48856ece13aa677339fe481223b11f753b94c1075c9303c36cae84c8e3e87cfae88d66245b7159621edfbb4e96f0ad036cb6cc4b299867266642475cd1c22b7450cdeed83de16322265fd7f3d089766f232e857eeca0a7adea9eabd4c40f7342a3d8bc878077f9252831d7cddec41c29ea95513f9717177c920f1e224b776505be47f26a3ab10bd48e24640de539c8f030d0dafc64eaa3a6dd6fb864c77957608ce3c2f7ed754f1ef911cab08a99db5e12097d568ab4dcda3e2ee2b4e599d58a934c85ad96412feb22c5daba38b365cf1b91c3f23be58c67be6b229023a4860c0a5ad1ea7e93d25f2885bf0ac5cc2bccc8f5a9c32e3c438b29f5c54335f9c754b93db524c14030603fe027146ae8eda546a20225b15d3a6729030fc666cbd65ffed297bf2ed6f73da80331987e2a5eda171c01aff62166be7b737c3e17d3b7bebe608318074e5a7b95c5160d6209f4cf7e9854a2ca3b832f7767b2bce0ccbf4cd3a0d0e33837b83d9e2201fc04649c43f0e80a745cf87af09f9eccbfcef5a8e4f4a03d1a737763b75803f9af6424fdf56bb5f21354882ee0c20eee26b32a9738533a936b93cec9901b60ae02d8505fa6fe63f2ef26438a4393277d81e1b045bc1d24e1be36ae478243afd613f70acd9bc6ce8ed195140b01827688a39da5f27af184799cb50e7e2bb4ddf8b1e4fbd58b5b20b59114dc5b01bd89d4bd4d13812c47bf95f9f7d902c63084eb8105857f31e2daff06566bf4efdcd98f81ae50b2a4fd73e0bddb1d6ab5a8424b6a8763fde904220cecb3ae8c9aa663dfe9f79c86dcab7099f3e7dfd1f79ce6f435850694e4f95864cb4722df06862484d2e90d726afa05709a8163f4e375ab45bde587e8d042b25ff0552397a23b669eb65c291035d559670a3ba4465cdb1eb6ff95666f559f710d9e7dd9dbf4b2ccd2ed6776564cb166084ff38963e14d744de9355d457faf862abd2e11a86009b0720efe6275cb21d177cc7b3355b7589f00a4dc633f8205eb219b8582950b6a696362d87c69b2eddb25635e9f58a474cea81976f9e0df154dd6a6f4f43adcb2aa163118eb3a116df0cc8c827b9ce351f16a7cf7ff38a2c543a16258d98fe7b5e7db447008c491d6ae725e946539631f418e27a97b69c79902d7a173f43e399bbfe98868afd8e2db8982f62bd117142e733902fc5810ba2ea7a531392737ab9ce0ee8a63727681a6710cc91e0aa814413962ac5acec9a06bbe7e0ef2a4dff800b7c835c909496d702aa04be59a4a4d0df979298c78ff1214f2320edf77c008abb982680e03add69562e4ee6171913262cdc2ae66a21df6d517da75a3a8401141d047bf19d2157012493f42faaeb2aa9a74bc94493d36b091098cdf204b4850484c0f4fe6e4d78d9cc4beaae03adf37b8c3476150322ccecb9aabc0daffa9b3ca81e0fd4f29a13909f92805b080b7b446bbf66802f88cdf962d7f5d9794360dcb96a5436f76b7404443460921980da75270b58e8eb22b392d4367d47cae57c008844aa758e1189b4cc6b73f1a8b7bb8286328ca570d0b556748b8da9377b4dc44f912c60b0be69c51e22178ec4a216c0dbe54685ee3c0d5858e4aa767c409e0b23fc6803813510989e551277f04c1c2777475dbe95b014875bb6cc359327225f37cb719c7a599f1c85652a3abba9166cb0c07d560e65ea34532d0fdc248a693d8a8fdaf84e5ec86ed7efcd83de23d97c230c7c8149cbdaa3fb7897e2ccfe3c0a6aa7c5f4cda79bb92aa6cdaab82bb9f6b407cf7facb092ab6444d08dfdb6b097e004738d90a4b6c961aad8e5d313f541217595c5fe1eb178bf5ab888761a10eb3a30dc77ff615e9927721df255243f456cea814ae54d5825253ff4a030ba548e17f927e3a05751add57a41ff9853b9ce17c6907b8c52caef03481674508aaa497f2d542117fcbd8378423e788b0ab7a7de93f7b7cefc18a77723a61165a13724c1374e31a8b80b851a3b5e34998ea77e19cf662982b57de05d29766102793088a8f61f09b58116b0aa04ab41bc8512da34dc91f330880eab6f29b28a4ea971fc2f59942ebff501f8645e3719b00f7e05088716bb29ca2fa25bfda3b471bcfa5941bcaafad0fd96d3e6f90ed14efb11f29d5563bbdf9d48203ab8b76c4fa0d1f525cd3214e4b5f75d565d72002f14514998bb72cb6038ba82449d105f2db39d7e4cc3a2e18af7f4f9015d4e91e9cacbcb1fb88970738faecaddc9d00150340945ff135b0ef245704f48b4bd0aea7d1dd21bad74c66bfbbfb0e78b2d616ddda429f21790527e0ad38eabea603f7e8b7dbff6f1eabcd4b2c55cb0229f0f05d98a8b6350eb287b9facc226705452fbfe6fefe5c87289f5a0447f81eb428320432be9c677272f8452b5de795828df0eec20ba6ae1e9f345373fc2453e9b6382ec98593e730b6b484b9d6fb5ceec6d06ac4130bddf9a486a9bee8ce8c9ddf1382cde3814e42604f5b106a4dd07d5ab9239ecfb88764c209492fc3ac0380765cc139e55e78b7d57bacba02469c5a1812a8c1a0153c12f8c52bed4689e98a5073cc393202c92d19ba46f6d74314da42eb8b607f5a163eea5de57155e64841fc3521d104ad09ab4f4493fcffec02bb641d48bc793a12bd069533575d776d6f7b4cf1a39b4f157308a888362d46270c159d52d08088c5dabd45215ca0cd1393f83647a5b40bb81e6b2af0034ae166aa4f67f5a8f6de3e9c66a90fea0e2ee519548cb9f973dd61ac1c492a2742f98aa011f9d62db31f404b902d8d37bd875d67627b0eadfa2865095f892e04373d95b508ab921fca73228839b59c2833cc97ed9b4a736b88c40898a66e6ce4f7dbbb8b7c7361b3835f4d3551c4310861db59a30248ea46abff80975a772bdf28e15159a7a63291f15e7a7c7e0d334070dbc09266ec5358cf46f6e14db68de8b8632cd34b722f09a3be4c89380bcb25858b48864d724fdf759eb0efa084773e868d2ddfb2fda3b333da18aed2b7c69e8c06e92db925ffe7d3ca500c3fb14f17f9c180fe11b5ce7a6f62c0e2ab7913e315306f0fad4a57327a4b7f702edf56b98d7bf2abf11651ce5429c7a0c8bb714584bf8a3aff4541058c9fb9838acacd1d53d65386953628e9063ce7272faa03a46b8249479e767d40b3065cd038d510e7b474329b9f370ebab4818a1a8fce09ba3e315eb59e478fe9adf3b29d305ea7728ca83829cdf59dad180e10cfde338f50747a09106b4b235df14df545b6185470058636ebd576a7c1b68d6711804f718153bafabe259ff3430820ea55184162b99ba6bd91d0b5560029625d92818d78aff4f6db421e2d0a874180fab64ff0a54096ebaf544c1464e1118fb976d815696b342bd5ccb54faf7884b1e674c0fa97d9bc214f48a7ff960b7611fe63d2093b6b0650fd15db7cd1f1f73b94e51d8ae8857b6f1a2f1a88d9c407c76691a675301e7d57c1de2d146ab0215f94b9bcacb8f3fe1d1deffea9f1f18d048150c81991443ee9b62e952d1c30503cd377236f21b0a4043f3af1f758302ce6e0d310163012e2d609b6cbcbf0600bd0f415f981eb4f396f7521d438fcfa51985801eb9f9ba3f2fc72dfba202fd3f4ae469c3c4d9933c3d4194433be1a16d7d518e0f1efb88729b9379b99ec10bc3cac6a2cfd9fce0e2750d6da58c45b2f875e5d55e47bb432cb905b49a6370f7ef88b5cefcecb73b4b5c937ee565854f7c1a66b081e8bfca6217a5ae779d0349c0cb925b71b1792f0e68d42369cf9557420a8c931999b76f537b38ce5438c9dbd763d521c1da701341052b8e8ae8be7e0db9445e695197f2f7634195f110520168710a3368a7e34f811172b041f83c3c2b9b0abefbe7bb2f1beb0b45e40cc3146ab56cfd5a2c03e50b46958b16799093cd73547b3b7e5b85f65df34cc3da665b3050555dc4d34bf605d529de1973fb4d63159c01774ad5f6d59bdd2338fefbc6d05622adec08e33ab155ab76088f775d018729a7d2cd1eb7b3537b2b1d2bddc4320e96c4ddade1bb6add01ccb976a9b655ef65dc5edfa1d4545b92c7b14803759ab2a04106dd4a4a64715e041f29a83399f60c9fd0fe32e5212ccc959bfddfd66b88b9d6358709ca3e4e23aabf2a5b8892ffd95919499040ea814ac17deb875107ce1f60890601816b1a68cb15ecd11bfe3d32742b6c409a90597cadd7cbe50fbcd2d75040afdff7fc06c5e5962e231f1f8c940a17fc9fb822e8b69f1c44f55526001d9b3259712ea902ca7d8d228789899948adb7c2cedeb197cab8b53bfa101f71d65d53ea1f9f066dc36561fcf9e14023aa027573998df992cd251348c8e2b0137740b07b8328a101212f0d115db27b725aac4588bc9daed62bb457a42fd43f16d6eede00b1783bee8e5b22b9cd31cc884d70ea75bd9b46661464e6f642a2f58211da8cde08fbd073ed3104be2bbe4cbf2a62269fdb695ce7fb540c92afaca37d7063e0e392f28936d7629d62625b7779bafc8fe558e5f6ffba82d2f35c850771e3127270eb4aacf37f205f814f252d4c63cc3ea9cef46242fe8dc6ecfc0c8a48961872c91d0ed5b9ac0084f3209f6dc07892daaad6519db1ae0a87cc485bf7d314aa266d57f50f33f8e8d0c11b79d59dbd1eb9ad2c697ed7d17b4a61d5ccfc02794fb056c4e68de286d73cb432ee4f65d03523779f7abee8a1584ef6f771153d42f3e46d9ddabe17c72bc772abceaabf2a63fcb0886b43dddfd2bd3e86f9193bede84cfba5e2ec5ca443de4edb7de89ad6e61fb3255c2ca8716cfa73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
