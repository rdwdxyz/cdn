<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"669581135c068cbf07981e42e971d32b0ea70daae7d515a2807c275aac438f41188131c95e08c0e44a1e791d7fe7c864eacfdd19fccf38ba6ef1c474536173db28213ee06f7183c42fc03bd15aeacb851520f057138e8e9d945927128ff13ef5c7578a36cf1c98fcdefa4038d4837bbdff6d5ef16a33b1f9af019759e7e97f29d09f176ffde6aa9f6c3ccbe4b6837d234d1ba0cc6c0a20750e1cb167617bc8cb7bb256831ce229242f261e6584d68f0eb5da3d270867ed35dd7fbf4c9162e81384ff2c297d26d5593d571b05503eadb8c3dcc5513d6252c009d4840a866b13f060f975ae5b6bbece5d7c6c9c0c8de8780dad1ca31efe5c1ee72ab7c59dbcd93bd5b9f279c985b2881485bf3b394f32161aea936801c98ed85a02b3e8970d9e63c0927f1e680559ebd55cb99e7ad53767f500ebd0050dbe3687b50155aeaa79abf788ae9fce8adcad0ff4f4292a431aeae0d3a1b1ced26b1096520a83143f3ca34150a0f6e7af4bd93dc4c08888e2f0c06f8762f706e2d0221f123c7efe24ddf51b92ac299b47c9c637c3e3acf02cda6c5375ee40430dd550303dd4db159f11a4386d7a2317c0d226ee1e37ade734e65a6d9c9580c7d8e7dd2ec98ab6bf918e97ba22410214429218a75cb13b6d520bca33a350c6e4c1cb1005f4c78166e704fe556a29210245871376baa11495e6b1ad209a9973677a10131f6705d72966a174e772ad93cdd23e1edbc2452e3c0094afd8ac0843bbc01542607c7d59ef456ff87bc73a3ea554f1c7e8dbf1850431421bea03319628852f9ec17cdbf71bb99713f16fedd94bf16893679534364cc979527af277adddc581aa3d60ca8216df1c2da8e0879f321334cb4bb445960c3f594e6a055bd73c38ac191681490d63dcb5a2499e7c520082c10c82e73aa9a35e9a29d2c6fdbf1f803a794052acda41abbaaeb59329c7f98ec1d0c8677ac9a1867a2fe3c63b87b608a1584eeee8aa5a78512c7d11358cfd6b0f35d15b592a9656eef42c68b3358dd14848b49802446f9b0639e0af072e4b17b28c95eea879fa9fa361e304db88a80e002fc664d496621be73ddc21cba67e38627c2f4673ca90fe5ea1e0894e6e13478ef89e4a6b9195bd63dcc5142101d0b9345c6d58877668d6d4b8091d36e47f3b921a260b517dd32b175c9c93e6c0f2b2f46e22db186475897040239c6a63acbef06cb5151b935c994372c7d9eadeede0909e3a77d76a48324ffb1e2a03fe5150b7243f0ca8f0693823d8397198be88f759e2067c3d2c69d61f7e33f6b4c4a7f32222e4ae1efe93cdc7bd5ed6655b094ec0e9b2a11dd89f7dade7ee656e8667ee2ae8ee73098a93092e9980013f729eeb7665400c19c2bb8bd64e6c7d390e469569ebde3d6c49544147ca21df5a5930b47ac130a583e4d51a4978e7ec9388f84fcea23970924b06430e774e9cd59ad990bc687769d6987a4761912ed66e5dbf335f084fc10ba7cfb87fea4e7191dc5dba9e067d842e25ba9ed22fbd39fd0a807cf7b55ae31ae081a0c9900d7f9011f36386fe51d8b2af2198b08193dfd8f9316214687be0c4c9075943ff6a0dade29c92f6636ca53c824eac52c61af643731adfe9609eb1467a531720c3b6c0f3136711742716c13fe8537046c7be916049237f5e065c54ce589fb0747287d2fec5aa49dc6e783d7e4b5e5b47c55a13526d90de44b77d96b403e18b4fff1b5815cbad44c12ec7d220d03d23cb2eedcaaa22aba000719b29e9406e6bb4bb0b29cf396ca883deb3a6e82dc6251b611a38083c196a5da695fffea1a96b433b2a37052de620630f26fd877dab55e1f198f21d1a10b0cc7dad1d97907b209cfb3a725e5125b2f78164d1a5ebb641adc2c58948f22901d51d33668241e37c9901e27bec2e72dedc7b955843f20138010b045824005543a3d8fd281ef3545290416b30140f757fb57eaff479a827d85ac41b9e26c63a12c8f9b6caa2260d9db892846a0f48717dd3f04266d1578a158b9c1502c0e49a8ef2b4ce710f422711e2b0aa789c1d7d059bf23b9577dd8e958ed8b3b2398accf733c08370b10b40188af51da7b8fcc6c0c796bad812ef8578e66483f2a5845f8d79f87a87f7fd90cb0c6eb5840d4152940f40bed509ee89ce3bc47a195bae70a634dddec639417eaf66cfae76d7c5b9aa771e4ddc1e16d1db208ebf4d9a3ca8a263a89b5ea7c799c5f3d79d9395d101b5cb0a4326d6f15c8551f1381106863d4ba3ef1a6e37fc778827ce328e0f6bcde596bdbe087d079cdef233988f1321208a1c34d2688e4c5d37e7f9a25b291b996c724a7391a9878c3c5340ef4477a2b1ffe8e7f444bf9c3767ec3e83f61d86269a2f9804a32c8169d49fcfe46a5ff932e3a96e11938edc4a8808bb9e2abd55305d70b0cbd76503145465fa7d4eedb4efa1170f697869fd542b10393205c3ee54a3c0686d9b67db815280c9093969c8afd7efa3950d425a86cda7c115c3c8b0316213076b16fc3b1373331bc78684af9dd9ddfe65ad9abdc7c376ff7322677af591c2efe742fb897ab132f484f48f79b47c62be210465e3bb4994ff98856cc878dd7808ec6a8965a0107907b3755432ff8eb85a422ced91bcab40bb56e551ac2fc08aa38aa37031749fb507c931de47953f9f17e13dbd722e15607e5547d6f5d5ea7b5cc45b67ccf57a7882d49d48e622b3d76db4aa4238b05b89246f6bf6f03af4f3e89745ea01e0eb74e7e981432afcc12bd9df1ba7e815bf0d57f1a56eb1b3d19572105463d0f7bccad890a16a724b7ec320734b372caf32326a2a3e094742343ecc579fa801f035f955fa11c36ce7d839dda9dbe1fdbeaa6583bf5eeabbf82fe93db70dc4ce2936917b80154db55c5899f5d218176511ea827e8a0f848838ca28dda1ffbd1a036bf8e91ae9f9021034a3b0ab0f893491b52ea749ed3c37c20116fa69d12f7d715b8513e89e0e04693fde8610f7be46ca7cf175df701a2ca6e87ce0d64d7d5b6f6b1f9ce3a999bf18e985057b4a0847ab0e18163f9fba87367e35ddef310a146acd9381616e0424d1bdaf12a5f2519b71258126e01fa94d8187c9d3386f062128aabe1f245fa354e6e18383fe56679f5031f4998d129b9a055bfd73806785e830ea5e91e3b457ec2f647bff096235cdcfbead96eb1cd5d4c4cb59318083d2971db8e9009f5aa8988737b5b8023d8d5c82ac18a1efb00bb539dcd11c8d53e09d03c3cb1eef00b2b0cb6c3b3e366f829b5f32ce122e8078aab412e43fe771a41ae37be0ec13f8a85a70e443db986dfc08b9199b1a8713cd6f31605336bdf1d4e6321f80fec78c467e5c216b3f2855b9d79f2531589bbd9585d4f29e4d045a9e798d2f3b96e5915b112f0c2cb5c19f431fb63504241b9aa3fc9502ea4e939a086071d785f2722d7f42d7a987bf03b58609c5d524f4a30439fd71fbc2ce32033f2531d3f9f755b471786c17b430c674a4efda6a86e2c6de2dafdc1224e04a27bc2c9f8cd65cadb9d023cf662d369bed6a5324f69a49102dd92a82433dbdc339aefbcd328c4fba6de25589469978e87e2068541bc43d1fbe5a999701c4f8d99291400c5038b1cad6ac8392e6311f7e9472e86e0d1b22fddd4988e29d3297b49e089c4bd1111ece153301768343eea7c4299a33380dc47f6728dfd99ed3228ec34d925dc0ff1ff9c6f0fac76091f016d6fc79464834360db501efc3b2c37322e38c1dbcfb8eb19a60f4dc9c69d7b0d9b433531da0803b4a321e7a9cf089fb893ee47c319eb263ddc6b0c60bcc59ba36dc85e7d7d7b499cfc6e8e36ab985f5613f6585d63f9bfeaf97a595880455bab4badbd4a0d1739ee79f1c06333721ae07fae84a8c140d0a72045874244e93488d39f658f4419ce8b065259c77505304ea1ba87f7eea669df9c795230db42eec2f1a4d0fc86df8aac098e19eca95fa7b27afafa142d2ecd3c3fa5fa57534cedc82028eedf863519bbc0549b3bde3cddc56d24508b13553b7f03cbe6917b9674535752773410ad1addf5a24f584e690af31f2c3f2a7f2120097581923822b85e80d2584955d16faf68741b082dc1a7ff10829bce0eaf8fac13c1e2b021a27f86a8c0bd45336e3cd313bb7bd8340ee048691cd7b4c5ed15465527920ac3ee178e2c8b27ec46e83b324f4868f3336c103738c7690266abe74975af7ea8be8469684e047a0d22ff22075c959453f3f1c75dc6211410ecd7eca6eace3e4add26c6baf41392eff2b088b17c2b75b1180765839087b87dc7e3300b4ad29a02f07a9667458073ccf672efa4546e3775a8a70e259c3cf9a0bb85fb13a3757ce3ceb0705580a3e40cf1602c22d4b726fb0c511ca2320399d9f2b85035bf0983ac2fd7488df61da2057829908e15ad87c9d04cd738d7b6cbd5ef69c7f03fd3f9cfc72e31c301c56ae72f7d63fa86ae308418a77e416804ba55667fdd1f12a8c19ca3dd741d6f9940a31dc8352df1d93f04a3debfc9a3016d40fd1ce8f1f86506ea2c715406e4c6fa91b8a0ff3b342dd9ce2a5dc4d9ac9089dd83d394377f7fb79e2d7f6d54f46916f2afdadddb0a6f82277f58c68f31493213d455fcf254ec324ab42a58059694fca9f174cf1e4cff02cced6f98aa175346fbe5a80ffc1e928a9238f049a9fe2615133c815c070b252f77391bc9fcda85bc4a4de45a9edf104b9d78134f35f103004a7d84fbdcccb1ffd56b4b56f5514c2301849190d0575b3ff9a0f1a6560c39d2be89ff0fbebec79aae721867f68daca22e5da09ef89ba7c2b231e875dcfb112369fab40677d90214a7baa4541f6eb82b4f7d0da3cb6403bcda5d38f8e97186b0f3c33ac3a2c6c0b1a7f0f85b5c389cce2254b026f21e2cd320c35a8c519ca3c9ca0615a66de0ecab688a9d2a32a0c769e63b8111d505a3522abc6e3767c1d5101fc888d61f6801003b525c7c26034dd3a861b270fed26d3acfa55602217f54378e2d0bc78bff4910d9c40fa56668880372dd5500cefc92f663c2878390cb59578fb808b0b6e97948b35defdef59597fdcb1ee5cf92df30618380a0e7a6898dd7f76c2e5473b001dc03c94c0a13e6f3cc5798037d28c41a1e3344d4798d54a3cbbb106d3f6891381f4b2a8c602520aa004c4ab65682e32f19a30e01a8e0d324ae436a0c120bf3d5b94043b68cbf7ecadc5166b746582b48ceb9870c3d23c631d72ea38f53b0b58bb51c8dd1e09faa9a4c5ab2415fa8ea1bf92824e71fe8bed3f700557cef6de6b421179d49a9786db202660588a1a1f771cc5a226721e52139dde2a0bf8de88e7c0713364a2f325c71beb4db2a78fd41e9db4d54915a958749ebb87573e2664bd9b19800670f8dcbc88477bd668880c973d62f78d33712bfc91217f9a1e78d8a186f2209b28300765b3ccc622c7faef7241850ef93ae05f8cd8a1fb898b59fcd74951843a9e7920118df492ea30592c686d26ba64b03f9b92d14ac67e262e820c49cc917c7698fa03b198ce576fdd821376b23d628c224baedf2f82884c8de7eacb298352c4504969b05705b13ca195f70e6e1db616fc3fd621756522348a267b6d2e2477d9001d70d4f36eadd46c1fe691904e0652b890da84eef17147fca4b6f42c403e1247340aec6fe103394cbbd46a8a3c83d40cb4f0884e3c142a2bf09170b15cf31e657e65fe824534f96b408b4c1f5136acedd1714d83863123ebfacdb95028f75eb5c8111a951966c95d2e154ae54d8836c99bd3eb6e2b5ec66b8b452b3ecea73f7d02f18e7a24a01fe922b9a56349a8d9edb4ffbf314f9fb64740b30310258d8257adca1039d39ff9433e85fa12ae54da65255ed056fa810921941837faebfabadfaf7fe0a68cc50a64e4c7bd8055640c845e4524d9bc87b6db3343c640d424a3c258ce9b97a5708b28d6351581de22c4bf0f269335cd23b9a57864b910d378d19d82c6dfa2614c941cce57da822c17a27a396c839a69ef9345a5e9d5749f47afda0e3b52adfef6a39da1e2fb1bee37974204a5440c1e7c1fb86ae0075c6d3dbc08982b1c5f6c235c55b02beb4e48bee34d35e163c13aaad620848410f1738eac9d2aa8de068a76690774327baf65b09f5398bcdd711361189030b04b60ede71489e5d4ff9f06155324efdd803d4a6e59a3c94eeb13aed9877710acb8e19ed444b59bbd9b0fd571224319e78be0d5c37c6e96686ed310cb8dd38526f449d0ef6f0810488d8b0607455a37e8b4e7a3f476971df87bf01892678ccb1766d5e6ce180032a01421e5685ad8bf64b32e20febf576e2926b774f561c701834565b938a42b44eb6c7567cc5b64c65107ffa6b3c153ba75ee7f5a5ab9f1c3585bdfd2161931ce7ade96feb865499cc72eccbd79a257a88c1a6ec546e6a487dfda528c0b07600b853d2e11373021f68fa77f52fe3e932c4d1bc89649031708845aaf7e78141a52944e85535aa9bec6ab3e9fa500e9e37f55a1c11bf269403c020426fa7fa3c2a0e89b00145173200b7cbd8ce17a1a65ea90cb1b1853714ec3b0f3021b2c51ac10318bf8b2b7b01ae3f961148f94ae5668127122729c77e44bfbf56697912cb107e4edecd329e5a884b2f4a96fb366802c065d20edb0c1982311abe046454cb554c2fffbc6d204a02debc316c199e285cdf43224053320b4fbe75ea42ad66ef52492ed6b49356b2fd972aeea80f441239e3edb3b9470839efc190ed992137d029ba078777c438d8950fc96efcef25e18ce0d86aed3b28e9f29eab53d6ef74dca4a7588f30fa847789b82b7ab5a4ff2d49e6240505475cdbac007dde7561b1233ce5a7b09e1dc4dd0d250179c573a3810d81a34a640812a24b38e76c85768c4571478f0b04143a2bc6d0060be87d66ed6dc98f6589b7126bec4b7c3786214c21f3e3006bea3927243b2ab0228a30e6760a4cd441ef4db340aca7b8109d5883311f4486406322c69e252afafed8cb3476299de8688a7be9b2783ec78963909cf569859b77059115c183027efa7e375a59ba3a77dfcec40a213ffe4157da10b6a0a121701b8ab78bc13aeada694d2e8f29418cc6bbc4b5fcb6cb060c97e4e8fbfb9d89ea9f2dfca67161cf307fa3f0bdcc91687cc94764c57f6a9cdf9baeb36194f5f3922f6934e98d7f232a9fdb8d6768b8b1a2240f05cabd1c52c117b5f27157ca58e68741ce48ff6fc5b5f8fd99b5ee10da2c4ad3adf3f7f4acc65288ac54b96d298210fa07debd5e32393af0707aacb1b4469b488c36a713a167e132c24cf3f9181f63a8088b6662f52ed295bb94d4f4dbdbcbd6e83800147e717656ddcb39b1f11501067f07fd4239273abfdac0a848bc82b3555f46ae12c5ecf9ce2fd23cd29c327de0ca6882a1561b73b5850a15ac8fbf8a2c4b9ad5eb35626cacab344562aae87014d5b07d39b7afcb72eabcd325be05452faf72e2439d41fb9e159205aa582a2675e0f1080d42a692f046ed977d55b075a1cd657377c211ef143951dae6e9af8e06fe8ef1f93c9ff6301dd2a1e5bac16106c683c9d4043fd8b7a2a5b142406aca9d43b5c3ad668d07f21439e7d52d882ed478eab15be80ab425b2ca6357c9c2d0a7b770d6ac41c3c2ca74c713ad8228103140f231397e7808e06dbd4501c9ea709629872105d453979934965342a18948a226e21816bdb3dfc3bc10865ea2b9239552624f351191b50d0d23e5f55fd95f944cf7382e33d6ad13dc0297db09e314a8ab38d6ae7a7558f35f229e4a4a1a9bff77cc7dc4df4ae60c0a7ce8c3a77739a24fc1e8ccacc99b006fdeea8d11f4b24dc308bfaf7aace25a665740856ea5ff0f50a5c74e4e265f31b9ba0e074f6790d7a8ad39e3506094ab3224540f13676be6d2f1d90fff52e164b419255b930d735a0830529a5e7eb6238df03771bc312fbd69128485a773d62016f3212458721b366a8c46d5d10138da708dd6054931f746a338b97a97533a0223ac8ec43b80156a7fd4de07a03b0585a40c34f3cc935aedcee5122d601bd10a195c812765b9de92ae100a7ec3e0db26b2450a4056032c65f8202e3b507048ec74c31588ae241c0113855386ad1f91de2ecdb2431c520cd21a09da11f46ac885c560f4d9e64a005d20ce5e9593a67ee1ac90b762afd5dc6ea244d66d3ebf3d2619d7d5c16f537e0852e3a46859b1d9026b9360c1396e79386482c785bae56de61633b41bb5205e6abb4743b14760296bba8ebfe9e54f172e74f9383e7bf6b1439df4692895944610516a5ade42d10a61cd4f6402c9e8fd033a1329bfcb4531fe39ead5c3fe390120d541059edd76d3faf8fff66ae698e6aca12afd77630471e74ba8c3a2eb225fd293ababcf40ca7c41ca5d0342fcc02ba40a6e2a68e7153a5b2ed8abe76a488c3d77a8237ff6d7acb78ca80113ad2343bb1abdf379aa9e4166c572f3caa727eaf328764fcac367e7a75bb7ff7c1c019d67ab6b6082bac08f043f75f9e72e1c850d294090cb3c985c1c52e6dae714d90ff16e08573449ec5af43b160ef33a650f5a263a330876c928ba0a4a47703fd692eeefc147cf80c924ca6f983637cf07d5fd8b287d3046e83afe8fd19ff392719f2052167ccfed020fce850de75243d45d0cc593173891e053f0f87572fe39b7d7ebbcda93844ef2e91cdf4987262d0ac4d88f6f0c7f19a2775eb7a5995a22c6469d5c6b8b8abc6f5e677e7eee30b4f638f8e3dd6248b3d3fd3543b9041385204becf98405800b5c49480ebcd4de8f4dee4181404d5241e059a833df4936a6169bbf4517b4aaabeba3ab4bfcfcf6d6d81f6084f627a023260f841c0626b2d72a687f26482e85dbfea29541c95c03798523229f319da6be676180d2eb608a36314744556d6dbf6dde14a0c283bde774415bfbc2c76312cd11cff3bb1c90d6c42bf1aa35b142aa25b78765a60990d3fbf5d128d39e4aa82e857b47d85ba6c24f12168bccfa3cc739a8cc27f2c82c2bb0144e3130dfd03dd2d6de7153352d8079fadd560b661904ce5b86981050c7548449a17651bb82b549a28c3caf7e1fd11d038d981cbf3bce965c99b0f0e5ee2df6a2e141404490a5b8a22effd4febaa8fc8370f9ab6b844e05f7c3064cfe0fe132afaac180720977636bd277dd65dc120603df5ae14ebae10c997ccc7c35fcf1e330468c507381df0312ef5e857fd7013d638ae4159c9d9686dc6c4a2bcd5164e434b0d0ad533edf3d2a78d7090cfb203412e708671bd339ff6de7c90ef77ff0cf19f986ace0ca71ecdb69a55c304b9a396bdb63ac52cfffbccabb4a708bd78c007a7ed764eb2de2a16b41f29a3f74ef800486c0fa70854a3a8b3700facb38cf9e2c09e0e8180a140bad84158a2fc2202e1d5b40f2869276eaa6332cad8aaebd5647786f0d96417595176580ad98de7b5216fd30635eeea458cc1cf0403c50afeb94bf095ebb7ed8b03bfe636d899b35b4f0edc692f79d71255ce5b7f178febd0f37ffc58c78c5083d963584a120b5c63ca2d41ef701a81ab83ed5dd8e252a065d1afd36cde541d21a644f94ae15eecafdeae23db32e7426a4cfc7892878a6cd0a0d7b86113cde7444d67ad3ec7bf20f26d23f6777d97d5407448162ebc239d3a42e6a0a613f63382d33e25f25c66c09c5524a386d7cc2f8100305f3d2f07066e9f8fd5bf0f12aba85144d3f27156f183bd51bb672599a213b10ee02aa6a875eef08644da7215c6f59ffc16dd05010c1b1d3b68b0f89854468d7b484ce544882596b2d0ca8ec6cfa98d679ecdafdd22696a6084b177b80c1237e8b8b2b36835f3257b5979482324c93bee70473d3ed422bff74d1283df847abae4cbc4e3df878cc03ec62dd6511ee3006cb9a3bae2a26e9ad55d23753aea37667a36140fc9a095dc4c09946cd7d77878665682745df3fd24ad5c2eeb9e72f8b9c05379e61ec498233cd565cd8a04e66ef5b7623934dce90d4eb6546a5b25e3848b07f73252a2685dca09abb94c1e3e2dd3013792006b941d3aafb348ccef910af45859d2906d28b6b93e4edaccb0bd858b96708749e31ed2b32fa859c2fdb3cc725ef5a97c9627efd2e1e44c0a68024809a8b4e483740634d59a652716846744c069ef6aaab214a06ce08b40d2d18d99a70c81920f5a74612f362ae4de0fc7a451cc9d9383fec128e93cbcf459fde126493f5ffc4fcb66fecc4a84abb1223c343e3ea57e1f5d19b46732a124004f2696d6429f088980f9aaafc4dcd317a93570ee950e3f8edd2231039605bbb0d736b0204585798d2d880c80e14d09f85b1f3f4018a7240e27ab6aa099d3d85b1638ce2fb00792cd1d1f732086170584cd877c3082c40c17f03d02c5c0b5a4840861bcd1e3ca936de559a08aa4ae5f0d0c146018b94000592d8380a3bcc10c86c26b801913ec3ecafc1d03468ca8de5899ae7eb325a4286363c226d7fc1c4d403049fe7873afebb67a2f96ac7321dd006ac6a4a6903fce5d4520977a1c202da190445b523581ff090f14780b7785535127962df9bd58a4b270e1af4da836e02837c9358a5c843f684a3001b54523bffc05ccd7e77462988de247af6c2abdfb098112ef21f36d60994229fefff64e9ed802e3a8135bedc34800d4217f65d45dae27ba619e4eb8f3fc6a790ca0678e542f289fa70c4ef5087ab86d30587db3ae9ea651adfb4ee91fe7cbb16f94d89da396efe45ea0b329e8c8a73958289e8f230313cf091470b7e71da9a2e71f9e95b270fddf28132f644f75c964fd85b19da7ec79dd006a7ce1770eaa4921271a5b59d221432e2aae76b52376f7c6c9f2a3f3bb68c1f1449787c534edffd2c53ac62d6e0fd504b228bb1b5cefe3532193ee6ae379b4f88ebd9f8fbb9a68ba50d60b6ee5345b3449c5ae48a8ba31927f26735e0db789d96a55062c8ffe4b85ce3b2ae29f046302fd3f03d6323fc6a9d8f13a6c8b7b0fcc8a5a6fbd8bdd9aca10bc40bd6918a4ab35f526735be55aecc96fca5453eda0b180942c1a10cc3fe33cf22b1e1f371e1b3f345d5f3fa43362220e457e20f73ebd96586d8bc5cfa2e80b5f835628ef985e96872fc87942eae5f7b7b55451ca6e43e6f1e3e9f6085d41453f0aa78b271f235979c0ace4b1d6e663a39e13d9f2dc8672eddff54ea53f0b159dc94336af0d9106ab6e250b70380f3fa9a40571b014d5293d14140fd3e6f89acc46dae30ab511bbb6d9780aac2ed39b01aa90e7b6a01cc8e994ed5d06c5a203420ff8feb7eaba9be57bec1d36c78e3c509e550766c1012f6d625c4590b486a748af833b3cadd92e61ae3e2565f8f8bf914c16bc76c62c4cb69898b839c242c2102fa71fe1a5812c47059ad5bcbfa13762e106699a01a0637c84083f74d86e4b3a62435c1a61e980b03e6a7aad95f18c03b2f19ba476619077b91e918018023b898f3b8a1bea8fd2e8bfafdb826ed0bab67e97897e10070d19f3fab5d5b6b6f4cdb6a66f6ef5f3ed5e6feae92f9f5ad0bb4e1efcb5761bbb4beeeb5f15da3150a23c4bf6bb6c8b482c4ce8110b195cf477d286fbdd43e6341184ffb40d89fa8b102df199e193444aee61c2471bbb562d4c1578bf2580651b040ff80ec48506caa476664a3269d6c52ddcd1f92f39690029d7102a7a58c86f66fa979bd24703a342b120c34a9ffdfee219b6c969728a26562c05392a3b4870d92ad2a2204f8000c4634d65a109df5f72228f166254218f087ca443505a7fde29e0549bd58724613da859e1271626b9e04b2d426c3d4768a18ff09cec2a57b34e355179f04c4b464d4387acb6be8dcbafaeee3d171660806da877e4da9915b549d4a73908af7094fbc8657926b0e4758288c625cfd3dacdf6f520ca735a0dc973acf9d728942a528c6156568b6b4a9168175169346723bca9eb17f78d50b9656a0279f384dafc0d23c891b0c4873146bd16681664b53002e023707a938108a154ca41c822d7a13c66e8f68de231e8d5252257d477d30446ab821f4e579b16148aa55d4c40bf8af385de31477821d27ec01a689e938ab627e15cfc66f336bb7bb46145c6c6f752d1f7da324d749f9eab93bb889b08699e44efd7e119ad561716e356f9a4f040678e03e69c630083e82ef7eb3c7d54c39a8ce152d88c009ea4b7eb1323ba750c8114732cd2b08de5e56e913346d7b8ec0114009d994de7e90a6878f0d23a0c8343cfbeb9d6f098e5a612212daf79bb277e17d863c18bff7611a6b1b8009406e2e7eccc8fbb9643e8cbe8465f94f4e61f98399fcd243a65a97a23bf2e18dda3b65999e1928334c793ec38b322dd25329f3e6a518baa2236fc4ba78bb5fb0506470e149c48a159703d365888dade47d50cd9af520a6c914cc5b28953ab55c5c3a4ca0746e708e3c70f0810b39f044d53a1df155a958c610b7a5ad6d717e61e15cd725c73c48933490649444982d22e7b9ad0d410f3b2c471dba75a84ab67f5f07d9924b3bb2642169609007b31bb2981d3cc998f804d67adf2db95292e743fe6e92888b7dae1660b8774bf242cd6b08204e4eb0138017dad0e41724cb79df269efcb765d7df3bb1595ea8be21f4c3ae2cc0d3389a63029412c844893cfa971a280cbc59f8de4be217227ce9ea2d7e74c5f92ef4eec4c628a342d0468d1379c593daa30e74a6c41817f16f9476c64bc0e43eb83862fc49744b45ae1d44c63b832afcad0b913fe7442c11eb5fe4f44bc44fc286cf9a25cbaf1d2aff52f1c89ae106430fb158148ea2d3283d9b7d4ff15a53b63764404fce28189ba17395273e240a9470379b07ef8359c5a467961354edf957afab8bd122a6fd10dbf75f765d507da33f1478c819cf1597ce7fb5efeb9fa5194ab86e3c1d7a9727090b8c278d894414159f738f5f605034aebede52d53b1138b800d1fd8f0ee3a94c07e79557cad9c3afae115b7ad1989a4a597b64762a59e4264c8eb5bd4677b8b35f29dc92d2ccb992bc0310960230ab5723783db6f9cd65111ef8598ed1b62a3b0bfa3778cee1e0a795c3a39498cc751423fd893a542238aaf334b425c321e5f7f2ccfd4f67c5363b020152462c2d7e82734c40b5e882892efd483583e055786aa223b8a53cc3afef30996fa886d4f521e139273acf30ee4795ff77884137512d0c66f017ce71d9c164d7a0cca8e1551cdd9d075fdae83e33b0f309241b07843b4efa82c5fb568e326a9bdc0c20fd612c55ffd512c748359bd2869b988ef3dca53f47a8a43058b6f8af51822877b523f5a4c83b2e62f8dd12c5af0055a2895ea21806731b43f8858570bc793dcb459307f315d014030d2c5a233dbc6c58e025b93ccdb0d1c990f07ed493588e1a516a96d86ad56ef76134a309ff6f7c06d7f506ecf451caa80e15391f59ab661b089a1c0c242b2e9a7a1ce11b8e5017ded1ddb25b0cc18b7aa11bea43aa54e030216601d3f9b3fdc9db380277fc2800473f2fee9f69731c0f846e78a947dabd61abd0ae9f2f52a03676e2bd9a4e9a7b1a76a78f4b1aa4a889cf6b08b87f10699e00fab5e0bc3d2d36e17d90f40d623b9140e3950c6d947b1ac3cd7a21a5f70281a33dbb875cf301985b51046a82c037ef36b91242a0981f548bd1774718edb112f7067cca9c2876372f7755fc2911f1c2d126d618c1748d96ea199a9b6f698cf4815b39508e8425e69ffc42689df246432fa6f32eed979a04833792de374d52a6c253c4f6198f1851eca452de6e9fbfb51f98aa9ae6319e9f3c4db9155358b3032631fcf2ce238b6a8048c9e350e12e4b9ae48c0e644612516d3e01a8ed8682dca74cdfca8da087af378590f8a124e210b69d128b98b9233fb5efdf7131ed8874e8b58b71bb86a0d19fa31039c0905c74f4d11f4a0ef2b85a4cec60d5f869c425875d21b69e84fa8169f87aba1f362d4f4bd33ebee92f0faf91880a1405cf6a8e487a3bc763c3358571b445128bd5dc2097c921fc0f446ff7816968de294e4ddb196bfb26e15b085358b0679bec94d7aff3121c1d6c2ffab9b33f216afd683f562c06d1c3c545baabb450e4f4300c4b4f5672ba8e83ade6863f9928e64919b111c439cca05d8f8ab7f266315fc5f70ff566e9c224af669e3059c7efe9ac76a28cae3ba37ee2bf874e50575fd2ff4e0506c21af21533d76806badbfc8f3cafb6c8f446846cad3fc5600c94750b579479e1ef79ec387ce3361695f3fe0c20511c89d4a4be97dbbd0fa69d4afdf328aed34ba9fcac8c4b8f060560b2a8d8444cfdd861de2139dcc8b0d5b737a865f469c2e0ae7f48a213366c2480438aebb7901d27f511b223a0b4710668bf6534c5490478af6c585036f403a6e4c4feb11a04bf30b7e9e548ef33dfb5466969461451b99c564d970a3969dfd4bf3cf09ccc855e0b12a34c70449104443842d782dbdeb74646725dcf83a7ea87f42a88946bc8e2106980d5e0e512e01728d9034c1c86a7ef0d917142f869ac8867e75cd719bd2bf69f6850d8553a09fae5b59013f78323ee4dbc123c49e0c00c03ce1718e905704b70d741cdb373a9495d694825afbf345cb9eefe6d97b1c7db74c987a8fc91561ae9b622136c6ec896312d6727cf1370ce1519f96cab9e3866a0b48ced7b246a2e1308b5f7325776c942d558c64f75a0ffe8f94bf2b44808d93f23b57f0bbd6f6eaf7d6af187b1272bfed9a06723ffc0a3783248ae2ef9797254e2cfcfda481107489a037a233485720f2e08072743c21c34405ea74c617d80e21a42754a5445090ce5ef3e2c03c1fefea9213675da9d6ee458a6e93e08e8f3eda5e1e2fc9360f7ecfc4d7df48e45f785060e8b84fe20eb92c23517137c60578637a5e703f5c748728e2c35300c8388587ae25b668f8816aef2b0c4e8c0de6aaa2cb59680059e6a13919d235e9c1282396a7e04eb39f75bc28942bba5881ee46751f68ad84801bc460349b7f17d67f99599e975c6d2068e9ed32e5a593f347b7900dd8f3255f58e1253259cc8329031cc2ea479b2c41b04d67a4963af4a258a55bb3372ec1f43a61bbccb5736fb8f287c33c2f1a66189bfddfcde3f8b63950c6b35c15454a0b3676f7181cba08c924d94eec8011e29b044c7bf3aae284bc4505563ebcdd338dc54c9164f4b40bfac9967e06053f9c6934e8ef5944f1d8e57480c447d187fce03f366b921cc57b8f4381ffb8c39e6c479486c7a378c3f2e749daca7aa4d130ebcb2fa23fa8f58cc963463ced43256583c539bd93b0765473d0f15ba1aafc9ecc69a1b5ffdee4b10390df90f90e1ac5c28628bd6f5ae33c2b77cd0c90a146738fc9e970f77d6710c1f32a20d384dd08dea4ad8d8fcef1ddb9c42b391198e0ade634e6c419cacac56e1dba91f274cdf92b573348701470b022f549ff5d2e7d1a6ba95c1d27d277d383642239f6e8ce34e518f91f6913c30caa9e9354495930b295c7c4efbdb871d6f6985cbd025fa951a052e3adfe5d843c45b9173b97d751d99d65157b6f7045ba81366971c8562ac347b5831492ceed66f9162e0b46a691d65302e7ba2b043b1ab587e70ee958367a516c715fce16cb7ed093168023a1fbff0693c6646c57175cbda85d505092a9a85fa61b9ee6afa0f882988eda12b5f4e5f438e64e25d7439f937a6990f43b619f44707bec0e72ffbac2208205b7216a0825814d0b014720125933ed5330adefb1583e944e7a3936af31e5b336a32d391fc85422df6097057cc00a2e04abde30a5ad2a470fe1991f50edfab726338b5e98295c65f87ff7954a988adbf5dcebdb81368586e04f2f369ae223bef1c23e7904526a69e0aed696673ac7cb441cc951270ca10ed8b3681e023a82fe2bf7a7199589d0c662ad2906fdb5388d5573fd7e23e30e0f88c3eb5fd0c4cb4ad47c2db784602657ec7b940307307417a3931f12d4b90be7731b1c4d7e5310328956622f2427381e2b5d6e9b5e92c27859422b033621728da9380ed4c6cf9c43c4b2f7e4a3e0c273df6223a1ea743cc913aee61d18c74e12911096dfdbe2071dfd479959c81da94a2c04b712751833356837e518bcbb266b1394ba0562d4512c0aabb5ed9232d184a5859162fc9063453da460e06259671c087efc6c3d8b43e6c638d89890e1e61d3cd9a2a33af02893809d55020759cf85b2df5d54d472571255d8164eadc640dd95fe79b669a5f679015c0b452e05f30bb8bada9c0c998e11850ffe2cf48108f23e59aafba8356d2d9fd004ad236d694f1385f372710f36d5eb9a42f6f48efebe73e5bbfee9f2bf22287143644b13e73b7d6fd24a9e4ee128a2d7188f9ece4601c5589809aaf4bbdda0fff2739b567d4484771a91d24c9b5ed7783dee1eb3522eed22617782132cc6356470cb29498f6bca0cee66e0a7ccb191d2bea7a222157e35c79d9245cc39857ec18a8926ff8715c9177db7c3ba797f31b8f58e08dd7e5121a2217d480c5c3a088f626477d92196ca7ca4f45bc3eafc32cd2781738a87e3845c1f126b4fd182cd917bee49fe9149a5557c88f1df3ebf6116a491f0dc46f258765f5775a54d5013d71500a0c46ff0842139ce33177e369f72ac296af96c553e5ff0679fd4150c96e1e68e079498c575fa8cf72b4ad35b63700bac9accbdb3cfe237ddc1656db6c26b1d0b6342b2259fed65126323cce60a6d606ef0b8e37615d44dc5fc7bf4c75aacc44d336920c1191ac828339053b30dc5cecbed5d239ca14065f1d429bb3ecc62e5b236656e94fb25900cf28e22f39dc68fe9650ee76b8837b3df8c76c9b88612a053363c8826cbc6c43df13444a41f94e29b1347efde7eec876106dc7a3ca0ac46fcb6e4fa18fb09e1ad082f3bfdd809dbff4775be72aa2a3f87596279553268594dabbfd1b66f83d18546cf05553ff7421765e6eb0de7d65d955d6cd83046c112a68b1d31a766caaebbd5dd29ccef666609240e1825595f51f195da92943f3d1bb86a0306a51c8375c29a3f96478d6e7ef17840c182f6bb78809e84b2567a9e6e9d453a211d9f9b43146ae78c845db11efece96b723c6f49e6b88cee68b3d967d082f4d94df576e444998641d309ac612f4ec1dc9fe349398bff66698ff7bc514e01a98235d8550ddd7c76fefc4e4c2ada1da2046a264882a464be53e71a340526446bebde130805fe1d2c1703055aa313481dfa6f6a41f781ba1303e67e66054b780e1da2bfc47b75e3fe0bb0617b4ffac9dc7b5fcef3c13a697e1a3abfa75df68ba5fadc1837707107e7fa13618b0ae8b589cc3aa23a00f581d8f7256a217dded6080eed602a30a91061417e409013ae42aad85bfee60027d2248db0a3fd444dcab849519c5a4edbbfc3bfb169f75cca0d3e7031e909230411f4290dca0b73d13853df714967bfe96db2ba3616490f9d7ca281d3e1a5f357a0b1372e773e7519be37cc8957f9f4d9af69cffe12b312bf2280b89c7f6f6a8661d5e9b9112e914e14175b6d77baf307dafa831c2eda8a450325582050e6533a5cef492c122c6bd71f47e952f7f744dac58c7a19474955c7ccd953c1e7bceb82879dab17476c91113a8721efa2c7cb7e33d34c2a9c4fd4e82fdfec3df9b391d24fe462c17704e82a450989e8bd409c9f14cb52c2699aecc7a234ff70c693817cfd0539f3b60420ebf5d46bd26c17c9fcd7fead46b3eb82ac5c7599afeae00bbbe0e2e59f102235d2bc331523719bd060f15c1b25f29caea5e9332df84a995be848cb30b2142ebbef16cea46100338a4089c0b934ff49eb27971fe41e9986f2e8039a7c5fbb4cfceac269fd340bc4edc29e7f0828dd6154bd06fe201d48af4d6db3e05e22c6cc4affadebc8647141512cba64d04e9939069b7fd41d8bda65a71c0636f91377fabb931e81d99297ea317c9fe09d14b5a015da59f4cd9394c563ec7294fb558d84f2a64925ab7dfdbe2cce4635bbef6ae13fdb0a588007cbde1685774133ba1cbfe012e0ee780678d814348f0d7a174154a0c3b195e1c4ca56a266cbce2ab439165b256966d388482d2b8318d1dc4157cb1eb2820bf188328a4ed4a8c0062b2b75db6c80dbaeebd4eeca146b7ea192f6a62c0b13d97a8c63859ae7e4ac3aa75a8bb60d7b30f028d91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
