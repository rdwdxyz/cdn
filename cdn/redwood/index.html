<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9422a66eeba8557e873abfe06814ce228089aaf501330995c3f45ae3088ba8d5de7c39287b50fe3f9763f5c2983a7b3e8a734902ee66acd8338ca83659f584f7032a23da1e640332eb558dc99c98484a6e54095207421d36a86b57197501e17b9c21d848bd847827a2bf74974ed8131a206dfb29357bdcedfe2a0f75a9f8ad7b15cc3996871ffa5ac04e5e9cfe09c2658af59b617e77854941898aed714f737c242bbcbd852e78d15aa39be63afba2f952ed75212e0abe49e2c2293bb40ec94cee9e87de1b94663684274596e48c7d7750c770d6f55d8ffa2078923897d9dd41a95af2c3f0d13e6094b12b11df66fa08b7a6b16576845391d758459ac240cb1bde7e044f15d6bca2dae1edd64b201dd13be2d01dd735ed9f466053cc7effb49a52be2669577bbcb055d3421a790a6dce308ac38e7500f8f11ed69a89e987cef67bda9063a9a61166bdfff8df86b141011523a5b8920f3274fbc2d446e08dc63a3e7b16182d8f21c9975b9ca6171638284601551ab60a85880fc2ef587f4601f2270f98977864e19e19782e8d82cf224dc4ee6ff72c5c49d3319a4ee24f06213654b1673d67636c2049bcd7e151e947a0cd3101def1f66dda72a2a9780f57c209c50f1dc8f783559c37ee4a7a1507aff2f193b0b8a5b6d0d747306ea55accb3733d8c6962d530860d6c1a0037d5cccb28884a4b303fb437d7510721ed5da09c07a2467f052effe0f6373b05fa428ddb5fdefced1a867d4fd5dad7b68a68c4a5fe399b3abfb4f4d1b9f738876e95ed0a81edc0429b1f327dcfbf1a51c761a5ff1f5053ccfa9f04c3d7e734ae7f13792d124be7b35dcebe871c43d1a195228dcb7cd9c6eb61e344b2f8fae9d32136c7fd1c7194c9aa2c55c44545b9302443a23808df6b982b17a3304b9661efc6bb3f8901da0e1e3744b4baa8f5f072d6cf716784eb2ec34f34556d1a9af087a702110309121adbd9b7e9c03cfa148e1ed746c057734fb52048e765ddcaca7e2d2b05b4569d67d66775e748e70441ca74124a78a30925ba8c014cb9b23c3fa3f7d34aff80c4a2a8af83b6311eb2181f576c48010fad9561984dac8907ef380d94da97d04359bed772d536ee1fe4a29c8a12c564a2fb5089d632e35455a9073ef16c9bc243afdf79edfcee72e011321220e97bb92546b97fda46f602a09d6663f50640fc6672e7f18f5db0bdf44ea6f913058fe7f9beb7e8530d7f7db49adc672ea072488117778ca7fcf70fa892b0ed89a54a97dde135613fa184851e0d4604bda3d24b8d07bdb8a4788cf5bd555f4c2897aa86892daf28ea024184689052f5f107a2bf1c61cc1fad9687a8d14727dd22b80afa0c96e3b10915e1104df00218f1fb9e946e97395447231a0d66972bc07992b81aaeda51de7fbaccb538619c0647fcb9165bffa59ab3ca7d52cfc6e610ed23a03f391a53a23aa6dc901c1152a100ddcc734ea5b6b759011939edd186e3a0ffae47cbb2b430e16bee78b63aeebeed2ef159ddbe26ffb653a826e0000e7faa7e9a2838945a915bfc55d23f029065d42c3028ab0e60f517186227d065aa3b14e89eb2c3ec6d0423a3c63ec8d0f065c37b3ea373bd2a477e6a23daf369b8ed87a680e6593249f261a1f2a2058d004fd774ac75df26a1affe2b51b2a3a1d33233c810f373414e940dc7465877b1d069564b6575344e9f0139e6098101128b4eedd9e6d1376082caf7677e6850d11ff45c8d7a66b10e57df7bb22f6946ea71beb2b93935770cf49e8f130d987180ac4702591eec034f88d98b002b8cc587a1aff956cdf475fbe3d9425d53e6065fdd0cbd61e286f262509475f9658f52eedd15e7a342c638983a584e96326fa208486e42f08fa2581e41d68ab3c193f086aa8035c43f64c83498ecc9855f9fd3928e4f497b8d10b5f8d4567b70e884293ecb708d51bd3fd7e155cc7bfb6ddb34d43410a9e53500487e971f9ee0a767eee2105bffbe791610249855818e039d274e6d6e0d9c9977698d0ed8a1dec679f610922080367f5f56054dd9101eb3fcce4fd298381073282997f855ed164e25b61d64fd51973ea8eea5094219638993b37a53a67a9fbeacb1941b6300ecc91395f23f10f6cad4fae1de942da720093d69bd52ee78d180c4bab9f31a92a3e4bc9e2d34e988fcef78973c5e7a3fc0de46e85403d601ff3539427e6dece2454f252e6b19afcea5de007a45815be1d9ca50c774bf879f425c4264381db009a1806f399538108453bd984f69c34975a5a2be419a2993fc28d3d25b88d1ff720740e9b24b94a2aa90d6bb0dca6e3dd9100b47a65ab0ab4878f2d86f0872553fa13ce0e3336be78173056dbc2a2d05845dff282b4dda7399412b3a64588d1a9bc675435b6ee4889f99e2d25be5073e9734f2786fc049a66b98fae45e9f9df6ffd46e72986bdaef461d8e609311ec77e24c431edc1414812be7fd4330cd48665a3c57f92943de71c98029d21bdf881f65187b46bc7b07debed2eb8ad07daaba5d3fbf0e11f70b241892e1661dfdf5f559503b1e6cabde7f8f0ab2d607f3a4cdcade1808ef85355c10559f8d37935f4f0fbfee5b96f2a7fa7673197caf788d9def9a050f2e3d18d22060f09f282bbe488bf62e70822bd44bb4983a0000789750730b7c8b552dfbd3fe5cbaa201f292d998f143fca143b7ed30a68b9ff365fc51a6c6fc07fc30a4f9e5037d6747f7b4b10c223d6afb259a37ee5d4aad08f5bd978a8bf8868d519bb36dd6d42d43f73afcb65596476528c99ba2dfda7c4ff3fad1c38849fb7c4b6c09eff2a6feb5a8edafd750ff538d1e2316e416115d342bc9203ef1646e7bf3032fc407a62bfe89c14dc9a106923359afad46b68c3d0a3aef845c314365f7ab61ae37e4bb1226a8947b96d6bf2cd41843547fd06758df197d0f0f3ed0dd76e5a8dd0ef924e1a6328656ee739e9c1e692a20f86c337ef70b1a7dd9049d5438e5256f87de13dfbc70a0dab79f93793e98abf29035552d740794aa61d8baf7e7c39c8e8eeb2c872dcdd3e61ed04a390b910c73e8d15dd08149d7f9648805fc0bbc6fa608fc28e59cc516f250cb10eae6a3e65ae939b5b4626b8ace97c4bcb25994af787649d7963bbdad12bdc10be9dbe3777ff9b07b3d9fd1ef1102b899b79fdf0343aaf3303aa0d42f8e58112f278a6a7093af7c00991af2a3f871757b324a5272964296b46a78fa8def880c95f0aff77295ae0a497b5ae40e583bc574c02c5b290ec0f4aaac7eada127b8f7e4793025bcb2a016869452e7078be106ee02c8333481c399f4b98d730bc206522ef11404c87a57271f127fffeafca7923b993f63ae87c3f207bc3ff303a4baf8944a0a7e9066239ad4c169488e55af35d49198d4e2d5dff3a8f6af1be90e69172b820eb54f8d7e5907dbe0211a3b7dea5a5cdb8b5fe173b8686121c63b00fd1aab66a8ac860703182608c9366e606c57cf8c6cbc15374fc1230a4761c0ca60ebb03adb8b49735009300b53ec3e055f33efec76b370fa3785552f67f0f59d53da238973e84fb60e081d848ab1054ecaae30037dee691e7146e2d22144419feedf13692cdbcbcb4988bb482ac7e8dc15c9a7765661365cce663d5f738b7363c339b21c5aff81fb470d737a41845c7b509436565ccb55385f92d8f5a035da30effdad06887b86991c316204c7f81162dae7f60dfa224db2225557f7ec710ae5d97dbdfd195b09d4d2fd43d7e3472afaacc15b56085a853f14e608f52b25b8b6e94f7ab530390cdbbe62708b86ffa4b0cae7dc4215fb20dd60dcf9f965fb7e281a1ea50c5ba343405b6602281f70a84a4686f7a7b96194a5cf62bd0645effd310daf66c80875acd4cf4c4cb0dafdaf3acd5784fd78e914a33a0cc8bd5f9728b10acbc08921f7f57d1124a3ac186affe78794493de91727b574ea88243412d46da614cc469e7d027ec4f2bf8d536e719d17ec35d9cb615ae98fcc8fb17f7ec1d048818f80de832cc4d01c54e6e13233f116b409e041207eb2c2bc4c78333aa954e6b801c589d1722d5115ec06ccec0bfb33e6abe8fac9e48ad89f572b3e703eabe3590a7778c8cb07c4237c4c3d71819b943472665e966c2080104afef5dfe58944de71d2d2350b46f421685dcbbd313b8c6f2f4c51d64fd30be3c1b7e7aac0460b9d8600f7c2050be0747a36964db1d420fd833435711d11cdac3237280fda22c097c1a3142bb1efb033ed303d842bd8c87c4d933e41bbdca73d676d0581d10339011681ce24d0ee3a0d784e66840fa12d5398c519ac49abe1af13a64d771163f5f5e6646d2517a077b214deec622b7545964c53b6d206022a023af8d0d57f20b14710a81b94205cce6c87d3b962a59e9d2c992ba2ed5d38575d701f2fd7aed7e624fb30bc8eebf525290c2ab97efe005f100aedea3e5a1951d450fcf65d8a192e22cd6838285902445ee8dfb5050678c7a0ce71d894ab0c6b455a58b1820e445cae6ae8a20c5e9ee215530660f7799fb4e70494fcb288c84b5f02ebfcd923824233c0c6b1f4a14461759d859aa6b01c848958a0bde1860450c8ed2ed5e1acef46e87368d5718c18e3395b7a9d1e968e0dad995f60e055f5ad72fb5088c2d7e70584dc244c35c1daf207bee28f6ad43514ec4aafd53b3e8dea7836aa142c09ef1fa31bc88f752604f8ec68b47be2b3112a0291612a992eb85e9ab4fbdab97026be398451716cd86287fea1a8d6015b4d9aea3aa6e38435baba3016db10ff1d9df0e5c19c4d77c59a0b1fc885bf7e604f7ed7bed073dd0b74773c65d48deceed896c19c136922bfa48568240c999bc632c5a83b880885588ead4b789e2c96c658d6c3fa4f60d41cfb2f8562d23bb2f2f9aa5fd6f2bcbec42e8f63fc0c0d3dc2ad0526651572ede91295689e67141d04e0d700def80405d5fcfea2f501d1cfd00777673006270efb58c7bf9c63a276c3f7c731c6376712bd27843573caf2f91aa62fee2951852990f0bdeb8f3683722737959d2aef76f827baf4c84e758427b389ce665605389e8d3fec90eb3a773e9a0df244d84747b1509b4acb480dc477c8d178aa43479232165aef8cfddc5a3cd0ce13678fbf39d985089695a8b3cbdbdf0f17e46d292d8e5b685441576235d334421806d36b365981ee92e513d1f652d00214ced69e30dc276774f4832e877c1946a2044b2ad50bb7cda5de9f88df78df0b51b6ec14eba696ff8c6d8367f8d75d0579612abaaea7024f29054cf915be4fd0dc3a04de99985298b28dd79b0ded2e2e74c007e07d75db0292dc8754117a1659b3063d94742ca086dc0b03f330317015d2a1a65107238680290b92882bba3dbafe78eb52d086b5744d0c1f74c5063f8a1e0333037c1904a0b768baa89a5701c9e7121b3a28229b2d8cbb506d80ab924221eae7aefdee3b3a9532bef49b592ea0424abaab98e64df02115bb37e5bdba40c2084d454540d1a27d03598802a4bdca14605a6b5cd0df63b5f4bfe8eac9dd2ac951e1385e598681840362047d3a9800d3dc5ecee9f19ba0f7f27a35cba1bb741d7d3c3716662ce53cfee328e6d59348bf38cb3ee504fb405fe0785fdddbcee7c6d6a3aacf8381a0c01871332dd27972c1c6f1c5ed661a16533b023aad6083e4911b3ca385fd675c159b7616c54a4239b60d70d0cbeabec827cbdd6e38b8f3a0a98430a9985d70f249b6998308afb5cef4a4e2e69a535d4250ce2dfeabdc8700fd40a8c9c8a82a0366fde2519326fb0a209aac9a68fbe65b5b8e3185e202a63efe489d98f243d09177641f3a00850a4952960c65eff61755c33b28271b73d9d154e0876ce8f948549df4b007d2e562ba235b185ca237e61ad3f60fd3bfb2d25bb4165c04011b7e2ac8de32da439a63c97314afbde909cdd5963964459afff3d717ddfd09cbe39ba1dfb9eaf0261b700642e36d7417ab80d35a495d3d3e2a444a924c73ef6165eb157f0fbfec9b5a31c1c72625881ef08f8a189a70659713b4fdebf78efea1990be378aabd9f0c87f0fbdc3d6992fee931b38a79ac2ef7d778347d7c29afdbbda7ea63c6ff896e268f48432c7beaee7339d6d0a7ab28fe149431b8dc5960a00ab18e25eae58733e757e803631042192214db9c96320b9fb62a6a7a79d6f2cf910d86cffc20b6b0660f709f833077657e6f11accfc690fde2dc67faa970c3ce6219e4eaa56cc1a312b223840a67fc132492c3b1f04771966808a5bfe0eaeb1193268a20a4ff6674e3519a2e13a65c96dc5004cb223f399bad760f9f90fa37b7c34998ab814c0ac7710715e1586579503b1498638f988f51291a675c65a2337ca1b14d2422744be4a1e21de033a69ca46bbef545eaf91963663218a270caedf8a570e86e6bdffe74fa3fbd5f7adc999f4e2223ea79e73667eaeaee72713adfedd335476e1cfe85e9f55e59b54bb25963a16eaa5268f9e69cd9bf777f676a3f4bc97bb8ed34cf45fdca1bced625301bf76f6e7135b211997fd07e0dfdc7f32292a99e2e023b5606b71a6d8ccab77df3e86c3aa2f0a16b7b86d59b2789804ac57cae80dfda684d2f1c4780dc222bb64df3b2ad6100e54efc882f0f0dbd29b348dd24e1823337190e7f6338cae5acbdf705576a8cf1998020107ebb7414ec85b9fa5e91fba4fd389d5dd4775425fed59b8d462b61e80e72b9bd2d58e15667ee8c213e6fccdfa3884783ab4f2af32ef28efe173b568b887d4b6a4d99fb4512ae0a267095ee0ab2f72375b1530ad2a3bacfa14397685d19c88cc68c3462fec2a6e428917ff2b31c3acf5c46e55ae297c98f4a3e5c78ec255cce5c0dfcc9c070e907c848935d4e01a03ebe283a649fdcbdf9ee459039c3f4a5788db6879ad8e78d87935a5fc2699d4e5a96cc18dc639de7e05059f5bdb3a2dfe8b5614178924bba09c4a6e9a45c21b5a390acfd72d9285ff16d1a1ce9ae218ef705d6d9bf48a164cf1e6ea1b687489a14babf7a540615d32ffbc1171aee993204ac1ecc708b8311605042953730edb82c22b39c7dc1ac0798e1b3277834655c72318ed688bfa546882803eee292fca20e8cc249e226703c4d0e0154f2c9ef69aae5d376abde40c9541b4072ee6f8686d675edb81265d927afc2073911c8fb51f07aa4ba5b5d728eb864e8900a96fe0141d46c6430a9cbb202f685ab482acde06cf45af740e93a3ba72a93161d3b2721de6ba35905600ae3ebc0ae6a951291fe642de64005ad2b00d5c7c7321c31524376b99b9af2de852f0e95069035ee0ea39ca0603bd9f9ab228b4f3157adab02101c49762740d8bcf94efbc9bea6b90699b45823b0f777f5b3dc64d6ab700b6b5870fd8a0cd156ccc7c0fc450179a573040230557946ebd87f572866d332669b791d28b7958e61042e04aa042748e88a586b16e7110276267ec38abf786278658ce6bc141783aeb09ce820a2f57a3cf73b25c68fdecdb62277eab8de00079584bf572a5a4b91d62b6f73a4d53ae9dffff1cf4cc14ad0f10a835ccfc90031c88653982cd0afdaf5188818a2fb6f71f172537f7b108e0a256bf589f8c4371777663cc33d4505898dea4f89e90de0c3f9a97d06aaf4989f74dc35d70572bb76df2b3e6bf988161af914546b310a118ff8dfc5207dd61471438f7b136aede265ff1c5315e776540cc5614c07788ac64062d32a123347e35fc17d9fa689b89e1f3943a66cdf7b9386640c2f9f7e3e89e6a7151efbe3d6d3ac4bf03aa067db6779c2ef52244e66bcfb7c2b5534e562c131c6943e698c2cd76c81ad1a10749e58ed40a8cb7efad899f227303aa1f69ea9ab2d166c2efdda6436cf25d541382d26653229f87d15ba8e0e33929f7fb89a640479eedaffdcbed49e6ad43255e99cccfc4143ecd0aead18c5949440149d0dd00c916460072ad2bc13985b49b9d95cdad5fdf39032fe62b9df42668ad0fd859bec4d6222109b132e0338f892d7d880be0791840776f798c176ee6c75fc967b656e1ae24893a18eb27f4c31ce59a231cc0be427a9d3419f890f25369925dd42ec64de191cf7375545fe1a70ce5a0c0511232b69ad18226bf4d82e705bbef391551903a3d3f4279be855e4232c99ad670b667c6fedc77e5e3e52bb7908c6cbd72f9af7f16c590d25c3d4a230a448c5bba04f76b71840818f12aab78e20ecbe7f1ac4696fbeb2ecf2d9a5b1d4020bf35b7c2f9939d9d5888c1db9d99456e4b319e881ee573a0f2c706727b689f5e3fb72d5764841a692ef7ab7d2c80e79d190d05685bcada82e7b7cc89e1050dedd08ca45c6710c0b53de5e85d9a1e85e4f989c1b013013f7fe9c21ef3784e0c8b81ff00df1c26a1ab61ce7ed84e414bcabd7ed849ba8da66adc0e4641be64bcdfc629e017ca1dcd6ab37fad7f6d167cd206ac65bf52fd755699b40fb918d1b6ee8ef6d47cd5fccac8d5d8c60ea2fc36d7583371e913627ae16f86fd0c018b4788a96917ec84112d6d354443d6225659b3ac6674065e8252aec341f345e0905c07fc06df351bd29f83b75c15e45a783f9ceb1bf589080b67319ff9a47b80e16b43e93696979c816d6808d53cb30e1de4ed8f13832b7f61a03fc9cf779f7866a35bbbbab33a55a74d6a39a812b6dc6851ce65db8d6578bb0076e36799bc7df7991a996051b61cae571477c3e45c8834b952dcc000fd97c7633a65cb7dd6f1d4c1635aff41b36454ab5f1683d7717735cf3296e9d3d3f6199f4372f9e206267da50fb4527075e4e5237439373f3cbc7143c8c4b4a488b4535c4ce962f258963abec874d885dd1eff53f9c26db74e4c30894ce8f9ed2368f4e0018b9f8d60033d976984cad420c7294a3cbdb622e3ac9f64fa46e487c63f0b07785e12cfdb754db21b9ffc646016e770446ef7d6d3b147063d667a05e6c528871158da0aeeee8f7183348a5b83b8c481188ebfed51f45ee895c39b016be9a18a20d4cceca2a556cc8ee7710037f41f53b5ba4bfb266934131f122e29613d3df1903041c7866167db38afcff3f283e0a0a765d794491c78c693103f80ccfc4520881c75aaa11b2561b45e63c61d222992b26f669504d3587b0a35a43add017e1e6e448236868fb71b554faf1ec7db9f374821fbf6a204e170c7ea4ce32cbce6e846564a23cc195fe894a9b7727ca2b12b16cd6bab92ec4b8406cfe47a4a47947e07b6612af1fa01af146127b5a24385582061f62434a93ed8a1f4aa642dda188df11b8dbc17fda0676d08c92ee81dec5cf40842e2f734090627b12c2b3f077c377cd766a54e0981e4b053cd84c98d7029f67207e772a8921fd563c4485549cc784d8c8432d83e66d87dc42b6d0ca9a88e03d85e57e93296a52c8fa6edb62d89bf2537c9dff6a42360b995f577a2ae2faadd1844529b361fadb75c983ada1b4a6c113d95bf351f5b953f752a1967113a91a1db7b94ed1649810a054e944f4a70291812f86c7daae9f80ed26b77f4e7ece94c2f68fb848ee5a6e6e321d8e1e9988bf17fb8c7ab76d88503d6bbb66ede1102aa694050d482dc6dfe0be086999aad66620ab7547ec774cefdb6b061ed53aa5f2ee58cca1966adb5714f15c089f58fb0435adb546cd3daa2dfd731a9441ab5159369ad1d64a6e0d9e5c773df34188ed536e4e98337e01f57540b878a9729f2633741a71f370cb2775a0117b37712bd4a3b9163f9ed19ba3dca9aa1827884a9ba5289404d8257629d0fd3a0e70a6571f35e243b16692f68010a173016d44c14201f4d94d9a46b5e77e6c40592a804cac4fce1a4cc47fc451641985d06763793e1f2fd1d48410b33a7bb2e019c89917c52ef420003d94e8ea08c85d3f17ba0f1200161433dc0a5eb0f89b6fcf37e3d9155b64ffdffabfaf34bc3e91c7d3e51fd3d51f5592366cd3b38a150cf35efae286f96eeae2341b200f6fc12c41b955ccb4cf60af743f295453e47a47fd1f7385f6b53421a87f8ac2f04f3d67436f1e3b5cbc6807493fb151104d8495b501c52b57ae217d2d9312ecf0a5a8d79e55d7d0b90294b169965095ecf5b864961ed1eacd687b43b70fe438b23b18f8ab68315bc7e7993a0bc9147eb881170880e3cb376e78d7a5cdaac8e6ab09f0a8b950de179b7fc8e70ffe36d5f670214395473173c0ca2a2f533c0c0c68b7c00a3018d28415207726a283f2c6ccad8833842bd8f8fcd0e41f244594647c1798e32c3057bec77e165f2cb655ffd097a605af7bede276285732a953e4dfc6057e5f6a8e83ef9a5d3d0d3a40219c83ba902e5af1d4f3ba233754e078c52579c78286db5eb52c9755c5ed866ec9283f192421c8f352b5fff2f913850e8837f45516f625437c1b804d83af3ef1b1be263938660fc6ae43340ea9fb88e79a210132754ff5caaca5e3317aff1dec8bc79f8c2368c6c6adff8b8d7bec002c196d1bb256932a870171194757c345ddc0a9caedffc464301299b5bcf31c32d379e3ddfddb9d318c43eaf7c1b462e0f7deac584dec50c19523479376f8eda00ae175458dd65f3b539ece7f7c09771ee9a59b882687da3a87e9e7edaa9e9f5bd93b4ed9487aa54fb41a7ec307ec1d0c9aedcaa68edeb177353bf7e1e4e9f4168c8466fea87ba4131764fbe36552298ff38e7b00078aa9769a53f29f20fa335150a963533dd074ce4b79e73a68b9dc070f773e3c5fdc043dc96adf9fbc4263858b04e9bd2da470a9d4308ad7b722688a6dbbf1bb16de37cc65242c7432813d6d79c23bd93dce5ef29586865f87d74a0dd87c272d0883a7e6b586faad6cdb59e60be06eb03635847536b528d09a5e72133170706133b00d04fc4f1275a9c36eb774dded8e58f75b99793afca660eaac4fa726bef6eb7fda746cca64627522a81ec23c3c184fefe27d5a7a768aa50c55151d5af7f49be89fb48437c3b3f847a048468d86de93d0ea301c0670bb58a25d5e7487fd01b3285d368db3af423a59e45396e9f32931bd9c21aa1478588d739aafb153a112478cf9b1b445e3a7f4350ebe60387a50cf3acdf1376351fc7806d73c6f9d44acbeda757f460214f65f2cb56a347b93f5a80de69d7ad922ef708d54a218e709f333842898fd61039827eef7d5dbe102724fc8d4af2c1b88dd0f46958f0e2199b9319d7cc9550ef05035328ed1131ecd0300fb202bb6c546da757a8fe3e275e3218225c8021a7f0ee90d53d09474c68f4fe1d68261a3e1b835b7a8f82b1ba2a98b59c8ee76406875e9fe56c39bca253218116e4c9105d9f7843c94b1ae889ce8df16d0909756766294c36882d6bd3af2cdef51b13664497108ae26d43bbcd60e8b2563f6a97f7ff7054647350e7852454483fc088751817b75f048ad25ff1d7c88f989e0cc9b1edac5ff263a6893307c81449f46f2313ed2aff8af593b7eabab307c7bc5e8bf2974c6102590838e01940412166e023921d77f940a439de7eaa0bf9f17822d9adf67b595376990e3340c004fb53251bdf1dd834f0d9cfe7b85161fb0eb7e7d56f91687cf797cd498f2235b48cc5b5fa7e38e248a4eac164e007873bbcbcfb62f791d9a01e0655c0f7ce16f57fd79bc7cbf74587564977865d10c856200727a0f4e27e55b63f1f390cf7420320c3079438f61614f3aca9f78f520d5ecf204b2fe4daa437eb376176ceb4e3957858cc540545b434554e54b08bbd7e762b6148cc4a031e930a1a2ba1dd243fe73854eef378552b7ce319f489df541148f675d546f3862eb8112f71beb03fee5440707736407698867976bd0594282dbc9b4e2f01be5f170da1e6e23b93c39887477facb3146204f8cca262b67f9948733cb326f3639757485e6c81a71350e773d16a990117dd56f3a1c65cf005900d0d11cf6b30b42d7a15a709e1b2a1ab28d8f3f2bedafcfd9b3debf72dd3e94c1ae24329a31065523f8cb06c84089d34a7ccc95cc6bad7a02d06cd71fc0407e5c65ad7cf7a8220d4758a900f213568496ee543b363687bc8edb11a661f7654591ee704a2cf23ebaaa3c39dd4a40b5c939c1f09e7f07d735fe60a3b9b6b9a1e421763415552d6bf1d8744179836ec3b0edcc723532d431009fa56c63d84d3715a1ccde90d99bb53a5551bc71b14e7eb658582db597dc6af40a1c81d25509f1203db9dd6e7a70de924f94643f7c770e14d076dd92f93096a5aa202fc9e5bd7710d16fc91a063378d65723cbd5083fdf1a80ae5ed332c8d3e6d2d028f8483bc2eca6b04e7aa8b31141f65285fcc74a4169bde50d25e73b8535e2637503d3f2eca2ad071b83e097aa655d22c75739334775b6f16c502f71a48516b4c7a9e19631063819c0b7da7bfcff742eb739bf0ee726b57e9afe5fb94ba9388e16d94caf90031d93f81c859e53051549ce1e44c7ec7faf7e0acdfe651557d2a10947050b80ae075dc72240fe3717eaa73a6a5d7658eadb70f0a1108d5a7c49e7a48c7d9f4adadbf5b0b67bb33e36432ad616f97a643f00d58fb4a704c3da833f6deaa86f0bb3128e33f2f332a8976aec59ba156db088b2cd3f5969307ed6cfecc17a37b2fb01b63fc77970684f800a8b2a9ce38ab8ea76faeb341ab93c001955de4307e6973b9ed11fb87b577bc576f9766665735f9de3000a56469dfdd9f4fd727b6e9853c4b42fd2d0d7317b0c0233394330825e9598126165e2e9513922b7490bacdfda15840e1633b15a414dbf61098b9c3c2a1567075a8d511cd4a2a054b1ceaba0893c9100d7451709def6bf7dd8cb39525f9cd88e5336bb5a1d63d3ad209cdc08836e2dabd63935c405127fbf0648d8a10b51328512ac7bb1070e2949e64e780ba9e7c3ce233ec144ddbf286a95cb620cbe15667042e8e5ebc20223d0ad6448218c2639c8831870f31de817e18cb36db9d7ee735342092c75be5deb575a6527df4aa05c00dcd33000e0bda38982be0a99ccbcb774d2d42fc786809cf7840607d3d138f63b8845c7230b24a1bec9aac51f1e458ab464c3ce9d5311cf9f9747174b21f36e9a05b579c7585994d80fc09c55ce574c2e592a9bc77646285f05cad59d347742ec3038bb97a07a0806ee5d485b94792537432c8f625aacf1121a0593904c62c5949c2b453f35669b3d1405ff028f39831e99fa209a2f68f8b5c63eb5c5d56238461a4c496329d8311b35fd94c50167c6763d511aa6d863fe2b71f73803028d972c3b8990f51e89376ee304cd54df5c4d1f9fbb65826b34d3903a681fd3394dd1f8171f9cfe346a2135ec7e0dcfeeb8f6bc9062f35414f39a29fd46bc5b55e6195432cd27b8d3fae6d90b1a5c56b1e766f0a1bd8381399cbd269950d46ccd5c45caaf520e570bd13309b2aa92ad6ad30eae4770b4b7fd669281714b82b2ba5b39f6a61edeaf15f12df68ac3418f9e570bec5b52c0bc736eb10266e0ada94e753ec73895f7eefba1937a124b686489eb1bdb360ff1acd1de8c0c09a8735d67c2fd117d972ddf3811000d7dd50bfcde36241a411223afc33a0c6b5464ee58dcaa8d0c5732043da87155e23eeb4097d4f614e87b7584c225a8e73d5bb9412ec8042a665053bc7b14faafbc1f75c542967b43052fbc011b5700be8e47562740b08ddeff6706a1e7ea2efb5195b7878ccd5913e6e031a8e3d48de5f05f511b0d503784e71cb79bd283701ed2f202c1d94d9531e95f447c3e1dff64f90249f406c92125e26ba7ea657265ca306904e015d6556353f0b2b33cc500e4b0597f00d5b34061c4da70d0ddd8ef529026b3cb0fb9fc94c8c41b71ac1d806a5225fb5c2b4378ac88540bbf27a7948fb51c9bbf84c201dff206c57989413f18a29cbb260cd80fa34ea868b92c86ff95f17bcdbe5b095c1cbc217661f532d39152c25aea2bec90f3b5e388a26763d1386be90383550a2417c3bdc0cf899d166f50d9af7115bfc3caf5fbb6e9ce75520e01f28e493bfe98782567fa79626c496e471d51e3b33953ef3f918709a748a854a31a772992a68653b795a4aad6026c8d02cc2d47663c4a176630024b3fbcbe442721e8b68c0f8eb429b4265a6ef6ae975ea3bba871fadd996cb501808d5ea7c664c425ad31b65f679116b53d175a8f0590b76c41eb3ac3751a1f033d2d9fe7e8e26e5a07c051a6ca21a8a519c7304b025d5a282cc5b00a155749b9e40bc081bc34e6f042c6975e6e70ed4c5ec654829d48a2b024c40885d8bb7eeba2736fb9b4168618e529363505128943d329c2e7808e7439726189c33c58c7906ff6b98ead61a5e61448b0bbdccabdad2ad521a09af45573f09259b246193054cecb919f24e3a249d78800a052b1ffac58478ba29c6e127b174c04606bc18aed41513685058fc2506c9c943742e1f6e3b45d3b850de9fc756a5409fc09b9adb190c3be114c0529fbf53955cf886f6638596a2ddc12bf955eacd6d217332398b7c6e0cc4950cdb11dd4af814d3ba49e2f38d53438480ae4c0ec328be44c1394d6abff724524fde6766030e3f26f53d5477a08013ab4c48186226355dcb65a75ef81760036cfc4d376c408d9326f05fadaf8fec9f2d25f4e46bcb298a52d5a0d7cc37620d81bff8fb0e443409e8906bcb59747bcaa11e8e972e8fe64488ddb19240f639ddbbd2f40283c493c5ffbfd2aa3169cc37795561df91aef7e986b9de98bca66ed3141ab3bf2f02ee33d956a3d91cc1c3880534ea85717266cc6a4b0d575ad537ddb45aee8d7948940b6b740d0f998a2913ac4232e3527768489a62ca0e7156e40c5d2785c7e0cc549f8e18569f9c83178d31cb4a55ecfd16222244742d0763ff08132ae3bd03b81f6434502b664c112e6b194a80da55441fa331078ff305e40c7cc3b6b6f9e2c0bd0fc71d30de90bbb3374527985b1bd64fcbc9b9317e2ef463e88c396e40631839e43d6e19c27c661917d0b88dfc4f30b58aa8b0548649770b58fff73d40c3d5dd0b71302d4537f1a06ce031d2a86bf082cd6aabdd1349f7836fbe901001120e2b39398c668da6042e937ab6bc3f7e2b3f4cac78ee1efe61a0f8bbf773bc4089a3bff8ed5bd8f7dd71a651a792918bdba3387dc6f523638029c4a1c186a165f211731135eb6a88355aebed02d17fcf1ba6be85aa7b0666a9af1d0708e9b047689f8bdd4509aafd8da41ab51feee31f31d741259f98cb6e18331a337c12a48ac92c4b5d08dab0184547f86d0db14d7389bda6914f2e0f58e721365a056f812fd6410a761c4b96b4308ab5d4d9f988cdb2c4ed4a4e3acd8cd6be62062250941baa36ca424b7d13d12d6528c2595f6469ff5e8db865c5aa96d76cb26895b767e6d51f4dc7e190354c1aa2a35b5ca4e048aab658472255b8497c7f4f68c86d269ac91ef984c2a23071ad6a13206f6e7dde2f5761e4c1070d254a5f47991b7084055c1a75a1dc26c1ccea6104d4ffdfb340c4a6ff538dad8ed73931124b811278c0c1e55fd98522c77fc81718ca081a692a2d74cf978318d792b7dccf1cfaac3fe14aac3df274a8261abb80b11513e30c058622ee709c736485ceeab8503948c59332c313373d027d55f784dbb45800d45f54ed51f99dd04bb809d050f030006148a7f688d85f835c8ac161196fc03da9683ee6e2381eeacc37d82bd1c0651c1b7f9ebdd68dd2fac91b531f07b05ff5607b2c90706741e048fb89985061c149790b6808e0d9c86f6d61dce1394926cdc9ba7d2d2dbe8602855b06b664a1f9691303477e95a7157cb6bc1f6f26826a0da8278ce7cbf809c5d6781982f30c4fc0cb187e2293e5b70f587d29b35a1cbaed489d818c73b36d50d1e13edcd1a214dfa74842afb43e45554e691973162314912fd04720bce16f6bc56dd9a7dccf1f7ba5e83d16c6a7dbaca17b2067e1a608e6d350179defe52c600267323f69a5f4a741cfb925bd4f08c1af5964d5a4072ffe7f65c619d06a5853d3247e7b6f1174a8fe0b5aa5c86c765355fdb98cc27823a82584d95f09cd9d62c0e4e01fa65de65ea9cac2c2ad570250f74a9110e3adc601099afdd3599983c44a3c2680e3be79736d52fd7d1d21b05c2244ae227752b1967af6e7ae3f9deb5656585594b8460db4fecf4144c29ccf0db9679cdcefe8a6349d5688c74088932c35a5a79f414f1d51c3cfb71c15872d86bcde0148bdc504080121529736a363c127e51dbb6c117976299f9d728fefd6ea9df25cc54410ba31437972b2b0411d053c3af6626d9a6f50aa1a631ff0ef0a9e8c888cc38a0871041b1af7dcaac7df5f4759cb42bd7019c8c7c6306569b9ef5919de630de8a57a7dc0c4841a8dd2950726597e4b8279210188b77ca9680356deca4fabbac2ab64f2d6bc2bc06cc356a35af99fd329640475af29305683e6dce8f33659333b8812adbbca1274828eb125b2f196da64720406ad7f360abea4e49ae0d4c9b5dc5dcfc6a51922009833a34a779a0bb660aab68b7d188b37192545a8d7d71c8511eabc56cf0193b5de79ae1ad8b0823ec5e9eabe194bb205f6065c82ad00d2321d54c06a5b66a326a3dfd19be9eb5347489bbb8d0cb9d15fcb411ebd5c92ab43afd0e46d33319fe0c28ad2055f591db3342555df5dd92316992247cf2d48b6704088ce2760ab428d1f423bf1f9e1239022ba3f6a34795ce6c144ee96b7364c4b96330ea4853e7b5f3d99bf216fa8e64b0b77bfa053a95da91d9badde87ae0cebf2aa2b1492b82055bc67d1b2de7b0a4f79e03ddcda32b785c8a4e5aee07e51b179b1a53dd370ba8b077af7ea46eead9c8ae931c90f70d09acd639c0495dee4caa1ac5f80ac584a86d538c5d8404a0518ab1f3afd3c4c41e20a2a5045fc39c2bcf80f42261578d527c9295eee67525689d7d383bf95b5dbd051d0a5cd918dc9999e5aa42c5875711608b88f3b31c48379f80ab0441089a0905f440dd72aea17d1e54db666d86142ebe100109e5d72e0ac9264efec6251599a9bee5caf1b6adec59737cc641a48ce12ba353c5ec8a14c27ae9d03eb65c51efc8b77ea36962fb6784588b427a61d51f5868ba208a4470aae6a937534ab1942b88ea4f37be2078be6b7c1fbd23f2029b70fbe880f52466fcbc9db25585007e1fb6cabdfe54be5de20ec05ce034867ff83d8915fc50df0ece82a0cb2fb2306104f744bbc348d9196089c5864c1042bb9c1b7e4fadb99b672162174e95b2e223b6e8ef180d7d206613ef4c37017c5a1b6f565bdbf9eea2cdbf161a44e2007b5e34277d8beea199d63fb2b6dc5054b8cf615077fb76eb92367f67635d8ce1b1fc2ac6f91c864b032573f634ef3ef411d77417197446499aa265775142923c2a8621878d9aa2a0780df2f77faf504a6f90a6e28a8294476746ea94b3edbf3ce7dc36d2416fcc7f1f99ba97be47bae7ed02eaeaa55d18c247e3bccebc085accd325ecccf18961b5504d0ce2dfb3121ec29d47bcdab8beb948238f29d8c0b2560f76692285d58f4379488732a2381621f42dcbcc0fc704c3a1a3bc13170ec810ad114437bfa8419a4586ff43c5eef3d5d1082c3edeebdd537914f9098adb0ff7222ff33297a3d1f745adcadc87725c2950d6e86f9a9c20f93b07664c94f4f27f111060bea52df1254b523de20bcdf73543e4ee693d4fb96b0b042d9c86c2143fd878eefab3230ec849944f7f2c380492224edbc082c342fab90ecf5539729243ab335f0b58958913d21365dcd74ff496e97a9e46d0e22aeee591186419e890aebd3e56c1800b2be9fff0a6c107b139d79e70ce0bd08f63b786d929e663fa83e809d8ab11b394ce3e64e657a54414ae009bda05e34f0dcf6043852aad22a1c6e972fe305f0e950b8c7c68f894ded9769f0a75a0f2895bd91f6c035bd0e8c2432d9e3f5c39f937c1afb573decbc3b916e62a3352752ad9e041ef6ba92161632c41ad7340e8b76431b6d49b890058ce84a0d5db21af224e7310db349b124af9a5de193a348700f81f771c432b39e53c7cf48edbfcd3343402af66f89ae0aa5a9e85814eeee12eac6c05efd9d9c2c2edd4ce79a37293bfc8b181f2699ab4a112ead589d25721bd278d4b055ad60b8f4e060defbac13d8629c0aa02e4dbb4f836a209351ad85a438dbf919b0c5f3fa2e5d4b4730","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
