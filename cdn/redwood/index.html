<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76a78416b9077e58a9acc840ce5e98f0f997b11baf01918cfbf97f925907ed55d5c3579ce210b3f776bc15f489c5bbb7f06924ccf0b9a6c699819fc0d02c0276e9a06394b79022aa0ef9b19144166a1899c8fe1e75d69993bb7a6c81174c38d07078ff752198e6ca7ee8ba068fdd2dc66e99900ed0bf83b2d2af52e4a020f1ab3d290da376226f0187010e3272d46094048ce668f0eef3ea9bc55dde40c92425d80abd3b1c8c47069e196f49bc19d263ce261e85ed7cffad27024f4ba13697d5333c8405fefc1e0b004e14cfceca032275718c703dede83b9f5a6ae74c80655e3aa211020e65c20f68f0204df17aa2cc131df82cc683e2ed7089564e7efa2dc3197ea63be04d6a91d0676cdf7aa1bea64b293f0a9772653a2fa0a497cfcb262c40338d03aa6c03f943fb135bd1f1ce5887ec3f335ddc1966392f2c40efcbd931225f3ccd5a714ab39555dc6dac5bfac490cc0516cb682a4ee15ce8e01b78d78fa07408447f05f2c464e682e946c97de8e8b95811dca7614dd433d47399c0d21ef8358930b90c4bc13b79c9b18659f03040391c1c3524cc817dad0a48b77c318a827d967e0055bc27084213ec9efa98d05150dd5a5f2fdc86fabd1c5e811a65f0703c1d054029398370487c7e36d0e315181bb1905c22cae8d5ed8c1fe5319a766813a0819b584b811b7ee24fb662407e7257c3d40753cfbd3a5dcba4f62db470049be6cb7c623649354d024d14d7928b97d4333c58d145c1115d13cd21c1d7c56dc69a3bc410613c48a5b26fc965329b6c393f055a3c5cb7ab57d4069ef94d90b259e8f7c78953e64c786da6ef5a52f82b34b2063556a934085dbb212f35e6c6eb8e288070a21889babcc248207b0f025c7abcde54da7e3fbcf871cd9b9e5f92fcfc285803f90ecd2d98dc516f8a92cb9d509a2d220b5b9f56b13d73a548433158dea3a0d06f903c9351f87d1be474143bd2732ce4a802b93043165203615f6b52f37487b0f9d29df7877300660241e6d8b7527e2a13482815966715ae45c4f113364ff8ea4fd2e5a12aad9236c10416195acfffe350b64a7a1e36108793f5a72c57dc9fc42209a9344566881a83882796b818bc941d4934b2d3838b712fcff0e502055a39f022024d3eb949adcc67604c41859efd07c21033fabeec953c20745046114d8ebef9ef44a88704b7f197aacd2a80c663e8950724d96f35702ed3ef64a2af71d997ad8de203eda315c6f6b4a87247a200b5a03cd5aaf69fbb85eb275393a51d1451366193b1b7292217fd2c939ec9a8557b6803fe24f04b22f4d6c3ad3a6ba4478e15eaa7b2c3e4532aeb6ec460cc3a92a12c3a4fe5d127230677c6c04ce3bf05c58b8baff576917d8be61e34ee37efcab7fc9734ccb9c8c090a1e4e57d103ad66c57ecb5a0948194a523ad2abfb7d3109419421f92d2f363a84543a6824ee71fd8b7f39759071338f4dec51526af2801b3e8f9f6cce583309e3aaa41bd8d20165b4b482aeb54140e1c53c37ead75329fbcbc2a7cbb2869ca128e73dcfda75191bed57797bf53819524f90df0f27d0c14b8191e05f4f95cd55b0e3fa84c0bf55edb7dc49c8ea356a3421538c60031e4c2c6e6704f1809836153bfecb4eacf4c4d730b6009904adafcb3f874ee70419b7b1dd65b76daf835f988329ca22ca5545be1beeee95bf0af8ff06c6e9960388d96912325b0d573ee675f2d19fb51226ea1feeb65e8c8a51b4a273efdf9476799a156428400de4ad3cee6f54d5c9a8521aa647e87aaa94cf87d0c6d568a0891c24963ee10a4329a3e2eb30ecd926480b6c9bd2fd41890a6c39d70c8fa831191e4bf5d27ae8f86d3dcb202a18d828c69a4c764d93c9c92863a6778fa64bd4c3ad94b19e22f71989c34d429ca68a83cdcd1c7bf64499d2badcf2fa21fcbdec9ea04f24063ac3521caba25de33364d30aa207c3332c2ee892668419c602da4443ad51ee236e7632c89862e09ca0d6a476d798262001e76fc63621a1177c9a690291b6af6891091ce16acd6ee308ee500e96dce1de95de1d7e4f5e5c9652a67f89b3e362a8992b9f8b61b8d64d587153e3ebb906b3914b78be2716205036465d52a993df28dddbc5eb2f238a0b2bdad797633076254af394cb6d22ff2efdbd8f2b4e3dc449de5de8dde5b6b9a1e5b2b485db57dad0deebe3aabb752eeb2e2419ac73af6c81c6cd919619d36556bb7286d762eece41df29d49c6578611ccbf94b132ff424291869575cea0351d5194e56b31f3d03e12351bc367230b9da40acc27c20432c7dbc7a06a41f090ecdd8624c8e4c9c366e1165945e44e4fd81aa8a2bbff42f3cb7188eaaafc59ec95ad2ba5451ac2229c83c421eee5e9541cfad78d8c39cc419300f5bd6c578d6ddad4fcff12def2462df128e9dd2e773df24841e505d20f1e79e5658003571aa8682b12ee840b3fad13369431fbd1904996842aae76457f756030404fb48f8efb9639920a396955c51e8130109ac76818b11ebf4cb2040953ed53cfb0c23ef9caa3f4a214054bbda038e69f6546cd845f897b157922bbab3a8eef785c3e7b5c969e9ba84824fa3c9b4f6f62d1141854fc64465d69c7ac76756728d0ed9ffc915cc000bc12afe4896b72bab4fea27efea58d72e172a35bb312ee3359adaf83292359987ad92cea3bc20c2ca45e2643a338c6e8aea24010bd287ef80a74ded7f164befab8a745219acbe1b26d458dfcab01e871ccd9f4a4390cc6a4c8991006392db53420ee6361803ad4edbcb2b555c653f37097c50f2f79d643a185eb7931376333c3734d93326a64b9360ea83cb9a2fa5060b6daeb8e366caee1250aea8e71fdaeb86b390c6bcdc3ab38914d608a04cb577dcbf84cee818537f028ce7b561b37dca739cd098015edc7d4934f756ec10b99c5a79da5a3c75bd7666df5a3afcaeac7d7e6a27f6b5e158fabcffde6a983307722db8cdfa5306ed6ce89dded2fc364140c9ac3f565f12bb35d85f82df396215ced1223f8cbb92e220c4de9b35a254fdd25ffd77f9c5118b8983c676e068fd9fb4b4dde392b7040dcb3c1f11c2707d439bbea94d1d98cb6a07bfa792eb0958922b07a66b4ad5a7db8cd93624d954402f5f721f54bbd30424820b7874027562762d5ac37a70211db9b9d2622abd8b60df6bc84f842e439b0e55d06d6110bd53b84500543b8b750d2a7f4150545d1b5155003929955615c1a96b72ce0f9ab41306c79dbc729567053239f4711587afa9247eecd8710453229f92847b172dfe6237b7f6ec29521a78228b53962d05fe8bbe823ccafd7ef28aa8e0345c6419fb5284ba7d632017e2db7bb2a70d211a56e19bc94066106998771f9f5b25fa8b4d5dc76d54fbf22dba0d1dca80c9ab9f273c3e7f4f99988c4f87264fb7e1720d00fc57e8d8650fa4b707581c9099cc023e426b3d72feab870f4c828c0400fa78718a70ce926d3ca08a2bc9ef8770db44d57bdde92526ac88e37b08b6adce020f60df658be9d693e9113dc26f6f3fa7668797f6e5b0aa6f67f1645b090ed733df9707a797fe44135fdc7d18ea48c18e084082a3d9dc419153ffa99282d3a3a138016156369f27f20b5dbe655858d79e3f0ca4aff9ca69b0f135c9aa18ff8966a1f50e309d0060491768a1d67fcd72022f1f217a35e5504880935cfff07fa62628b23a92c27b87b9442c8e09a2ee06ed0955093b34c6f89ed87fb0f02eb057be36190a92f9018da54f528c5446611e185216ce63a456fcdfcca7cc736c5d643ce60e9ab24f7a27b03213d0fcd93da1bc6fc3206cd63e2307bdb8ac3eef2ae2e178f695299a932134cfe704e4ed9c9d4eb188bdb91e0427b481254a347bae59452f91a80cecfd572c619194e4a36ddeb94f020eb2c9ddf292e4503a649364d17dc1e180c340d4ffb693a18bc5432f9671cf5bdfae669903348157b0bb170912ade9457cb75b0dc74d1f6d3741334d5bdc61181bf2e28e8af59ee236cec494a71e127791a9f04959248d4ce82e306b7ee2202bd8a6221511481bbdf8071118dfe0df04a9b48cdd74a8a7a016ec8efb07ae113861575d692b2e8b0b866bde88ecd2ffb5f8d5039a72916b08f57d88058d9c3e259c218d22f8959c8965e778c7d8135a72e44431c99eb7b48b7615e5530ed2a3bf2813d33db62554e807b85dda4adca892178cd1e2de49c5fadc7c0ba8e6a9ad22a0c1bcc932b3d9a3a44208401350fd403da6dab585cea64f23dbc6c8744354ccb09c84aa3dfc46dae009ba353e368d545737f4576338f059dc51a899bfead1ca5b99c9bdb126631ceaaa14b7a05ebb85b33a4ca1300d2c56384917a476ef96fe9a4de35ebcea2cc7e98068d454321e267ed52fbf33e497496416f98cb078a804d19bf6c8fbacbc79038fcbecbc6b93854637ddc3950805d80381d3bd68b8496a3a6ee32c95d8c441339e2c190a18237affa03cc0845b88dff9ccd10d103e6ae25650ef4631f420d7d13a95d0fc560cb1b19a35af930adc9f11bd168630e8f30f6fe229dc1919c5ca30684efac45a59d340f7d49612d04f8b2d7e6e8d9e423c882d0c1486bf2348419724f8b6b012632bb075a7a8c000f339c01215dfeca927824024c306cb041ef2619ada74a76ecbc3c08d4278d9e71115550d509a3403a568ef598b8226f52f9e8a1d1f2e688d4911599452c721fec784d2facdc52c152673872bce0a6483855319ec345e535a5f3d1ffa5b8cb776bc33f3c9d180562e2a9f7cb4564e88832d4e4ddae502671afe6e1535f61a05712f8b6e9c9f1a0af2d4891d9d09930a1326c2323f67a1e5f00958926a2d38826ffcb4f1ba9c3f68a5b98f62f678f434fa51bf456b58299edf5f0a7087078543b64cd6d54525dfe1b8dce8ce9e60b4ccee04d0202b733c8e9cacbaa9f46c29741e7565d2a8ab141a8549271bb5b1b3143f9e1af20ccf23e52f104b78deca72b0c0009e5782b825f0534b2737b4f0e43858c4e80b100d993c711731c6cbdf2c214d2cd5c7b14edaeaec50e75065facd4b1b81b611ef5f3fc239f3fa8d025fb3a45bb1bd6517fbf6aa42338f8c4e3d730193e7c1fd58807a3d87212401f5c0ba09c266fcf7a7f6e99fe824a212fc7dbbe8697937aea589162e410305ddea425d129ecbc8536fb3596002a7e2f0d0eac1c2641ac9e62b536b30833f44efbb361d3137c1572fa48f0e148e1271ec464ecc6f9a473c0faf98fed78d42b27d32236921904493ad8242d78394212ab0a6b20fe64a373634c545daf6d4dfb675a0847f5df40af37482fcc678267ccf245304560360cfdb89a46b3c7fb7faf9122e87592c7faafefc9dc03a959dd33d9332ccef4d3c2c6108c8eb0408e68356810a5209f652d352c2ef5d26ad8b877b9b86e8f40296367cb8f081298b7f66b313c7f90060a32d2af91eda771613608f2269e819c13fc78780acf8a103b690a131b92e6150c5ca18636f2e013bd3987485c020093687a626996c0eb4a48df2c3a81bb90fe6f59587d8d60f3eb36458f69c16eedc360a9091f70f047437eb9a300cbc0533abf31b2624bbb8e5a1666a9b939357d98c10e2fe17e63c8c1301fcfb88167215ccd3e331f11cfc1627a39e7deefdd51aa8d68d5ef223f4cb0742cea97b3d34435294593c1fca5d1aa4a8b78713a8241910713ca8aca28ae086b27c98b7a1e9b14267bb5b6b924eace332d1edfeb2dc993160c4958636df9485f3f7afcc63b8a73e1f34fc96cc1d6db63bfaeecb2bd840dccab938fef824a5b8090a640a4650eb79105bf8cbdeecc7815e72273333448201b9e55b87dc0d6ebb8bd0694400d85755c447d77f73a43eda42f36741120094d193c0742bbf6a8aaa8a4f08444dfe6ff5e22a02ddb32e4fb2af88f7e460bddbe135329c22337afa3b33073786111c2a746f499016dea0d1c00613d9fc8a5a836934d5e9b2c3ecbadd6992bb9943792f7b2cf06dd59952fdfddf3dee78b59bf2ced5f9153e9d65f11dabccb168cd024689f5346da337325c6af80cfbb49b31654cca7f19f692b0b41b30211039b85b1b8fc4f87673e7ed6d57ec85e21d2af43fdc87bdcc4e5128a19270477e83074924d022939390556d1a58261ba5766e13aca89f5e8f6f77abe4a86ff23a7c3e098ef307ffbbeea0bf3360e88638ef4410b0f8b8c5f15474dc425006722229ffe18d4752ecd0483305408312a8076d2a48780ed73ea6866717b73a5ae1769d56049cb69e8c0a12fc7b358441b6b01f08a646d87cde4eb97a2030d5674b1eb6d90f4bd6093b83793dd08b24bd57cacf7db531469d3312fae51da5681ccf3231ca8dc23ef16114a5633bea741e13db0487754ccb42fbf1a68eaa8d5c1cc0a8b93330c2647a0c41d1f9d1294707ffe7b293ae0725336506e7674bd47e06165813f0721d67dd23da1be8da42e15c9e652f2abaad3e394c1c7dca718a06e9df9c69b019ace3c09516c1ff42e38bfdeb671d64ba6444bc36da6898a691fdb72539ba27f3ef7271feb71112bbbd0ddd1b8197c565eb31959551595ce44f253484cd8bc549223a02e306bcde5cc6504ea7abab77c9fb01af7e194cf47a45eafe4baeca4b51ad7fcb4bcdc0abce42422a3845340901d635683beb4a108170a4f3e9757f03ce5244a2d4b4069ceeb2ba8d2558d48134d9329057d166523826ca41390a093abbef19aed5fcfb2d32c55a6917f78fa859e77b1715a551bd911247e18e8bcb3a3543f65cd4ffbeeb8f70c3ea4f7f98b3a4ecce252f3d8e0da29d1f9cd5a3dfccd625e6ae5e31aea7c472fe986c5af181fc7b78ac14267f93aa9850cdeb1c53ec7eedfe5503718d5108f2680d9825ea27f4189b88015bae2dad5af246f51f7b998eabccabb026193e8c4adcd254f98ed1b48c965e38342c54e5d10b4b16b0ec3c2bcf6607b9459f7749ab1e6cd41af96718bc2214d91b889d317b165ad7217e8b6dca24cde64b28dacf7536fa543ae702b73b121f3690975d4f98bca33795792c167dbaf52c7122239284df6db548c520ef274b67976eeec8982bf01e890c5350e1b2e95a2dc74dab15fb7b524ba2ff76e56c30f23aaf76fbd8bf09f63b2cdba896b920876d74284eed3af61919d3a9232d195ef1350f0559e1abdabc054d392106cbdf9f76967c2ccd7ab7fdcb8f1e38170119263150bdeb0e7e56735d38219346549ebc5ad0f5957d2ea8d45576a7f624d162855adf5ad19b086c57c66d6712a7f46399019c5aa5dd6ddec102f3cf792ee3c5a6a4a9a6ce6aa27652871c8c7615aea565ec75f57aafa9f5c4f42ead630ab4d1af5d088d09caa61a76fc90618e6460143d2045a4871053569a5660ef0bd29678d53e526bf3cea7e34a8ee788fa9bc88dce366d68f0f7b015255a36bbf8e886ca38ac76eb2a41e01058e4c7028681126764006c0a4055bb201d6e6343668f9099f580cb0cc912b813317ac92d75e9839cdd017aa4a5d6498a8dd97b1cdf7508878b063198a211066869f7fa0731b021e58f0ff78b570abe8e7c89d1a1f5ef0b317a47e1b19894feab6b65473f4c611a4673edd114f7e8e834d4f94709fcd84a7b8aeafac01a18fcb90bd55a2799eec05bb87a8a9bcd5ff3dadd7443e2c7559ac759d588420219cc794c4643fb2c6239300d79115b96d35b11ffd615675eb97f98482fa19493b7a28116568cc6a7d64667789dd70d4d466d73de2d78877fa691e807b7e2aef499af94f552a276637ca7a3ea87dce0d0631e35606b04902f80f20c38d48e5cad741b3fc67f25fe0b141e023c7b9bd2935b76389e8b1fe26d7aa0e687d52d3b889fab7665f6dec84fe58a2de9e79c7b6a9c7bd79befb0ee65bc43b7fd4a757d4bfb9cfc21c2f74b115752ce98ec9dab4e18e64989087668935e6d19383e5b6a51de34fa7a34e97208e70d50a00672d40980119e99fbcb29a50eb5a6e30329416dc095b0dbbd0b78789a6054dde93ed63ade20a52e7352f8375f10ff5eb02152cd2027c0df35903f8e353a0d7c554fc371433166c2638559395b8bbde79a0ce9d2dc9b1975fd98cc50b4fc0db41e9094c5c6d555a6889dce4961742a9c887fbe383d062845bf5acc0dcca89d8cce00539c105670a8ab65126509c8a451c21e301782780e8efb8f2014f35b16b82df6218b0885f033ac4b2fa9d540e9beb527c87fd8471e9f0010581d2e3bf4adcd85205f9177aaccaf8774a166ae124687d547e20024a9d9b71d39024c229ad7020c86d25f122f290785192c082cc7e58a55106ff2786606fd772df7ca4af42f5b93744772cf6c5eaa380d1106f910f9ad55f65b11909b5885b65340adea54616684c2d58f6d6b2da1c6242297d9a4d6e647632b01a1670fcb48c9e57b33abb6335be69761fdb87a8aa408fcaed49dba80e9755ba0f4318b7d4506c6ab9b4b7e976de0e4367e9879c4b55fc4dbe0a402660c0acb0348c7a2b44a8a00a230c08390bdace0ffd18df3afb9ee0278188e719f6342756eb2002e9923ef045aa54d5f65d27569a1f31dfd1b2433cd2eb3686738c85474ad08d11595392157db1a38667c622ed274c32b9054127f9776995553527e9383f80ce9c8170c75c819cb71bec0d1e10071c7318382914789268e37ccdac362777ced9b3221c7065c457dc7401d8ea1316a6815e1cc7b8a5e18df3d967e9d4e82b3346d02d97ba9ddd8e79f9e0a79a6c4a32706bbd39b7860ec55e8715c3e39a79d6a1d16c83f837fbdf919b555c916856f059cbd5f30e0a6d84a837de11a88b6f573cb786517772d71bbfa6ebcbc98327135f0408426ad0aff1746d935899536e75a2b9ad4718c4c2c66784d5015e77c914fa3c6f850872c7c2b30273ce2dc49b8b0f3eeba88fe5f822e9ee40d9e2c5c9ade677e45a1f18bef5d5d60089a38462514bb88c796475820f87d5f193dd66a766bc2f366c0332aad2c84022034839b5329c443ec94f7809153f4c7dbc6e8027300ec7d0c4066c0f6971033f87127dfb3bb7602ba9194889f2a767204067e87fcb50e1df1b56c34750713a37cb53c3302404b990603043221cd3389256d286202581f8f0d462d0c47b60ce45937e21dc9fc3bd6de7db8353bfce6fe47e1078d6e4923c4f3388bcbbaef3cb379cfff2497610cc8d2b1ee7153a6683dfb3a9a8858cff5fe39ba8baff9e56bc4fd3988630d796d9ca4fc5e029c66cc2d07c5f742188aafa6f2e7de751df9ed2fe0e00c902f0b4f12e769a120165f3eb6e93a6e6d1cc130e8dd41180de7f868d2b958dcef3762e146cb78c7fab4ba036f106234a8f06b3fe84d282ee8e446bb3db5614fdc5b736be3bc23739461e191a9ee72d1f1a397143c266c681c9fd64c3af9cd045c397aae150915131b79dc153287d437608a359e8b639449e0d2b554a4719d43c07463dcfd496d8c8c659e9f47b9ee38373f273038c950e85230e0ab66ce431bf4bb504b70c8464dce742607517f75a03b1a31099c30e4bc908923a57997cbcdd9b75df4a2e02192a0e5b40eead766e7e1321a11eaad526b0faa96f11facc492de2f8cac2dd518ac249e1d49587a39bf5e3de77dde42fc548c874edf4a4bc42bb48b6bee3687626c145ba5350a52db6c28e824db4049ed5533fe759ac93c7de096212aa334df65cbb4367772387d69b7b5d13581a2b74a14a226366fb53f69e84e173ca0977394c0996af4e68a308ce2de22f52c47c93c0a2a585792db06bd7cb7cc9c39a62d722091e6d809fb1c595b930271577aa56f1c7584f5e0478fc3dcb334bedabb68c81850bec443be0594510c00100fa47a41234ed4da027e89dc380ac574c3772296792fc901a1d4c94b032cbbec5ff1101c2e5426fa4713d519c49262dd857b198a962e5bbd1a672c1504b3bcc6db142809e4f36d5701a38355d403ba3f8b3cebe7d62f9cd3178bb392a06536bb7cf5791d4341e0987211e67b8830f446c150fc308a1870d735c615f1d33ab637a7e724703262feb35a8440cc04891b1208110f2da3f0cb5c88c7d468cdf7b81006866d1180275faee413b9705477fbb530f05f3c6f3362e9675d8075d7905e6efe19485622a24cc4b478b1bc7f8a38a8074ef3d8d7002f2ac06ad9e6080cb6ba6eb2036a9459156cb0b324280fbd6eebb7cced91579c84b80ad585549dba126f97caa973e252e16c3c2aff990fc813952485c38dbee9d41e68ff13814e959c5f387bf65977131584a1e520c58b974f164e4c13fda20bcd966af0eff13f13830d9af70a461d3bf640843ed0b2714c688d5c9cd5f5fcd20171a773d660b2e22c1de89ee04f7678eb2256346810d74337da46e0deece1c5973f9321d3302ec47d39ef7bfe0aa91646f7789d639a781b74e7d5ea207306646f1cf45a932c6caa8e4cf83cea0c8e3f09001dc80b5c1c0e00f2d6f8965ae4a1878e5244409c9dcf3cbbea46f338fd26eb8bfab244d4c7332cdf23e8993e7d62e9e4b7022f1639696e4692e883db0b9a7ff5401e5b4483677afd4e8e14ceb93a42380b7fc1eed26896ebedbaa9aa4bbc497b04aefcdc1e411ad89d8dd05b7b7a3aa85c4515d031fbbfdd3d06834a22bb90f091f6d7a2b4a5d764a8b46f3bb727af9c62e583928a9868c41dd2df562f3ae44c187a3c423593e7007b0c21b02ee0c8e3ca160d79f2809cc7aacbe6d8e328d1a73705a99f5847d3772dddcb3794632e92821f3cd3557759e185feeef0e8ef0d6fe3d5ed8d5fc816bb3d42fdbad83707e8f8a96c6c83ab4404da269a14a01ea54d716e9273ea095d82fff28f346b9cd5f365f328c9ea7c70b1d5af5d06fcdc4f1a971befdc3f83a46236ae280e0d7b3b5acf9fab95112e33ad916a31aa3637a7a3e357a2e6f2e49387a92e7b6a18947fe7c607019ae9cd04c0989ff4ca6e08b1bb7c64d06b31134450176f3d9a1033dd73806c1f66a61bc1c6025801d8d47581a14e75a51c12ea9e8e25545bedfaee259544bef6f572e2a73d1afc78fa3755d3511966fc7a4630d1bb0f8deb98b637cc040770415e068c103bdef068738f503c7548eb6a47d0c6bfb70e0dc6fb1ed37f9b0a95bad1c71be057e36bbf3d65a2f67eedee24be8f4112936234cc2d0b2a8b4ce629696391b45e88cbc3ca589907908eac3041d1fadb2db9ce5801bb1acb03697d48ef24c9e9943b214f8a88a5b40001920c0edf3c5b27d6257be5b2bcfd1f8685de5223c6229bc4057f2968fdc46715ee8af5e1f167c941369f9c48d7ba32fbd57e342ccf6f90dac249b9d6e9b2127160f3d8eaa479450ef7cdf8df862796519568b99824c7748bed201ab2d9f5c6832ecc5c23cb80f308113ed936332fa3ff6787b9aa9f12c6e9c0fb25e78f605a0237d21270d81ae60dc3ba528af6e1fb79de187466fee4d7186d3b43882c2d8b29727cd04e672adad261440a17522be77bccb5e5db11a4112bbf2a8630f328a48a75f87a67b2f13060cdda16c81256994eef51e8b720fe7426ec4a8601856d90efcde4b61d05844f35bf7b5a0976719ed7e97a3a63fb802e7808c8785ee2fd9857ee571c3f3a000b2fe72721c353acdbd5b0e9e9dbe804f499b64a9cf4e731fcc812017cbb0363ac3ba0c34ffb8cfe055d87bb3c4d4281aa7fc55735f3a77ad45d687e3b551008d85e2047cbc2116c8326bf15856153fb454731468cb6b1fed736b0399d0a0dff749f40d5e1ccdc99b9ed398c585eb7fd0405939d07155ce3c318480eed9880c76ef77eee6f62379fd04659b25df915c3000cf641eac87addd8b6f59fe08b0e489db675e88e402a9f7f39f556beb169ae8de03111df3ad68c39e00a2bbb20ccabf9a5ebfaac37c5a37a51670664f2389a71bdec3fe46c4640d7aaf27834969f7e29e286ee939ba9628bd0282fcd5087f1ea458ee04bc40dfb4bafc915612c18bc92594f6805d025c00b83bf51c41e31d4ca3638d0afc49f982afd314dad26c62441b293952dc2db2eae44e12c292e84e7ea86d42172271338b7706a1cab6cfc983e28ed9b63d26d5142bc3bab79e516ad6a296424d6d35206df08efcdbc0051b1c1d5bd908995becb08bc3855efed04a34a5fe8d185defadf9e7228d83e8f711c4acdfd1f596e1fcbf9d49f4c21788de06034f82232fb2acb0b1af874f2a66ece5047212a32eebe27654a2bf433ada223e16e988382d99b3e6298d686e9b90c7a3063e2dafb2f1aac1fc6fa9caadcba0d87d2391fdf98ab02bbe0759ebea5a06494bf44de7ba85b5eb665bf63c37dc03f2dcde5b07966757dd7b09d34713a5fc63aca9aa2f555ffd689c73af14c57acadef87561b9e9e7b3360883594ab6803b2649ad2a89cfe6c1799bdcac53f8fa1363bed2b2f659a287b2454bcfec5c3755f29a01a693957ff9208b4825c59e9fa2deef6b6eb1b45b06da88d0debae1e3b6a39a2dc5021e8100d1cda1c35142fce7a3c120c3ab2e2e9f290c17759b9ffe910241291d7ed44464b65d6db35a6668be6657991e40191f80b7756502e7d9ddd358fb5810e921379c9f375e41c4e77076a42eac8c1477c37538f9ea328e8a7e29979dfcf16adf547961288c5b6e37d0df0ff1c9137877e0919ef162c5c99a53b8c5a68c658b85bb0c93e919e3dec630994fa8ab942392df469ef6a16bb8ae34decee4ef16d0c3a633ca290a1d9bee945b12c618c6535dcdc0ed87272de50c5a3f922a1dbf89bcd352a56352565750541a9bb1e692f7252a9faa7fc244ef77c2caebe35ac5c8434669376b081df931cd89e37380952e329534c09bb576d242dfe83602c5d3e0fab80a3138e41430f00b2ff90cb2ab0ab07341d378754228a6f18e306d9d4708f363aa40d8a34c83c88696d125ba068a1614667e2dea2df1755ff0fa5f9ec79920bb6f7acfa018c499ad4576a397938b17030354c65aabc40a3955b3e52f8eb59468b467e854ee7ea1010e61a436a1e5ccd686c8676a2b28701b01f498f96226ea4a6ffef77e11d54d5af890dbcd20cc9f0a1029bf367e8639ed97d1d37d6e65d28beaefb6181601424791ba2aa03bce0bf5ca0a4921a08f297916d6a609ab771ffb2eb2d7a38a32759da6eaabeafa5e10e117394d00c95dac9696203cfde83820a3eca113681d49f830775b2d7f33252eecdb0ec49e4d016f101fbada8bbd2f0d515fd4122ed0acff75110743b6b0ac64445a7b28f17ff701ef2ec76dd7cc5bd1a93c820cce2fe73f3804521c7276d08bf869a41613af5de4a36190e189c52296125b79f41b7330ee92ef5d139281b7a0e098ef32f505e329dcda422d27a02240272cf12339a20650764c27b3d06eb5de41a9d70f6db42a1b1f88572ff95b659dea5cb17be6b6ab3feca357396e51b6f0e2a309e1fd213d3e054d1764d9eea082efd3aacde29f28ae542dfa04449f569ca728c4f6e2b2a66cb71c87cbf9df853f56a77a307cecdef19800e63e2ab5ddd6dcf4a0e9db4967f69c8ab6ae9d5c5437cc6fe0c8572f9f4925a3477617c871dd2fdf7cefc1102f0b3035b93247fe96aed3f88e7854bf3daedd868f492400362b326dfa5d65d75066a88056cdf53ca64683be4dbbf9a1e40a596d9ef71e4079f3e4072a93855ca1c3d1d488084412e062328404bc1b6ce9b6c4ac37ee3c8bd15006ce820e11108a23a4b0ee7399d3606addd155bcdad2ec7b6aea22017e79af14eca4ec40af931843be57ef3fff08910223092b0e29bf12d3ed364a45f7a0f9355af6ccf1af35d497322a51c495a70aa98d094bad66725091bfe6df2febcc99bc62e9c1d2a0e1012be1c10dc5362a9baeab1636d148af764f17a51996463c4b646c849884e359291d8f9ac83ac58f4e7d245f8ba5b01eb0133330101baa237f6caf7d06391b8ac189b1cb1bf3aa30367fd42ef6c8e2c022bfbb66c5fcd46ce182805917ee3093f78478cb02f4de7fcdc3a23038b1d8dc5cffc3a916543bad066ec88e8db20d7538be27e54482a9b381eede42a10de910961bd4f6b4f60af9fd1da40a0cd2291f9557ecf9db36dfb7958aef48073654c21fdb6a8c688737c62227451baba8d926a4b99425f84513ff9e83d7a71a44f09aadb1507072d639e35e244c09598e649f6accd40b9a1c1787ad63c0e0f3e43d96a9e4f9623df08a4f97fd2814a934da95dc1b26c17616873fe0885d1eceef245fbdf27ac75b037b7bda325f056a49c88bc988bbf9032ca24577317fd00233de9756a18d80ea4834678badef20216ad6b2ec07723b2019ad218ece07f098854e9e2733606e47e775dfc83b5a9c5e9efda0533c1342c1ddb1b60be0f0417f624ae2d6ac9a7f6811ae045f6b838faa842bf5687e431d41423727c3571c8f8ba481c5df927857dfed09e392cb80e44944686c03a4a9876d8327ad9d9123b0dfd60a5a97debfe092d1eb372d2ba34ce4b45513e7069ffb2d6bd54354fd10811d0950afbf1aa61451de2297ebe16125e907cad206943dc9c6d4a94d17b301b820f3a11230f1206cf0c78f1b640bc1ad2372c69f9db0b7fd38baf459b3b61bd37fb5de3c306a7867ccde49742d46ef27bc19eb4b7117d96ee216d71e27bec1c49d7b7fc5a922b0d494893101d968685f483e23b4504ec0a18ab3a900a33f1d8dcbc6d2f1da6273dc35f1f361f683b4862df34254845ce07c059d9297cf5c067c7c23cf1615253499097469313dcb2c27030defb3be545d53e899fad277009012df6664992b4cf1d469a530366a11935436f47ce1f89bbb7cadbf30f5bdbc5ad3abc64bb6233d781cda669726095bd3cb9287e1b808ecbf978ee72f45d78f0305da60e0d0bb127d48ce4975037a7692371eb6c4669ef0f3cccada19e21f59fec24d67eaa3ac1c0ac082b2eb1da04c1ed381183efcf0ed1c377b16fff9472c01ea04306cb8ffbcec65d4d4d7740cde97d646e3e824a9e7917d370aabd180056f3f129b093abfd144a37a92bcd335e9cbc5a328c2256471a6641947b4dd289d5be87080af247f7ea9e91634b71a99348f5f8ca0d21195fc9d0bc64867d23490a72ee1d6d4757cc8ab9eee08f5fd8409973bee5b8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
