<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cfb343a3a5ab4ce2137b047af2c062bcf6c8a2966db1a825852343494f6710b670bfd1477e7e46fce4dfc378eaa7565d88110b270ac4901316e36e059171043774bf13205fd05b2145cf7ce8014c3e571ea02b646967d40af03987d2bc5aaffc7b68126193ec1df9cf9668ee61a3c65d809fff1f7c6d8b9fda934ce52942fcf20fc6794be09b592c3e0ecf147b84fcd6802bd338040f95fd3a0482b5e7a6019511af58726412700515f942ccf23c7ae0f4b8e5dff3ea16402ab83bb192608a3e88b10ddbe909a2e276d2d2c762e29c82b8dca3efe94cc2c2ac4a4aa26e732be8f05153b4431be4777cbff4c0c044c9c304b9fcd464d5713fb37bfe88d6672d36e3d47e795f31f4bbbac03564d0adf7b13b7634e944b320a814a27d1b11efd42717697d64fdf15c5d913928aa357c56e4920c473d3b0625c2b1badce0ab5658b755a3755c75e8f3ba02fa60210f86d7f54e79d615614496d3bcb12526f60a7a957f466f77ee2b61f6ac0434eb7234e9509efa779d08567a183a5d41f75ebd9afbbf38110f71d58475e54f5ab618c81bb87e57cbaea12135ecb7c5f6f44d38c29853a26322bea0676b37a23a6a9bbecccb226a774aa49cbaffd3aabd4535b319d041454ec2d5a11508882c5293945be188b8e998946007e1658a176497740821a1f3d1bb19dc8a9d39b2966d937a0d4739237fe91394393775d75e2828c961b6ae408b05e0e4fa8677679a4af4438ad8b61a259c628b6b332d8dfd36e9dfde384cbba644dcc1302d267aae482073ea22a684143cb6a19ee9476b3674a716b0afb43ad7ea8b1c6529ba7279ae1895da881a2f94b7e2e0235ed2bc231effab9d1957265babcf79413eb56bb5b8e38bb85fd4023d69ac6db078caa3c00f782ca5201285c8dc54a1e1f00e5e63d4a4a47c2dcbc24490a12b61300fac33cbe54b53d800f3ed7bc918d7e0b2886006dab65524db75eca42ceb436a111dac708c4bd5d57e35448592022c360748f4a35f5bd1cbb0edc8bb5be244067c2e4c94d12785738182c46c379b784e822ecb0066709a12003d1b4087355959761b8c9b0fb88bf686627cb5568e10f079680fef58beaa1b514349a8b614f71f6487c0f98b3bc811a1ab0124e07842936e44374980dd7c7fb8198cf56212632ffe9a845d954664fbc2b6ca8ea5239a6d727e7ba76ca0266287182d6e97e5448dfe54f1f9c1a519afe17cdd8c8a6cf67e75e106092b74a6ae1fe0d8f5ff0e41c1b5558f377501f4437774329fc4b1be72c5b48d6d23b6bd8aa0d938df015f26d2bd4e54d3ddb3b92c43028897f42ad2d6e0e4876d7f48fb8755919b32c22373fad82e581405cc3963f1ae5c36b085e8278ee884b66c6604aa203f784aaea28fdf1fa80b01229cb4cf1e0c7ced74d93bea49c0ae1974fb8d92a6d12fc048913dc9b402b3320a57c4adda250094a2b7a505708fc145fcc447d61408e8226fb55f22af8c57ca7cc01bddd9045a5907d0314be214e707034c248e4f21f75dbe70c2c8d6e84f266f56ec65b5ffd400564155a59cb8f37199c62621fdaf34ba25c6f5caa60d500737c415f3e971595c25520452d1c48393f1237dcb63ea010e507c493c264ee126a7c0c1dc400d14187f2d698cc0de9de5c53b9f5e278a1a10a739371bf73b86d2d5048a4bab6df2956561f2ad1e8f7b9e0ae177877d9699401af3f85ae71b8aba93f162fbbf73dd86db0960207bafecb875daf3821a9342bba0077a33ad89d818ccccfd4e5ac46f86ea354a497d813f42deaa15ebaabbe866258084c0e537e3c0ce1aa87085097f22dbc2ae4dbbfa76c7cc01fec89286741cd6cc8f780db55b4fc7dcb6b30cec17a0d0e31fac24f1d2f18a4a3718c416e8ffdc4af0ba57c0e52f11bc301bf63de8283de93dea430a54dfb758a6fd61f5f62b636e1ae020a227bf9fbe763ea450a30d428007aac53714dd51c3969435dc43afaa702092aa2570ca4f3929d89a4ac01baa542bca1f8703759cde9bf57a8b90759df5a8514047d6efb260abf5c03a901b4d0c2ea10c856c83ae1e9d463b27adfee4a7689790b76b1c2ff5702a43609de65617615d63308de510cb0cbc922d05510e47cfca91179a8115ae6052ba8dfcf3d2074b75e5673e1ad52df9b16c22e1f808181b707ce61313bc44f738d07b0158423d991727590e22e40ec6a3cfa4961a8b40658c7e156ad380fa27a6715fb7195e35c23649e95b52bb325bead125f51e99ea79594886f46bce034596cce202efcf5334ab80b637b56ae0ec1e50b760c9ee2f7e1d6b8275ff9b8eb7779adb69624338e8190c8dbe868634d96e2737771b398b04b257f762f79a349bcef41fce4353e2f6e51bfc37e2de30ecc52bd14c3591bb1afb7a643bbb3b676735a825874d8ed83cf7fe19156a5759d2194d7dd154dca15460e7cab22b59727d1f302135ea70dc09430f30be0640fa2adbbb33ce18a661e7ab71cff625b3331bbc88858b3e813066525dd7002b8e142724a18b39594c8bc4213269975c80b192112ff8d515974c855754858c62c7960df5ce7cb3bd5ab30915e193c4141516352476be89889bf7263161ec76a3efe394b65aaaf3936278a547ed9c1ce9ce855fed6b1b93c0627ab70acc0ccba99a4c226c3147ef858d9258e2bfefcd81cc21762b0032d1cf2cb1c9eec08c2574bbd3c31a5dfccb001e1b66ac5776a6d32fccfcafbda2afb410c45a1563ad43888a65b20a9405727ec38afc3bbbca5f13c5ce91643c761d23ee2c808fae4b5f497885fe58b5836e1e0a05d48b911e2d35c9a860277b0e0b4d996116f89c23fe392d22326663ebd781109f4cc4d9ed5ac2b5314b99898d049f7c1cf6194d5e41cf12e1fc5b24f0b3322f7ec660922916ef25595bfec6c5ba080a2604904604fbb0029b2aa90615b427d6221cd810a2eceff19e8403cf264f5f457a6f5ebb513529ab7e9ce96104e385ff0b77391e3c6a73b88023290e7a69dd472273080f06411f616bf08a13d37cf8f9a18a81c188cc61eb6b96ff3650384a666eff50c1d673f8eaaa0685af278ab73648d645f87ebd864c9820449ea425ac44e82872f3deb84341d3bc5226e7f74e1d54ab90094bb838c2f5c3de1e9df0b713a397679b0efb62cfe93cf6fdde8b14bab3df711fae6acc2b494640b2f6901050c2da088c63cabfadaa4484f9603eba7124e7aa7dd2c505148589bff0d3c039174abcc2b87db1728265a95a7d0ba8521b71e2530239e6dc6ff6ee41c4ce6353a13c7da00bba5fb498e72626b6c7cc82e666fe326e8f73ec61f48a869f18e9d308e288370e5269184f20609b40cf41ff2bcf020bf27f192c7c7ddd0d67d5506adda248cb603431eb67ef6058edf39ba9e7b15935c09e8f0854721d2b7805672edf343fc9263c78ca84c6cffe9738ae50aa8448fcb9a20c3fc47fb8c58b36c12fb271442616f7cdf31d1131dd77f736a8c47e45afe230916c565f9a4708dfe2ab6ba30b7b0e13f7087b6fe442860eec4a87316ef3dee2fadd2c57d4d1ade82731b984ed7e65abeb7906f1886eae90fa23d3d9515b4ec79f3aa05e54fe76612110777f7c5c0b8efed7af80358e90062396808ea9bdf41f0298c7c6a07eb9fef8bd2942d987ffe4803a98ebec5e7f46e33f54bf79de6be0f2abd8dbc3d02381acbf6206a63dc060f35975ac0094fca41fec53f0f1309bd81b2f4f42f8ec101c7cfda728614ea046470d8ee75d45afe9b7b9fa50b06284a6c0e8dff050a5f696152cbd5255a66cac48d7bb4a618a65e8fc80edffcb1fa9ad5ab95dbb8b67b6639be18d6efc29fa7d1e3520cdc87c300a880462ac51c44a0f0a5d36a43385e56158a4ec2deba21da92ff69372b0a3bf0cb991150a23589dbf9b51acc58e42617c826a0e857ce2e94f27eec50cd09eeab37bbca1bf685d1db54512ab2e8dfc60d767750bf890e573502d29c463bbcc91d5edbdb000541d652bbfa2b43f6e60cc48e93fd053853db3214dec877ee68c94c3b20416f044ffa859239b868339d00f71192c21d9ae7e0a579380bf8307d65595c4bf29926c14947f387427959e75b5720fbf3e4d12485771b786980d312b4813c5b55a81ffe087a1b5a01075f480329d2a8dcbc0aebeba73a48b35dbbd1ef9ec5ca65c83362ab7676957032f4c7509f24fa45a5ba40ca897b76ebf0fa83ef192d0928f1592ac9997fb2732ab46e978afce1b5b913e940d57255a4c5f8ec93003c61ca8f22fdb717b9e4596b4faed22a9eec90a57ff9a0b2e8288b1c599ce6201e589b266a8b04d854c848bbce9eceffb1482d1683fffbafd020f5e026facb353018b9d7a36861ea91a59e1eb365450c31fe2de6355aa6d1f09a0b6b211af8b34210a9d440f5b1174079c61a5edaf7370ef0318d228beb63ad197602c81a8f3785b238124d8e8dc110bda5402d978c010baa33571df48274e8601fd1c386f4ae86c3393c63bd0b5d0ab3fea0d1c3bd72c15b4b63bce534fc887dc85d4501cdae9efc909a0b0e14bb55844b6906d198dd3b85c1e7725806b7891b91f99dc88f7582e61c54bdde98d828acd7cf3fa7352f31a5f47fa3b9afd56ddf514702a16f719807f0552acb755a632e24a9dc54a476ca9efaf69c33dccd457c40f1854be020701975b4462d93267ed4df52a5632e58316227fc349d0e619f8de6effcf752d22b909fdd9b53424b91ce14925d9ff2d87a85fc1bc8fca18f7303f3713ccd347c1bdffbebb6654651e8876b947169f6104adae6a49ad5c37a4733ff3fee6f3bcb99366eb77600adedb4fe86f2cf7e727cc39409f454db99a0c2fe0d79f9bca4fda22b14169ef335220321d3c2b7b5e41d5ac8474e80f6784c771c48b9a8abd73e4a9de24866f80f25e9ad22285386aa97be5884119d820ec8e08cfb04b42456dd5e48d37ad07186d05e990b78ccf7a9e57b94e0d8413186174b86ec701e141c449163ab6305d3f5fee38c5d0914e7e7dd7f789b3e55daf03d43f28430e4d80f02194d2053f01f1bca757441c52f8b80716cf1fc0d754bbbf359b4ad2ebdf374d36ec8a44d5d2580028e59cad4d4fc6ad3cef372e348bfe5acb4f5613c19976ea09e32fa9f4f1c7ae35bab61e44bcb01fbb737e6752e985c6049b718cd44170bd9da5483ea2eb292a6dec912e51eb50d453ef5c82a0c5bca9911e782485205a1f6def05d881732aa31e423d63975535e66429ae158cae6e83563302441d3ee44a4431131e40756732b3f8f8e6ae53527156204542631cf56d700ea252db717bc4efe585487347dd5f2e703de7939f8f1345d194a440643634c7bd9bf33666d73d02b1fdb91e9ee7110aed7402a687a0d05daef58c125ecb625abc9e39a64276c4f9874b4a274e095b42b70b9332db0e12f2368aae147fdaab796f79b698c3e076516ea9eef2894c60ce9fe04b0999795eb75077986675998f8e301807324d7438105d00ddde270e4ef6e42bf20b181694ab4c9aba858b69cfa98e72f6ee797a07c297fa8d589fffe874fef2db975e36295c94523c678a546e83dc5f2b54d4563a00ec35f3e460e487b67d1764508cd85b3d9844dbaa052fe5c00f6e1f67f31f48d9bd7720cb5d3e41b3f314894b485606b2fc516475f088b94f3314cb07992930a79f5bd0160f6e57d46c2de54807cd9f9f473180d24e25e7be4aad4f690157e6b9afa516e477a8fb1f286b145910856a65635c5175a2a01e2f4b160a7757729ba69510db662e5e87795a43a2bced8b40ffc71f13059ee7006312377853c5fc23f80aa560576e820614140fe5761b241162413f8872349fbbee4cc2123c16ba9d4f8cd3203e4a0a7da02ee6260e37547f4c20badddc13a450b65e4818701dc5392e4ffc6ef102d1185108e83c761e245104499e77b098ebe7a53dbf7a3fbd1c9f7c039029d4ad73b8f3ef377fdcca5c3f0804d3074fe26e08a9796a32c0d03f4c9d83ade795f485fdf80e3432e6becad5f9c23af1e6882f13d47a6fe3b365e9a3122a0fba0908e63ad76d5f98a8e30f9101dec84c34d853a3456395ca39fe662086e51f7b4c5129e903b2b021dd0313c9b01c6e0e93c09ef518602000aa337258864594eb5971a11c43de4318c9e1b187660649e0a5fcf6715bb5a03ddb255c1b9f39cc26058d779345a30623be8b6d7045c359d72c2f09d0d7a0249ed131364c62ec557acf4aa3a1d146f9dc779405783718991c2dff511f6657a12404990303ab2509b2aeafc93f8d47341099cc84e6daaf6bdceae3f340435ed7941ee0ff36395ee9023311e0cc0fd5be9d45917e8bca63b8178d2d8056cef2070b627925b058556ab62f87ccd6873a3908ef26d5169b5c0e6c0e6025bd4a330918a8afc06567f71ee4bb09f5b7929c7e96452f92157b8f7852643a0ab223b92dfd892ada902dac505df45b413d1322ab5bb6708e17f627629052c40e836b4794aad562df7c491466063e591bfa98533f11df52ac4f195d0ddb24e0bdcdaee581cb73073eae5f4c0c0772f8c42cdd5d3984b00a24c783f410bc6eb16b89b107d9062768c1ee18bc5486e5c314acfc08b90dff114156306b830eed0874d21d5ad2416437c2a8508aee8a80d71f10be18cfa786d0ff3611ee561110a91daf0a4773c5c3d4919075f561e6dbb5abab0f6a48a8fe35819e5ee2047e5132dd4cef1833bcfa87ca1ee18aaae50684867591987d881587b72516cfcaf332607e538a2679db7adc302c244e95957c632bce278bf3c460740d84a2c0a3e145059adc46f4f2a684b44e601d8d82f1d3c0b589411284dae3d0cb12f90d3474a3341375d1886fd8f48ac2e9cf1c4ea283a15ba2e9defe209bc69a3dc2fa63da2995e2939e62dc67c482c4325e9ce1b6bfb0c4b600738ea4ea834b41a3f6ffe6c95c77c38469c64efcdba203e8551894af93eb5beb356dc22ba7dd7009532bbf43598d25e9763eea7b3bc4af3d43b2cd9a78a2c6d2d976d65e6d3ed34b06f5777b6ec8cc631b7cb6b093c54244ee1e1c015bc4e645e4cf32d9a9d1e1ca9b39fbc493eb5def393273eed4246c320a2b80b91b1d90153ded7fd2a5a4fdbbbe29364dbd5aa8a27b604ff2d39fe0d35609d89d0ea7c27bf47e749d8e2b72eda32c2d492bf4c767f91e5611f9ea981d2a23f0c129c90ebc6b5d0246d604d20c913c2f8d9861208222b5142485101af5173a98d4f1e913f9b391e355b4763b171cec72dd2d38ba8dcaf553d67fd48cb54c597f8beb46ff3157256b20f454a872df40931420c25dc0e75dd87d16c117e5cf5bea5ee7c49ec77c134cba61093a087fd7313f1ceb7290631c07ca513ad00d71a80985f72422de5b59f44ddac5722291f182555e9defa222335de447130ab08659e493220ffcf89ac26ce3fd314e20ff9628c9150db9881f11c7a0b3d258039d2e6873b1841a4a8310192205aff6933a957b0b421950532d710634b5b6f166ffded9747e7f9b08fd996b457cbe09f659b82bb48f5f58ac8f437ab8a34afb488dddfd15021aed74ffcd444c62939520db1308b4da2eb172f0d0de8494c89530072b6c5b3af3982283084bca68f98e816579722fcf009292be391574de88be91fcdfd31b33022f1e5a87559e3b026c488cce8de753bebb1bef0b19f02e718b2db238f3552a1510e0ed58880c653d8af08386c405c31fc3c700b59a65a74d87d1250ef5b46ae9800c9222d47f814a5c95b98985e426b0b77766aa2db51605c38ce719f25daab77fc69a7df3d8f2503493b66c2245e2e6a4626ebe338f95aea4a7e1c2d1a798ca232b55e5c8759a8aecf55418c1022a851c1c415e9705340d6df0a7d03265ca461457d66f5982e89b04b956e60dacb88206c6d5d3ccfb2524cd4b5e87ad71ca11b63ec706d7772b31522fa57cac2f9597dc2da99547f91c0c762c552d4712bcfe47c5dabacce2c152d7ba10ef8dff5b637e4434b2d9a0b7bb76f3b058b1083b05e8da2a1640a6dde9b967b4d24bd1e2a96cfe81f6717a54eab3d1a61c01a6591d8a482a043cdcc1fd080fa7793bced90876c6a728d823403db1c4ec0f93a2cdf15fa88980c5baaccae837f31844278dbd5ffe3e42428424d2dbb06f386ffa99ac5be1d6ee21f7e06e346b3c63f3bcd4181af5e6babe63ed6c354ee404387d65661fbe8ac5f4fb8781a8307e13b4e573eb4f8ae9c1ac8dafc20cb1d44279fc686557bcfe3165403bd7e33c6c6100432b82f43ed06d4d5ac09405af93202f924305a7dc3236890ee7d1d7125262ba96f9500ae01e7c8b864378a0ec383939d1c39ac05073919edf5dd063a93bada8e5712d6b6f1562b14738805af88997b9c74de9059fdba940f0bc16a3b1ff53ac128c319ddeb6af11252dec06ffef03d0ca52fdf7c8d4298ed82cbf465c9758246482764b8334fdab7a44b3913ecd977bdd02fdea7e621593017de3784159530f68f8f69391b19b31d94c20ee1d8574f57de1a76c9e225c48a2bf61fad3154cc72f8b7689a331c7681c3c026cf8fd04f350fec00822cc4da46ba9976a29c2565c1000055300c71001e1aad7a903427e47391026cfd8f5376dba8d691912e1ca3695b8c7be821ca5380b5dc7b49778ced131aade3d59b68deb5fef4a86792935c7be32099526ad43e80cd9da2abf794a0c1e3da7d3655e347f7f660ea7d19031ac72e826630007cd90691c4bb818ea9f8d7be056d02a5a980319f8d73ab630a0c700a56aef849ad5bdf3921f1856bb7650c5e165afc3b2e56d7c9dfa05f3d3c75ed77c644b21ff232c6a04e9bb0f344c2d4c4bc313114054e9b20bb7a4e172737612628f8f790d81aa2b228b564c469933b7f4b306be35aa13ac2ecf23b56059f3e366324456496de4b5e4634681eab84962be9ca996ec627b02df59ba8b5a3b6fe209bd8c420b614361f027948dd6741bde9fd58136a99c278faafd216b3ee06d61094b197bf3cd721964fba4d490ab0e976af70f44c30a31505684b1a29ba94f9863277b3fc1e58aa091905165df67583777b43d6794c13053c99632bbcd061b3cbdcc6d46a3086818f10d5feb89639ad808055145867cba23c32098060b6ca1ff5b953c38ff1b822fd9d0c8f3393908dbd801bc91577f61a77a9ec09ac2287cbb7b5662b6064c844059d1830d77abfcd3543a045920050d2e26267842c95f2ff59907032d7f49b236f14c44910c3d6be5ad620eba11d93070b1fd8507ca7961df153644eeea345064e7c3276ff728c1457c6d78483631210d90708855064be9806ccd184b923239474c0bc2a8ba145aa7b11ac8b91afea5f61feb48203a805c10343625afc068b58843879df1ee1e336a470bad5c82842bf2d71b032cdda85db17ce135834cfdb976f863badbdb5a5351650dc0da6d0ddb3c125c79256498aa270b972ec5913f8e29b6667903e989bfef692edff2acd85a6605fef96de90de56a883ce1726f4b27b68c5e00ffa7563db4398331f719fac8e4740925a202f5699e16734be95fb0298844140b8316099d473114385ba8f446f52ed3c6d4b75d1801604dde0023563b9ed2422d4d97aca75511a786e0ec29c23e8fc3f14a59cf6b2fc62dc698157cfc7e944e7bb6b8d7a99b923a7623c755e596a8e3f4ec4d19bdb7da495ddec0be530e7b4af4393151e9d69adac0e0dea8d59bde44fe7984e4be936c9e50052c709718a7f74b1e52cac50041e7bdc4f47e9209282dc12221d01eb0fcdef08497d33b527811a670f38658e951a7fe8556b1af0de429ac3a156e142e4a912048456892aabd41ea6068379438f0620bcac97dcfc069808c297b51c714dbd767d2aeec15e8ae98646fb2ad786c4a13e69cd201669cdf7ba95436f257830f3cfccef37b50497c48af129429f49b86b70253cf73745ab4e87f3f2b2a0a7e8b18415b2f255feeeeb72a1a6506cddc7caad7a6020ea50d28954614b1cfdf2672c5a29f287e584ca14fa8e98db6fdb559634c88d84b8e0e746b3faac267ff2f7042960c04f41d112e2733ae5e1cd547b498a25309d0e058def1fa7238f62360f9fb43d1d41c36791f1cf368b8e42f6f9e57baa62f70daa5699dc10aa680d77614ba545c0d42d7ee331be2b26ec94d8357c700a2912097c741d21e2b5d4c77f19db51ae98e1576215eda53dd63da9bb17b448614ab8e42241dec47fc8d421546f08a14d6cc493fe7abc98639139ff861c609dfade56f62cea4d5c87a6127502e328efe837a14482298883c5c626c11cd915ce0da8d87940ce7746809c463c58d1428bce7de4af1b32e22a5191678b34567ae346fc62ca972fdd8ca991c09f66ef17a664a82c3d1888871c1c6fa43d618bf547200009cc67b0ffc8763b0f11b49eb7db81539d989e3f841fdf7da8421cf6d00e44b4ff1049cf7a1ff88f973cf30c2907aea89ab8dc37dfa9c17a53887cd66050936660e1e39cf4eeff073da6c3f11ddda9e868a48af98159192925c04990e981e54465e1b23df25f88d879ceab1c6de024f4587388d9557caecf2d53055f562e9ea7fd37039eae3d6f2627536532291e727d387bc9035fa9ac5bb7e1e1c664bc3381cdcd07a0f6ac92da68670592dd3ba505f37138848e71c2309617ba4061db77a41bd03f8222cd729a3640622f7d93713e131d5acec5c6f50ee4e7557eb64aaa9447531e227df414ef5c9aa67f7462bc5432fa87762fd3427eea9921e28eaded1a8406dacae52ffdad0c0522854b093dabb2d7a1fc9bac0e825923b7b702c54673d34f69224fcfa2f69ecda4a6115a4935ed3da79510c717fb532c5b7ef54898f5a788a42685d06190dc059a4d3936c221f6929026bea5737e9c954e6477e1326cb4fb32c1c1e1e027169e2984dfdaf49adb6a7addeae5ac5a2b7473785ce88fa358bf1cecbc163bdf49ea79a033e481c1b62b236239f9d31782e891be6f6951ad94728b124a34913a4b99bfcc9c469e19bd9f740cb3466117a7c35f731018d4513c17848ced65f64c5c11fbe325a6a1690c9a56bcb11be4042963813cb2a5e4e35b4f5ba2c1af59dad3e8e258684ef404033c0a212e58b868f1a569c02bdd2feaa188a2979dd121175ff08a29f3842b659e10703e297eac2076163b0cf0000b0cbf7eede89a87369b1f467f0bd9bd048a184c3133a15162c85aed52a07a241fecc303b4a4a85ef937e4cc853cded2eb78c1ded65f5968f7593cdc4094847b0a13088090bc5ae3e4905881afd409974f969f7d9b634e4409272cc2b17e3428cd4ae32ee688766e23c00fba7831b3331b7a07e224fccd3d044e850ff2c7fe8c61ef0af8045aec7d143baa91c988ab9ec7b4230861a3a7270ae15bd4f6a5320296b3c1397cd8df18a41ded7c9efc0496077634d64d72794b2b26650e938d70f09979066b52379dfed1edff62ca905ec4575a8316feae7790713a3fa7762d43ec28e183c16a2f544112f98f4e9be7421a7c0a6e6dc7b0b70beb542124c9e66d2efc9e5e93d39a9255d1be133e3083da245e8f11e66dadad8e9203b92af7a81a08daa93e82935622441581cccdf4a5d5c2c14ddc8fc0529a9af0a87bacb7d541e9aa42252968372a4633b8ca286e39678afe861d3f5a9dc4608d6317c3a168a24471a5bbe15fb3e0eb42e1aaf1bbf262aac2be0705b1a0fa99a2e2da29f55c7e83a3dc07c481ab33d2fda31d9a8a99661fa364936c8e9ab1ccf305a36e84b329bb42f977d2f6da7afcd525bdadbcf9f580f3c3b015488e92ff7a3d23067d81bffc9b73c849847e4887e0697e0f49afb0fdcb105c887eb6038f67a24149b3ecf71c12515b1455e599d3755241adc9db57643ca91c09dd48f3906c26f4270c22cea9fe2901841fb97e778c025f81ac830160e1ec85465931fc9a630703c74061f6989b06ff1d7f6944a0d0c9444ec35d01d34d1f2a9fca3a2a0cab8475c2cbd3c135ba8e0cba1c80053fac39f876ee5c16d44f069b2e7e72440e1747a5bcfc29fdb919ab5d6e210e14d25805389181cca87cb3272887383790145076f11da406309c1cda166125afa8877c57f67ef3f213b0573dfbab64aba193c1f52e941c99ff555f070716c92cdae944ac9dc76a6374d40f57b34e355b451923751c1a0ccce9a1759d3e30e2c84fa074424affc860e9b589792a84de0948388d285efefd17a25b3f34466615f528bcbb45827358b96a8b0507d70067f10edfcf6a4d7cd89894ddbd24cf596292213f344dbf5b83212665e26b7eee6291acfddd310481cf7e4a6511c5420a3581a7c0474b2b3b6e573e4df6c34ba97cf1a1217528ca3b936d281daeff1487bbc06c0ba3921af6aa2ab516b8cc56393293d35189cf6f92b5949b18e021f8bb133d0a54467f20ae025fb2d02864250178256453c3281dd92f5592bbb487e8a071a605ecc58728ebf9f4cd3cef8321cca729685f516e6487470084618baf510dbe8a2f69ceb45cf4a7b6a67918d8ca30ae6786635062f3b52f3aaec8f71bb5a0a7290efa224e01a7a1065afada9636f06b1074b5168dad23f5487bbb04d3b530625b4ea4dd91497f925388c02ee567e6bda319743b4e42b9c033929d0333687488ff42d8426dd122197463bd77b4f7c2bdfc62f3eefb0a8bab652f583958801472ceae67521f8ff41e75a517a82b8687111914ca709a2a5ce30fd981cf99fa772cc2797bfb25dc2c452626d5b0520a47103e5c4ce2d203d78e77dc61345dc01242b40b82ee307f3a6f1c53288cd3cc8ce966511360eb7475aab5ddf8e482575332539c8cbae9d41b4c8ef51c58e8b82d08ef5b7555fb384cdb55fca340855181dc7f21fefc01f0237f776266191b919ec4f2e14c29d0239295b05b4c4dd0ba6d1b73060773193091df5e7f0dd7ae651d1f8c62b30352bcc22f77011cdac555fbf23a9ba935921ae4d2ed641bcc5cc822234431d1c24bba8c8f1eebc5e409525e2ac60b1bfd5494b1e4f6f3395031da4512fd988975a572a200da21227ea5d5c44cd0e7e2f1beb6e8f953c500b338dedffacac1862839eea2299d3a812e084085307e8565dda3945c573b6231f5538a3aea822d7a011d49237d43222f2e0e5f71396781ae2b50943b2d4e09454b4e8c26d9f63747746d16c66c7f9d126fdd74880a3f26f86204ff555b298a63c49cac60df47928e4211272eece35e42147df7bf44fa924eb47d12fea79a23cb470900eb0c6dab7f2fb01f5f0153cc52e11661891c517f403330fc8a0dfec6badf4f8f46140c7b4fde1e959acc8d29c84102e8d514e6b0a69aa4cfdcfb3d229153af074d3832d5a5e288693286c0b7ba53717cfea09c826b4cab5f49b5dcb7afe4df34936b2f36b2a1e6132fff0d861cb9b1e9bfc31b47f05b7fa73d3fad0115f9aea376912215daf853f85a17ddaa556c72afb64ad619eb87df7dc62f35312b8b577fcfb9d1a35b703016e95724384d8481dfcbd5b65914d64fd533802b9f95df60f49f12f07ef1835fa41c613fa046c0aef27781856d6d061696c3ff21bb3a80062a0898cffeaef929eb19636c7a8f5b4b3cbe889cd846b15bc299bff7347b3e1d6d5177593aa48a8745fee45eb551d2d688ddc605fde6d41d2ccb96d383f921c394381d92413f80ba8a1da5b22e25f4d6c6d99e79f071cfedaef16f54f1a9c18acbb3878f2b5801170bcbb3c00cb8101454ffec61ad09ac64751e6515772da401aa199b6e4f2959b1f1ea3c8f853a1d50c5cf1c4835c40a2c2fd9b5765a8a7c52754b413e86508526f8d51cf510b9e5f4d9229ecfccdd09cda8ddb2abbe7242d9f629f7a81c9c25e091d3d92278acf907aec43b0e315555cfaeed2365d54222eee274f67316fb5e27d1fc42c985ff93f1c7b5fc101d873d586b31ea8d18591a89fe22330872921c397e4839f4c6b5588e82f1231b7c7caa329c1bcdd193e5fb2b936414b1d603f4fc416013da74e1e5a33a64e5b0e6b1c15e85ca128dc8dee46d326f5df2b6c4eb00d91e1bdd970d821e34cf3d976cfcae2522add8e65944284c9a0beec9dcc9c1dcdd8b942bd58f2d7bbd328cd6c0b132af4c77717bdb8fd80117f15e1d307d87cd0e2b8a2a412af50ebd584da65ededfcb8f563d6d0f2d7dd1ef3e435fda4e73e25104f513ad4bf2afd9411aaaf828373307c4b047320fcc7f73ab9269304975746e61e38fcf40a19a439d78b274daacdecf6d66747da3ed0765ec16240219e78748fc4c83512f4d7ec200cbe8cb0928b70c889113b1d8cb73f044f682728bd9c651ff666aba61c0cd5d101a6e2be1d1a6fdb956587d35bb05c7812cba50ba439e629b9f15daf269e2dac58f9ad97d7cd1020a5366e94f7e9f9808c07e18f5fc17d4080501b9111b2876c23395522bc82ce1dea4ab5f4a8687cd87a330c8b78add38fb367e86ad1dbcef9142f6b959b2b6bf4b9965ec74501744fd33785ef59232b5fa2ef2cc21176140d151d429d2f6010e8e3c05319bd865e30e69933cca1fc0102f72b286325e5119917aac5d0fceec7c84980fb00473efe3520a5b96b5522b0a367b2a86dd06e69edd63c2b9e89837233227fa39e814c6699a290865872a5c690ff724623bb30c93782f57e362afe7c7f9b81e39d7dc342aee13dd0d8c211c4b69f0eae70991a03e82bb9081e803f694898c23b12273c11499cbebfaebff46501cdd06f2ef362f67f62f1bf4afa7b5aff33f15936d2f5716d2c90731cbe174d5d6a3dd8d118a295277f6cd656bed6f44acffe3bb00dcfe91bd6f475ea44b31b924b0e1d16745d2f0259d9880a2b8be7b6b77c00eb8bdd5ec83f04f2c747c0c736e2337ceae013a477e0e4152e3372509ae1a32cf5fa0c49c168cccbc6df61093da28a088e7f2b4655252c239ed078181f6a8d9c2bd9e3d146c636b005d5af07919d7cbd45a254ab03f8c4d41408cd12b708a70417b6183d4650ebe640518cb648612c4ec273fdaf84760fe8938f5a89852f1d86ac0b860645c9c080d1819285519108adbfabe77e79fa16aaba3d1cd8c62198fa0c4c6a17b6499629cbae81cb6c41de41c013bcd67d34454f7b354a86f7eac8e1213d27043e7ddb3f0beaf73bd6aa6e771cd7a2d20017ebacc24110ad31666786ea6a949aa8240891cd3e9b96f25e55199394f17fd6fbd851cce2d54f2322049cd6f172a42746f586a067600aad2220c2fc95178afb13c46a33f8ff06a701097435cf2ca4fc4139cdd5c10ae61cd47b0e3f8571c5fcbcc7a07c682e7ccf122a11e8ac3c861107f2eea7b677b1ff9e259d891762fe7ac81017047dea433d6e1c5c98c06226e7ed5cf2ba33b12fe0586c89d5a7212b89ed1eaba852d1ec2962915e63974afef7f2bc78786f9cd54f356d27a72a79b7ebf3e9c2c93a007147b314462d810d28d42596a4a0aec502d326148eb1a34279fa3eef979f2ec7d68b15ccfab53b362aa2a45f24e2d7664f133732ab52a5fc09e98c9de9556b05b27deb7d08860ea0a38000e4a331dac7c1b6856c0538077d4d231057fd2844400e427060f3a68e4a8a5acf4224fc1b0c415bd1ff97082e0654295ee0caca11524761f5696619cb1a55a457c0af816753a736b78ffb17fba1b7f389910b25d212c6582cecc87e81d73c1839832366b1e0379cfd3b9a590c2d23b73d8d62e755a1124b251cc14f3409da4589a17b7f06f18d1be6119b9f6a252bbf563420e689d91b8f539f793606e2071929564ba588671912b5d44c9479cc6437a3b72c26dc202da3d0685f2867ccad6e6989e4aa7a959d3191a324b46dc486bae7edfdf6973597d533d1591d180fcb6ac6096c03bd447c95c46936ce994640b9b9fc01b623989f555004a1b085b282749e2b25b9b9f3078c769a1d5344d21f470adf7b3707c0d3dd4948b1656887c04db62357c43d3966044455fc3f8d707e895a8ad26bf09c141ebe7b0937812b6ff58cd7e3ca01f6dc6ab1c5071b2289182c9a8949d5dcee8377e0a19e842659f2b0b7743a5de3d37967f481758c56312abc0c70532c53631309429d81ebe356e78c64ad309f9acfa17125780114e22ec8122dd31410241f96c759bd01029d628e62f9cd76af5fbae8f98d9bf41922aa45a75eb5e059b15b71cbef989945688fc0b700382ad776a846d95be0de0a26ab985785c374db8da2e09a533fe3f24212714b365965596c1b3bca5dbc5cbd8c98d9526ffcb6f8eed7afcf7188876cd6b42b6d0fdc49d696d6ec5d3dfbc087c41b8cf20597070a82ccba8efee83dad4e0f7008867376fb71e8525e31da78e8c0378c1de4a2bd8dff76dd40f6b1f21d0ee506909a8798440c85d474ee333bbe1f31b1cc8c6369fd924246452366c9246d44c748c3c9828b4a8664684278f27f46cdb9f80f4a1170e7b36529883537ed350f908b813cc9f04e9f7cd22f1e2f2b9765422da3769d13113cba7dcafd1791876feb3d09cb760fbe8c762068d647a53f7f10032e82f8a80f97eb5d98a12e2bdd47955da39b77f81be47e152b9fad3d86ec570fcc45181ab7a8ea7cda6ab80a10ee7a594690bb7614fb20b56384d77c9373bc8800768e35f37d928817c0a7c526f063bb767edac28798c4dd7b01584144c9f7f78a6d766a9ffceae64ad353b8f5ac89d44a632d41b77ca2130797693185f1c91bc43d244e333b47878e34be505c6121df4cd2d49395910d97fe1d70c23e7114a47a8c7f2beae043eabdabf7d3582a035ce481f9b8f37d6d77866209ed10e794e5d3f50adcd0815f351e9269282736480635bf864c597c38c975909351393a8456b9e312b0e5f54a08adaa3e28f97801edece69282bdb6a6e76e41f3b5f2d7455f2e9e5377b8ba6958ab0a72503e3bb0f0edc39e000dd62415bac0395b08986c05fab71b7f032b3d436065f052c77db5b4ef7b33b166bd2df6b4b24fb6c6e1059ba4bef504c04d98f363c10b2543d0e51c7a72880eabe32341c7fb8ab4586c2fee8947819b52fd893e20754fc7c31c3eeb153a34f7ed89929613b12319332d33145dcf0645ecffb6c901dabb26644df8d26c947db865867ff6da8b2fece1311f3d2d9dac059650f20542ed6deb1d8cece6ea39e19f1bea1d823381ea364a78de89899146a7e5ebcc8c37500f425be1590aeb78f6fe093cf2ed0dd3f37bdb4c3d985ac04482cdd3cc3c4fb727e2e2c17ee4ecd6bb035e4bc64cded6db467b76a8fd020e6b97057967272282a6e27e552c4a82b9d7c454fe3553d749cec7ef9511913217e90834f0b70162e687d315e084b9d6c430e4b1caba350da0573f2c292905a7fb5d76ee9b793f0c41150164602488a7a2bc46536e12b7dfea0e25c42f42c231164cbc59260538c39d3a2e09178f0771742950d03b01e43e691274ef53effa9e5019c10c17cfd60fc6ccd859eb014684a0d4e76eee6db1fe3c7ce71067d4610ca05a880e718eeb256834cad3c8ede2033fd976c0d861de47fc00bd27d72630d85c476b3cd1a519f1e8843ecb0f1d1591da27d4b35f1bab2e42b64f4303e6d634022a296279289ab90a66244d983964ba90dc9e5bcd7bbb452b69f8a964283e8da68dc49fac910867364a84b856a0c3711b07e9740932500068d118553024907a3d9d6e9b2334c18734b8be19981effb2dbb3bbbb9ad655490ec14fc54a61f798162f76be04cf25e85fe58217e7b5115a217974001b70c8fcd0896bee508d7d985570ddac45cf07372ebc338a388a496292f0cbdc993e16c1efb9b8792485d158d7e8cd51ead253b85ddda7eadff9f3b872248b23fe99b5c5f95e792a2088b1ec29310c7da3b3fb34582b5ca4c58ea3ca237bcb1f510066139d525ec02e26012717263b37e2144e1914eced34ce9d8ff92e35a17c325033299b411e7ac72636e96e0b9f00a0eadea5a0888a4b5e4f89b738d4c591e2af576ff8e7903c882e804b510ef6bc1fb04b137b680aa3ca31c87b5c1c39c365c56d48e8cfdc852c0c42506734f214856dabf1a2c9462232a71068b7dfcb268894632a865eddb4abb47a42ad865b71534e134e39ccfa1f13a6e96b48e893f35c94ff7c0be37fb0670bf17033d06a41defc35e9ba1fa24964e91be04953e6f92eefe8872ecd23675dd251ea3bc69cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
