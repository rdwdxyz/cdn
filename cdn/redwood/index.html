<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf0456e0abfb8f2f026931c2540c6a2b087a95978539487aa523614ca320ecd0d30f9acd730284f3344870101b0c0b5fd9537fd87aad08f908ba4c586288f861d7ad9b5e95c5661fc7a63076e1efcd853fc97898460ec8a1183600e12e606d689f9a667f48b70a487b6de4a34ef5ab6e9f60a2aa406c0deb00dff2ce03a6d07f4b6e2dcb2b4db827b0768535b308eb6dda5f4b4ea7b60fea94b71847cc6038c4b798b7b00474199f4a0db4936d448fb1a7475a85be2a0ab63425f885e52ec33c46c233f43f34dc22f0b768eb06b741f7be42624ac9c64840be6772595e71dcdb54ead1e416b861dc305d0da2bc22e7c072133689dddf0d2a249746c1cbe68e38ec0a300b44bb777a8ba332b112a617923365baaba11be200717a077b43d41325ceb920a16b0cc4ca411b129e470830dec9620f712ba02ba59739a7856838ec96b2d803ec012c46a29d7a5afa7922b74e83a2ec13476c426117554efa9d9d5d1dce078e50029d6079f74665ea80bdeb93644a30a9f0439fe16dde7b5e1bf2a41c024b6b27c9a0074f85f5ad601132360eac9ea12b58f830c96cf1d74150dc742a1f5c2d967796c6c25b61307823dad31c50ea89d8a286495be1cc6b467679915762d6c4d40c4ffa29100a4ca2863ef46cfcb45fbee3e3d54d745c4a3d85d19f637c86e0d57dbf10bc5ab8284972b6a41963b17ff16bdb0e09b35864d0d9da746b7769d2d68d12894b25377ae51d24cbe784918738b8c274f4d2a81a11dbd72fd35f0d2092f53d8ba9f97e7297675b19f209493bf577bd59f1859326ee7991ca9ecc18e4b161bfd43ef5802e8e31dd0dfb7f7eb84c952b1aa056a655539a94ddc552e61fd8915f796a29c711c188f0e900e98ca8e6db0cf39deeef4699ff7c8276d911557356fdaf15ebb2c07c0a6208099e17727ec09071f051307572379c08b79291203938bafbc23bcf4291e3cf62069d86d5915892ead8d6669ee11c7e163334981d1f09ef233ea9d775cf31267f9c9ca3fd9e0f29fd7a92cd5a8f27c1e733eaf7827d400d17c86e44fae85ab57e7f8db2482964a3cc0e98667ec6d3f5d050fe02bc6db6c4cc0b4e5ae6bb83fd2cdf394782558672b22d7cc73ab29497311634631dea96f304ea92251582d7154a92e349abf2a1fb1135e2ee98e61f512d2cbe1e737f0f86e9eaa266fa9d96740aa06f8f1f16da36d37ad653296ac345480b0577a2f6565c75ce3603daae3bfc85c93203c3b73f10f81ff9d1d4da8755a671cd9efba3cf8cb19d7ffabd2b84d57034acb0054d969846fd6f10ce6e98f3a21fff8c5bc534275405ea7daeadbf2f19b118bf42afeb18dbc5de9c98b88cf1ec962ccbd5b9ca8fab06855073b2f7858bd91b987b73ef578ff9ba1f2de904a91278893fe7ac9eee8818f36df0fcc7057816c296c9acb4b1c2d764ecfe98dc83e37c0f79cf7a1f819cbb6861aa9250f85be0dfc282518d9a287a41c5545f14d45aa7328e1057baa99fcc305c58bbbc29f2a12c0c500b986c62c21318c3c3187c1f993d49ee5815449cc45531fa5ecbb67e210943c87822c24e0028c8f71a3691db3661355088e0dafa87d19193ff1e16cb5c046ed073dbd74d162a1e2edf42c61153d369909f96bb3eac6395e5fcb0fb3304b66156a059860c7096cb12f953cdc09667c73c105519429b5a49bcd99c5d9afb68003472cd8ddf0b69cdc7d70d2c8cce5e2da5d032472a186ba9b9b69ecafb7dcd4dfb862b08b58b972b28cef9d5792e00ce7d1086de75ddae7c9e5180ae45c03139fcc3c499e6ed29e437dde40fd5ba720b07b94b6b61f6be55133e5fc73ebc628157fa0fb63739604556437e5ac16673a465f8230417b910e72fa421462f2687ea6fef051d58418a825dfe2eadadbebcf47e7f8a0756bebf62256730e055d477327a72244b22b0818640da5d436cbc398f6c3459575bdc2bdc72385e2ddec7f4f254739c8d421391487b278c87a60005c1884ba9b27a0ba4469dd5d3854625d29dcdb48bbc0f527bdcaa7aa04e6ec7cbc40076de56d24616071a96818509da1cf315818d5e601421ac6faaf9fd222829f3b2ae477a2e39da3ae275cb7b727404a79839782683225c556dc22a3249c1730c96e4f7b1e8169853469882c43a3a2dd83a935e73a7a6f58dad1ecb75b96b216b5eead9b2ae822d6b79c33d32457840a64a3ceb1e7de3d8a6d10583f9587c5f951244660e1d30060c52479474a48f3378e2470c256be72f40068b786e4e120120ae6ace0ae17912c01415cab56df8d2c40dc3b8f51e68766aca027819a2ebb6d6c749d3b7a0f3301a974519fcb9b102c2edcb598b5af67d1162a958cddd57222720df30d7ee21ebf7ef5828f3fe8ea805f3bd20a8d758509f811e96ea53014753d1aa25963577e2d4a6678e0c65732457def3419870a5794155c97f85278f0ae3b7eebaae636e4c9ac5ef7f6676fa2ddb0d9b564bee86631a0366aee462e0c9cd34cff39fba3e402f18b806feea28bd97a78ba127f40b9676a0946f73d5766d3b211deb3ab9e0e99f7f61b174a969b5996889539777cd3ce3935326027717ef62f237532c8943a3d4b448b4b119392bca49f4912b4a884d78acc66a590f80e47394337a722163dfb465a21e37d3ba1bb8c64d93fdaa35a68519b3aaea797ef166d2a0ae088aea9aadae04a8f938183435577b6c28f5becce676e3fb621e6ffcc24588dfdc3ed43f621d9e567171b085c26e6f38e059e2540020b3014b671fcbfa58a25f99a23fa8e790e00ee24c1825a51466544105126801d23840ad9fb8d09e81de68bab030f98af6fcbc3e4fa8d00325ab2f1db294fc1b577fdf334de7ba65fea4f41321772d608a4cbfb4d81cc22fc6c872f851141d29be54039778de4e7fa8f272acbf0be8b87ec7d9610ea37af07ca7675bdac25e8cbd67655227b4595991b3430a17cb8a04609e0eb52858ffc700aab7f9a2f7ab1c6c58a9f7d77b37b1ad6130da92e5b9b9098e2b26a7beecaee5d22a42bddbbc97f6deb8cff4f23b6c7ca72d5ea2fdd3d196fd857abfa9e8b804065183b415db4d5ea44cd1d7bb7e86617d42a794c4c76c4e03a47c745b233f8093067fe4fc38d084cca4660e7e006ad1cd2a5386dc29c9906a24b7170d6103e275260bff2ddbaefc160d43816a11770a715d9ddeab76be4b6c8958bebf83e846a072ef0f33c64446c36f333317d6c7590b49a650b951f7e9b269664d4034f6443e4dfa543cd1d57296438cc6182d8b601365cbc64e1d3d2af4d5a01984cb1dde86c28a05291667e6380d68291e24375793180cd4b818f3c56a041c37e6c9d7b4b046b0a761553a0adb88a2cbadb5703a78b4d3c805140274b3698ab1754c8bc7f782eb1b9fe6a2049360ab6fcb116aa140b9a92056117cb437c9a36ebef2348094081fa61909481e7848f8c4c9d6b5a7c66c912c3bbcaa89ee77eda8eb9fd5454820a4dc43f5ee2614ccd4716c5e60d0fd33783554698d41f6af7b69c4e88b2f38b86f9c765d07e40edb92b2e155a57515dc73b90528ce3b0ed46c1635a6c8e4a8c8db7c9bb01bf28253beb9af3712a9f3335db4b9af4c4ef288a069f36d26a25e52e5920dbe5955fb50a4a66b9e0d199b9177130a0d52f3c316744fc44c06720d7c78ca726657757b384e8fffc916a1c7aff961ad7b852f901d305f4aa4518693c5ef011430cdeb86bd1695aa9266618f285f69e383f323e1a2d9162662ed216dd8f2f944daf61a4badb6bee5aadf5ba9a56acf4b3e4ce3f33a94d74ac93c1508067d2827f2d414cc029017d205c6064ef646beaf2a3735020326953a646bba00d3089c0e0eeda6ea71b814ef7f43ac5aa6d29a87c527849a348080324faf10f65d62ea9a04d68bdaacb64f3b58364d2c96fd72892b0c1d88b8875f499a2ca86d705df7fbdb05852fddd2c877318d26f1d4b6c61cc789baf5bfb06e4ce5cbf8befd46543b785f65824e7c27f05d65dbb2c971d9fdace17e3d85bc2d9d350017fafd0eb4ffc9cbb5ac9026c67408fb28e19c8215decd3987a62fc08b1de903d81bbc4960a7da4f67150247db0c0be00dcc6ff330917af5282b9b882632c3b320c0a9014fa316754d625f966c3a04ebcc5a71b641234c01f7503c93ea75c2bd2f39d3fc2687a39bbf4c7044f7e8e3fa0234d6f9d0a3c9028ff222544e9027d8f61e845800921608ddf481b60f71215b9d1f11d16309470a0a3dc7e2c3a25fd087769113fc2bc3ce87b31c46c5ef5b6bc0e23f017439b7cc3c3fa1c433f9f30a320b8cf4608bf537ddf3ea780a156e69709f8fa41984faf5042a6a1a2fae48d687fb13efe3d6bc1f394a95d68b198cc4a59b5f07cf96de4c6872792ff742f23ecbc52c0d42312c678001d98b524e12756c1366772a540f7e9b9d7ee0b690947c222691f1089e531895ebce7c4e9d93293527b15318a111efef2ee8b63032ea7a6ebd4da0557911f2a9df50a03a32d5f77dc372007f048f5fd539628c4c24e98695b90d1bfa7a9c0b5b59e50a0e47b1eea7d38a42e6a2ab2e52ff18214cdf4f379d1177f15d995ab7cb67aaa5ff59ffa38fb37490cdda449b34c391dd2bbfb304c6f936891a2eb470eca2d966aea7c990e6ab8026b7e363658d936417a399e92d52222e77da653ca953b5c8ad045a95977e65a905d79ad54e7461571f25be34a0cdf30f012a1d7d660c17e2d75ad198d0b3ebdb60cdce29bc24a4ab81fec410e5c8197af3e9e69a07ef68eed3e49a5f09ac6a744a112cf545d0c4c121d8fabfcc1126a2081a17c55703db980875b532d7a3de98783a31bdd576be77908a48b7b75d86775060249426c94a2e6979e180df1dfed71b125ef65c333287f8d06e5f13285ee39fb83f556e8bd08496cedcd4afe85b00e35a2f685b028e8210c8c613c2bcb43d493148282f227d7f7101410c8d8b9639487e9eff755180053f9b401b6aa55ae96b2b1731b251b316aee49fac6a31ffbd5fba26992310ae4e7c440414e752d3a21c99ac6a76ad37a69287f7801fb6cf31bd09c3e5f97048d82507656a386d6ff15d104dc3cc7f5cd8eb577aaa037791b637ff417b842bbb6202214c66de2a4817227fd3fe79c95f37c737b4caa526ca6fdfc91b1bbfb8a8a8d6f0ea14d03df8bd6912c9a835b4501d8f00c541fd6579f35a5a664ea19a572440cbe8957b00f2c87fbe326db12bb0d1989786503b04ff63755d440656de841f81ff9d426981da81a89725d796c3697a2a3c0e250de86f50e24d4bf7b7e05f1570d63ed528477097bcdf3f98bb937b6b0b25b9bbc93a2378efa9a0913b65bf16dfcb29047bae40adb142799ecca55c053307259f96e9423b0f004f2592507a52171f9de5f18f95418f8476e065f336f8a17247a7b0aa2d0d583b9955d40569b254f5d89338605e5bc2c60329f7d7bbfb4b9262fa1cc03f0ede0ee14efa85537f4eef27add1476bffd5b5940cb5f50b96074bcef7fc44ba71a18e00b3b3e2943c2e0797c1c46efe66c77d2148a06a9c0a906239e67af6f601c57e0e59cc6ea5efbb7301bd61fb5d9a3d4730b2c455b9dfb39a1606a5b3bb7ac04f279d7e469344ab4a40bcf18a5f4cdeb2350bf2ad6d507c0fdc8ef14802642330d60d0fa9dccf11bf389edf2ddd7a75cec8eb588f0d458fa0fbc16d6e75e048890cec99ca89eba2cb619a671aceaf5d81ebcd962cf739e229ed52be921a52a5654a4bf6505f0172629ea68b07c7c70376b9d48dd1a0d4474c7926c4b3354605cf621cdfe047ed0716b1de808a0bae8d7e65a28de5ba2b0e78f076cced3b44126791b8e0ac33501d45f492bad2996cdb84594ca049562d293759e0f7fc1c4d812e895ad322b9cc2dc5e5d2eaac7f812f37db20faf586ddb36373a2716bec1bc43312aabce67f6c6e29c3872d4ec473c83a4b9d8525ffa27d8a71effa0d483d5bf1f7c70437622ca0905a03136c0bebc30a16ae38dd022a07dbc497c0e1babd07f4dd098651db242f3c2a9e42ce172dce71c6bdc9e374e5ef516b6ae6c8cfd6b9fe7e01f9921b06c64eb09b32ad2a0a38c9dc00076d71e92f77bdacefc43eed7c3cb71eece17afd02290a89b03ac13820d0a8678f04d6950075c2e7e5ed566ae609f0a7d12ab1dd9ab1662e14b4c778390fb459c021ad15d083af5f10fbf595c0dead7e71531b59764cdffcfe0605bc6c02ad148ed55dad185672dd39483de3859cc0cdfbe20f8c0389311c32100f9bd7e9790ec3460959655c9b2088137102df23a334d1d23f896a618302ece04298344707a41f1c5fb137ed0ce6fb4c7e77391317e76978c7a78903d9aaf210dbe4b5e9d6900251012bc45b00ad8ff1dd4eb9b48df0c0de076b20995dbbb4a60470b3498ffb104064cb6a642754e1914bb5d6a6e83798f495d9c7c75761d84f3e4b374f4c1d51505be698f2a29f0e0f845ce3a17eadf5c35be07c25b9659e5980da16f6a930a07b5a7ce3e76cb7e3d5f2b13640b4f56d34fbf7c5ea45754110e0cf9187551bba4b9519a415e889aec9d03e9bee30402be45d4b931f06848509006b4d10a25b9deac8e74e6c11c2eb8dfc6b5c554b54d40bd4fb9283b7e06ec4602ffceedcf8cdf0b561e66c2009dfe6613f05fb794873d6b9d11e12c0d9430d999dc482ddbb1c6bc9ea55088e344c0bad5e3cdb6a19afdcb1814ce8a04bea62393e914211a233b36dcf27058d07941bf093b103a08a14bd41f07bb236a5a10be7610d1f07a2e36888c4e6c900988bccc39be7de536b9fff3c7435886b5382ed485bc2d9c83ed47547e1dca179460eb9a7bcf5b84950f69cfa7a02dc5a4fdaf80cf1c4a60a80d5937035f997c9bddcd1b965e71dae080acd014d39ed60c91e330ccb2a63df8728802fcc7148e5c49c7e5e5ac7411d86532e57ff7dc018134e129e411bfc6e404e72d02465533633b84bfc2e0aa4d44382dc0801fb0d1985ae4ef186a1ba1f69ed1610db3477bc7ebf285ce500cf0fb42c743b6903a7bb764f5a74acc94c9659e2f7ef2c575875793d75137977cec21f3d1cb54b125bbb8df7441dd55012d2dfc61ce9dc97ed641a01b52d97b0f3f7c003dd9b501dbe968a995118c91ad3612ccf348de3ae268ac60a6f1474f1d3b221efa24cb63db18c3e3b2b6b8138c99820630f94157f89c67953b8a205cc8e009a5fedfc414ce68c50e20eb3ac6fbc307032bda21b9266415c80a236d0d79f97e9e80eb9232bfe90972ece65f0332ddd28567fcd5e235d9148332dd880545f039455b1e7d6f656294215fdea4dfdbc9eeb966d1fe6ec32b16175cdb765dd7e294384199042a35b53a18f1d89392691be65b72d1061fb65ec18377f9aba3abd46c175b34d4681ff203ff566b226bc58dd9bb492a244b6afbf5b7d3ae94717f1f22270e820ec766158093315a4383562ce2d4b3665a26a1a3c22c80c25a86c4a38c6926712cac72f27fa1589aa5f580d145400a8896b502a9b8f9c5ce30c62dcdd21e3fbb0cf9fb2941a5501e9c399508ef8d4d24508ab4df20bdd8915f117ddc00bb958ea5b0da16fbfdcee69ba2b95b58d0f8dfde23c330ed1c4ce659e91bf727442e3c00026f44f558040021fe5b530dedae03dd7d29b40f8d2cc3a425b75312fc05b5d5da2628e26380efb3581c85388e47897c9fa9c455510d3da4d73a7bd138c5eec255388ea9d7b4b396efd22a78b463286432efda01e8bfbab4c0a9a4924a45703f6452d6fb5734042d781d9612b042449aebbf7f12e09057e2c9e960b5d13421f033e3214751d41c186799ceadedcfc1a7ea89e3b66777bb81a3fa739e10e81b51d5d40340d4852a92ec85fc92112d09d1d2afafb603e05c19ec3b44b082f7de46ed24a60aa928f90676348ccb5f621b76ac500b4002aca9568078d257f6744d6ac18242b36b6c2b9737e73512e8ea46a30147ac224cb49e5644e94fa95396353755032984e1ea250081977216d5a2e3d178a351076e9c3345024d5168b1f7d70e008be137c144093ccd579cc7c590ec2f97592865d09b7bff22d9dc500f61783ad0abb28ac25b1fc4d4e30c6eb9304ed68b7d9b5ae8b0a534f565578abf9665ddab7e6a9d319465caf97b36b0707a2ed2d263bbfabdbb32636b9eaa4a1695f904cc4901e3283ee489d1744fa306650d596128f68a26b76a6b8c5a5a39dca5610ac0a3a7a937f066cf1461208d1aa2888df9dfa048af9b167d9e76800e8b6f260bbb024bb392c8470ad7deb379416533684c73cea48882dc439c33dd57c99dde06890aae806317f01125451e0fbb0c9adefa325b98b4c2afd57cf6066bc77aaf3295147e5ab6c6a3bc92d84c7df084a4a633080a7dc6a7ecfd6b73e3bf0e63b356f3f2fbf38d128863afb57f4b0873cd7408556dceadb1c802ddcc6246033021a08216d05cb9a27ab0a190b366cd949803bd2c5197b8f20bcc49749dd3fed023ac474284accbc85724dd773570445422335229df68fd865eb4a3ec830c9dc944c7ec79491b6a63e37c888026eeb2746a55ec9c2401751aafd32f28c5a862513133a88bcf88e577bad630f1824253731cb3eedf9b54761d58757068e56edecf738bc87e754ef9dfb94f50b64bbb8c0bef27751ff6e933221516ea0bef67b3ae4f1198366f8863818118ded0656f57dc6fd2cb00d370ace61e0faea49201cbbbbbf02fb59815e76dea3f38471e990f6e2e8609fd1ab9d0237561d517980d10d29540c511d51d8e17c729d88951d2710c31c00ba2708b7130dffa6b2d99afc114033ba8113b3cdcc2c7a902fe2a4223eb111f57f291de5cf8bb671eb3b909171d776ea003c36e6a84df831a195c34f6aed46105ed1b4eed38e20367558f5b08e1e198f9cfbf51b08959d48d38fbe4d35fe4d747b33bc9af5e4f64ea7964589940d6d714bc9aa5428df90ae8d4c38e4a523541881fad5690541c3ad2cd372ebde610ec46607251d421f0f92e7aeafc1fef1a15b2b60e1926a9c52469ff8ef567b356b12ce10b751d7bcfe77e9894db30843e0df48da972c5c68c0515efad8d9799eecccff4f137a76b2dafc0a329e8b60f84cfd0b31b8e0f2ac4e8359e42be3c4a6e2ed09a5bf3fce46959ca6ec33b9eefbd63488b8b41808e96d0346493dd12a2d7d28d6a4067a0ddaca6f9aba7902c1d1ce9751a6188fe895cd2f59cd4767728a65eca1bbba740676c402e5b7bc107bfa6cc03b73c280a36244b43da8bca2b1c35be03abdf5361d7c1e713a1b95b13dc0c14872790174ee26a5c385dd24a7ceb3a514563e6b6c42443b651605e892d027af61cbc9f6f1b347e2fa7987428fbfdd751fc235a79cedb44b9344bf98b8c2a1ecefa69b2b4baa03c910f90a72e4f60096e20a88952c0a5fca392a95f91f0d3b4e303157253dc114cffecafeeea010a64162c66741b48e19eb01bab7ba0e831d9278d07de23e8e9a374c204e9fe80afcaa48eb4957b55b4f7726f5827b5bb5fcbd6fde061ff8545718c8c7e4b08c6933d5f9a425ccbe4d4a79502747b09b57614ee26fbab1d0e40b92308b196ca731400fde6559b346f342a7f54c63ec22e5c9cd0a9444436d1f8a8511f4c9b257c14c3294df632f5b4c241bcd692b09ac8192fcc24a7157f5181e26240a5cbc926b7070fed7ae3c527719daa91ab857f5890292b46689b52397de9ef72ab206eb8830fbdf4562311554b0538b667c25d57f7ecae3c0484960f92cc021ad000209f2e6dde2d392f96489c9f0554114b605403b990bb7cd9f6874e44935c9f4c7c526afec8c505410dd26ec74c36ce9f8715424b9d0e5cedf3da52cc705e6178c890de62ae54f8d2f217319b8e4bc04e8bf5240431b80d74ce64c4f4a19149c876a3baccc688bac5e3f97c4beb893ea3f9a0be6afb6e2c6e06155a0fb3ddf5c5cc877497a5aaff69d382f03bee2e3dbc8d3729b3f511529448916b328ae85d2b32cb6f89a30acec4dcc3d87b3d59cea5b738ebdbacc842f47ac7521ce313ebc8450e546d11d6890b3f3576aa4e902231904b3da030951e5c1a0bfe64e5c0b041fc8014f31fb646c13901896c1fd932be50baa502d1757e43213f0af402d06612d0ea6e4fabb7a9caf8c7e6b4a3179eaf5c18fd6a2d1c471767251b156c76ee4f1771c4fa854f75e9a23856f42296cf9eb7d2182215830868a3af01b55604cc9cd0706b03643073407815a0f424725dc7d3d24a00a824dc35edb2970e7856a0066c5e54e14dae90ae404a3a4894f9e12267254b45b9d990b30e91154688cbbff0c6c225b67c82c9c1b98c8e6e1a3eb2882376d5009a1835f97b8cfa24225e5a2b9888b2f55e1a2dd04cd6faca741f9ca91633dccd80412b40adcb991fcc747d4fd31d399031614f90ba19d962269887795f5b069eb1fe7942c2fa124dd88bc46a40a93fab3974073e45ed0566cd8fe857bfec6d4de786ea3108cb8f7f2c0688fbbd38047337c1707a42455e16e47e4d7a9a8ff69ec3d8758b01d86f45b1aaa4559e182b6f6eb33d473f8c0072d62eed13353d3a184ed0681d82fea937a5191f806eb1b1c78504cb9377302a5c91a3181c52f41a9892bd95c10c91985d46bde12bc276cae234c0051fd4de2e0ca747fd25368d320a944a5c71e96ce9cc24a1d8e25d2e27b244a2dd6b9d8b287b2e7dbeaae68aab6b2333eea51575c0e2053789dc904f8ea14755920a27874f077aac105722a92a88d281596190fbb11f95fbbd425b3811a402fba53d0395100c13ba018ddd9e228c1b2edba6d8bc6482b488983b7eea51007a040cbb287230f84413ca2230f2031f47105bb015dac0f4a75259866d277ec4e5da2dbd8ddd2b681c28c0823df6f0a1cbd3fd9b61c30cddadc5b2a728ae65196772eabf9c1eb778898a5bc50266430abd554c0f8a9d041de2595d5e59c2f57c4771559a87cc110b14a4065e2711879fca2e49654bfcbc936126496ff0a602b40390024c16337be481af9d9b6f978fbd02ab65ba007f350f5b103fd2fcca9fb1b57dfe2e26a6aaf765c0e7690a7403788664b62b3de0c8adfc7f1882870d4919f8db72d846076f63808fb7a1f5dcc2895ad7ab6cdcb42cc6bd4092065114350071d9cae79d799e202e8a0dbf2a2d5b8cabd250ad801bcc7588a501ea5fda938ea3e958221a86f515cc3ca163a80e62803d6b814f81447ac3e38b1f8509225e0ed5ba42362988a58ee76c576c973cebbcde14c7e5cad995bd8d7ad8eb9a0b192d78677f9d0727c506d5ac0402f7a4ca89aec6fcc5d17d270256508035ae466824c7198421e8368eb82506dfa7340897cb8ee18516c42aca73a48d6f554451d84cb894b83401990c749e50a77961d792b2e706c3312babc11f7ace5cdda51a5383ea4d03a9313307a46e1b6e108448486992ccfc4d67f8ca16e7805dce26648e9f137518f630265ad8baaf08b1d377ffa0aa6f8c6cb8845e01ca3356b048bd5b33ee6bcfb48462e616940fc043c24845fd7369be2362b55dec4c10af783a04d6ac4fdffee169a9b6a5508fd3358778d6daadf9f1fe5d78f0c2cc5a0399179608db1edd34e0028cf3b7e5edbf663ea66fdd43977fa1b82c31b4bbca1a490c87797cc2ee99e2321f1e8fc0c7ec3cb6346c6480c087746927fe372bf082a94b9ad792c76e06dbf5c90c6a0bf8afa737fa541a3cdb7f77162dc2baf90cc0de1536573e0ecfc315e6a8479481968da35e6317a60643e7077ffc258c61bf53c4756581f3492dc332065f57ef44fbf9e74e6fe5582ad698499af769e7cda868767e1a8e7486d1968ad86132a40b519efb58225f03e8a38fd9eb1d9df432b77ad8a41b304d3f0ca19842e931a8448a981a556e3cbf3be68172401d50b198a3e797315886d57788a872686caa411ca7ae05af549d8804938532ee35db127f5a4cf64fdfe46babdc98bd6730d02f5b56f60c784d74fa7cea532fa586138fef254f2c25ef9dbaa4e8858d29901d60b2248f1600ab3c3d06e2bde5456d8171068e03040e804a1494fa48c0784be95b4634dccb36d47c52a1bdda7458f055466fe2330f5a6de8937003e8bc9e92a4001e354fae3c0d6a305d3a689113451155754515d8a995e2e96443702d5289ace1be92ad8797e3d7f8067d45de17f00bd40ff4a51a5198f2ccba319bcc0d94c18e40ab4171c3b2f5a46b3413906c7ce11fbbf250c853e75129497e8c29c44c96e0c149e4b5ac8e1946dcd4e74729d8b61fb1ff4e521693bf7b5a4eee816f4155294cdd2ff9d0e5fa67c1eb2208611ac72135afdc3fcf727d3484951550968bf4ae6334e96803b53f677610dc848f9ebe3575889755e68cac596fbec6a1eb40f070283f8067d02002504a03e55ebe8a48b467c4e244d9fdf83bf9d7eda3424661cc94cfde7a52297b6c64cc5a9aa3a783d2ee55269900e7dee483c98965d2dff7503ce547f69be5c3b1e24b13fd6d6a3fe4a48735024a6fcfea0c1b2ad6e58d8979d304b4a122d9d2154d584124b93e9edfc1d37a5c9905d79e5a51cb4174560829135ead52b495c0c6e43b60cce7460fdcd6b2872ad8d11a3ad580c24f73a25e9785f79b5a3f6ef8e3739069e5ba79ce01239cb85bf737042e0fcb0a98e9cc6a2b55cb18c82687dfc7a52be1b8ca4422c7d390e095d307c00ff907ca1e182dc599a97fbc7dae7b71d17328fa8d0d6197a72e25b7df12e771bbe95abc49f113823259a4a6efea5e9673c5eebadcbe02d925205a1464d7493e5bc124bed23fae829a2742a6a4132c94a574c480b74f1afd01883c2394fee19177bb7718350567840529fbe7160efb3286e33823c2186a4045915f3d9dac4551f62589cce8e54794ff672a34cd0b0db127b02eccfbafa990b98b72f75c0ba70da574b7ed58039b6437ac7898fde9aa1212f38ef3748ab4fb03ad31007d0a5ad976f549f96b825a23a8f832918d671b62cd293e35a10562557af77c944433fd710f82e2c78812b9a1bdc64b83dce7356a6fc69020b20f6a097af67515f3af0787a3fcc9232439d5726c33a1a6fb52a0bdf3f0efb2767cbaae90365e6dbac62620f5910d95bc6ad9b0790a6368299ab123363df6234dbdca42ec58cab6d2368bb4634ec00dbf356cff874d6d7cb03de526df8003960a0be5d4f1805b044ba2136f08b36ee63cadf7337229d099d0e06702c2a46bcbe7ce98175772bda9eacfadc67e352932cac83a17ef76f4573206df946d6f43efc3edbd39a499e678ec24421d15c4776ab7678103684f92a140bf39e401f89951009b6dcd3c76b1778b18c70a662496f1751d6f0ec3873eaf21528c268e7d82d05c3ae7db2c6e11ef38ad05c5cc8fa01a9ad036d09245ce176d8bddd71d03dc73d127d013ab977caa40eb88646b91c0cd9c0e04931cd7b93be269c35a5aa126dc40f7ddd346163888024a0a50e7485015edb67245f0ec41f45b53e80beb9067a7baf6e663abcb27f9932b8a63ae4277e64de57ae73eaafd8c410ddcc332033534793ba4e00a7fde14907286c8139d7f35112ea9b3127242d1f4afe04c3244e5abdac8b3f1033620a18a07389e3dd63ae75e17f1a12a5940f88322cf819d937e01ad4dc9d70118e30eafa3015c27927f88bc5e7d1274db73d92b66733462b454784afcd4b2aef27178031208b1175ccaf6903f91fc47b1c7156efde9161d15c2873990c16800f604fd7dea110713e10fc04419e4cbc562ed2c62f63b7073d4e176f417dbc8ac8c860106f04d75388c7a7b0a199eadfbd35c61e73ef8aa82292f5532314a3ac485911b67ad242eeb5d4c298867bb3c31b417e1f753faaf68477cd179cf7693829f3dd55bbf6dc1d047d7ea47be0b7e268999e962d00bf9627615eb914f7ca497c604630ec79043283d7464d1d7a6c78331cfa63bafdf9294c49aa0664bbd24cba375427d092af9e94de816c0c4739652e176a76a1a242d0e3ed2d6c3a79cadabab0e9bf53744ab4ddd83b7114eedbb03301f5e2825d5a9e2f274b7a24ef57b564d94ce1e8f2b9443fc504c618e6907ccb23aff6d14ec5a23a57fce866ca058c945f0674f7cd9a47b36346e7c5e67e6a695b019de51270bef6101069122d68ed49084a9770fb2588a061ddd60aab1d7e8d2e686d0d480670e5874ed379f0cff5113f77e4086027280d5b4f8d2a7cd9ad948087587cb68056093e697c7979a57ea1f4b29115216f573e9622355a51c2835dfbbe7a02c77b444c1829eb89432a41d7b77c43539fb8640a294eb5c0caf18ec522f6562b3f30c5ed2a1f3a3880d44878dfdbe4a31c0372b55262201515b367c4d74bbcd818c922342f1991e08f13d26381f9ba74c88e9e130b26f421d19aabe1205d8568fe9a2d519186f4f990f1793dfaf8421cf057786113d6226fba935157280f32b5aa29145f84631ed9048d588eaf30fa42a01e7d49d974b22a60d244ae2e40b90dfb1444fca593df1a2bc06d3971695d58c1b7c2c0871ff375ab8fbbb852fc23aeb875d2de34df8c22c46102b0c11e164c800252b214147504f8ec386b97466764b20f07d675c4ff593620461ca8cd47388cbfb8d85e6bb76c5b99b4a50381c1ea50d7821a0755cc79e624362fcb4173234396560d04a693c0e5854f2f78b4ccc1ec963622927f5061a3794c64fe5e8ca71a9c2803506c1b101367cf127188e9f98735514525d80872cddf7b9400b2ffbfa7677260df7c5cadf9c982bb41fc18aa32d4f5b2fec8bd7ae7b1ab8d29e79883c2cb01a3a39b8e80d9bbf6af50572313b8dfca8d41013b8254cf05b2bddfcb1eed008410c45d49500a5674fa488654ff4b75b74039844b0d7f0c3bf44c5c17783c3eaa655177f76fa6c0fa3e1bd4e7ad7fc7291c00ec9f51b3016afde766385fb053325efe86e49a10165f6a8de6e0edc69a2d4408fbcbbf7ab017202cdd8b1bbf87f557aaf3359df2e9dbcff982abae52d2d4da466a1fd66195415dde18c819149152a24e4a1672dc06a779f7c3c5c60922deded3634ff2d56475f5c0afcab7ee8a4e0d2e50c96b43b309a1b786a6f0c6c5388a40497a1ace41f1ed314f8785ae7b67aa869d427e674e3bf271aaf254805de64c1fc9196d3b31d574ba3007a9717534effb73138b7316628d75f7cbb1060edc11efa7578b7c2ef3e33f828b4d938f7541419167e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
