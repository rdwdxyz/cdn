<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ef01ad27d68edbb985236ab7eb3ebde2a2356e64108f23a3aa13ebd670c0499dd4c8a4c56a9eef05f7c71e508e99e7db968b2f0eb7963362ce09a9aeeb572fa39f8292430f85fe5996610d76682a38e9ac405077b6439d2dee15a6e677a12b755b54214c6333bf588450493b9136f5ad204343d139cfc5399bb48ba6ff39832a02032a59ced105e22ceec16854cbfcbae43ce828cf98d1bee78b6898c3b96cc515baaea164093d99248b7071ccfb072e89c80ad67b2f45898d4d304e7576f46b836b09375f749b069fe6b9cb30f1176e17a085a6bc208b30358413a6599a6c1001ca950be03a18490fd04284a0fb96707b6eef6f65548e4a85f8ae9ed6ee7df1b9f7653810838889a0b3952dcef688c2877bafeda1ba1ffa3c0500d946ac47b8d0e92ece5709c5241b714dcf725deac59d795f55a3c29f0164d2e44c276d8d4ae304ba19b0c2bc0c79b68037582533e188d67534780c9671014bd5430c998418bbd1e13e038a342d5cfcb829c48c2856f9dbee4691438510234166b7dbe28c48342ce4422e59cb1cdd9807d94e9131ac4a966e7fca044298c0ad65d61c965365c40e10c31edafbb5c759b0fc13b8759e1ce41765d36ea7b0af072fe877fd91b06cb3cec58f54d44b226f7183da89cfc30b7bfcb7a4f2e712a67a54bc7415df5f9d6e80638adc1c5937d2105bd51e9e2b176f148f147ff2912adacfc235d888985bb62e05cd83596421e9a9117613dc6f3d8ab6856889bc4ddbf266025e5b950274fd4de85bad8b52979b64b062f236ef10b243e43211c8758c907bb78f44e14c40c57723c7d7577191fb0d45b4ef00561a320dca8b9017a30118ab473467bd291ef8e11b1dfedb247da35cd02b382848d46f982bcb7493dcc877670079bbcdb8e41ab09cfe3a583274946e3527467f553ad6959b2bc1c879fd806515a4d2073c09f29c42c8e2cc7ce98dff9af7f68826ec4d621296ae2492f02fd0f79856449bfc9c2b72ab5130df00521d1c82b7ca5ee5dee3f5795b47173b6b5d2eda0a68e7983cb7ac9a6c1e0d63472c1f7ef07ca783f2bff3b4e9e3fe46773af326e00b54caab226badfc0e76635794414d2a1600a029ecec023fe0f214de2baa3226f5c343cbeb42804e2203001734b8dec3c10a66b93ec7393b8bcdf2497db449fa700aee990fdf81ddcdaf0e58a69dc7c3a310664226fc0322b7b35571748b24ab361bd6e98b0a5bb26487978ed5eb3ca7e4164b83ee0b3c6ea6811c0133e445442ac9a97b21887bceb7bbed6d425a3704dd6ebfa85b9db8ab2851952f6367732fd6c5288b25058f7e945e23ff86783539c05dc2c58df27b6a4c362334c61b3c71a31bdb7c24684ee4ed4c3decb22fe098ee552aa286ef685ed035dd113a46d88467feb2134804280381b68d897eedb5a922beecf31ba76623b17aecb19930eadf791dad3cace7615c1e78be77d837d4ffc332d4564d991bd278d605a1cdb171b470ab1cbe5b6e7811336dff479a9eeae0b83028f3fe535657523b0daf898f21f0aea83b596a51d4a502f07e81c7652fb26e57625da9782d4a74dc42fa929429f9af208c941a8cf8c389f3abb3ff335b310c0344408854e61366306cd81deb529680d4c40938f108d6607421472a66cf0bef93d7ff39ddb3f42fd15e2019591395dbc8baf8830e23fd69b94f5aecb571be73ee92cd02835568e47d7dcec06c599b4b497c591c88a3ade58026befe39fd82be89105bf1a81ec5dde21adeffb23cec46ad2eacedcf507b7c00f338ca6a7274e72df3c7160f248528864db1b160f6b4cd5445722f3a1f396335bcb353148ce37f3aaf4f52cb551e45999792736721b32fa22829c83455d1cbe94e819459599d5522fb0f63f6256ac4fa1a3daa2880b09823e12c79ea3b2c57267e0d3841619e7c85f24b362af83f6977abc1df8820ea324cd9ef3911d4e67f25df44bd59740756d7b44fa131b8516912ab036be06be71b6a1c6bfd78ea733ef2903454c6e89cec8e02bada5918bb84dd4000811e75f09373323ae2f1b579f169f42d6715aeb9b7acf29ded4b60a5db54c155f795c4de8768ef4b38cef2e44a70725359071cbe1bcc12e2a36e2f1391d5828d70102df75289126e92f2309afb9ab7d1c00f3ea6f975ae2b10daca86d4d8eafc8fdf9ed6a28040831f075300388d61822395759117602298b4396cb7377bcf6f1f54808b30c58379e2d73955280a2ad007eb8d470edd7599a6a620baad777407c688e48d07781d65181d6d0b13baeb5afe5bccc02dd09244946599ba5db57b91fa801127328e771c1e929355da1250982e76b0b2e55ba5c5c3e5334c24374391164eef42f758f89eff9edc7cc2bfe3343da8403e9662ace765a6bb1ce0f37af03cffa5c24bcff2ba262a6bee9bc29b3217daf44716ff07ef88c0557ad577f373ba909516e8924f6c335a44c0258ef7005e04a4ae8f0121713759f0096b13ac238c796096ea152510e63f2fb85448d0d76e2d975f777ec162cf563ca0c738040263ccedf873650cb2f56b9b27031846696ea37624fdfc30afdb9a4b1ea4ba57b433dc49c1ff075e6ec023b6013d791be694c91b293f7bcc21acf8f27b2dee89475f26983d9b5d166e3b979a37442a5a0700736b762789629a47795040ded491d7439ee61c547de86f76e9e7ad6f5500e2bd140688b8d23099eb8b4abc42ccdcad9d8d70890803254fd9770f38cc848c618a94f89cc4aea78d2147a8e8d183f457a528eaca55d653aff57ef64dd3d04eae1c5635084c7454056d4a7b6ca6fdcceb977dc7fca3f84ecdcfc457a802fa3b6c93927a077b6d4a55c690621bc5b7d182b0c8462a4ff597ac50ab98293a4e2efd62bc54419a8521d28d816acc3cabe759c58ceb8d848cd579c53cb489f3a619ce69fb880420cc917797882a7bff159dcd7316266bb0edb7b61d241cc8cbaedcb8191093f520ea454daaf89404e83c24540eb5f7497786b3f066e352c5a693dba555c531fb8a3bcac9f02546cf547d950294a7f31ecf61e3541fa1dbf70f61b1cceb9cbe202f3260c8215e8339551d22dafeac2111e64f4952abb631da943a4a8bf38d8e48583345cdbe83bbc26b79c859981af2392c01d7c7e0b7c7c3a244339b63f1ebf7a5d5d650745f22e504bdd7895d485ce27cae2cbd90fadb16081f11560f9d2a58d9e4f790f34f9fe95bf9032c5102d522c542a12de2598fc0e202f03cfac4fed09ffb8f7d45ae1e042e387512ddc580d70224aacf1af69810534dee997739a9c54ce378b65939d1fc6d5b3f1439c1d3e329f803e9f3ffda83208d28d691a814dfa37d7671b28b826d9c86312f2737aa8d462b1ae5929dab8f0d4a9b71ef01defb0790366fa383b78eb8f30f32f8f30f3feb40818f9d493e500d3532003947ffdc2eee4823d531f5627e639a7d8ee8486e8c2ca170a6820658616ad98b3f7de066a548b69bff7880f18f984eaa46ce568a6804ed064318ab524ef4c4f3ab58c41c572cede4e98119bf0c1239d78a87a59dc22908c3b4f816614c85cc7b28e09261396fd842e1c289d294ffcf7e008dcee1ef2e9ff3116bcb66b112e0d5bfc9f840c18bd6badcd9762fc24a9a35fd73106eb9479fdbe50ab1f2cb2f7a8178f7a2672115c27f4df6e43e2e1078ae4b0f3103ea462e75e39c411afb20f620d185e3ed94e4e6c9c342f3069909f4cba8f70535c377573e10eec269f48d04a0c4a9fdf2ec71471e5d56f1c047d5e47719d423788b43cf7544888a04bade55d1c79fa38d7fb5c9e039b33f4201abee79ca63d6f585816172440459057f020d7f0e8ff5f9d7fdc9ca91c7faab468554f00b6193f4f2529d5b8a30247db30ba48aace6738943f9fd0b5ba89341237bafbc559fb48fffc6ca97e10e8682e5a61d83e4f1953618f12e5ac017174c5327666d71ade56044067632195453273c50c93921955ccf3efd8969a13558cb301be67a3dd055199735befda2ac6f3cbf3e3df2f951deeb6156c8dc201fd9ac4edc3c08addbf9d49f8bccad4b02363f2275ea44635afac654502a98abd71a97de399882f23fd2f1b933347fd8f523e1d4cd1b7b75e7f6bc3dd45748e0c8207fbb4d4cbd49fdcc188841e8f93eeded8424ba483cd0eeff05374e32e765eac1695413af82edc428cf47583ea091181c8dfbf8cb8658ee24ffb88fbadcb3a4c886aa0acecc34e90c36ad80e875d0bc17cc9c1aa74dde5659b57d18be91f260386e076c47ddd284d96ac7da3ccfebf922cfda4e547c33d81695b35e631bee8a46401a4247c46f8976810b5e569df6722af659b7ea3985a845f493b1f711475e5c3575f12d827ce90fbf92db818e2280f0395d5ff98591f593b9f76e84ce9e3054da9d673bf5292da8fb77660dcc16ea8e67d03f3f2cfe58b1692acce4d80b09f31ab9a7da579b08a6b7127f8006014dfeecb8519566e7c3275c0464ad7dae036af4a91bd7554c8658269b3f2ea497e0c4e8ebc18509b2721c49042f6afe7e38aea67b1edb18ec79d60e1b605e78719ce2efb09622dfd761c8d449024ea82025f94fb79a2b91934a21a7791157f967ccb746b625084f2c6d6acf1711cff694215d80b71107aca8d4f8da805cd3a9688372c122d57eea32a573079442efc2dd13e5285ec191b866eb9df003f2cf02ffc24175c16a2a6dca23d36dd01d2c8c89d20746385dcd6b65adfc0969bcb2f37e180f27427883adbd283964e1bd8d21085009059d88e4d6e8694870201511d6cca930279ab398f6afc42e9d1b52b99d52ed6520e3f18fa32d1bf2f028d56714918a26802b772b145ed0fb96160a3ffd12f113bff0623144a8d592eed3f25185dd0f1aac19ff2cec220d1a7b0dbb3bbf047e2d5dbf26a45687c2f179881bd1a3311b7afedcb69b9897ac9bf2dba482e29ed4dd279db19df16204f138d9d446b16a620bb4fce628b7f709c8ee7fa27bf01dcf68833355f2977e65054938d90bae6deb7b957d052f7feda9e8d61cb26da4c05abacc4ffebc4e4cdcbe695668e1909c284057acd8b8db239c0e22c7fe9f4b2179125caf10b152523e05b3f1c4fe9aae46a43fcbea6cd283d6e2e467b0c5c9deaf6b558c51e1e7f41ee69139736b25546d88ca41b3f3406ba8a7424421bd301dceda6c8a39447f325eb1dec4bc3f8ce1a5328f39211003cf1c56626993ada1e40b4aa3f103b16d1c6ec8aff0a8866a637d0ced87997cbf6b3e57d7380c850900da88cca3d13e746e0499fc47471d21122f6c5128f6b62f16c393faeea3fb67108a6cdfa4254aad90545daf1a6eb3883bd8af6dabfdb2465583026cd3b7f04ef73939c7e6427f02418408207a68fd10b76f33f0c34b790af6257e35286e11cd5aae8efe51aa0e9614b461fb9be9c9ddb57b726e5caf68e5f29e78176e9fac3a5025d5e17054ea9de8c6724651179da621816bc3bc41e1a2698dbdc131db29a26e4ba308582cb45bda80f6284bfd04647a030218689680b6015e77ebeb6b9de80dad09f9d79270f031e958e2793acfdcba776308e9be6124ab6a3dc5f6ac6a5f164a57db739a4199e4afdc26cb59e69fad920d85177f275b334675514dbdd79926c7ab678988cded07fc4cd2a2c7fb7c623c093cdea9ceb497d0d4d4b11394da5dfc956976779fc5e1c89ef6066e3fb942161f825380c3e311733b6fbf2dd992775e034b05a3e64aee32ab3b19b67b6463fae120c445680bc410c002138e0f06125befac3a7de9a1a19611fd6376a3afd2d386a38423edcd621aeb93cd62694eb5e62ea68efd74c299eac98b90ec691a4b495a554678d55cc0ab89e14bd9202fe251c904cd9fb78352e7faf934a717b9fdc4481183eb29a1f360749fd3df46b7c089a9ccadd565dcb3198b2296717fa2405076d03465e0ad69758a758e41b9cefd89dc735d45e1ea2ca4e90a7d7e4792e8b5c95960e223943738db0319abdd8a6920ce3ce66882206d802c827fb11089d12870768ddad0e73acb58fa9fef419b6159214470e70918b2096d2857f4320e657d1626296427ab3dc5dc7f034a6278c88abd7400dcc8f7ad87cb047faf45d9ae5f85028e8cf83fa24e9c503183352abbcdf51753df08571ed0e0778896d2dfe02045325701de9d685c0bfd745ee871f10ddc19f3d26c64309d8bfc02dfa7e3c7a6f9683ff14c78ec46ea8aa17ab5e4153a2cfc9bbea0974f28a69e49dae4d16a9acb17ece77f4441f798cee3214aaf21908fed724535eb0a94e330d73a256cb1358b9e2bab48ca64090c8c845165e72c39f15f6015344bea9e0fcd37e8fcdc0141fc933c49c4ac2fd779726d155ea406ec3598e0887ac04fd32380d8e5212b6edf1e41037e5c0b2614f039f93fe5e3cc0689ad870dfa626b81b07de0b896931f78f720a9222c809205dae2f31b38f6c67581a19090b0eee5b8736cbace6e95a51b52fe0a466a0834a2d1f0c3c47e450bceaf66e672ee55da704e853e4f4a2740648afc82f209f5e259a8983695c69e70b497d52b42250df43c508d998867dd70442aa1c7fd2fb3fa1420729f09a4ea567d19e71d77f88253110a6053f40c5e48f5ef6cbd460f01037b196d3ddc30d914e2fcfae4140a9c371a2d89af6ec990b4af6bdd55e2dea13679b09aee8370d9a612f93e9cacd1957b7ea4ac869bf46978779a38d188292df48c3143e9cf68bfb79f655372df40f658ee36dd6eacbab18b265f2bfc70bea7d9aa53be998e8b398d6fd140e7a5cbca70c0b07b21051aa41e52a948c364f1c20b8ebe520fbd0a3b845d781bf322fa6639bb77af5b897731c2ad5a02a455475c0d51f2c5c2ace7b5ef0f589648b80f43eb295430f4b1d14819032ca2e34b2f12c78c8fa6807904a4ce381476b992edb52e9190c5ff8ea267aa10fc5a8805b66d76fcd597592b6180bd77d56255adbfbac3b603db618ebe59d5e4e1127763c7501a0b5eb4b881ab582210fc83b9bd9c475a8b50c61da435c044d88ee7f80da58cb4aa321de623ae74fe29efb9d7a2f098c64376a674cc7ec04d37953851558352b13e045bf6e5f7d329add25e60817e59ab035e375be62c90db1451fc659ae4e301b94222f895ec00c3500a14d1e35e7b426f18be6c8cec8cfb23e1c27068b7133187d27c89d9430db4db0948696c502f6ad29ccb6e21dbf8b2b678a3eda384e617b924a8f8f75e0c9711a5858e6b8455a94eee947cd276e62d8a336be7dca585140777826416077219835ac617574ed33fdb2d3727a6d8bc99ca1b82bc75114169e28b82cc518ed702336bd4a705080497d5b81f4ebcb055583a970696aadeaa3d19e5a6c5d66f0a40cdd411b9991e32b7cc1be74c88d86e07d96975eec83178cbada32e9eef92084d698c17e8a85ace581a7e715e32e7c8ca78a8cccc184c648120cbf202001ab7bad8d7c16053e7f66c6f6b94027c0157be0424a8f323d3100774f9846e33dff58526b1cc3678d35690ee0da2a8a5026219e9eea34287dd00f21d810c5edd2dd08110f3142ee4a48630da94479c618e1e9de99f8d6e4fb3955df9af0eea4900611262f2b89eadfa63052f68e0ba8cf3edcb1182b52fc60f7640c9706943be8e5f1d02cb890ae551db8b1ff9de1f13311f0e55d609f04774efc3e3b77293dd93abd3eaa8d257debf87b0805a798bcb7189c6ac350ce9e3b6040e4886e1eff447f4582a10e358d90fedd8f2322be801fa601b9f914d08afb8c70463c836af77a06c3a2f8a0f4cffa9f6157bcad44c313dc5ae1834a31884d7b562908333dbe311fd291d214d2eb6ca96c90d1e2ee2c1a2760ab2a84176237c380d3488eabf9535384afea9bffda14b36d19833762f446f4edbcfb50854155cbc05e570a685e554e82b330372bc42d5f00f2a01c55089b23555f74565663cf03cab83ef4f29dc7a88273031403eb04055147f9e76e7cacfbbf5875e233fa0d33b6baa64a746327a3babf4b65bf8ef4b7427e051421f8c41c07f2cb9f9d1b656ee889f60b23d6aaeaa59339623d80344aa445c5e1af8673e1a9249134401e42c065e8e8993b20c3df54748772f76a5513e90225eaa1477c56ffd5b9f91b399b44b07fa056e524a35412bbb8d9ed9af71af0f13bf626160fc45d820e25987401825dc90e1ed1fe147edf569500c863a1b4eb1f0f0ebf03685b99fb8b5689dfbd52356401b91e76b1eddb0479934f81844fe273c7ad4840b6c0e9277fa6889ea562afe024e9d37dbf777b5c9eaae223572899edb1f7b256868db472213ff964194f13c67c5c5b031ff8ee6c3cf745be2382b223d75da2426bb66908db652d809cea60a199f9eeadea40cf498f3bc1b65cfa458077fb1f30a2481a86e2f672ad9440a28aaa7815a68dc197c92fedc3680372b498f23fdf8b98a194c680a77bf78c533a9754e967ca50e7d0d891fa181c94efa7346104fbe7bca436a71641b9dc2640c68b7e01a3e2c5d2e59969e57628bb0499c9103879ece7d74ebdab8224008237f9ffc3923b45a6d9f9e426cabea6e427c73e3c250976207715cb39e603d7060de4485d52e95b61f21e8b391d8fcecce59e464771764de62f40f4cafc243e627c6d1efdc1fdd2235acc0d41809593f54797dcf52128edb3159b74fa8bce743b6c0466ae9db3b10a3b89bb3ef70218923c00993d1cb27713f2afec4e219371d3ee40b4dc1f274c15b1d7112e34db3c7cd193f65c6b2768ea93027bfac96349e5d2c3b014ac15b8413d0d38bdc80d6a1ab8ae00300360fdab69f8d7cf5e54ea526c47987a5817ee8d2cd2efa810ec62f652cb7fa94757a72a9ab54e6d91260dc9c023afdce2bdf2ea92153e7982a22cc8e84e0616bcf6a5d804cfc84a4c807b43c04c0b4b5717678b0907f5f3d5bbdf6e2b79b9ada335a941d62f87991768106f3c182888b639706c221bbe48cad232c21cd8cb87f491a8343b41c2e4b9c8eb7ebd81515f20dfbb0dc6e4704d599dae59f637256952f1d5eb3475ef2007d5e3a0bc451e5020bc79933f2c05b01d7538f9256572d341c49a165a29b27e795bc229a4763b715d33ecc2c15677545754eb339f8be79754de4a2e6a6e4ffd528e2d4b89125b42f9720960548b27901c0157d6132d549618cb3708b64fb289d512ddbd6480c958c1a3c7685658c42ba345151c6deb7f8397583259070be934ef7d62e3a2ff8f2605e5993908223bba5675a2782abc1308783d2c8161cf75bc7684d718f5a90b42ab53d50ef8669c185a2f126804fb2510bff6712369e90ee49f4e6953bfefddec843e611169a709c8808183f2e280c26f173e73879c105909b8cb830b5e84372260b379c171e1424cf37bf25aae3c0a5aa0ba82b4d10424809e4df0193b73b7bf4930194dbce4613dccb5f5f6505d2ea5bc6a4c99a069ccb950b31d85b6a7de70b8783598f2d17331fe167ac575d5c7e20b53c2290371864fd3d2c94c3640b1031f44c7cfdcf4c1398afff2f5d9510a5184dc0e25afce836c294112285851da5d0e2ea242b0029a35ea8fc8f88a0949d27deb0e7c587ac196cc900d402f6bd43e9e082e9af601abffd313e25db4fd961e35b17412722a6f3edbada50050ec31546e667b327d7f2388f450582c9593055859444fd07c2c13decd1f1b9c4952246984f733bbc3698f14e90e1df9f7323a1ea050a3872cef895bdf93faac9bc14dccd6757fb0ee2c078c3f19bf18185e9a95f620f7935654d344010cc576c9f1276f0641e9d66a1a5fac0b86a4d6a76e99c4675139c58bb0932f9d92fe254e8e8b478a204c61eba78337852f8d9bfa1b7c75e291cf512bf57898c209218f46838270caf4493a2cbb3f33e4ecaee93a7289fbbed8fc2e0b99100bec5ce3d52934b9418c4fc5f487d6c44f2319197921ae961d56ad0f26ced3368d08bb12d45ca7b0c337e7ff0a226d4a04609d583ae79bbca8b5558d8394ef5a9f6cd2da099b46af2e66c07d096aab6b00617f94c441b57f8c9b6a6bef99ad38502796fc06a38b4a6a7d330cec63e9df35724a0ac3dc987aba1054b4a7a97657378929e7ac6726ec67d67dee38b773fa88baae016d2b532d646bb576071cc99a6c4e881ceaf7462c5db530b60b6a49d967f5e0059abfac8af99643bd57209cc7c84894a1a4e00ac10f8f1c385077f6df3ac2a8057cd07767caf435299dc4e9db8497c2646ecfd221b1676ddcc82d6b7c1b57be9b15cf63a4c3227b946207f6bdb7c1a5af23416b8f82a536b19e641be683966579f8a6462e5459448bd5e1d3ee93cfc9445c6a26f5fbd331d56702260c3eb5a6572de9513b10eefd9b72348098e24d75deeb6e8a1b827d1c691300e2864f272f6d38a4f739d64da461b614c0ab91bbae00cb3a48385df3cdcd2fa60ff84334e8b9e1f5228f7a34b960dd612c3808272e7357937bf022cca285d6040f0c4649e0a3986cf5dbcbd9d330c86b7a554320f699afa3a1fbe5c6ba4086a4f0bb4dc4921ed2b0eae3e624acf3a3663efc222665359709e90a2bf0d23d6c850716db34a235c5928c18dc400c0a678ba0885c070e05595c394732ecd62b795a2b6565d4f281d6e722c528c0d7742d7d31b13982c86c98560fe3c40e2632b8bdbcf8d57866648f5cc59056f5a468d231bda39e1976236525d66ad1cede545c10a847ea7b6e1434982b2b3e9352a41ef02b64ff9930707a5ad42339c1ccf507e66686b9aac3e7728e167561f9db91893ea59aa5fbdffc2723492c839f996c9ecf1f8ad55509dc68168701ccbe3a173812b67dfe6a5b7016de638603af283726bac9fd80d22c8dd3d2ea93644631fe94c6e34172e9d3cdab4da213eafb8ff852f4d845f926c341dd8a640aa10556899678782dd209330177c34f8d768951add1d4a0cce02af570c4f05f88dedd7aef1666a7be0087a495b35bc913737933ff47937d73814ebff7c71ae81a0c02a6aab2c607bec5bbe04dfd5cc107cede07576403ba93171f4b571e29ecb42444c402ae8f4d82c6b1e9a6105e14e7b803ef96c2d3389cfa8d405322d494e5e0e827bed4ef4fbd6e27eb2e7b276772ba9bfda57d0201bd1601f04278c1b0ab4d57ce19d7f24f8340d1943908e836631b8486bbb6258699e77660f1c248afb12d549a7b41e80d5ece2aed20c40a8a0bff8689838e2a8b825dd34f3c427f1d271b0df4d6f3358dd714ecfea4000b8bdbd66eafbc2102f50b342ef7e584b4b0165f6f9167d04ea3ff2221e0bc18e3292aea69f22a211d3127cc0d15221343386847d9b7ad8f53ba1bff16e39c1642dfd5da7dd09aea822c42896e7c71e3df6f3c1c2827a5b26508a0d8b08be6ef3b1b6650065a5c91b1dff4f23be1f1b98efb2fe2acac87053f0e06ae0a4f058de7c4d2baaa8dba2afbe40f68b5bb234a81497fd2248c4238a7c57fc2456896987005ada2ad58712e6c89ecb441ee73e44ee27172e66a97a865bfa574004fd8b7219234184d6d4c5a63240f162cd5849fb25f2e59d0b4c231295bf9930784d2ba39162ee6a73ad512e134c29c96f640ac407fca2ed75259a89672b61e7447729a6fb4ba6617e1b4e799c2c6319b0fe9a783f62b0387880a9de19826711fecd03bb2db7dd413fff9c314ea035b7ce56a86b1b83e103903dce1ebd5f8a78920a238530b453226d88f97f423c1c87e6fc1ce9e8e4714a641c7d41303b978e23458120bdd1e12c1e10556b0f068bfd24318ac27aa7b1228a3f8fc8efbe04a5ee5ea882d951a40f298cff190de82777461ebb2452fa856641749bb110edc1d68bb2ee4cd631da7f8550259a3f9c13fa1698e8a3e24f00e7b8d120c910a209ea6e14b9d4dd0509eb6165fb0a6978f8191f2b22995d0911b6e26bb852d6099cd0ccc68cd66ba9d159e76edc132dd5fadda0b841a1457abac34f0bac614d700432e0c3c45660bf09d2f0ade2b992aab9df83b5ebacd91bb0303c5a606c992d66897c5ca2e39b84287a74d43988d29c93fe3e4a596a6739c4b766582841382f999d834a330e45f71088ec44d0bd1f3d9fb19676e39e9f815c260facf143ae6823d3c636ec9450656a07b16510af42430b778e7e5210eb94a85556e93e08ea94173bb17b8f911dc86925c286e62097236845a4828bd67d34ff7aa6965a70d029c1c6ee7bec20e8372925714d413d7549395cdc3f0cbf43a9cbeb3b3bed64615513273cbc8cf2b7cc292877543e88da4a5e13376ce89a457aef0033b7cf08da0d00e555cb0817fb9a12f59cfdfd969acd586473ccbee1e24ecde788e2073cba01c327a49f79c62ce211b01988ef8872e4dc427e90070b47f14be703c550a0c9815ffd9bed4dfbff07acbb9c5661c219682713e5b09f269508dd8cbdf11102f380a8905213bb3806624a46d3c32152c460a6d27ba273b61c2b0d861278ca376a45ccae0e18fdde1a9604d1af7076af975d6b48731f240536cf4f67d504d9021e36082bf52e5131a61878ce20fb26937f5031f76f9c922abc5caa8f60491dc2f541798f29147c881a76d0674dec9dc39b647679721ebedd6ceb11ccad697179e0d1a86825b27e6e83628cb7fdb7b537a380273d4421dff8483218e50d0cc92394cf38936afb47e129540369610e909acbf4dba6c5b5ac41f9e25288fa2c445c34b9ff7b0e7ca83e8f71ad10fe6e82f77b20027ea56c6fbeb966b4415090c23442e0a8d5953994f92c753382647b8b029d1452c2f2f657b63b9a9911d2a147a79f476bd2f7473c52c2a2085cc09918a70fa1d756d184e128f2cafc1508677374e60b830e4f0156de246048fe6111c5be88b9e336d2e92fe8baf54e96583529440024ad41cee590aa57fa19f97d746dae9c3148087c66c13c7d0346c178199e4c3093e9e0adb14674ceae3c039d40185806b140c6dc9eff26b18bdfb05a5ca156d61f713ddf93859ca76bb43cb227c00042c2901018efbc3f992ffa29dba524a14be25ff46f5771d9ea863ff586553b6fe3e4973bcec087b865771a92bfd28c1c65c2f83f7d00b8144541d07c865823ed2729998832560cc9fddcea57861e5880a54fae46b42832657cbccdc257b89e1cfbdfe6332d708543884dbba7d7ac83f5318420212dc7039dcd453994b0e068e95e2da267d783a105abafac6966dc4721ee7be4d2366962d1b70a15dcd05c4adde5f61353db3dc53c4d94046c799d4d80f0a7ab3caa8d6f562f8504b278e79c5a67de78fb53f6257940c975f4b33a62154ac8c5d122f16ef7fd7bada0f9b8d9a8eb2e283258ed105b5978d14e64426b133e7e0e504de4f03724db44c25f650ebd2e9fac4ccd20a2996dd945059a8f47c331814db899519b45ae26e738160140af60f5d4a520d14f4920b9f929c065ac16ea676e017e0b63db269a3064c78e73ebf23b4c8e9912b510161f406b0ed272b7de98df58eb1c66d8698ece77d18d675967539800c6784928ae02f831ebbce8715b8ec73afa82d1ecc729795e8f4cd7e7e9dd43bcbdfd8a0b22d2c60cbe7367ca120d974d6a390fa4464f0305ee03581bf55b8d7f2ae15ef2f35de0529117480640c295924b3edb9176390bfd423889e9811dcfbd78778a017f5d5c81502dc7ba2f4be25df6adec0a9e0af846af311f56b05552fcf3ff643e939f8b72ff724e978485dae1d06ff470c6571cd9180cc6c6af42d53c2df12b5a244d02f6a2753f5139edba62a805f229ed66d7122e933736ef349d48e4be69e62d627e083815ca696441ef867ad5ddce06f4ea4f90c50150da634676140047e4d8d9eca28a7b501b3ebaf026cb7cf766b02da9021133998d95e75cb0c07c789dfcb5184c381ed2cc6456d71ab49ee1697e00ca7f9a1751dd0fe1df9e22765d0e5da0f0bbe80f97c2b5ee4845f4dd8c82bee32acd2be2cc9725bf65590c6d03b10e0dfa0d100ae4487fa6cc6e2da233bcc05a31c2c847ca7861707d56a10eb01a466b71a55b77291309af9dd91bf2b599348ab8851e7b610dc9112319094939b63079399a27cd54661bb97d4e37adf2b574a1ec44883fcf8f7b22ec865776b56b3f29ffb773729ddd16ac2be4e7b893bdf9ca18548dc8aa3c79c75041362d96b59dffb812e2b841ca1a42b49ae4cb4d6847a8287f09b322f9216505ea15f0c7767d5d7a462600076d356236b1a67c45eba5022378988df4e12f8104af154d3b041f81d2027e5e93f24367537c7550356368630dd5751c0a4de898f1316faff79b6b4f443c8658392775bbe72820fdf2db62ba9c00701b598856da3414081da186abb1108f80ee50fea8102504094452b54f99d01261a4f4bd23321cc685e71a33d01c8c7c6ad16a47da929700fc142c52b15141120d400f84cef4fb79e3f3b8c4bc31e43ab4903d9a9a07844d527c4cc65ad303528e6b932d85d8d3f4ef8890be7a6da43e4da7e4cf33915943460bf320d358be6a49348803e2799634525f6d0b04f88cd87cdbf23d125d8fbcec58ac654b76a85966f48fb8ab4b48a1b5967473cdf90384423143f26d8863ae71a6317d0d7982a7f0d5e7ef3a08703fb534cfabd590fe56cf89509071bf190e70470bb7df3048ba1b4cd883a62a83297de49d98733e80e62f76d88cedb3cccf3c8366da12bedf98a37dbc7f766300152555273782cbf26e045bdd8ec3b0fa3a7dd41b84b25bbf341eececbcc0b3e337250eab2eb69dc183d56765f8f6c44988319a94d364390230716f24a54136296e68db587567bfe177def99ea2a9a600cad7e0560556cfd34278030f56d977792f12245e95d441e5413a379f57b98b741227add809dccdcfc85efb3f6b40b679f244cde4da03c40f4a3dc45f0e534bf0e7dbffba94f36ff71f280e56af3568f5394bfbf33fcc6353d27909916377d3e44d0ab01ec3f39a3481aae83798b7402c58ca70b79f1dc6e592c2bffc21172f6047b7683812f9d8aa728fb35dfff9054cbbc7c001a20958471ebbced8167b4949c638a7837554f7eb90dac51cbd5755e8df38b84510389cfc509fc495f55abc73d618f0b76098b23b2efdbc273fc11df65824cf7a37dac1484c3b3556ab4560f04aba8308a78c68cb77fa8a8e8f265a620eff5d7ba1e673f5ec2aace44678366f2471241d33d69d344e58aeab922230c7cb2560a5e205ccdb08a2d82e47924198ff1e1ccdd17a7035dfd09734922fc381d0462b3dfe24dbfb5f06f1190a1a5a132ffa5f971b600b7f6fcbdf82f36d4de413ba65906dfc1e80249571cecf041647c62017eeddea46f55100e88f90f342afc04a64ffb95cffd54bee7cd3fc4c950d5a415291e79bdeae81092961e080c819474fc90d6f0cbddeabfcc8b5a29da2ff242248b7455171db845a5512d05ff4c78da09cc0083656d5e7768ea684e33dbf1b8763723fad74dc6792239fb3a36bb0a48ef1a0367e84372db8dd2c95858f4d6275d3fbee265f4a3bca0c92a7675448c1f056d9c97451b7f996b36b6bd66626fba98bd23f83e2eaab9e49e2b59dbefca479f2e5ecb96dcf0d1437168761aa9b816451b010939846693b88e0bb79ad674d9d1165076bc16e66a6e06c5ee6a095b8e5b0ae416e60a2e6d0c78b70181c69ee09372d90ceb782374e7d044e0d3f46fff30ced8102d7671bd4c2648ea478160489dd3ba5622fb6868b68a111e8299a2b3cfd207acda453260c63bc84ca260136956b3ff1352a57c4c6653dcde5cd35e14141ef66e3040c383f137fa31d6d62c3e373b5bcfb81e45da6a9bfa15dac65f613aacf9ea17127839afdd37fbd4cf20f1e1ab5cef4943557b8ed31578dc1bd3223a6d2afdf3e8b93151a7719b50b72f5a5550c0f9c26864f0ec7efcc65d28ded0efac82ed4830215b2f5a6507412c96406674568dd931fd0b5214823ab0006dcbf7ceb42f23daff22b2145aac8bbf5f1fdff1d0ed176d7d6590b1bbd6bde2e9330f773bffa0c5c53c351f436b7d9cdf5dc3ed4d3d5e06e152f740a3993efcb8c6bc6ef93a9f080ad26693b1bf3e028884b3c66a40d47f2a36cc7bfcd17bd29e79f64e9f1459d3cd6214aeb8cd9d4b797bd8818de2c3df9cbb879315691e57132c81dd080d56dba4c71e543d9908ab9ad2a6e164ff4ebaf2eabe3ce41daf95154fc9d4698feae2e07b43a58612e2ac23e359deb95402744130e4023abbfaa7619bb462d3f29eb3dc6b37086b78f535c86ecf58a818cd633c20cd7641c1506de1efba5a0e2d9db811e8b2496f6106de0cffb6818b92efcf1463684c6c2292c7864187840238b1df65af417a26f46b6249d0723d3cad0020fea79d2351538d2ed78d41228889777964d01c1097d59136744aebda5ed968789b6a5a38fd222d5375573a51e285ee2da3c1fc3d91e90f2438f4a4d21dd97457df46d78e2eecb6e04a38a4e0de592ab386fc79d0ae232a22da7e551f43975f8f7bb2fd0602993d023b4fee94bf1457cbb3abaf35614ccabe9ce7d7bbca07a90794ad93877bddcebf73d08382ef1ff9c934a6f9e540debbf0431a8630e0d97b0b2c039643ca62dfd92e83355b886c5771ab41f26e3583d4a68672842fe49d144bb266775c278ca03c564b69a93ea54d742175ea8bb0ef202f23d1ca41c421c6f7025584b3d2bbdce91c73267c83cda260031529c4d18ff9e7a89d5ab2f54839c9daf36361390b8a73edb0e948b76f881874c851e5bc18b00c526ecebde10d2ca50f5794aa00751f1b2252123ffb462bbd23d843c5ecefe76adcb4ce69927efe13a72bbca70a94b811528620dd4e96833e95825d54149745d709faf3666c72caefb875826416e9511057bd26f595d097a6e72a92291a0adfce8349b1a6524c7332917e0d5602709f4664c364e02462a3dffff7c9095d0a0f77466d24224ceaab14bea80f9cc3febe454232223ab89f68f395e87456086afb613993888ef2b4c364a7bd9e05321bb7f05616df8944ac3ab9f255f541d544140f1d0a967c22b950f6b3fd2ec2943c1e1e8c712f6a9beb9582f5cabc7d7f6fe0f70a0dca0645883ac12234605e087b2b37dd0aa7b4a7c65dfb48552233a8b48f472d68e7d35984b39d7e4e1ed9ec6a1b9a041abe3a5e913476a1ad2740a0f0e008a1240291438cd07bf58131dd8f760c6b946af473a2f9b876e58951fa3f8ab0df7e1905b506bc75434127717b7088c65257b1c342f04158be55a8d420fe49520a51fd5b9f23da6e0705151191eab60ae720d0a2ec7ef85056eb9505ab1ac93ef6d919420a9e7a338fb846fc995f09388537299815d63fa5e20f92021bd80a8ab3c79b7ca48052fd43b3ca00d615a57d1b493b0a118de0d65c9956c4296bd5fec85a562e9f1a084552eee1389f81fe0a9eb833a981068a192a45ca6b62742b73043958a417e71dddc5ae346eeb4991dcbb12c079884e6cb3dc1ab8479e7a486cb59ab3f754bb53efdea66d205725ca4a5e13e1da03eb505f85b3ec12bed6ea7fde8ce62b9a3381c7771892fff253ab02c6c28c721a0c1421bfaff5f5850e65d8cc5feed8a38f14f58124dd491aee2bea023cf260961492bfb9573b245b1f4f9e83a47db319b159d29118eaaca1b1cfd4962452cfd60332fc454b386986324baf42ff332fcf4feff2b86ec35aa2eb907897edf5184dfb36dd22ad1c4cace1e5b3ef6a33f44361e0aa48fb84a3e8423f49fb13089e5c47f7b0061d44828bc50f58170578ad6a6cde4d04fe0b1ea249735175e83418c86161958be4889a007c049634c07f1fbf2e0935cabd4d113f2a75ed8552f2c24f89dfcd636b48e369d55bf3ed6b4dadffb4a6e1c8c095597b4ce498fbe27735a1579408dc30fbfefbf171760885784176f9475be7341945523181c206a7bfbef30e34ec35d02f4f30865b4d3edf9013cd7479657b33e5ab9ffae7472fbe0ad65fb19990a19dc076b736dad6c1b13689f236d56eeba54f8d633bdd607a6f677979782edaaaef13e31f3cac3f04287461346fc958709a3c27aba97921040b4e142a39c2a2388efd85ffdb9b1e0543c0cb25bd035526b4cc135ccf4b504050c5275ddedd1a22429f5492911836aac11ca07766f4c7603cc18103e2f42d265f7ce028382319b42526dcf3d4be5074b74bd7eab7a81a6003fc58f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
