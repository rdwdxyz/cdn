<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36f2b9390c40660735332da289658f6a5b7e2633f892332da01f5e7587093e6da87774d8d58f7a3543b2c82ab82ff47d75a26ed7ba29d4f569e1816df888c576a2f85706f5eed2fd3087143acd0dea7ceeb7f17b64bf85dd06bd6d1aff19401709f8f5a63c9e9c2e1b4fac36201b1059f2759a531b84a23aa00015fd98fe9b16ae9a1b2386bdcd52c8192c009b218c4efcb9067a14aa6ed708c952c5ccb00cb788e107291d0ed7aeed99e35f6637e837e714a00810b793e9101071322b76c791bc15657788a8b5058842b00b36548a6dab22e9cdf2bad211ea2f0383deab94544efb85329d1e1a2af8a984612a1ebc47f121d89ea11e302b7ecd066f684e4ec5f8520879121cf917a109a5cee81a7ce1719f429aca30ea101c087f02d9ffcb4753faed5d5779cad4d3a2a4930c9976ee94e5599f4fddda535abe7b5bfad65c775f3588fec75efde054ba988c38dcd75f3d7a297e722f02342e754427c5ab13fe1d857cc85e90335ca5cdbd3add92ce07a8e03ad5449a885dd152fa701460b51c5b2777fed5f51eb06595156a591fdfe84d388e7aa104a31da49ae851bcc801c5fa87d311fbe2677e000c86b33623981790b44cee784d129c96134e5c8586ac48685cdc5ddbb104aa077f1dcb72ab045eb7daaa63e5c8ad0b9dbb651650d59d2bd7d897d885c846a5aac09009790bf80d144b4d0c53b182e5bbe9cb362d174d3e764d65113c8e639aca7adee74d34b6e6817075004bb49ee2a89fd69e0edd5a142ecb743ee66d381ce03e139f5a8c813869176523c629bc7a29910d1a2a88d00efa7105abfa558cdc4486147306daffa00c7ee250a97dcbc9efb80cc8b570c1c7d4871ae8ea3051b7e7465146a8578cf2ac13669e42f402a1980b875e173964205320e97359d47b2b87d3df33818a12812a21deebb3a182a25b01ca4afc50b088abb8b5d2be998521a708e8d1dff92b6302c25d29a89d52bfc77e7d0b12fdefaa5ec94c9c69e83e7959e0ed648d64f5d4a81d6922ce9a8d6e19923ac4518122f5f41918ff8d27242f0f8d14468a145c6d6f3c55b468f2af821db9aab7125027f86a5dce68c5c4fdbadf6b405dd2f5ef9ed4f6332ffc6da68ae2351ded23182c129cd8fbddb1c5b10bdcb4645cd10b057d51052f122b1976cb224cbeb39fde0cded3f9d9defbb1803874784003bfe854270402c6a52387f4494d61dff18ad949dd3a919638ecefb7c053881ad2c2636784043ea750025215924941933fbb1977fa17a66fb392a020fb0d9854ace868d61127947dc2af45a808be94ac744d74f73440512241e6bb5be5c1ed1838bf6bb7e678f0245e04d93a7a20612e93892ed723c3eb7bc5ab9f25ea438f31b0367dea598561f6207217041c58cbd73f8a32870cd890d378c2c8ca1061c773191c4ae8f94d0773663569aaf436745bc6dd1a093ded604ba8311ae083631aad21307378fc9ef5947057b370522ec89619ba7ef2363f07f1962f924b434e630f35926f6bdd3c6ba90facf3a95b6bc11bc97255bb26af4a6f65caf7c1b6ad57bed8747ef370192e09042f734b88b6e7d38488559790488244047f0f01905834e7e2a2a7efa99d01aa8d6817104c9939c572f0952720b932b012922a7142dbed48d16563fae70a5bec24682b19948f1149ada1e7388f6d13f2d766f687d0a506f54ff3df6ccd806b91a95a38066e07d6853300e0f85c5059c4d1c6e9a8f63503961ecb057a0f24366639fc74ab1bd7f4db8eaabd7659b79b1a8226e7a0dc000e9cd4f15f375cafa18e633b91105baeefbdfc881decbbcdd7b4f76cdb951fd00d5c64f4422e6f09cbf51d060e1dd43cc91f919910dc2767b1caf89f02b210cc004612ed1e42d7451d908eabefa678e741c61f40d074819769c124dee29d9cf5768ee73d5eefdfabeeb4d9d47b978b91bbb35bd957a153daea61f9816fb43415d84ed3bff7a428946410adbc8bcb4eb4028be3df44fe2feddad40705ca05fffe5bc1a23d0670da0b0b217647a5e4dfcc46f075f970b7a0140f650f7bfc15ee6c67e7c5c1cea1aba0300bf8b8ce371d145e1088b11a7ffa5ea73296cdf17579d8765678dfcec4e3e7d9c090e4a61a65a8ccc4db5d8844260a3564c1b5dfc22ab7d99b0d3236790cddb1cad8d3784fa8078c81f02e9b72ae87ec3a2366348bec1b0a8843c53da6b973d05e2a7943b7abaed81f11e9528047b7e4b7e8dbfc6a1b808f0f7c0bffe84f89d87090a35ecee7f5c1321597029d39125de346a3441d808d9d315d7627a03b0f325bb08e27e7b3934c7ff4629e2a2c1858643bb5139545b38236ad885028ff14d1cdffd6fcea80bc9006c91cc227e74e751656ebae7646ae93123c6549f210cc9d6ee774bb9b1ddbe396103301bb679b0db550162ea614d3fabcf9f6237d51ea7a1eb769870c2660dbdb7ba39fdf2e0111ee20cc3b5cdf3a9b7d7a74072abbbebec33413158d1e93d36cd6aa1153a55b67a21b4c5907b8993432f75e6710c17ca9c11f44162aa4090ab375ef9f5fe044d7ede9c84d1513a24dffe51e9a2f39ec6ac83f17b90e7532f75a91d972cda4bc375f60047a3b6009eaf62618e64f8818ecf0c8ef5c5ee6587402e3858afe4a9abf72765c9d7965dd1248fcee4ac63dacfe78f066d22e9f5f97c51da75b00a6ac4cdf3c4b4ffa935ef4a10a5ca73634e605e47f04c86babd4c5b082310cd93002e79dd10df2d1dafffd7b4a610f5313da5c68e29b408dc405ad1aa278a6adbea9c1561334023a061341c34e9a5069d654ec29ca6ea9c8eb8d43006c1d89bfc6c11e255db44daa737b0b5144597b1ea5ba684fe5224d5cec3fbf5d6c277ffee8d41bced4c7b7be2e1fb0e72e33d09c49c41fb9a6164422feab83a33e82f755aa82074353b1c41e4f4064c5a36ef5985309ab600902e1f4b31c4174850bda4267e2e82ff0b724c6ed9d6dadc922db50d5d62c9af201482cdda81ec96e745a18092a56b37f0cbc3491642467806269edcc48c65b3ee7ba46edf213041b75d6cdeca03b04a3183cbd537558c8e929ce9f6fb1bd574a2b33e338231f03dc1b0c9b8bb73818418234b701255defaa09edb7052baf1f28aaee6470b1c2f571a14996add3e58f337c62306bdf1b439c5de6058bca366992ea4c4fece52373a27d388d0786be7e420fb47b7ff8d66c68481654239adc543bcd3c8d03a59703bcbaeda3f06b1021f44a4301a23b1835ff7c2ec5fef08551f1cc7c721c32c532ca772847d3e9739d5fbde6968d116ea8cb0bbf16c7c899ebb9e81e4cff1315b3f57dc3597fa2c5f03015c1dc67085fd8d616344ca9268bbcbae5f8b1bd93a03c1395f4707718e4b4c7b0a476449469e4906013dc696585ceadc4ab8489c0853245d45df1ae05479ccd7eb0b889394ab2f38cd3efc2b01bb0136a917634e51f329c38a1ad05e04e3716e921a117ce0bdeec7f2b66068061a0f073cf129da6c06b1e3fdfc737462220ca2c7d254b764aee10b2e5468532a6c8e95355c3c94740c8beaa48405c673b26971eb0fb0dc414937f995fd759b2f445cf1532aecb5181091dd4da5263cc6e021726a4651aacb6400fb351719fe6907a923b7b51e6b3132982fe787375efbaa852413877b05b7220e7b273b6877f572752b1cf977c25e8e75f265466e944ff4972d14548738284e6db39f2ee50ee8724fa6a1e1541a16ba3ec285c84599a28904b73abe1e465ff70e956332741a069f8c113d882d4a49555e995c836d6031044ea0092e3b14a127ba0daae75b38fed8e6124fe5d44d805da1283148338785f7fdc13242e1d044ffd9dc1715dfe7901462769a7033a1466506019460d73e0915f17999ebe9b1299f5996144af7fc28ab17a71380197907cc397dc4c476e84e7602c6fd602db131b554bbc7919046f336bd37969b543aa74c70916be6aa47a51cd482e3c2f58e2590d9d0f2c504635b67b36d376df8f3be43524ef3382584f2b4b3eb0db74221bba49a2254fc7712b13aa8f886bb1b7985368a64cdb5896b141f3c571160cd57b8957261663199531ce90b335e2306e12332bf4d4dc80be1c7981680ddd8853c03ee373c88a3e0a411490e20b1deedc3a8685f2c5acf0dd95895f0b4312c94fa6989010f3315a06374763331db64381c30c5e194afb2b43476b5c59c86a9fa983bdefbb1d30659a5bfc03b4ee82245e905f22c738e9fa0ec78ab0dbe34ff0b52ec537f5c882519c13a9a2b6b21e4da4ef5ff161fa55c62831178717bc366ead93398437bfd374b31c2ab87d2c7d0bc7cd62a31e468d716f7000c9b580f14005646a7fd234d4b7197808c9e868d4328604c463d297b44591fbcde19a7b3eb585e13c16f41a057947ee24c911a10f6e089022d6a9529cbafb7d1a4d2f41c1c49328313d40e6fb8a1834f646cc2ac622449eb0cb243f58bc68cd2d40fd74d6cb73d1981b749d2043e57cff37bde25e18e112021a98ec25d55b3439983bdf7e7e88faf56c038d52b531211058bd312c554c7d79f38ee5d94ed562b0c264f2678f8e93b04c60bc3c9645985831bc4d6c45435d46c725108e7b38d41984fe11c9e7a2e2ad9b224041179ad1a5270a81453bb8004ca626adc2b6dc955e501711b950fec0e4fb731068948e72dffefd9515da24619e7a177f5c6f71814ca162b1c79899e8161761d0cd4b313d8e52738f2fca4d3e22afaa4faa093949fa9ddd529d78b8de35316065507b7617bdb7c1e29eef81983f1aa1ab221cbd3171c073b21f5deea390e2f7aaf5d2c740a47ae50faa91968fef50aa6aca4179b0a73af66543b1a082b9fd4561537804ba3e380e60a004d6f00320fe61cb3e54d3da42fcf805516eec417c49e6c6bc09f278e90ae20d220ff687f96662fb2c774f080bdafe9e535751ad94544a23df97d1d3514cc55f3e0a87e36a59f14e32da0b75ec11a88456f84239a2012be3e55be2b1595a608e69d668452bbbd796836d3558ee81d1dd376df8dedc427a13f6c99429fc96f3a2c30e75de4f009e84fc36acb50d6e943f5b98f60b66c4170282c47a726ca0fdd4f6eb9e760f5645bc410753b976103e8be92849cc17271b49f6b3c1755fd27955eacbdcd3891b029a9bb26c892ebb344c8e6a99b8c07c63a273644b76a3d753c31e0f56ff221b7e2966b5c9ddd23bbd9ca95ecb5a9a5bb2ae1ca64c13a8ccebd437b3735ecc05c48bb40d515d4b9fba6be380701a8d7244ccd4f394acc03ceadb96f5503cc18b2a4597c7c59db39054649ca98c16b3d574b0e4f995c2211d95d501949f5dd2e18e119ec486f9fbb1e1d93a8553370d1fcd173a16ebd9b6b8833bb863d5bcde7ef6d7b367d610ea7427d0b9d0ce400cb378a572e80da15b07771670d0aa814d5cc9709a130c59d146401b8058572ea3714e2600e98454f530afbda822b6a3b5011ba8df84e5581c1626348bee0f8cc537678b476aede5cc8892a2afcccdaa7f9ef200d85326275dac6f03ec1710336c40f62e9b8d30c41e85eab952fd8d4ba6c5ced0eb14c9c52b10faca80d77f76482d60c4c3965b008fb6e202125013129595f90d025390c3bcb068c8c7c9b93e56ae4bca059668b61cd4452e31cb2cf64d7402769ab9b77c8cb4426b9fbca6a60ea1a5edf145eff6fa51af3ecdb42c93934b176b3fdc1e72e75e2850c622c754d7bf7a8c0be334807882cff4893444589f89b618ffed4218e122188fcbcefc66506aed559498062f29ed4d64eafc476743dab1aadc5114a7d25b726d5b7b0fca82664763ef712ec941663edb0955a71e4c748e2fa89ce47868c2824b71f56fc5c11c66748d7556c9d5cf7266aa1322f89a89cb4fbbdbee8b5be37f1aa2b79c46c0b9cf1df489bec053f006c3bc3274fa61080d7573d7d22510b925788d78182eb21b993f616cee4e6b9256b136e67362019610273668510481ab801748557b26ebc0493fcd0c81610411b7f8ba412c42d9fb48282890404e088d4c06be7e16a060f6a97fb0740f5e057d0c01746e4531a4cc540e1e9b2c7a7cb8e01658bd7d777269614254a421beb0211d793faa67565b1a8a5236cdda61527ec46047b340807cf4879547758e4b126a10c0c497503acaac16019661331d2619084795a09c0aff758222f9283c49c1fcaade78d44c442d100205ba4cad3a13eaa5bf59cb2f91f2f7801cada8b1fdc452cff06cf17f6da7ca0c54d38b073ad2986fe9b153786739f2295484e9c075096c9706a63c58afbf7a19d5c046573a1c1918a5c9370a9842703553682372fe0420c6d21a6fade5eeb576cec9917e0bbd6fa5d19e2d9e0af2872865d5c226cf1b084f114e6239f7b7fd8d65f6c38f0677f48367b7463a8873fc1c6c30bde2bb88b1d3c704123238cc352922467353f834d9a805c0d72f844ac66df2e2595a028d239f35484f074a80cda3b2160d3cb17d6c9487fd46437252a968964b8720689cf6ae3786521325d27eba05e47ebe7159e68236111af16a56b2b6947709ed648c9569928211e4b4477e1529e5a7eabfad2148822957c64f7a4765266aa087e6812eb9be19baa55a85d0898625b9f8619ab58b860bf9c426c1efa450167483ba90dbbe80b840379e732eacc2f371889deadfbe291b3479b626a944c60347fdb1918ea134a5a1bbb0428d67c90197dc719022e6fe08a3db0fd7629f707d2186cb148fe3d784ae745b0a77f9df1b44af4209b4ca71584de45626824b7a485a5ff68271e47c585e39c8627f6bb47bdd807068da2f1b243fa107ae8edd6737ea95db9e381abbe20045c627063f48deea0169970422e159dea60bcd26b5b9294aff1d253dfef37445534ec7359461acd4ab789e1c246c9654b051b02ce3ad55e619ffbc22a7c5a999b107943af1377eb83781394764f24fb44cbb26b58ea9fbfda86f3a52dbb9c2f3040c002a6b143e5fd8981770d1609a41fd413e72a93cf1c984849da510cac6aad51aa50e351432f7aabba2322b4882ef8ee2e8e3ea5b1c94aa09df5b8afe8e86e1ce2439b014dbd5a80a38e4e8d13e34e1913c96a7f239794b358b87e31bbec5236d48cf118e833e96063272fea5f986e1c1d006a707718ad2559d7c2b3183c1f8176285b82739968434f6a17d83034d66e67c854f34248d21e070f2c91e0940f902d053261443ed8177cc50498e9a0928971d3accd9dbe6465b0f545e3b9aa283cd46c955d031e0cce449d25fe09967df66b62244c9d9ed8377f7b2134d4e4aaf27458dc0808d53f3de974f9ab712180496f238b2d105e96ff1703bf6a7267b756585db2d6b22bedc041ed03c5902aa03a41f19c6f120e640247cc612589152a37370f4f8d14e959ded64b641a17166a0c6ac355d0cdd19c744fec1803f4713bfaaca1282eb5bddcbf52bc49f2f94b174c2fa67011a9dee5e4a0bafa55896a1f9ead3b9da84498893895e06dd32818fc83b6c5c634d5657cbb333ae08fc7bf1f4a59e3e9366412443b8f7018f9e3619a636ea81842da6a2b61ec60167e4545b7049b2a4af5f1926ff72a4cc4656dd784e2f3401629c3f06f6d78e4bba54d06a8a4d4f805519bafc407b84c127b02c8f6bdd6a30069be8389d9a64723b469821e8658bb105c5e6730333fa15b593292e4a8aec7ddd8f442df5fbd23adf6f6afdface38f862cd7b12afef46726ef257f0d166c4d8c585a948300b1689fb050f0f112ffe132259fd60aa88d0f9af8d8148e10da679cf67b17e8359cc53d90cd7fb5dba82d4015b8eb8ab99350071942919b97368be39c008e4917e607bca5ca6f666dfaffbb3244c5edcae30a6e84cadb06fb64946445d00cca0e46b96719b9a3f83c7d0a07776270a262eb587c54781156a5fedd9e93e0b4010b6db49586b6eea1d1e8e6ef62fc7f591116e49fdd3661f10635d0fc687855d9de0d49b3715c0f59b16596c188cad4873a406b44f37f7e2427a882bfe728d6a5dbe57432e8f641a42a5913e8a0afebe8c163a69dd820399705d03aec304c72ccf9adb4be3a38b38dceff0e9f731f1e55075d4fecc9a0466f236898b0837ca612de57579651e697e508be4d09683ecee95981e3e5e598c71623118464a40fb3f5c28265e987e61ce1c1d9286087753253a695e033aea26c2cd82daf81d1744fa57cf68f4101e7a02dbb5b993921239e9e2772d28dc18f2772ce94204c37ff2bab3ecf0a41a4d25e285619c3e31febf94ff6c0f82fb21f85c80243b50429cdcc1358a0cccb7417db1ef690fed740b4bb11b42f4596f44c71817a36bad650b0a77ea9b700ef4ca4e6e9d9c9fd0ae27657979703f87657c04390c96879bef11a9f17974f2132db2ec520dacb559789f59e631b41af83ed1a35b754c37a93b8848cca723bc70f9b883a4c05af8b859562bd10906aa69761ebdee485b06396ec52d41af8111b6d9b16d575a899333cfc4717d1ed643249a6e51777bca4ca7c6928e9c3267f51444e126cf60ed327c9e0288d6dfe09be50f985103a6df2186cf36abcfedfd791c48e655754f8df19eaef2037cd208d1fbab5269853be89d9a70e095d78a217b485b0be3de84b0003acaa1a508f4c1635f27620c232bf58dd855ed7bfe6fb87df690cccffa93384c8465bc9713066a0d5966a202f80bb3e39a16dee38636c66a993b0d437777166486afb4d191d534c04aa103dd906155171e82d941209bffb19854fdda8fcd387a8fb7462461dec3ee9595a21961fa69a3782fdac07b0bfa4c9744d0bd602347b3d52c8ae3897ca53c494b8760d66c877d394d35c5388dcbc3686c57c347cdc593097f89f01e18af3f035c39289846bc308ba5107edbacd30b03c97f2b4b16e9577a39e70a162d03158153c3ac6351aa1e40e7dff75c8c85e757b9d6c1fceaa754dfe83b1bd16323eeb5eff71cfeba75ee558b84c2db3c1045f467ea633d9996a2463c62361a3ce908d0bc8018b09b02ca73b2b5072ec0ee76a20a7e24143a635b1bdc575dddc3b8b5e3ae13a05838625d78198d63f9d0a3b04d53629ada1d28d6211d604dd458cb6cfc7a08d5b4f2b1dcac4da2129bdc506372eed6e265a525d627195cb0cd1275954afc7a6e34c0606bab0f71d75dbd9a284140c9689e8c5e71985b041f3bc67892581a63f7d58c54ce20bd0574f73b43d6bc887e48692cd4506f5c804ecec4fa520fc1e86d63209ddb62b6b65641dfd0d9f30844cfdcd63b27d4e97865ad3672035353425c5542259b8594a137dd1869cd205fa3d0383eed57b6387a55b84ac0ccc5acd334fbcb64e7f438088ac0dcb0c7581a5696c7818d86e04839bcfe47f5dee315b5fec92a9ed06fb67f04200f55adb59649087190ddf6190eba4dbe43e80416fa308820e9d1f8ea1eff5696202dd75fd3974867e08177e5af84aad9f20692dd0fd8aab6a8025dd282dc10ed5d2f226998612a6057d8b4f9867bbc5a7ffba49b8a8851a3ef23ba1e528c335b27d609185a98cac0d3c54acfb4c5dc4f2b190f1dc1a740cc12092f38e8624a83cea31e93d6a2863538cebda251c0ad08f9bcfbb7456b93e491f0d44b7bc931a96a476053c787c03472f184bbc7f4f42ae3c4de514e0ffa98147c9d68951ab5e51889cd3c8988fc91d542473a6282137317bffeb89c12d9fc6cd0375c01a602c7c4f0f46728c4a14166b1c4b8ce1b74e7b7ff804d2672149d4478f28eb15121ab1699424ff75b534513d1586d96f93a8920fb6497f424a65161acc8f1a12a803db18e08dd79fd156357bf4c036443783efffad1c16a9d80f8f4ba808af1690615eb828119baea4e530858eaaeb2f51261067d3efcea237da6f5391ce8144c9a1b8c2e12a40c5216ba44b887c833306f5365f688359b1889bbe7729e29f5c433e352fbee234b64a5669241a1ab76e29a58a657af2e1afc9d413343b78c39a4c7e4569d32c0fd61b968ab69db5b2434b5eaafe0a648e89293882b7d702ad7a21590fe477b5b146ab72ee52a303d43fd899ae8d910fdd7abe2e3f1b39706bda90a802db674520162635749199bb57f9f52db9bf80564ce24690702d92acd0fdeaf841cd695acc1f87d0a0ab18b47427dfa387156b16de8d4341bec1ffeb96406d440be1f62382d3a69868333ebabeea8064b45e49507033137bcedd754f0806bd6b0d1e7389a4cd48fbd08194088f33924b821744dfd601bd27f7dbefd2070bfd6cdd90469d8d80bdad86cb10ddda49d7b68d75ca6ff9a3a424e26f8f1e3e3644480e6cfd97426f96ce8a320b1adc415f569d20683245ebb99d3aa682c46c2d099642d666942334643e85493c208cc91a35220850b9cd70ae12ccad59de4690db2ed650e27e57bea39426b710a80110688b0d16961b667d12cb5d60a74e4ca121fdf57d9a0be4be254f863507191c76731eaed822310b5e862a5edb29e23cf60404ae940e78e8f9dea17d46b16c4ee3477b05b8f14abeb3c5d9dcaf530d2d30af2ed1a8287769d5e11e7c9c1cce3e7e9ad76b6b3f451630aa8d32ad93a4c33bc61bf34212fa59ff5cbff6f610336f1e98acd262b55211406a1663b4d25d78d4df03084743d9e10c70b661e1840329e19940df42f6fc057b2c82a21d5ce88d8b5dcb65439cc965a38185bb4d2a51dacf0add50141d3294ada09200ef6efaf00ccc90a0e8a7a1a9c419ee032a84829fef4d94249621157ccf1b93ddd293ad4ca346b8af54734414998390023770fc97864a11c6dc842c15a827e866ac8171b406de64b3f4fe1e544fb06c93aa77bcd1d39b064eaafce89e9f051ff122b90d0d20de854779c5e48ac9ccee5a3acb8cb09dc3c0f39ddee813e26122a914d94b5ff423084cec41991a6bea4d0103d15d68b7ef072839dc00829095626f61849a65a437dfb796fa6432d2e24b792828b115faf2bfa8ab791e551872775acbbb4deeb76a386d61c0844c06a43c1b6a0f51f81e69ac3bb5b1c04a85a2715e0cf805b0ea5671d6f098f9a921d33329f7c70dbaf17710c0f7b52b125a82758e69f966d137bf06e4afbea0e4863db8d1311a0752aaf6578a3aa07db3d7b1abf7b390b2dd72029dbbfe6676f1538bcba860a891dac7192fb8be7b0422fa2ec25125f8aba3220132bbf424adfec08104bbc9f787b79743250c3a4b8c75783030641571e0b930cb3d0981c6db873a0dbba1d98d63cb1aeeb14f0ae493ba02a8c1e0c0dae0953bfa328008272723b952c336b557265a506c8c223d5affe40a52a021cd636a6a10bc1c30975aab8ffa116e8bdd94b2784b6a8aaf296b90e96db25f062dfb1e40f9168b86c6f0c42a80ffc1fa7ebb42a900fcab43063aa79549649af1a152bb1bd093fc1ba22b71547e4f0db257435e53ce8e7f8d9e3230742eed3f22736d27598d7078939b1247643f5d17603a3c9cf02ac3196a8bc8b4aa319f1d3183f0eadd325bfd2563660f56f13447fb97c623416f24ba71a0bad8036edadb0208138da6379541ed6caaaa3bd5d77048de329100a1ad700b84a8ee5327f068517f4a36c61fef23fde7d1cba406d3efaa4633baed76f96c0e95e4e30e51d14866c2429f71c2ed3b5bd87464df29cb37a2913a18684bf34a1b72a3ba786eb9b8460d1346844d2bd0e701ad2df89d059c24636875ae093927a152476182cb661e5b706f0da288f7bf50ba10224dff5479addf53d580b587b0fed019fa269a828ff416af5b5a0b35ed6f3a89d37fe0c6e050d945545c2881e8d5e12f046fde2ffc8b91fe3e47bbda2063fb3605242ee5a522c65152dc05597853b7a722d08a7e40f88560499868d281fc9f33638d651f10bcce6e4f9355917baca0263c1bc7b53c5dd9fe4d3e3c78f85ae76ba2122df84c74ccccdaa294cdc67005971fad58518b138024d8381ce5d36bfea4391062fe6e11c487e10b864cc229777df1aacb31d276e5135ced02ed530cbcfb941fd27aa1d9cfe75c99a69658614f8300e58689006abbc64d3214bca8cd68f389b3d0e35aaa558637db09b1c18b50cba5c18212f1cd3d6f0dbc38743bd1a62a20b516c698f6e4d63245bf8fe27246b17a9ac8f17b3e8c3dbcb47fbfbebe769931ab8e9ee9945fd07017afbcff5e04d5770af2654ce3b0c74f2c5009cf4fcccef885f7db3678270ae4f80ab97b379aa472a2c7ecc1e36ed14e3f33d50a1a723517d91a00ba59764e66f1d7d257228ac7a3272e0c3bd306127e040eadec1b21e101966b361610cbd3a6bad7b3e2aae943537ab725c4b7fb86745b2b7d578640086908ea0ee90b5155f803c3a0b232ff6618f396e04eb49cba8d778755a05f47a2795acc014704b36e5616ef47884f9b55ffb5c4aa0c989a107d22e1f7d028fd1098479624fae8ae06fbb07f39f4465777e04cd020d95d11783a2464d0890f6ea611f9bcaf1bf81797e48e7ae59f318933c03be3a98f51ff838e883742c66072ce461167510512540cb8d25aded8bec3241444c8809d90ff51fa852354e10bac3fdaf4440a943c9dc01843dbbd78a15bd2a36e327595c9edb24c0dfc0df3a4cb550b367ea4e7d163b4a270072a743148416fe449422eb607209051a73e91810734ed2d3a0c2f7271d99ca208d7bde98f50bbd62fbc068d435cd10a8db871448a654c2d7b7b612eda811f56a3ec42f84afb641093cc8a60b83d568ea14f554731be1b8764b9b53d4aa72a0f235c867b69b1c9e45515f506c2997046aa7b439ac979eb46de88d82bac37bd0f4bce218d5cfbc955f500ddc6e97253ff9107083543112d1a8c77ac4078ea9bf0427a5a31a988b7adaac0d57782c79acc7bcb095a78756c20f887b80f8ae59dc8bf145505611d1f500a3c8efc6a5d96dae4ab8c899fc688396d019726b4fa954c61dec878a581c523927bec4662cb1d7501fb07c0af81040070266325ce8a0abdf0ef7ad4e9134527f94a5c813eec8e8d24ce334cce64cb8d2380530c305e08f13a490757333fafa0c99661673c9c9dc27ce8f2411222e022224c56a9b2773fa4ff9fd779a21c63017f60b07a206d149eafcd596221c1a8512f81b8ec90fda1d44d173ead72efa64964b6c2cdf3b6573aac617b6b4e2a0d1b03ea460c4d89bd0124687ac9c54f660ea024bc99845ad72b87a05c0db8d059428c692f4bd82950967ef5c6dd933b0fb3328cb3629708d19d9a5a12f7191597c9ba7e06571de542ccc5e21a6bd46980e8b912d7a13638cbe07eec4bcfd92d7bfbb596a644470e947de80791ff20736f8d271ef0d0d6e5af42b8669ad744d6096942a72f4579cdf6f78665c10e289d08793b05bfeb878fcc82dbe506ba9b9e938371246705c4491bf594f617f91150faa90baa7641906ab28ec8a7224b75293efb56ce0c4c5b9be7e8c87e67fc7ea28d31c0ffb22e66f7bfa23fb4435b9837ec8371f90c27271e2453590d56fe170cf997a6c1cae520c3f75d1b27b09048caf2900b9e975d94fafdb9f9cac569c914972c6bbb6abfb6cbe22bc84e2f9c3e6d830480c6dfdf11d76e16fde46536edd2f9fcf3a09b2d9c963469163f58ea7c30cdc50f0aff7d3f606c39cc02f29466bc7e8881f9b10caf794de9bafecbdbeec46a766edac87c71aa42bef11107ea89aa0ccf8e2cf593ca1de75a0442a159e298e2af4b2ec541db7ff5853b03c694bacbc714456e8cceca3b066448dd60539729f9a41ee764ef18b80dbf706aecb7494a6078f727a457dd40308ac5e9998656bc5b268f3f3f461cc4432bea3b998849f975c86f31b09ef7f78fd07661a47db36a92b4e83cc73b717c144b927e365c3b257cd3ce2f25f9b409ae0c358d3daada5d0328f7c14bc3f5097d159122af239a43c368c5e2e5cbd3316b72d1dabb7cbda8ef116f35341348a2a37251f1abe3068cdefaaa2a9ad3486ce8eccd4f14ed21098c839b0d4f9f94fd9c35a8ca5f5e8ff2e5269f322099f10d780dc431005bbd588b6e2d8f8ba490e62c02b01c7b83e226c601cc48eb86c2c3c0579aa310c62506c512eacce3c401725292b279c8266121a8a0399a200e625dee8775c23f1d7c22d387ab664a6d3cc6cc256b3b13feb08791eafc5572ce668ef9b15b00a7a7928b849fe3fb25fe42bf09a66aeafcbaa83551477dd3f53b0d9951dbd53fca97043c383c0c5781139b0c5b573925e1d4c9309d07221a2e956493c9a7de12bb033f1f0f019bdaf82d990e2a3ea9e1ee18e55d4df1d16bb80a9a6a815176ea6d4daffa0f1dcbf1bb61de37c1e1b25495a3ab80aed8b6c41e24221ca9674772f448315f639dea2e127410c544898d035405c9240df12652a85e49bde6c002cb7d8ec183128077ad274edba5d11baa4f74f38854ae5140963e48a839058909625b22f5bcbc731aa1bc9b016cfc0d85410578bacd894b4e2f78f0763760144f05dc44ae872134ea336b48c9d4e80dbaa6ce8aba549d1ba30a302fa6c4dc2a9557d8a13327ca6fd1b43ffc5146c364b118d116c6cdb3d6ca209e415c3d38013691176ad5bf6be9b7ad8d93cd36f90f89f2eaee8a62bf8adab721e2f23eb70043798a6394717569bbfedb6b82b34cb3c8d799ac58528934f4d467558c28d26908e90d076d5950b3ecc2e19f1e752dbd5fe5de6d96284475a812e6763bcdee0af9b52d63ada8e32fcfcafb14df4e578224cdb80c31dd26fff497978d2fe7add31bbb06feb532cccf69292db240791232a42dac680a3b422e91add06f76cca2b0988c04a9acdf2d84061ac8fc7176c23c277febcb7a5bb580b5f71e7cf63cb139482048f8fa8d68a695524623e81db5ac612396f3f9cefd2bf7cfdc462db7de4cedb065897a4dca871dce703e6e9b538fde130fd966503cb83e9a0d7871443f869d88bf6f0d7309bfcaa5ad48c955c64f6e7b07f3232575e6b18f554b9d4e09f04f158ad0d1c271f8f2d3e734485766eabd02197677315ce2ca1672f75f5974b533ca4214681361b750e7c130cb4543ce0161c8308e5fe4e60c99f949828e5ad26ea268466031fee21238ca4e102ae8588ad10c12e981a2153ddaa952f7aec4f905942c15909c8dea4c27f6cfff102980b41ad4338fd89dcd380e45b32f8499d8b81e9d56067eadd8bfae74ada604062158291421dabd65dff5d806bff6a55867ef7dc32ad6b63f7385482659312d4bca183114c1674723abdc5e81c6cdbd2dc7761661f48b907444991470fad127408c33273dabf1e5a0f2995162a584de4db7bc430784782462dbb917272467a6fd2f8dd800464349237254d31af1648821100d9073b2b7e8f7f9a509169f8b5b32ab3f61824b3a7f861cee6fbcc2f0e6e4d4fbf6975165e20da2bc1dca280c3cef34af1cd0662aff722356d9dc20dc4b166e73c2e5eae11ee1a7dcc15d659e5f2ba7286d610aad69caa4a55e395ea7e6fa6677aba89615312bdd19f0ac1a8127685042bc8abb08524720f8e860949d284ff7a28eeb23933c64d4aa0f0136fa50861bc6d0523e969615c76e21a73f6cdf4a5953aa49a988cf2d4da7ec90d0bfeaa2c7c3b9c6d1c526dc2bed10e8ca5bb76749b2b2cc06a9afde682efc881e3658cbeb9a646fab41f803b1d819cca38a032e958ef4a2680de4bec3ad2bdbb2bbb69b15dfc5e8679359787bce8d164de34a6fa02e5d70fa12181d227e11daefc1605472c8816c0bba460c46383cb6952ff013334dadcf01630f34ddc8988cd1cc4c601224e7ef73920da0e5d9121ab91bcab1220800e3e7598a10f098d07f954de6b37a3225e0e22ebf68239b562f0132ac8fa7ce29e7d467e1da5c7b1050766c63aa43f97c8bf045f97cf2f084cb12a1e6396b3a0808c9f9f1abc27f8e9539f1f998c9ca0399e9bd2d20a4a04407757acdaf7c707eeb9765f327ccfd93f3bccf5b966beb558c3a83fe8237b48abe9a818a6028a702bb518c80748fbfec7e903fcc434db1b608ead3fa6f965ab7ddb0ca9a7a28f1805ae1ee0e33f9a228292503d051ccc38fd7dd7f1b409360877e176b0f013a2e175b8f321b540154499351c717f103495e765e6d8e1bf50d587d67e4c9849664535df3e5a1f0316668443a802296ac5ac373b2848f216a84f2f8b684684ec51e4216f09f32ea58e1453470a3ad19dfc057d7486272deb0b75e4dc95d2d1483063c04f0f65b8015af099cc6679af9ff22f11e8fc16e8bcdadd004301bef794ee7410b132267459ff1c32d3a2c207bfca269034c2b6c9797b117540009cd21670f1341abb0511a4b1c2a831f7d3ec9234a663ce1d5536fec60fb96d2494eec1e083e50936f608e1a54dd16c3e766ce1b30c25eabf23cbeceed3ec7c645937326e4cab060a4bea1c899bc9e78666da1ab084ebc1b98df9b7ee35a9867cd290c3817fa52ee33a22feed6078193255484d48155eebfd2775cc5bcb1e3f264293d9762150d46f7adb1cc523bd68ec738f461047f8da2f91d5ebe5e1dbca6ca02160fe5d522d39566b0792a998cc8dc551b1a46fddb5105d509ccb626f962d815db87ef4916d76b4da4a2a5636b3abefbd467f6e37fa47b7dfaedf56f6f74c08bc42723bd6d79b0c22d7fec913d8990606f8e98387e3990fd4aebb25b6c4ba839984098f4537d9c4e1d47d226cafb607845bca2ab331e2023ad7ff60e7b78c9ed0f20a29ef970bf563d8318fb4fa3fbf3004a23839f4595879ee9345467b3c2f9cdcd39b9963d903908b984121ee5374427028ec2e256797e55af841c9c23e3061c4a2fb184cc14c67a30d1e4723fc65bcb2202fb6c4d275804aeda425d0397ce1a998d62622b8ecfb9f3befaeeaa52fd395b93f36a581e7bf80b453b13374b1a1354c787d66ad51587d4b50bc13730d1760e02de53fffecd773aeceefbee389e29ed033549f501f206b6b5185667fa32fe8400ea548436491b7edcbda1f4bd0b8f42fe58ffb6c567e18626eeb6a3433831acdac425e473479781bfcf288929100bc32b5f9473731e0a73d022d1676f06bf2a6317ca7285073bfda1071a03807a1f1d025faf9ea7ecaac54ccdc001850de0d8ae549991d908e72ff210aebf963a1247f5fe516b49287cbc9a0e2887d20145beba24b9d8ea2a30b60cefca58240af8c68c26ce13ba652e2c55ad28e1f1ede293d08aa7c28ff01b63c37f0e8e1f5d0d3cdb6cbef5b5f4bff88ed3344093b0b19d43a18ce75309639e5263bb0d748fbb39d223554a80894f936083746c5276b36a3ada691ae75e51f432f111393beb592ad36aec39fd6f18a4d45ef5551355682983714c03d798571f2c0b49aa2173dc3775bd256f48d771c2917fd8f2a13cab4004c8b8aab35806ccca3496a18860fda367b43b9408e34b89dd1dce2844608ffc0401d41068556a89b28312197bb8f191077f21acf192e435125078b9073d9b0afb65d9cfd08d9514c1c9702a2ac8260d3609a486ba127172d1918da0db6418bd2b0569b9967c50381760795b489b33183bcaca250c799ab2d7a52e54d9fa3afe3b8306d9a08b75df735feaba92b4838b61a987516a20e5e70984c319334a8564a6d904aa178705024631bcf9bf7e94e758580d469324e0d95a8c9dfd13545165857d15fd57b3b51a33d1bac87741079af3419457e6f4f511b59bae8886298260274a8b36beb5fe57526c509ce26c47354c031a54cc3010fc9ebf02f22053b05e7ec6f2653404aef0a49f4023e335f308c447992554ecf94cebe5d67e1ac78651bdfbbc3f6619b1fc0d78eea460c2be298b0b3645ad6eb5362534b6466f5838730a4475a5703ccec7319b34315cd281889ead0de6cef2460d041942aff9f570a6f6eff5f6d6635743741af0fbbb86874f65de0ab34ff75be57c12059c338eca475427f07e8fd1f4cb2442f737702f6b4067381297fc2976381d8bf2364cc847af39feac6b3484f3a76f516f50ab4fda7a9f30deca2c5e20f3df07b771488a52b9d28fbafab028a47afcd3a0d547647c9007ff69df6e2bf558f7e1c6caa7d621e75325997fcd656c87ccce0b2f3cd0ea4fc2db5f9e794be16e23c1dbfba02177880de1c64f337760b0ff5fcc154df749730bfc5d8f35b00ce462dea064f2f5f14094a505e82e66529d04d18c4c0724b739cf439941a498ab3deb4043990b586f09827d1b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
