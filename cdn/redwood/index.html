<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a1b5113a57086de76731cc5438c94ff81a9a12293ac00350350167528257cb5a5edca638c35a40ce4667ab78577c9b9381b9d0e606cab814edabc543c12a06ffce298cc959408f3ed0d75bad2ea13e2ddb8a00f05abb0f4b3172b93919e673a507b62e42633e725b6f6073f6bce896a9e55a5254ae977b77344591b66471b4986896f1d24fba606e1a9fd1cfca9d62bf747229b121297693c76dc0f5421be16ce90bd7955bd0b1816250e34eaaf93f7faf51a33604640e120fdfb2a13c78d4ca62485d177c27b2a7074e23127307c6d227db0df2b97fddcafa6d527be3f2a907cd69bb275feebf635561cca3cee0fe1d5aff223b52bde65714f1e4761cc2a887a0a65032565606643dc1e5ab480a475470b9f0a7ef1235da63c26dffddc08ed84360cee59b8a0a25dd176439a9b1928e171616e7ab186e51da1bcc60620e5c28d5ef4cc58ac7639895c70c9183b8b9514e69413cd269e4644ff5b4582607cb9eaf906aa9e081631f5aa1a6e18478d1f5ca2e34d2faa8440888f5b848b9b3d062cdb162c41d9ce2ede1ec12fe9de680f2bf460e374e25d48b226178cc32031ced9f4a56c28d9f75b655c2b895d868e66c976c4b9238883acbd77b05114af0f335b03f34627b04dc811117f9640bf1242f7bdf09644355039219101b7044b4da1bb6b0d7ee488e4e40b3989245684c57dca208122b8b71ec2f27a92100894113c9ade0224732fada617419dde3abe74c997205e9e733e5251d227c800a536315bae6834231b4b06c9cf62d6a38391569b070c1a36548b99920b18116f71e2b0d7f8abbac9f68ef0e608275ab7719f5a98728bedef4f978a10d2e55a791da91852097ecfb0b376f6ea7049bd9b449cfd629174b406447f2b29f1565bcc78175b0c64bb4822d79094124179fba5b51188640932d864e8be5246cad593eddbcc23b4bafde525a3825f872e70802527675ecf02e3b6c6961f380e8ffb6c3e438a579e29118540fb8f28a077fff6e1f75a73ec0c383e597c9346360ac3096fb6e4bcff57abc70355a14daa4448309579b3886071811f2f8495ab3c63b8cace3d9471cfbafd26038bce67430ddfebac3069c02ddae6c0748ef25855082f4a04c970ca316d9f0182e44096f9595f0e9a7bff2ec57e055a366c72c18832711a1aeaec946829bac313b8bb34cb14fca2426f07230abbb6fe94b590c5ab337ffe03c95cf42f550fb367b884aadbdea5830a27b9226190ce46214b34a5ef5507d897bb49b6291eee1c22fe67d802a50cd6977f722a0cc70a807dcee1c347fa61a97da96a92d92371174326cbc1f9037350e56636d36db1906f36170b662702292b4f7ae24cd48c3d226c45d1dffe80a835e1a617fe65e1e849b75f67f682c0325f871f7780995c7c1d7f958ac0db294372e9bf9cba8ca3edae33437b2522e947611e8931a7c09a6804c3784576f6fdf085aa9215ae3e488ad7401f92ac4beb649fc157d05ad33ae29855c35f4789e3e9eedf9f058f9d9b1d98316b9a5df10ba892c0afaed5520280d3e894f18d57582f8253d8a6fee25cf6d354553f065715cdc126cb05a3314f87e367c4682b816bc09c21504fe9fbd12b2520c1abfa0a11d77dfe152c30437ef36fb5522c3939eb62ac6378bec48a293dd0f1fc2f342a48e01e0b599f7871f9d7781dfa5e6f551fb280615e055be215c6c4919aae2ea55aca2621c6500537ab79d12e0181c9499eb0c9fe868d17e85b5019e10faf01480c1c251be6416ab87e81cb000af26173fad7adecd857d4e21d7ca0500604c9fffd6d8652b4ec3f184faa1f178c3459df71e972ba2c2dd4c98e7c3fcd18a0b58fcc31a7eb6f7efc9ccb36656d2af2363067520affa23c76162d549a12130c2df6b8bc97a9e539978e6f1bf79e3f75fb91fa09004910ae29d955d8aefee5ae5cb16bb309b16f6201a996be8c523299bb72f858684c956ad6122dfde5faeb71d0461da8ec8bdf75a7f29447b4f4937695f0deca0475845b99bad4bc294a2c0f18d390bba66998bf4e041e72521d588ed5f78354fe733a00f3dae57bff7202a03a2829bac7bed144642941df08351d70c6b5847051786125b11658f17a9d775a0835c411e08d48dadf68142e70ec84f9a6ae4864be8153d5814a436d79a0c7a96f2f7adf0437a6bb4c196a7ab60ee2de416df1f291bbb029ccb482069cf3c641b123c9196e644c32ab819361f89c6e0b6ff4787152d45b4d97ac7fb738a4aa9904eaa89872f0a3c0ae5149004f5b07af8a1a3d2e91e1b562d37b4c97604bf51f2194c3744fd1872ce0cabafc16b822f92800b621079ffddbf726ce117d5d7da731042199c667214614cd95260cb0b2f7455d976072a24fe6443cebb6355c15f822e71ecfa788c0e893929b02c8dc2ecedb4596b3adc7db50c1f536bfc9dd7ff0467dc43c265b2b49cca67dccdd27a74c48a20cc8fa47323dd7eaf312d623e00d14483c1ef1813b1e71f94dff38b7a9dd67e817fc5fc2637bbf18b7a51753efd71284d71b10003b14803f90ca0e6fa88e1e193c090ba115c0eb7e0e773f09c9d50369a3563708eed1af6a6883cc32a8c27785dfef9570a5b7e4002a540f865d1c6c81690158812b3fb246f0636ef0330ae29fa8e05bbfe4e8964ca3099cffcfedc6ec0fe54cf8f869eceda68bba0d0021e7f4807de39ccce82760e09f3c96a5183f48f3961c314ce4498affa0e7273b1694c8bcbad9b383da1e873512bdc052e1ecf59dc499f7af36781ac937afd14d09ddc2d711f0d62ad43acd6df32bbc7d7245ce34cee5ccf07999f252a009143da648eedb443ea69b014e1c41d824d1fdadd3e96724cab5908217f4c72ebc830ef723c63aef8234bc316eca21933b5879f715b5fce981a4dbde38ba1484d6f6f8a3e91719d4c17579e5ae8f1b20d6a4ea6238473cf0aa3b9bbc8001525c2a6f3cfe0a8e9e044f1a5be1681b151521a2a4833142f6b8a15d4c57f1294625ed1d861017f20e852c449763f3e9d6886f7c7e32f4c3a67ef19b64f0c18e76a55e09c30de72150a7080fe45af5e7a1c81705856a97532e1319b967a53af494b27605e4b5b46bfc2f86f1e5a3788efd19cac1265364e06fe2ddd29a9009b479c245b1d17ac47ae9e91ffcfaf3b0a037bd2e626a2e0167776bbe94fb1b217ff84766ef7819f63289d5cdc89e3059f0ff187ee032d7451831365e4501ec0ea6d1fa3ecbb8d09c881d431676a8a647906e83e30e47df1192302a5718cf17d6045dae338a534a830aaf29f36c14b336bd4dd9f7a12b7de23ac327351a37e74e377816964394e5229db8d265a6ba04b15fa84148f20d1b02bc27143042f4c58e20f13020d42bb35605763319f40808b37048bf0f571f5dfdaa502da49bf46978cd65ff701a25b7de32b89addd1704aae14d9a4e5b02a80d1e2e8547486e86226d5aec8409629536b8327c91ddd48e03703f918fbe4c948450f82e2f282c1228902badad6ec5ecfcdef4f0b2d537a9238205899570061459322e28c6e63f8fb6d7262be9a60c61dd07a33a871feb1f51bf61944379b54c83e17a6f1244d7a38ae4e35cf7c351571794141e90e7b7b180ba53e1a8057683475a55df1a4957d41f4b136c5d559d0f5d4f02a272e538582230a510e62b1f2acec09066ee49b7aaba7a53d55827cf8fbeb66eab9496fd128b3edb73721c058f36c24fcb74c0ad2f468101823e7f092ed80e0ba386c0bc4c20498c2303fc1c9458a17156fb3748ed534e270ba4bb8bfd62076e4b85a78ea3180e9b6f9130ebf710333c328435cedf59beec60b99cfe7093e8e0e36b220ebb3798006c0be2a45dea7dda81e7ab695198ed33c719cc042064609306e7118c55d2985b7a883983888894b220ba1b0d52caf9f09934ec53f2cef36d8cb5131303dfb9135cd25dc6a94c32821351fb50050b29356cfae80bb1cf07805c1e905c59feae4e9957a9635ab024ee2cf8352a6cf157fc5737846d12e30c8d2a2478a38b38bb285154e66803dce24b4273b8688a15d85889f61f14198c8dc68820009d302597f596be19979f7e02bbb99a98d874966f44a3a5570e5983ca60876f6e80b7624f7b19953dfe68dd86891ed240e825a77a4f29965babdb6b4e6cb07a8b792a97740b359f3be16b4d87189a2af36134566f85263fb677281ed3398394395ceb8036b8ed4e73ec602b5704e64ecacd3e0ba3451e5ca312f03aa275e769a08806cbecb8347633cbf70747270f44db51634058ab436f05a20f5bf2bf38db533d4448b128570d5a8d2e1140013210e96ab1119fe921fb5a09a4f5512ff692eac680b5fb5c56993c913485db3924073130fe5facde1b2fd6af4af17cbe96e378144640311d5e88f691d7fe85299fe5253f7d254c54f972a5072e98bab3ba5deb61208fcd042da45eefebdb7cfa9b3bfe4a88cae4fc2e963cccf8698eb2d8ed28f85a8c6b16aec6c772f6102abd41980865f09bed48322a95f76f03f250e21032ee47a206f8ca68e100fec6effece5d2e579d295883267a9cfdcbe3a8593d6c76e5989129f19059de4ccd4240d226dcfedb1196e6b6220d9b64657e579d930c57300c9f3289175cb33954c9080b8f6d2ae51c40c48efd2f1fbf0165f8c55469abe684753f85e0afaaf599b2d1114159e56a0584daae6d7747f52c31dfbc9c1df5029324b45e72dabe864489cd5cf2e115624b59506930ecaced946d1342fba431d24fad2b64a707cd974bcb9900072690a72bc4904dc0db02189c86ff94df67169c5ed622e9dc81ddd9edfef28c84221a3c0a80140d183558369f4e957ae93ea9815354638406e6d3e98db64ed8fc959a2ee0a4234b72ad16a936b570d261118439e5a6ea334fcfcf762b5e414bb1a3e35cb0b0bd93e50cbfcd21b47b2946d3c4aeaa97800b98d506dbf6e00e07c016ad423d8986f5e2dd0b86612aa73020266a7c9168d3baca56b74c4d185eb856073bed4eb055e5f90090a4ad245771b45e41a30e570cbbb75023f093f07d278ffbc7c7b96f2b5a5bc5c1071343d5fa7a2f5d27d09800fc71bd0719f8ec01378d36547b209b383569f0e7aed86dae75d90886094a44a93b14d8323a9b07be05863e49a0c720525e95c3430b8ce793d8de4043faee803abf44db1cb307391e5d9a69dd3dbb4fa25301da8df02e4541237741585b6898f3cc9a5c822ee994d049461d98e62e4eff10faf964ab70c88f8fd8bb35519ba8af7248a58967a92ea731c8e8a139de1ff6e855c43cb745aa05ae63071dafe672ffadfe5050d87fd1621bd43b8d75b83163379c729ef60d1f5662bdec9f8d8cfd406669922bf3e5393fd5f74d782ac604f67f88f06c96a9144240939d0bfc044847e096199e4771d76dc13dcc73042f8006c8f12005759299932ccf7a17bb4ff22eb86129ea36c4f9adca63458f135c00d0b4f08d3fb26de81a5bf634adac9dc62d1b0f21ef31960387468770a2f5adcb50d80aebdc6e5f3c62e8c1b37367a4393e162e985163db38adb725dca9ab38a1f13ee962142b0e60e3b7b576b2971fbeb925fd20aedab1004a5c6d1ea3b3cb96bd8226b21a1aee5507912d1e18e64e217928410c867a022008c013837af67c91b957ecf336d46a13be54a27e27c3814db85748452f8896a2db5643021294456693b567bb7e0f24df2d6fec1be1e4be59dceeb47a640073f21c05f9c46dfa0f27f8042ce5b30e49613ad0e51b019a274421a4b92d881c86f8298d33280fac8d74ed8d26f31a1db5e5e7f77fd5c49c7a5ff1732947ab3271a51367edc5ccb1cf61446e6f122c368a214c3985f5efd46620bf365182ddf0a587d2c4b845317d4dc8c2b532097ffc62c07547f9415426bd6ba38d819f16ec4edd51630db71d3d47c9ba0503af53b3ba9ed0cbd1678d0ad2247ed47ac5478ecbd25e6927dd4029fdc33b87d921517d444ae7c7600c05f75c54e5b863e714eb44f1d7b9398addc58c10539fc5f9eaa7af286fc1183deb476a13c99b7a91acd6667a912ed97afdef0b91d7e946c603f476e368213dcf0e0ea89f78295760360155bfeb7ca03235fbef1c19a84d916f2b4b2db353cae5b8d4edb2da8615fe11301f212c6fa276491c92b00986921de4c3b9813b188db4207e3a691b7d4f2e23a869fcddb22129c9ae393b164a2977b082f3671b24d3b778590a312def610a0e351b15a459f9b9de04034530085b89807ec8380cc579a48614366aba15d98891de0419df99f99d045d6bc53e020baacec3e643096c6c4ab90af4972c37933e5da260db6e928f6e36c1d976c64966699d1fb0bf738d618a246305dd6d70516b99900e7b35a6a9341c1fdb50aa6549ccf594c3a08f9725b01ef4f0dcb9de8a3ef8b82e8608018e112b72d124698157d6f15c9e83d52559164b83dc94f83d472ae09812a5f50a368e6a645906a27f57ee553b6f9abddebcfc4ffb43d0e545fbb6b68ca37b9df5ea965510ad1ca57606c65c738ddc5d0d04817f73b8d27539d3f45a4caf932f48e7cf86045e124b11def7ed63b25b769373f5810ee2485a1b136811f3c928f2ff3bdcb6a870a8751751445b54048a14e7ca47a7b69a35ab8339516dbf0fc60fd32329d38a7f220bbc59ae9e9d1db4ed114ed5787e125d4695c5b21edf68210741726b39875894d86d3c99258b5bf64b076a35d8f9310cdf306748daa50dcc69f6289697584022b2e3586b86f84e8b836c5d2457f92cdebae1f231701b46c477f2cf744735bcd331a98c0a8140297f41f836018dd1d7a7edd69bf97249a0c3ca84ee0eef95c19035f4b8c325b12a8a052b5362c0f1a5572a50d21f0b9a30e49026824bf6ba486f5fc14490d0ec1f7c5d28d35c0deef680012866c1c75ae3bf6ee49cf500697c714dab3216d7071effcb8a669a8c5fff0361e9b5df55974de0f66e6bbc880c54650fd20a1a28e936ace2dc599cc672ea358fb5d74e66c4e08e2c19ec0b4d77650d14f8eaeffa59e1ef3e2d22c620a704d8c38c242cbe07eb1505f69acd3b73917dfb64e8fe9354038be6815ca7a2ace3f58d7f3e3a6e07d2b15702477c5d5baf914010d7d628f959a52ece0f8a050edce8371df191d348047f98ad5827f0a0f0393065b1acce193e3360c5b507c9fd5b4fa99152697dfeaac0f84fef489cbd7ca2ad205e4b7de5f53604d4f599e7c41132eccc79cb76e7740f637e0c1ddfcf92032b32addac3b3e3fd1c511820c4d2041770607cdd0b93ad84c7491d4e1f4c7a92f0f2b704c6f2a681eb5e52aac6356ccd70d67e6974294b374d918b7f18cfe23b609f5c22b5618c9e56aa33466b1d848794902ec9276acc06c2a49443ea32b20dc6bd05aa56ee5619419672aee01ce3caa6fc44aa7322e0ba0bdcfa1fe5befb8f26bcb091c3c2da309b612fc7e42e9bce15ccadbe8c4ebe2f9cad18c722cd921ea9661eea928910409c96be24590628d065f1733bfac768f8f93e0d8ea321fd98cfbd44b60b78350ccdc91696633df2a4cc4f57614e79f55cfe7d2137e2fef20a124140f185deedf55681988bf9d08391b2135f4772e7d9064890f05ab0a500389b1b7a6e01ec3c433662946e36fa43e8a104c9698feaefca38476bc59a8a123a022f2af069f8a3d41a6e7f0e8c35d66edb731b573184786f438f4286002ef344609f4620a99414e63a210e91e4bfb16fa4c0721339b6f77e38e4caf36662bc7ea7a1b626a089eb006c1f42c22a477de2bd07234f75cd0c4b3abd651270ef3ec7d929dbd80b08fdbfd380dbdfb54b9d755a1f9417bdfe7ba5d8b2e206b33f799d2a6257d5c6cca6ecf02010d5bd3f13671cf1e2ebdf76ca87b4368f32bd7c91a1fe3e4d85ebf4bf668b377d19813cb0137dc6e371e6d1a66d26802499c6e63be9654d1e2ba9e19f8a15080ee4a11d83223df6f5a4756e5aab92f3e969c69222b7e936e18391106c3b6f6d32165256789ac7ec351eaf9f90dee1ed429229db00909983b94f6e2acebba903ec0b0b6f88cf3003cd79c3aa1f84bd6a033d7714a3815f411bbc5a607848518e7cfaa1c4d05e9f7d21ecea1b4cb4b5d8b17806f5dd71c95deadab3ccbca4a8486c3e8236c2d49209df6b7bb2744488a376008d49592c67c460b444ede5cfa30f6cd3e7e01e44ae5cd06708d2a7f9cd8ae56701f6b1b2c2b65e6db9773e191ede62891e2cfa137d012c89ef67609e7aac9f650022585977074a6117b0403ef808a18bcc3a1f18db0613e21be8a5f008f2105244e1f3e3dcdf2bf73806f24919a9ba25b672b29d088e18dc0b301aca8dd546d0d0ca9961adde5b1ce323ab802882db0c8280302f5f2c1d507dbaeabafeef4c013930a4ab7c56befc6be0472efdc364e4eda97793235ee6f48bb2568ce2293d84fef9bd5b89928614c4078011065e9014b7b50a88cb019b66152cccf3738f6a0928988b99ef65878c61336b09db7387d8849a0d708b3325cd6d687768ec88462111a54ba111cad9392ef593b50ed3aecd8c8e06fe54a023394f18741e279712fdd1e04bebae4e976fe6d2430662c34e9059f92ae5d17715dddbcd834d13a3ab41fdda3f2b9ff4460b5bb4ce5170bec32fb3c32adece088a9869ceb8c313db01eb2b6f0ce44973d3bd097cdddba4a9b47b86c0b819409ac99f9f6b385b1311f4a0ad9e7bd821d031de1c4e7903767f8c4a16bf780d9caac28e219f63f0f1062d6be802988d5a95aa3d77741a174052871c306bee38b94123268546968e5b3856dc02c8b7d306e38cac278b1387cca02299e19361bd2e1bafe6c0c246097e09413f6892cbff1eeb66af4f56707a70afa4e69b94a0b2dc7b39f122d8f1a863bddd719882fbbae299b3a3125fb59ea5ba19a71df273c5d2ad47b64741dcb2b3b412412517c220fb74146d0bdd26c7ba2577a6e4091eafb96154c84dba75046496003efc3cae8c4b1fc8772b5670852b3661afc7de74978b7b11fbaa113b2421399a65c680099aa34da4edc48e8e4a0deca030d1989853f24b74d5c3327303079f339cba32d1fd3728cf6a294740ac05d9b7c370e05bb5e96594dea1226ca34394c28960fec5c0eb84fb03f3d5b1db759d7d4c6f0a06abe2e46eeac1b3c24f39c8a0fcfdb6108b507cd6100cef2bf57bf0b462bc79c7775c88b7087d7cde465e4694697a9af8844c606574c0a97dd29ab3615f4efc4f0c29cb226ba02002518a5726176f8ce0ec027cc77dfb3f9ba46830275c50ce2e6c4583c3c101b60bb4bbeb8dc23d796cc4eaadd11f030450ad6228fa3da10671eaf0ec878292598d54f45999b5259208271650c48006f562b545e2a14d80efea0f34ca016426b742e75a80c7d8c9afaf46ed7c1e5d6890dab0f4761eaffd76b4c1e42f6c9dc2fb15281677180131dca6f5e9a82b773cdf3df52d02f9b688320c77dba26bf80d20ab677a5656e6c1e714e8b4a87c9dec8fa49dd21a94ce45df49629cef55050877041be5df8fbd24bb134a288c9c81a80aadb1b6699826568669958b7e2448061479b6af86d05d12af1fb3f4df5a3d0879fa70b1762a1a4369714b74d213db6358d533c25f5ea622cb2d6bba3ba05bd38cd8e9db1f44569885f4e951d4d962bbc7a3552c338e5145a536e014711949c074cae1ee5b381ea6307814c1489039a4f43772790b5539405b9cf6753429b7a5c79dc79f18a37db5c56c908dee0b27fc9505b5aee9016c6d31b65c65405e7ebf03432aa00bdfaa8d8bf96294c3dff927ea5ca3e748ba194974a6f572bfb9f5688232635ce9a0ea8c94994be4cc5e733b4dc3f6f4de6fb2c51dec653c0fd2d686de8755b05e16ec148c54348b808dbc38ebcaea8ec1707707d152f3179c9412c47df68eaf80dbb87cda53ff23b07dcfcfd8f96bf4c1a8725d788008a683e24df8f6e26801bf0647a13a40b5cdeebc3133f2c1454779eea01d05555632a2d0a23755f1c5006bede5aec0b70c36844a8bb3711e7d6bfb6d46b71f056207973c28393b22149baa5c5d048b32d0545ed9b5b682fbb9a42c3b5b3363b855e7082579a7b484143196955ede0a610841ee2055b7d605428e13f8d8da8e8a1cbdf695271f9216bc20335c1d47d2656f363f11f20011279b7b53e4a4260b8d9763b9bfb6534c44c3c967f0ba7fd259781625e98a9ba036c4395856f649823a3b8b9d033a967ed5acab30213a40d3df2ea9564c8340fa79d28387382c67432fae91683718731d8d67e28739cc1a08270e3a1efca0256ac96e44278d6291d5db85ba380dc3e4dfe0322fabb63bc6a0bda013808a73b05b3e6d3a171b17cb688c1441b15f660ce06f98f9f952d5c8a79234105bac8c509aad0b0ed4e4ef1b527432e91c782e1fb23560aea42edbc59272582da5af909837c7f69469fbd5d15a7a0e6b7fd00c3331138676b691a570fe55998d4ea647bd006cfc5d24e84adfdbbbeaa1fe20fc85141e509f219ca1c50bd1d7f44e34fa656d6c296c05cbda0080f8ae6411c64d3f4f156b33b0375a2587102992aa55ff101c1c53b17152bf2f90da4ff7bfe46a8bb24a4cb6ad9ca1e854de5fd28e7432f0b114294c76ddb44c01f6d042c4cc8a79bb21e6ebd2bfdaa5718587895fb7c9f830d0e84e435ed022f5bc440e88b1ee51bf744154f5d3babd8bd0d2ab628766b0f099af156607311831a7febe3cff749db3066194cb6681f46c3a55eb62a70b5a60ee066f5ea2b74d81ae79b2d22a7e32896bce080ab4bb2cc372a34d09ab95dc64dad4fef83dc92f6f5faf51914fad63591acd0a304758cc1e8fd96ec162320b9aa8bdd00279847d01bac63d7e500fd04db6c59946e838cdb4489de639e4a805aefd7cd0bc277405cfe9a26d28d6baf4aafd596bfb989ea1465b0abdf8a823e3f3f298fab28b1381ba0c749d0cdb5d72b8fa55045dc55d8e3cb8ae7688346b84cc6dc3e00e59a70c78abbc5a19252da357b93026b0bb415027987747f1d87c19c9e74fb1930f4b947b9b9bc7b68fda401df0373e54386d0b7511608722adf2037eef9a57b4652c088de2e6e0c60f0214f95ce05200028c21a0d03bc88b2940d0b070e343b2c7264f27f77df057fa9412847028ed7ee921d31b2e5de22379409a27128b516cc2e19848137574943801ce2d3757a5c8a8e2ca06a7ecbb5d6575b276df97056cb6b8a011c166bf7c4cc51b4c1e726d40f32bc91a52dfa8cc0c8bd7e93fd5e6dbfe7f45282c3490b8807a65c8386ccaa6588ba8031e40d8faf4c41bc01221ca08dd5203288cc0fdef98c4751726bcb0298ad3c829951a890c37419204e8f1007793bc3d43f401b3059da547c765580e5cfdc697f635fb01a2697c470cd9d59335428674f494cdd8384cb80c38dc68b7d0c503fbe5e302c59c58f1f878ed12a574c8642afec8055fdf8485caefba81f7559fab70d873c2b24ce84bdc08a2ede3b5deff7f2b1ea2af63996a85313f6daf1e55b5a2474cd6c6b62ab221b28d7edbceee5498c3970391fd34b07b7d5ae747148724affda3d5330a6c0e2af3e3e33d7ea8fc74e06150199aefd9841de6e87c799f7a054cbedb6de5a60d44bd8cc06e344f5afa9f8c95e32947291dda8a381e860306c4d204a34c04b03d44d54d2a8d86e68f6493309212e1231c324f153f03974928f8a304524a613089c1b071abff7acad1f353e651100caafd14eebac26d827be520ac5fc2f0a035f481e826355722264a9fb026a659df64de6546b2fc87de2a30892e3d60ae95f03ba1578155dc11b10e46bef6bee477885a7b1d5201052f1cdc2a18da4f1f9d886d0737e771baa5c1a7c115a3aac6098ff171214bc85b3accaf275f0394ebe9e9faf92d9ea826db504be1980558612f7dda18d1b107a42b2d0c4dc89a8aaf0683f4868fc688b82799817a868af8bd3e1d0761bd11c5f446ef1e8d02b4ce270f6cabd2dec1dca7e5b174ab61ac11b57092e860463709356ee574d918bc3a80da15a1b899bdce0bb0ae8a371ec6579a8f39058bc403c7ff248c67a33feb637d903cc29e9d5049e783660a75568beef251006c87cd63a5193dc072493cd1044b60885fee8f216c502bde02e83c1c15e8a0fba3db92ebd58070acf909e3d788c0c42310a3b7909f7dfb752f3400b4185a1cf2198fd1b4de82542bbc9863c11194ec980911ca5a95259c3148b1ff71bbc4689badea5539ba3461be12f22de6d7b80279a34296ac19e2b2491e061151c430296876c126e71a542015bb086034236deaca4874337c2a26ad63ed49dc47b1a7a6f6e9767f27ede994a977e642ab53be180f333c36224b865917e0e5e5f7b4568d22b045ce4ef22a805056c6f2b57974c476d3a1969c3b7466133fbc14e632e90a7fecdc441828698e618fa5b5d03613d6a56c48f65b6de4f46abecc08dcbb07ad24f9719d6162e3e2bf41cdac12a974b6e34c27f036ad24e7d5d89e710903cc224adfa659ff4590208a6d56efb7b8916136faf59b2fafe037289541d22940516c063744a963b4e4e1e5bb91d9ffe65d6decb5f44713a18a8c844efb1454334e1c8c20ae16248016fcfedb9812d42eecf29cc07ef3af55d1a00c89f2294f0f569ca98b286c31fd6b76fe1b2b398d0541d4bcecf1cc7bd301a09c1bbf83e9d9b25c20c5aa7971f540dbf045be925ece94c6502bfb3ded5e75541dcc655e759daaaef9bcb701475d78593826b605b013fa7f4350de2ebe4d08e4f799048dfc8f4e427adbfa5171f4cf4021c3ff4a9caa553d9a1760e0afd390b4353e26cb86c9015af0627585006aad2e5bc58cfe458257f0edbf19a8be54a5e702eee8863a98f24fb86cc4ff746c32f20c6097146e01da0ccffb8f11bb404c1741f32a24c5b2291d4cacee8bfd1cbb094c6b2d9734d14b14a168977a42bb800d7ac1ab0489e7b0636c50441a0522a536e0e4f14c1e466164bc96769e31f815d1199f349288353c8a6bcfa9ffe6ff97a9952b50b953958f31d5fd8b20728b62a3293eb54e1f0d833157ffa7247fbe80f6756d0f622960a02cff3a57b1c1921f175522855814b30d6d811987fa0a4c7580fca505ef97d385cf8aa0c7d0c9bfac2c780e05d5da9f1a6865aa9878e3292057ac8a8de350dc1c003522dde47326c980a5791ef0d26449d92e2d4b7a6cb40c7dd816459be758e2de00a11fd274dfbc28e56cf785ee2d56382e41b6149a459d1a7d778cca889e1cae902fdbdfa98e69fcc8e28533cf235a265d1381fdb1c2e272df17493407c6ebabe382390d65833259a49e00172d8545f7902242ca8cbfcf1d15a390471d3efb341cb020871a707e2f88a8901b9adc497b11f9ea56cf2b3f1613df98ee2661705031e3d07128442937bc077fc7d782d0f134395d1b924adf6324a3710e882db50b9bee5591a82f6959fd0f90c506fbc5dcc122a52b700ce6b28ccddfb1afbbfbb011bcab4b7a47563e5d9393b777d46e6fd33f91c439d10db6401c4182598d4199ea4de157d7cda4d045d37c4fd22cb69f2bfa58937228c749351ea167986141b9ca1a3c7d4c4edd4c98101eaa84ab1f28e4095bd13b557cbfbcf25907205750decad93ae9d3bcfb259025032289720cfedcc57d980c572fc8ec6396c79102533c568011d2109f431dfa70d1b3d071a69da8cf02ca47876473fdbc0f87f7dd15783b2ff10b0ac759c3360a8175747a8f55d36c2738e96364ad8c086811b12d9bdce60f1355b4c481f6c954ab13a0e2a26fcfb4ed2f0567e8d259c69b5f7567c47f0296160ea416e2762ada4722804783f25363c1adf844429f672b29e9b6b669122614cd0a305426eb00cd490d61f6333e1020c3e3b809cd0e518d4385ca2be433f3ca34802506b9e7fc76ad864e00943e876ca53c7eb448487d3c87a44d977f38e0121f205736718c328e6a8c54d6919e85bd80bcd858492bb0e0ed4ca005b35cfd4f558210af428ea9e03db397e4e85445809642af2f6f0d4a27935d97f134b18be008f29ef73f2549fcf84ea33482ccd24f1dff3a76eaa128d294b7d791faa4d80e6cd6c85846c3a1cde0bb0b5668780ba7b39ce92b0e45f9dbe70e23b072dba0d746749ad6543ca11907e176cce5263265bd93acaef2d3805605b7ffd2766ca1719433615f8a44ee2be4eae48cea3967f47c9f1da6255cd7b1dcabdb89f7f3b9c64ccdb66ff54d7f0e3164d39ca568dda796685e8355b37b28825cbcf238f86a83b8e3aae6b43745f97da4c236356754f458da36cae05dc62fc9ce9c8cea1992eea9c9b49ac93df029d28f5dfb1ef0e7989e83a6c8d1b04d2284445e58316cf57771d22edbda38bf064299f2d5eb91445be9f8ad4f06f005fd40da0a7f87d5d79a27c0b4296de9a82ff2bdd3c82ac02848483f5091d4f1a65ca0353da332e17c271ff1828af8adef94f62a12dbf148e947a8397f7667f78c1315c6a3a1027380706642e0008bcb1f7ed324a7e879fbf0b92cb24b83858f6039e412c5d5c2cf6bc33b0ba0d16f6533665717d687a5559b19bc685c1ad6de6e9b532793db5220334299501a3342a7df3bb106c8ed8b412f9ed80eda7aadc3812815fa9af5cc1f2cb6908436fbb56648efafee48c57d5b9928de49f0cbf619136d9554b67d340dfc40994d08f732bced14af74f2a932fde2d9d74c7a30350cde1b646fed8af3917c989167c8095915533fcc82121017a7378625a1ae388cc2987593f3fd4da5c978c64546696b8fe395c23a3070371441dfbd9ab252977175994269ee46a6b393f053cdc98cc4af0e28273833cbf86ea8945b426dac55a53007f7ff895be7e7f31c540cd95217e922cc2bef9fc50de9213ade2ce098a5893661f5111024a8a5765d1c154b7c814f42a0d411fba4333015eed2b594788ed2d8497d6eb47d180ba95847c817db49475a239afa51250f7ce6bc0ed2b3a8568dc3521b3c1b3b68efb9090ac66efb2b4c4d7c302bc08f5773a47f630c4e65ad1dfe93aacd54956b626ecc829b0b03cdf1d57c4c049d0deffa09cec8f68b8961442de04c2c09835af55b94c0d2aea438369e3dd0eaf679de6e2ffa0a04eb30b9f1d8a9cc773d1dec3e0b08a51cdad17bb368d980b22cded67cdb27b3b415876ca4786a6b29ebc98a62a5c8e036a40a46d52785d21cba3d4cede178e49eda942ad03ea16f3676d88d9df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
