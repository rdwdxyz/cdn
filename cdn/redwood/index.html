<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"654f795f178ce78836f770f8f9d1a2e071a1c12e7a609623681f959703a06b07bd060572355cc18ce2be4b7347a3e28f0b427db417eb3a96aae79aa219918eab7fab2977371ea2ab4a731025f84cb369c15db9ede9f2c1c76cba5a2cee4c905a2204c11d9fdf87c92f670cd4c28fe3260b60dd254cd80208ad7c352c944155c6774bf09bb59d853826ed39eb29a2d85526d7fb96760f65e9aecd3fe868263ed1cc4e74af54507ea960643fccfa52e642f6d4d7297fc7cbb6f17c65ec170eee472ed4c62d53417ebfcdfad415d6a0b4dad55890c848b67bd62d4bddfa39ae24f996604820aa3b655d93518ba390b0396532b45246496239ed767f0cef40553cf7b1ea05667333f5b1f70c30afedc96d67a4ad485b6f742d790bb4581bad76709bf1d3b009ac54a1030e1bbf4bc7ba0e9353cc3f270e13ce1100e667bd74946f6aa3fd8bd1785d9e7f267c5371d09a18d2e7fc9941e42d0b24503ca7b44e89849944ce58c393a3813f46a6d2adf87c9d73c792b80f4655462d88c69eb60f3d79fc431ac3d61c38c45e69bd6ce90940f20f42130165c0ac98cb473c3faaecc04aa7be030ae5f70f4e83f63f23ee2698642249ca036807e5b2e95b9b72bcd2bc75d0743c0f25b2b858bf12d7dc212b4ef435f680df73f854ab6a262b5339189451d42b3c187c638444d23bfe5bf71a3eb07a16e1866d20a4aae14d96b288401be5906dedb42899366104b87f2419ed5604f425f434d5e5053ca2c9698ec367ef705d2db5d14f327cb842cf5a057b02c7cf94c4e0724928761c70e891f9770db59559976b3f9315a89402b9e25f2eccc01583f0bda8c794435c6ca6850f363c3da20bd1542a3cb28521f82b31a7106ad15515c9e8d77a600b000faa8bde5a7d979d4bcab33fd31e498c2e5126ae8233a11bab68854b5d6b672f32f186ddb60335b7f42d38b912c03a2c232d8b8415464beb8037977e7c977b6cd52caa5f14a6ab27ab8cd13d190622c44d989ac014786da21f6f73fbc3a2d85e3d0589c79950509d7628c873ab4e99fd8db3019eae1fdff18fafe2bbdda61d05da8e6f13e0a60788d661703b15aa0edc9812a56aa7c9b66a0ef8fa9ee9b7b84bd60690f0d3eea87fa35063c389259241cc7aa0303d44374399f7ee7abfc4c6104f22a02ca6ee061fcc2c912e48246b89257ce8c45062d7d15e4ea876458be0d8e8a567698f36905c8f6135bf99f8c7ec40d3df7857e8bbd142639133da946cf1980e3798971e5dd01188e4cc0cda8ef806d430651c3fbcdb42d47d31602bc400fa40a1d99bcf69e147a84cf4c60a39ccfd73ddad0a27ee5603825351488ce315d079d61efbcbe8c141cedb202fce2dfb799b6ab21255b2564d9cfb0978747e433e46b7d16a390ecfb6a034d26c433cf8bafab9430a099a4e5ba4cf5562394e62c47af3d7dee4ef42dc5411ba36ddddb8a57b61756b2b950e4619e79c3fbf986a09417f2f52c68c29ce2cd91556b40499ff853f9b4bbc00efa5982f23a1e9e712cf7fe5d4b9ae24e7f94a7818c505545a6efd35459fb083b746afc5f7e8a5f406bd05ebb17ae14557e594474dc3b187292f0860c4a6461f816a401ed9d06dd1451424e2560fb19477b8afbf9231616644acabbc8b238bb7fd63db942a38582d54ddc57dd4e63db035f5fbde445e4deb316a16a46aca42faca28d72e81fdb4a4390e3dbc4ad1f69bb572e9ce42541e88519bfc5e127a0a3c4ef0d1809a5230be5f3959d2720e9a52fe32162bd157ead68cd6f679fe079ac7586228b859925a40ef111ce15b90907f1d059b898036d227a732fb377e9329b4c84957abf938636d72a562de4b6771b69b71a76d35e1d838f3eec92c60101e2f78fe8dd522aa9e40bf76d2e7f3492704b14ef82f9ac9b7762065b8beccc22bd8771e4a95f1dbcec9a39725c15eddcea6fef26deff17def4d5d58fe2af33fcbd8b94c67e07145c10f125be2f4c1fab7b37ad3f767ea1cd1603c29f334a1fb4df35d18956df57fc1fdb4aba9f21b804c7752b9bf8bf0a1abca656b2a0fe52e034e6b241966ef66afe184e7764557ee6b2fcfe6970f6fe1b0049ccb90e4be3977085302acc780e57b010c2c2f18a8fc1db3cf27d9c9f16c5937d1a4cf3309bd11876fa8f9a5e7387e392f2d5da5edf1b9b270057c9f4de10604a16a3c092bf898276ed4adbcac2c4b133615d1696d29c968df1331ea5782505bd46eb46cbecc247f4966115310181593e302104a33789bb993b07df2e55d55626029498012926553214d6f5d2d136b52041904641d31c00c417f18cda6b88908e80d58c4a369340b99ec85feed59aa0bc75fbf531f2f5227eab96a494c37fc69bb1e3c8e80de03f3aca6737bd133616a75ff9891485cebddd118991273f0aeababe926effe69d3b1ef268d869aa89b22e7b83954cd42a136d356005153de8fbc7da26955dbad3441fbdda32a051a2146c53de20a09b483de29c0e7615ecd868f47587445462b72cb487a7e723bd962d7670f25dc72f503ebaa02e5f6ae09e63c47e9c90b499da3ff313ef746d7054cb535d3501dcdf7561f7a4dfb3d5d3ba7fc41b378b5bdaa65ddb9760241d73df00f19e506dafe27ebde83231e2a15eb2fc501c039a3e386e4fd23b2f4b6cda190925c09e4cb4599503420cb7815e6117cf4cb2b3892c0f1e0b3f83715ce22a688b82546966d10f58c6c8cc0636850deea4a0357ea1190b923018d8741f74c9cac04b5614bd55370764dbc7959a12a39250f5f42017f98f64e4010872de1321a9846d0d20093555028fc0e02f1ba61c4d839453f7ff34e3f1e71d4b40904491193336e103285bd096d425bbe5214c79b556da038e4bef8dbd6de3b57d14f64e4d98763e8feeb45b57f241ceba6e773c66b61939697e7f40af1b56a59b2122365b52e7aaafc81447520b480007f020a1fbf84d4adbd8e05fcd9eef649f07807c1940ae078fce1387be506c4ae9d155e66f2016878d775ba08fba996694ad2c2454ca0f4d47aa4c755eab782b956731570dcc058c316a787209436a046b1b2297c1ed0b345341e368508409496e1bbbeef0d662a8e1444b25cbb76a1415a2a13238752ee65f5dce97e742d6c290ac9a8c4ad313fcd261831db67ab54d70c01919c96fc21acb3c39792a222972efd1a46a1cdef8de243db133c436f5519bd804e9e2f1e57b0384bdc1114c4b8f3a999e127c32fd80447d4b89621c484308e2b0070228c029468f096d9b6a8390d7612ee759e1fc705c657852b59c68aa476b0abd762d2031ebfc70c0aad0f89a7a565f2ba9dc6b33dca17fffbbe8cd655ded688b939bb4e38cc63c066be009f873891efc87c544d1630708bcdbed8ec36fd014719ed887b37e1e26f2b9e81fac204dda2efad61fddb16fe21441a94ff9fd132eb15acadba32947f94f17ace2de8c696ef25b01c1c7aee3f23caafbff8660970a7ac35c5aff659272fd65826e563dcc1730abfdb4650e3d1a54d3a42a72b592d6368faed002891f52aaa98c9c6aa232ce39984e70964fa2c5d755f0aab1df18af3381caa0e6653afdc2bfc49eb8945b76932bb2092c86e19c093dec7d7825b4f10f33ebc276588de57e637d1d6e177231d7f15463b9a48d9fb210dcead228e2437c8090f7585453794dd4ce3add127d14a2bbb6e83a13315d4b988f4f2cf47e3dcb53bc4038e983643dab1ea40556c1b80384a9c70cd902b906dc76eda3e607b47e35490e8413f2c7a08ae09d661cfcce5e9b3bf443d4a4a0ae81344f5781069a122424ca1a4bce0f37d703f132aa2f2142fc67d1f63d73381dc3b174e80fadaa1126efb0dc84cfa8562aac8ac0ca6f54160069697dd325ac1829df5f16341e1b6e602457f07de637684e8fe6888892108c4aa51499ba66e0b8ccdf9ea87eb2ae4b54c18b1a32bd6d16df5f5631e7686b2990bd9d3eacdb3165c577e92c5f2140a20e08cc0f5e37a6dbca1caa10414339c5840ea0baa5e20eb51e780036113d86351ae3735d9463c2c72f58d1cbf8dd0d9b64faf15f2acb3defdcb318844bbb1792907498e257a13f60b95ce1ad6cb9b8cfe7953aee61d1194f5a4326b88a3bef7bae70d7df952615e971c19ab6904afa96f92b37ac24b84eb1358ab36160e3e8f5d8133dbed00421d28c8d9007becfd6aeececebe41ac0f9e32162ec3c206eeba741f785edc503fafd30dcc4a62bf1e643de76665a7e64f1ce52b8796a0889e90c4bf4d7522e15aeec6670dc1a04a28c837b75634dfe674a9c5821871d3ca979a4efde92a0253f373780e392b59e515ab215b1f3a756dbd309451662902dd3977bc8a48bd75d6c75bba838bf3a92b5e27cfc45486df63b2536b6a16a3e5d737f149aca1784791f91adfca11f39d8275615d9c958e0f8209cc637f76e035686e683666108d867fb79de852a1b8ce4a71a612698e01c3960701338fb698856874f97ac1b06fa51e6f599e863e5efedde16d756ee15bf094c22089fa81c074284c268de3e77e258976d8ed7c40463c615fed6234b08991ab32a6596c584d5b0bd247a1e2386a1d129846fc80c081749ddf2772728580380e30cc980c8caeb5f82dd2b494ccd8e5026857735310acd5df7274bf517f74ed9bae947bf86029e8b4b4f59e8df0f93803b576c35042a71ac1131aaeccd3b9528e3f23c5058468b7679504594464d12fe2a9b9722e9d76169a2f256551688a651e5827923a11bed1cdbc57a0f2ede3227a97c16c633f16c441a23d06d634583cce726cea49c935702ea085163f630c00f2170b5a0b1b4f34c590c217e3cee9aad9ade53d954d69ee61cddf01f29630cc97c1898447f43f93943b1b997bdbb5109cce1080eb05f6a196639783e1fc4b4d0ed8d39e9deadfa9562399d31b53afbe8c5314b7abb765d27e339c1e5003706e2c7b3257fe8cf171eef7896a171bba3b876317ab277a1cb9f41f90153ac69f74007758bf3c5a19ba02ae14e4c29beab23934af60ef2b3c0f9067a8310c24489c853f8720cc226264cc0ea50d423bb5fe21ce342c9692460f42058534541ef4f2dcdcd19269a92b44a02f508fb825e7c781981e5778171f463de1b84a622ceb4eed185ae020a5843c7e3c3715385215f151b2b26476233d4af7a9bcf96322a01ed8ba5298196de52e7ea4c3d7e2d9e81c2297c3481c7ce39087f21e4059e3d0015e509f93038d8733925a0fd35353068d6dde5699c5dc0b07cb2c7973ff30b36e95a362f50ae87569565a67dc8b16b200433e2aa2d45f732c65e475707766dc3323e40d8e0a3c8a0a6c9f24d8565e336c53c09ecc1a8e9b051313488272ce0b9409e4097573831ab1c5282de30f85d011775272f358eec2a3c03aab07a6cf0693b9b969550867a2c73c1d8239cadcfdc514736a59f29471e86bfe16d59c221882af1aa2ab2bf80ee32c8a3c646854200e64e1c864624f6c434a9c97d51ea8cf374a22937b16c32b1101d93916b3891b766e17b9449f47c92258dd7a99c3843eed2b616139ae8764d0a31fedec70c311f7bd306be72bd7ffe1bf2b0dc936f845d5f3d06e038f7862f0f24c5bdb75e7b02b7055501c8858b56dd278c70366eb722772a23fac006ee48d8b08423bd9e38385e83a7fda035210521399a9dc696b9893a474ba6818f8030e620c556c9ea1faad2d09dab6f9fde94dff01dfed2e59532f3fb89cae7e428192c591c6ddb54835f501f298d30ed5d55f28930c2313138e1ec4d2f7c3d69498b1a26849df107458d1758f648987bd666b1904e27131ddfd9a5c7e2ae1d8766d1943a4ffb5025210ebd3b98a3b4e93036fb586921c5c198056335865dd3a574fa2851dc4768e1227c8dbeb57e8bfb082a1c1654fba4bb04114d75059c4769471e6077b867ab98f39462f9252884e8e1bd6909f5d1f2f65895e1b90a4e9585e67f2926df4443c16c6b8559d0be65897f1068b364e763b890cac3270ae8fccc9a9cb50aafe7842e3e721c794b42b278f189f89d475e1c76bda236678c6b2404f507baf2d0712f3c10984bacaeaf7ad547d8b5618cd952ab7b8cac62b644cdc074e34dc65f45b68f3383b2377aa1a93bf5ddb13780d2ab49c92935ddc17aa4defe5f04d3f964d18be63eb70d399c2ea76899ebe051712a915f4a9ed0e59b912cf768913f156cdfa417f556bfb0079d54f53944e43d4341f4505dd0a91b7936c5ee5c55d4578ba614f226143bef2f333b0dd3808eb86d16cd411fc93a1d98f20fbd7931c5a7a396d66574972484b05633e17c38c8cac4dbcd4f86f7c65c39d43fffc76ba633635abd55ca6de2e4b32bf6aaabc96c870981c0bc219fbad23f822e98af7542702680978d34148de5af35edab328b89f9dfb3b02ec5d9708219ee86ed30c7cc1f0a035f9017cdb40adf79afda08a967b4c696a951b79196104d68673e7a7a41c74504f71ae4cb33f898fed37fc5d5172230a207c7a56767fca47a8a6eea13d32481b4503c45e33361ead5e5387912d7cc9f55a92717336e0b53620ba8833d4fa034e74d5fd72c6fe26b031cd5188bfb70b12960c2800cf8946a9a4b4338c37fc22291e4b2e26cc2242615de424acc3fc3a0ef7af89394343557a8e0e13ba3920bd606da70737f2cf8aa5e97d355aeacbd782b9331fc99289c04b42d657d59b2678d7bca79117426644dfd0989041302e4f5189fa94aa0fad5a19448b5f9f3e9331e64b905cd266421817c3064f0a52c9b73b9f545930bac3f6fbc89b9c75513633ac58a475c7a907bf5b02109b248880dc6d0bc25891dba666b9257b16b470f4cc322c02fa71ae3a5cc3e7b4aa0f628db0fd8df840cb207b2e27635f7a2bf5145c85d4de4c64cd91f3affca36db866ef06ac66180406619dd9ea2436cfba1954b3889ae5a34bc2dc905f2a67c254a0ec17fbf14d63205d821d85173d4b3cbb07d2366a3428478e29eb095bbc28a2850acbff830a45a097f33f4151a2ad73998e16b80a23b110523dbd762fdb9d8586c9b2caee49b3b3262604a5adfa0cd5fe83aba4b628e6fae6e14cb7a396a6ad70b6f3c2bbff22e661029c53a527a6f3035aa137bc80873695e770560c83289d0fa5ca755d23f505234d11c165df6bfced2765279dd806a3e258d47732faf4cdd01537c090f6f5758a829c8641dee6a6ca0dd3a65839e246f5555f19000ac0d6be03fd79cc8d15115a05ab00a480ccff9444478cb8f19ed4fc6e9786df3476cc56c9988e0a1eba817b40843a8da6e624640376a5520e257abbd2707419692bedd1018e17fc0660321bdc65952603fb240a7eeb10b5cee54b0f110ba372bd44fb6040e65c62540cdeb3e9dbc49b2cd491bff99f5c241f8bdfce21d5299d91e2e2409c4bab9d155c6db43321a69d4013164972cc74bdf36b964957e0ee47b8c718f9376c2d36162545ae1e0f8a2f0c4be5374a400ae9e4b8e7e23666db9159f24c09ff1da2bf6414fba879c7d492b2411bf29838619fa97aadd2d206a2942c7407cc4d22329beaddf848747e79da1b29d25d835b0ca4f2328a466a868d9ae53a8d2c0d7831f457a13bff673100243399a58e609260e1eb92c025aef3a51fee445679bb0ef21a22b441cbb7cddc2a7f139b41e8f7abaea39c98fc44c15a7a0b26f713b7bfb40ae3351ade6a7868e2c5b70100431870d482e2d8ab6b36aaf595facb127c84843886fb64c0ee9f93fb8684e0c5f2494c31c5b8c535292501ff7e3eb684271bcc52bde1d64d9e805c7c550392ac31f990b5bd9700bcc3ae76cfb7576de5b56f8c7ee9ac1fc5a42c038951ad7fecb2488d450335755b33179b7607ff7c8e9c59850e8cfe976e77416a0d7b2c68184234eeda1800f674b9a7676320e77fbc81d21ec0db7b1e07bc886a2467ca4bffea4b6dee48a6da0534b827b51d447953ecb2e26b04094373f2fea385150d8bf67a4fb06069085826bebdafbcbac6c6929c9dcce3df9f0b9e5fd7236371ae77974ddcce581681654d51af15404d8da0e6d4ed07eec546a8eb2c17a36c9f5cd376274bca3213259147ca3400224e7d0e04e44137d97439c7a66d0b45e9b8d89f5db27e8182d95eddbe3524df6df8b51782a923b6976d707985defbe74be3bccf8d0ad2655c36ad03c230e2249afb1e8b69f0d3358c2d0e5a47e7665abd13484f007fdbf2b8f8b88a81e75e4e00bffee5349c7a2b4da96052dcbadc1d957f70530c85c6e4772f43d127ae05dc2d7057081e212142ddaaacafd361a1736feeab7d4c432daa0a49077d35718a3892326ab5ca8ae9611769399bd5b66d9c3c77ed5acc57c9f310d4072f60da93eba320e34ec8b2bd00d6b3e954bb5029a7bd56ccc2ad578b20a6edc4b689d4943543a04bc49272110ebc0cfca2820d32a52e4b901c0fd88e0239ad1270785c040995e2e76f28894c68c1ba40ae4579ff0fa22c8802eb23ece071b6b7a086b216758f0989079da5a225d08a511a0719b863143464e2baeef51ec0b57ccbc8fd915559223c9ce3b394a4950cd44267275275fe43ac84bc01225fe741c8a38e67efecbf6b1d6d434ba4a17c55d2925f45094c4d2d1c7e3f354c63973f3124e46fbc1c4b914fbe32c68ee9c44454ae19abd436d80604c1d7883ede1340727f9de4fd629cbe2bc244528773ba243082323f9e1fb49d0762af6d8c81580394b58401a4207b6e7d0c874c8c6d6d9002fc7a524d19cfd938cd90cde6927873483b1ca8f8b698a1d7fa9359b7f356a1d292a77e0fbd13f3ee08b367ef289b115cd0311f76ab79256ee965746923f1d2b98c4806da3e3151fb1212f42a73274fafbe9612a54f07533aae82174cd3229b4f86083a5625586a1fed89f5e22d8d371fbe08f8a5d8c33db91572338eddd4056a57e0a16a15958dafe3fe9652ddd73fa88a817f604b4a9c9acadd681a8187c185aa5587dafaec2628be22c94e3c466061f5234f7cc823e4a59b15de9f9499ba8ce51c56896ea173758a1181cf339dd47427cce4d7a517ea311e2de37533788e890a2e8e35cf89edfa12c19d6b33c88d87315aded709adb1bddeeae28e1bb8a3647e814147919e12642fcca2540d80bd87aceeaee9a3ce488506a14ee0c60d0fdb5f0f5265575fba5eaa1b951f06da1a95e4d900f5532fb687506341108719c0ee8bcab538bbdc6c4abfff9133dd9c4a9dec8cba895185e3d1d1be5fb5e3e60f92ec1b69317aa6d407e2a08a49d089276fc671086fe0aac596a261bd16fe26c8138b1064b8506a0395403b91ed1f50b84dc5332dc9d2f57f3f9f2a688531a8425c5bf954441bc88ace7a8a5f98f8ea1c33e4835b2544898530c8f91334af7d5d719c80b62c167b366db30ed5f04b24475f14052556865b7a8556e77e2773982675890e081239fa2b7820ec502b1bcafc4d0198ec91c7259fc2d75b124615911a41e2d5eb2ac470fffbb1f1acb3c05874a21a27d0fd1e82b0883cb4992e5e79598c3a7f6f29c95bb94f89c22aedbcd1869e0c3ef33659379150a15b6d0d232c19c50d61f34234ff55fb00c7cf9fdead8c1308c090680841c959b3215605ddb508a85584346e435888564e397a243e666da36e6f7cc12124a2c91cfbac9078a6024d743e8fd0d8d4838c1103a14c2925f04195f039cb46928586651fa1287675a1db0385fad3299fc0ab334f82b1eeb184bc70410c565ac48a0a8cb85c9d812ddf91da34fc41cd8605195664a0a3fc8fb5482cee39dbea80ad0ee91d560d2e1db632ba11594a866d84ff3ab036581b8dad0d8cb070646c7cf92ffc81a935d6542eedee255317dfb802fa25203846458d852e3b2b42a0b342a3d4184c4f8b61874403529b28572cd57fcca5720640f06e2c801d0bdf8ed948e8f3522b033a95e18af4579906416134fcb7e24dafcd0b66975fcd87761a5343dbdb481ea1d6cd620ca4904166ac158a013e67a5c435c4036d2bf8ec1f4f29dc6244f15cabeea8b96218f74c31c29377de37cee8c8e3245c9b9ffeae297d1123f880827ac8656817a6255e3c8b537c11eb4e4b15d3b73ce84d8a1ed0a6f77a0dc347228669d67b305fb7d5ff9b72387094ad3359a0bff1e9e7cba3a4dd1fd3998f0f59670c43b151c82cba1341bb934c99ac2173fc847a63c0bffd600104cbf4420ef8e670a877690d06fd82a0dee44a9a1f841bd604dd7c60aed2147bbfe37d64551f66b0f444b36d6e2f2a70c15f9c3527178afeb0f0039271152f67e8a4a60458655fe57712e4804c8a3fc0c09095c0754c5c4314596f74f5ba309ae5ac0072e58b812cea7761850382fc383c84274a2edb16773874989746b19195fbe42d1c9b71f756695cd22765868da3a80726fec1672b41ba480633c51bd8958717a88c95a745ee61d47e6248e19e360b39fad8f3d034c6f3a6142a670c19fc642a772a80d1738e86e2ae9e25fdc0a51b37a2d2ae8314dc0c3a83b049d57e4b96658da4c20bad3fa15322e644f0f9d501d62dde2a9af1526f76f4f1d1be642f90afc23875bb08b8a2ea96d0a73a8ab4788350852300b3b45e5206ea58436a666f2793bf78f9a81a448a0ad396c09b80df898b55fe3eeafd8d52bdf4626fa5ac9bbc2c5f4479e87e1908ab69d04fe91214022d017a47d78ae9892f63f0bf9166560147c7a5ffea3e51d54877fc38221e3a7ebacfabc694325557f9ed774fae362dd7950b9b2d31069ab15cba680cc0f995aaebc5548466e30f6d54234a44858149ea6eee13972be37ea4ce9bcf7d619f6c190fff880c385026029a43072d632b984d4d87a837baacdbcc017fbbe99fad19dfe3eaec6e603b89df53256eb2d0bced49b6da441744568640e5b599a93d08a0e6ac264b238d7eab1dc32aecc25d2102e9dcd4bb6747ec65c9b2c328af1543607c972c977e5172a7d2f8f81166bcf672212bd5109b012d87bc0e6d992b6c4bf5168085961f9e269c9c5295b9a297a96f57201b3d2dc52f448aa2f6b586e15a56df5187a19f8457b1b25e92e0207256150c46cd6682c645359f2a9be502a8620eded0f9d9f973a2951cd65d8992167649c8db648b556deaa40e825cd596b7e5d3049c938e369477fbbcf2b60880efd121e7b5f92d75de434b3cbdedeff40ecbdd29bfd58685c8b6de361a0a073c5616ad782d16d10f6c8e6b5205f1ee4cc86129f91e42578b2a13cf171d9435501035b32f35470006ce66f365e6f4947d6bde723f9a31431721e4623067565717c7edb1600d9243579ec1414f9d0ce5d1c9114837480c2e6a0127bc5a67708299431d7d1ae9a379de3da4d8c1ab7d88404210b56589606577c37f748830dc571d85cffd62b9f38c31c1cf7232e7b9a294a62ca0d7959629f13dde04f4390f7dd72cbf671a5107c7fe24fd9e8c63f8307e464245a2b03278752a8a82d0855b5af0423e67745b19167d99c66b6cd0e5d7b0c3e1f11a4e521206d68ea3828e2f6a25366294215858f24e95556c20af60414d50deed2d781820eedfea408c4c8404fd7f38bdab2f4e5929185d5f6ed83fd6837813fdd9cb0687c38420f220626b73e204165b82a56935018b347f1c19ae452e8d760241a02cf38361437c924a28447b10515f703299c8e6fbf47897429fb477fff6ca3bdf061198edaa795f9a78c8a35dc044f31492c11fe9f856c5ab359438c0022abebd1ae8f37cbd7dfbe12bc1297fae615e75875194955c0595a213a780ee42d4af1c1c844bbf3e8e6966524d2c5aed23f6bd344a553336f9580294aa491fe4be027e31331a9d182064de1ea9ba46fe864b15e8ce84b1c0f0ccad3c06cf85437d158ce18a1c703b1c3a2a23ba7817a5ea5b2110358ff539b5fab95e2dc5ea666e6dd0d02e2666ec21aa63fc0c1122d6209dd6bce48fb4667d8423eac941fabedd694284b96927267a8c6acbfbe2657d4cb6f87f1b96c0927d492b1aa7ca3d2136c0f2d2b6579c465546fa287e7e9a85531d75a45cb436a509897db71055c0d04cff39f32f2d3f54a6254706e7412368c7298b4b1677c607061b5e35723ebede8f3b0b7f106ba3eb59b53fe9149fbe48819f689193403a4e3d14007e3e20423f364d6eed87fb26385338da5acd7a7a23c2833201111b4ac8348a60eb93a226dc70f5172040772b6b94b280f16beaf7e3408b70cb4034682f4261225f5180830223b7e0d316b98dbeeded0585b0352d9e481786ba07a14bf810d49582d718c089b7f9c871e79b1b8b767b9011f4ed614131834b696cf14a57e61333eba8d4c6bdc165be73a2f56e7a90fea7872eabb74cd8c2583080f4f2d2bd70efe3749dc9a1a498e7bac94305f70da1a5dedd234a080d0ab9fd87ac9fb68c3ee8fcdd3d29e428668d86abac033d9d52808afa679ad8dd42e977dad15c879fa7e848ed0b10223d66ebf3beb877f33bd9071e47779e57893c03de697906f817bd10788a8de6518ed4acbc48022dcd022a32cb8957c55223c087559972ff62472c9a9a6e7e226cd087d7c71bc96c2e3e89f71d309a0ab894978ddd47bb0ec398958aac5494a771e9baab795f1c6f8897cbcd3ee9a0654b119d22b2a08d08a48d289a617e0858da0ff615a07b5fb59c226d409e8497f653966ff0266c38575af4804e2f3bae692475352aa9ab5e6048bc0d341a833e4420b8a269bd20dd59776c50c90f1a3c266b1045ca4e4e224c5e11ad3b9a95080b10433299af226305e4825ecd0b9c5652c03507eacb4f80b34234983d5fd438940aa483124f9c3a1b9af443e294207ad323e7f03871ae5c9371b4471eb2d9f91e3378a0d2f4810dc2961408f2fb769c247b4fd263cfd65918f1c114ae862e4e3f5f72af638b813c8745dbdad12a2a86be57eb5729aa135b44f5cc0b6fdf3ddd1fc346af06e7361181f288f02b3241c24121442342894438e26fd5aa5e0fc3b2034263cd3d4f3ebcf0d3b380f4a9f26177992b2c53708c5ddaae14af6c68f07496200fe9d906ac6b8511e33438b5f7f4ece96c4a89ad0420fbfe753af3dc7380ca0459cadfb0a75fe7a1a01ff30c719b74b6dab48e9ea193fc9421edba361331b82fe044c0493be5a4b47d9cba2483782dda5d9692f7f04dfe17ad1a7cd8faa42f1d12a324551c19cb21c1c1c79e1e2657b48f9204d59089e8bd381ca9e0e0f7aa88778a61bcde26c8f4e88c17a4b2009038371c768da595cdbc313012614ef0d475393599c8a32490eff37412e5e6c49810f8dc6bb4b5a71418c8aea9d03f715c3a6324dd81b4fde77b45cab7696c962b762d97fac7a7c1f86a3c9fb93de789dbbfdeae8896d512bede0feb6dc4882a6b60f2ff2c5a4aac85b837714a7664c1302b8141bc9ad0e21390c2e64da67a8688eec9f64c7b675b53dba74f9bd3a0ebfeaef30e64e84cc2c6e5e866d4ce76b345d69a4715399719067779dee4c3d21e8a36e6cd8cb01a2a94ebb838bd4f3579ed5f41cd2aca073f83e7b9c713e4a8998e66f3050512eb4c747dca0397b3163469b82867f8629e3bd1cea1b98794531ac6733c36833e7eaf7a1d6dfc7f394afc84a46c78f9980ee3c4721d35e6728cb5f1b4660bfbbbb3d2b153a9138018221d783f51b05b250c6dac8f5d765f1f64ec4abc71f80af1152404a3b509a4afb787b5382e13e67089f8c0dd6d3d1d8fedb01438bb520acd1f76a20b909f88daa17ef3b23d53ba368d3882943b33722ba61149188c4247cca0cd838f1a6a7390ab8efb86d14da4359270cb62efbbf52131e8a53b0ca726982956037c5502b4b2fb3b16c56b2b0362369687eb2346766f896195400354e8c123a656b829ddcb4631479ef408baecc57da10876303940b4a3aa2bfcc8e836057cacb11d70fed5b0cc3de58534849e7c321c8bd19e58bf6a029d5fe2faa7c72bff4e0d487087ea7528d6b311cd4fc1e4fdba9f7e7a25658e5b310bedd05fd6acbe76f44be15bfe3f7e2eb169e6282665727b7f3eb2e96957f40f91abbbdf2e3edddb4455e4551f1442d02b9ed300f7785172e4525f0b13e30748856f5c3c157eab8617e9605b7f0024219d9f1ae764f55cce16e227eed3eb242e634f3bae3e004d974c158ce30d101082dee26311e7ea4ac755758bd065ba4111fc846998bf5761b3320eff672bdf3637d33ab08aa96edf878a85de71dcb62b5da2ca95cf9a5f0ec1819a11ca24159c5198db2513af7b81df3c2d1b69a5661180ea60564d4877e41c60cd42684e9d39d6bbcf267cff07139cdcbbd687b291e25b6bdb5b0c79828d084744807cecae2cfd83c98ae992cb75a5b88282bdef31797b2055493dc832ec95674339ae10d0a08facbdfe7adc43d42197ad9e4716dc18769b988b0cefb9cd4fdb8298cfde2fa8add43691fbf332c5ac5ea0c32ea9291b1814cfa0019055ed283c45d8b1b9d167a3de0d74d95e836d32b037608d90562a808ab1d81b6c0037166e11a8c9f1ad873e4846ac7fdfb4000a2478767339fd38043b53521c602f04c38b7ebe204bf87ebd4eb286bf210ea538f7ff9a2e07f67025d6e5a2c9c63e10ea94ce34c6d97b778d95a769a38183ad5878a406d24042044802b1e19ee91655bc3e664799aa003bc12f33c4c3d7f3e134df6f914c4b2c1bfc84870227456343b8996e611fa288794004a2332d2374de84866ff5d479d59d161418dcfa17649a619eaec1a08c1bf7e39cbce4d1a61ceaaf0160d9cc2e07ff4759b916b6eb56dde006440f1cb11418a03e1c736110dd3fb8102ea2ebc45c39d8e9fb8cbfc384b307271fe5423921e8e0ab00174b438a4bf4eaf3adaf93028f113c0df70eb0cbc862bc0aa69fcd8a2c0b0804651691515479276f9535cc79d07a1fdf8e35332f1a0ca390f234afb7c955be66fe15a21255e4901c191a36a8f4f3ddc34fbf67dc973b8c2d7b2a4b4f07dd0eac684f5d935c7e42d43e5f3c8cd87f7949be286cdd65f220d75a6365b15d9787b711f620d894e244ca4ca52b820340fa0476dace85fcc7f480df5d065e10374223b17468a582791a0337c092ca5a5248e91aed606b175481cab73a097b15d4e88190e42cefeea0a6848c86d14234307f890abd025f527e4f6a85151c2684d639c67d45cedb3ae2646c1b86393acb3d5a877886fb0f34a8537e6ecddb1dc2109b3e2be2f045103a75e5e17bac6d37a60caa9f4adadc1a0c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
