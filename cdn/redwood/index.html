<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea74516a9c3c7cc524b324a983fe87de9133bf1991432c24e549247eac63a5a95447a76c655d4ee43868d141a2527aa85d6615451ca8fcd09394134d9d180c5880dbfd0fbc9f9170e0e7805a18647d16676fe24d2fc1f8b781b5c2d4127fcd81c08b2b1647171752e55217184e8bd8c12540420f850b266a4785074d33c0e55ef9ba3ed8d506b67fd211506640c45e45aa59c91f4d4cd43a682dbfa1ddddea48305f3d92e71139961eab88b683811671f672fe1e126b33a310b8a153f174104d21cb7d403d21937b5c10bdba4eba4b36a8d50c0276740f75502a7362bf0ce45bf7c3fb2c0d9923ce397ab5412a0568dfe2edba406296dfd0f5adaff9c35c5354f9cfb205dbcdbc9b7f2ebe16a9f13e2678faa1131b695c7e11a1553f894f0be8fba08bb8b009a2f3fee29f90edfef054d194f803d1c54f2c91371889e7f01a5ae8b33caa42c6acb807c1e23b4e4c4da40c9696c8aa8d396797faad9a008a104344421b880ce51aeed80d73214d45f6834fcf7e7b643792218a2fe8c8a81d6a9a4c9e589533e76a203b903b31c6a14ff2a53c39233c7bece03abdc1a7a47461fb9b14ae21554e1333467736045dbe4f4c2a37bfde03a6ce247bee5682bdd25e707c8c219ecfe7a41e479194de19325165afc0c50748c18782b7e8cda7fc0db2f6752b8a295fe2126d7d8ca3a4f8fa8811d6d7502fc3e06c53aeb83aea6a96ad05312a52cfbac491b2f54423ca193b769d66de7fc96a3576211f08ba920e9b14146b78f49c938f7f3958766a727a9d803d567d55949b0f298b5c230a1409af18dd6c731cf19f1b444128c2f79e8fdb8ae78117894974222ab47c07366d6861351378108df7caef9e8aab52c329352fba5ee8cb6420538a952c8dc41d5f7ba578a872fbf79029e136c52770fe79cff8017bbb290dda65a442092009d9e768f7d712064b1a949e54bce9ff02da119ea4bdade89a4a88c2d6a8fa1d40667518068a7bd646cf34a543a9b845727c775730ab3ed6d66c4578e6fa9d01149e31b357e62056b19e647bafbfbad50a6588030462347c3c36c84c703add73aea0b868f94ac0eecb0bff4a935ea7e9b0ca92dfbe73cce41cc210772b619b5b57e153e892accc7790584e49781ebfe66edd1cd1480683278a781a37576e93b1f29c77410ac642b37ab63630dd429056c23256d557cba49e9558aa02386cef7df797e50d377bc5bc04683d0db40d46d523ff4ed472efce717df31969ca8eb804e8e4c91e00d95b063b2ed5c8ad45b20c6739f3285afdfda5ccb2d519a0f3e6a1054dede1423e33661192683565919ba493d0d0d963e17e8da69470fc7cc2bfe8eda3dfdd2b1dbbaa6dab73f675c2bac9d4f306508d36f94d95d3f3d7a68052b0c98b5a0b98f4db8bb03043c3cf2c4a0c31eda0b80f209572d762a8ec31ea6020d569259437c79ff2ec4f5ccb8e7b03e55edc73640684bf9dea5c63ac2688ed0af16371a19303c35d8b7427f0003245c61d231477f31c32c35f8454ac2cd46502e906f94fc7ec963a71d29343934414dd2042a0f827757dd37de752917e16069a04d4e2c01b7c47dd85f81a83781785be65062b7b33338fed89019f2c99102aa13a6a66e200952fab086902cc335547c8816b0205a25df916924440a2686fae8dd215848a5e02684307c6a6ee2723b395c9d9c57357c87819d4dd165810a42258d8b55071e7797eec17e31ec09781dbbd6d084ab4acbe8260e5f01bdd3402772fc64109013a07a462b8888b574ac523d535202ded47863253e76afd156f73677211558622b810ea9d85bd9d263694100fd01bf301a6f5649416aaa48ff0da0a15d96a3b4ccc325f28c1d2ebce7dc28eec3f2ce65810b5a7e2f4f8979a4186d9be7d0e4203e2618e9b096b3e65478b8efa19a9f79b5d752ee11f0a7cd5ad57cca68067104a2ed621aca03d1a22edd6b685b1a0655b4d582c0bd7682928ea210b646ece63b4561c5eca1ab3492725e7903bd2b1b55dffdc6b02af057c349f5e5da8c3114f4e618948deb26c00a487a181c8530b816906b26f80a7658a76254f37cd6b1abe51be3dd19bc12ceb7d3f51f36a4d5d30d3142348d08a9f965f1b4b259bc87330ca6f1ecfc33f2cc471bf22cae27658304687db530dddbd3fdcf198a48091bfc401ead6c776f6f5494ae1380eea7dfb3dedff49c724aeea8ee0768c3ec2a8a90e7f520a6f9ea71cce836169ecc9ab555cb5dc0a671d3f4f032ea1e78f6aed06d83f8e3b8feff744fd96e542eaff7bde0a11bd2b25409ee864b2bd77507a33cc420e55ce3174d5222ca3e626b40771b2795cb9ca387f5f41bbfb3626b0930d4af21dfebddc99b1d5510c6384ea0a7ab42baf1bb03b056d0369f4b1e46f0cc422ed6fdc963dec27e0c688069cc31fd4bf59d6a56b165c09be9f877ba567b6438f503839ba4ef700c57eba991ea729c8922b4fcedf418c935a127d2b89213958142882cc2cc2992db0341e54c8e4ccf3f5045c3966fdfb416beb43b0ee04f890e9545c0024ea46e26378371846752d875ccd29510f39b64b207c259fc7164600bdde35fc6560896fdb481b77eb51c81a03c3503e80b8129fc78847a93acaf8585e7de2ed56baae3eb0e9e9308222ed77821899761691be55a1326cce04f40da78ef73bf646fe782c71a4dfd15627171c58da7779fe08310fabf4e6e1fac841d3385eaf84dce0a97997598b7fcbeb7276b1ec89f210baf298801a9ce8c63177a8e2dd9b43675569b88a474e793c5377ff842572a45a81589af2d861c3b30ff7331a012f1427bd895a6cf0238f34b0f7450d4571fd471650172cf111536fd3f07a82f6616a888e29bef52f940c47a5f8751104a7087dbf956932c65dc408bae5447b6a10b1e37e509195c2b8c97b6f9c494ed841bc73261d1d5712bb571d91a3b3ca7914528a41976358b6aaaf53b39d303efc3f4e1ca98469fa0f62e02e9c525b6f65017ce53a301a391f3c4e44e55481d1b616100178d5354860de2c57c48b0f13799373fccb452eee23c92e46ab394697a9f124b0eead347a0046741757037ea93e3a3a054a5bbddf1c3bac1ef05a3eb6cfb76d175c1f65cea8e46184f1904ff4f545a274d334c59dccc9207d00532c66a7b5e7fb78036c224bb9a6b192fcecd2c0cc13df94cd0401aa2b652813181690e06c70b3ae04189f70d8095d9398acc6eebeb499c383e4be3a1048181d4e12be7c6b74f2cbb6d380782d666dfeb6092669c22e670f521ceb78c4d38bec207195dbaed7b8382ae3ccb46b926cb4198ac8d34ad6ca7305cde87f02a1cda38e0bda449a5ca6d405d571ad6b634927fe650a2736bb4d16369a1810f4673def3407b0fb61ed22bb69934580951027a5a79e86993d12884bb189386f3809648c6a9e9f9386a0c0755eb2d5019c549c2308f1a656186e53cc7eef9d8baf8fb4a3c19a91b4a1078fe74b780a7abd0d58a4f83813798964ad5d12c5c2bb9ad19c0ac1464aac4a2c57054f2a0470117574ab9fecd92c918f289ea4ab2d76b308c7499d348cdc9ab9f7c8d5267d02a6bef1ec2fb116e5302cb899340225549a35e8d3a6f0a60da37b1056ddf9cd86cf252dfd0af1ff26599fd2d7e8a985e7d9d243fc0bff4c6070cbc3d17b712dfb3a0f28ef84349c70a2fd4c7a82fbacf2cf4750c38b805887ea42cc73879a1a7c57d13e6f4a2ef9760ea063f64ce051be955914b617f4f6b400433c7ea9444929781eadabd986d1635dcf04529bc78951f2abadca581a578460ebb81bcaba56ae6721730f9dbfbfb080ec5086004845e98b18672ebb9f1e8d2d957f582ef072140d36b8cffb43f6cd062e7983c1f4957bb4e3927c187d6b43e943542e4078a1623b24b7516955252c6441edf5697d29ca251f21f9bbc64cee5e2bed99e14697f1a0b09ed2b9288da8f8ebb8a3f548540cb7d2d68090aa724ca385832bee95a18c70e70bce625b11f0fc76dfc1c0bd41410e2726379e6bcc0040307ae2d08be364379d46e5fb1827e089d13fbf63db0fcb07baedf12e9040d2d34dbfcad7e99ecd2c034589b6d01b5c441249b7f2b3a3408ccbb9bfc3ef7f4b6582e63587f1e486d67d97effade352ddf9b5cccb788c386b25e7faf49431ca674ce52e5d9d488d28ca0034b9995ff9193da9e88ef1573862aaecb728ef3914be487db52cd1c1479788b14f1fc8c2786e655a5492255288f584be8a917924714978bb97ce8363009f4a83b6b6b83d18712477fdd6a98d6518a55aba7525238eedd18dddaaa2ffcd4df349ef0ce912b1aa8edb01a5d7f42889f1e783f36934d2e4dbf60f27126864f21fa688a4f202e80f69e62367f7dccc2f33766fcb908288d9bec3e68b6e6f91cac7eadab7da25ed6228eea23713bac8c2a37b7e4be9f16076e55ffb04fb9a99182482c0d9cc5cfa6afac7e277972a341df279ab385b6a40d61370ddf54ca9971327afa70291f95d1691479026bb3355fa1085f274413fb419d0b0b0e73c763488a04ba8350929bde2b0871657c83d73f0999c6e82895530e0081ff44b667e35c549e3c586de13120ff9d3254cdd6b5440bdae63aa9b4a32462a2bc7bc8a61066687c2db11f9276cd1644beb668fcd917da5f031ab2871efdbace70624bdacf6b4b7e753ed8db55668b8a50db7eac73e1b5ad38c31f0d81b0c7aa4ea07171bc149f4c99d594d8e2fdfb35a61cf5eb8a9800674a52bb17ae1583e8468b934ff5f10c93b6575ca4a817970800868484414493a621837b80172bd9a73e59e77f16fe14165ac57fcedf535dd9402f58c21bd029a8a3c51a5c777d525470f962baef109544c6e6558cf2d195b45759453e245ca4637145f273e189feac380842b460fce7674cb871cda9b61d093e4bd907af0bb1a33a3195c891a3fc67b11e1388014b9db48a110a38b67bc212eb8aaf395ad0e31f6cdc811f078832e6c3089bffa5ececea905f43af07089074e32dbeb0c20895d299f0a6884431b359532f0669531c059e83111801bd7848785ee26d36eb99e92c2cfdb913872851f5174fa703c2f5a5b05573e714a80e0a2bbdc8fd76ef74700a3666ef23a71d092bcef680bdc42c50f3f796c573eb0b3677e1ba640c24f2c35724146c7363809e79c6194a50dced11ad41e53032404682ae3677e0cc628ee967a12a593ace82a0ff4c34fb540b5345a84e664aaa47864e6dfea6159ef9ab2dc722823fb15e2bc8e392f4ea05fcf34c24e0bbccd9c1cd5148753521889269bec3eabf746e92614b0daf1b0c25d38df7a063dc2cc95b3c57cd1b2ec697934a7e53d7e1d8a5dc2294a83ce42a81ee44d3e1e0a83db643fdc47321ece0af66d8ccb9bb7bf9aff2022612cf3db1e67609d9cd3868e699730751d57d50427752d6450ccd22d55f1be1cfd45e81408c98b1ab023e9701ef70cac2026b6c4eccdca34c2df023893ca9cea02a79a94960661db61908d15f236e068fddf9f4a793b206b9018c189e72315ec20d618a2b4c9f331e71455c414c97526f5de0b27952d0cef5da51dd14247e7975ce1578f081f7b2223d6da08ab24067910ea0039d8838452adaffdcb2ca6709d86a50daa44951a817254e7b3326a808ed2ae4135a3dbc74cd6e463d7a31d48c847eb6d7c0d1de54ea8c66ea02237b52f049f8c4b3f282a3656055be5fac6e07402a1237c917f8629130ba1756e107c24e0722074409346782b3fe0bbb569bebd497fd7a732122dedf947076d404293b19a279121fef0894ea1cc26d07990f9a9a651a4bc6031a6e2451f505f674c93768661126fc8c24b5c62110ce481bff75afe77cbc1cbb42159e1c16435fc3163079b8c5e178d01ef7fe58bc4c725144aeaf9aa3f5091d7b762f9fa2b50c4d746f1a5a84e713fea6a4ca444977fd2785b0dd2db655433efc1876f6ca7d28050a5874de98ade5c966381f3898000c098531f8952d9efe4526f624cf416f561f866aa4700b0d18b0d0e41bcc88bea7e4c6478ee2b9d109832d5d34db66f9736fcef1f84d67fedffc62725401edfcfee73b4728e2884ab910777d6c27901832374db376680d9244a6a63f9a4bdef74c5fbfd9c9cdaca01e79222df90394a131cab809c1a9421fffeb0327774f8ea58e19b92807c80b4f41fb5fe9852c520dc7d68bfc6a0ee1bafd82d4ab763c98351323820da6ea9e713a46094c8f054b32328939c7ec9153e3ac91386f85c73d24bb403dae49acf82d4092e59a3d854106030ec5091e9d514df8015aa5a2d6e08f6e937c48e15ad7e48249032521db3497853e7b1f4814d4bd6c7188521df02ff60d9cd59bd33a94eacba2023d6bda4daeb89e3235ff73ec6e432a6bc5f02efd7a6c622badb9502ce020f8b4824596fa19687e57757b80a64659259eb728492b06e8427f13334724e2626f221646b8fae25cbb34c4168bda8704bb75d65b03b5cfbb80bd57bad7cd65394aca40ce84ce234df38c2bef8e7257b9c23204f462c0c42dcedf702fb7259df4cbbb19a3b60991fb589b7be3b2931daeca201a43add38ae7b17258d030dc33365c145a207c1ab42674e3157de8f14ace42559b56865a28e0738fcd8d5184af49b0247e932544e43f0755e3df5a04ef516ff0c5dcdd5fbb4e7232f8c860ec9fd82db666d2fd27993f8c0cd277b2a2fec0a4b48623fd28b956ee34d0616335d85f2fc20b94a31b1222ed9b5bcb7385f0c6b1ba808c5de2da89146f3a2673da539d5964cf5ee6a9907771e8183ce2ae112afe846365891aa6d3ce748abd6f5715a6c3251c370ec0c0e71c23a1fb6888b9eede9b9307550382b313e382fc127e343b451ad8f21ad580d67f3c9964a45f2ec46f9e2e006d8acdb5b018d1a1b671405a810917e535b0726af65f5e0ec0d8c27c67dc6edc36df4c73495b2ef7af2796f986cccfd125322bae5f261632fcc0f037966fdcd6316c99f3e9cf18fa62fbbeaf59de9cc000c5e468415cf3fc6f319ab24d0f8f1e24b507551c99e65a0d0ace9a3ed1e22a167db5e56e85cfcd56f39a76ba8f0f6917da3fd5b6d12feeaa2cd985f077f0687137039c7a269ed8ae6e0c7210a728a31c6417f803db9b2d81fbcbdf7fbe17f30251830c3ad2f528eaa093f789bdbdb168ae231797d8be6ac1aaff029ee6cb1a5fe9d793b9440645638edf9806eb019e1af1e261c179efca6b9a876d5f141a2328ae2d66d2707896d3ece1a3bc750132ab8e0565ec9942ffabf2c0c70c4e16e815fc2a6b7fe90cb3b1039dbcb05bd458c227670bf3736a40f86bb698e4a392cd1bb92708a664769a70052c5085af71e4973625eb9c046110b75ec101eb8b1242210e5e4cf063dc2dce35384e7f300d5f081f9b87943ae5ba06af08f042772922c23558cb84bea52ff0d6185e8bee78c6f3114c771d33f9e4b823f883d6b68c7b99f9558c4c2877c60d0eaba4a8b71fbabd9b04708d1f43728c361bdda26a33704d381a9bbcffcf97bf643290c459e15bc6905fadf6997e07ab53935231d6ac227a94117db50ff93ccfe3ca02669d8cee95ded47a877705bd14a747a775dce4faa4432006a1856c745d49a44d5f33f58b656c4cf213bbf4bd5d2b854c95ef85860ddada1b57f9c32d387919bb9a9fb6a71443e14056101297ff3dc591e781ca962da10787795041cef692a5c0ba3f484bf612ffc97c2bec674928bd744241b2333fe82efa9cc564f5f862f04c9cc245b9a55957d85a869ca060ab4ef5f999cb111da92d8d3df97fb961b5341191106a9dbe4a39c1e24ead63a080f9e3cb14b71a7666e22d4dc3ab68fd34b56c7c03da217dc51bce429b383ebe0511a717687b3f5a81292a451ac5432cbf43b15f9fa134513e9d2914b10bc19f248656561188c9a86a5b598453ccbcd8fc06e7e43202fd3ecc5d9ce5c178e38db71065e8d85311f54fa52e3936c978b0406a90483350d3609f18881bb6c3a4af482c3a4f18f9e4dadf7f6248cd288e9608d8400007444abec7698e54715261081d40472d7a8a67e6ca6dde478a3aa34345cf389260541e89423e9e8c7e12453e8c8694923730cf4190dc3f7ada2b8c01e3d6d947b6d04c5eb7e9ddaf50fd1dcfefd91a743cde62eaada2810d481daed0409c16aa2dee756486403f870cfbd2fbe3ee354c3d5a499dc5fcfa5519ff9f384445d04342b602ed5531f6e92362edda305e0de129d4bfe53dc1c1cae097733482a7482a1cc8817c2859c65292b9b378555f3f1a7315ef247d33240baa59151ff09f751c0f505e19f759966406c88309a26b7cee7cb25e75d54096ef4006da69233d5e3df17223a09b97baccd739a870e7fb1b0e00ca1b6505ff2903186de0375dc1ce81354d5211e1c49d0f2d0f9fe5c605f6058c6f6e166166794f9a6e40564e0cdb18aff0e888d36cf5dcfd9e6d45637860793191ebecaaab284aad8f2663612f413ba29234cc6e9a94b0293b47a7d1f5c1830b1edd5df09a0c7861a88e01815cc861c1af8b945ba0e4ae1858ee46376b4ce19c91ad3d2734f975d43cc3d2259bc081fa62bd28497da4a9c42223f1e08fcc0f15ed77ef1073ea41aeb2cb3f59df95d4b847194759e821da9a2f683f30698484486df9d174e6a5e5fdfd457ed841ac59f113d117f180a0c4543f039fdcc1890ee2c0e0387e893fb134b30b0687ff3c294162db2524ca2a73241a6117201431c1d982674a15e7ad8917817b61968f7f23a392c7cf85050a4ee263e6f597c6d53eaf3a3b1b44a751b335cc552980e6c59f287342884dc4b3a1b19e742013b27ea4fcabe3af11ef2363775674d32075916899c67207ac287b0ff77e2a54b61f22d652b0bc079dae85902d1e6555a17f769ec45671010d2066c8633db910cde3020e8c48a37bbd5c5a7bcedd8ec2e1e036dc327346bd77ed0f26847ce711d94efb91f2fc6214bb8c9da99ed854e8b592b2feded63bc0ce50aff90bc660fd5694d1a9b9f5e7c1991021a9daf720864c6b5fa9b5874ec50b86f420f3c9db302dc13a11311b75c3da748401fde77983ff971bd65613a279af620ebc8a7899ae3e3511f187c63bb286cc082e99217dadaff60f59fdca91f1f64d019181d8a0edf5cb3a750b0da48028bdbca1ead9780150b57868ef52825c3712411a66f36c68bd620890dcf30bcdeb37610a74a8687ead6b69c497af58b2f69fb5c4775aba55daaa91fde24c66a5f4f73c4d37520174accf0018a958db1cfa771982d1a4311070d36b03a496cf99c67d2c16598176a582d8d07470cf18eec15a24783c788a64a98f9de7678c4c900cabf31aa2f6d2900ee782727381591da32232dd130cb304ba1364f91261e3c7470d5545196e99205f90f9af8b38750badbd8c25589dcef0b3472f2ca979b48d0b2c464c63604ca57db5b171b649937b7fa0885bda2df56ffaca6e83f8ed74ce80ce0f69caa73d297b6ac48904e67523e33e0ff184e29ffc117392558f9932aa543100933cd86d3f1e184c5505842af8d4cf7dfe1df1da5e0ed13e6df2153b961b324e79f0978ca18bcbd5305d95b138d2faf8ecef8da6c22ef7fc248e21afe6fa292544c3789fe28a2651b95dad657c01c4e81c987ffb966f306a825dcdfd19c7e17a8140cd94671dc471034994e92596c24801c663bf190b7c5af0060ef52789c168c4c0b52004ef192f22da54baf7b9d38408102009a518f5f831bb0fbca191db8c9a89aed402b944557b665f3d689d8a9103d615574c8ac025fa047fff2bf113bc473fbebdaeaff0b30448004416ffeeaae395f3dcbf26a4f9bc2df9b98186d8c5ae6596f35bb36f587f852f8b40068105c95413a4910925983e58bdc121c4c4465aa02a0be9b46f93f5ae0414f9fa10a7c0d2bc223d99fa1d1c849f60a59146b448ca278cc1e3a66289dd0d8710b1de9b6b082e5923c56854c6c1c540489633a21591a30f3826bb6789ff5e0a692d2619767fb83a6e9e4f2df734448dc18324e34ac8e6d273b14b7848262637618819f382bebd4dcccc5b5b20a2a403787b1b59abe27171b5941da93c8290b528414e1b8f96461f8ce75a84773e393f0cae6e7fd3e4ad4519581775e256f0bd99c6308938ceb832bcd0fd8c1dda1b2fb528bb6e0c91663390c64c0fcdbabae4279a5c0f88ad040acfa6cd83c4d0c59ad3138e426c8864535aed67453e2ce1371a84b9e4e255e55365417ed9ef05270018aa62c88345aca34f1425a6f5463ddfc772440b935fa233fd059f645bed386ab8fc3d3e66e72f8ee5f77c2e0d4a13c6ddf65b879bf1a333aaec1fd157f26e4661ddeee03471ef0964ae88c9c53b56cb1c1811a32164d900b52756c41b848f829a235600c340f1599f18a43a3b35c054215d51f62881b76d17cf9ad49da6ba7fdea3ce1e3af44f43b1223b03dfa8440485ba9afc4bf6b47767ee6120618687b5d571b8c11e24a8e6ca07b33937a8ff539445999e107b62592459cfe9839397b00b6df30d92cf126eac734d938e8526680ebe75c12d149d898249a2a5a3860b2c1f26aac654fba6f5ad78347911c40fa99eaa19b842825a882402fd38311959a54da16ffe20c6ce96fb84045e18e250daa17d7a0ff1778a84a177977b73963b427a7da161123778b81a2d4ea51db4d3f50c9bcd6d2312fb928a7e162d083e7472703cf2eb960a054b145116c86384e17340647b6acaf9e6143246effc5a228e95df1cee4daea7912ccde898f26048d280391399fb5fbeadab0915df1d07c6133a7255d576078428e90840b56af8025509c050498b6b72ce59904005568e11599e7b8dfa3c61452c2752910281a1e8a32c797e386784034f9efc41e3b97b77f4cf2a405b988f238a364857ed2ba48c88191131bcb452602817ce1d76002ce315dfb6069000b11dcd71923e3409d39c4f92c24fb72e1243e6d0c60cd563235d21c7b98df3ee79a2c5fa0549801805392d7b6087b6ddf26036a526028b90a19fdc5b0c7c17136446e6addff4cd37de44f434fbe2c341cd1c118ff481472dbd6ccfd455a4820423499e0c96caa19c26c95b332d3a6d69a3adbaa7ae24ef15bf82bfb2c52fa6aaa03ea3b223a05358a9a45a4408762042e727f4f3db6d2edb603304d991f7abdb30bcf816b850f0fb72a439994f2deec1792188e9a8ff784c060b65017630fb0291fb90ab845c217e925e8c45caa35febb01e8ccb2ac8c8df0166847f07c9cc2f95c9402bc5b52d9691ba7e4c3ed7cc15b6a23b029c8bbd94e1f5716ecf34168398619c90842f0c66fb7cce6217b7b48804b22e724a715bd8fbdb0731e465512c4a67fc5c35469703e69284cdb9e38a5c50c152b7822c226dd29e5b60af8e1055caf15b34a00da1009bd35ebf192ff5f6808f88227815e52db5a2aa7ba57b4f7fe95461481e399fd502d23d2257b8426de43ba4a0c3ea0369b9b093bdb082bd9bcdd15ab9b09a8c0829b2dcfa6c3e0e113e8d43e70297ba60eb216294698056592e7ad5822a53e065376f2264118b1f5dd04ae91ff7519ff30a939c8acc2344f8baf89ea3c4117a8221a92c892601b35cf39bdaf92e569dc407be9f10131e5e555f74f3d5a3e7e0f5329df99a690777134f66d7194b2390c0a789659b1d524729290719543d9c912cd5349ae85c03bbc99ca985572c9f55152e454c055126abb3597a102fe50d353855c862be967bb2ef08c6cfeed615a291d09105ef5b08a412cd3a662f634ae4778b6eb76cb0995bea67a5250793b47ead3c1e6bdd5209bf730c3af54f59b304eaf9d81f14b57174d5b2c64def4fe8c00e1ddb6beb1d95e1ec6ca7895385c5efc276ae40bc0843bfcb441d0d1de37538cdd9d16cc667de9e39c4f77a674c4a0edd4eb7f20311f2be42987117370f610379c10ad54040dfa23cee7ea13e3477146587ceec6311cca37f156bcbd510b0c7270a8976f905d4997378598e8b8ee5ae143e9dd49af76145977685102fb219998c44d21f7d83e0f3b7f3cf3db4975697794a1b13892a7100d7ec0f001776fa2a5659bc13c9c76c6418458c71177a0704fb01b2a639653c66931d19b8a74361904fe735391c0cd1e55c1fb90f67022b9cf1edd1ae3b6bea6fd1d22280a0df666797b503c3cf5d8d17c6b84b1a34afcd1cdb2910e6a203244b93cf8e337adc2307726f0239de664adc9512d887159f22e8fd4fa521b216089027c6a0eddbfe5f991b171d226d9e3958f9c292f4bc380f1a475d8071195210f6b218fc0eea71815a8132e597a68c63f571909334bcb81dfb6e436c44ff2fda260e9ff044332d1256d0716fb8b950e5826d1817fb06357a835159bae3f6573354f05b6adcf75d0936f5ae1461213ce9c43d0915fd524f75af43ae0e64a7376d553b7fb5ab68f6e0c585ceefeb89e0a2727fbedabd3e5241caca135bdb07a5ab8e508a4e04d37463998d8a536528e21753f8e53b7c902171ee6d32a96d6ccc2e4917b121afd63fdb179524e7624649eb076af6e4ffb8792bd3ae0e449906bdef98895671817898bf2d9c9ffdf0a690421f1e1fa379c172b3505c186dd48d03ac27e17f55abfc849ff8171dd916b9a098b0c378ae18ebd8d89ecbdfc07f68cc5bd8e9dad7be0aff6eaf8670e5c5bbb6233a46a49f6b0757bde0d73141116e512c0c4af7925a50bc04afa44f4fecacdbbd02d20f76b8cd7d324152b900c718d81198737e4670b10541111a52fe6a6cef2140899fe9b3ed48dff113b8b69cc2b6938a6e5bcad28c6795714dc5fcc9d78575e6285c7e8e7692fd2d59eac5338d5838c13f8b92cb5dc8f0f64907ea313e56600915dd9a6c3538168b05cd8ce4a82e8edc6a7edc6eb2f6a5bfbd67873b055039947ae471131f3b7c6b0eccd56ee4d4baf45b504e51cebcebc13ebf4fa95e37b02a2eea8fbcaf31e86d778b77986959a92901d52ff9076d38455346dfd259f795a353e7975e4df2860c4dcf402dbaaf2b85f66dd7466e4b888d0798975f62be8ae5ecb1175658fddc4990ef9b2516b75d446c4c0e467a78a6a74abcce6501f857eb11497dd2f4f4d29dc0447cb28849e10e85153744a0c4f2ca22422c36bcaa67e654141771733bf2b4e994df02ab4a311f346cc0bba547b2d469ea43b195244eae67dff7b0ed4f710a1543d4ccee3c5b0bdb114f27b4f847ecdf9ad0380bc19849bff7974d3dc72ae470b4238347b48ca4a6db355cf9b929e777eaba16fbea5d3f519b963b060ef82c6bb0e671e7f17530f7d5b8743670313072403409b0d97de906a286c2a247ac78075aff0cec06217bc2ea227cc421bf92d490527459aacf7ba455649beb55b7ffcfbebe3d1f4c094e69bf41fff2093a23ad363a6f7d6fb6b1fbcaade1d7d85e60700748146c11c9cad4129a770273fdf42b915826e0567a058c2259d8e995f892b8f7058876c5fae800a7642d8b072be4eff14ad78b2d4aa9ef79c33f9d26ece9357a900ac02bed97b07729032d566c71083eee4567085b3f73e711a2ed5367c1b74e8d8e930a2788da123b89dd21d9f102b95cf226446971b96f9b9c26fe8dbe01abcace61f8801e9a7746ff0e85d999d9aaf904d1d8e9d592b3d1b1f1bdacdd324e3d414e5180d6a04a059b606592c3b1f85a1a0568f3a85d5d132c4daf19bfa9707a967ce4e9e957541715475dfde7c99b1bdfb7be3ae000d22ac3ac3cbc69f07a18e9054aec350d3266aba535c9075a0f04a3987facae39b96cdd5c9bbfeb05191a1aad78f21a08f8c618144612aa9308c394641f31890243f7322860d05bb353c66f757b2872e1e0b3e224b0272388ca69fd702d744af5fb6c833b9a91093e61bc50b5ae90f5af9e9ac4cfefece215f48136a43dc4c7350628b4a327b0d1d9f49b32934e253cd026f5166dede16eddd15259d50fdbc10b47ca754b6af9b32a80a5799a8e90eb4ef330f82e7416c915a11d9652d63917810b2a68dd1e735268838076085e49b135cc25d827d56e4f70993cac7a0df9285b962269aeda56141ae8717fca842733bc5b24dcf805375ce1d9d2075a30eecc747be4aceb0ee189febc9289f45b6509f0913dab6bfc4e34623171af9515ef7caeaf2b2221540d4287c4348ba6e483a276a4194b92c2abfdd8c3e2c2ea9f39d23c96aa1e1463c6db9de63b38f87cab7eed0b5483f66340cac42d8bc22eaf89cc79f76d07ff92282c0df898981f0aaa3996d09ba58dd4fe648046340ea2d0bcd6064e3df3afe4f624578014aea8032842d72faeec38a59deaadd4bcfa9f8cd0644674710b36bbcf28308b8342494a79735a1efdc01fc12d9c3726c12686174fe6ec0c88e660a899fdf9a86e94c4e7721dd08820c533d4834804f6762a43c66152da95b61c2a293144407c3a54a65aec742b19e7c4d2eacff37a27ca440db6259825826e61f2c741d5341b217e386fba8fded360a1471f610536bbc6816523e9952597f4e490cc6af4c49c088ca45d4dd30910987a4ef97ddf6ba12603cffb6fa58a2c69988aaea96a6ebffe3712b987ca7a4c42ba8b36e48b271debcd2bb9f139359dd7cd6ea1c38445327d3613e085fa487a2816b43c859631b425d2f038381a8b4dfeaeb3ee38970e366e463276d936a52133020accb605f68be035a59ed99684d277f21edacdc92be118773b757093370e8ed1f7988e3939e599eff1737ff5e7e9b79e50affd6091c8f9ae03d241ed6b458dc099fe5d636e796af55fd8322ae78ede432ee48a9993f8e41716f1d53b798a384395791a960d896c887db0ab1618f48d1fc9533a6399f9472a0e60ab6a80df09c09aaf976d7bb09976f7a0dbf930cd0f42db62f364864c8b97a48bdac3abaec82b788df72c67a2293eb3e1178db4c1c57fd4bad9ea272af297998e72a0769098cbc09bc827afbc21116d75b07fc7d944a46a5c89d467169d18843535ae8222b1d87d6d55c25599705457f64c9728dca8f04cca8ca5bd7afd8f341aea9c2230c0dd5c60161d6eb04a44ec38fc6de2386f6eab10101dcc21ffcd2cec83ef2ba5afd888ee9e0f8d19ffdb624e552710d0f5f47301230bd5fc6ac6a4fa832a61cf90ddd8ec22851e48b45be7959dbc1dc9f9ec316e265390cfaa2af71b84e268ee5db4c6a1df1424e73ac44a58aa41a888aa190da7ba9ee1f33289be6d58aedfeecd5135053a5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
