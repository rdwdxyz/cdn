<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d39409c0c206d32c01576cf5132d7ae87f703f9821556c44ab110d90230bb093efc858fb135282365713a4256851155efb54d07acfcbc4d267686364342897a6cf53af2926e86e47559b3c812f719fd1ad85a6ae17d82df17ae2f07f6e22c0f5f4b93d48b7b7a7a6de173791cfd7d18fa2fb5eb1ef4409ad0ad1f03a4b9d4f308595a67021db27aa810567df183bcce091fca7d9f4c27d258124b31953363cafb7a29be6e52ddc2c48416b74ca6781b70a6d924acb1e820c643a36c33c111875a582f1f4edc9a31481c94f0f69d39f460943ac8c72927ff265683f9c2ab7095291b3cc12cf59f8976f3209d0d74f9a97e06cc9fed8742cea99a43e13d68e4dcab67bde08fe1e639b710656df23868c05d271c3b0bc801f4b5c62253823c679035092053b957d11ecdab9a9147764a420a9918e60dcfea98a72d4d7587088687816e50c766920e1e98dcd6717e09713d192c99d710337dca1e22026f6af7f0b028bedbc2d3e3cfd440a61a569dcccdf82fbf4582901355cfa5b9e20cca613dcd45f2bc8c9b175185076bc6fe99d57886d07f649c33638fa562e0cf383bb2fceb4a14ef406676ac1e8e25d8f80b9e23e418466285435b9ea02a3df3c99e373d31ac3424ccf793390a8e107a83e6a51503eb4cd3ae3be119956e7cd359d6960f63c413c0cc2f9ff54212811253f0ab3fa78386e81b004fbf8b179935bcc7183a4c8e7341131813f00f92632c9da2e7b7c7ebea3396904d494d3e511c9cf03bf888bec39b61e8011d7d028e2ab90707eaafe08aa4b64dc7b58eeebf158103fa2af284a357bffbb247e4650e362e7247a5c2bdf39bc84bb3dd4d2dbb00321d0171cf867f5a4083b11cb531a4abc90bf037ddef2915798939d82c0c3cfec212e333c16f97594ba4c6fa826c8f0c10387f3e94fb68c920713992fc5b601d0d6c3816df2def616cdd05e3191bb93668ab99762e71e544d05d28555ee668e77092826c60cd644e13a16ac9733e9894312eb54cfd4d08795049fd2ee8ac0d8801311f93ed48e59f8a519d8a87b205d84dbcbd75a45564a45d493cecf41cfbc6907d9dc4945c644bb7ce7f9494c7940bec5a9da14792eda90c204508e25982c1644cb77eb4c3cee3604b2703e31f5ed73c76efb483be65eef97b63c9eab60454bbee4d51c390ad2be6e738a95470ca8e67aea4fb7b7fc1705d641e40fd20b40a8452ac72bf0b31990e1418ef3c9d099b3f9583a0742465b5e123a98648995c66081cdb030b7753878e654d3145d438b88f0b9f22b3cfaaba4965c83be9ed94547dbc1f1e565024eed1ef229c35ee7f732b3122ff335bcbe4243651f80e8d69af8baef8037427ba84158ff9084d7e4d6a9afa575f8875dda91a031bdefd6a7a518e9c89cd523be69c4ef27faa4f719a5b1329b794da89f9f07c19d07ffb40d1648302850720f66867a907dbd9fa2c8df1d8af05f44eb710694c6b70ae6159240e794ed807134539f8dd5217e480cc3db0bd0680721456d8d1878a593585670eb70bfa4ac57cbaa81222ca86418dc33509606971b87ff46777a4e1672695ab5f6e51349c2b22821b8beb445cfab130a81fde2c1de4d13e23567392582428c4917a4514098f71b6237ee723afb212aaa20b7c4c33ceb6131a63f69255ed794d5d47efbfa777f6c812d56715f312a2c797230e23e0c3e94368a1084865058d667face90c0866223ee1b66af750f42ab6cb9f3d277dba5d944db8ae3488cb8f3fdb75a1616034c0674899bed8099a0141a38331d8482e964bdba438699c6801c39c2fac4bdd00d8af074a1a646d63c65c39f593da7019e23d9fdc9747f1b92ab49a578387ed74a1c02cce9a8625bfb58876569338cf50bb6ebcbb0ba3cff0ba9bc1ab770e824aa02ce740331c57c42d536949e0277aba2d2334992f3fb6f5aec8a9a5189d5635039a2cc6e5354acc565a4b9909759cc59abd82b6267902e452efac4c8f3012b8cae9370cf4e7c7c905910f4d498bcde2911cb47573e20d19028e84783f3d894879ce31c86877e9dc3e7e41912a9423467d2e885ae54b7ecad0ad90e8ffe8504b792fdc9cda4e448b5a0a0c8cd56874e6cd8129c3273ca1b5187c808a819496fbfcb65c0bddeeaa395481850c723f12ef624437d13d7f4c9ba245a0a507afaa242935f32398072c2add9695d6ba6a3b7eb506a5354690bd31b0c160b8a7b03aeba461c2927c89af11466e0173c0a37d6bb0c9d393d957fb889423a040d6d3b2d1a32f33237e8325be87a45483b7a76bc740605b689533a70ea41c305e0ef3fcd65e110271ab21054c5840eda4352ee09b7929683dceb22d78ba3254bcf56f4e33c837eb008de1ffbc248fa0ad3ab990c13311ac4ad8f6dddb1ca971862a48e51e99d49315f5313ce396442682090f2005215f2b370ed86626cbd136f8c48aa2e7c504f973d53fe160cff75741df53511a9d992b4695db1a8eb53b61693c92ba64bfcb456ceba3ff97605ebe16c2512bdde76524e9b46c34c1580b66e8286d8e871f1f8b288d710dae8d91d119b05c6c92c8821fa85ee7f3620bb6ae3f730867e038d9ff16bb5cf17bbd07b1e77f9b63dcc584238f6277cd75eea843e24c0e5803a6cf53f3c37ce296c66d773e0beb7283a5bceec6bfc978ccdc4e1c3f63db77b7784dc2dcb54ba0358a75f8e65113aa2541813d2e86c0dcda7b2abda7ce25ec7238203fa299f1292ccfe3db125ccdccbc7233de0338e19a95e9e7804f00a1f1cf1c9bc8fcc7849c63d23e370e343f7ebf080f7adba7f33ce46fb0a042ce02f080157d80ed351dd1b398ed4378e25d7b483bce3ddfd54a77bfe9380d3644f009e175898cc5f441d1e64a575e166c42b3ce1bd346dc71cec6f17ce18cb5b77734e36c051c054a86ba08f2806e68c170048a1c434cc21921608c4a81f805b3b0a4be578aa62112a75b75176f026fac0a8d60c660cc03ff846c5a3f64bd24a98dc99fd9a968b763c4cc06315c4f1d582c6b1b4dd0b53c1c3c0e96edc2f579b79caa1958457fa8329bff1aab811ef863390a698d33d7580263b7fff42094b8c0af55aeffef0523f14d82e349242ca88dfd841f12852c9540098aeda82f3d74dbe98d280e6d748869038e99b35b78f8c5975b4400ffa1e67130d7527541c8e9bca629cd42b1ac096724225ca97c1e80a151e1bcff69227f2525f920795ad7bf19b648916643b3ae3a2a8be901568353b1f1f8d9e7f9eca81351d78d4cc45f1385827dd1d170933208f595c33de0669f6359fc1e5f4e244e07988ddd45ae4d3b3bead6b92eaec5fce8924c492136c663cbb1ddeffc5503538800f74972a356612e8d4fe0591c0407a86075e01783f6eee3f019ae8cf31ef8d4f6f5a11648789002ea03907ddcde8638e6f191bb35bd36c96f15889e02f76327f355c4678fc7eee1f391941eb75340d62c2a34913112afffa3b24b2d5c0001b072768a168397046c6ab8bd2e46152e52f2f6a72f10c22c3875bdef84f6e74a73c583ad1f35402878176d5bea41b5ab1664df0242eba439bd04c3c47110702a499829056cd526506737aa4489af433a427d806a54f2e368c4a8447827a081064b3b3d3aaf157c6603f2a38204ed53007b84926539153c6a2d32362923001ee55e425340ece8dbc4ff530e9ba54073ce439250e253833f9f61adf9160c83f2cc03f106a012f7bb2056a3b31f59bd35e0be4f0959648a180e98e2dc094607c370f0b4cc34c9323abe1217e4a64381b83973409f2c8f28a3aa66d5e28a4e271ed7e4a07e86a6c4773154c3991555ddbb3bc69d7b78b6fd4ec868a1aaa4bae35f137f2f699b08bb33bbff30511402652e65e600f9b6e819faee6bfff33d3db31421599687a5feddfbdf686bd2e7011fdc2601234968bcdc8518480ac0a8f0e998cf671403d1199f28de2fed79a7852e487b2d152e25b1d7c6bd25161031bc2719b7db7adc000be36d6933cc410485b5e3b38d5a5b4c63d08fc0f13e6c6edeb96595bb2cad8e23ca7a4256a7d3e134d0117e1a67d1b20fe682513afe447de03e1550c3e65e422d1d58f11fb872af1c1ba87bb2c746b93ae29bbabf3417502a622520d4ca5aacc71aa37778b96153a74b972e1a1c5c4fa6c98f188ae11c3ec164c4ab0a68b89ebc9b25db9180448c2ebb83f1790401b31d9ad0c98d6fb347ff7c326bc72db6f1555cd1e45dc3c58bda4c95eaae530221da232e198567f1b5310f0282f2df2612ab80695fbaaa99a8ca7d7391e3e969b7d3988e0930b7de9a2a1ec6ee61150b2a0096f6eaa8bb33706aacdae847709d86aa3a59e7aa5a3b9c0967ba4a6784efa792ff72c9d3e59c0902642f5ab3f64b73e296a80f4052c006230efc0bf6cc8c9260d3278fc80e8c75cddf6cdb6d37e82dd375c759671afaf4c4b87f3e1fbf7e7f5aecc0e1602722edd8e298f284051f785324682fc9b266d4ee0e8be7558f6bbb87c393f2e23312f1c8da36e9e99d7db36fdc98cb29478f0fdbf5e29aa5e3445b4f40222b2c7c9f4102ee775dd5a7a0795048b47e90e41d23c38e5c152b8d958043a7afb6cb6c947695ad8b2c84d62222d7cb241e1c410a7bd16ce995497daef5b9b4d73e6944927ae380c88d6684e3dd43dec2ba91e1e829e3955273b4833ee2827cf9e35828f611695ca658f4c46b2ca89934d6e09ce2b3cfc9ede101fba6a0e2b894ec54b4e410dddb7e0cec16c0d55120bf7be5d3618c396f190858ec0cec55e67747d2ea1a09262b8b4390de25cc34bc61d2cf11623dd7e969756591d0dfce8fa643ed7718accdd82690a092fe1f36b4f1efb4ff9e6c5309a4d1ac02365f984974e45af2e81941949bb5d9fa2431027844c480a83af33c434345cfbbecea5f7f48b2c2d68b4023eca05256a8c2243eaab48efc718bbe63760d7a4052371e0343463729b4aaa717181ecd8c799bfa06f308a03fb69ca1c7485c6fdc07aa52c862570aaed0bf269a282f3be763b03738bdc72bce7a7b3acec4ff6df25eb85ddde0f3ac04642a7ad8fb4fcd4a985f4fc0f51c9b9490759b4ce23cad72631dc3264d71b0ff4b91ab7fb7b3cf57a04189eda19b012f06ddf46639406e8c0121e6aae924940753a33f18c299d6856b8c2d84a225435be976e95691a64d1a1435b6702ff5c68fa7463e2b942f75bff419d77330c0612b6145e90921afb44c6e8e560a2ba1c6ff52a624fd8c86280155493bc3bc0853f59d422bf2259ac890d985fec4bb424455bc2217f01465c308711c2e287e9dffddea0e15b1db10e72da4e0f4b7fc02d3eb534d84fb9250c2eef437272ecf09f210b2e3ccd7f2709aada3d1d88f9bd8614b05bd9e591dfeda94d3ba9e2ed80970919eae914863bb29939934cbe7ef7d495b49574e22a7479e65837c6b20eb866f740df4ef2c5cdd940a006b3d392976021af730db9aac99ca7a15543e6b30d4ddc76bb168bae43dce5bf19b05c7d2d579f7413dd15dfb0fe1abd949c46479866b76f6bd00de0c739d7aac96fa449e223485a93b20c0522d31533795a70426c8e84caef488de4f0bd1b9fbe09dd6f7fea6b9472f22208331df2ab9fe1f47163be0d8bc6027d352cdb7d9936a9fea8d8ad45c085ecde6b233c1016bba8561e73116b01bab56216ba20931fad6e3304f5851efd612792cc8bffdc501ad09a092306633d5dca266e3fdc05a912c0d5b782918fcc1dc528e7dcb2beac48105895482faa88a934341cd724ff0f054e20b292c6189b391166eaed641fd4bfecee953001b6d5a1229650dca1163e65fcb4d8fbdf62630af8d3b9e3139b916e8e8c9fee5d502fde23aeaa6cb211dd0a40648458f462eeffa8f0af9edd8a5a316826c5a547c15845089932bc1c2e8bf7a1781f0fcceb9831d54b8446bbcf65590a77e2b910961c7e8da905f077f82f8f5957e8a6f58de34306e228428298e95b3a1efe82c19c89b4dab46d6be4c3b0c55b33c8b887f7c6c1bfc59b67bc60777b94d454bf02328c7aa04c5d75168ebac584186368bbc6290a6f10538ecc9611179fc834c37e71eae782b7ed2f7b049db246f1807c1827494d38236fea6e2a29e2e5f9d3652628a83958a7bc4e659e004adb81d36e98eaf2ff7ffb2848c7b71899f6920dd54f2b70c29c1822fcd7183fc771429ae54970e3971f6868c35bda1ad00179c8e83b0cbade42149964f12f398bb7151083ed43b75acdb09e16171332c01f3c5e767d0e4774c49a1bc4dc45966b960090afcd01b0817f5a99da3e3a0323be14a04f715676cb0940db114b01392008eabc1010d5d5ec8d3bed9e15f72c5c509aa622a5aaaacfc927fa2d884a04adf21dcb4b063a3929c1741d68295757355d5645336d958791bd340dce355d8d8f14ef7f16800395bcddf69385dfdcd9bedbe94a5af5dd5561838a56a0e01ef99209e826e9e3c3535fe03cc9bd06caac47ec90a5a9d89f83f808aa6aa4856547dc8e435cfff97a87033a190662cec9231cd8943d10e888e56aed611d5fc2afeb7acd2d2a9626416c308833aee40fe3379b187f7d0c34e89176a81fa3afb93d359c9e616593202f202ed37ee9470d53afc23e36db49912d57afd96ec2665084a7a9e95254028884e7d71138bea848690d82840a9790df73e07c9d86ef0fb8081291856f95b3bacf5e18bae395c2e8aab0510cd64ab5b03888c3844ecacf26693a576a3168055efb35e9faf327abbc3d8ac851b1c435419aaf995684ed2d747e2d63e1be54dcfc21ac4d935cd70bf68b6f36b5c6eac5b99b8823c68ba792af02a61a908851110faefd2cb71200b0d015b74e2da9d6b58d8d558a4ed947841a2adfd08d0eb119be07d314bc40e184487e8a192fcf002e6ee459c480d6fb343aca8457f6d7d1c994f37face27e624d3a2400a18117e0ef9d44d543c7317d7f2900f919ecdb8c30eed12459c147b2b99d2092bd6596eb33c26da63230025b05d11eb02a927e0c634b73cc74eaabf3a0607e088784947754897a1d1f19ca0ab12660cdfebcf59072ded15bf5177b95ac9562d7d4df8d6c0bf7c4d8cc6e6d5f7ab04a266dc180bc04897c4cb6ddd89f1984d5e600911560e33d793ab668bfa3d9960ed90a9d767dd08ce072f27d9c679cce21f50aa4805653eb48687afeb6ffd7771cab1a2db2aae6e0bc95fccc76fdb6c35d1af78107b5b9d98f8b1de31adb8d9190c078709a5731fba54fccc6a3bda743b42787bf08d2d8568d787e462c6772f56f1c5a6864069481840e94b78720d8dcac1f8e2e64e326209762e2d60561701f668f8d2db2c2a3737f1a0b3c1b6cce1a1e0a55636c6a5b0b6e74e02c587468cad235bf5afb0597dfc8bcae407e21bbe8f60e573d68422f85fe6287a68e4c8f14f40055855cc1dba81661e45988bf4ea86ab2c282468222dc60c1414bc4bcf01c90454690d6f4b20a078b79cd82d39483639b552e28d300b7bbca67987fd99766271da39441afb0c3932efa9279147d7b234801f971e56ef8299a3feca1bb0a1a22f6fa5b15ddd211dbfce63fa113c5d007a2fd1ea13139f6ba8f079126d3c8f336c253c5e0d41177ee1bc89dfd80fca583d38f9918d2613aae4d5bd4e9decac818f4f24b71f32bc0eefd5e2d60cf3bb3d1fa0439e40d89aeb9439af8df52645dad097c57844f36c00ad09dd6d6183555c759b8a254f04e418880b829eb1b0a7afa9ffbd6e6696748e6ab608057314b6418f8ef574993b1f1d08c723e97180b25b637b137ffcb9b741ed4dfe12dce19c2f3e8106144bc7a07c6131bff45302d8374fcb455608ab88990800812153d7e2d8af69653e5979e2b7de8e1c2dc72541232428e143d198a6052e8bf8cf5920173c2b3016fb65a788c39c403f7ea5217d046169ba9b1b070f8647f5977cdc44213cbdf8382fe840bb70093cecb6e810360752f246c0a34fcd03e5f0d21d3710f32bf2ab05d04a9ded1139ab0e801fad7730e624539cca792183a0577c5c33745507f863ab73c259170aa5993bf2faa7f9d6a137dead2a69026cfb2ada256b4f6d26f7f2f037798c62dd4d667aee7334d646a350b7617b9fcdcfa2fdd769d5b6aada0e04b0d13373ef1cbc046d84dfa418f2924a4803b85cc73b27041aefc612fc75f34e1064c27f7e0e67c60efeddec6fe16e3fad6c89579f04caeca3497492ae862dc385d3120ee2ad42eca112d40154eddd1e117a53772f58bf2b60082fc174f2e6d7a428c36e077c951e48dc2b98986b91ba0c8e987c301812134ba8ac4dcc6a984228c3deb375b82ffa832c82a828c5201450045148e300cc156237aa4ecd2da05178fca5dad43324518bb631f6609d287b1f02557d5a36cdfe37d91d32482f318d0f474dbc2ca0c88e9d38d6c53cc8b01bd78e2f8e5e5929416f0c23da0ce8f9fbdfc3f27944731d75a0827b8f1295bf4229c5f24403c695fb6010d536a98aa3a8ed3c2a293d63eb2048854c23cbf96c7b80d13a96cb0421b5681297d836f7cf8358ac3bfdcd816508dcbb1c2a6e05375457703b296391cdd86372653ede87903f25dda6a8af51d0f443de545dd7ca7eebed21d73205d7a670bf6d0db888dc7c131c80feee8e1a9b5284a03c89cebaa7a168509fc9a989de3e47dc08f75a92beaa93dec122ed0652384d2209245abcaf020104ce8dac5461ca8ddbb15ebaf676900c9354428eea1edef3882555919b9826665ffb1fdc7c503ac573bfef523dd1bf0e807214df7dbde7436625d59359ceedbc9f6033f1bf187ea1adfa94c364248d4d708b822d027c0d77c95789c15131914b3920912ab015cb2cd789808225629058455bb4cc0ca61085434501f927778d9fe1bf9857547a5c4617eafcbe5b26d455258f5a9cda9da343f3b9198aac79d02e7ec0b596e81dc020b5029d5afb73e6b348c79b2ad0945142d207dd2e369804579994474b1fe7e965ab2c3476f7a565568695a246940b2ad2bda1ec2401a34d1c7ccca25d2139e5b9e51ec7ae974063838fce8da4dc66958425e67b9cde50e80d9a1a2f2a3035151f7353a226424ec117b617284d80724ba8c32a4786637716a61c1c90a6acfe08ead4448587c4229e7dc27cfa8687b63ebd010fca74407907e798e949b714f62d7d55305ee7c6a8b3febf5ea658504cb9bdc0d87af03badf2b1646c714e99357a3fcbdf3997440ced79c6cac03f5c9ad6b8ccf6407a5e30e8bf67bfe91a82cf58f7022349db8e06281868a8792c4fe3289b80ebdea5727e9fc1efc3a97a0a8b736e156869c3a167c6bee5b5ba2ab4cc8d0c035164b3cae05fbc14872cda98cbd95af022b9a77ea2ce438435944a8fa54a317880b4e1ec0947b47fc24c684934ad4179d1874cbef5f27f9aef794fcfab163ceb487d859c970cd1c633ab1e9ca4ad8787732ac5641305da5047af8cee0e7a32420f1081031ce42b385fef14b1e7205dd62fc0fcf27be532999677178747f0e975a629ee944c2b3518b652c0be53b490406938e5c9e79673046f6e1efb5e2aacee8ba23bf30148c05f60f70f3d2089daeb75a2c13aae39dbc0e64c91b1022ef91a4313c3432e5fe177bc6b28433b3c9d07df61de8bc4b981c533ffb9e9f40cf5be49a9ce6fe09705637a94c0d53fd062047d711ff08d6cf999babca9a6560a9d1c60eabb58788f91c9f2ec088f1ea7d24aa4dbd2dc800d60ca7537010bb24b5395c51cabc519d37c6011c44695beb2225e87d3cde4721b2f343a775feb2cbb9ccca8b1da7c66359b945f71603846b98faaf0ed13d3eb11dfc3f28b3a073ba834fbc9ec5b083c6651f85dfbc4efbd58ff53e8471b7664c67d6195410ee7c377dbf2d67a89923813e5d7a4631b336dc246d39954752d985a79ac1c17231d9146532d4a4c6136a99fa1e7dcdf52c5ad595314c1ad2033e5f4616df664d9bd1b4345db97afe581c92bd2ee55048008f57c52dc860e660a623c61b3d43f116bc4f41928313e93ceeb2e84d5937cb15210009bb8f673e1b8f4fb585d2f99cd3fb839615f1c443cdb6603ecff5a7d1e964f43eeed9f1fd95c5ecf4b8a7b87a175a8264a8009d6aba843af470575fee33d21ae4aaec088801e9de528371e1915b6e78c22eea563a3e5ac37f1fa3e02e5cc5ea9dd4a79d0b0ad1707f38e6dff472cbecba3d7eef59f49aff690b2eac89d44a12043c57876264fccbe864721b3fd4ae2d54666df1a5a5efbe7971b622d66f83c10980ca5b6bd6366f0a3446e4fba6eec65f7ad9e47ff4dcb9e2002ab359434f355a95d883c3314ad4a2695ff215f4000de12b79a19a886140fbe83445c583b80c56417828a16282266bedaa687404e6e992018f22f4a2e426fb400445895c2a806c9737b93f0879144577ea7d41ffad46e74007effc6c6d8c4cdf32d882634bbbf3b4ed0a69c2506fd070b0113ed3dd95ef0e2430d5a8c92152add723caad4ad6c05cbee138d0f884992d77c49312344a7ec1bc608c611de9dc93686f76709a9f0f34698d855e5491515ad726cf08d1dbd5b9c5d5fead46274b1c759a1161d8aa95055961a15f48b038d5c260f9bed232fc08701ebb8142c4f9eae0627b9f8559646d8d7a7ecb7b2d9a39b5e6b1f2583567ea635c7483a1b6f9899ba73e4f8293a4dc5390d10199ea77ded135aff1c5a784b3ca2e038705caa9679afb1cc84e0486e345d94c94a5156f1d43aaa00a850faac2adef9df26162a223564a007def572f61677b8b28703b571d021977a706ea338ccea56c5d56000864e6a11074dc4399e6d63f6adcc8a9dadf24bbb6126bbd8d1a9bf465eacb49946616315854708a74f52c03b74bf12a7a368769af8567c9e1bcc5fe276727337ca5aa3ad9b42613ccaa29712b2963f491462b156be2e3fb22f1709803fd16c4a6b77b3f4d655ec70567edd371c77bc9aad43487849caa578ff5ba8bfea285f77aaed2257f2f5efb89599bdf6b8a899fd15e84f89d03817926ff22cd124866d6d6e839747ae884ae3d2c2ea8b7a561343535b6cb76da4f4a707ad2a7f98236b0bb164d34d063c009835b256016cf80ea04bc879fac389670ad6c925090c8a873d04089085d0042958e65eae2d041e8e5f7457deb32e5fcd3b065dee31e31b61cc6ad122c4524d95990afcaecd6a797d963c177330e35b76f56030dedd930ac66f41b3cdaee08339c6c418809ee317e8a0080b019a2f9ef59dd66d2e10fa4fdc4c00868f9f5d42bb1a278f536efc380c9950b75bd7acfe0c06ee72fb99cca6ee46b926b133b1de959f59693d82c8a94a8805b1eaef2055111c7d627eba2be248bc0ab4caf9809792bdb760eacf85a317b5e11e2c82fec52df0cb7299e99f613e58eaa399c4af23bc58f5340706c3e21ff42e2e673dbf46dc430868c67d7d669d39914891fbf910d73e599098bd50e68f01b01016ecf302f27dc67866e3a2820bdcc02e18ab9c8c6f581aec3dda16012076a927de6eacdd2eca50439633aac8a3f80a0daa2eb795f372a8ba89571f571d48a12dd8f5f1a25ad700b60f0a278e057be5a86932843efc29964a28fa6765758def0d79b8ebecc7375ba3ccd0754b1640100726c74c9fad7ffd81ed9ec84082ae7f0b577c7699b9d1e1d069eec80bcb7c4d705416a67d91005a441d47865342e1263eb57e99022946ec825774b4f0dc34871ef8bab5c445e7654674ea1dacc270151f5ee3f409594b22248b40c0d792ea089a95e6e4cb2915b16e5fb5d1b62f955317262e1bb9ba6d6307c0a740d4332878fed3056a31029f96ccd39c5e3b14bb2df69887532024ed331a277c9210f90a5b6871b2de17bc2e45d2c93153904c29a740483844bea87b20b80bddd17a10a89fc21e81baa3987efbc4f50c353fc2332201d7d8c4cc70c58c6fffe720c167d5d738ae80a86bffc83120d3f35b59e1110da74a035b7f8763141a6e3d6fe4d2991a33834b208f9a9c63416d7ee5cdfec1ce390dfb04c3b62de39313d44c141cea0ca5d64ce04fad203c58a7aaf6b05149d8cbbc20e4b1935df89cec72a595e30d834df88cfa5927249c34490df97ff47dc2b20132ac5d4d16af00ca43a3aa9ae84cbf52657f2b0254932bd23925ec9c837fe22f72ea6516abfb6da7089e35b9dfbd8efc291b248c7bda0c194ccdd98dbe86c47b99eff867a82ddb7a8c0795b76fc6cd84fe5c3f288dadd44b252af83e7163f899b686a17f62e40e2ee72adc805ff46215143f94ca0d81612854d9cd0c4519ea55e8b3514e3da2400a2075847ac62cb0a5b7029ce3b77e7687b9af071fde761599d3cffa45cba810e2e1fa7d0f4fdcf536cd4bd111106cfbd0958e53ddf72586142375e2ad3e8e8c6dc14a376e8ce34b2d228a411829ceccaff1a88f6de2ec5823444c60d1fc09eab78383e2954f094ce1e4659c982d4d33b461752898f13223c49873481e69adcb01fc88d729ad8ccee22b93faa7ecae06a2b043a2c27ae4b92c2309b050794d862dd25948022721f194ded3b5983caad67557c170f5a0ba26f701bf94ec38e4e5781be36d61e1db0158a7a1707ff4b4a7692021ca0907402f3c50e46c9026024ad4a7c8e727a27c90049de5d5e66cf767b1babba6defb27004fcad725dd66836ea389f0ed8edd28d1893c56cb944af98f793d8b1c1fbbde4fc2351dc695b149973bfe752a895e65a89b875dacf3c9d4d6e6b6cd53e29dd7e462876bc4f21dac3f4fd1de9081bfad33ec1c3dea70ba4df186e02858577b82617211dd092408a598faac07d67a1aa884cdc8afa41b788a52bd65d09ad10ba886989985710c4fc89173c979c45522f5a55f0b6f278d2f357d98a1ef08862d65dbf884728cb696e2a7529753f8f6c81b9b4c10912ace0d85a7e837d43a61c883bfb45f2f8fcadf5b4bd518fa4c46293f90642e1a981e80a8fe1d58703862c6d64cc95f94a8e271b188166952ff397dc84bae1816ababa3f222caab6669bde6d250b6c0f39e520a0588efcb93aea8ca9fb263157ef8c54f6a5e5202cffaf62dc268e847565866f950069bc5c9ed9799b9c4090ffd525244de4b8919a2ecdc55233021be0a55da3ba891b4c5c8cbee05a7d5ea10da0b333718a456cd4273d1e84b25d6b69e73fe7c37a8da4de6c9e5c05bd83ea36d1e340609aad19c48c93ec377d240a992c67a5834c7da039dd831661ca438502b20860348c81abd8b675cbbbe1cb86ada60c27d171ec5ad80adfc0c2e34a9ec3ad9ecfb4bbdfc9e32c574a931c86b698ff29db7e93163e0afdec57dd3f71077c2c90a8ef316165ae4055df0d2176719047a73e8833554163ec1e985942c37f3012b0fa7a5cfef68b3af071b0b6a6bba60e285efebad1601b096a1f2eeeb6dbb4149e3348f5c5404271fcdd0118f1ddece33ad88fd64d85a1a424af592e3bcef78511fd19670817480fe6f7ee282c87b3625a17406d5001b498da1fa155d6976766040f0e70fe26e9b69ebd598cd7f406cdb5d1599e9647fb257ba6b046c48f1d5aac7203719c49d48a8cc8614751daa37d6f6a9014fc32f350f959499a8342a12510e07716cefbba4b73713c29028c6d45d0e6c01dc2dda5924bb605f7e4dcc7d5b6d808f8f4554309ea99c851254cade0173e1f55b5f3d43515c117383fc8bce299c0778f13f27ba1f24d0699c6ed8e6b801a232c94e17296002f4dd71839252269940eb55d3a34d0d63782bb585987feafd872f0eabc01ecc39d93459d354e593c79d025d9f26350828973bdca6f836775e7e407b63b091978da56aaa416048bccafad5044ca6209b8675dd35a15e646bf9ee051c49fffcabd32255e0048d73e487c91ccc3aa2a8bb72192ce2220919127b1050c1c001f2d0cee2afe94d70c6b1a6287747df5c3fba4497a265489aedcc17333af3c66502778fc3772e6f62db832712ab58acba2a9646fb7ac003d14fcec740ec718325a40693472660eae3378e6d54e976426239aa2e340ba266cf3a8f6d5924eadaa5b25d125a3c61c0133b6deea8e34daa5e7a1756ba2c51674565b115bf8173398550e3683e58605f0b41db3db3aaae5b1720d0e3980e5280307274b191aa173507230556ae7394cb2bd5b09ed609aa55248abbe6150ecf29572b873eb392c527f23077bb25f3cd637f98413cada256dd8d14cf2be9de6f1d7e516d5efc887cb2d0bc78a86f601fcc3103a7fac46c4ccbbfbecb785923b0e756c6d8351ee10c7b7269c7a843e626bca085858e52a2186a81ecf031cf4a67fdb8ce29f8214b66edc807cf94e276af6a3536ce9c6b45f188df7a2fec79ff521845ffe3bbb323b9a15496165bd2e661d5b1f1b1a25c6a81ec7ab08b228ae403a07e33f53798b510492bb065986ae2e8d70d23c6e851ef681fdcf6ea9c614d68ba2dc2a6e818a5575ed31c1e471e22c1a641b6801ebab51f8a5d7c5fa0b42197e8eaa4d18dfb94ac9aab88458c55fc1bd9e4a2121cc1678638d2c764b14d12b35b4c753069ecffdfcca0dc33ad43dccec1d7a7932e9e6491dfdb894c252240c7af42d677e4c19d4e2fe1cc3615a8de65765ed822b5532ecee3338cbd81b48e09e3177ae9dbb5f99df8f75461dce1419b5c512eaa3f69d32e3d49c981aac76ba4c23a46ac7c368f3eb5dcff7b72521d5ae52b9ed56ae4ca49d6f9fca2f3a9318250535de0478ab4e0a9e45002fa1f3841f919687a95de83d01cf93123b21568aa3a43414143022411e351db32692a4c0816742c4448cabec7bb8db5c647df6ee66840e3413206bc862aaa9a26718e37ffd91a5be0cc1f27b9badfdefc857207c5afc958e037cf928b47964f8fe5cecdd740a39bc682f8bcce77b8849cfcabf6bbfb46178c634b3407c4a3451624c3322b00399cfc4308fac91e6ea350786195660527e4f952ed5f3b44a470e9fd04f45cdc589bb0f54bf4110423d73df13d63621302b7131f73ee31cf4bd41458d4aa1b13fa62fbb104e2c8f98460419134ce51f128c3b1cc25920fb1ca6ff88ec81e7dcea775098c9cc30b73f6a0ca22ad936cea8542b25c2cdace85145fb36d594d3c581047a5dceac98fc0944ac7a4c8c89db5110e22f3092abd2bbac9a8bc432c3211cc569675f7b21867084521d5fa696ea339304444b8bad0f8c4ed3b50d41661f53357b7c433b974e0141211e62b079c417e59cbdd74ed773c6412bb29cbfd5f6f8c382e8ddd0a621f3b9f06124e3ee7fde903d71fa8d9f5fb0f26b7bfff4384435ae7b195f976cf84abc9c8fd42a22ad355efc5a9695b1927bc14ec9a66b88e02d9ff29f5bd20264ba78fb02a7c9223b5c17d01100a6e98d56ea3cff61d9af86f886fcf79cc3edb5ca18eb4bf21b8a133eea56496f9cddec60683c1c52c67e148c31fff67ec667e5738136b4613550eb04fc398cd92a4d8ec0c5f9ad0ebaf863213029494e9d9cf2f71ff1a6b9b197ef90bc6cc09ba48f34ed873a9daf6f70809bb31ec7e5dbe2b0f92cefbba0a19bb21716b713adbaa314ea24dca208e9f775209301b906e9f628db6566b77cb3623a9287ad8ab8a6e1ed60e50c0ef877c04eaa102d431b4d3a4e899bf2eb6686e439e3da494b42fe0ee445bb24a775a39b5f481526c30ebc37ed17e71b89e0701b88abd5c3e8e81dffd5430443aebcdfd609adcf5ea0b419b8b2ff7600cb9ddb4fb50252c0d1a904c1ab2ec7668c9f7a7016ebed4c729f75bcdd72a2f99084748933ff2d4b07286c3298a371a5cc0af6ee6e3d2872e83446dd04690e797d5f6a6898486a70ae627593df25c332485b659a35844e90a7ada4767127aa9c6125c068f4ba9d608e3204a830fb3d9ff4863352ca5cf07f155f0088a30ca4b11c6029a77969b634fd8524a7060ee9be34ce4937df054c4aa95efc873701d1bb8655294fe5192bd55b7f86f1c02f16eb325686b7ea40c3b355bcd037ce26043526b073704c6af0ffdf1367d838e03f2bb3bb2aba31d26e9cad97e6a16e0cd52958c2bfe882751de37312f275af85ad563164b22de6ca6128ca40d3a732494e9c95549b9af4fbf0698422043331668e9d08949265614002eadc0dc76f134888d0d6df6ac79d2cce2a51431022844d4facf4d0062e51928afddf68ae2a83fe2cd67ba092887ee8a4a9b705289399f7000a065d6cc4015c57e456742ac260f18a972a330bbcd898c2908d447d66aefdc3713313397db476af4ac450f3fb576b887f06baeba0f5d12a0733c7d40919d2ae33e7a0007f91fa2beb19d9df14c5d8eeed25607920e16136d10ec38cd2e92f3bcc955a13beb21a409cfa18450997da8db74caf7ae7c745e0fb1798e804a2bbf578b4dcc7b24e8d97928f8b9f19bf51b1b9ec0cb8fe34a5f7e6cac3673e766c6ff7c1eb6a21ceef39f85e1f05a48c882b28cce60851bbb9e996013ddbb3244b1f3cda0050824a9c98f39a364006cb2d1f4cc5af07d186bcb88d924d8c568f8cb3d62fa45754ecf2ffc4d9ed49f1fb6f3a76d429c0cb6f709c3f28d2a6441c4fc372e6565812a6943b992bb88603e95ca73a13aebb448de39b9b3b0b9d95681bdefd9431ca537bfcdba6161820647b91f6f7f1b745d04373a46a23bff663ff39341342658dacaf66ad377fabce7e35723ed50b335a36fae85b84fe7a47c7df67a0159d3387e8e7ea7785a1e1567517f589488423b04f63b8907a85a387ca175b54b35637b5c75f5381d955602953ebdfd8216ba67b5d26c39e34af48d49c9bc3eb7949723f77289699feecb00573f8f21d1ed7384721896c3e3e247b9c49029043ebcdcebc1c2743cac89e77335577836002b53cc34e48e0b8a2df6c8b43e99efad80dc3a89b3422e4f404ad75658140bbe556c9fd1123341397bba38de63cc3b95e3a9c3f936932be218b9663722e7b3df1268f5af8856218137c08f08cfd76406eb30cdf65c4602bd9ac6e33887b8ca582d7f52bf3f87d42ae33b199645662394ed4833fee2a3cc3e7c0675e598b7b92e62b6c8a84f48c486a468f70213e7f6e1f594f6328da765e0b12c3571dfa3a35d879d23a57904f5ebf3428387e04c3d9b3ead1ecec0dbffa7d80fd78ca89bf17ed8bd61c23697815d1ed7b59f2228074b61a174e3b7b2c76cda3825c5f4dd5ecee67b3e2886fb6e6ba11d525e39243afe307fcda4e4907570b82a4ad2a57124987ac6d9e176e039de90b03e4d145fad5d36b6d68510baf67091f4befedca3cc6a160666b44462e4a7724f39f0da664cc0eb1a7f211448d7dfc24a7625ee48743693246e8d856ce911d0a33ac2ce139b15eea2e0c468dafaae9b37af6e0179ba647396e16e61a838d0ee2f031ba3acd28871fddcd232c1d6458f895faefa9d83a38aa9482e65ece943ca7d1f5002b1701fbc73b416ad9632a704f14e7e9d1af3c2eea9e8f87abd6a4464d37dd712e6eb7e0f559f3d5ef1bacf1719a1833e4f51cf39fd75cc8db87411eb97a174e4ceb1b9409c0a6a0e3080571a56193003ccd3a47423b9efcb427ab2d70a956efccfacf9f94afb51618649def45471f041c632f3e7d3297f1351bc3d34c8d47933e2fd1f1c2bd131cd3d4e2dea1fdca5872e32e9a8fc156d4a16bfbcf52e092e3fbbd55ad6872dc1090eb8aca484a60f6866c0f1bad787f92dc208654e8eac86c9f1a903f464686e654f7591d2dce2a99355073003a5417faa0f267a045d56c5af36ed3bbfdab79fab6ff6a36716b7525d2d1c5a317d676003f4dd5966c77eba7e411958c3b15af2a730e8577466cb9e05831ff0f3cbbf4b1d87fa373d53c6c0d993c3dbecf82d7e73b29c5e60a73deb424114eab03a32df4d4484006542283687bec7530aad4c8814d57dc2ebe2301fcc3edcb73df399d0eba8eef66257781be6ad681cb6d6b31cff6662e752f718a0d691a0dbff25cf72a23c0a8a555b05642aa07fac66277ebb877c430ce202d3e8cf5aed2c499f3df1d04412b52177f5f2d35018041902bff1db40eed85a72ca26d5c82431c5f23ff56623571aa6c5c88b3e1aad09500d337661a345b1ea0de4bc711de8139cf6babbefdcce158c5ebbf0d8662d57a072f23e5b9cbd8216917a5e13043227bca470a428f2cd15fd80b381b7ded063fb36a7879d8aba9a3fe948656603e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
