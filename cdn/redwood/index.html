<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d18b485a2b55116ec87c0b3dac173440f4b502e8382acdb3784f73d419ed3b5dc1efd5708778f2311bcd5d82fb4872dd8f93ad3de4ca8794a5f7ce545b4a3aaead5c86a6f89bb953857f0e8bcb41683d6ccf93c06a381d3a80e932e49ee12e8ff5ca8fce348693aa6e2d9d43b92d8c96bc4fe73148f00ebb4e00050c6ff868e45a2e1213a8aea33c965de23f9a14d8d171e9d3cebe030a6a9e580542f384a6a3e129c7177e0d7e49f96eb52591957a39924ebe66bcaafd89e7785db27c8bfed731ac03954a5f311ae1f920fd6bad7105e42031018ea56ee2fd0c01d51ca89b8b63731608edd10411541b35e30e6bf3d6a4710ec0ef949fac82e12ec22a9a5b79241a8bf4cf58666f4df0b1b2e1602174297028b5aa45fcedbc1b1b9882239d4565f50f327c2b85d12f99415661daa31d000d6cd1a9b9db5dc9017ffd7ec8df0e52628c249e9e34347c29e6daf7eddf88acf2bafdb051ac919019c2da258734b40afb76f8dd58b3857adfbe1cd737bef18ea9d7b20020165b275a435490ab6597f1a99f12e6dd6ef4535bc55d1d4bc4e432ce8c51ad0afd3cba330acb30cf9dea27bbdc221175aea20406d968eb16e8d673ee59ffafdb124118d2cfbd0c6e456857e144a866a5b5702208e87c5f66039c332fd2dff4dabcea85d4cdccf8bf2db01133f75ccbdeed976d19a4040d86b744cb36e793f15108f391a2267c78cdedbf566cff01474acf814fc48ffddfa72d93198cbb34bbd79be462deb179b9d2e9d39ad9d774de2a2e1ad32d17d3db549ffffcc151412a321765ab8916cc1b412b2e70671bc0a9871cd88c1908af7779ec4117387aed5e41598a6ba491bef50f0e990d3457284d6d515f265f65d4d84fe1680ce601a30533c28a1911a1dabb960c18ed74ec743573d56c451941f931a031ae785d5aed23904c15f1555e55d25cb86a01fd9d8da318c8ee9bf23209b8670a93d37a97fa52daa811afb50476190bd33db7f56973640780088fb3da0aeb151dad5b9662bb0af9a7eafa94cfb24b50c730e10febcc42bf3aed2bbd69becd709dc070117f6c5e564922a2facebf36a317c8ace8bc1962e32e887bf33e3628b2e95c07e5bfa10c1f27754cb68b67b623ab144ea891ebf6760cedbefaedc39e23ad075323d72d974403b5f12b336b07be5b9a406514d51fc6db94db54bc2f7f90c86d1d04bc7e42dd1afb72f2699086ad78fb1bda8b619aaf64356d9743c9a6a60764284407b8d281a7225803a06d1fad9c89db6d362eb299d7e886ddd2c9ccbaec656a49936df5e8c435b65a97c6be8014391462fe15a929b453082c6238c429c501d94fdc36e918775a5bfc559e7dca4066b854927ea3f2a300c3cffc9b693bda8e206af29b066b9805a0f699f58fd2b81f1da71d49bb958b58bf33092bac3617c8d0e8dcf57b17ca8ddda1400b70f57724dcf44ab66113ff640fdba4b525b48559641b065adb09116ce6c317691c7a73911fe85f29b841b2092a39dee88fe60d5cd6442269c0c1ce3926495df725310b69b5d956c980b92ce483d16d85fb71a863d1887a273db16c0bcc5bd619164848d78beda7f289df04c195be693f48c8765f596ff634998513aa7b961e6870271901139e20194f730a606c757d4a78e1e300e9d602767f76e1f37da9b815d22c3dc7f16239343287df71866e5b48f6dfedc5fd6a4099efff46619d07750b0d74da61d50c36de28c1005fc5741fbe3a3d6aa7c9dfe8fd32dc66b55c5ce58be7058660950384bbfdcebb4765acf87174e77a3d245d42356d924c186ab32a9170ca2c4cc5a1bbf1aa464a118a0004ebe2ab8e6a08605a82caf96b8e6fc2eb8622ea5535f90d1a8ef1b5c85c0a6d55437ffaa2441de6624aa1afdfe57bd117306eea179f764fdb39a35dfc5fb3ec1c00f25d87dc568ee1fecba825031a67a061bdc79c6e6b7efb0181c9993beecb14a46d888217aa2a7fb5c572e55cd4b0f02e68ac4b15649aa95e4d5c1644d4a73d6cfa14abd8a79f92f2fdd80e4a90676da55711f61364e4b5b37479f11285a0169a19956ff3a42ca312e82f384e8fac8a452589e4c5da85d097a58310ffb62c9070e79ae4752f69478f74d0d87ffdda599af6d43fb01411440178df624af069dcbfbaea07b396aaee6c0ac0b24fcf8dab3691f61e9778262cd03bfb2337dc5338833a8e68bb54a489630194b25b250bd5313d9f82adaf6c44f284bf84f5f4dec3fb830442fc666aee3f2d1a36b540efe4ef430a992cbcc34b8979c90518a4942252e4078faa00ef488660337b3b9ac4bc9428a84044b2e4835e19113c36697b89580d4e062b26f66a5735ab00d1f31c4fd81d992f7294d28b092ae558cb7f2d61650215a70e4759e663a823bd53e1a6665000f57285ab30e4ec05ab43c227c094d8c045b412b58f1a081fc31fdc8cd120cf86fba04623d8051599d9c405eccd680c7f8fc25016dc893f4d9d1cab91e77029b30c88306acc81220d2acfa584640103101b7d50c004459617acf13b36a1975d640976b4be44cbd9df2df769b290e940653e25db9ae01e4aeeec08562d9f53ad741442acd6e4f60519978b7c9784ad32cefdc4bfa58c00d9b44066cb3d64daf93b9abb8629922bbb2cd9d3609a7833e8351e968b2769c062e9486a59405e32d3b8f1cc96e54508dac10d6e75096830b5516f136392a2da384bdf634764ebfc070ff197a0ec565dff0da759aea2c7ea5f8e0d004ef442b590f31a7563bba40aace5aafc11c17cdbb6ea5dbaa34f9523c9761bed677818b874093f707f57f0dace518c404a4c449263cce3cf4acc4e03d6915f2f93142a297dc7c87ce21f9049aed823d6cbe04004cbd720eac5cd48983f3b4d1799fdc4994102f6924f08fe5b7b2a3d4f3381e7651e393ee585b949bc125c3468456df633eeb298eee159299dc61b30fa0462703b6c76941952c46466d19a46162128497885d01e98334246bb65c2aa98ee6f5adb0b23ef40e613f6f5240ad00bbbbc4acbe1cda56c186f07f0d32a5c9c08a4a6d050293450b819455d4471ddf008f5845e6ae038a7d5bdc25b8170c1654c97f499095975b60f9b00376a93431d3002e60d81f536befbb39916637eaa5df3eb0c2f84a7b6c34c1bd4ca2bd93a163b01a49f64a9d8357bf1bcdbbefd1c420057b64eea3a8a5377680f4bed8a2c3bb2b3f8f06645b8dc0d3e3fb21b7828bac80a983cdefed7b095e3f8087e536ee70c516eb98b360283887eae2db9b31695613d9028c8db8361fc2f3880e8b7d752d12c95c8209b3828241102d8a0d5997f58bc4de6719b61c2f6cd04731dd9bb51764dfd2ea4f124e9aaab458e18e8a0693273b406b456cde3f5e17eb2c9a4cfec144f92afc3a3465eca4bcf5e8d057da064a559ebfdeb02504c3ede274e8a021f7f9fef0861ed67b07b72313e3b4cf3187ed9ae35ec2791f795e41b5fe754361d8941011d56782c8fcdc1e251b6f91a0cac61961ab9741a51d4b5fc45bcafa9567d888cae29d62672b03b8d307acfbb69b9a3c672a7cd9216ffb27bba10c5bbe14dc1dfb4d8d3a52dee9d4c14ae8426e8c7751115acdfa92f7647fe197c8a7ac8bc44aecfa038173b0b2aba871327640e97a14c918365fd1444e1c039d8f69307d3543a3e2187c8e439fb2824dfb01f5cda57d1502243ee37ca3be4161fcc414cf011c98985b4402bf5c16f8ddf6e6c4dae88836eea5b4d3e2cdca4d7b4ec7c591e2680e91721354df6d37d1cafaa9110ca58d204a27795e446170fc7f452163d420545cc058e18843a17ec5af64d7f6196ea0ca76efa1ce78c59db019525d05204efbdabbac4bfadb2ae12120c092858e3b80920aacf0e669ec9ec8210f55ab809a0f2d95e88d0a9ffa8039e817109be945c3b70588a77a12bbf91fe5c5cdc0d757d8f16dc120a3a23c6aaa4fbb3175a803894a46f43cfd3587b63d56a48b70b90e314d991ceb80dab8d4b9178b0613a6a669f8a60621888e33ddfab9ce4c9a3d39b3d60da846cd29376dfa34ae92c78f4baff19febd53c22b35aed3e459fa47190f1950b07d30e433f1da973ce2ee6ec3c2957be10545be87107d4c5e7593a75803df3f4f271e48b200f87e471127fc8e647912ca6d86e450828c9248db371a84b810aa39b0fc7d4ccd9a8ec64536ac654a7f0be6ab016914bea3a2112a8f239c62eae87b7bc290d5798fb29091591a3c8be9f3c3495f12b2a28f065ebc08baf20249055126d780743b252cc7632f2bbbc1cc4813b84432496d6bd0cf88a7057095724360c4513a76b3801d09e327bd9ac62e83ec04cba29b18e443809f4a2d9fb4951928a0799ee4f4fe6774dc45c120deab63b983fbb5446798e59b09232b8c2da6c80fd35ec579161beffe044bfa89846e59ab029bf3839774a413dc93fd59d299d075a0d0f90799dcee0489e4613711d4101c1cbc4ddf1142170a3ea60f2842e2ce74fbde5bed7fec8c4b86fc234d450e9cde1ba2f0eeb51f756a331c85e2ff3ae66352eca70096bc15cbacb6003e3d91b02061903453fefbe88c62b6de0ee617d377eee20403df96a60d3b71dff241be1c205526021bfd00af24a618aef6611d5a0fc4ac304742834d6dc0cd78d8b6ecc77911a62eebeb1ce51059b77d86909417f5f3ef7ee789561eb3675f7f6a68a474e513f1efef2efef1b710afc3b2e627266f648a35d8df714455f35f3178ab06361c52af4e312cac487fa7a72c19d4c7e3b45ce448808a60c80d37cb99d737e99a8b313bf176851bbeed6354584e9ceb6daa9c6abb0d67b111d4f6822b18ec48bde4f747ac7d1d2c2acd3f50cd3cb2227771be2e457f17d3d61f9ecfc375d56de1788fd900299835978534e42cb824287eecbbf733808794f3d454486104a62ea2d9fceedc164693d5dfdd50f93ec2dae600f570a8173c94a664354b4a536f856af01e7998f418737b35bedfb68568050062343b5374d3ccdd0c57605c1886b20254025da62a7492bba0bb7e1f3c40f3e8b9e12f2cb77ee9c5b6475897d6c99d341bae99c0db246f33d29eec682c197754b1e6ca6472ead3248cab10c36f0d4b04ec8277cb9cd4233cd27f4ae9ec80c7563d11571faff45419b26b881f86bceac054112d8f53304591fee5cfd79d5178748936f6bdcbe71a6599815f0129227d0c1e4e9cd9c7f9041ff08071eabe74d2ad918a05b66503262bbe0940631851c42ba240232fd981915c44421a5caacff270e6316b975beabda8dddb96cebbb9fa7b9a8ff6d63ea77a3da9aa918d1bd2ee295cf7f182fb3d1d47119f8833a6c90dd842ce1af30bb7c3b4f9212b223069d5e9f9016639daa9623cbdd70d0574f1454fba551f587b116f9cc95f32b2f8589e495671c0fa683c95a5f3ea03761f01e5f070d93db171c01a22817a61f39798352bcead7b38349e2e6e5cbf0ccc49ffea80dc2fd38060ed57ea3d35bc738a1f4ad4c6fbae46a325cf7eff905dbe2301de6b59f0d11c5baa7dba256a4ec24f7e00c9d0f7bce289d9fe8b4b8b768ae92c6efc9d07edd62e0c82ecc000a18a1ff80ad9cdeb431c431ad22e7a871587fd2e6cd2ab19184a9ad53211b34f5b1e72593907c51342bc4eedc29a90b0d231a68ac496dcf502d91a7c657bf4049ca20fdcec0ac94c035a331346ca4d733b2038ac7f643027061213cfc2e8d68d5c5194a8dfa4315b3dddf3ef0de22a5821ede1d28e7a3bbd9c7f5412178c42263a7b06c9e32ef0f34e783c4847e75795f41578c4d07d7301258e6b50acaaac214a286ca9f021b4aea4a5eb6297d79a7fd6a4a93c867da0406667b7bb1b5ae41b516010f8c1d1e74824fd47b617651b461a4cfee06128784c3edfbba16ee6f5ff40128d1683d4d7412ebc4fd4b6b3a4f75e475177b56bea2bc0d4f41400b5726a4a1c87c61d791e51f52b3956275be2461aaa03432f2cb3790c0706800ca64941e3bb427b64f3c70f6d0779993443d321c45f95e9bfb259af567c35627cc520c2b1a6f81442afb2ef1686d9569ecb15cf513ce1d89dbd67e4d1d92418a5eafccda65a84797a5c18668e64e527722487569de40d85c5994dc46049070938974b28881d8dd4de87171bd1404a81ee78e3d48f680332e3318f5ff6847c19bd879b6555b11428c85cec1f8514fa365c83c17a654facc8bbe6a02081bcf996d56f4c587a43630a9e062044004f3b4ccaba7606466e40f3a0b9230684be7a9437186a211948a6007454e49d8ba6d37858956575ae71e9e9a321c4958048be1e11ed26a98b1d6535aedb31ba39c572561d8b9e89cb51488eb1ab441525565dc5188054267c4327fb1c3ce9567b8e4b140a53592b1a0f98c18cd58236519df484bc7dc22fd8a3fe200fdcf18ea63f0a2ff6dfc4f612130cf5774e57ffe174c3913bba26799fbced39e2f590b8ab9b3da3c03bc4625d890f26f760a5f4a0a57ecef4dfb2c8470e71ff327a4f028aeb9daf846a6ba972c6ba5bf9fc5b8474ba901d378d2243d7e98bc093ab2832feeb8d21f3e4f16e8030c0a2bcd01d51ad5559a06b6279b63b06a708816b1bc4657c981adf7cc34ee554981615d1fd23d90b7fe46da8710e3888040cdf68bf32a8d86297ff0afca76cf9620b0f520d5ed9a8a4ba25df951293456bd34e05f127dbd6c78a98aa986309ec379badbfe6f342ab05e4951b6158ea8095fb141ff0b3e6354d5c6161c695e6b1c580989db8eec5f443fc4c60fd9a8a86a3b23051e1a2fd858fee21ebae6e16f653439edbab13c2745f159e45eb069bc68546e2e3408ddfecfd6b46804502eb2ba91670e4bc8810216b925942edd31a2af6821090fbbd7f4dd18847eb3eaef5f28f84e9cf3c487d7394a0cd12fff21621b2a0cc490758a4c6de191a0eb86280ea35b723be2a8fcea374e01f9f6062101067b3a7acb2cc2fedd81958258cf6c67bc8f963ea80a1251eedd3dd8ef0051b3b4a42e793869c9ea0998b95b461f1ac1e481c9752eef8c96f16ec03e6975634008cae4c3d8d6259904d8e4f14f8eb7e76d91bd1c2e2cd9c8e9106c50c83abd7fe43f7fec1145f5b8926173432e9726fa54963ecb741f3fad742fd93bdebcf7a659921cf1353cd72eb5c1a33cd45af7c5fed4a401ed6678aeaa74704305b639c215ce8f8523da06a1b2af40b8b28618fca2c8c47eb17d212eeaad67482e917fb606a3a205ea557ab4659979e2586f2adeb2ef0d3b980beb7581957d664af3165e59985a269dabd495b9df672b19374a6061ae46b463cf8368dc506f8554e2132189c3294f4431f78fd566ef29c09124162c9f1e1a290951542f803275c4814db8d49ca3adad56b10f040ddc7783322a70d9d9576222a1d48cdba352ff92f45a71089c96b3fe6f7c68248a995f6664030544cedaa211c40a0b0c8a4699f468030a0fd21c57060c5504c3d69ed67ff79d93bbe1da201aa72987b516d49643d4bf362d8f681695eb03b8384fd506dd2e0add713185b981eb573fe18799af17e47b0656760de4b31a1fecc84c95075499c96aa04ca8be9fb04cf18a66b25782f2b84637583f096bf8440ce8926245c888c22709b94dce54d8e048b30db390dc5e200afc70b7bcd235a3065562344fe00d462a7bee4ab343a6dadf5a50f61f3d73f2dab13d1bc3667fd0836d3e3500b4922acb6ead302e756420ed85d471f474bc66adcc0f39363a93273fdd556bd7c6f119c70f15edda4479a9eef70803e284e37ee65ded025b4108e3ae3a383d4c75a84a05fbb837691b4e14ff380a9fbf503213ae4d11263d8c193288d3b262d13f4a3c7cde7590f67fd0f8d0e0dc045dc1fcba3ccd24ae1d2edb4eb952167d1ca83bc68b8bc54e33a74e6257c62210fa82b99ea835ce6aecf8ffe8a368e6e9dafcff90848efd6cd8ec3292ba1e32a40a7f24349d09e9a740e15d7cf25cf7ce8b300e8d88debe3b27441164809a8f4ff5af46c0f2d57e8ee05f7c913cc95b42d41a8af6c29f2c18cc938521e7f06957a48db9043935495c2832957b53f3157f75285687d12418e90fd4094af61df96ef75d7b7a917ebaa0b5a65abb030a5a86061aecfc7edf26986119c712b1d39e52b1bf8ef4e274f12cec9b70d8488016fdcb94a00937f69f2d3255d2c0f2e0532384c465be05e34319c500fa00386918b6f8b87a6bcc65cc29267f6df0dd161a8c53db5d44d2d4ff25eea3d08f9a63cba5ae5652cca76bbff84b841845e3b7f762c1925344f30e38c873c2d464b7cff9c5ef458ef855e8d51d483071c929909ccf029c7f7ec541566b77ba160f13092aebaaa5fcf88270ed7da745b6baea05ced91df320ae2c3268ab2864073bb15ed6a9866f884c4322a25a8f77f9c498c432a3723c44b0182132949ed60ec9993b0eb214dcdfb753d8455135681ae491ae948312dfd05cca26332520f9455a63a870076dac3f2176b1f2022acbe49539d7327a5dc0b84bfdb86d54fe76fbe647f6a77ff73444929a058186130864fed933a1ce153e8e3dba130d42c701664e25f8ffef61bd956e9490a8ca641f8d6da661198590179638cae5641720b43e20fb63930d0e1998be01d987d4c34031b4ca6aff89cb7ba992cabea20474f804833bf495aa50dadec5628c137c4caea2927068f53068fce97b03cb10293541b3053b09c0b9f8c738775a6f1a02c4e348fb7c902a289582bfbb788be74ee2aa8ff652d90bbcc0945ba311be58f504450e1400fed9921f083653f17b58fe1b01518bbd8110b26af2592a09e91a99729d4fe4814cdef7f48399e540904caccbc7db152ae3baa21b445955f388a7434acc4dbab7c95dca1378a45d4dc08d75b79cfe4ee4b65e68f83cd28ed24cdf313856f1f33d8e9076d06e05c8623adf9291ea5f720a27fc737390091996308f4a211bac3922fc2070ab2c0e4fa6a1af348a3f1ac7f12bbccb6cdef33b0b4f7b2ea725f6a5b8f2d6db5e189fb4f163fb85b3d8104b661fdfe0fbe5df4f4fb02be7c01d6746daa11c0528fdc75aed71899aae7badbbfb0964ee4fcba856c0d35fe3660f7d184cd3adeb543097f48c70e5d3944d6c63ee54950473d16764a73cf11c8c2df974d4386b57c509d856a30c85dd9615948b5ee7cb6010e4c49b681ad04a334ab68e2a7719ff21592804c773fa56cbb5e747f2ac06cc0817d50e0dc50bb48c13e758561bbc801f8c3ca005412767b6f798d711dea2fe81e9663d70089af6a3cf83a6e2001e4044339364bbd4a3e4fd6197d5d1d2b4cfefe7e826ca2a966f4193f32e4217370bcee016848a462093dfe2918ab6d8f8b624aa46fdef61f3c57fdcab4d6d9b94dba1c5fc8709131188582a72c8bec69abce6be6d7799a0c763c2a3511f7e047eaf39c3a09bc006ab6a1d52ffc028d215b27b7cc762fb4f5dd08cae9cebe2df299a7da4a41b25e597f1b7aeae90db597c276faf07a8276a7d6d5846497a125ae0945015f5856502d993993f667fb03893aed3ee6191d304bcc9580984f59d3a71b7a6983f77500af493033e22be6ecf5659f3046709fd5f84dc62f432b58258fe8c756cbc047c3595cbf2311d2cd5a0774c12ac28c4bc4ad541996e9726e60599a27d3d5cde26b70efbf87f2bab4fc2bac64cdd428728ae28097347d1ce8c9b248e001b62774a835ab35cce93cab74d7f2ce75c48066b91c824032c3dc45a3d84c5898b5832965af3b6d81e49a6cc17561bf0053f02289df1ca79c38dd41153a78704da5fd18870de50e6d0d685fd64801529216ba77d501f1080706bfc04fac8f5fbac34cc8dba443a450b23d14c14a7eceb6311a7500a2c43e86f8bcace36ac2e010314bd8347c1ede0d410ddab701801bdb4df3fbc9e5ab644a33418ab0083446e0f5d672b79c0167b72a9ff28533ac71f027a197de004881f1ce40c7da7550516a647f67dcfc7f0829189c4137900b699f80ee807003d50c5fcb5194345beb59e48a985b4fb95422b48ead04abc0499a2e8239b1a88c05d0c460deb9ab4df488d250045bc4bf2d35ba2eec252c6101b5884b3af45d6eb7ca8c4071e5a79ef010882ba700bf6367d8e75fd03a8e000bca7d9f408d18319a9e91c3579c053a43ee5ebffe812bdd7c458a9581cd786e06faa55b8f3afcd1ae6068bc51ceffbced35e42cf150c48a7702d0a69936def854675b46fd4f861aafe24ce98d51b721870e430147fc35c40396d4f03638484fa8f25bf40ce82bc63a8ef7c6ecd253c4796ca09b1af24a0605b30f06e596ce14217bd464123e723501a1ff68051f642163b407ac1b33b9417f355d444d9622ae7c88c6a301610a3ca7a26c75d3201c278f010cca3df5e94a4d6dada053a434f33007e5547cd22258a4935b1f02da6db7c5d295c1916cebe8641af9520ee9a7eca7e8fafdf82cde0e3a08c1f5e2fb320213c232e9e21bf1d1c92f665ea8b8c8c9fffba857ed977210c8ef799b9f19a2abab6aa6f7df5094d72e4d3a85d227dd8b26302df828b6d17ba351ea4da64afaee60b049bbf7bbbbeb0e1c0937b9763d4a82c8806940e354f33ca9a6dab1455a3aa12c9702ada1a3ccb9e80df54fbf84bc9f11f527b58ff7449d64464a8b0ee567a8d8c9bd4948ae83139e9f443f023f85988922dc6ff314e2aab756a95c0873ae6c1945258e59c059e7f294a02978b4c0ef06040441e9761c6573fa3e945a29e953445c763d01ce4df70676f220cfa1ce00259ac83518741b221446550aca7724c04c08d32ad69b2993e18742a60983c93c5e556f94e064ee4e7f0a935f25ed1bb278f26d12edd6a3999265a572f8c8f094ef3003d221779a92533de4df19f8f45b9ba0b2bd6758b73affc66f06fca4c759bfd27ca9ff42af1cd5475debf4d17397b807bee455ef9317714c8ac3c60c45f034023b3b8264e5d3938f7af5ad410f2d836ade6d4e8ca58553dfd9eeb765a37d69d87833c3372d49ee99857f0f33c551bd7a598475d438b93bea7b9c4d0797fc40f30b2bcba0b77fb9afb0e1be18f3ece1c81392633b75944811f7c212ed33c793371896bc28042d430bc4d1b9f3836924af2cf83a31a860860ffadd4b0e2b36cfdbe3b81240066331ae2f0efbab873b46fc6f807573009a652b6544d166e01baa79affa2619a07e067f4c9eba9bdfcaf0d53aca5e914c71ef60f57e34e3c8de89ccf7d2131ea512493fc54e6c3ab672e8deda1ea4849f7b77a4e2b8cadaa3c56d7fa63fa9134a5b821746810da32ba9d4c82c0fa1bfa223eddc5723d2a870854010f8117919654e97105354eef26c3f42804f70095c33cae4a7daebdf3aa37110f4e63d329ebd42ab0f0c3c3222895792b29c3f8f801cf3fa9d9a82dd0dcdc3883d0e1606864057e91c2b0f18bc364151d38ea805c6bf037a1a2259ab5f8fbc2568f6a89f5046578563b6433921bcc36e85012d5d3a975c8f646cc00c8147331870ad15d2ef4524384684ba494273e89520a817cc585de28cdcc84ed3419b0e3ec45dbd7217c18b702616cb6d1bce1795da0d83b656b06af4f43946dbf4278a1eb81bc0213e2912edaa79b7928f095b8d910369b3b176e281402620b1c7b7df8eba85ce71265ebc4a7979a9db7824ff36f6799059ab37eceec517cd9737adc59009cb091a15d12838cfa5b88b98ad9b54a44763b3b2ef796f4ddebc7bd6203f8b02f32510262c2a97f105a417aca9029728407aa2be6a77854ad51758fbc42114b9ab1cc13ee68ecf53c4f94b7059dcf618c8c5e7aa72bebca80f079881e35dec2a95754afae08153217190ee95c62498869c0c4d514c27b3b115f16da53533a67762858c73f2a9e1ff1175deeab3e3c95405fc03159867b4b89f04710ed769aad6a28e8aed7b88ea7c7e90243f3c4afb00af0eaad1595ffea9ee99dbe87594e33349302cfa3ba5ab9141c2bc102257a6be0474495db1109a7f48668fd81a36cfa96750334343baa7a0e1d09fbe67ce4b216b7cb6102f4a63d2ad5d5941b8b46cc28a6144aac1a83f2004e3ce523a8608138a83aefa958447ecd1e34f4a16ca085401144aa2d8d223e2895c36c43ded54ba161aabbb3f02ee339263fa082e167ec25323c0abc6bc2762fe39d5f73487b50777e84394a79b8ff03744318ee993b3637375ab7cfab2c32d032928d9e8977fc677cd428dc7f61908a9450fc681e4087cef91b33f04b535f6c276cc414ee2a63b5280756814e0dafe2709f7d5b30c31647545d8d4738fbd115228ec3cc94384cf66bda4901126c1f764fc4a31907ac731e2dde3a5c39a9531d6f4f42277e66d07301a0c0a3bb0f21923bd14767701bc43d0e6f9e398346b12cf8d786ba2ba14a5ced0513287b4599541edba46597b2244bd5f08a939bc2d7552984f03e2c5f9b605bef3c5cae7838450595ff493a24fb0f3b40b1a5b046660cf28a5fc12f3d664cc8cb6975d47b4198e3cda83fc9262ed25f53ddfac3f50019348db0f4d55d330cfab600ed75306240af4b5e48eef4356105c6c8a94c45a43f6de79656c06a76e5d620a67d08e8b279e3e4120574709f66388bf908411b460ee6ea329bd7d5271b194121fa7759f3be965103bb0aa58b66ae7152229e249d5448069cf99bbc0538f6946489651eb5d60ded7d4bfd08e2c5d8b0e53ab4b64eb582b9791bf5898c4f0622ae06ff255e3b75b979ba3a40d9cacc48f789380123ee0fee3c7cdc257328d224f7f21fbf5cbbc96f3a229e223a8b97a730be68bb8ca711279e702b7c6a9b4668199aa0da822c70b2e2164169fd971a32e99615b556f0a758a347868f4a50e0e260a57e1104499d720142b1be87e73b82be465e42a46a309392df08b7dea3a1ea17e6fd1c9ff4570c56ee83f812cba126ffdc462db1a2f133838d70346865a8be00cd31583382aca0ccfe2f80003a9ed7a262450e7675743673b51ea6799ed55c7ae1627733f1999fbdc16afd6a2ab1757e36e9eb14f55788abc55213ac453ab1da06876ebd62342ed133a1ca51d8f83461d6c169d0363f5e60ec134dab09b50ec475c699e14abf637ee3c38ceee1294abc72e7ff5e54c01d378b65888c8bd1fa002f06aa34811b470a4a04919ab859c3f5542a6dbbeea40fc238c607101fc8b9b5420f04f2e803f5f31433ab59c354895f8c6d7ea917aa55aae52d205de78d591ac841212071bf7fd599e9c1f4cc22299139f3d72aa15bbf71db1e1066f995f4114252020c2c4057b7bbe0d8ce545853783bc4042ea373c69dbbeb71e9998078ea5c99a766967986c4c889a6b32c66c963547982e0db54a768d08d5e853b076b9cb3e1f6210df620f62f78818be5e421039facc5577bfdf242f660fa326e030f46e7ea5b5ad0c661cd50683a096b61c7cd62e5b763c5c3e9224f5218a6bad3461c9fb685fb3f2de0553df437fc7919d2c28f372d9fc2284a16e15ad385d9e3717952b07aa0ce72472de226993f5eab29579d1e6c8b30f4d142ac13620f5db1e763ab81a973d1d4d6d2c9aacbb1c3837f39b5b730d1ed09db443a1008268065392545ddf185d2ff320df2eb6c441d2734d43a94cc3c6b5791a44a6a3fd1d5e5e9c7cbbf57328885edb3cf72c3ef244d9d88727c879bc6e9b1817fdc1d526c8120dd0180b500905305fee8e43351d93da104d66030e3cfc0a784cab151e94512961dc514a466971d095cb4cae3ba595530cbc28c97ebf4deb492c404b18f8348c35bd4a60c5f10072f5db00d043df4e4ae8abceba40aed8f9dcab9085f972e7d0f25e84614c85a3a8e270f706ef2d36e6b354b5c945476f2ba066515a40043254782bd01ee72cc1f6e1671f9130fe58ba4d7a2f00068b53452bc4400f7e7905d11c672f048796004c671915bd01f657cf2c0f2abd4e76eb58d08779575ed47bdcc4d0a3350add069e66cd96ebe20215328d49ec4b74e90b2eb48d8c2111473cde60b3346cd4a21fa243f9e96e138d27eceb4d8ba39df03ecf4626fadfc5929c4871a11643f3b20e48b3eb2b007da60cca5f75681079a82fa65e2cde59817d3c6cd83afdcc046afb46dce585a1a521b13426e91f53e834bc2ae387b6073277404685cc61b44dcf42efda87155651c09de3e6b08a7dd9e7f1d7689ebac5f9dbd1ae4e8fb748b46aaa01cec7a8c187d5c19d0e90e96f16654f16bb76fd5992a8160a67fd5d5e4d2554f0b62f7956871a27c874630958fb0fd6a8520ee103c7c33d1248aee90b20ea82fc23b84ec3c17695dcf091b3e4fe1edf37f9e630a3088a1f97f4a46bd0171625db0fa062c55a3635d8a5c8f65e0194dcc5e58bcb6d9a0777fbfeb923d99012a986a7af2ed1d6d788a5e54d6fec167db4934d3486b3edbc373b8fae317530f1da83496b2e3eb547e063560b9f319ef7375829ceeeb2f339698412c21942f12e262e6811726684d695bf3dbd625390e04026160240d218fe13f7a48253b3c64010df11dd5e00cc6f67af813b3fdc46e7a6a4bcc46687737c26320c6246bc9478abf07e6cfda28bd9fa487638aaff47ec5e2393603580956d5278a3d8cbb71a1d234d444db9933863087a41e5fa4e5022de293df65eb3bdb47cd6a9c16775e3fc460391c86840282182d7c164ea4fbb908fccbb1e5b042a49a2cf8eacb1985ff2d45bffaf71c7dcfa31221696997ca147655eb12d33c5460858514aaf6d6f4b803f2962d29c1e50dc7427269cb2f48b2fc65e912034c902e351dd8e6f1e93a1b756fa14ef3384ac426acb262e0e88c6cd96c3fd790d14e7ca64ec0589029cc854226e9c984e161d21affa0c27ea94ace94c71823e64e72099d2c49ce1a73c2377bf16683df6eba378d6edbbe3a3b65c494226ee2b227b0f84e692fb35f9e3f192601308c4df186dfba16fa6c7f6189a981dae2c701fe0899769d970b41514ca09b3fa974ef2f7cc73465f61679bd308aeeb060e128656afe2c98e9852910282c2486f9736ebdc7ba5fb4459b9dbbb58952761a346baa586b1eaf6879c6414a12bcf602a703180ef0ebae29589c4648cfc50ee3388b928a65a03e1d1088be64d7d0b3ad18a31568764d40af98dbb04ac010892c69c3a9f51d45290e4da20aca3282d903da2ad532521b2b34154ffa3c3b77ffcd435ed8932b5665ffce8332967daa9effd5e0f11964bdc4c2bec11fb83d1c00ecf788e4f4a25b6d1d397c32c6c86af6cb4820efdcc2fc2777702837f8ea704121699473df63af259c4cb42edc5cf571cdc1447d4b52f80120dc5071af81f672c6198d275833500d0acae87359a085acd883ab28b1137d4acd7b7846ec739566745b11dbc6fcdf546d007b22e3a5f223361476729a93b76c59399e6123a95f385a255a427e702236dec204a1e28f8a4ec1a5257d56e09438b28467d189b3d0fd535dbdccb66276be9617003f82a254f65feae8cb6ef974bf54f0f3326c09207597819d071102a5d954c7a58901203a41f8663b9792020b7a0a79325709a754107e1819820887b8abf282e758c545aa1297caa3bab2605cb3fa9f2132bc4d29482e5c53f8955df48183a640772fdadbda67f426e86505273c85f4fbf18169746c21ec83e3e4d4d9976afc5e44c7c1dc4b1d5327f816903552141b7edb3102d6ce96e4dd7916fe6ce99eda443ff5abe7dc9c55f649318ec4213ff32583e179e039c43f3ca239482eafa195b9e29ce11cf24a8f4e801cbcffd35f1c07b8236ebf2c84ad3b387d34d822443bec46bd95104ed70bf582d6c9db7e176e381881470ff7844748395c35f25b8c418385141739f534d431ea40fe8c3cab7a4aa2ee797f41c96d30c5582211c007b7f72d5e0f064ea65dabda6ba6f1cdffd1ce81718538e82ff3d42454feccad878a19c6714bdee91017337c4fe35102d2077d77cb48a82fa855bdf600d81eea66ad7ee0b8e519b6b0214bffc595b9a3914ca0571b717513103f9c09a7fa963869121345a4996fc8310afcb1b5eae1a4d103f8020d71bbbfca966acce4681c27c1f7e06df08658ab9352ae92a5720d93526f84f00ffaae42c02aa06d279525b3f1b392fcc2774fe94c60afdd1bb44f5f63caba0188b4378e8bdb39f0b9c5760d783912b29387b9cc2615e90558cc2a2ad00b8f535bfcfd953265d9f8fe387bb388389d156d61048f364dd5b58d515d0ec9c02efbd1afa2340be24ed49cba076109d7fd81a18667c2db76c1a9b1c57ee9b0502df4307fd27689a5e88153ebd933b3526eeac3a518207ccdf5acf7c3b365512264f62e6636a5e5e123873dda8c3b3ab674267f169f868b512621efcde6649e552e880f7a684646dd724407af9c501d792c3d68bf79adc514bce77d3216349444649cdae41e0ed3b7ff67c62556e61da5f2ababaf65195051467e59b01a1b9b3fedbd184317f59e476a8151e1acad91b06e80cd682e74270cf3202bd47f83fe29151d1015aa9fad1e163f0597489eacdcf4a939728addf8b3baf5fdf243eb94bf6f4ef6ac1772474bbf2b494c6517a309868d9728820074006326f6040f346a9518e3bcdaf86ec74a47b7b0d3ec5a13adc3974c302a4c03186e1bee96ba45fcaa850293de9fd61b60495b5315523ea08542e3bfa31d49945f86f8205e4016974cd9fc7cb0f5811ebc3c5930807356d4d0b1417e077b6a0919ddf7322a7910d56f07a4f0008fdce40698faa4dfa82400850840085b3104862e6cb297fc6d9fc8749ad7b843f20966ad76b07fe71aa58a43e91d97bc1294d5d53e7547fd2c2c2dadd22c24f0c44057a76a3174b3895b3a3f1d1fdf5b6add164cb9f7180c8557013963b93360be405bf39724eb2e793735189987b94070bacb33f12f078b54791edef5c40ef17dec742721a563e176ff6c17335d63aab60be7fd99389375b983aa50e2bf71bff9d1aa3d54f77e8c43b74aa288159c7d93858c56cac1518a153ab49db3c7f9d68a9b44b978e21ae5ebbc284b57907dbd21b9fb825251ddc0924cb81c6f0db5727780984c7bcf70d2a6a0943c4a052ecc145f626a042d36d23669ec1fc168a249f0f23e58d42f9c04339edf0e4cb9d8570a98b6ddc9c25053c3461fba4433d415dbb05c66b9208879dc972d47d60bb8846e65bc83465f8b4c9f06c7e339b085bb311a8eb41d7c32ae7717cff7ecde68e42a7657c7c8b03e7ddbb3c744566139aba44131fbe63683792edce7d187f6fc9e754a1760fd66022bf8d26b7a45c46e7c79b144b8af1545bdf63a9706bc38ba2d50c9ffbcb2499e57facc217279568f9663518ce495b895463765ccc86e032f57ed32ec555f0a1d791da5010d6544a7c6842fa0d032c80dc290c82e66ea3fd43ed2acfbb2e5619c8a84c0a33acd31e275a725945db9fb8f08da1e1ad94e02a2942629b80dad6745fac0e60f94d904531f66fc0cd5a1eaec5c25c051ecdeef0c168fa32e2bd5fce6a5e560cfcac505222a65dd6d1ea1733bfeac98b6169e30478e3693d3e223dae93a160982a775ae69acc279e3ec77ed3a2357f90e1b578561f5854c70710e52f5321b5f2529f6ebb0799566fbccdbe0cd259548c9546aae95e09fe0a40dd4facd70009166f1d897de071ddbc00f3059a8cbcba9fc2defee1e4155e8dabcf0ecc55f63430cddea9ee98edb69fac1af24641ea41aa78a4a6445d7c373495c1c057f1ab92d3c944e47960015ef64616f3545d6f2b26ae97d0d3eab7458ac5da72da7663d60d3297ab2a060a1402d36bd831e33d54216a89d5b6db2f12aa147349ee30b6fe4277f147d947a274a40cf44760c5ed46bdfa5aa1940221853edaed67e6300b96030a46044599c2e1e9a5fce35a7b731f02b542216a12d2d00e6e5f37028030a07250decf22db4d908b9db4a866bca90ee27b5bdbbaa3f8c96fe34b03b0782d1023f04f4060db5e53b09ded4670ca43356154b74e2d831baa11efb38cf3157f65939237bb7785cec5a87118f8262216244305b81710de7d28aa97f9311ff3a80ed2ec55dc36afd8bcf884bfa675d7618b559b22d2eab30e525697b2468cf18d5b120b2b937c84b1330dd718908c46d2b996d7d717cd5770476e716a4688e78e38f105300ef0ef88b1f485abb8e604f689edacf30e12474bcf4b2812430b18ffd4f3df57e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
