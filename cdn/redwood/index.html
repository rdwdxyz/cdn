<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0f05a4816de0f3e664545fb98c674e0305a6e9dfc0182637328a8f73f4d36c28e191f0c8478b16f7018c84eb5c7823608502feccc602fdfb4206431e96b2f1638bc2f00ebe9b6086b2b729739d9e2c90d0d2c5db5767e557fbbb8bb10d7c44cda94d0875b8f11d50a0d6a7963d3082f105df3367c46c68f627173f452a4abcda717bb1e9752b0586c560c7589decb1925a3cc7130afb7a1aa569e74f1be3cc6413c956ef1154b3b18d7420eec28ab9ef069962cc210aecea9cf2ac34fbbb028864a7a1e040795b7d6f66ec9821720eb74d8703feef35c2c025ce6fb5029ed27d7a52bcbc75cf4faef438cce1ebfb9712b36355971116da04428e0c7c9e63f0a6f90e7515787a23126335114ed6e9dafde1959d0401fcd3686eed0d0094338715bda00ff81622e8a8a1bcd6feec4ee9129f867997c3ed8ff173e578d6738c08dfbe31001991e5caa254dbc4d0ebe4bb5c214b3581fb65a3a175ed01b3cfa8b0c434cf15850ce49ad6e53d8d4e3820c962721bc0668e9da7eea22e0e6fd5d2f8813f1540fe781d66760470f24fed0a7f2cd0cae6e7b865f60e24bc7ccedce6fb01890d5e3b4dd6e5a62926bdda07519c07f89068ad4f2ad4ba1ea3ce7081772c8ec39d5f0f861787bd1daeaf4ae82b1874c0e4e2eccfb17a7def3067325d5e8c6b2f33c36e6007b0c80598a7fb23682360b922a028a91d97d2d7e5a6603acf1182323c7fc525205c3697d5ceaa51dd397f14a8db91f5faf8534c465368a73dcd7ad72777f290d8bb9ede1be98365274ed220e0b8d9fa27d0673cfbc179b65724386551f262e0fe4a2eb05711d150e4aa98a37e42578124a1b273637f995691149bf3012ed27c4fc744ea6b6faf2fb9b99ebfd74af2776b14f333bd251bfc642e524340793b3c3b8ba11598efddffd2055d15aba2c91b81a6de8ab702111f006a928e2519e030541b80d199a9902422ab8860e455ee96c1d9dde2ad7b08959e5fd1a86940f7b1f4b50aa990724094ce279c7f9ed639611d86bff7238b8f722bd35767ea581d4e27c860d34dce84b69cbd9ff23b568c4004e40d70529951f91c1a5edd25acc320549d2b6540ae89317597c16b0de57e25879398bb3771b4ae0648046d59631aa1b342b308c75ed47be280d80f4c115e9e2356487c688d7eec74d651bf0d889e9094a0a05898a56fc19eb6f2ad2d4ed1bf9b1a6c6ed12bfe1c7fd73145963471e35b2fc7f2e263054cbedd5c065c5f503c56321e56c26d2a11890d3b2d43e336458e040b1690ee85c52b2dfabbd16fdd9ace039ad296f54bc75b0179c53081a0402aadb019161211161f10e6a83e77dc5b7e96ae59e2646b4fd3fad245bd15346dff5433eaf3aeedf21fa63a7757e4bacedc5372f5fdbc23067c5c57883db2155fefdd43353eb1fbd78d8c2ed4951293b2fcc462d70c8740a1f49d2611b07ca702ef9a492fb20c5c17e1f1cbb912fcc8313b9db8daee92a706e00107783a89bc46f0ffbc1dd027e38f20f0e0d16282c471e2c0148fe87b103f62be28c39eddf73c292b6eaf373f23a8beedca0ec57d644b6f7926e1c9b13e28f6ffac55e42f7bf2bde812ecef5fb3376356327fe846946ef336fa01fb07e546b95d0bc8410705119a79f285cfb12eac75b6ce897bd9ac34947e541901dd38f820dda39c85a24f1d24176605ebb183584ed32e53b4680fd14691cdee84d6e60f65e7c70f2d38545b391534012354a27d840e873331e224e67216d3f7fe309c4fd432aa802a7269cb8bd77eb79a1a127ba8357932a30ab92e7b233fe5d525c3da664be42070e1877cef83de1ca9c7a1b8f2f23f5db66e250ec02e5894af03f3ff377ff14978ea03b798e8f435a61629fc5c20b614e527322e8d76014087a8de73cfd79cefe9cf0573cdd94f3edad7cef22f0aff7e5e72de5027a57f2ec7cc12258aabda0f08e3b2f621906e1511ffa7737d7f7522d4e9353febda7966f36269b862d55c6a9255647c3019cb33a60820cb47133652dd3bc0cafba4879ebebf10eae1650822b4f0fd1854c6f707a27b63606c723efbdc953bac97f368e8ae457b4d4f7e4b52d9ea21ee024b20d362ce3d385369d4c7b985a2a2d90aade0207678cd00391edd7a029095a14fa5b8b24873b089c0ab64374fe325fb87fc3e5cc112b3edafde130f6715f01066ceaa98314ac9aff9d65eccd5bd522f036b072c4e86cc67df664d533626a858d0d2e4292dc8bfff2839b11b6d4e1559ba438c11f44c3295409d6d7d08f5f6da3c3d56902681f1e3557639268d7338cde69e0a0b173c67af5eb505fec980b6cddbdcb65bb5c15991be67b5142d524c13b361043b7e53915a059aef76ccc80ceccf1d7bd8ab42477adf537fb319116e6bd632e8df8f92bdfe193af544109fa930c44abeda379b01f69e13d2e76b1b84970b2421231bd1e6c5843fde35159e5e014708fd392ae88703c2588aa558d33c527b45afd4e1aa28a648b1b94c76fb7872ca45c8f48f3d727636f52524b9371170d03381e3b2b777e90c54faf6e23d065e43cec4b5824a048f54824a97998750a9bbd59017a42ca01273cb50ca93701525da27c0702b2a6e1ffdade2dbd9478b9f3c2f39e4c9be6ae98d9ce727675652ef920b180b6c2e230b677b7f91d4475ce5cb51575c33d2ff1df86045ff9db1cd337e78deac860a4f94127e93d79bf65096833bfe761c76f7c8ab8ce7e817f3eb9281dae2c4c80b648ba6a9b727d36d869d0e4b9a688315c15d02d563bd3c2b41da16c898f356e7d000fad5209d1bb614667aae1fd23df502d0d3d1566bdf71424934a9a8357a1f692793510b9f1a254db18bb1f3e0915633b49fce540575cb66eb475100ff68b05d15ae1a04f7155a40ede46ae8babae3735e7580a8a851729cc9aba3597677df423ff977eb121d1d3e6dc6dc57ee19ce3e59ead9204c8d56f2151c2981cb83f24dc825552c3967b6e00ce615415163e27596483c82a18f06b5f10097482ecd6407d445055620865f5cccc3f1b77d4f759e03ba7e65de6b5cd5e9b02f6e8f306d591f4fd652c489db4058f89b514dc1fcd3ab4947c51ff4730e91c66faeaac7775bc198a57f75ef2d82832fab61f19c8d2ccfade855cf5306e72083c016a29b1a67ae7c46ab21c899377bfcd721bdd7274161fbbb8a41645767cec41bed2e6de21865f28fb38c4be67de90a9b0c77c13a940586593e4de66e611aae334656816e0b9d8d935f7b343eb63d5a6d893b6f27672aa060db074b46f9c2dc0caa791de2c88bc9a1fd256c26bf4196c8a4ef79a447124cd91459332c1e69ef441c0919078f420c36f0156d55b0eaf5875cb32a0a0b56a8984c16e3eb85a21fbd6cdd89d33151fc1c13990e50e2d85b42043e2a1b28a5b281921c538e8be3e79890d6a9e13bfb781ceafa6e58b359dc2212bf625e6e171666cdbe3550b45502868788d584f861517c2c63a032f677a5cb1ef9b9d7b19ad92883f9319d3634a96b9a751a08b88b3f30f9c346e112ec5cb38e002d1fb1ba9b4d7bd5609280dccc25a8ad8b715b9a13a83b6f16d68e350689c2145156bc3ad908a5461b6356bb32a9aa1009a4d33cc4d3c60ad237117a2c93c3c8f0a01a8f14c3b5d2c2e8785a7fce4e3370e411db16cc4f76c2ded05c5e0e2652ceea9d70ba242a294fc7f834f30b76c731cd1c50552dc656ecc0a5c98453bd6296341d40969437605aaab181cf3c1af0812a7c9ce98a83a8f49dc67ab265d3a92103742a2056ccd45824c80a14fba3cf5e0c65e2a697b6a0cbc541d91b33e318eaf62cfd0772fd025ab6df4e88a7ca13288272ab5c1e021531c697b327e7484caed02ea7e2acc13862c6ba62c3c29ac4b13d6f1135ca473e690b3675559fd121791a20f5618dfdd3470f229575821f3e3a7934dd4dadfe337eb9a9a330f9c8fd83863276d5164dc2f5d01157f15f012e49518adbb890cd17a64574a3c1d6709b4de4e24b323f9d68dbf4ffeae0ed6bb86a34b313e8cb25823fd70bb23ccbf9c1bb4cb7908d733cb7ce21a471afff7b0c545e1852b7b558afd7d1fca77e25b72714b2ec615f6e3a5e5a98a3fa9bb40d7b5536318b77721d430e4774940f5bbb56174f662f80252e5a0e75d716f64247c3fd96c7a38e61d35eb3e4d2edd9721a938fa39b37670bd85588b11e0d17752cf6848a9e5866039361c950ac79f5c654990c580921df9bc0dfe92158be9b369bbc0993d3600915d1e6388c63acfd6ab934163f180481e58209e8adb91f909eb8bb22bbae343331879d1e82f514c442044f5437d2d2413f21476dff6b0276fc92aba19dbe177189640f8b4bf49d32bdda9bb610829bfc1f1c1106edc269bcaf1497c9f96ab0212edfb8b3e6f0bc584910f1c6073c8803760b23ad650206de4454a8c4c2ce1ee4d63e9e298d777304dbe82561d93f5fadd3e834bf305fd1a0e91f978e188d3c7958bcbb54f98fc71d00298ac696f5cc846dc91b4fc7d63c10a7f58c788a220deefd7db08b79c0bd8665212af3e81a9c8eec4c4a099fa70eda0f1f78b740c3881b9a506e767a5ca98d5b717b2bf359e553a5f95560cedc6fd09a732e1b4fd0ca15b9447a87a01f4f7b33fdab28302693db4033511ec30ea511acba054c722cc8bcfbffc9ea7eb080cd12cbc1ed39c5b5d151b1e71151f01e8b0f344e89688dad10247631ffe45974e484e9b60404485947bdcdbd63114e6c507604a87e31e0fbf3965ca83bf922f6985fc9235042989375d6a071e9d0c53899edf04aee0fc4b5e56ec1edb8fdd51bcff0f24fe03644782abe09ebe4e0d9ee8135453207669bfe3c371b0b6726e100adfa96aaeb0508c5c04c59c83404f96e9f9ca327be5947ecd4702d242c987ca0044bf99c707c9f215eb3707e47f8d2a30cd2e5fe10f1df3417182c9f40a449a1a4cf8ebfddd13fbc911344b11b3d799834c840aa968e86699bd058b46347b56285cc9851fe37dc3b42007a0a1c1e200adeca11f821a8474dbf56dfba3ef37831a6440caac3143285bde2f131ec877618782c34bfb84ff4a109b3825864870f9599ee4b92213761826c023a71788ba877efb0f4fce0e4fc0e21fb70739440b2b1623a43b6ecf454ed1f5b1091b5b9819843223730affab3fa5583b9b4ee1a97347b35757573157085a6736c4574b9fe7adb13bd22b96701961e65d80561e807a4caad556bf470bdefd1c72e136730041cb494a66c6a6baede6f776f057f51bea33745f8ffe31f315023422c6d83faf8c34610ea2a4ffab7fc38acfd46aff369ca5ee0356fbad1ce0e119a6339524446c3c454beec7344e8e462ba57cd1a5b4dfcfac487bd3e310f157fd82878e3d6cf55b0896bae1ee0a9ca84b419487115389e5bc46fbd1b7688aeea49ca5026b000637e8ff4879051d7d65ac1ba953b20983196a925a416ffd2139be20da7ffbea75f03731dc7167a599db5b60c5befbba4e36be81bd141bbba682985343b8df0f0b8fd53cdd7191169e9a778d51714de553c2a378104d4119b31f39bba55df8078093208cb27e67306ad214883807e3d8979629f335f200084ab80387b38df608e30881b3aeaf671a29867431a37d6b842f30f344ed63c8b0ff4cbadb92297735d0263eab514b5377a677321fa33a13d3a2d03d3b6ec052cc52eadae56815564dde088705cdd1b59a6a31bd8a64907d86ae7d2d8029577d97cb31bfccb8f9e50da3052f09afe2ed5c4701d72fc9e3b3045da3af0b3ac5929867c1edc3b37b38c1785cca2b6a6ffa3ac541b777adb0dd38dacd5d400044adb14217afd85b51fec8e8051d4956ac3647575967c7843fba73e4852a9b6db5cd62a9fbfe2ce0d535aa18896cb05846acd2b80bebacf8079e1840b2a665a9b5c3bf003e98fb220ed26a24604a0f4b17358581a915aebc6e3b3dbb721e9fb330feb1577db7b052478e3c4e4e43868a548954bbe4f5a9735abbf75f7cbf92e0672ffea6e94b37fbbe89e60de830c585761ad7999c81cb926528daed43f01954a952da2cb582d0c50485088da1179f9a21a3f07ada757c08bd4bc1c3ed2b437eff7e69c4e52fa128aed515c725e96d218e724ce8a3befaf08e681b6cbae86e35735d562d21cdd703982feec2900953b2cd8847090967c627809aea7fa8acae5c7590e29df888f3ad326b4c046fbcfc0c1cac5b5b43fef05ecbc48dfb2db11c734c315791ed2d946b8c6b671cbdc7c0f02ae87c0efad1b4936672d3c19ce341a8ff57257219197a6c051fea6abda75e9c0a050d08b95f9ecc6f0be274fc4fc0e35ab35e96b78ca94bc5373c5e152b66b4ed5a449e8fc65b741ecbe60169d7fb9afdc4bb9242daabb7aabb12bac9ca10f488da410fa043d6c92524d2f1d5165b245e00f8dee32fadf247a1d885d2fd1e1516d4eb6f4df40928b7482c2ab833b50d3315cad4491f481e7e9640ce044d5c378ad845a1185f6f0f09e70531fde7551129cab8785e0dcb337d8223c0f88ee0a7495f5cd2fc978c9e0380628c787d49c754a0db014dfea1f51b5f171f00e5f018b7dff8beb8ce12b110bfcbfde11f17634b8b6d122f902633fef48071a914f8f995b880d193d970aa1f63898e926cf2ff72026711060d92cf2a34f61d04553a3e7f4be590f1dc91802f7da812639c84eb0222bfb20fa242cfb1fa7ba3a0040716cba0eeeb38598935596309adedb34f170f8c6011266d8975c4ae55dca503f51626917620b17f5181dc8f6b2312733688b025613e8ca00fcbc5e9a11809c9df9ff0e00444e08f3093a6aae63f782ec7661b0cbb681bb530ee80031501bebdc23d5ea8880ad40aca6a6df45b57747b6caaf5f7024323f4a12afe6a98a6d950ce95ff3c600d28fcf7e5be27e234a33dc7c444731fb6e8225c652777b2dd2336348b59a06919e44e7dfd410b1ad85a02ecd3457225615d845bc75c3f1e3c29f3ae7c6cc18e6de9bccd070a00faa9abe9feb16edef97558f936724d42480faeaefc26267a8b4ffa286755ebd743e21b6254c8bd3a373075165f2f309e1ea980e49f6e4026b881be91ab9806c38c7db80787b9cf2b85a129d399b74d48d2a448d2c9e710755af7885b3d1bc1041b0792d2ab160b2cabaf5db55ba584d55bedff1ea459a90430058f21e08d728b3edf821077d036106ffcdc855f3090b0e41e92d84665ed1f783e182c634d704ad106725b56816c1bb738136fdef20e0c9e2063824b2828b840524f372d641787c075cfc029f974191db10573bb081bb0fbc2de18d954a3b62f9b6bb07948e71745de4d62dead9921bf07864b0656a141f5ecac4ddb683a80199b32da61709b0bde638f2b3e4a8013cd995b7a0e1c1899133cff320e94d8caa4fbc9ad013e88177d181e3d42d751e30f2ff32e06d60d91c346c37447cc26dff16de0c9c9a497facacfaa2fd92c841820a9bf1e52d2ef9cd3abe19f5c03fdf5cc2aac49851bc51fdffd9f773477478430eee533924e2633beb2f41dd9fd919b0718bf4b7e7a1fa701f231a0dcd2274b90a3710d44d8ad46a579760fc5fb16fa00c8dd935f442f1d4b0cb76275b0621d31897a6f9e87a083c34711b7389d78ffc5fd37e14d7b34e1c94ffff3bac048a115853eb70f68107ae8650a0d821afc1b8ba45d409dcf0148b921e07e59206b15c7d46347f630107f63a1e882f9f0de8d23d6cfe9144d4e1eb33074b68c91b0fec3f0023eec256079f7152fcb12e790be91e858fe9599880970a5c2a8fe1690550d88501b509d159cadf0d0b11d6c16d7cddd9041f16af04c7a558423b343acdf175b4d5f514e2272e801e3c4dc193ad6434ff991822ecf05016109eb326b3ce394f7ae9ba27f6a8df6942f68be32a68feb9540398f3085eeec3d94ba45ce2f49e31affa405ddbbc2daf9467123a442bb74275366eafd7b2e442e2c047d2ca8ea9a12e6818ea8055416ea9e17dcc155206fe768a50423e070c8d264e2af162add94d8e20c8b445c9ca0c772f53c7ccfb2dc5fc95be4077ee8295e52e653a8b1cf7c97408ee8a2fb2c1b763464f8c6ed99b3ecf88fba8b08094c3d3cfc7fa82d8be6ddcc158472c88560ffae9ec461db93b0d888e7f25c6a4931c8199d944c746d954e37610113b6397e3f8af16bb5ac079ca9aa1575ae6529dd8dc2aea6d5b87986ae36a2a2106668dd47d9502f4bdf6cba97c38bda414d9d4e15ce47ffce584f10d543a852df36bdd686c0157cef1d32ccf8120bb30dd108350b211cb67bd6d99ef3928cd0cdebe9d17b784db9b2adcc5381c572298d154fc2a4e51f1136947b790fcababdbe339692fd3159b76b04f2635dd6488ce236ddc6f7bd668b70b2026c0d1adec1ced6e1327935781420723fbcb8abd9524955f74d8ee4e6fa7bd6aa131538a45ea48e3b48bb36a5f235f61e9d26ef6140885975ae272b757c61247d7d4239d39d69022403d6797184f5301fca75b3752fa52a75a467e10c74f975466f9b448d53f195a94c016037806d455d3136c578f842e27820365531282184abd548f56d0eec9bc6e15738669c95a8bf6282143c583e419d2ea36cee66c500593029f30cf8498a47ca24212923ea725d3f0b1361d51268a522ffc222a42556fbe3069ac427ad531fd8f3351943b5d563042cf4afe5b30b684f3c3c44d15d6b5af14634b8c529418399a73442af93b61694a88da797e78525cf73a6344c69ede215aa2277142b56bb5e64897085b6134c9a821b82bc70a1d51e36b937004107aaaadc3ed21e49014d73dfec893c2dcba7e94ff6a3398ae96b73f0cb265af78832805c0bca18621e9c80947ea37a088c17243771a1d23338c45ea5b5985e906512939d3bfa37040c209ad3b4b0997e2c90f10965302d4bdc7a95d18ac6043aa319a792e9981c6b63ad13f60bd52183b849e15cbc19e11d04e490cf714ca798cd163fe9495c70e54d65a804229dae02ce6549f90da7461fe4c54132e25ea754958f7cf37e337c4a07b6d26e53ea1ad8b05e28669a10f2e54cfe696370a0b2157c730b31d7a24011bc0e07a856b1917343b2cd8c4ecc29a2d6d76cef4f8e090d88e4664657425615618a5017cf80fd5665e3d4fd81df8d7f6f39d96cb5d7f00aa40f830c1978297c356b617cf4222974e74559c25eefba1e44f967ac4cee3c1afabc89562a159387f63787436567006dba5a2ecf1ca39fff67f7fe678502fef6aba39feb89aa949891f4fe9c0954e1bc85981f05ec8b3e034ab617e870afef84f00e2cf571e01f9833aa459bc54a79397a2b95bcbda8e18f04cac0e2854d4f32a244a50cb12a14ad7bcc21f8b06cf57148b945de84f27bc1409011837783f3b08975817878612d6a24519577b64488ffc36e4bf762dbb602702e322a66c2c59575db83ed7fe0aebbecaaefeb52c7c2122f6e226a4a10eb28c93292e54a8d4666e074819b654e7d3ea6a47e4f813145a542122f71383a97432044ff7ba9f915a4a772f0b2449dc7bbe0d54c24a3fb2028367d6180b86238481425404a787e0980b50c94ea78422c71ac8761b0d0eee6e0e218c374b3b34db729a68d325b4cd4bbdcd62f66334996e12e7a3e328e41c7b1476593c787d20a6d7e0975478a7b06a8d71d8688785381cb342357ca998e73572f048bd55516c8f2a6938009bece88bc69bcf2081cb05bb9f6d710b5796c5987e7f9ab4cf03616197f4ede960b33b5bbff88450d583bf77380fdc6714c84620bfdf8d8066c5ec989b892ae23c63068667c0031659cb023c178c0aed2dadca0c2fe2ce5f2cd65ce3a31d86b541f50f0de41ad4074aa5a3232d6649e050a34582308a9f9c0b07dfa8ad2d52e810770dfaea8fc876279086e283b9a326b05eb6dac0daba61a6bbe42e1317c45442a5a9d9c62acdbe1572733698f9d87c1d4e455971445b1278da974fa67ff5ddcc90b18b3295f343dc2aee2b24e0ec167be799d51f267bf955d71ec2e882d54d32e3cf8ea1d916e4d569d1ca5f9a7c75458d72119ada42b6b556c43841edeaeaf04777e155f8494fc56f5e412ae19563124a86fb7bcc83d9f0781ee3193b49884f7a18c184e4e0ddf7b39bf7a411ac06b9be979cc702350927979ce02f575023a57e88dd29d886446d1bc2a2572772dfc89b6a196b3f428cffab3edd7ed327994f687517d514b6128c7293e1a14a886725f69acdc24369dc4019ab530915eaeb4b65ffb2e851f36ae6d0b3ea128fd06e8acb27ce8fd4f863e74a4ca2f012d3b2a448be78bc628dce24f5bdea92a1bbae1f846af4e3e21bc8f4007228749280c1209edc624a9735b1ff2c087c72318225f9460fa8ef996d1d3d5b0ea2962cfdede4077a88a339af926b3f097cdf689dfac904ab149a6f8883906c87dd815c2e70ca22250d76c2153ceb56c00d4c541a6c29f7c01b00b3444c12a45e1671d21a585a1dfdf1e912f6a4f87d30af778027bc402084d1cd1810d3685363ac6525f2749bc16c44f4d864260b005d714131d2dd704e91e149671633ff4bee4690f1c29d527f5fa66949465887653a0e826b7daeffcfb3f8c129cdd8bf99ecf46274d03d5f0a4ee2e4a46a68b39d637f159743dfa834db487be6485ea1d0e97b3c2750aa831b982d01d3db9841f5f956a70d9529391dcfea2c03d31ac103689ef2baad7a15b6e4d854fbcb6abd0e3ad1658055d22b0dd5b966c1a347f4d26fc0e8a24009f440edc7c877c5271cc70be988c1b51a8820859aa545ea92ea66e86d3c583d242d2a5db6e4d08a9891e01e206bcf053503191da355aa6f261d7f17fa7225f55ebfba2759db901615e3c551bbe76f9d16da97fee6dcf7557c02135bc1b991bdf862f8a74f1c5f153b6ffba0d61c51d17ea761e07477e262a4bfbed30f16a34ef4017cc19cb98b36e713b948c0f8dd6892936bd609a000fb7bea3b82340e128ec223accf5cbda1f4691b69e22ca654c2e246fd96f11301d69588527134660ed966f566d752c9037de975fa94f082b4c436173865ddfa8ee1becd9a8dac35aa1178d7278bf757c3b301537da891f8d4231833af4aaf0e3afb31a7bd45aced4a9e45ba758dc4838c742e088fd6a9b3b691d23e0055b75b5130f1c2502f09896a8b28a56eabc1f220147a8f84abbce02758bb791cf834cfbb5a18486147728cc759d736567e8e2687674831ad245a52849cc0e5bd3bad059adfd1d3457687870c23d23baacb60ab97bd62e628132bfbd1ef0013ce7220e2b33d9a6db78f10f168930c3e6baba47ad11124e0e798e4a5cbef3299fabe506f4820451f0e99c86c872a8f9881b9da3324e9899d9ef00f7deb5b5cfd8f2a2a985d69597240c39fd07b46761810bc1e497c7dd7bb51b166e587828136da6ad974aae9805683ad18fada4607fae6f4ed446d677032827d57aa6a59ea449123a3ef3696109314b5654ddbd6f17636f4249aa3f9dab523e434f8412b8ca5f49a3b49af56735d450251ba5b150d21c9e7d014003735aeb05f341406fe71ddf729de0eed9afbec5eb6b94ab3799d14b112ce0b236104c5a79099548dfcabb0cee5cfd685e49c7336efa6bfb6b4119846d0703be2049f5f3b121e68f4d8e37ec06a8a53d1ce70c22bf9c2fec0c94e951bcd4e67df30832730a790c9554b311c9c8e188a9860fb00b8152eb3009588799dbb02e9b450e7eee35230950bed52914d5e80eca8601ee374320181ba2f2d1b3141d558de04d02d2515234735c332c431d77375a03320337a800ce0fde124771c9a4f84704694b606bf96dfd54b25bfc7e7b3992ea355e203cfba79e702b18e9a61959d0632e01d6f85e4fffced121ab3b6b808746d48871f65a0ae5e73c64455505d8764923a69f2d79ce68f6a7c2a0a5f7f929761f4e4fc0b6632872e09cf005a82b4e67b01d6067de6ffa2078e732fb321075e1b5e5e9f8d6918e90b8eab5abdd06991cdcd8b39a323fe1141a21a7d546b6b628b947a16143e37fc18772ba179c2f3a121701c1707762f7bacdad4d01cb445d28f0187cc0bf7244940c5f0642063f2ed9193a7d086a6ba9499bd94c6d6d971824d7656baf4bdccd34f85c6aa34fec8a83157bc96796f310dda9aa4264582788973c121fddc818625573106bdbbbe16da94128e27f46475556317bf26d93fce0400b6e8dd04dd6fdc67892590e263f64baddf24c6034d6c56ba3df09e56931e7978bf1d9e39791c5028d888960b034b82d7677a6e1a52f2395225c31780250df92b7ab4877a520a406441f4deb30a624dfd02367bb1567f4110aa85f9b49bcd9a829b85d98aa88eaf793ceeb793181596605ca70a575671d566b40604e85b3f0a82b019389c86368dca34ef359b5c480c9c4aa934f1939fc7f2e9dba0c3dab31a44ebc9a4216abb37b88b061cabdcbf90edb1001575e449d259591c1872269413ad05f6550b91072be926e633dadfa7c8f92fbf6ebdde66404f9b20e0f2f97721a1f53049f74fcc6c7425cad78955ca4f8f3b63c6dca9910eb4f0aaa5fc04f9eab444aca1f91caf55a6fd7fbdae17c954d5dda4ba0c07777c1d5f98b38db6ca49c624f8d652a5f053cac710b09a8625521e99902120fb0e407359a98533b91a2d4933117a683c69c9e32ec2e518358e8d352ad5bfd16a6d42092330c4fcfb892f6156b6c11f437b6dd888c1b3bee0b4a548f1fbecd25c09ff023e32cd5125e184279d213beba7a9ff65914c82f87a8922be196865c5b7c518f784fd89e7ca3a62b8350f79563deb11a7798258c3c2ecd5971217ef99b2b0c7cd041b5d91d765e485d5df93ea37147449f51cd95113b78ddcca4d0c1fe8d45b51d4ad977965233df8740c051beb51bbc7ab8916d70821aa2ce55b7dc3288afdcb2c189dc6f9b2d14a790c26e3407a1d9c7a3d89539e5028cf4fdb2f76c0ae2dcad12ee3f0921fddd721e7d43b06e03d25c72f773e8338e63bc02e8660de4f5aa06c406162cd3aa57bd428eaebd737617a66efcb7a291df751b676c6975a23e48b07528fff64e9ad2a8d68d96197b8d22e1a489256db452a37347fda1669ea26a8884780d4bc69ea037539ad710e2038a9080ce99145adf5a20f8b52c72bc439ff1e87b06533caf904d62f54130193cc4c5b8a28b7ea351f7ba3560ff25fd52362889de1f7bb71fc85ea852da6d240de57e7c0ecc00271e26de35a191bc7f023fb46c50a019feb18c0262d03577f174cc0c26829233df12dd9f8a257269748c38d5609e4ad9a569395b4215ad2deef118280836a7d7e6d86ae8a8d5c218a8772605b135e87389fac57eb68fc86c908d348e4f1b0093be91dcfc619a4bef771e2f6599a63016e5329e91cfc164dff7c257211da5e5d842eda56612e659a95e300ee8aa8fcb0695d70a1687404c474b54eeb4fb76810d164c82458246fcd2da57be46cadff1ba2f0e87e7bf41245bd553d047edbd62c061565e1f6e08a77dd8615e79bccea3af37fd3dc110d1767a52db6732ea0bf633f24e12df89a6eed2c2276ade39393530ca455c5109590e157f070986016f50c3196dd586a153ae8c3d937dfa89a5bd06d36dba81abdd29fb6c2eb4a10e2779a54184537186313a46499449a562588c95b4d038ac78a4897b3bcfd59a3a40784d2661f0b942c74f741e825dc366a0992185a1cdcb5daf6a357c451ccb99d8995dfcddeaf3489da3a19edc428366769574845c4701e83ef709748e5b991472934a902a4977c526e339b53ed75f68bc063ea3a7ee610f4eacd466bc405aa8772da33a9366fea257edd1a32888235adecd361cc5b33cfbe7657bd2443385de6a521de772bbf46e880c429fd7681ba2756dc3e04a9e052cd9d1bceb368074315fd295155ecc5243d6f0ca191aea92b7f68b0ccae6d83edcf949bf01a3301f9427606000fed3b439115d193878bb5bc22090ad9a0aca7e1f364307ddd5397d567137617b0d438369fa77b7b3254010c0f63f8d3bbd8ee1fdb5bee0c67042c1407bee258480680573c26051abe21db299c9419deb0b08b1f6de8c876a974989e5b287f7393cd7bfac58aa488b124a6126d11c427a7029e9a86a49fab8a58347a3376b222560c36453c266a362158257417aa7de02fcc347a7f53979f4364e451f1f8755eb1cce09239693c42da8b0ba4e2f3a859352ee02792293c5160a6a28513b015a4f73b012d34bb8c60613b4fc565d408611b0daa9b57d79a689f4856c14afa2961bf97b48acdf7fca3fb9cbde991211f32f902d1b95fedc8309339b63843775e30a859864d4be1e509cd792b5bc8bc6687f2186ae4c0a70d8c0d33f9925124cb75c58ef63ad4258ba76a0420f3f49feee6c41b33e50005f1392990d3a1969b1e9db12f5a402839f8eb4cd550a2b6ff0e4c80b66b65e4c9e64ac1a58e0e042a116c5c7af842e72361668012e2e910926a173078ea05bcce5d327ea9254f664e640911641db1d0f1e7cefc748545c1d6cc52dca00e2b6c8f0e2649e98796fa1e236996bf104f2a0f5c831b6b5c4567521b8a10b361993f5d84749eadf23f59bf04ac0a58bb445cb0a76ee225b6bd1656a0a2015fd13a1a596f58c0c56d1474066ab094b872ea7ede359d0cc69464a6666e6d5ebd30b1d72edd85d212284e55484b3963159660395275efa75ac2dda19248abf1d3ee44c5129c9db9fdd993c0bba012e01ed112fcc95687c1c47146290ca4a157faf7becde3d9665baa09124ed0aaf1b3e257e0cccfd6c99f1e0d677c774acc2209c4e986a46dd5fd4dac0b512bbcfd92f5d37758c579cf909af679cc2685908e6bb89e3159d280505dc0d2bb770620b9ed0a91de6cd5b7a0a6013de608355ddcb2e2b12b23acd87396e1cf04c883dd519e9a0a2d6118467b72f7fcacc272f32bb80da5919ba69e81dc72089b5094663cd0c678c2fcf560e24f4386e55b1da546290d6a86fc8af6853753b301b0a94e7fb1d24a869ff6ad21599071e7d309d5c9e736b753ffb0e167ad84df1af734a56f1408629bb5a54c7b90d112f081d6b9d04e13d88f9dcc961b0cb105abbc8d51b4656c16225ada0fbe8e30ff8e4f38abd1a38bc24b4d82c6eebea30dacd66abc52faa185037b29c811a55475503bafb9c4c3d8c978783abdc9e7f42a0416a5e31e00b7afbcbd017b3c09ae273c3d1cd69410ec09217d6ef60f99433e726b0aa727b8f77322e53fed9706b26926607b7c3ad04a09c51325e82ea15eaabed5556dfd11f36fced15ec341800db14ed3d70b051cd0ea46af95a40c057d92d131f41cf0c0a0795514f24f62994cdffe3ec67554b659bdd99c9479f8f6432495cfb54767fa308c03941d42738ecd55e3929e21cd2bd7fe83a5452e369725dc7ed54255943b4cb2ab6374ebb607365b986b7726714c381a941fe4ee4ca827ceafc2cd1ba0341be66a35517f5cecadfead01774d1a9256cd7015dca43f6ffb72a0730eecdc26d11dfc1730f6b09fc49705cda4a98bdc2a93fdee423ce9f6c409032d002a9974683f24da15789297043a42ccca73d01bab71b8c5e836a00e04565de63f2b04c9e906c02aede1f0b2217971a6ea70d1fc842af5cd26018a8fa1f8c808cbe111983b65a49284069d3f0d572b4f3c773fe24d0dec1a50a095b497c8b6493d27c7e2ccb9384b11d515a8478a5eaad5acaab3205b2f2f76d12d1dc354fffe8f771524cb08e081b998cf099e2a1dd21b0cb18072a164e4364b36ee1d637a62a65e1d0b39608a0f519de7350204a76fae587fd43db252e7cd6e8aea24de2608cdc87ea78623ebe96a5b5fa63585123d38e45df38238d9d241c008cee2047c8cfff3d769a8cb0e4064ce46ca629f8ebc6b9295d1ad9648d86881d2cbb1144af071f78bc4c248229c87486e7943ca7f0c3419638330ec32bd4a24501f73a567ba0920a63d29136ae4dd3f2db8ebb7a81e0f7b47aac56368f5adc260cec5a9cec22eeb35a4e477c5a4b1f08be24cf32e218b98cb2ef870b2425c496344e3067dbcf6d80ffc69e5bd85f45ab07e7d153ad66e81db9948aa41164bf838a2855ac2f43beb888cb2fef776d293a6f8de6d2bf137f6cacd43f16bd4bc14841ea568b0380b950bc63a3f11c10c8b5f113ee093ed00c3895e27bad1c98fca8cb7dd16f235e4b16cf8a9a04f2fd28ab8254ace9aa1526e9f0822359c56457a0021ed573a056f65ad8a0624e02a4b8e31886340b0371086f871a0851703ea0993236562012b4ad9ec31c1da661bf42d882ce51d01cdec116ef5c76bc715827d85345764bdc44f9a0e5c5c7c86c0001f316cbf9f2550b12ebc3ca8a11adc4dee1435fcadeb6de53a252d73073a698e52a088cd2c4614ec30cfeb58d8cdc4daed2ac0b87fc42f3bcb6f64094a53539b2ffe62f63478c5cae5b901961dfd165fbf44ea4e671be3d63817c5afd2657d5cdfd1b41e14a7ef2af2d9b2438a41ac44c412dbe47036b3b92f84fd5f162f4da83bb6beeeea8a564118dbb8a64c644a472f1636884a9d31f069592ee4dee13711ac7d3a23c211ad690dd534b17c52c44baa244582d71043611be5b1ea785366952d75b2cde55fddcedc29e863b0536b7803a588ded5f48773ba117dc96201a272180fb2ab62e5fd3b95541273508ad0b2fe78b63483f270414c8473b78449af708b3cbb8dd78a271cbc047ef84b489c0312e24462c0ed6ee3616e12f4a6f55f4c7f1df027a26f00dcbd109b150aa53a24b3262d359ebada434543abc22ed2e19d136c2bd924687eabc31ef4879f2427a0d95f450a28f65775447af1e3b2f996980e8a0bc62d4fc939e02030bfa1be4dfa21518f4be3089632830c21b52b657ca8eb92268bb329fa5ed257569a5fe7715534ca37b6177eae6d294d240488a0bb80679a570571323159467dbd2b4b01520c17474649614356e02c36b1fd053743ab5fd8ed31d319d68c5fcc266386ba36a51ead55bf3fc35c0ebcd0b7333ed47a72bc624ba5b420f0dbd25f06b7f36686d93e3be9bc8259f1c736436b8cffbc645e6d154f38edfb0deefe6cd444b3c597b61efb62e186cb95087a7c0e5f9e48c6b828e7dcba7a985fa20a79115c843071f5e08a4c2dbb30e6c0f76ec5c1430b8f944d7b11bdf0b1dca97ba4dc678294e485d101d98b80cdee3d9e685e425bdf2b4ec547e68c8f1b8358e9d3066be5c0a5d38b0c3f8cbaaf9f941f2f04e99e6d90e9808399a42d385ea9b56ea34a2b7530e1e4e4f1e6e0956bfe199e391bb9f889ce23830bd4c931cb743ff488799ea512139bbe89b4ffb4363da937a95d175c7167743206c30deef24bd2368e61be919e36b83bafea2358803eb65bc0b3197a5d5fc9a05411d9cb01e82ac0eb1da6b29618c753e837d3f5ee1c732aa1bae7b40341fdd9542e5246e25b10a0e61954b0bfee6caf8313b5695c0aa9c6b2693b4d5c7b174f7b40debd7d2cc554b91923bb649e12865d88b38d0ded791f4892d9b06aff2f4d9649fdcfb2bb1102eb8d47ef897dd0a06caf923f0dd2d3dab63756b6852b9018c3f4c5f8a13e0540ca1a6a31546cb31e3ab76fda698c17d44f61e913fd47a20c1cd68c51d91bea8e9d598889d75456ef856d0894d3db0766edfd50b10305dc889bea6b8c834d023db8f522dd09471bc9e65f26c93ac494a865f1250f9a96ceff10b2e59af48065ea1121bdfbd95b4c7cfcd4196b69a07159c889d5e247044fa8be5983398c5d0c02a4650c9784c707800e39bc6311e592f7fdf2ad6c13209c827a174b8ca78a70631483cb9563847f12cb24d70da3e65a13601e0ff3696773691c3a8157e6c02bc72fbf69820e6886162c02b643cbdd59066fc001a9c4ad59baaa61db4e8c7f13488143c20d164f3090eea6f54c3a00a18af790f7425269249b7eb77d81708be7d232fbc98b25863d80abe1f0818f2358ee460a88fed9405075eec5c7e20978c3578afd4e51efbdd81c42438b780fa45b7cee83a4105451b177f98aa02f175c6463722859ad51b1cb5f8d3c1c784d467b70c6fb82d556431f4dad59c9d6dbe7db8f419b52071a11595c919b9087cdaec24a3e079cadf7bc21ac5c9f30ea1ce081739cca790e62121b0290c60b329c56bb373756d67318b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
