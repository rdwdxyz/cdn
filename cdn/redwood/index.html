<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f83bbd9689616e083de5c650e12a90c0e7fc28823070b4ec51b5c88687f2e12c632635d0eeeb091494d676247fd942de7a24095a9e164f365a72e880a5d3ad9813472470c1b8f78677184355ff426f50e9b64a9a0701d13668ed5141308ca78310166b1a37a91ce2791bdcd749c8dba80e3157aaa09656f4b37ebcd7cabd5e6cd9090aa3dce469adbfb39ad12d4ce11d9c05d32fd668eaedf2b0bfd1b8e13138e3fe858e2a3de85d29941e9fba11f44e3a7e9896aebc7a09e2f743f1d9ee28d83c6be79a004d9f6280fdfb7b365dad6492afa74077e6a9db1eb0b1fe00904de44abb3443ba759369e6984dce17227e2afe38602ed3fc70b4d4f98fe26d388f9ed733f689ba4b2f837fc0a2f9f9728df81e2214466a839dc296f40e2be346d16493aec88d950b76360e3fc27d1fe1807af5528896b896c04b81008144a8a69bd5bddbe22ddc660b07c2761137d0432b03b22c3dd360eda0dedd4d6231c56607c4f026578caab61d776102af23492bc2a96613074f49f5203f5d8329055f00ad98824d2c2a89d08171d46064f6ddead15658dc263a5594c7806d7be6a0e8a9b64cbc1389b89fa6af0eefd7ae6caec4f27ba2df4e8a04ecca1f54b5fa89b3af780ccb088cd672b2972e7c618ce9b4a00d7fa8d15dd0c26c717a8c63abeec9a3ea44c151628793bb5a863154e6eeed4caf9c69e1f3cbb568937abab9431cda1c4302362e0cb74cf7649efb2690dc28085bff4c45f322bcab16b144ed73ae6e7567a840567c63db9f9fda43aa781ed7e9146824e14b47df7370b6dbfe14d73bf2dca55cfced3cb1b3e31bd9d184c85b8064de5496494fda7388fd4742a91c3425b6236a303689aee5bbc2c88381e26dd999e1d2e10177cd77c7ac8009a3d1c15f679b45dcb56e2d295ff55c70a5b95ffd3e2127727deb350454f2068232bba6d6d73d6738286835d21875c101cde05f54208f1018319f0b55a634e2864319dee693746288ac0b02e5086198a99e9825288ad9c17f623ece66b2f6ee02b3875b219bd31069c2f0fa41d9fc915224efc87ac93b86c8bc02275330f7ed53712a88d43ab696d58603ba473585039164b8a310e90ab4e21044a836f7e67591687c494627494bcb013cccf09b2a8eb608dc40e57ce0f197a41b79d89443b1d5d86459424834cae3a5092e275969968f637e5ae5862366d65dec5b85d40a4e9287ff2a3d2b354fef64a19d7613acf75fb74ce85bc159d4138c7077593c36d9219034434e47d8797aa165e46acc34d842b870fe25a2c6a587a1cb9c4af9eb675073a9dccb7301caa8d08c6a8eddf62e3e6172cdd90b2ce7a275cbcbb6c4a9a76cac294966ffef831842efb7ddadc8737bfb9cd8a7a7b59ce0a1cf24a543f98de76c2e9b99cc24420ba7081ea1c58c1fc330e5362c7dd947eae4da114745831eea2054109eab423972afd6c3ed66b727e3f14aa692d97bb2ceb5663b72303f14710f7e96c0c684898bbee1a2dccf2eb7dc8ffe1b35e212788bb323d00d3bc6b9b6dc867032fd9db2cfaa6f3c184f2370f4beb0a8e310b54973e3e6b6970a2577c807c355036bdc128eb56a9dcee33b49dff33b45ba2098a7e5e6a0f21d483f86b8c869534388eaf0ea966a0ec1375899d991181c364406079799c3135cc36c7ee3239aee50b5f9825a5ed92b62f6b8147935c149cb3765d7692c327d04dfdc7f28311e48b28bd2aefab70e2ae2bc86ddb594af6e3ac2a227527ed52a576994e54387b6e68eba98a24859685171988dcfd2dc3ffc18213a6f7953d303a5e4369c3b8e5c10840230e0f9b9805bb500ec8b16fdb81e15d983ecb70d12674b07d32e121369261444ca713617838e6ebb0fd8465747ce7a85024081b8b088cdc57213b8c6a1ae053f6c8c2131fe6452db077afeb920ac40d4841ee9485b89dffd9b67c52ed96e5ed2f8a58a5d132f51870a3da8415b4f5763bd528760806fbae4ef7ea39d32bbd13500e8e9e5b4e1d4c2480ffe276d9b11fb8bbf3e81f4505c382c7f9e848bd6c9e3a9d7abd55f6c63b5d9661c2047415ffb30abe37ddd5ee3bfe77f750d90df4267cc460d2b12142742bc4c9a5946336a2790a38eb403617b644d27e8c85380f08fd896c95c032873f02d4698c23dab8041c99ff90e359ccb1902d5f7bb22edc1c668d33989eef670c6b587b8eb9b2f46f44982b2739f8f16263323c31e29c75b2f23b2a9cebeaa27fd80ba7c2958662309b857db377964925814b2a8bf7d105963a8796e1e7d19b339b4f0a63acd49152106fdf668db4ed831c7b7e3355860ac90bda01f825d264f6f9e7c4863199f52e92dc83a3fe9bae6ebe653ada9012a51b5fbe9c63d0d89216ca822f1d83b23eb8e6405dcb469fbbad898a17ebad8b061a52b22a56319e6d58800d0eee1ecc1b92931fc0a76ddb0a0862909193b4582fb3be5cddf047f8305c336370cd462a9dad6b65d1b8b107f88bf6e3f445269af139f18a7718850d289896f43ec3c0347c8af38f95f84111ad2d0a27ba565291d9dbf4bc4aecd7fe0cca88b0ad5738654aaa9b3381119c309bbf6319a316953e96c58d300fe20d6dc40bc79b7da92f35e8dc9f53ba31d648dd5de102d61a39ecbfb8e12f6a01dfbc1ebb8196f47f4adf824c1491555291e9606f6d79c1ae1be3d42ed127dc94669dc466d24a13bc8d727bffcee8342e9602c799cb07dae67d3a262e0df7c632f99385e68d46670e7adeb2befb136711d7ccdfef5f42a9fe1d9d55a83f18c360d3600788edec6abcf97ded1a21b1e0fc9827a68c1837f8f5928b43d5004d784c9c9ef06c4ce823cca7e0a13ac541fcf890a940947df34b1957c3a3e39e61388a1b6aa7a5e9ad39e6f519de096f1886dc86c346cd6a222318d1980d5da98305f2b7039a26272ff9042b9f8441f443426d463ec7f473c6eca14b26a1fde46b7b6f2920b76f0d92ffecee5892fc3a31e3fc32ef56cac12b7455238ccb224d691ed369202a2aa9a5a44c68b9cf3b371624dbc13dab728ce13b48d68c58cf8ef049b2e1f69527ea34fa89213dba30a3317f05aa6e01d8376b2b5f50fb25ca0ec6ade717e43284cfc94a2629cde77ed95bc2fe1d4e56dc32af9f3081b09f1949f88e269c8e99123ecb77b03832c9357801a1e04d68198d7a647e3e31129a25577b708f6a2b8762f54c7085b4c1c6830bf50777432824f9c633ca211e16eff57d0906d4d375c78b550c8213a86f2562cfb20cf234a724135afebace52a57fcbb25cbcb0122963bb4a15eab04a763dc177c2973f66cbdab68de99e185259af8ba14a7b46875c5ff712469bd68c43a2e25df3776956258e8357c756bd77cacafd7d3b26ed6ff71151664257777e572ce7288e1c4275b91ccd634fc2c4fc7252e1bb952c537676e03f3473cf8963bce47a4832ee5937b33be96783891a3a4530742af7d894f07db47d6c57919153e08407a9be561397d4a008e7570a5c109118d78ec6a107f505069dc1692749552c9462e1cddc589b7f930105a480a67e736f831baef67d3d6a7cb372f3e76d21a293b0d0680f2388399c44ba4d51a2485581a60f8329dc0d2ca34d3fb8bebe2f5029b5a11851d0764e6b272d5cd0eb71b6eb33a617ee4d180e00244aa342988aa5d0feb6995390d97c42009fbc331e3f036f6f31c680769ba4adfc5477c802cc26cb38fea34602735fe4f5ca18e7a120ca4cd63e6585f63522c6c6d1dbc1e4eb32f95f39c67d708bde39d62d7a964489444f0e6d7846971d59bf1b06be3760a5f49119112eff8dc7e642059ca4012adba32a50e0cfd6811c09c7c9006be6abd9bb25520dfb2241bbcf87d3836ad2c3c0aee680ddce66ee9650126e62228875107f1a247d1f3e29e1eff7d4a7a131bf13366bc08c44c0618a3411315aae861da70bb69bf6a64630e5fbbe7d558657d8c3c722794397fc06de4ba510c7323126245bf21ce4a8b546468b61ffab982d11e0ee248ca4e6324936ba812dbb5937f0a84f83558791b85de5ea68738ece867e27adf0f0fd6d596e209bc216cbf9dfbb0e044f78c64d3d4026e8e9e735f9b9f130cc01fe128bd3e6319406ab16e3a5b9b4ea4985e31ef420963dff10fe2d8092b53afa64d98467e96313071c26d9aebb662324ea03d8d3b6aa0084eda20ccb2d434e81dbde1a346c9518481933ff399db34829c9aa7978918c516d74b909ec6aa6655cf396faf520ef102d488195056479092465ef9c344b34fbd80f057275283d7971dbbf6952fcd4df409c05c3977da828a181c9d26d0b30c9d88073712cf9ff1d26ddafb7a6553c3ded9359a82350954c5ada2be8909ebb6b2224b974fd2cc322fa691c88fff8f98eb7e60444acaff69daafcd1f1f2eba22db0600951c0755d17afed817c0cbeab0000e1d1a622582a2cf62a0dd2fefaaaa33a283c387e14fec1d6d86dca4eaa4ecd632b595f97d3a2141df207f40d13e91db4e724b56ccaab73b63b42a7e0e8896579ff826fecd8a3a75fa58e5c7e32dd2136f80f7b8551add4c918f6d95923e3d05871a0650f1a28d4fe0ff5c868f92ae9b81d89b159e171bd0b9811eed8a339b63285fd71872116d324fe244e0e01b007c0c7a17ba44348d62348eeee416f6415b3446286f5c816384e9b3dcd9687f2b419d7ad5833fd0c996ce5977ecdc87952901c7d1eea5bd660e7a4aae668181f0dc1c4003402998c001e26d637ad169f3686267b476e48262b5ba6f130fc5061265c63896de57f48811780a48d34871be9fbb2a6dccdf664200d59d916f82d8610a5456b776a452347e86d52940f2632a4d9602d351b358de0ac9e5b9343dcaa2b3bdfc148c1abb4d18e2e520456a0f4c00b2b3ca239511e61adaaed899f8555f24ffc270150337193e270554a35d2369e50097fd395ad02f5ee0a8643f174a3a76b200c91cf0f4d024f1759c4a7dfacf1661e0f92f3e9470807cb67610123e57797a4da64d1c9173f0b920e6b17f3a6217a8968c84b943540725066ec1e61c51e504e25fd58c79b6ce4da6815d42f9fc10565f7e4013b97389cd97fd8b82e285ad3f52bec2bc39f8be00176f4e9dac4296e03c3fddfd9ad7c1e929c4474dea233f7367e44e8b43eae4e482785acdfd612707af50c715c9603747ac0303150d2fa5035fe8c800da58dcb601473ed14cef2ac1ad877955bb6ded6b361781788d1fd3d596e31428084043a19169396557b8060a1fa9ef1600c333ca6c7c121fb435251221d600d787dbd4515480b803d197864c6252b9ecd8eaf5884056738f48cc031b70a407e8b2a5cf61ec33abffff0cfe9fb983906e3c223e1084b039d71c023d9a673125db81f0cf6022068de2cbb22dd1b22200ca8670bb8beb5d2bcc577ccc84beaf562ccba6b0f123238ac3a9caae481215296ec8ba9f01c9229a710fe36aa320186a514fade91698af711c25ff36a7443e25da22d8fb7908c2b3fbbecc7d183b9acf78529cdc34b1b2888aa418ff732042c8c30e1d9fff76bc7393640eef7331669ef93b7396fd09ee54554ae3345e70ab8e2cd657eccc75213f384d16ed487d2167745c5fa01d33a70a372a33e7670962679342e8f5107afee0aad19939cec4b9915ef2424a19872a041f88d85ac9b730164f13f621d100e3e28c7356e8377b19d583f0247bfd0f90bb85fca5db8a44526335174145e225a794b8bba52a5233857bc9f094a40a8cd070d1be68d5b24df54c778078c6e346e5c413d26ae4b76065634e1fcd1f7093e74d610d92e0055d8ab4815a2838d6b402f145692ccc57eeeea419666de301d113bf23cce85f14cc734f7f6c816822ae6dede3844879c3e363235fa0d8d2aef7a70db0982e2ed7a1efd3510a27b48298cc335ab300d08dac7c90010afb27ff3a1c1c1890163a301cd0ce0aa809087559d429f36ec725aae7e97f6777c178ab74fa0a37449510f980fa78504074484a656ecb02c722e8ec0b446b27c25da80fc5dccd5b497efe71ba98ef7696a5d0f49b20b805002742f2945f6047d440f621fc718fd1cfd2acc70c0bc301187ef82bcba0ea2c1bb83b6425b362bf6c019d27a27b801d4382714196f7df431b13dbcf2f7fe1692bc14261937e6bf0c4c931d454d004b4df3f3d21cb60fabbaf78aff13543ba3dfefb0b68203337c6643477841be3e97e37ce1743aed0f760423bb660186f21b741b0ecc744a9987d1e17519a4e618f9bd618e1b45317c9899cf76af9c1f3d5c99183bafe106a99bd9b0f7d216edd9bc13bc4c64a1e86d21d355728c9e7337d0b0bf35dbac8e9c150a2eda727585012b6666fb77930f7f61ec14c9620d35c13559e507f7431f4799bd7fc37c869ced68ff86954f52a8d1ecb54ab2bef2de841e162711674150581e653afee140d87c95503225159efaa0fe4770c98a9ab2c99b5cd0796d0166eae16742183c8c0fd69fc51c2336c6cc2ff9ff668d8087aee6aea92f118d20120902dd9e45312d02316899e3845978d69a30820ef7d96a1071b2a7a29e595506b86a2c299b5d141e9abf87cb4a4022d945c9b98a5353f945baceb5b4ac4feab87c4cc922e0f6409c5b4befada10bd310f70411830d3db1e45f46dc0ead08f910376b226201cc5b624b6ab0289c3e1f47510b64307aa6a1c94b094ae05a77d492a614db98cbb7bfdbaa20c9fe26bd87d6edf55f3dbddcb961be7d54a9fbbde61fda55ea71050e6cf5ad46a362e4093054c16b2ac46b2d14e8eadcb7748f38d50d70c41c7cb55da2073d7a5bdd0ec0ec741f9eaa0a4c5dfff562be1da8a3402a7685403e25083f6a626b6ef8cbeb30ecd396f97eb17864200a6e80830397709eaa63a3ba4cf216f6b37767d8891d9e5b0bd209c3e2a6e06a48f3100359dbead4052e38ec8acadbf77c7df32ff91ecf6554d41c53963119884cca32e99c200963a1154898851149fe31ff08eecbbfdae2b35ecf6b1ae10b0946d71ce906c34dc29e6b94c34c23a12cd8af72e7a25cceb0150bf78b82631e73d8701f28f5dfe271271fe2e2d954179078dab96d3479283759bbc8259c6636c5fc574c5557fb547ef904bb79ea7655317025d7c824560e39b5ba75a82448c5e5029149305d7906cc805f3d6460e614fab31a0ef2cce9424711d394228bde963592b3c1466de1dab8b7a1b5336c8e89d2845943ef38e90e207e112fd4f1ab7b89cb6c7eb39902b057deb910041ad2ef29695dbfb21ea0f4368d3eba76847a5de84aa9cc5a2f31d3aed2a616b7e2a700d0f5e9ee9387b698a2d87b029756d6844eec5e58cefb6712cced42bf0fb14e5400f7e72478fe438a2cb6b84cc7ad1a9158b33947e96c4ade1b0e305607d5a164c6f084bdb6f9fd306e73b83fd1774bd63b97b538b80e4e52f92e3ecc2ce589ec1209d5a65f114954e2120ae953872458e077e8247acd424c560f2277ea7abe69454e24599d49fb7a9b10fdb406bee01a7f721154280cbe056af53296f76699fb220d9ace7effd87180f6788acc71bbfa4fecb61ae4537689d59361383c438cc9b415654a21132d6a025986ab5d6aefc0ce2689276188ec234d53d1be059b4aa1ab1813e07708a32342afcc9c5871ceb49082c9b27c427fc972c44005c456af3f488bc2683f31744ae797050ddb3cb6b271a33c60483091fb3e34090b83df38d16f0e08604de0fedb00be3e168ee87957acaa04f1349beb6789889e2c67bdd45fdfaba7a32f2e404393220c190e77c4488b8facd4bfcf1f395c432d12b5887b20668141b61821ca5d040f4dba4036c1163e02036bb9ee0a2d8a7f1a9b971cb60a24cd90b98a0bf2a0fab8b96588029e8874aee8d375a1292c4e830f503d16482eab294c5c45761780f047209ba9e9840152f76f41f5043f0f649ffa5ea386697c65b8705fd172a5aed6cba1e334bf7d843566f1f1f412e801a1d02939fdf8085b920d8f092db8bfd14b30447367e53008141f091d3ef9f3969fcc1a2efc01a3e585fbcb6d49b3973643f0dfbb64ca9ba26ea05105cd99a09f4985b46b54f1697a990c630cff9f31ae9cd964d4b6f4f336444c9971800a1199309078fab7756f8f3323be1dd6012bdc354e7288ad9da171383fb7c11e3dfa15184a9dbd0e83c84b03256c670e964bf773fd40b3f6eed790d2021ed49151b470e6f7659e3b36a58fb06f81628d5f70fae8e07f3419a5b0313df5eeefa5eb635f3f5d917340763233d82407ae07b9fb8f0af5e14c6f32ffd4c5b06867c99924c8b794fdaaca55d820d1c3f7b1c166c29fcd4e2bcbaf995b7346bc321a5e0952431d95fe47878b2a3d65a51e8418c408b2bcaa2951da43df2b777016b0bba621eed9fa43f72054ec45c5d5b3d9ebb8eaa591e567a37d0d95e01aff423f9c80b8d499e07046220515cd28042bfc5a32f321ae64eba6a297f09ae6448cb4c18d7b8e86a5b2cf12040ae0833e487d8208a7ea5904361b9d0e7a903ad0349718ded51e9a4fc273a444ace89c5842ddbca75dce7959172ce51eaa695597ee79f0f00c181dc084d63fb4e6062e869a0655dc1484871cc3611d938ec599e485b0ceca8ed27be6f3ad834fe1cd7e31db3654dd93528007b2f6d05ab00c205ec4db6dee3fcec5dfc2c148afc7105eda767fde0a50554d71b7e5538ed3cb3e5b05250195dcbe9c4ab247653c815a0efbd95b226fd218abca703c5bbd6b547b998b3de37b936d19bbcbb4e523bf01276c9bce84a992f153d6fa3d07ae1a93093854b59b967d14ffdf3551f6aa8aad6b6f9729958039f835383185aeaa5329720011537c31014bd25f2e04de191ceba147bd1347ac7a99d5de55c02f7db9ff28541c491d5dbdf421a041b38b796170a6e971a7ae9e643c01891f088dc24ffb24d94ba5cd57ce5b2ed5105c276ec1bdf7633d00955667fc184291a1ad1b1a236f11d33f6ca29dfcd7dadc1a9a1957c4df115559a992186c17c61e261a095c21551123e591a5e20291732fd551d21ea5e3ac3230be11cc11e28078972afbc79d2a740fda88b5f67537556983c4692d8f33737fd56ca69d0839a70cc8825dae45525c322744e17e6e25b72ebc5b6ec82d20b6d76fa263aec687f9fa71efbac138cfba97414e880f99d14e99151345b6e69b6b31f23cda571778c8415f416ac82e68187beddc141ab257957ebc61870a2ed31ff1bedaebf505075150185a0cdf4a232bdc73e83c81009fde78f0804150f07d673d6011852ee1ea89491aedee0ffbd872f3e3f87b1a41f4de9e61dfcecb38af8575e04b8ef546bf1a1be21ee97bea2bba36495d6694d03a4bffab4f3d9843b607fecf628fef38b4962afa4134388003a417cc59fd13c25ff62471aad2062b4789dfaf23791356ab1a9e3520648060427361338799f0d7481a428b957c86b8852cb63dcb62abc8441677099474d63f6726fcd9ef09c8f768233287f2a4cb757990bb22af58ece741f5f4ba1d4d97a5afd77e1b45bbf615c74794fed1b576831cfd88d6160855bcf95f81ac51cc58acd606be968b488f642a5882f43d5cf5edf40e678873022c6c168ca5c8292253a14e5755d16fa7133d29930686993e15aee4244e0b87f1278613d731cb1452152ccb9dc311d744b80ea6cc125bc3ed41eb4564e404906a90bdcce5458f43864705b4b0916038b1b8c49aa79bc558af74c2218b8ec1bc2768e832b648f461a538b008a1f456fceb4a18e07478945aa9522c404bc4159c18831380794638c4cabbc31bd54c70e78b041f0c278eaa8678d5a980646f630c483bc11f352f6cce3135b4c98f1642b220f174d5c1aac70d6ae172cd1af199f703460be5915009a72dee45d638ddf95a0a9c75f4acf99abd3ab3acbb8068e810c61c7d3e6663ae54d89e5ed25ce66e10b6f16925fc598f6eb6ae8df608760efcd9f2c9f53e2aa849692c42a6402daff8fa2713dbd723bbd3350ab72bd3b7fbf0c4be315bc4ed16e26a2ab110f3b87d952d038e6a5425ff382273313982aa24bb7822731a128bb2fa4247ac28843095d03c6c4c6fd9c70b1210ed17d113b9f8e561dee2fc29a0d86d7209d48b03c8195c83675a4c596ef4d578c0e4c485ec05a827385f897e0585094a87d0d8d8082dcf02c6869b2121e056ca8f0c260a3d3c5bf38c75004ece80bea2d1f998da44476e67870601f3990a23ec697094fc718ced6e9b572af06a99580ccdd558f2ea7508e45356ffd8427c48dcc78d925dc0fb363127683b6eaf515b5196c9d02176d2d4cdce28b917b8f736c84a249363ade68ec25d72d6aaf53ff5e3eca8a34b403da7d8e70cd4d85446ba06df3fc3a5c189ba2ccee5c308d3211713a9d0b3f856bbde22c35738ab360f66b355bce0c1dca4af4ba51601afc2d5a5b42d85c9eed31ab891030f52371411f508d605a2a0637f85d6cc08f0fbaf9456f8cd78d30c0332696bfe8457c132457108ddcd159da28360017e44d064322a51c01eed2c4b51783717e0ea795b5a09a2fe2c726d8a0c99c9bab02599bdc764b4497542d34f2b055c1f15a8dff949c1b02191f0682b1dbd3c2f6c155ad314ad14e6043a410f6054cc43b20d5a2dd6a824f338f99d5b1cd4522a5752f932cf7ffe607be78dde7037953bced0df84593ea164b9f4f4165cb53d3db078d62caa73a305ac39c56f5359294e457e15a7179d4ae03268973caeaf398a5c9d77d505769a58e32ba46447f9b1acfd34aa28366949afbf6dd9af6df38d61eaa3aa73e7b50c4cf5905526812fe3c6ca61d9e3d2557242cc87b1156ddb5176d39f48d18a719ae4526630dd6402886af7b21df804eccf86d94804b299aaf27afb3c7cc489d12bbaface371d802665aa5b0ed6bb51f8bb1ddeb40e0fdde61540652fae52e798756c8aeac62eaafd6f927de0efa4c5f2396d3cfe55a4b22d816530efae50d22fc1b1eec94e821e601cd282f0f993e28ccd1250e2c7e7c80f001ce7e67dc8494c197990cdb9f1a5908cab8b41a613a2f151035cecea6970fe8f937457ed254902c84e45d3f4438373507db4e5ea5828d485c85355bfd6768f722fe6d11746ea35abd2c7b3614b164fc2c4fede18ea7ebb56db128fe67a49aa88f9b7a46bf56a44d84c2f09ebe0fe96ec4e880aa3c113d0a50a05d69bd2fc8d2f081e5c2ce717334ab3ad5552464f6c04f22c7d2863941080ff928dbc2b0d593bbecd9f5546d948f696878358d3dbdfd2e760284a8136eab19b47e22e891f76b78e0008fcf6ac882e5b0c7d73296bb8945ca4fe4101790a50d759fd3f6725ab1e7865fa878ca486215fbc2e56ddc7e4c9b2f89055841cbe4b1e0a8f599e9485854283cdb395fa3af30c1fa2fdf47dea327dca70ac920067c2803492efc65878c33c6e9b98050d75cd05d7c7781472da55abaa07be8b0e6743338fef2c2519f413ba4244709762e822ee454ff664e8b012865aaa506268e8c8e33029c4c17d3dc844a155f6d19c4179c7f34a683755c70e46df98a86a2ef182bc69cf7e0c80fc6137537bc7f775469ac5739bc0875cca3bbd690a596abd4fb65a29487155260a2f4dd7fdab9280f0d16378494e14bef92aea45ad057f00e115dfa00d0705301fa04eef5c0cb42b32873be4d430c7288fc56517db7f8c9a6f3c6f47820d57d86e1d1cf575f37373b74d789bbc7dd2cb387051c70ecf325eb8ca1fa7758f66780ac78d189d39f2fc57f9c8108f31d2558079695da78941e9cb7ccdce573d4f69d997b69e5cb5642d3c79b096ab2b0c18c74074baef281b09de83cba8b94ec1d2f5ea03c93963af446c24b988af8508067ff8361f260f1d4d4f298ac0f4857489defa39427075184af40230e2bc8ab82284538732411e34d0d8e1a7391bf8068598f65c07d8d3d82d252a7f36663f7875c81a6861b2751eef68113c9a56c014076c45e569c89e8fb68c35651131170089976f91f83160074a5b090843d9b4511cd9c691fb2981245c1ad59c4820dab6d9fbce4dc2f43675b852d440481bfd5d7bbddfa8c649f5b880682b00804fbe4fb92a7feab67a3a314c56a101381c2f88812ef8b093f2ae6b940f8f21bbbce5ed511b782d4b7b766f8055a027d0a17c07fb830e3aa4f05b3fc2eace58d74646b52657f8035629da0c0d09ea443396d26871f2d92e604b5f15a7d4ca0058dc01d8be865edbf8dc5b5fe1187f93a52305e4aba7d415d825fc20513be0c85ae614acbf9e77727c7477263dfc0c0c1c4095bef84fd762796a18c428eea24a97eb8d0ed5e0f3c6b29ec659712d9dadb6243238725ace0dfa4db556aa872df1710387218725bca41931168591d8d2d7abd7114a17f6b91cae1f6281437581c27c50bddf996783c8f978c03e2a13a501ae1eac7757dff3d0f1f66bfd7b662f9cc7ea9d1f1be18c6cbb7ad0abf2a9a5bdff850ff4c07b65c9f71ca4027627193437718bcc0675b8d38f7ec3c81fb932f2760d04096b39234becd15922c79eea6f31a33664fcc8316235663ae19d21c41c8d77976fde28ed032569a824534d971ce0d9a17d15470f25bf00254c62900b71ff18213719941f93d057b47d3c90ed3b08729b5ca3e15e90183c4a1d9e9d56b34b9ad2002d14509703ebb0bfdb03855d24db58a38a4c12eb315cc3eee65a8c09760278cf54246c744849226ca50b062be1215e72816412c592326cc8f3b1071b4dd86bc5374017cc98a25af7dadae3223861b66ad570cb5e782eb78362a2dcce965916938642429adda7def1befe376f903838f6acd8cd176ec383c8bf907ed5f110a260c7b5be0d8e4efbd938ec4ae2297a722cee21f9fee9e3b30f5c19709d46f967f9dffc86cdabca0bf19727fa6e42dcb7b544821704974b9c48483540ae1727bebf60dd8170812c32b141c6d617d85c6b2f8d83876b55551b4d3a61db7ae46970b49889accd1e12ed19d581a15b54e68679c6ad509b81a2e7bedba463cebbd0ed6f99d36841366eb92eb74f853b92891cb19ab48d7c8449cbce3aff9cda22a1a4d80d9ed95b2b177590554d6784e99ec6f59a23a1573d898660d6acec774016884d9bbf48585a918b5201df2b716bea0d7ec9f50cab08631a5dd4090a991ea3ed2a7e0a4312ce8175b50d6c90ae422adac17ab8def1b67acedf5e370e3918e9321f63958c4e30f6e84a624208dfb79e64ef11d7983d104244a6109717cd0be8d091ea1568d9529218dbdde6c20c3d9387fcfc08b6366be451b3f7c603dc5243a3dabf7b2e34cd41aa38891d61a4d6c4758cf666e2809353fdc652e8be995043fe738cae1e4fa01b61ecd8db56cfc2d83c935cf1c7ebe10035ab8a8d4df8ab79f870f973c4b99cf133397a685558d29b541c128cbb349083e00e04c69b402e85fdff02193b73550938935098db3c1ac8f10370e2ead8a6649446056cc9af14b51c2a76a1221054f9ee1e4e8120eecaf26b73a70609b3622336a17d1908965dde185ee4775acd4c274c12920dad4772deeb5d16cd9a55d82c0f01a2a572df65c7c588d8beb9c883cc731f679910a25f5a69386f6a49aeb6590a587d8e7bb49d3f4ec25516cf4dccbb69126458919f07228419fbcdea7cc2da701a707502b67f46e1bd1df16cfb3c0fc2a4cdbb8fe23acfa0b3c11298c4cb4a39f1c7b1b59bf8ab8b0b635fee85f2f729aa9f64770a57752c9dd4226ab009af4c92a20f9be77e0ea8553fd4b9385a0873e5e600e6ff37f6572b9e85d2a860b25dd95263b4687ab694be3afc26e501bcad697e8a7699e1be10628fff1410f89a1eb26f2cb48a9aa4338685acc589dc12ac5dbcdf6b45e973aff76859c0468d69bb57bc69ccf7497e7fe7a918a15ea71cc1ce5aa71187981f942a4309cb5c95bf126abb8806ac15bca5a721f353b1ed59dcedcae2af178bad17761a0488f1f3695fd376dd764fd926ce3cb70caef70210b43722c4e89377158a3d4ab679234a6767523d351d23b76ff572e3d52de0c518a56a462b2021e8360cfcbd65bb166cd38d25546df5daecb0a17b3b781af9510820dfbd236880b9bccce8dad79568111659f99693f2a3a0d0dc102c522c13fc5339276c65364d39446873df3874871a6097092c93dbc41f5f24fb0dd5c2c6f70499633ad9cef0c939e3846ccfe1abdc64df52b2e1702f2ab3266488ab2a196f79456292b5525dac36990681a7cf5da95430ded6db6f5420879afa8285414715efb7e820b1c82b719550fa729bee8d2b16392a5c9ce540d2ad76c9055f3261a3c22958bb3c28964947b5374c831b5eac9ec67e2d93065c038efd6a59eb1512955ed9c088d99e2fbbb97ee0a6ef4350ee02003e53b8c29888f7c36afb26db0b00d0b7ee3530e8707ca9087e485e85587204c77e0d91617309769947c7982e0ee9f8e1dfb6cc7a7935234f5b9f752fe460c41ec5d40fe2e931958d421af673a141164217bc05d94112d63fd93972b1af4e03272834479c4c07809ee17cc81df0c31996e96d8fba778a4dda3c40d792d23d56b2ff469103c98f20cef057e8c59f676abe27d2fbe54683d5f26f1a3779b8c8990c0c0bf19b4789bc8cd96f74c37687661f3d7b45a0396bd3840cc04496afb5450f259c22da5e1ffa353268a5778adaf0a36d0c323756d0b8c2d54a385b986fc20d1009ae4240d6cf72f0c9f7301341f4a21609371dc1a9845b576e8bf9f068b25dc9394024376be750eb599851596d4e435f9ad2cca34028006243985af2ad50978986f97f6e88aee15f21060f39a751d61f2ecbfdfb06f62830f84cbc26e258853339e43cdf79e8f4c9fe60e34aa55f7dfab42736d897d5925f6fae94f3248689149657f834f319e08b8ebb3b710872ed37426657972d2a41e006d26ad8656991c60bc80247474251c9280f3143c0f78885d09a20bf51c9bf2fab89912154cbe29e0cb28ffcd787ad8f389e68a8d67f3717d179c7cad977c2dbda363c2545c1114e0532d0f9ca1464a2d49e57914b17fcd797a3f33864abc21a0148a8263cb54e9bf35c344c2b6b52b99faa9cf35b2a18b9cb8afbe64b46222d42bbbd90392b46e196df8d9120774cc2f9aa8192aae046b7f066d27317c0f194fcc340b0fa12937ffa1115249735d8f0edf89cd1d2730e9ea7214ad42b097330318a74cabbcfa285beef1661d6254ed9ee51a9a9808b580a81342bf601a9d41d50ce21eb5a3573151ddc47962b0b6bf18c2ddbc348cb44501a70f77a15ae72a758119448a65ff1b8e4f5ffef49011aff8dff483f7f0e0b8d78159b38f5dd9d1feab29dfe88ccaadd49453630f076a87e464c66831297cee9e883809236b551a03002bb86ef6274d2af13b7a5cf09a9ff42e3f33b106d2e7a83529378c6ed446d1b3021b31667ef59e0f292266f68053c61b2a6bdebe46655923863303e51b9048a38d366819d03ba7d46e6e0945cf46d59aa69d2515779ed6ef9a276246bffadeac53452c129e1b80b5ff22910fefd4a069ebf2077469cd245f6c2cb887e59b8ac7a9c2864e4add16c7877c85e4892fc0567af5df4fa35357aff10c5e10e749315b834edbcbf47fa93056ef4285b71dbf3010f1e2bf2d005be1b869e80605a8d0b9b6747ad2708ffdc4440fb981e983752a9eba1a5aaad981344f4056cefff06445146a8b5c4c7a2d0dc40e2f8a41034d648f6456319dbb938a78076f1a004c450d3c9b6490f9e89cce3e5d4f5b54031b4648b65326a7ebcea30cc305ddf5ae49d6bac8ec2bf0c88d14a8a52659ca3fa15cf8d5f37dff55a8c4cf5e88f8c2efb2e8f07012cf939c9ac62b27939e18d1888f5a36aa785b0ebec34488284a07ecb5f5399cb9ff24274135b8053c86e85a91c098fbdd814d871c9a92ceae8ef6daa02aaabf45eae79b469f41a9ad17c3232c026a1bc4830a3e15874722c5968758eaa1b564c9c9dedbb9ff4737cd6acce1044a5bf1b9a313ef5f7434d6cbf6f8ee182d79d57ccbbc927d62af0c93dc745b7eafce619fe5336865e5b7fcd01a12f95b8bc677baadb1b7d3b6542e56ed5124b35566ed71825024276ae0a1e0ce7d5468589b24193c33e32353938ba10cf0642efe851441bf24f5be1c00f7d5f7d299037de28e77e807450153370918432bd299e34df33bbfd4d59eeb49e97803d4abf526326b46c223dd30832454b2f17c3dbbbd0ee26ba723723f63958c6fa88d69759575036d7e31c973376fc90bf93653860e5b0e3492b8295108f2e5d89533d79862174a360370ae5c894696d0c26a8cd0ef0279f7ae9c9adb932a6c2674ca6b8be1ae4b5252703c53da6cd56300c69b587adab8aa20a8c4fa1f1bd4dcb60d2e994842d535637e6795322cc6415766ca0bfc8ec70d4d311f7cb2ee4ce8c83becb3594a681a6a044445783e1e7d3a9f4024bc5313771542e92ef7303eb94bb994cc2ca8360d8fd2f928a45d6c37c8c8e947f4a551cfca8aa0c62f5946ad2ba7d0fc5afb9fc118638ba5bd37a0e96017c2696bef162d0308a25de6e09462465d43df23d35c58e500095f3c28c4462d42cd606589bfa964aec5979068243dc6a7e7c64d2fc36b90e66b64ebff0f993b6ddc6b11bfe9ce7f6d2fc7f0b911f355c02e0f7227dcccc7033e14b8d1eda6090cc87d8e90a7c9d98ee2dd8fa438b03e21256a99bf09373d00084b62695c5c6aef42655e2c0449bb24585aee37c051849328e9e9efc87d81c2c5c9eeb40826c68c7afc82076e0cad518ffd3fd0b5c3fe6cf8f5bc6003b22f472b9e10fc58c79c9fb8187ccfae8748dccfb2465a9101c3171ab1834f7c489e373bcd70e0a008d3b2d74ad35f525177c5460f0b6c0d58e0c04bd7b6cd1370bc857ab3e05bcf79de62623f64fefc1fd66eff732bc84b953ce6f40f38d2cc1d6d9f32217b59fd43d7383dc173d4e5834f6974e5dddd20e0a32aa14bb9f4a3ff75db1d98725b37358b4d234b5cd468442ec7f914071361aae17ef14bcf86e64dc4b141bb694f13fd0b87a45bf3f5a607d6139361105f40ee3f2ae6a3a890d1aef9525a7b7a975127dec5f019435ef837683bba08a9a391239850aaa65b93365e97d42893d6229dab35ffb3f856885556149b3e636ed6cf8babddb0aff5e8279a61492b37cacb2bc39efb6e713a3841db818c83c1501e3d97f352633336f88bd9153af0dfccaa18787f532cef67f5aa48c49d3774d7011f368c9f44002a7026f5ecc3a8dfaf2eab091280de2bfdd19ed681395261fc2846e474e921a182dec4f84cab6cb4cd259d76fefeb4a2322651994da09631c83e4671e57188014c0d10d3d028cdae401874c802acc3b15d921b6c20db597d0ce50829dd8491a1136334e1ed784f4876e00630cdb7938bcc8c42e4cb85edac647dc940ba6f6e84d34e7ac5cbdf47c49d571c10fb62655ba5d75985e7e190f3619e2341da1c46f769874d5ebd98c941c658370383c1660a6adb48aa6c1868c3363c6afe8c52f0a15b6f5d2388f52caff7bf258b6fcb96978475ff14fb4f5d16c34ede2fade6b22a4d0909dbd505212966e1f1c38a3acb751ff41abdc494daa19e39df0650f85eabb1c899e39d751a4d6b5cc987d7a2bbcd1c16419d4a720cf978791295b4b6e24f2bcfcdb8ee4cfa130928be29b2940cc034a08575f6d5fe5d59aee7eb2f7380fabd8e51d5a7a949b24b5e9c7102049bfa48c1d05b74a730ed351a55c89adf7c5fa53b81da00e0eeb93443974db4a227d06072288246141927902e170c0650a275a7444eecbcacef196d466e0d8304c7af8abdde47643f4f00cf65816cb556e106999a3bdc8e4be9e267f52b6a8cde6b9c4d6a046204f00660956858d88bfcf8b4fe66b35e480fab7433e0ab07f9f86aa8ac823a76ca0f725f266cfa41bd1689b4caffea5635fb5cda25b3946be876b14d6c9e391d030b750a3f95c31b38919e364ed3266cce8746a8a76c91ca6e3983e0fcf2fb93db6f9f4a6501225464421ee13fb0567607ed2bf0b7bbeb5f934ffa5c2c87542dc8a2ae1d228fc93860b5c5ab359afac4de03b77f8c5b5e2f96d794479979806e0b1e3d937cab5bed9f5d8b31f05673bf37f361b57aafb478ed64ec8f99efe481c7594bf760fcfea683c067d960195d0bdba4610f3291a16b2f479b0c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
