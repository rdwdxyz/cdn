<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b1cb9959e612fc7e7e2cc071afbda2b3b1951fb7cbe3effd7da3e1e7f715f800a6b6b3743a2f86ec80cfd71f24feed925d1e17cd783d0deac0868e1244ca8620207aafea18e43a40e1e196d0ac3e04ffe5fdda5ebd6add8b68a729a0851c8e6ab8ad1f5b2816586af41afd4ad9ea3d8f07b005a821361763007c3a8ed75b224478b5ceaaed92dab6ebedcf40678a112d1dd919a33de22283cf19eeb756df2494f55d314613aa1b6c179d87c1239a1d6d8908bfd9a4e7ac6d1e329ef3d5ca2d4b42b36398d923a945bbf8bec30bee57fc3d359dfb8ea17962061f441a5703a9e200878d06d5dadfe3ed744870f52f66b757baf4a1516e3b55e8bee6701ce72f6b735e3631ca695297a58a0f856a12ffdca506d62ac60a796efdbcf81a797887b43e08513103c956e0563c644d15cda4c2c3cba60ad96ae7d349b517f6bf8ca67c3dc2144c716ad59d967dd017906e03321f373b59d172ab719b7ea6a910ed5e9ebe9d5f6fd93388c895889777c72ccf74f4768f03d301a5c4e9889d8406b1c7e0966e5abc0d93c51c22c37fd089d2b0bee8412cee656a15c05e75a749b6b1bd73cb9c0ab38b13bdff4beb7a8f1e8feb07c71d8d9f5de519a2b7cc2a5483b4a2013f2f3593828e0cec135c2df31bb0061f1cbcb67f375db785afcb652bccb7e13a845d39338e5a45fa2f5fe0f55188989edf87571b6fd3743a83563693df269d654b0be749861c6a6b95a2fd7b8f356aa3efce9e57b67eceaede3235d3a56b60954f0f92bcb0700f33a72c958aa1754e546567a69506f0d344f76b0afc8be43bea47556e899c2ae945b8f2f19c3ac98e51aa202d18b1123c1ac359eccec512cbe30c8ad244a315f92d3cce560dc5aadf972313182af3f8a6dae698a3efad7a9b2c7c237c3f361d0f194127c0988eeef4e039013251b8b8de569c20da5e2eb37b39b4de43e557a7fe76332ac1cd448308ec79c6b3bfe13d52b5dbcd0b0c40935c75853bf78daff96a7cbdd9fc4644326d26a3a6b6bd1c01cde30218641a8d7301cd7dae442e75102ad11f43e5aeeb1d9827533f4e7d73f2c146d94a32c6a394ac149d6029f40095fdb8cf761e377073430ea410118985897b228b430d63f852fccd030ae217a3fbeac600f0005cbdda85f5321c1a96db254e6b9f08687fbb3b0aa1c0f1ee5bd7d8c144d8bc33f6d65be988780e722172bf4081ccffd8450531a6106d7d68cc65c45c1bccb4eef7c672b722b399e1fc4fcff3e1e8bacedfe0c41e0ac224c10cc502b62eb739da9f0065915e01cc3aef0e2b07fd18411522fbd0af20c3b6f4e1e044686e09bbf24425ebb1aee0a4fa4261cfc354c8ceec5452895dbb5d9de2aab74c7b136f784cf78e87a0972f73cbde577b5ddde08eed9c35ab89bc0ce36f618008dad041c4aaf938136ac17c6972e74b78754b8cf55bc0c4df01634f27055929fb9f292b58df221bf92aa9b3a9c8406216df599e64c2c4006b240aeb995832943c75848addce342bd25c26ece5d4d130c09c6c68b467e2ce5bd3b5c535c0c0c2daa4014029e491a0d768d8419c863c7917c2ece4f5d3159d97d0a1b81373621582f9e0f5aa3d6189ed76c8126c3521e9cf32c8a7e6cf139f33a9f1b8ae03998f5d49e378c90809e631e6756efe586a81e0df6773d3017ac2427f6d2e70b9d1b706b4293cec4cc7d6911629a66f2daab0ecdf3cedf090d5866ffb3885d694bf7ed6d2e3205f0403e55f6a7ae602b6368a23e5bdbb7656db82034044c0b420888455f66c2dbc258c61f1ad89fe70e931234cef9e94b34d2f052134a5f0ca7a500208685f1061f464a57fab514596d993e0935f714f8b88f9effa1a5acdeb54da3675ac3e607dd7a06bc85d161f377b2528523c9c003b1512785ae309f7c2f38bc9bf4ecb8342af14e89d5e9494d2bbc7536fc81bdeb819a5f71aac89a6b43a9291458b84827f270ab0d6f37253c7ab932ffaea7e9ec4f0fbdfa3f9c1a224af922706f017e7b826bdd784111d44a46b815f34bc3514c033a867c7d307fbd89d99b52e07b3b3df2f19934eff768c3d1b7118cd53fb8f4c0b2729d663cbf13329563d0c9607efc80b15762f5e3ca4a9de9d341794bacb53723aa4f72a9afb448e6417720f80dccb0d689b6c04e6f2c4a40362dbfb633f555d186443df8bc7fd1eb40aa79669280e84ebe3d41c464244e1b1e2a72e75375b57ec94fdaff82122d7ad2d5c3460006548a0cfc3b93d93b38ec66bd807bb4aacdd775da81653a6dd7838a219fe24da9ae8bf375b4403cde2592552868d86a7d69accaa14a3479a8db4c0d881b8342f19e68cf099b9de7c94e1681e35a01dfdadce48666ec0a088a448f9e923956163538aa0e63a0649af11b8f052ec005a4a256e0a2442ebe633d0b58989e846646255bc8980132343d80ecea5ec6e2c6f27a54f4821fcd7e6ef23b0a6df9f70164a9a8b936b42a707171ad9fd1a1ec1237d4a4415f6365b9a794804ef43908c0e9b8eee1bdd39c7b84ab4b4308d9b26872c421993ca3be896d1f3129db1106d77c92c4fb29ef270bbe10e54e05f62e5289294345d8de7d5c43d74759d291b06bea7c3241d93873dd8058f1df47f9b85a9cadd1f770240afc57aeb2011601e5109036bad37f81b8b58cbd44b5fe58a1bc4beb776e529965d7b342cd52831db566cdd69f25bd893be711793e61b0ba5bec661b1a87cfe4885de01829cbd48704623d8e24652da981bd3c0513c52a3280a8fddce722ce94c9a7edd7b09f494e51d3a722c682073718efbfdede5495d0f6a297d5f7d9d2def002ee217fd3b6e26694149e4e5af0be686dda82e53c952bf7b79d25c456e94ddaad4ee8a2b51418d8634669fe56781c8f5f356411187c51505d4558d0047b57dee44712dfdf7a75dfa5c9048bcc3e92af6a480f24913c05ed942f9dd92f9b79428fa6889762fd3e450cfd7f1c52f3a81206def520d16bc8a9ada088b3f1f081cab9b02cf846dae50d0873460351e3e2a85d4b1eac7d97cf1e4e2c72e21213a5a9e7c48feeacf62539071648a7e4e653d936b1d947441c237f2e4a4dc684b4a08c1ca376caca276cc323d9118276eedd17249e9935911b8f67a4ef0be522927f646a7edab39ec508fc297fc184ed1c584880664f42be76903f70b1aa79b75e3a17f626cb3557589f668d6c07ea1799ffd5e61cccfed7762135192ff5f60c472362ac467e31504b37e216a5034c734321240f243bbe7dc629877132c7947a30ae26245b13ded8d388e98f7ed0fa556e33f54405993916ba303a90c013f07082240f9e4047c9c55391d415183ce59274d98ed878e57cd4ea6b50819f42331d5c682234ef2a4affc8f19bc978d24f1d8ce245d10017f145f3d04171c928d026a1c2caae5b08a9ddc4de6f7bee0c4a2f2ac697cdf855ff5288f4c7b486b1c70411727365029082d0c70d6971165ee1891aaa80da613f0fa65fa3772acd1b86bfa30ecd399bec082c1cbafa4a430098aa2db9ee1d7a94c750f957c4f17083faf35444b1db23157284133ecfaeda65bd9673b4b336c3fb60bc31f0ca2475818c63f1117a70c94b6790c54cd185b72f5eeaa9fc4f0575567cf26b59c884df5458f919e0bb95b8e21ac7b1281635c18460a16cc653e52496f692b456cae7c0886095420385461cd475370a02dcb74ca8d1d3ba103d013d881b929c96b0151f22bc6f8d02616e3586c6a16fd3b49852bc87fb58e4150da02eda51d63d2d910772d0b02d7532886ce17a58fd5787913bb421c7b5d0751b5c46cc5ba63bcb7b7de2979cb90f4956132c0f225b9c128977be24ce09be38010b17bcbd70ddb7b740857cbd4525ffcbbef6932cb0a88b7fbd28f0dd1ebd78f3fc2b4ea38ae59df0a36471284be5118df58d817efa22d7873f2f24793d14dbaaa01c6bd0f1811b11b892f7655f1214c2d341a5a13b455ca3498793133040e4d85b542c6f493b0c48eff051831c77b429af3487dd4a2c5d7d60cb1c07cd81cdec282e294bf32bc7706bd0809a1a9f82be5dcc5615aea577926b7f53cf503dd4c8eb536838ddddf7b0fd3ec5428b877fc15c213f41311784d0268eebd4cc3be34ea721578e77696dadf9eff5c854486b892592b7a0512bbb06ccad03e00861ec01322ba791a1de0c276f36a7a66dda634d9a950e0a905ee8d247212e5b73d063d9c1e9944949ad769ebd80528d87d1531646a81aa5b55281ee7a5435845abbd4af40e5c27d7b8cc5a130d42a3901a26623a84b9760e350ef07afde61d600e04b0bf86b9e4a4d45b44952c6dc54cfc0a9490f9e636ba9a4fcd78b3de443b7ee0a9d88590224ef1f1e93ed313b5d7b03a6f0e35d2d164428df91897ab09804096a8b2dd4fc20d55442e4f344fcdb31f9c3fa474dff5e9673021dcc27850fa60881de3811136349f60f4afd97b7db01ee6ce38978eddb2f24ec17587bb7d017ba4661ba9258d3ca46bf80696ac1abb85eb9c8c210329f418f9cb9a77b04eea377c1ddebebf9459d244a9ff02f33579fbb06396811d430f28d9d64a69276b13a9486f7fe51c343b22bbf10cf0354ab6737557c978a86bcc9cb10911062a5b3538785b7bfbd0d64a3f2c274d349898b89190ce92059d81db5ac22d87698c1a2eb9850e5f3f9bdecc5901f47233f916a58ef3d18afbd28f1fb755f6b368c8580615ad5042508a955eb60413da3ee52e1effcbef4fa7226b4203c431cce0682f1fd0be91ebf8f66ea51f908804d8ee7917155c7ce34182e6ca47f891bfaa59b3293f8bbd7b626c2ddfb7a77a20ea137b5cb553d2e58f75d18415cb3f2b67c7c40225622d539f180d72d474e2ce43925a3d00d9765ae3411d9825b22f5f93852834bfeda20cdcc50864fd06d5696101f5d2e72d2481f6e37221fa516b0efb40d1dec0b2759cd990dae92fd95c9a81d08e8bfa7ba6c80adb21717ffce45c8491667f7c4eaa3259416be829dd32ca149eb432eb20067952cef51fa060187fa5af302432b643cfa7c58166f6df6c7f6c9576e07ca9baf1a94c097d9f5d8f182303129039637654a734fc6458fbb12732310297a684a2d5073e1112a47f692475997ab01b46c03894e5d8a4ee79734ef08a0c9bc16f41e044b8725be60b835eae60753457b90de7e6e0c3feb8bd89a1c56cfca1c6c79ca22aa33ad1a55095c617b037eac2dea49958190f7f06499484f7e4b8c843ee514bb06409e4721be036e02afb3548cc333f240029c85efb76ead67e98de18ab421afd5f512a26f824e62c41c8bf8213fc1e2e9e473fd6160ad5245e00410e4410b80f08e5eed2f7c0e2d1a8226dc74502ed241e7c02cb3dd9750c1df2f9fbd935946ac21282123e62b219f1c3721071cc93fa1963558445cc4f6377b893ee08ecba0a223b362f16d7610f14c60644bd4abac9eafe08f788320bbd668c785b5e04ddfab80555e3e3a40c3a1342023566150803c7702bbcd07f24ccd9fc77268eb6c3466e50b1991a3d84ba6330c1129a7dbeffdebb35a660e94de7a6774a4c5ca42cea16affa5f3e81a0a1aa40b5b577920646d80f2eab19004b3cf97a55f3cb85ca58ad4b3aa1cef4d993ba917f4c830fee3753fba1b1ca09c5b1f8e995ea5dd5c129fd84adce10afcd1d816ed8cad4bef89a912029b47deea43e3724b348b991c00da4b3fb9517ae6ba9dcda106682632317383024155e315f6f8b4bce74f0c0843d8c755953ece0282049f83305479709c7c4a3c4709fbc9d8eb31ee640417888a9dcdc853dc8486619047a90b66992e483239c706a67b9e955057303a90dee570bca189553959378a681cc1f8081ba9f89fa9a46ca86f28ecccfd62509d24458a478f2fb2549c51f44ceb041d9de4fb27c15e41d739a65969e688224702362fc5dd0d91b1a26ecdf3306453d4164babd6b4e48814fd9583a8bcdd7200e783ec8cd4b166c61b7870e4a9ba26a167e70a6ffa4fe1d5238316ea4a0fbd2d186f128f1dbc8adf2dfee8759edb3711d87230d56ef66af4c750505f13185148fdfe360272b6294ca436069a5b211c7753ce93982283e3c1dbab47d251cd55980b68f1163292b1910e5cb21695be7e8aac48d199fa6abd01ca25b9230c307a47a374d2209a74ee94253d728d5688fc09cee75fc5ef5a9d06331d5dcfe32ad7e62eed27ab0ed2b0f95893f1318bf9963280b68d0649de0bbcd8a274cd3f16353df6b753f12c0ecb643189ca0466905c9610948d9708ced9337df39ee8ab9f28a4e84342b34192fdb6d294730d79ce30389682380618a5877196c8dc502e4c1cc7499789c693942b66f86135e9eb6002a7ef688f89b253e18b7ca29814dab2181737ae50e16038fbf8a7c8e6f5e86e0ed026079fa3977ee9e836e50a6d38eec0e9ea2f93c395e0eacfa6dc63f33e2542939f6adafecb5b441fd40e25f817a896be617ae5908f553d09229329debb92a68495b8ee5623091f54b3b45cd76482675c2c0ed3c30cf3674c67a6fcf252de4ec0ed0cc796f289ce94e619461f622d9410b47d1da12ea20cf6a0fd032678f33f783a1bf34f4ca4c2b45ae76d188768d038db7365682d2c730b0343b190207e1d0a3d9f62609cf824d9d714d6d88d66a5e957946b0846749ca5b3f9a70599ccceabe485e3b950fcfb8523e1899e3bdff015df9885afb6f8ecc8c13e3a595b47e8c073021658b4f03145a335275b48f2c7ed4d30923e7cccde2402cab4d94e2d74c03f7cce68a799a4176a52409329559931271c13e87648debc641bf32e21728a2b97d555a9d1c107093b8df90921efd3855963da204136c5f5ad09649a7bfe23a441ff545b12491e3e5342bfd454b9925d9e529b936b764da3861b3f9ae85096e4a3f1fc37e683d01d8b0ab7ee1d26e8a540257bb76a1c717e8338c197774417346affe7065f7518c8116a84d47d2abb4950d14b090276195c90d4805376076715fe0bf9908522e9f55de306e0dbd9cc2db27d974dc93f7b2452edc4219d8b86316b248bb37939f5ad2da6f3b52b7dc8a6bfd1a216459ab434be99b8cfbf34de619d97e5672e4bac180d1beff6b0e72cb75a45e892c3e833c8ab0711e505f066dc434ac67220aae9d7b74349f2799b4ea2b34c78f23717054da25341e04b54fc4e0b3037f08b81c570f2e93476bd3f3b99da18e01e493046a092eec6925077f468b177b9bc50cf17ddf37a6647445b1a56b67f3c2fd97a77038c52f845357379aeea5d9230e11f3907ecd3ce623d763e99a1b2f1f14dcdc7af00c4b32657717c4ec52bf33bdfb3fae80174ec6cfd75463e771f86074e13693afcb3d73741c583f896ac92efdcf68cc0888dd8cfc2fae6346e0b2a0bc45f7a0348abac5b66d689f2f3a5423c26d32d5d663da4f836d0a84b396ab967beb8f675237c60c6825eb17679a24b54bbe7977061c7b505a19fbf9ed754f596f648ad430af616e806883a1e8fa5baf4de974347ccc6317acb8e079d97125006a5410450e2e669c088af643a061a23478fdd7eb3413a0b89cdb300ecce1fb365e849fd163ad6eeccfc946b274b94b185e278ff5dff4f933bbc86b1d3870d78ad15d6e1ab0b038298e7bc59583fc41189a496897f56f9ed21013948d05693f6978abe3a32a9e3b97e0fd8e02db089dfee3b7961f647ec2c4f0556852413885dc9919a156b81353f14a15ea9d033e0e97f789505f95f02de6c6993004db548c74c8de70e0fe4a2eadbe3e8b3e965e781ee5c224053ec9b0b039c0cabaa1941e322b96582e04677d1d3e10d5a65b416eb20e90257e35de00857734fce7ce459f48ecf4e710a2d3d86660c5ec6ca3c706c1ea006d1ef1631881cd56be4301f71e83029d3d9bdb709eb4128204a9100e55b4cb48614c30bab0d4b79d94326cae2ab10f736fed527aef712b2fde5b65d470f31a6e80b82243911a76ed93612bf6c9c5d754a4c0b7f4515b7dbfc2b93ca382b6a9ffb269b5421c8b4ba8a7b0eb99ef103aac2b0d744d132ccf0ef0825a629693709cd08d6423a91ad12054c0db1dcbbaeaf9d8518fc6d61a402075878ba8f0be61af6464a7ed0c377a2a870f17888f595f316005869beb05fd0479859223e32ee562b1e7e42380325207c51b7e7be9229617fd50feccaba0d3774d051dc525d90a7cabc922072b8ffbb9fdeb486ab1dc47dba21cec340645014a8fab73e7924720c739445ec2a29f9d122f2f6840421bba33db64f5b77e3bb964e93912875eb0d71cfd2d3c41844d15631cf6e0ff48b3604156e7c0ee253d48af08525ee32e922c6b17090765dd01d9da4cd7d78aeb5552d3cd987f08c923987cf844a817bacdd8f9f0f5941be54651a2fb53a43249d07870fba8d10e8f97d75825175c98c012505f80382ffc7665b2d522f5f4fcdc9e732ede4b6e2649b7ab86a8c10e1e7fc512d4038637e986cb009e535c2aeb861419ba72d218d378e4940ddebdce0535133488f1b98945c28597f78dbe24c7b8289ff52586a51f891d00db44fd2088c44966010ce837e8c361e15e8f4ab1e01dd64b47d9ab574a16762cb4191a0dc629b8c90037d7ab651d81016f6044e8ec87dd1d038797cd3fcaeafafc229228223313ad769dffcd89c40b813b88cdc8580866ba3acc65fb89077d8e905f80c21026afbedf629d3ee8ba7de19c801b757cf4955d675e0d9d217dcaa62727a4fcb6d6d80f36493f6e06953537fab7c7910aa3c0fbe4ea1d30e02074e415684dab712beb15e854b643b4690faff58c238eaa72c9561b2d8da2818432376c835ec4f0d2c3c217640e9a6c41b30c6d7c41db58194f1fd8471c22798a1976d29f39dd67fdf82108c477bf4e338747c44a3a1c9b89a88932c3472746679488cdd9903cae88331a014e90289899f6d311ed433aa0b5866ab7601499ca7fb55ef008c0937bf27a62efdf08a7b8fcfc7a91cb49cd636b514f9db7c2177d29ebfe097830ff4d6d3ea5fa7cb8bf963e9fa24bca70b1f4ae4094b039b65be633d4f268468e7496e88fb41cabadda42151ebf9e43a7ac6110954bd1bed4fd0a6ec3965027aadfb85ba652a4ce7f93f6bd28d3dc84502a3680385c4592f1257e8228e464c4c37253240ed56c3f9b1a14936ba2c4aa68f49c5c72cfd86bb6c1363ebbdec7e0b9d57b4d44c66b6ef06f4da86a38a49d39f71986a1c2fb327fb6ca15c5027486f0c37a089409903aaa3e4d333630fcffaa6a2015eeb257a247eb8a7eae3439058aed0c0fa1d205f936e2e4b4ebc38ac46e79fba6ea53753ff9bfa6a135d25fb1d86cb5750e4540bfd708a36295aa6089a1a1e6c42021338371bce1494c05af07bf530f4f94350639060de244e1939095dadc9fa00610e4af5e9cd88462ff7d517b715e5b45588539b0ca588905d5d2a8bb041b09253f97f7515da21e7df7a9cb45ae25d7abec99bd8ded033e481f692f523398193c2fefc5e547db06262b1b7a3aec502b3e9e07ee53fb182485d6f1363f2ca51a413723351a919cfe524d56facfdd9558f64004b2e1cd6af13a126d797b62e502bed1c5bd0d038f823868ed4c6c9af1e985c61384091c01f20529e1a2f8b3f0342c52d4a5e6f89b7517a3a78ac00b2822c41954dae58518a207980ac326b2903d2ed3febf6ea5a02e10c0115e418a0b5bcff69e8d413eac7b90521aee54a0d4517d7b65f5875d8725e1a583b36cd8a3ed60b0bd0c57abf4f6e4e5b88a46f2f1e5cec35ca915c56ebe57d1de024821d6a176876aca059a57a65d002c4973613fc0cd7fb3f69254cba171ebb2f441a52464e6473b4816f283f1a7214b056c37b14b92cbf6a320ceef20561b691a41506c439f372d7ea537a3facf3f44291c6cbd84f9672a12a07ec9ee5c547097f2d399613364e7ca60cf0db3c7c6003d907acad2ade4b0a9b860ba4bb06b33f1efa8d566f00ab9a118ce884363349725db2ddce5708c9aa639c5d24dd07b81db586f015cff9effb01615db768c75a20662eed554c7fe43c5507a9b10c51ddafc77632dfe64ac330f515fd1909270fd43886b69bfdf1e378dbcf1dac7b740eff554e1ff842e03c64407a51bbde6c2a811bebcfbaff319544ef7ba13edaaf18ea68d7938219ecb1f918621c5fc1211e759ac845cc619d74abb186699f5c98b0c36bf614b98076a7be36b150aec6b3c325eef3aae3e1b34bb300fa9d1d37a9adee3c868acc30a7c76101ef69c0c2db3f218e49cc46797605c146c33525207820c2ca737ed8d7e5e2f57f3c6e84d71c4089bb45659713f01ec3fbafd6d1bcc4b8cd071f0fe0f3bdf1fbfbd827e60f7295905e397a872b32a419177b1092d4df4972a7b34a43eb99e681f5068a3ce9b6cb8a602afb9150ba1fe81608f623b5bce6faaea60ff70b61dd488ecb32da61fd4dbb47d7f6d14817760fd102908d13e1f20f4b3739672937f7d8d10774ca16cafbbf5c6fc3826551ad6017bde5d28163f504df23dbd207b709a6f43b69bcb35244c110b4c3200e0b0c3fd50c2439eba79441d20637211a47085729d884ba2b24546791357b78f5cd4770103fba10c0a4a946f55a2277e70c937de357ffd2a55bb95ffc9397f4dc20df209d449ae114b45c57be9edf190b208eaa4080fe28124e2d740ab86d6b9dd1aefb8738f81f89a0aef5f5fe686ee0d12bfe1fdf282ebb5cd87b26c2e8e338cdc8fdf52238b23f48a97cf965b7071dc0ad79ee3c6d11b461a3cd4900bc1074d3a28a562223fe12ee83b4761cd8643f8acc9294114a0d0ec0e703edaf330ab0d3b2b75c8086e357c7bc7455b0d1289dcb74ee35623dce12e49f7fb6006e3e738309df54790de199fcb86e2bd8faeead2200f8501dc33af9c23cf9196ba839dd6bdb6c1e541f993d429712518097080c0f0ea2fc3d2567aa3b059e94a943ecb578a1f84eeca420c0f2adfa0da129ee4de3d09d7f389ee136a5bc5c8ed48b320dba8c125aa04b92375d3677c7d80aacc89078a2a0afe5b1cbdfe1297643b4b691fc4f97bd98f09beebd91ebc01691622953a0641b97bb3c8d4eb9225f707ea9217af3b6a97e6b6643b2562740dc186a3f0a4d86b04495b095752d169d28e6e5bed466f9c43ffb915bd3c663136cf1534c799f1372420127c2a32ed0ce0a45423074853e07e9e14e9b28ae458d53ceee2d29643f72fe062998d11c46d66691575100df1c12b4362f154f6a68e4093f583c8ad5c35f6ab48857c97f95bd4d9e24a2eba486fde7dc9565c96e529372ddf06028543f29d78614d5257a9cc6225ebedaa1de84e3c748a04671a77072297fc2acd5c50c35be61387ae3fba8130b999cbd30049224e45411b57e38cc48e3f0633b7f34fefb0ac3c7e9925d0593024d78d9a16f348b82bed37d298aafb9375c72bb153cc7c3e90c08641a7e98ae0e75e67b41b4cf91bcadcf642e4100bcdd5737dc9aceedafd2cb3a2e51908730b0cfd6f7094be81ea4f4e9a295948d66d1c9ffca487746298b2b909ee67345b91ad0f9262339ac1877c0715df7ce3aa04c333da3752220ff0a4883ed3ff2ab65e0304387ad7740c46c974ff9319e73504ed6255e0ee2143e74f801f923218c9716dd1720b5035571edfd41edc05269dfde9dbc1b3da94f6715226ed4459d1e8535a2db15d286512ea081c9285a1572b2aca559c514f21a5155a51aecfdbe090399db6886d2a8bfd7ad53795542de440324ea43feca84543fac26fae4c62140e0893598bb620d5c971b2047ed562b44ed0c4d7af35b8ed61616fdd6cf4963e3e55d9685afb4c5452d5029c6946f81b20c2baff4ff0305b231f8137fb569dc86116bfecc643642dd03704796a4e1214c1752cf299a9b834f102219d9ba8793f13d189bbcb0045cd7a5e2f299fd919702c25ac37dd92f035fd8131d9693e0935d5ee2e06552c8ded7c5bf7c0610912da99e13a6fa99c1af3c027928fc448b9d8b38c95eb16b1866910ae2d0c0297206b4471b0c08bd9e1c83f0a01ea8e7f6e49ac52ceea2dbf6cbe88f8dcaa6a1dc893eddaafee783be3a05fde0cec53e9938a68dc8dd4e684dc25ff14d86ad788635512c3cce54b95f3360895295ef8bb2c852cfecb38181770ecbbc08a487056b934613134e314e1630089a12ea1e8d526b53e41dd9629930c32626d32902270a5918b87a5a7c416388d88c6936a22f8bf0460d8859199cc41bd4c4104a70ebccb7619a085778bc746ad72bd7d58936b0015ba9052d4e4709b8f86d6447921f50a3f1e849dd115e601bee48b22bf69570a89429fd6176ffb868471c57301c084b5ca29db05ac19b080e20454ff9e573c8a6b29663d7c1882c60a85c79fc6c6b784c539a8d06906a1c63e22d0c68ea81328b365f9749e5b3829385b914ebc8697ae776ac41986932647831e945869e8d382c2370978c2817a47431b8fa13399e93d4619d971331f2b5336f865776115368f79cec59e0b5723370dd9f28f9e1d2545063508e317ccbab926a7127cb2b95bbed5a9b8a7f28088145c951a16d8693d797d8155378a8761fee873346572aa717d84bca44515154de28fbb834e2f3a4a574b835333379a74d7a3cfa12a64ac6729876b6fd4081b87f8a0c2c477efb27ea239c7394f8d55409a0b3b293a891ea64d052fef384ad0a73410a02fffd153d65df6309447b9f04fc6f82afad2545910f17654c8de8fde57a5b20e9531a037d4700fe19518955309880d1db6b68b45c9b76ce550395fd6315e5b068334ec84c860a6aaada7276afd0e266d40f994f84c806a1fa454e1c11e4849d930a7413a3495522cea9ba460a7c9beb7b270a13a89b0448b39370b33b47f4a968a3d4b2e2b0b6a6e849ef238fb6675f76b42799615cdf5184b89edf039fe23c44920eebc30a37d680b8d27f879fbcaf368f5ef98491025a9309e11f4fb0f8b7ed08914956effa444b2fe3e6f63e306125d389eae211cccab9acf17feadee9110a30915821a9d94e2052ea60c9b0e747a09ef3e4921bc4791d825105af814c1e70bc64ab9a097dd9c20001009c7761e0981f29fde5e763899d332642e47fcdd0b147b826cc922001de4d9f55ec340618437cf5e547fd6be44b526ce05474023fc7130189ac814db64cc1cacc282ed5becef075db53d23b02680229ab6dbfd6f3ca556d4134765f2d7788535a6cf2f2959ee8db9ed16a81aca5e98d0d6b51e5cc5a7e2b90f785508b929c9678fdbeaa5b9f26fca024be302c51f5232ece05ff307f71330534f7011dc7cfda3b9664966cd0d62db150a4eeb9e77e965ac1bd0bf8ba605df91a4430659223130cc62628a55942b4b91cdb0467bc984567a77b0070ea2b75233148fbadc0c97306a52f24f5ef86d2037932f79beb28e07728610712e78ab8afefd7ddfac8eb21155f8121c71b097068165e6a6b4a200c0baa38a8c3dcc3f589bcd172fda4df3883af47a4acafcff8c9cb2ea61ef2c13fe9c91600a4d9b7a1ea4b1f35d93e1fd894dcf49686408a0873827837321cec2bd4a08c96b503f3dfb8707cd07d62d34b7a94ffd1b03e2788afff8d08083e9675c327269d46c38983a6aed1cccaeae2af229721a1aae06aed7f8ac8eaa0392954af3b6d50872aa52caf6611a05755cb37104b3ab6d908b2961d94eed2e0c1c123a0dcf37f00aeced6c001f974f6814852b3ba475fc23769046dc0279c501803e6a12b364f9ea707f95266bba4e747dd2b784758310b4d66bebcb1541e3da98b2ee1b386b534e5926df84e069155d2107d17d6cdc677e410d21bc9c110ffe08c4faddcc462961d2b866ba3f85de1f9f9930ebaa2aaaa173af9aba290929247e5814c321d48860972f1acc8f8198baa3ac9ce40d59d43c8bb0854aaa88ef46fb4e8ef2e9567001a80125ee5c211b43aeb5bc2d5071a3921e4cb39d08c11a7fb732d290091561b1e2d687e343bd1c65145b5669656fbb31f113698ee087e9e211f7b4c7e50714aa97b1049d57b658bf4179061c374a8482346cbc13aa70597c6350c0f07386fc304f6238db1683e807a73b83cb14361db21be43321ab6862d34f08e340441e09e789c2d7205169286d302ddf14783f20d379bbcf47ae20e24724ec8b772f337285d32eee14009410048cdcaa7a9383173f0046d4d2680a38fb2da4498d644af234107c481cc60b2fe3f35ddd1732a393cee485bc36a3b34d3b4df1c853f06712c297716aa2c622f4c82bd142d51fef22022ed318c24b6bf60beca20908c08db9dd1df768a5a133807c97548e1127282ed82659b3034cceec25d5f906bc7be98fdef2a766e8f28fcaca66e93e6d2bcccee41f98a315017d52abdc126a62c461a31389c9b2769645478deab87a171f76411905e15f360659bc72e3956466e0962ce6b89b4bc51c84578629db5eb721878a8e4e65adf79d24badf694cd02c33720f5743f3a97b6ab40f60ace4675b6e2922c707e0b9eb135a1f87d02fe0b8d71e9de81faa6cc25a64aee7acd266a60f3dca9490c2ecd36a11245f8d7eebbc0070a2b0a4b9838a22063deb943406b2f28e3a25a733f490f74a9918ed66aa70c779cf40806e120516ccf7f94623b2696d008faec380612d25d7810784df07e803f72ccf880305f5de5b42effd4bf129e6748ed3db3da3dad37f4d2ce2f34f22a88957b69908766129f2ff079bdabb927dad443a8282ac2ca3eb3f8af250ca80640ed8842baa01bfcf98fb1d3ea6e7d125a3bfdfaea198ec02e2ad084d5265c6446d1f4b5df209c1239a1655c2cc5c1a7a0531cd7a684a0ca9099bf70692f24c9da5a1f648a60101f995ffc7ea26e2baaa5b52a20ff8b1daba4580835ffdbf2ec34121ba9afc9d48360be3b3f029b50dbc1a7b8c2443edb27a9d0a46a83a05f19a814796bca7d9646a644b021cb9f355f69fa364fbb1b6bdfc02d8f89f9381ac0d95d28cde29f9d8a8c7978808ffa0bbdb0cba9fc78bd1a9c8eb33e4cce04cda03e075645df1558c45e6079b3fb2d43bf7d2c1b324ec641982607ffc5da7cd806f600c64875bfd0a7dc5caa9eb8c4f5371f7ec6df49231d1c591bb3da7f35caf8c8e4feff74335a4516d9dcecaaecb0a9b493e591dedee134118d8464197bba17df8668a37b9925e9db98f7ca51372a5dbebd0e1c45b567f19b008bad9dde9316f72083ad59747c318df2b5a1844c8b78f87f0ade7e2e9a8acd1ab4b316fc5fcf0762361ac7294229e421de5496563cef95767961d6271d0e15f25841b38e85cbf5b207e1249b1499e098c26961c3fc87accbe871d85e660ecbb74680e1c01bb206cf70a8afb65bf25ddb3ac4b6a91479bc470bed0f571ae33c66c7757fdf65d4e1639afc185b751b662cc6c50a2f6e0d5d8897534776c59841a3943ef934ef2e77d699e3d5fab01035da5e6ef25cbe33ef254b5de8101a4f92c830de96d1b8715fbc45b5d75f197156bc64e4560fcdbabce9802e7994245830624c2f6e36f1f173ed10c7c956cbd05c697df27c2156dc41b93691d18b3be8162a7e1f43021a890d292cb731f9f798c6949919a7e41efb233c97d72d111b8516277b975395488b42f2017ab00210699a9e510086a79b59d91de87e5a0094299072e83934712824519c49b48e7b185afbb3fdb101cbb906234be9d0171869e12c5fb498dfbb4e373314ff829c8a4209082b120129249e4046a96e529a81aabb22fcd9073838e394b0880fd1d131c369527224c2a14954c8032f8d58efa27a02be6772751f7b82f4164ec9d609ba1ffb0d72cf268dbfaa271e4030f162b40637273823b9d827e685764d7c1ccd4e6bc3ed904076182e955ae6d650582d575a846248d838b37320331da4a92d0ab1659e8fa61443d7dcfe0e501590d0b0f8117bf2027997fbdfc9f200da8885bfb39a4064b4772c7b8ab5128cabb12b8e49955cd8e90c10efc1f93af2e5e67bb3c1a1b666bae252dcad7bb4d4ed3fb7b74fae477a6b5e7cb34399575a6fde4e67dc47c4320ff7706de037329d3d602ce2e16d2aaffa0c85beaf8dc96e282ed2d15e575026c08b9b6ec3525f2439d02a41e8daeff50bf07be5246640aa8596005bab5b669288dd4cae87fe082341bb75d9cb6c6d500f5fb815391e71feef9a4c3f7b69267032222943ace1a18ad8d153f3ccb712929027695de92bfaef7c8cba90ef634558cb3b4719108482b4ab111fa96db33408ca18f9baed1836dfd9057d7513938efca9113929920237ec29a11eea0c702eacff4cbceb9e5ebd41b50d33d6b60c033f4c3a9febe7c15450224261a0a6a44ea6b6f2c6c6b2e7058de3c72562f39dbd2d799e6f4fb942e8dd37b58995fdd8d9534cc9d61ea11bc31120f9cd61cecd38f04e427b75a3b6f26e7dd56758ce09511aab039a4ec3ee0c384f1c5709e6bfef44639e0d524200d655b9c48d0874475112be5a8511700bf3fe03612c4c233e4b531e7105692f1d19d2273865f5a5663b8c26189eab8781b41c7954c44c896e521bcacbeebea534e781661477ef1a531a41bf8b890f4db0057b67d94eaf3881b96608753691730442f5e6b89c0b01f297e612f3d6fcc71da6cb65e911bd18c9bae26f40d7b4f2379745fef6d703b49974c0ea0afc0545c7bcd73058aa372d6ae93926523424bafa7c9facbd4bb0f07689845ac7b2cd824c879c3461121473e258d61d60271757bd9cfbac7b8210b02821d780cf59142ae5b58a159ff40d0011f3fc9b2d56372eaccf08821f9136201d0186217074e47f3aff798af40f9294f2a09de7338e0e3e811d1ce5791799c8598dba185821f0d368af21dfc7660fece1bba3d0e1147ee2588ac63077f1513d1d6fdb6777bf2d094204782fa2ebff6e3c4632f518f8e7d4b484b87c846b040c808a7d2b295c6acec4484d596357ef965b052ccfd21e374111583878bc74a7bdda95ec0777fb862fd51ea72e1865157c84674a3fdb8a33a405c321fec79be927d913cd2ac8f27c0593ef20351b0d8511bccc277f0487bd6d99afb7972ecfb173de45214593ebc6f861a5230028adb598ad4bf191784d7dffcaad4f7c2d0283efe5555b9342ca479aa88b0f282eafda68bf29a9404362e4bd650eb2383f89db0111ae1dfb403d2b9d791d406c406ad3f710de640a5116fd015104d2e78b8e5897dabe0a86e7a93ef56c5d1ef8b314a17686b48bbb1cbd377fa240dbd66b44e9e6740a5d5f897aa4c08f5e7eb0a697b99d5903a9ffceb638d3d0c781dc97b84d66cee2cb6652001bbc93200c236e49f7f7d0f5a64b8b655f660f9c9e5353ad0379e60deb18a4e46e229c7921ff1b6108c343b2f14046d700af7787acf976a8192e6fc8fa2ea39cc651b3a5356ad9e107533c0d6967c51dd5a97e81ef36dcd8480b18721bfdb5785e184dd691b794e23474469ad9495b59d6d318db4e89f2659be7712410ae30d0aab5b00aaf917261200ec671288aa4d8723326c019f0be2d86ca9ccc772d9a90af7134709d693e604e60b4ac23d3174f308e0d19957c6d1caebc66968f603898fef8392cb13290fcd97fe631bf2da8648d1f289f8d2ce877e6751f912bdee64daa338462aa7bd95d76af854c58c7d56ff4d4c0f68b83fa1b152d0e21ff9db3d862aa737cfffbf234b58fc4ca470b1b5f640f641dae3663ba1fa75fc373a4455d7c3c6bd4f20baab9331d91c01dc351861874aa71840f13bd70864bcd00594c6928d312919f38320e6f11338c3075a7d63b7fcebee15cdb25867e1b527dac7b311e76c7f7a64671addbb4904bbb936546e4ec92ee61c740a48694ed9c45c2c9fa58e8ad99a7fd1cddcbffbbd99bf984117e3dc1f3441cd0a4f3759f7abf323b9731bec7449444590f72ac06c9becbd4a3ef8c448774ed95065c22311afdd5acfabfa3a15822d7bbfc7ac8eeb733d58b7128ec3fdf7354714ed96d6884b382e5d1682e510cd46ba7483c9c92f62b256c10678a8232ff45ecaab1325e804ff9756faf7130cb1a0a138f3c8405b94880d50806e553183e2b6ff5fb37b5ac7ae3f915b7ae743f153ae11b6dc0c1b9f9fb7282884c43aba7f5e5b202be0914c04f6d33e539feef4d695974b4930ad49dabafb08a99866f92847e2a1a690c3449789937141bed01","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
