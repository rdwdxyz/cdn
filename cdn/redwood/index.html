<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89c42d0a5901e1ab452708135acfa78b3d8ae07d432c929c998adad60e72006885af2e13757379493120c9a02f40e5b0be1f08f2f6c4de7c84e1fe90d90aa7fd36704b4e45592536d90eb0d9325f1e155b1b21924f0c746df7b47da8ac130fe5dce9b4e5f9f115571b26c4040e1ec84ea81183bc060efd76fe143d1edc3d4f24408cc8ba3318a637c452cdbee87d249c56a19211350a1c5670ee9167f519d57c223204b667f1bd82a78c548115a35b54f05017ec0081822b8fb67bb1d1ecb494d5016940cfcd6beb8bc90f892654be7ce79256c57fe67bb115ec24b712d23c439513c8df47b2bb6cb2ab4d1520062fea20d7e5fb71ac9c8bae1e31ab97ed3819e812bf7b16f092048178e988a414bb80b1abad2605b400ce2ba5ebf9f85ec3c6e33ba501d5b9acf3a87ed5f276075e3f69699d57f6495ec32f1e30da80befb4ca96daa5210a021de6c77458b524ca01675b8ba9d39bd43b5b03a92263d0505e5a681807c26d9fe62abba0fe34057b39cf64b49b30905159655687908fd8111109ef1d81db1b0da7b89d10ea8683f64bfcdf00b3f1bf13c7e5896e2e08ea244b4133938b0683375848de471114ee59fce903b3a821d813804924706ada14ec07a2c9eba974f5a738d9a2a026d84014ddb1ee8b0fcda03a5a53cae96c5539f24533e4e9a1b294420bbd2e3a690363433ab8990e1b2a428ac5f98a605ac3d854361aeadf59aff22c143cba5675206cef09aa3f3e179ac9a894c289377c37d75ee958c85c86a04ae323f3f6b743c67fdac476cfae1cf3e762d740cf904802674a932319f2124d20cb9e06639cdc3f5ea0379408b017fdefb7ce3e78a50c06208c43631d6d0d5d5ae6cd65db8f1315f62e0df56313739d91f018c5fc6a7c26c3055dc6deede8d773d68a4d95a7739d7e59809daace39980c2a44d3ca7d729d5a73142218bc39881f14c2fc86c935361b973c40fe608f2e734661d104829333115041beeca98314784a11b21f26c9d87c6a80f9341152812558bf95e5839bd83d291fefe0d27fea092cbd990961cf43d95f9ea0bd4cd819b62276c97deabc023c3af8db539335add25c742d48746b1f0357bba1de78a4add8edb3a769f24a471f60454f82df1106d9aad62270c2f348bf088518aedd59e14fe34ae152afaf1541453069b50ea8a7c03adcc5df0aa916ebec80d66d2ab8daf079fb0fdfad5a727c26a067a3b3938c5ca7a7e8fa4cde3e44f1fdeda9a0a00fa2ad0fd6aebaa0eaf9e7a2865f7f2f4479243b4942a874fc12d6d6197d3bf652b26fd1a39aafd2a1c22e82844ba8b48d11f03b056002b50fbadd64135d8a77f07eb37ee1b2d93e0b5f71c1220391cbd7f50e33df15427e57e8c7b635b01cb4794e0418dc7ccdd335a605a9fa55b872693d6a73119a44d71ec341ebaa9da3540e64ffd6dc4a0cd0fe445e86e240e10acc877b6df312988abea97d7e94882f3604786ab9c816018f85134b9e26c12264882139fa90eec2e23664596f2cb81a08cd38e2dcd926538fa18c00c9cb1d6be11b5929cc10b060814cf03369ff5c99cf2606284bd4c2915f0c01985a9008eb8c69a6832c2c4b8b21652d256fe5a23df43eb1cfc6619cf2d33f3f0732b690fe8838215b307a8108c00db3cabf40c70bdca1b8a13d08786515fc5ab8ecad9968b662f71414d7d2a7ee7b19b658759aa1e81ca98d5c8371b49caf933fafec2c7e0faf646ca280b10222452002490e616666b71ec8a7d9ec1bcd0ab5f311eb617846021c30bd113084a1376b0f4c0b1f058ac2764dd8e340ec5c26ada265ba5813d6d488b5e15acbf1a906b29c7c41840767dd70a4bc30a6cfd3fd8fb22fc52f8c45c488d6d1ecd177e7e1fc80dace077c29f0902087021d7f4c4f45cde94cfb5b7752d99bcf028afd2455ae82396ef23a8169c3dfef305b67a2ef51615a4aab647a14b7f7c31186b9ef314102b66594f35019149a16da8c39c99db5b7cfe34487a850552c37cf2abc0854aeea7c3c2fff1440e0883a1156762ba3d22c3e2a8da7407cc640851ba24f47b87717be45c5113782307f142c1d965ed22aa85634397ad109dacef4664e4d69dcd781fb98cff57f4cd40eb9b13288bf7e977df605ac207ef3d6478242bebd2c0b87943a06365b6cfc91b3f0fbb8720bc4c09c2f90d71572a95cac294f5d2e2d68567620b5e3c02012555df0c19e3b2cabd11154188d306cc938c25c5865ebd215e874508835cf4a90418b0b3139cee3d3eba68dcdc50f75dea21174ee2efef72ec10b516b30c07c51b2e47d61729740e1a237ee5a20313db1664f27623786d803fbba6f91af70c2c3c6d103aab87316edec411343fcb71e09f67fe5762a8b7a2e0b409d213cb3224fbbaa65152235998762687983e354a27b40360ac289f68b55085159afa0d3148c9ac0b0b2ccd61e626fcff06c106e88a68fcea5e1877d348e1cf4cb6c08e65057e77e3409a1840a3148f1a262d13ee93c0c06acf4f6246a3cdfcbeb4835fa54332f36c6e7b5ec7295335f55bfa2599b03bf7e7e0b306562de4c485d8dabdf8f81c3ad67c1ab2977c4c3091ccecc792b43c006d13c07ea59c178e972394474a9ce8e4af020b26f7aa598f7d702369d4adeaee0d486414294b8b6f90159acd4d6bc848810be093cf00fea4b61004fd613fb84d761b37bcd6bbc193bc405b638528a4001741a905e6eee82ab73a99250f342b5343461c6171df8b9e0147692a6fda805f0672c26bd503728e5b20dd8ac238c18e172dc8672239780833cf6b270c638d00e840333cac9b2e11c2730259aea0e484bb3ae13679fdb3aeb222121ba2a85b353b120c48a0234c13ba9cc46228e4a2e1a4f78ba24db2127b63cf32b79665df7ddfad7f3a3180f177b5752efcc04e430e38ae59601d753d4758c55422749a1362b0041594ee11cda7a55324744583aedc6ee3db4254ea57bbef6380471948cef51ae28fcb1159386817990b9447081c2e223946cfc399739856035e425856460aba81f5a824d4a2a2398a85d77c06ff9a5e3449b8940b33cb1f188f7a116e42909cdd4be5362305f6bf3a807de06a810284ea46210f283fc61cbc77f71b4b29a2bb5ea1acff1ea88d66d90665a5e8dbb46254e515a4554b13363538d7575a889103bff8e7b0123faf336f0643fc71970cea2e9f029ee86dc40e5d823a1bafec86f1fee8c4d6115da96002b6548aecdd789ca7db691c0e93c6e627b762efdc5567d2f0e71be7c40e05c37f8fec218b9029462b4a311ef839682eea689dfe49cd47df449c8036a6652613c314f08e904ad170e21a6fd0d0e4190fe2afb99efa9e934333020567b19ef80f6072d19c20f537d0e88ea460b7a46bc10afc4c9b151dea88d0bdeb48349863f38107ccf994a6e987863a8bd8ee28bcbbcc29744c3ace5143a8af8293288efbcd6e0f2daf85c13e837418c3d26f5d4799c1548e0db9648d518c4eecae643e4dc09bcb5be0370f815b15f0ea9082a3f4fc5a4dd09ae711ca93acc1c783457daa7413b3de7767384511c15ebcbdd6f348c3878f9725a807e046cf073164bbb6161c6ef1f5a33763277aede3bd55158a0bc99145b5b1845ae458d9690959a8c9458d3e419d2b1d23350450ecf82103edef954d43b2401550301c6fb9e6a1b51eb9874a9f6c9b43865d5fa6142c07fc748e2c2b5646220f43b7125869b6376f8d6f0e602b98553563f55fec0e3a21e6f2c32ea7f1ee3ff349be3f730e141bf1876840fd2681f3bb570e605e4c16d212dac13fcbb2967d5bc856ea5c945140ff1742c5205711eecda2f6d40cecdf337fbaedf29fd4b187bba479ef74266043896a82223871334a8a1c8ebaf4e1325c5619a61eeac189749bd0ee5e4faf02256d45e97c0957885ccd539af23300811bfa5fa013a4eff8521d4b6508b0a83925804b1ee16d9efdde09f99f692c8af12d4994b729cc9cbdb4211267e76398b4bf10ea50519c16c83adb5487f7051bf4651efd566f232b051640cb6705c2ccbe23ddcc405e5c6ade3ae703a8b4e36545394d55f1261a0eb0aad528ee760932554b666f82549b2ce30f82b3e4d1339c0d5b3263dff2290d5cd25768a1b3afbd27daad3ecf3d0b78fa88578318d1908a79f3005289ea55803e54bc9c0a35690e0a631a74d3c49995484bf82ea6994e0623d73552015a39619efe2c42e8c71ed0dfe536a5c78b998eb81e01b754be1a143ba35577a27a74e42527db4bdcede9253130c5c70cd0336b1bab9d3d710854acba7fdaa776472617e3b3d76acfe0e1139e712cec320384a202e4b44ea74363c2ead003f758c58ab81a3d5bcf6cbd4c968a66143ce281f8d5439ae6b9e26353c5517824280070bef6529739f8be25aae83013c8f6150689a358a45cb88d947c2e34270efba435413391935554db6d7b70de17004a89159deeae66dd03e5c1884c1f04ef29f39d6531d7311203242c72c1c375ca97f4c2918e75633531451e08bfc5f93eab0a896413d97fa817101e0f830721d72d14c92281ddfde114bd0f98c837a7cb37118e8c4fcd280a44a3b693bb2a32c2c81fe5bac2c9efbbce09a7cb3d6c091b65129781027bcbb297297e6745e882489b8ba35928abf56fbd55dd48b78daf32b4607b27bc68a3b13ff15482763bc189d694910ef52a404ca5f806ffb596562fb7e7786b3fa8d3a8bf21489675e7bd2e18cf4a27a63894581fb97699f2c9746c751195d0b1751fb498fe5d2aece958b8f86ef9cb7f5eb51af7826c51be2fc7a29afa42613aec839f6043be3bd0ff6a8bd5415ddf8678b766496e1dfb24ad55b98bad39eb8e14a40d68427d8bee3d13ba4bfc6bed3c425aaa08f1945545d11a44f72e00c6cdb6e0a4b2724915a15b9664a6fd9fcfb32066d20bfaa3fe5207a0cbda7eb3de852356cf28c9f7c157d3171697dfdabf74fff9962073f8a1bb556fca9f718635148d6ac8bf17d39fe2258278959641a34118b3d9a108c790b11cd1fb9cc5a4902fb19fbb7141f432c18097e442ebab16d987ca61850c42e448c0a113279af5494f52c13a6915772c48d36160c536ce61175c9d235a2064d8e2047aa8f3aeda4cfd5a890ff04fc3b9094bec11bba73e552961f384098593df5f2efbe122b5443526186db6a98f16bc19fcaff275f2c03325d890b61746d7b49afcdd59c2dfec8fdff4fa98ae01e735d386270d2c0f68ad6e34c58af1774e342d805d4329b3825e7bbea3c7e84198e4a3cf31ab561a32b58a95358cce35e9e964d839188d6e6cd53510e2069701d56da8c63f736109d35c77706f8dd5363638a79c1117501880d09cc658ae2bac2f198abf0e9783e06ed20fee2ce5c386b90b3bdb7885766533d40eafb932f02d1890da850c0d1fe9112de881481f52bad285e53c1e2e2f30a8e702712fc4fd30528a1d4d3e0547f222063acdde064cad49cc4b72443effadb3828ee396627401bc3bb3cc02ebf9a495113e2a836a22bfa1ab4a437f9a9ace644181ab1fb789cf50c43e3c5a3c364e128ba6daa62309f57b94e96ed1d63007f6ea3b598199556b3e51b30fc6403c71bc47f5b9cdc4a11edea5ac726b9b9a9cf2ab1145e61f4075f6f24d6f1514ed70086f58524d3a96678c7adf45c911fd3f8ac3cb8c3ec0cefc31b123267702142e49f120d5c1766d7450226dd96a53281c76e7f9239e3cebbe89bcdefd0c8ea9ceb4f14cfdb66640c31fb734aa4e69258d8b934e34a920535dae2ab62f2465bb3f813c98b0e74e2ae8d4d40cd5f3504c6b39400542a11bc1db2a437cc96b067e3e6a6521e90e4d77c780895601ec3949526eaf5ce22219ac693290182d61b7ac65d4007e24427046930752aa96e81368617d889ff7c75f7034ef73f040fef74827526a18cc29bee045c0571c603051d20da7ba97fbd1b04c9507b97bbf572823fb2678e47fd1316274f625fd84a80618c967400abe8b9c486bcd4753f30cf300961cc18ae704ea2cd7717fad8554677d33d8eb17d8bad1bea700bdf04316fd672db9b2d19bb469b593d68feb72852461cc27f62fe4b1d9780f0112de11e8eec6992b42b001963158fa1a90839a584457ce9e39ec0aa71af2e816a9150c13936e9145d9952fe1fe7c1e3bc23831c1631f62035cd7008c56d356787fc3312c65de3ff346dbbecb16aab40318adf6e382979d6be45b7d638daa3d2f8093830594a59ffd22345abf88ccde0dfb9abd8b3cf611f658f775517ac39e04726642f208e89ae297e84281c9e8bbcd5fe0f67092e56549c9c03ba4df99b5b02739009a2f180a5e0ee5562934a7d8f1ba8d06fdc1247a45d1516636ab18c8c11590293fafcb71883ddb7af469513ace650bf36bb91e2a73559244e24fef8d75c41ad8cf3a4845a4eca007e521b29255b1edb3a845499fe228ab0b42b692ace3beaa10adfa1c3bf8fea86984923ef26d49fc97394b3948c98930a651f138d64cc926f61a16ee9a2dbe78b0ea5ad08bb1ced4d064dc570864bf2f016651d433bfa415b1e456a3a69e455224b60fefd2dd85f197b4c14020b67de0a5654fad83950aa1c4f56f6d50afbf18e4f3a09c3933188184f0baaf9c9e36c9b8b75d628133eaa705411c5975b30fb144a5bf8b76ee1dd7a10ed2f79c7574e4fcc703d089223e37d9012e85d9487e9c476bb0331d3d4b331c8ccbb53b8373b62a61d11e202360c833ee4e3474f0709bd18519969e3a34e8baac051e4bcbeb5dce462dca056a6701f91a1499338218fc4bc105266f644c65c287aa67a873ce2a292507df40033a78ea43ff7c2b068b1b7c3dce7a5f302eb01fea07216cdd8d04b9f00637db85c0a9248f0775dd21396e49e32d061c7721e6c2f19e7ed94bac1e29d0da259bd098f1e1d7726db7d3865f222244b9360970f6f58b78bf7c3e9f42f645f32ee6d65fb50a021d8e98523fc57fc0e03f0da0446d22204f38e5400c92e4c60311302aca66015e02536d307f061750227290efbb336318a8dd1e799b62739264eda4e43cf1d824c0008cfbdbf189ef8609b2ee6460672f012bd4d7d0a6c02752f98627e28985ac35afa49081e46462724622313e2db06e4e439721985fa0507838077864d304e2743c45a476d74c7c5cc4eb72ef1a15feeb52febf27f40b8e32923944f24092dcaa90720ed4755cbc81595e896fd8d991d185b010e979f7e2593e0db676192c3c5c32c56ad5fda80bbccc7d8829f2b16858c37802ad8b0eea745c5e467af870a2b86e122cb24272d5aff0d36a1e9df85d5589f92bd30da5d981bda9aa2beab6c3bb6dba2cca2f946cab3337c3f44cf096bd61b9349185c745bd9a8c312033613dad1f7b1867bf920ed48305cb21a54aba48ce2a7440fcea0d199d9eec3770759b9c96cafde3c6bebbe475410da1dfe1394705da2e0133c7e3965714e74793e2a37c3161779a45d7e74a665fdb1d80f3c69d74429fa6c6e7add2f0f27836577c4ff88891ff3a7a35e716b54ea6d59d7b44158bc72dfe2b69621200a2f625b888b296344090ae38ef522e6b9964a1ed81e9e79625f23dbc14bcfcad692a79ef3a8baff1933115d77d77bf4ef7d727219e181e2655cc95ff70ac61aa15897c4b3502da379e5d415f5c27256a65c9712512861fb672861f52495609e7d121d254a442491b3815a70a457e8bf94a441555ea651e28be1a7bb2fb777345614e601c436179b5fbee66e9239c8970db4903fcce375c0adfd661d063f71c08884698208c2eba02287003e30060eaad7e8137dc5afe03fad5ac0b6fdbfe36be4860d7a528f13df92fe418512f7a57ac572e5bf828448fea5e952627d287f57a185abf8afd659b29aac47fb3bfa97715077987859261ead4e16425eb59a46bfc78e1c39b7b3d9b4928f666380921e3402efb4446dee5eb8d9359ad4537d5d43da78dbb77e99f0b73e514c0cddc9774a5e06656c8dcb05f4fc9ace97c91125cd55eeaf1e34bcf14256425819658ca4361a666a7780ee16f0d323917347f65377346d2406ae3a8384252ff7caacfa3e95a289c161b4d471633289f6751dae91834626328c0bc5e4fa7c49d4d8aa07bbbf7b883d7736f37231ca37c30fbaea889e2453e00d62613207c38f2d7aaeb851900214af0eb3396b7dfa526aae371b6768c4b4002eb382094716c2d6ad5c8fe991fe30ee708d2efe86e7a5c3397ae3414bd35a891a07cde86e7647fc916fa316e9d7a0185ef1d5795b0d3d6d302b02a3385e4970714636a785085046a936fd1deb21cb8f3fc79c06ea9a771065f296229577e17c142eb6b7467ee1d57620cf7e17fb574238e75233c75bd22da1b85246efcc093bda48d9c9a151062b6587ac9239d7c29341ad9de96b55c3d59a83d9911f805a357e111611d96dc8cca880bd8cbadd65bed18da407ef11f821c3631c9ded7cd236368f45e803591488b061e35be0a2719b8e782df03525e3c9c4a163c7edbacd1b60af6983a3d74564bdd6d25f9b0862fd6ef331c2becd2a8f2d18548bc376d92d5a5fa87a09a3f2737cab29e693620f489d925c1ef0f679cf628f07a2aaa4e36da0d1c82a1b77402684e2536429ded537a43fbb8f2e07dec676a56bcf62afeaf7e0144615462d1dd4338e215c682597b6b672e366c6d2a0cdc1a4f5849800590db8c02b860cc9307754104b7ed0538dfb9490c94a09a3d9512bf33cbf763128aee8e8217c3ec1c8d78384fec00f790c0ac47e74d3260212ae1871f8c88e7c7dc808ab53db7db51c49c0a8c527b0da38d422cf44bcfdf037026ae08954697e6913a4d2c4a85a6e5b4dc7862c957f14c92191421f8370810a235edbbfffbbd8a92752291532ecb9f3079b645a4a05f0539d894633ca8b6a2f2ec62e9360a528b236913bc047613560ad4181b301eca3e21739af492d333fa0a8d0f3ba7d95a760a998d4e2d5c9033170e41558e98fa1df2ccd2df9936b932f1740552dc2e7f051f7173226c74d2febe5241a92261e38e9e94183712f3cdb50707e0ce08e45439a46f94c290d79e01a48a6a7e836a3b502fbf20532c852c12fc1af49eafeab56aeadda8861b73b9b43639fcc04b383ac68ae06760c85fa697ba58d7a65d4853921811c96176a3e7217db0e19a04b6a2ff4f3bba9535fb753e16c5d5050ebdd313cda8887a497278ce6d6f63bd619514e0a63bdbeab787f0affc66016beb217428d963edad6a31644a23664032353beeca053fdaa09032c1af76a15f7f0cc2c3bfb10539c48929d6bc437bd5e61a7109e3800c18969ab08c077a67ac7cad062873d4fbf6b761fcf27c1b94ceb1a29bc5667c6fab9cd69a6203ee5cb67396c46eefa49e3b7c2412b43f3a38fb8ae4100b09c0c50703243adf8616166817310db68008fa29b50831185c15d5bf49869d5f4b6364d803564b8ea3cd261ec970c33a8dcfea8597de93541b80cdc66c9700b4640326aee88a5d0b4ec6fbceea55572454a322919343a98f380645b3db330d7b0ba0b3db3e8ea22f19f4a5a47204789de3e2ad4d65c986f4d38ec53d945ddeb04ae3abc574baabaa1d9ed4579e717c164dd1a189d7e5092a17097fdcac7c4a03c04f8b5b7e496d0746731163481b02022a2443ac726e12d8330a6dc891df65ee7b4b5d1350b01196a3327e2e1526b24dc53af8d7d839018a08ddcdcf4fc9ea39a621a8b72d8938bbe510f8bb8630bbecce92c14a0c197c1d8f587be75845a99f39f67d1edee565c31acc9ba68b8633ae8b57d806376f1bba6601510f8cb1f6bc3f7748bb2cdf104684ae0c8236313c1bb8913e6153ca8ba129947e589c48b581f020c6f4f6a165e330ee4744913b25927c60eb6bd1e606b9c5edacabf1aa01b89b713409a4c410d66904dfdbe8ab71840f1cc6272b4686082524cabe86fd5fbab4b5a6eb3c9ba905a8c3580c474ccf29c8714804038666dc24744cf21b774482a0070422de1f035bc56443c4d263d3a0b930575110af225eae611d0089858f956a04e4b24f6d8b3e4fc11e0a111a66a9dbb07ecab5ea23edaa7402429449ad689dd6172e5236177dbe0a8aab0b124f4cd9fdf999888e07734da7e3b4180bb9088aa514b0a0a65e76c1e604caaf5b68fb1acc2e16a23193c867f7aed64406f2db39fed383f4c5bd444fbdb1cc1203dfcda9dd032fcbbb894380c87a35c2eb4e67837abb025fa1edefb21eb16168b9fa92743496f1dab51467c0bce75b51e41feb91a15763308c1fba4702b42e786358776ad7ae5729e05d55a3453e349436fe41a5e43c7386d220a34bb7c992d1b0a197dd98ddba605a06c5f818f3788207cfdd182929eb8c83fb0c85cc9970fd09dddddd0a1e6d231d15c63a2fe12e20c9541307e4fa4d513d6a312940f967fbe79a9dd2d5a42f7ca8e83d871b262729d36fbcdbc6cf06cf92ad1f1bfab8c3e0133291c40de9c6e6a4bfee51a8c63f483f39dd95192559ab81810355aa4b69a36f98e9b119555fc849970ad791db1c427ae813cc6352433879a2fddc31ed45f4b5ba9c7c407ffb6b33c3f8a9c84a039f89a40634cfd2aade5a219eaca786143d09356517dae50626472d6852c5096bdbc766aa9489c9b6ef729fb9dcfe5e9a092156f8eaacf86b09fb9d90bbf6642c2d01433e5fe6554ceddda5e4d04e9951b85017f2a6536eee355f598b552d2daa9e978e9117b6265fdd6fadacb5b6df49a7d945b15d1f03b3c25cf741bbfe01e1a86c551b2a0f963e70086864c28b512e32a41a8f9d0e7070f83b5839a4bbe45f1b6c6d78fdc61f65740e2a2da47f1270575a5cb5a6d138648b7ab23685cbaa3539ad925066bbbb51d910d3d63fe472cef07bde5ae154e4e432a8d2d32f8df28bcc7a166f7bbe3ad0a0ea1353ffbd27b8ca762bbe2cc3789d492a87859adb570e7b2193ae205a6bfebe082145089615e3761c29b03308e2886537c8c14e65a5839794645c922c1937082e884b7e58b935d53f2136d904a14ad0751ddcfc5d679f3052728709b20bf071abec29336c6adb734b034b895cdb717385a23fcba97dc64f2747fc5ecd3ff1d5640372d332cd29357bc315ff2b84b43f272d5376379dcd1555ec639832dd7d045817ebb5df08f93d992407bb5721c34cf9df182469535ec055d048e64924c1858414182628ccab2feac87fcd096d65aa1e1fcd4a65974bf1980aa60611922d7171beb7b43ce40453f7ea4576eaedd3e6854b9fd5037e2a28898c2cfb6a538a4ce8e4dd1d0f0da24e472d3a0a27020f980a8f387ef3758e2bc6014546cdc1acbe1f2cdd8adfc5b3e5ebcc22b96069470c557c51700dc3958adadf1a7e741c42b7ef37747ea8f08b2ef34f2ec8b8a01cc9a305f545b9bb957aee030ba0036142ee198826e4d40fd34438e73167f01752bb8f1ba1e6faeab2b4900ced2dd90516efa53667298a91d3218fa17f9dcbbe860f71c6a82008e40f2627e727eae9583af50a2126ac41b2d410bf4c00af0ff7af0b723f0ba7a8e52e8e75d91a995807af8b17b32c125a606e67967d312d4e3216834ef4a2e5cd186a4fd449113a2363011ea0867e59c7adbc6164a445c1b8a6fdff1b68ebd0dea409f0bf96dc5cd38d25c37fc763296f9448eac509fe8e2c13c4cd95fe166f61a109ef178ffe8e2737c9a35c0a49e6038951280d6088ac9717be3986d7b2a4522b96dc6dcb1286337a31484234d85a92e6ed68eda57b36bfcbf881178859e2e14e4559cdefc58f105af1409bf90a9750f07197a2e95f0804503638891f35fc616a272949bfdf0307e3360f19d675a2350c77efa7e64ba397c884cdeaaa2b4abffe5c60a0cae8c0380ee1e77bde756e6c4229a70a01b0c0a766d80509c01fe3e6dfd906938b1261721008eda1dd7db7a2ceff2b495692a7b3498b8fc5c4be7e3c4dd19ada542a0e4225320bc5bbb1546a36074fff1f99075ba3280c45ff7d7d4d02dbba4c7d955bd008f8e24d304f974790fb1bea76bb0656ecb5e8758e0f34489d27deeef59dfce9bfbb57e0cff9b93a59a7ae300944db9af579fbd4ea64ffc7c1c0e08d8bda168ef8b2305bf6c221950a52c59c5c932f789fc5691cd3c022532736635115c9c22ca917aa362a4d04789c475bc4373b56cc359ce171d81ce12ee7ad332927f7d82c74a14027bdbc1d028c2fee024802fd6735a9d8500a8a6aedc7495783a0f1b11e5375d7ba8ab851fe8ac0da0505b90f90b39df2e647fb5d47edd5d15def2cc12f4610c2e5254ca63132a45c90a28829fe260ac8f02e98ff5cbfd728576eedf73f12f4d644ef008e34344f53581dd213599b6b610b7f86883fc651d729dd771ee154916868f709ec1952c51774ef25635877069cd915037e07f734189375b0c3c6fd37f37a00da18f3b3e74c97670acc951912ec3680308c09044c262331af1519a5bc6fa331c084881b37772d49c56e61456dfe9db3ec4cb3ca65b33379e4594ce72afe9663162f68a6e2b001b5e670c06ec22f6379f23f3b3ac2fd2ee09b333900b6b794a96d3f093a9f5617d66171ae644cd73f92bda3845ad608fc734ae2cf98bda4e4fb944a7ac1e8f3e732d24a7c390e12c8c7ab0c32fe1d19006fb985d43a0bf94d01ed6485cbe207d050e9e4ef818599dc71e7b637ded322a9123cacc3c74cad8ef11f856de5885f420c27031c6834a9596b72ca00b6eff258550b95693b6b4d02c733e5002ff0e88dd425130b42d223e801072b967fa9e67fae4e7c7b81c714fb41919d2f0641263e1e7b4ec3d41681f5ab7d0a8d7fa00bdbc1fcf896b362e57800a5a15888f68536d61f9062fe00fbb06657889d91fbcc97439867813d7841c4dfdc48bfcb9f9fd8b9d2a6dde3a06908d280f2dc5b3f70eab6fef9ac01871999a6d8d615dba7aa12102f8176948b83537e49501e53c36366b642f4c89ffcc1201fc4a996d5ec997d014a9add34d3f7c4bb13bdc1fe256b60327af7b9a25f268c27d4086a1d83e4888e66b170af8c3f21e5082bdd98a719f4bbc56117cddc37917ce04d9ba5e649548cb0e158bb015738f54ebe5ba43feebf0aedcd8bec1a72d42f6348a9b37011d671ca92b0b1d712f94c1c85e0fc094e7b75a62aef543d3285a7134037f073cd278b0c383752575a26ec1b339994a9eac71a6caf027ceb983b50b0b1f62edcff6b4a5c68e504d696423c4c019e61004e0b8fabb6742c6f68dcd15f2e650d61370ca2144e2578db0dac65d09eea5063efbef4fa7c60b2e6f95cda5f3fac3c802fab90f86399e681d95fbf081c3f9ebbf3d03d63681a1fca4a6daf3e12f0f2673d45417388787d3e907ab52253272f27af9877405569ab0b66fe311d127c08fd30d961f97f1fdd38cb95ecbf23084a160277b11c881a8147888cb643f47b3e2292caad1e69f37b845e0337ada491a62cd287aba07423b504a1ddc8fcdb0e62fad9bf9f7fb644d19372f0a9c7ddb49735aa4b9289b807b124e0bb692a1e3aad07d8508335854db8960a29250bda66368db45c97a3aee3fb1f48026de228dcc2e4f5e80a07124f61ec52e4c319e3d777e7072009fabaca24e2c1de668b7ec4ee9d7412b426567785e419d62143ffe205931bdbe1d1bc669077087f7e31b04e18689a3c7414d060aa7396a4b5d5485574b2a1516a1c88d36a2b009e1ba0e67ae82a4342040c8791041357b99da2732b18ced69388bf7348265b63db4a0c7ad9c334d0e61d3278c45ff6b8a56f53c77ab23f14de1a02828e247d67e6b39dae4b4a7fd2fbfb7593fc189659a8e84896ea44e73b3c33b2802b2149de321d6c218b78b8c9e6aa19a1096df9a895272a13f3e550fc253ec7136e2a1483cebe70ab6146eedc36f3a69bd710b2ce834dfa5cf9d847b0f7565b033f50faf3ec16a5165e748feee983724841851cb15fba28e9ab35e712954cc8e0eab182c8ab54c35055c5853b2f26369a6b37934f46d69dd70aad89f24ef7fb895b51fe22e8ce955dc857355b7a285a4867e0c9d3a8004c2b76b0bc12ad33cf440274c8551ccef1ce880cd66007cc8823941c85a6f59ce821a56e4336b220816527fa29bde769f93d677450c8ab76419ba58eef56f914234205f446cfd6cf96dfc107d14ce4f3a748d62444267946d1cde03d0b83c94301a0768b53c09cb359a1236d65406d010da6cd6c969c65334dea07883031cf8b6c919d9287b389b347982dca7b9e5969be2c261a7d4214711182fb267913e7ea9255779ab5d3391b8f935bfac939eb36cf67a86754ff05fb40deff69cebe4f08c94b1d7cca768b822d5ef0d0bd461c71059d162d7993e25b8874294a28bb5c8b5f2c5a67675fb2ad66eb8f24825c98d27c2532784785bd4b25316ceb4c00276741dc76d164a062d6d66e8f919c1d79a711a71b484b18013d4893d8782bc23507bca165ee66b1409ec9b821a660b4d2532fa0e49232b47b2f46dbbf45ab3e2cd7729863335b06cb2597a02dba0da51a61b01d177ee2918040eea386fb7b151852eecaec1763a8149b2917cda1f6d79638b109d25d0987fe412c23cb46020124bd297dbdad7c59d55fe6162c8e71c342993c393c67d2a72d48b7c3083e67a14248c46ed45e2b2b500aa6f48d2cbdda3ac56e1f499031c75167067463d85d9490a7dafdecf0e2621089eeef4bd033095e1af3b112f9dbfa39ce62e779b7c5803b54064ad57497a8bfbf4f7f2c0400aeaaca5b00c3c961ff8f84e0389feb9f47f60fc61dd9175b1b7cdbe2fc2c807f6e4ba1f7b93d8dac8f59f1780129f6347406d7b4d9453f5a5e4bb3e66528ce86ec0e9d5484cbf49e390806358158a3e54bad940a96f63af1e13df033904d5ee94490abe9a10d7e7ced57d828fc72630d7ba2ed31827b0cf0b118d3bd6e7947ba697a93c3ccebc872a7fbdc556b80a94a4c567bc3057fad03738ff184f0215c951708a35f89aa0a055abd5a5da684d398f2c580b2731ad3bc48473a763a6676c5f8da9258304b765569d4052d72a35b2a2f60e271574766d7123dd82f64da7fbb95b183deeab1eceff195fcc27de3526c04f0a89930e9da0788beb9994053374b4c9132198b636854dafd16e9247897c47366a28b2fca355a3ac8208f4f7398791dfc9f7aaf526f0b09457d995bd5a2d15298433afd4a8e23960869df91e435940278f24d483087d67b7febee957021ac2a5f63995b0393affbcae617cac60a728c21bf1726c0492b19eb7bb7fd75867f113a8108654caab34267daff2e991cfed0b85c8dbbb33cc95b5071b2662cdee0042b9232b3dd28e128f542946b6c37125ed37849c12671d3a1a676cf8d13c5b8c14cce9614a5e9c1a2d3d1e0ef180234067c96c149227b09c6a7243ca41a627892ba5f143ddc6d9ff84ad12cfbaf92e9409b02310a7566f24ec136ef6abad73196a6ffb2c8a7563e417e6246f71a1c6806128574741cd60414f53092a125f1ecf5ed120db94f322b4863410ff4b35a8f90369f82973badc3e7abe045fcd7b95b5dc5c383b5e56223fe8b02979251a3e3a19015b09e8aa7997a42d6d981e806e0fbf5f76a45e54eac419b565c3ebfb42524e19e252f0d0df54559a05114609c8a7f61fcd3fad888be07f853bc8f83078f9069d67d05ddd610fbf953ce30b9ab05e0310e6e9b6f7e4673f8019d2ba6df93157ea9c6d866c9025d0b19e5f9a559293a5b39c2c7020c42e6fda868b16a9509a5ff365c990f0912c7513202318a14902641a5dde57b813b1e6e14faf4e3a0fa05ea3639d2faa41063a97cef60800473b152b57c401bd759cd6be729e6701bb90c0ef57cdf4b0b5170fe4ca0abfc0bfbab72fcc0b18a7187aace34da0311fc4385e2df2dca2465ec0ed73da49c17c58fa2080f3f0cd8312ceef305c05c2d7033ef5975d6d55c71a1f92d4d5b5477a85d47a763fbb452bcea4a1a835940788222f7cdf952219af4dbbe60b7b651ae7632f26e7be17f73049306fb995527b4702b3927eed6784b0988c9109d01d8cdbc2c8ce229a45529dd6d8d13033f8468f1f72b54992733d1c5e732652473a75f50ba5c9db898c31d89a4df1db0d91070942871e7ff8dd2105dec34a9d66da44651c228d7e1055f3f4e44b7bacb48a7c0edec890f5d810c104ee2d29862deedcc8e73473e3894d560ee01c14a165bf0249cd1c2172e6228824a36bec9925b171b7692789501b29400892dce889da3005b19ce9aa36e6801d9301d0f02976b6b91a1adbe3c6ed01dfac93279535c63b53a8d3c3c78e6d057ce95e8abac0374398b509b76a4e290e8108f15d1630926fede06aa3efd7f8796a7abf5f5c53e4b7efb0e4faaf91713df5d0d5dee447141eb02083068ecc30b83d016cad24b38d1ba618728eb4bafbb0beb75ddf54daf624436e21b9f70717cdd6c3bae1b00b311111beadee677f94fa03ef486565e7f47206e6e0daa73ef85e302db73df15ca2c135b4ab15ae91ddaa928d884c9c47150c718bb950cc79fc1f8d902472a10b7802eb14c2052d34f850522d3d4e929ce22ab3e691377309417ee3d326569fb6f16b42f199fd75d7ab069981903ba2a6912b916b77d8ea314a26bfaef477ed06020e908cb98b84682bc0d7c1821e98df760fed7d44a729ebb6b54d76d832c640bf357820a130017286e0d5e1d81446fda17b247be6fd10ec6c8944e96ae5dd728df3106e6a63c4b09a3c4a098210806890ad1778b1396101488b3e121bc3693dc7281fff994736c9c2db0dad54c763a3feb6d62df07b4d0bd3277fa84639d762799cab6c0d0ad79603e06509a9f2a71f48fcf5cc99d28fde2c6a47f9fc4a0eb517ee34a8bb9f9d7a103e7f4ac70d49e63c026916b355cb5c70b9f3f57427e0895345c998a928998ada6e9af573fd3a63b3a1cda29620dc14c6de44c04a0f08290de0161991c415432fa1bcbd04d81249714c5978be593063bf3e492f4821c59a65c702f90ff5fd15b85ee935a04a2955b735a7f57e5e561e0c2cf6fa6e3dbe6d0d78f9aa2d5ab1e67dcb351245d39cbc624f7283908bdf0a0a2d60fd543a61906991dfd45aec5b22a033d19e9d2a95bd7d1add1f968c8dd397103252624aa3ab1799051d5badae6f9312ab25dde46bd45601d368ed34d22b7e42c98e583930452eb37c20f963e17dfb4472382e93ccff0213c00c60cf6c2a8ae35df40acae6f784db5cf12b775eafdb3480d27003afd9dedc9f9c19afe0c91809d0c7f59a018d8361e9524c5f2e08513e9157c5966aa0030a00edbba8d5a3cffff7bbcba1119299ceb12150c74188767c09d7f3e6033e2ba37db060949240e42f4b26c6ba780ebe7d55c0d7296d46acf6c8df8cb72fcda3c37877cc50bb6a5f387b2fbc8199debe59e60e902c6d62dcd73cb07f6fbfd20f55f517c6dc82fa91d296e4cbc929d9594736cc6865d318463a4e18588406a0cff06533c2d3287bdc44ae46e193367392315570c0c897b6cd1398737534d853ff829594ec6c05e7b3597ade8a29e34414c27c0e04abf6e9ded415acd30e181fec3867d6fe1c8aa3a921be7953d89b553bf0ad7a5236c2e16e981e59e558443cbffbc71c9077946d148d181fe6ba320de248148b909ff06c899789314b55210d08999564a1cf2372c084d6da6c61fca78cb8aa91f979e5b38613092ef6dc74b2f5d2b0afc61a1b86217755f6d8eed0e60246540b50cd7020b302d10226e261121c6d5e575ec556c590eb970c6771533a55190829c3efabd9a244aaf15bdc2becfeaddc5fa3f6529856647adb57d8db7ed99657af4dcd3950cdd9ef14ba20be84ec5747cc702fc50ffa71c6e3827bd30fd358bee5463aa20fff874f7acb482970dbd80aedc5e1241842cc1e16b6d5e7f70a421fb913b6de5c68cdee2a2e987153a53c263e6eaac6059dd4e109f0c7b6e5fab3ab3f58ce1d3cb275c575700c185eba723965413b2de945471d5f6023f108bf704000570d902f68e8f821cf0d6f0039b0ffb91830e9503b3ea0e36f09968395bac451eab7e687377f70d73eaad0eb850ef17de7279228d66d4ee14539db3af89ee6386db393e9ce03cfb22e6b48aa085cfa7625a85688c487eb0d58f88794bec6ea8ddf1a88aef50c30438","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
