<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47af703dc3ebfb2fa1922c2d9ebe774858af01db783adf93202db85b89aca4130fc3405fd87f979f6a26891617e8c0dd5569229aca4033b8d77d5aab5f9607f4b01da68ff73023f0de49e598edaa074f548b6d04b4d837e4d0f6ac106f6b54757a86a836136a30f348f94279f3a238572c827b876acd399f8328730c9ef74627096abd1d565711b2baa8dfd1e11bba85f3723d858971872b44ffeec8b3da744294e12926840d62c57f36472805426b58d419028d326f224a22a3caf97b5eaa728dfff5dd0d6fc41d8938f7437cea074a45075250aa7c213b3d2813dd7d6b0a756256590661a1ac594b88b98d63188f42786a12ee6763bb506cf18beb9ba4d2868b329ffd6a749a8663ccf7a773fb685c22f8634d8dd932b2bf4c3592e2a63e9f2a6df903f6c573e15f5492615956ff385f9bfb11b9eca5d2bd8c7222e612f392b64f5687250f3af072ae086ec09953f9e5493c89ac6e61d56999a1d11998cc16392b10486c0bc3a190f54844a2596c1d7d5574657fe3a305f2841000d5bde6df9533fa67af7670adcc12f06c6a6e47e95991d8826cfc952428683d56007606c405bff3a41cb646a987f561920878fa098fe9e16c3c5a12a8845063f0405b61e0716110519fc529ab5b7fad9f809bbaea9c2b3ff7d43a470783c661f333a89cf0ce251a685a1928a3b75baa8a0ccf07c61e8304c461b6f5187f0b7a6cbddb37fb406819077b5f7e8c4662e131e0bed17cada3bfd76241f3e72a7b6c91099486a79b214683da141295fa61c7a6b8727821ff2cc524daf197be094473aaf7f6dea3856bb6abf1735fa9d46b52fd884a51c941719ee08f5c3adffa0ae86ad8f6bd7374fd6f2740e875848e045a348257d9f755334741dceea25a338d219864c022cb3f30071946b994569303e2a47e1072a85504c5283f53ed0a70426219c358928027725f64779b7f56f125ab91ca83416a49068789576fa536123f6f5de8516f12ac1235cf73f64297f4e67ffa9bd21805b4e44b13662882257e8e82898d68da3bd46b271a343dc8a0790d231f9f3cf9d489d7685083853a7a9c0f8f1939e169ad45a22c1999f3e614a1d45b672e7743f61eb7a693fc0f82f37877dde13dbf3b683812924ced1d49349c928ff836be262e8837443788544c644a63a2976e9ae5a22bedbf1aad3ff5d2d1a70a2f1a19ef08ce9e251c61dea6c242367f5b95dd2131970754c7c551f4a43bdd76d5955514b5cd64ca879d109a282fca0837c8c7820ca69339fd0b03a72ebcc12634c2b24c184c405d39147e4412265d1f6b2a9a371d392de9e3dc74bae3ade827d0a10a6742b70352cd5711ffed7bde7ca8e2c9ec5b767264200ef957f58557c9fab36e1fb28f541c153fb46907d98d1702747c58e80cf995e28206276c27b34a23136ba18110ecc3055fd2a0168034a9f30b63c5fe2a3416cafbdea7779ee666b1d6e12f444dbe8e053245893062ccec4ff3900fd148023e56c1581b4061f4d0b30f0ee181b381f963867dc042e57065d7e9b869b26ff26203c94aa19de0c39b38b712673571434773b69e779085a555db2f4183f25be9b87018bd66095f565c6a2c08196affad0bda72515f6573b03c8d29f0b0c17f362daea23e0642567e21e956bb6750645bb4dad13ce0554e0215a1801c924769c5594bd0498aa50ea51ea451d7bf190440a4c7a9eb659eef2e795408159475d630467b0fae3e9af9fddd41c2a9cc5e469af63db905d5917b43bf928cb80f2fea86d93104874a95819f91e47f85e748fb069e9942e088f3ff0fe985c1a8c8d62124b1deb7f26a10cece492b9c359ed3803f886e20f49c7190f681f6ca40d0cddf0a05f1e79fc53b31d8345fae229878343f8ba372c079fee41b295538ad852f116208d8958d66b78e5a77b84f73caab36b947e10a91165dd6c976988af8a60959f98a07588b265b2ef8d3eb29301cb03d90b3d7e877ad37f4ca18325117104ca56dda4eebe7be4fc4495739d6b1f731801d98ff07a39d9b4fcf7038b25e6327c7cdd22d516f8cec496882763dd35375702e71b715c2f01f1a36128f270d09b363f0981dad3967a30060d3fb1d809ee8d44b518cf6902576be3273def40a63b23d801c2743568ed62480acfeb5f61ae8aee753e89e3e09fbe50ee8c6b5dee244c2f2495de36944c147c5697b1c51b35f3fefda08a656cf7b686e8b6ad4ca4526e2eb32fe185c3213170f01347cc3975efdfaad179d53664599951630eca6e82a8685bbb095f469a9a54da6dcb6b9fe9df5894a949d0fa7ee7042911b0d17728a5d858e9a6a1d6000cc4c28b202edbdff88a1fd7459c35ace4602b2525fa5f0eb5a30ea7928d1fcfc13fbc5fe9e0d24ea402a037f66b2e283a7e71a9a0a756ebc0902e0601dd2c06569ce16cbba6d442936b797ed18d04f464ec124ae5ece561f180474d736707bcd5d87eacd814c23073dbbeefd594b865c6ac3bca9adde73291d8dd485851413e7a60a173e9f2192a0cc5ce790f83e21598d864636dc35f37140dc0664c7e3ca5d7a7e57f40d638e28c5143b93d0a522f28e58810cdb7b12b3efb662dd45a53ceacfa2569a81e9f010d4c57f8947ac2e459a4946d2b3b4f2bdd4024c6750a367d090073fb0819353302c08cb3cc95ccc86fbfc634c0d5527ee84477f797e11934abb94b061949fd910451d71ac8005d33f0b706c665daceedc20ae149707aee9a913d1840d295e411e7b563be7fdd78aaa9055934ca38d9d6b772cae07922e1a2b0dbb31d331237406f97f62dbeafc168e4ded2ebf5c74bd6111c33a584922eebc269a2e76ceff31bdd67a5b40befa7309e06ce27d768d6d2e98f091aa7a21f308bba7a6c7d99c3b6b0fde6cc26ad7c2c244a8618917d925f235848bb6d3d0f17951289c8ecee743eb8c9b6e7ac678954d86224973a7c212f7196139d938a5121110f491edec6e428d61719c483b4c78e3df56813e954844b62acf25e1df010fb19bd2c44f9244a0cb0a0851f7e6980f341618b1195429de897e6f0602586eb08cc92eb38f8992bb81f4f47c52201773f7053ad3e3273402f19fdfe9005ba1a40b1c55a79fae6cb39d9a830b312264fbcfc8c2d840319ab88599c66ca55a696212c59f32cfac748168b4831457ec557d94d2c37a35c35a98a197594c825927b9801a80e793b05c4840506544ac2b1b77909d9ec644ce1cc6c2900ec70f1724e3f5feefa34d9ac54a2ca22f67d74c56755fffe0c97b9cf4cabaa1786f47a2d3f4c9739a519141dd0cc3fe3b3cafd12fa72b126430f9ded69c34babb5445081970b6b69163d1a151fcf2da3720bb1b418f234d6dc748cc4fb103baf12edea604f237d91e666ade77be493515c6e70c9ef5f59691e043c4dc58579ae5c660fdf110ec8ecffcbf284431b543c7f48671e96dd2fc120f95a985c49e1805a89b85653341e61d0c6e5b8b4bdf568f725d25088da9fb8a95daa7b56227b6309c4114920adb1caf79052bdc07ae5b00c9d0a7eb0d5e0d96576077935cadd5b87ea4dc4617b0cdbe6684fde85c8fe9a038e77cfc49cf93f94c945eb358dfa50330f24bf4e8d19c5c139887e82a1d61197e726071e98787e8c52a82384d81c1b1fe6c3ffeddcba35bf865a7b3fc691df261d53ac7063d3281fd9b93febb403da73afba832f7274360188d8e842b03fe5f0886badde657c0a55700bbf05058cf50952fa48afe667a6b08aaf6d11e2667d4137a39b78b9fcbffa18789d05ddc9e3742db2476fa534e97797117214a192adcfcb0fcf41c764a382e1c612fa9ad650116f82668a403b56d07bf4c9aa52752b3c5c26c9cd3fa52f3e7da26472afe15323229c7e4b226432c57003ebbc3ace9b141b44a94314dc664ae76f62031cde3797a0fe026dae4866a101b1966c89c32be51c90533684d3983a04419e8f963b307bfdc6d572fa9fc408b68751b15960a15b500bb90f9bfe08c9f2212c7d19eab2add2b06c3e782c2dd8123b9fccaa60a61fc31a8642c316fb448a36e4cbe620a8184c440e1410b3d0b0c061254f1b88dba64c05b00e736e5cd620c950066ed7aaabadc6a39de3990e10029c4f9d0dfbad88b2a9dac51b95235329d116a21fe70749bff99ab027d1c8818ef7e64a1264ccd5f2925bfaf4bb3bd4f76e01f91cac8a3397b678b39b61b104cf388d632b5001215855d2112562bdb925f485b1392e33a5c9f5531ca4959856d784896a69ae94552538cfedef74f5661b8865e9d794311bff839da9cb44c03a97054693f60fbae9216da17eff4ea157ddf45872ce16e26a89e85e2db8ff62b2e3ef111506be8018b33e02ae387f25fbd8743307ad761b90f2b6a9c1e1c4ff1bf7fca9f6fd2fc0a04ff4010209e83bb4ad7048f0dd8104ce5f4fdeb198c03caa3d68062c70d99511d1f72b6ac782b11cf857c94751cccfb3d281e2ce81b0c72a7a6096cb76543326e417e0e87bad175a8833f134b3aec1e5e310c6b1fd76543355fe9ae51c57e1cb5ad534225f12ca7b9477b61773939e714ba7d57c8d279daeab54fb178f4387382dcd001e048566985b872214f375573ce2c403314687419c9bca3b43b0dab9b4ecc62f48b8557bea49be5712c0e24bf93300bcac32456f384ea223a858782001774839fde933bb264ddedef8ef3fc8a6c23aa34f5bbc95af4f76f45d6fe00535a7c4e8472646cba6c36af925df7c81ebcd06236307587fe1cf0b8380d585c191ea721b43fdf56f9a3b229d1950a3ddf2b611f12a3d13419315cbdf987805faa324e01d3dcecafc1dc4b51299b54f7fb05fee081a746d4e6a58beb65995685337e934383c376837caf4b8203b8aafc2af17802537c20c01f59eca9305d498e7af21d72b53d6bac7ad9d1b062091a43325026b15cde6d27eb7827d8a6413a6d844419c36c4d96e1e5375d747edd8317f192a15240e4bc55de3bb55368313372f11555a6a5eb131821f9bdc250991c4e1f1269ee03c0c26354a8e493a8c60bc728b96c0ace06a0c20fd39e3f3a5b0357b50cf8911518094a5ee0619827f9fcfb67c926da6e1c90492f2359bc9e42a728e4fe912f1a7b8b20ccf881d365603c6a95719a25b5d233c0b1bb8a105506f004a9bc64df13414ecc69307c3b4306a9f2d4be37374a4529851e176c45a14d55d75c30022d86355e3923725f78568291206f9f1483b6980617c271b6458852aebb47ab5981282dfaf85108dc1237b371a9147ad35d18e6c5c9144d90e59c6982217c66c2c2429b6d26e691e7218e588f6bb38ff7d1246134df2bad6a57ed8453e757180dc6ab9a4e5a28a2c62b4cc49e540f6217b68b0746352359594c12aa569318c78dd2975b1ccefb4ad8ba882694c8660c7e1bdec76cb4ca46235d34bc3861aafbd30e2e2d5416a4eebf890d9ef0a264da1291ad3f01c95d116b215bee8631b41f27552383c91ec3e8e4bdf92db46fea822e1916365e70297853c968dfa05c4ed009e8590395f02a71aa17bd2df8553e0620fa9155d924c3cbe95985a52bdc24e3fdbe77b50ce8f48581eb2a9c134f800d98bee807ae299fad8efb6448ceb6d268b6e9be2586e38e3ec5715a37492bd3388caa78a776fdd0a20f7c943fa788121a2967997b6b0c1a14814637db5701084ba28bed83573c731102802fe3f6beb94b6f334705ebf580467cfe350fdda05c397572982df11dc0b25096eb6d906fda4ebb503be8e7556fbf5deb54d498e9612540f33e7e23711da0a9cbb136d0016e5366cd6531c67575442e58e0cc772cdd9d54bf5ff25db0f9333ea952abf9bf4d1a6b30f714a1a6a6e2deba878563aff96f5947463f3bf4dedbb4ec20b8b803dae48b52bb34c12728659d742f875a182adf964c60890a61d37c66e570a8666983b202750dba04091dc2c983d448c70cfd900fcc914acb486bc14874ed99f544836092ccae2909610ef2803bb52ab4a00b1af8db5567889cdb28e9954eaf8907e0f7f52ef689fd32419c6b99de1ec6994d08a2ac193616043f55df6731f66306076f50f2be34a42853e41e22ecd8b462fed8ebc2d13077158df2f189dd867486c08a2b922fcccd009a496318c0ced4577f73b4bd9b760d5b6022396ae326c863b827b578efc06cb1ddfd26ef61fb84730c7e14df3623c9375dc206013f21aaa5d4cb056c197bb497b2acc7dad882986014b51055e19ff3580993965ecb285e8723edf6d7813ede127cbc66919932a1259ea94b1a42828a4ec75fb261f23e1b277d87cf4efe4ae5be29be2bb5b6d4125abc7da6f4544f464761fb728acab59ab83dff77f72bac99cb1c611b6ba0e0d19f6bf2e9d9f43849e840d1f6ee888e9ccf15cc9ab2849af9e64e42c3c884e5e9a92e1b2c4b238f5f6a847434f97bd8eb9e4fbe252c600a13570293efaf4bdc24193934e11dc31a13df71d20873d34500efa276cd748b8b303749fd894f3384fb0b312d64c00398360a5f9251a0d8587fb53a845335a5be87361360159e5ddbc8b952442bcfa22cad7a7ccd178c1695d423c064d8f3a7d3b8cd63d319f33414bd3c9caf1dda598e5f69879c8063955f5162e5c65ccff6ff9b9b4ef4c9deba7bc7dc4bf9f3c732da08cc98b070c5629b4e2d860bde9187b2e7a33192ba58ec8eab00bc668b7ebd68092130d32044320063b1b563b56ba19a76d7e9de04c44e366ada29eb9eec2af214ef278aac908e2b114ac9d9beb07c8c9fa898b890b6a63b20ca85ee51a85175fea316929a96d04d4a28689f79767f0570264cb71f309b2dc9cd7d142dfeb3ee5e866b8cadbd15091b354437632deb4ca106471a76387685535b148fd1b784ac03b14d30a312d96521e1dd212c4c69187f2d92030b93b8012862b3d6bbde6672a33ef7b45bf84aca3461e21aaabd7fcf46d2e6fdeab70b848e3f9f0a6eedb51d3614e83976bd0aaf3cccd3244c55ae07ad81f7cf06586ca1eb932ee6d564eece0a4771ece856404c0f89a087fee635a890ef009504908631ef59eace3d3868ab893f03e92e739287d247d4f575c9f99a43764915838e01ed381236dd48606f2e16489c427ba09f928e65518e8d72f7b6ab1d1378faa6a7e4357f8230757af3983b607e2c22d3c8b6d3419f5f2e77e373408627ab54acc8128489e64e38e9544db00513eee4b7ce97f28829c97fa7e81dd9b71d9691740ff00f618cd9ebeec6c14fe394c9568b978a1cf61689f949b17eb9f685e6e6f2f2c893f67192220520687cb37ba51cdbb716ce1a961725cfe0c84e268b9b9504cb7f3a3197247f325679db5e8c034a033346e26c7241d7ca2bfa0510b7ba49d00fa7357bc48eff4414b2149d07c4d328da51ed99bb9272b0650d9d27b205ad6510cb6b4cac96b53c2ab797f55a2bd20f9180348972e443ccdac27117aae3e2362d3db39737ae3986dc745bf2e58949ce80b351d63c99cf862577b7bb9e94fcd61fdb9588d29b856447da9e66db4a9ec9ff08bff4b8eacdfebb3886781e4739d436b26188fec7c5cb6f015a4ea99609e8e00418d2eb446a9c6aa738d2a65825b3b2d84ac49b535fc91fb54b9786d2addbdd4ff438fcd27873e229fa63caf81e92f79c8b6245f2eb68bdc955dd038f496eff9f6a857870695a422548591f689985341304a111b825e6b1d0cae8f71461978d76eacaecadb47f02467c7f59421d9f53ddcab10ff24e8bba3411d4ad380096fd90b45c93e91df7892b9319a33fea9d73a9b74d9ef906ca2ef22edb8f3978964a646b076969e6ed933b51834c1321a44b856a8d8d1587a3eb5391da139e023bdc0f2cba40b81311aa476b98e39849769da66f2a682cd2ca99824108fb9feab41636bd40e66fb047909a479721a930a3cab402b7cfa866ee4d0430b1a105152eb7ab61bb82336421d094ecfd7b04bfcf754a520651a9a326d0d6485140317a22eb9b44d0f158f3929291a47df6d6a8e0cfe2f34a5bc2fb0b83ebe094c3f241d0f34720b7965a1f0f7df17d64466790341dc806109aec5f1379c0177fd2538fa76b3eacc674fbcfd19b083859fa883b89142d83c9389e9affcf230eda9f3c16851f6ad453ea6c78d9093c9d019b131406c503e0ff32834c94be75f02e6feb70cd02cbb7e12890388f1b157afa2801d1fafade62bce0846fe8e0d326d77f1d4ceac3eb0a26cc2b13356875b67b6004721a7e2a8272d0f65fd692d60b0d178331425385a92dbf258c06584e10fda3a90b555a1ebacb00afdef2dcd514c0dc1b1cfbe2fa5762718132829afcdcb73072965c4be5dcb664a1cf00cecd951aa831dea4772544885189325883d5219b784a5b6eb78ee8180196cb81572a3acddcc0a0932e16c3896bcd04f867158b9095aeba138352c8c8455dbdd9ecc4c1cd70f6256832d4ef9ac45a5e1bbed4054e0fdfa6c4f7ff7815c9dbf331623316499d1deaf74fd10ba5ed5dc04706dea39de58027be0e652779b6400acb80b38fce9fda8f6a963b25c13921823f0c22231526dce8dc226ae182bb49e0907afe74f1e657f220d68aa2405aba51fe25a9551c528b3a689197f8a1abf892359b8b4a793e3dca751d3601466351ac549c4076c5fe291d88172b2291f48b05411240dbe718602a560d0da131d64ed3a7da520ce70b537660f0df8f98fe890515c307ccb0a179cbd6b6223e7da48822319bf4daacc6b92642e555b58c9019d5f94e10e460ee30bb7eac2e1ba1ae857067cab230ef15e29917c74479ced34e18a45fa374f0803dd6469e2ac7176987f6f41bb6649db21c5ed2d439e678a932c4b569f58d195009f46c64dd2f94375e47553b99f984972e4b4fbc6b59ab6a5a4767b68c53316d720c5aeec1de65baf428587e34fd4a4774445da46e147b6bddcdc6cf777e15b285860fa4c1dd768ce10454ccb643c462cd323e3ac9d33cd2ca8ff7c33ae69da5ab17885fd80037d483edb53f79382f4aeedc8d30b1de78c78e558059541f33906a200a3f3ad55c545601e4387cecb4222f12d19be17e698e8ac60c4913da82c5dc93310d157d32f7e1c2d1b5a76ab90b090671127afa37d9dafd1c2f4b2e9e9299d63514f35babac1b51297a7a1d2ac4736fffcde4fb3c6bd765264d6634f92b7a15ff1852f9c7f56250ba0f9c3fd66cc28587023b4ec7e0446a4ba386fb504cd8ea305e4c1373f6428be68c990ede567bd7d7ba625a53c322e033982f95a1167cb68bb4e09af5b2f701d9b5b6d471d34d62ffb38303defcf96cef2d5029673d856f7effbd7739a9567684ba7da58a806be24474330b0b5a1b1055c77becea93f3783d756a846d4bfb76ac493877e8df246e8446e8cd6ccac75b07721998474493e5c9401fa2ac60f12d9bd54e87614c0b22d84f54c68c00aea4415e1c889613676574b47c07078f4eb42543b23c7d48930509348d4fb84168160d7ece86234913ad9149980ee27358c2cdcc115df58ea8d4f5fafccdcadf223352dc63e2d24e8cdcaa99ac3cb2fda354021fa0c27daa103c1a48f591ae9d9b897659f795bd03675ab892c5a8b175f274422ecc76dfc5888d030e9ff67564da5bae379088f0db72efeb9423a64bb0171ac8d3b1627c9b9fca09641a4b76adbba8374b5a4ef245ccf96a79734476d47b822d1991eb6d7682c091075060d57ba8f0de87f4a4b51a1611526fb2508edc2f68bf7fd09c5f97329f9c87a53678ca9cde665a57ea108fd224d7ee48b3c1b21eeee3ad77b1cf338540dbf0d969daa0d3c474c1ad55d3b2c642df8a8a2ab30cbdee25a9cec1b81a33da00c15ff7d5c70e4033a9edb1d5b4beaae68dbc3aa4707aa4b58df4af7c806db2672251f389cfae2d650f277c4eedb0a8e6908c156cf3f511b2ab971d495bbab675fd1d9a58da61ef8281b563d2bd6c9ea9f9a5c17d0df5e3abe3716c2e28a524e07f0afbe2c3e76f2155470de6201e665531cc68033f0bb82e7fdac01bfec41cac6ef97f03424064aa584cb6af4c18d18f548ed9b73029507d1344f64f7257e9c8db1080b98d6e21c6a77b7cd064a7f10dae87dacec967e8561596ab9aae7eae50df8d39e081175033dcccca513f4d26500feec23c9570da8f8e1441ce6e0126efe3d86fd79e745eaff4f4f6b6752a3de93dd97e25bf5d8c38c4e8da3ebac0c5efd8db1f19d60b08bd2ee103650e49f775f4662b495316e10378088be3b9cb315f84f5f562616ca2b13cbec5dcacac46ca2b9c38c95423e100030e268e82ad1596c2fdf20fc2806ff9cad813b787a0a861ac788bcc4037fd8ec92dba5e4c317dcdffc479e743769e8b458d9308f0b223e924103852ab2111ef97177f0129e0d2d0999961d6d072ec80a400fcc20f5dcd7c0eb36e94260068a555f2120db4a6ab46943b9b903af1831f638c4efe2cbb00737a0afe19cb090f002887bbe429054ff17f6a2c5e93e6bb810a4f029cbe8f3abfb36c82e90a9f12d5b6853111eb5e0d09fcd1662b66065fac7a2ee63f2e96870c0a878ce8704937e3ea8cd34c9e15d4ec16bec383cd77bb423dd7288c613d2b05cbf3fffc5d7aee2c2cd2c5d15ee993b6e2f9a79188988dc5ba46d4d5d7d1e099fe63e044e376551acfe5684b9e96d888b225818d211496b1c02f8a54ca236764e4b356848713c4e1ec42ca0e2520ebe75bc899985d2987ca84a8704c982e8ff35cda24c2d9de6f35305a326d431869eea37968a395728bd89b11b41562e6452f1815efe3a270e7baf8c7a8f2a295c386781533b8e3391106901b4aeb7642c80f6924a1cc28d9c76e8dfd456e4750fe50c696a2ab358a81ac7692149c28fdac124b4b9a3bc5634d42eca5e316fbf3935694e825ed6cd5337b6a113ecce1922adbfee801f023f9fbde26a629cb5137ee91ffbca9e8b1281eb40d68d744707de0e70044750b7a5ef201869997b06aac5ae11c5970279a7842c19140f93f2ca784fdc128167df87339f49dd66c5fbd94d41c52cbfcf5f6de5f510395e8d975c57be68b12a920cf817a50700b302b960eb74dee2e9f5efa84ed051731c9ea5cbc6c25d2cbf9b73536dcc8f46142fb25c405e759b5cdbeaa05c2b8f5e7dd9f02215b1be4c08d01a0a8e814a02829fd1b4b0de966089aaf8eb71e74e9ea8798e43c104aed3bc6ddf5145e837251d115c450280e8ea0e1399b2c7249f9d2048a785da77373fda95059cb368aede881c22435ae281bc0a8b3be0732ba3b2837a6a6db29275975c98a5a98625b4d1bcf17888346f077ec790b743f7ea8d46d291edad3a32c432343e876c83c83bae0f6a9e3dd29cc0668e51317e57b1ad67ea908840d1927941c018e7aa9c0b06146963929fb48d755064a7aaa77103308e08b6382acdd86809d94b2ac6e39a1f350afb0e68035408e1156ba22c79f74eba1564d9de1a16767c1f49a339715944e65f8dd3a7342b5d48b50af94ad211a877d61f569c00edadc9e676ffe8f8f126c89fd608c92d8df91932ed0ed476fad46ce20b6cefcbb4c6fdf1a52fb1e4a7c9379805e73756cf8bbb489cf319ec69a314d0a433ef6c9e768a1b03494665f5a0935b68b41f188e00666cbe7be60e5e912ee2063e2ca56dd28c8d78b9f6efd8e3dacc2e4967e18806f26c5ce98d48cfce3ceeccbd04af7a9e90b5585c14c031728c34376ae2926065fc55b01d6798c39fbc9fc2df0325a26c81de48f9efee438baf1606dde51e3ba21938230b9391f57765d722c6caa9303f7efeb43a986f26e6a733867bc5d4a46cb72ba80cf54bb551a2086b25a9a06b46addb0d8c82449fcc6975e2058f17b9e66c2c692c9a9a65140be9ffe9087460080c8a7baf32876e822732c81cd8162ebefa1188812d89d83dd0f7a2893634384c410107a07d28eac97c9dda554767436aa69bda747a1bcbd7f6a9263b4d23dc941500e40b483c0a6961050dff4ca1caaa71be7ddf3299e020e0b130ed23d9834d0c780b0da7c08596d31bcb51ea9dc6de7253f5375b5891f07d9c7d317e44ef2b35ce51a905c7a291be4449084f89e5a677de44609497957fef5aeb93aa1861060dabab87c0ab7124f2b51550e033705d20953777ee6a886c04f5d38f533337d9c71b07196cfc768c940fd75babc6a00f51adbde6b6fc91c29858422a45628081317e74e5a0da05a9dc8c34f74263a36380c114d3dd7a710b2636be60633dcab840dee24f27a243b79933ace7fa76df6f702042b1bee8b52a4ba80cb2793a53376dbfad4d529dc5b36c36d91144662ad54d92f07defa608c11900e7106b8733f63281435abec384186d2e8af256d11b5aa1eea47579e52655e1283066fb91363bd100a20675b22caaf9aa225b304f13e4865b6205cf343459518390b098d65da45ca8beca36d57c9d807781c93ac6d11f2268a186c5bbd6ed33ce1c1e21f0ce655065b4ac1c64c36837f8250d5eb3cfd99d5a2bbb19fa56d728830c7998b628266d5d00ed8fb6d38260e4030114285b4d058b82ea9e5c3278e08afb317c3d1266345b64d70b909012d72aa2f3411147ea0a44dd65f63a3b75da736614b59846741ce6dfe61ccaef83227dc094e7f2b2f839065942a8bd4578a3f22f44c48dde7a22961ba63b804a43a97340fddd383941ed94fc6a4a4efcf891d671ae6d21d0f090b07488afa0a8d76f95ddbc197ee537b8ad9a5ba991ac829d2fbe5af7fcb49a3b41e96fef37020d03f7e67c6d4f08a87ba93be18375a46cfe75669ed5fe0104ca622862cf72f183c49cb93b4c68b2aed5fa20ab80befbf214db1e58ff5c85fc53cec32aed18d725f78f4e1551b4ce3de1a7c3079d7b1f1b32365903f9ef75774356506f6ad756c39a9bcdb3007d545b41d289580fdf0c3fba9b157f086bd2b17ed233b95e281b10a25a711e7b1ee430fde11846ad7149119b407cd1b00d82a4b240506e442eb44ef4d5372dff802115ead766a11537e7d77524064b618c269323be61f66bcb7fcfcb8a39ec66d9f921a115ca1e2f7d93dc984b9d1bcfabda8f8299449afe363d37610ad7eecebe073c61d541ceafdfa03b8a7b7c346bcdb6ec90fa5c04909a3f64fb12e4806cc8dfdbfa786f58bc99c9592de54908651d9b49e031b46ae16a2a92d715ab883b1d0e4c88f3bdf50a7e82ca303ad598d2ecd873f891b3ae6748593732073b0aef586d58be8ecdcc1d20cccc444dd07da1ee6668d84c2574b16ec8f8532fb41fe7fcb88a8a26ecea85283ed5c32a33bc175ee09e9c45cecae4f85d4005a12554510339c803a25f20b17b0714ecfc2b2a9501e25bb2ca6cc84084dcd6ad22d2453e129d589712e6c68d03df6f836ebcc2b30ffe2c1fcccb5e54ea10c8fc5e2be2b0cc1e0e391ff28584e38901817af745cb1c8af33fbb283255bf2a5ae9fed519a3b02664bffc737793b226d652ef6a0e148db47b20fd6581844a0dcf266d7875a7d5905abe9c28557a4e686c3893a1de0afeaedeb5cb92230096483d492b845e4fcce293dbf486aee980a959ffc82597d39ba23077f417ff4e15801d2b02df8b2b14dc495f7be4bc864006fefa370af7c27c054bed5c0e17ceaa65b7cdf39fe843c13249815eed9e081f5d22b07c0172ba8ff23e5739cd128d2b5944ed866ea061639c3a04f0fe3ae29c2d2ddc401bc6e4c0d88effc36c47afb30e99cbd5ffed6bb571620026b63fb0b515b0b9ed6a888749375d94f3762dbbb8ca65790418ee398c73baa69307b9109b60ac7255a7283ad9c9706add797d89365295149219c4c73fda84612fbceb1943e017200c433b41cdced5c1f2d5bf2331391d49ef48e67cff511568e46127f618ddba31e49f657fb3049e5660ce5b80aa65fb0c2329a25873db82e8a7225415c3d967ba681be57388a96bc2c1643f72e86c9caa48fab91f7f9e6498edaa761dd6fffa6128cac2edc014cfbed02efbd5ce6de871b705154472702151127d93c7998fb1f055b3149f7a31e18a48c69af3075063eab163d79dd0948e2dcadb4b8cecf6e1629e7019b0c89ed2543d1fb32f04468ba7b572e4d057934713ed90b314d983f693b0f1a4fe5bb40ebfa33c407e079f8adac6d89f053e8c90791481d4d5caf417306a2429f592dbfc1480707abee1353e0c67e9f1536629f9ad8da43d93c09ae4693156548ac8dbb7ea46c5b2fe8299a68cbfedbb28828bab2a83b0c19c3ef62c1d2aba709e3daef3594e3034c7d6a41b03dabe57f065428027e6fbcee75029fe8ed81cf80adf1861206b2bbebc986cd104e71c7be660ecb83cb6a2f3fcb976dc2a6bf6526296595c3c6cc386a4bcd536f1296c8433a178d93436b083a50c8c504e65e5e361fb21e3b51e80f89546033fcd72c9f5f54247b6c0c2a5fa0977412a83c2e1a3482e058dbb93e18378cb6b060ddb7ba1d7dc0ca8976ee581d7f1cb0e684211d8405dea935cfe36dadfaf104ece0884b4401373c7181792b49b29f68f18fb2d51318fe5293b118a1c449bf1388932f00e01486bbe13725ade7bfb4b66192c04b6cdbe909d21ee0a95a249e078243e1bd524b3c1955a57df631a1550838aa7641c97d1e47b12485c0dea14116bb4d1e1d660075d162e59c075c84bb77ce0bf3c47e404b3c1dcf81edae624e0620684769988f00c12554755b56d5391dd6b4af8dc3f3c650fcdd855799918a6c0719ec4eadff2b3f8057876dfeff14027491b96f2ffdc179be55f9ce7241aba4c0996d9b6a960013c602e96b18fe263c68c3c273fa8832d4d50fb07e12b80f1ca7cd8715a9ca31abf20dcb00a95f5b817c0b6205edc8222c77e6af2fda779a7d5a6d1247466ee81c0f043ac2fc3c2a345cd01873e471374a1ca5aff23cc9c2b3c9de4778f8e2382bc571e2f7af2d86afe5d92d3142f9fe974e507e661e55a2d278a02bbbc06f94936eac83b5c9d413f61c15167524830bc168fef29329f119afb2b20c774e0afb8e39ce54ee07ea22cbecf418d5ac158992e6ef5a53e05515550c66c0592fc70b88004f36e2c7a6df65d5e86fb13f3f47c2bf81134f9b62ae9eb87aec24f7a562c9e91aba1cb589f874d147e403dc212b0ce16e7d7c5e3809260bd7ad135df2aa87cb4917a2ad1f2c2c51db230bbfeba0123b3a90bb22c31b0676eea91c895e2150354e97099edf2a7d470cacbc4ceb35278a660c9bb26f455df6344b68f2cbef41b5ba9d602ac2381c10d87499ab7187ea4e02b9c0b1aa9ebad3b61e99c5a8701e9da5c3fb7186e52967d874e9f059e00662e1501d5f8dc7dcf419d3eed09192ae9f5496843e24f8a0c718d212cf04f0da22303b6e0e9e911858a013efb4971389824b2b1656c85ddff2db249a013dcab0b9b28c95e7fe10ccdcedd01e34f949a530478416f3812fe06c5895b9f1344034c29b50d9c410ec8a97479ac898ef131294a8e64cf9e9f4cbe1c73552014b977e94bfe35797414f2b6a886b914756231c57e2e1a0ed8ab38df4eeee70c6551975394f45f33c6cc92cdaebe4a27b0b0d0387298fd12c71543f5ced03366c3771dddcbd799d263a96483cce96ede0f07c46e00cb255d79790c5822597b66d6df860f989391ca095b6b40aaff2ce2fdbb4ad9c0b222601d5fc9d9fb7ba04f9b1131491dfb73c54873ee69d9b613067cb2a65a91d9633c65b12191c744806e5839c6132cd61e705a4c0898c1db64ea6fdef103bed757a6e08b80f894eab1f2004ed4982941892669628574010872eeb8429e2413d91782bb5f9100d3583041f5e8623e7cce68a3f172a66acca4d9648b27640f0b49650d040d46bd493856e10b8cf4ae2e02e043ad473e83a571be6f754e5fa239842fdeb90e34aaba7e196f9dfdfffb935b07c0c0966b12bc355c8bce5fa4173f82616cedefcc81bc8d523feccd6926e84cf81039349ff702d3253b95cab03de8f43b6aafb74a64a13b29f377a091f3ea3698a7fd9b4d0472fa2ee101043ae62655a7619afa7c23827b48d9a96b02803a7041cddf2ea872f7278050c759c08bb059290a063830b0fa276564a4b312a8d0640c2bb52714b4cdb69e1ed8267fc2f181abd11b46fa701f8a76c8362f09eb44b1fe7f61ab9e45a5801d60c2cfe562b85d227a4677323c8858c9a012eae19e9da1c2a4fc22ebd10aad5a8a14a56991529a9e4773baa2ed4748bdb3e979088532001c0ae3a0ae16b5e5eedc4413bd9dcce1d347c599f617c4a89c3357f030a920b752ec5c7bc53e82271a6edd4defd02303c5184d9495fdd64445a5b6bd7a26076c87c3e191ae6c7838d5c98e35a067366641b175b966cb7ac7f5e14dc8ca557f0905e7246f37495991fc51bf9deb38272f8673ab205501971b6239ae4eb9a3c95be738c51cea8090ac26f75e0cf3c09c9142da3886d5fc931e3ee061166786c1d52e820112929feba25ebe5cf7038a776225d2814223d59a9a1bdc5a9bc5e2834c0ca11733f7c866813b6c2a28829935bd3460b051e1a860e34d86a58cc53f768444ba8e713f90e40727dcac4089d88020b42b7fd453234b694e61279e5c3833e4cbce4e823c0b43fe18420274d82a93eae9904c0a70e8453e8c5b9cad65c7e105ad66943e90e56f86832c7f9e3ba866bba787c714b38e21383252628cd5e6ebe475282b60959f901e380c0ef7bdccbfe27f258fe2c8d24259a4ac46f1d7115f0b40a3e5576e448976bf7a1f83a9a5d8b0644bde709913ae4692221c4ab11eb1918ad18887dda9dbd699fd508378ce021721771e8df9955a1526b615927bcb5e928ffe0e6fbd346a352b1d15c502f59f2ed3698c12c2457a0c6fc1ddec772cb2337fe28f79d66ca4bc52c14c49dbdcc85f50cfd18b6a44a7b8801bd081dda0fda3dc6ea81bb51e17c488eb1d5abc2e19f43585542db4693c6b220c702753e555ebb03ffe863986d858668d7112ae90e50a56ff68eb28cc0354d5fcc24cd2ac956953afe915fd965453a88f11b4749eeb3222c53106d6dfc235761c3b6a1e5f67c75d16fc52713d5965d6403f64783191153e22f6d6e31014ff3fe64367b387038ce36741e511cc7861c7993b6c690b9fd8cc86497b0284c5738e94234e2642ba7df902eb93b855700c698d0adaffa1fe38e1bb28c98daa47b0aec27aaa5390fbc98993fe8887f0b346133fc6c944c203aadcfd30f8cea793028753a0144c0d7470b01bdab8e84f3e47267bfe9d3aa2837dec2e12c9ec88bc2e55065fb9db7789906724487833ad48d574a9cb94fbd5f496379cba87eecbdcce6dceee3b33a23b04567877827a6e13020b3fc7c6e4f82ab048ea6b7c9d997b5bd5c19741b22421240f70da44063557a7cb101f353f8ed16e55b9cf4329d8468d1dd968e2b691061740c7d21f542e6b9a75e2d49592329a5f475fa5bd68cc2339adccc724d1cdcbefd79544eaa2f8fc1691925fd6fe083bc32647d80b2b9593224e7daa4fdb49de3e6282e444d767e13ff0bfe53104bbdb1307230311a95c34aa72a6a8ae8e67d7726211b99d2806971841720bb1647fc599090dede7d7356ea634a3933f11abe49e83d3ffe8197b797d7c3ffe6027d88264cd74555c241ab76d46011f130717d5a75b404c23a94480726a6c3536b904e75552f3fb0e0ef3f3b3b846e6fc9d8113f8c45e9c5475b582992e12c8eeef117d1a57e19c24cac65f8767028d6fd4bc1d4ce30485a206ef359502cc11f104bcbd65e83527cc8b03e21f5eb85a3adf5a48a1a8f9e96e094aae03df232cf8e5d5cb0ba8da8b2807633df0aa76878c270d4ca04a8ed5246cc34343bcda2064f443bf63b24dc4c3efc8bc7fd5eb5ca3a73f87ab65130ed052ff5a0454f06a2f9b725c1c79c4e8af8b4a7c931001289393d2363f3b99948015b250dcf94967379b44fd4ed34c1d3cca282612c71310eec371d970d8c21cab4532bc26f75645daf56b3aa49ed4dfa8b1bd7695b35b7c9c43cf5c571fe2f4c47af03a16f807e9dc75dec6fbf5f7a02679659db4ba1cbf0cfbe2398090f3b8ec2274c3132c87e7d88c1a46954690d8573fffcf3150756458f23c415821fabf392d3b53b5b209de6d82dafd0bd35da0abbfa8af9f446509390c4aae16287af3662b800b08114c3ef174fc3fcb1bc6ac8e9c0b8891ca7a6e3be04628ac7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
