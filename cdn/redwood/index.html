<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"027e156093b16becf2cb143c66e34e24cc20c9480309845a8da9b6a0b345fc70bffe379f3f8969617400e636a4b3e1503b77f0db6e6e36d578301b849394365f94880c45a0cebc71d34c13bea0fbb501e3ac40bcf08c16115ce9013d6146ac60162cf0ee3892235531224672513809060752c0ccf3a2ba876e60711d2afbf198e312362024769e9a9c7750484a14bd0c77313576deec23dd50ff7e3b936ea42be3d195a8f0312137594a001936c079e0548b5443db36305eb3827215caac40cb749aa47838252dfe0382a6b343748f66def33cff141de65c3c6d500e0409f7cdaba2bbf39ee7eefd917fccf1d7a7ceab6e3f88d0cf4281e4a278cf0c7a689eb51b60c69b35d884641ebc2475e7c75df78d54220990b129719b409f1bef0f25e5fe8b893aa4b0214fad02b5f95a16f11588c9b6e389771ec9f2e4d0e6284bc278132be89389836146300df789ddfcd985b79076849b350d1116bd6281eb581d3767848c721335d25067962d0b4467c24e7aea9460ae4694d37593994e818ae9751c6ead2891c6067abb3556e2ecc7d4ff767aaec523f2765311d85b936939cd49ec5b0d4dce41fbf795c73bd67065a0fd66033462ae3cefa958642d5d051f4c28d10abc3f39a590fe7d0039e85d0b95f4ec45de5d38bd6ceb7a8a943b6db9fc0199d106415954f3793bafedc757fbb89389158a539e28ef70591c50d3336b744b00a945089815ad647de4ad3b19dce3a83cc40968a08ad571c28a8c1b6b418d9535eae1d4d551f81285384bf960c313c24b2d2dbbe9ea36fe5a8d7e19cc44c643702ae74761ba6a4eea246808e2c4b7f54068d3bfd795ede7bf272447f2f96b896c0030831dc63d1f8510e0382bfc758ec7c2afb3111059a4f70fc5355925813f61913c80ba36e51a906b4e1ec26318e15b4041716342315e2bbd9c9654acc2d2911c97ec04161b01de6a9d20f62603cdd3283f3febd82bc1f24be21ee0f000f350c816deb6d8104437bd4aba751ee889dede519dace0be8af9ca89971797feb6fe9e4c2d1aca315ed9406471ed1133853b68dc7033f0c7b9d3a35e0ae6d47f43dd1cb6d65d1f17c8d636e2e7d97616b7dce1d2ad36eaf3573c166ea1f8d76e7653e8af667c1f91e99233e1d7d2d1a6067ed1e1a06ecbe4126991c897fedf09e709b7f39b72d4d5bda6391a09a1631f0cef6cf7dde265123e7b29008419a5629d5c1e5f4f1ff489c575f82e04900ec06de1b030c7a7a4492a6eaa61ef364c2b5006c86c795d8feae02b4e124bbe78b7c5bbfa6f5990de9582a723567c2b738134a6084c0a58d02c3a349499717c7213a29da87aa04c6c1cdcb8dddaab07d8a6d5323c7f49a69e14fcf0b6c8727b3cc1a81643aeb3fad176f8ff02a477dd18bb6de4210cab48738582fdc2f3cb44562569c4a79881d24c39f91cf2d38664330203c391240c9f80a228c348dc465c0bb9d0ad3e599a346e3d45ff13d9fef1f09a90add69d0a9552705e922b4dfd6eaf5cfeb079a2ef94e8c2c2b6d36b02439496a401b628afafd25edf7a62d24f21241ef849fb9cea2fe88cfdbda18292699bf218ca608f96e5d71a51a5b27e39926aa30ce4db51ae736a13503b4cc32100aa84b7ae26994df7eb52459beb2aa4392521f2cf60e1ccf2e90a9343b9b6c8418a0d8006bc3ee012d80fc499ffba9f4902637c0e91615f9d0ffc6bc0bad15fd1db639197cab3107b11d82739536ed66340b0a5e9df014ffbb5b50b37c627f5e1678dd056c1afefd807a919fe8d322d0d0c2e15d6484e18aae018a5e7193937781556f6859c11f1abbdf6602da6e4cdd2401978c16c9628a4d8be1213c745cf942226acca4ed22c571e96d39ed49322b1b751685f0a2f26f3b10a760265dcc2e8f204e21b584b52cf5184a000f0cce8e3043c0c44b3b59b1a062333d60cce0164347342609ad2127489f32c068e8756d26662389436d8baf3ac0a89c74ee1a6401b2497ca7c85cee387bb944cb494cdb32b34912a4df1d156100bfb4f8429830416ddd0843fad698aa7cb19662edd33d4a6b18062c309ccbccb19bee569cd96d1dce755eb277d79b141adfd6c71ee5d2fe8bafb1d88278624a3761fbd33a6053b6fb13d7d964204cef9790da0b72c508515f40c3c1e9986a3ada30d426c4cdd0eb4c750f8cc3c3065c0c309f0c034b48660ee979add2d9e247e07272fe3bbe12f23a42fd132cd9373a3b562997e962c922458ae015b235ab33e83d85eea537d9e160addfc2a27b799ef8c42ed8e6e5ad2fcb69b66c76f0ed8e8003efe8f941b2806d149daf96f8506b4d4f71fd66de6dc643a3909fc0f1ccd1c96c556e0a33db746f40eb10bb3a3f1c978316140112696e30f00eb377bb6e4e926e9815f926bf7fbd7e1b136a56f769272dd8b7ce085ccb9357bb92cf08b17c942215a9f117f867a4dd67a249d78fbe5c630bdcd20de6d11bd937e6a557576bd1d3804e33ab94f64ce3a7df61da603c463d5b3b91c52560cac03d25a7db63bd72b473523396c65e488b27961c0f76300dcac99e37b589f2227c53ce343bb21a22639514af246bc77158210b378ff3fe4f7254d6025a78556c66bf9ecf9014204525f3b93cecd55bb25409b6c517956a08ebc8ca8b3b75f47ac9311a0a97e3eff6de204cc4ace6dc7a8276bbbfcbf318908012df14d971994afe847024e659ba43c3cdf8db2a08c8960f1d65f5e2bc7057b87daa6aad9e40bbfa059cb5bc5cee82f0b01519bbf3c594160606f97d25f39da35356193d9113596a6c3075ba51a91d02e03dc27f7e534b012511b49774a6777dcb65cedd3788bc0b4ca9dcc0714263b86f74c55598378232354fa7772846d9cd38bde4db9955a4416cb306df91230a1efb3f834b9d3e93c92b0d6ddb407cbe8bf98efb1baec37ceff6b44e53275b23dbb9ec0857ecf1b10585a244d8758ba64d1d469aec109292ce1e46de1a4719f18a30fdb8e3b22b34e8bea07c66535de552557d1b97c98055108c622da1e945618eb96dcca5b86f92db9c1a876b2b4a17522d0672b0bd4d292b7ea4183e97f328ffb9650fa73dfaf1674985a1a7a9ae9e40c77a73b2b41c41198a213e1cb7c076670fbd768725982fc15574d4ae13e41e42d1014dc32623ed2e85a4d6a1b2cb48b026f68860f93ad1bb587604e29d5edc1b8bd41e16ab59eb0b106ff4a44a9dc8e37743ba3017adfc412408d7746fb9d3e8389a2ae1c038bf6982a37f7dadcc7de4461e2bd07ac15126ccd9d01eeb1de2df990baa3b8366b4be41f6d12dc2ac63993ba3aa2077b8e6d2dd3442059591be1819e1619151f2a922958cc9d575851f7384d758971df848f2a59bd58750730a6db8dd0f2b9912e8c2bdc38abdfde54247419e8fde96388b6b4ae9d8c24370d086a12989962fd1b87880bb5670d772193c5996343f5ef42e06908148e802c83118cbd141cd5d22ed174326671466c4b7072df75a5594a7f422c188de14ed7704ef9844f5fb3ebddc5d85636da8af9b897ec8a28c2f34cfd997ec778e1d0fa2077a8f3629e0d9b3d09dc952aa436bd2c00af38f57f58a565689737660cab908b963334d25c2f2885d61a22c27547826a7606ab422330997c62bada484e1c37a07812d57e783acd50ebe7e0979bcf42694c0151c6f2fe9bbf4caa7df1f6e04782f65ebb7dceed7ced18b35bd4f6f25eafeb4768da9316f558a9936af30186551882a4d4309ce51ca48b1b0b081d9992698c2955b6c9afac99ac136b728a6c3920cdb095fa478b2020b836a37e8bf44207e4e0484914dea4c9700bb433f96bcece5079d567bcd806875a55b5a95e03b62d2c5810c80cd508273876787b9380e726640eae9932ad4b7400e8da9aeeea376adf8607ba7996e1eb52961aa8d6a16d1b4a0a36932884c990d7bea808308d7854651f1c1324c691d0827b4bd46ace89950059748775d7ff7934b8e997d551ab12bafc5f0221eee97a63ac6c2561f7de1bb57f9c0e4fb0cc4e53326771625414c0b078170b895aa06f1a9cef30b2e4b7610e70c313c47b1c344b7eeedfaa444ed741f2d6a1468658cc976b910a97bbc7d0e9266d185242b83a0d3d9c4de76029d45e31c7950640e1e9833da24e46bed7f591ba45b5e083aff0c0fe754375db4149a9201964fe691c4ae446fb7473d23531638533490855f7bd3b35b1650bda966d662aac1d6b6bcb91d4db8c6c0a35c683a464d283b17dd05b6a2efbb6ea8d6196acde7d57060d2c7516f6c5f4f33abe9e6dbcda78d190b44be320a25e6cbde90d3dc2363b2dab2fbd4c38cc7ec3fee9486db042830f3af140f5c8a463322a20ca235785645059a4825ecfb9f6fde63d571b0ea3bfa2b2a3b76e66d0691f465fc9af022dd810dfdf52e10c8bddcf44dbd616f325dff49d99244ab58a04e7b0af0b5aee59f60c464f59948913902afc441bd43df1313dc61265beb83ade61a4c2c43fa631483b1fa94b85aff981a8aaefca280510870bff2810ec5f9ce2c64c46efabf654c741497aea1b2dbcc1a4ba03cfe072287334a07d192d23e3fefc82c74ce56c4b7d7e8ca919d4c3e8d07a393bdcf61da9f9a98dcf32c9569667d59fadc8e2097e8caa49634e4a0523d985a65187f458d50d91370c0537bda81684af1791f893c894949f1f6fd3c62e1cdb517eca1a7ed2fafb894e0b12618b36af76bba5299e607852d1243019ce10c368f1ef9a39a69be5ebd6befd6b770bca9d9d328b31fcd3881825c89d0411a5dd72620baa1c8613689d2e6a52fe248f8d966b346a1ce5970ae276ce6e59027e6ebd3e387a117570d644d60d6c3a807d4cc7cf25b01320a7fff83af38808d8c4a46870aa2c7d45f951344f5a16628c4bf1d68f732a2d309c19765ac4719db1400a5ca948b8201b4be00159d36eb81672718a05a5e6e04bbfa35d3589de82dac0d0cb079ec30fff3faf0fefee41ba6f4985388183b091947c04312e211fc18976c7f307ba487d9947d9604a2a43fe667dc9ea81a49c1c688bdff464489dbc86dd7eec0beb21b2e3acfc2daaa48c03f91a37bd75465cb46e5ccfbfa1c4f5e0827dd37cdcf99d8f5e67187c523de006b0e3d71d538c5e8c73eb51df2c4b19e835908166d3b2774dd56e342ae80bff7b45e0ad55aded0166b90f09efa2cdca0394549f475716669b8f46be1a210b50a15f7dbc57dfddedd817adf1d7da339fc04dd7d6c3cd7688c26fcfbee2c849e19c20eef4fcd3388642256c6ef7b009dc4db71f7d501a0bf8b3f638354ae30f5dce4a6ecb1fe6ca75baddd2bc4fb252e6cb08f7982d8d6df1526b6e67ab40b67cfee3d4cb44781dde03567251ca0eaf29283fa2b3f4d479e2e7179d733e378643f45b5d20a995b7644fca315455176fcc399cca1b2ef2b9908d3243eb762753f3de937780b02d57524be371ec71a9c19a4af80673bf8c2ae5eaaa99907783b5627d71c5579d7c9fa0f9ce380cb3c6222b21d9b4a2aec1a45353f1c7980b6899b84325a69e4003830a2512201004c08f242b2f2db477167d0edd400d61fcf61e885cc723fb02aa4c2608251e53a6ac728c6220352c3625e7807a7ba5025cadd8540386adcefa1edc06dc282923d83e1bb0406ec49cf1b60a0db0a1988673c9ee9aadc102691724b07f12e72d1eebb14510f13a924003632c104eca855622152cae3bb8cf37e4a369b229fb09d79d3eca86b97c7d8b1ca316629379a3c4e23c3fb9dfdba8dd5e555243ab78c1eac008af1a563e586117c7f0c62580c8fa064e7aea8bec9bc6822aa61a37bd5c5eddecef3b7d14e4c5da58ee063e680d0aebd969d422ca23713c4dac76f68c58b66ae2ce24d44f351b39b128eb37a82a6986745f19efc061fa6b96144764ef789066ac835e28ba0e00008ce790fad68d81d1617cb1e218cfc38b0b0714eb9826ea8853cb65931f147370473f084b52c861998ca1db7fbe8b8d35341ecad5a4c18f9194f8f7982037ba775c43068f7de690acb65b3037abe5da27c1df160336730423ecff8b49aea1c78c648703ec98bd8676f84501703920c0b6727d250cda20259e3b6b0ae59671a1f00920459560aa1208c1b5121c1befa331290372bcf5d453169bd312fd1c7f8ce78aa53d90bd23045c2a9b71e60b84e0bd602b3a2898ba654cdf54f5690b03234fd86af85fa627d4e3ae22f454d102c723265cd64de3a55b86a73d94c152b4a7c4af9d3fd6e10eddd52acf69abc559e176712f0b55bf98a9451ae93b942a1a9ca01b58c19009848e820fe73caf7203a2d2b677d2c7245c86074fdcaeb6463cd79ef4acffa21d5d00813fba7b736fdadee0d4c61d73b2b04e128f862cfe25f57f57eb63bbf7a185808e4f6bda59dfa06035c18ec1429009571f798ff0d0c942f709a493d308517738a57720a5af5947c5f6366ddf915a9b0cc0a41a9d29c16d8fcc83f2d8a0e822c0b3e873600de727e390ae92c69019b49361111d55025416c9d865d63ef4c3ed1c53e27d94ecc69f23adec50ecd647a85b480ef5825e32fbd6cae044b072fd0c77d3877762968820b2834e4617dfb968fa51cd1663e37457a073101c6eecf2bcd92155cbca094bab24bc3aa458ec859330cc9a8ff8b4e73796c3150418324068002705a0cfabe42fab0d9e28740fbe6071d06d0a75aa29d028899a907862c101fae8d5a57e9bf5711e3d9be8145bad312d755ef980194746ac3df96e64c9883748b116e906957826233bdd5b99efc6c0d32b8c8903a15143db1e662beb5030447e4142528b5b5fddec8abc2751279f7aa94b59d745c826ff86e3fa1268ef82e6248f9358ec80252545108cf37f09d9b0bd1d57b7cc8be8e0f35f2b93dc154ca8fd49dafac0a46834b9d7ed681439798f3591adf78a97e1204e2f4fefa1f6b8160ed37db97a9099c96db1665c1988ed8d88e7ea264aeec7b8445b09abe9fded3d5e2cdb1ddb8aebb482849f0cad0c36bea0ca633ada0054d2b0d63625eea45ed4f85c3b51fb1d9a61f1db91b9f339b2b689947c47fb9ba392b0c1e43bd1124f892b01c2ad03ff946d193ef55fdc9cec0256b75762098f01b45083d5dbd7f4cec9c2f2c4d70cf08f6ae9c04f6bc3e587800f781fdac753cd0a5ad64017227a77070200eff613484ba48c25eedd2e0ce5e079e5248e33a4a3498bc4a364dcd1b3830404306beb7b78c1dde52ff57fcd78e97ff6121e60696d283b428ebbd3f0357edffefafa1f1351eb50ae87f693b071802815d77ee20634ce1a2339795295571b5a3afd6b45c65442308b1220cf1926fa82a424049f34ed95689eb00d07400a74747e94a799d68487bcd39a6c638ad7b614ff65b66723aeeffd0921a13d991d2bdb25714ddd9465782722b7ce1f3f0573b6fdbb9f33fe21368626e36ca6653959e8cf2ffaec00a9bc0984b8bfeaa07d0fd2107d02cc19152e5e854187959c8a27c9923d7b12a01edab6ce501b748d00af9b2cbf2154221d29dee80b5353bfa54808f1a25f6ded19c32d8fa435019401b5dc2e2dd297a456ff7781d41598795715d2b303e4478aac697d97b11b34c6cc2444fe84d72bcce4fb1779b2def91d7ec7f86c8429c5bec2aaebbfea0782bc2d85e7b3f7e0ffb1bcd97341acd9d03c48e257c10ff0b8faa8bf927749b8892e6e2aacd5eb24842dee0b8123f1baa565dec7688c8ae20473cec481aae083c0be94a7c11963f3b6b2870b593a8ed990dc27896972836f3da55c79d4f6b4347d812b8d97260e682f6eab928c3504439746f26e7e66c903dbbc1e271184cbfb37e95a11b1676fe6b38809da85773151acf5b5180051d6f283243dc486d08bc55826df8488a4d3bfd4276c8417075db887169d46edb10624c12a596d45fc0bcfb4438440cf1cd272540f60b3cf336a3d1655ef1b84d5b91addaf7e3f90016e4df2f164800fe19cf6513e8a89127fd68ada9626c25c82385b4659ac368fe76c2673643f533ab6d8d180b6c5b2e378219f18782274adef95d606b4b712ad233f4028286e56e241fd17d69c27bac8a8452edbd4a9f5412ba6efba437af45857341c986b3d17bc0635bc933c1d6704065a10de91d32a2e6c6e6f58dec49413d55aaa7e5378e43c9dafa981f19fcc4986523df65a386f64245f10acfc504df34b62a277e6638863a63aa643da0bb8cdec3ddaf032e0b3b8f26c108dd77c987689d9e02df3492f0fa1d51e120b7ea947a86e3b512bb2b5d8fb863feed0aec0b5d969dfb5f2b86d321fc6110aec23599fa3c173e2bcc47c296141fe53d2b5541394943a594030074e6e5223e4f3802468bc7ae4597dbe7aef37d5b113b83803ba60a6fa3e8286478ae5e0c52541fd8ebdfc48d982e542002013fb3aa0af2643b463592324c351a55db5edd623aadad12b7ffc46ee2ba30b78adfb5a7f30f7fd6024e264ea36aa67ea3a3f88afe4bba5465e3eb99c07f3fd57375e149d5ae353ca34a38121667ce889e147cfc273825641d670f6ed2e53517e3d4810766b9491fd66c650209beac1d70dff2e570ac9350ca7bd575f5b01ed96068c0fd1f0b8064eee036eb988e184b37f6937070438537cbdc63e8c55875e3cea6e78930f9fe44fc2c5bd5f927838a7a5c5f6e32e5e99091d3908eba7376caf1e52810cb718c3efbcda88323e40853e78bfc07714efa909044f7f20ad1e97c734ea0244f5db49cb7b9ad9119b11095db16f4c32005d3e9f13880add65fd792a104d91eebd581717b1e48c2bf43499151e57d9d49729684d34bc4943a92d7d1360d62faae95a78367dbee8127ddc4b9dc58137c27d181f6280db833b90f8d70c4d4bf61b99863b569aba3d2eb61c42d0d82669d1e8676b6956d7cc93b98ecfce32650fecd4dad92f7c1f5d6c3b458396a939f131774b4c820513274e9e229c020b3ff833a2d4c559cbf5996fc5fc91da10f31dcc181301ce11328b56ca84fdf8228f18254ff6fb43609a2ee18e998e5da82ab3398bc4fb249c03347d2511b6e718cf2af558536cb3cb4ba6c082bd7cf489260d61ee647664de3393d3d83c7981faea2e1efd310110a0eddfd23942b4080b442e1db1fb7a8100ca754af32f775d4fdd27b2b66d53bb11de76642a3c238fe98c89bf6a96cd08cf5af14d7e5ca62179a9909553f8da6d2b7d202a907967bd07a44b47b06f62d70d46b373d13a4fe452dbd46bfb55a923c4969412fc2cecfdaade6419e5214dfaf9ef4fd374cb3ef0710c55a7c4e455064565ae878570b9b4c741b59a386150c4deab05e621f92ca52c6fa789135a355440819f9637902f27dc31208dd3c7cb52aeddc7aeac6ff16ef9a305aae337aeeac19ea5a160cc08333b9a95fda7f1f1d013406266672ce99890e5be0e87e84c8315f1f2c5c24c4f4b61c2daeede5cbc62e748d383a551dc714444bc51678eaa5195c25530e65520132670fb8a8b1b5e35ea3b2bdf9675bd92b303cd6ea28ac52b4d03fd21ae9819f8887f162ecc88474f0ddfeb36a8a9933b561b9ab8e33e0654111fd43eba615f98035707cecb59b5d769aa0fa4e1dab83cb4244e6bc7934bccd65c911adfc5538cdc6aaf70dc2dd965e0858499555db1a0f06e78f725025d4becbc64cba0300cdde32ded8883592289c1f171d732106b7aa23a4aad0df5baa38df7abc55f93688628e336167c9c40c03e3d8b92b8331575b57d4d253124a002fe1037f2692730683ba09f4ec880f4f53ed7a11bf675ea47dee7a20558d427dcd4ef94b31acd6ff0a2cc41f292a623802f4d31f6665e62606ffee8d6622fc397e185f75a78ce535a6a3f5cbd1de038a9002c8ef46644cb32bfa19c71f4d675b2607f0b048d420bba41d7964f59582c6530a40c7a543ee98ccaf5df18903ea7aa81124980387956a5d06209389735ccfe2c32b893e86365aad8ca1318840f7f84e1300a0ec6c99d57478f9dd06200afdf3c09043df7be29fd723360c9a90c8946a85ebe5f579062628399bc55832807473ceea9786079a290fd13da450b0af8ea13928a50800e2eb2ca2b2b05f48733b42278239ca0a09a9b68268736198a7ac74ae3669df00d095ded9d509f577a42d97ce0c40d0325127fb85440598b516da7c1364129336b2034fc52812abef21f8b8f6332efb6df20c85cd29b097450af41054d66e900feb4680f53cbab07a73e2ba8f25fb350d13b652b963e32dd38aaaec4822a6e28a065cc4ca2d25ba76a1d6ddbf79524310640757fcf87fa63fa5bfe8b04f7c949af55231a87bc7c6fe243014a1562648a6f815a93ebc9f8bf19eb2d340d31471740c2ec1614e36178860c1aa619ff0c62a59bbc86ccbb191066d2433a1ffb76b228377de409c0d037aac12ed0f7d77daa9e0c619d4a43370ae107e7769e604cab7af25624e213cc551a528d3a1654cd4e19ffb46f0929710b94a92e443c7204ab055fe334120fdf14f0c64329fcb8f22e51943e487075a0697b0a472d3c4e51922e9a69abc57ccbe82fc6e3e3f48bc6c01e72a7242e7180c469f75f02e44f30164b11afe17cdb3d0262a088642463d55ba01ffb226ff8c736fb4b11f6d21d2b7214f052c691d568ad8ae314647f2ea6ce1c2f5da0647bf34bb7593f8e2ef9eb60f80837fddf85ab202e4316a67162e0ab566fb79df0978bb0f9f804e1f75b33c22665709c6cc70a8359f618a24f5193635911513a7ef230a43d81930b32b8fddc0317a29d4a90999ef04df4e47ecf8782be8a6b2d44a52b8efba044631de580f73b3b40ec2a8c74a9aef8ebbf8b854e4073ab88678620db5551ce43261f8d85ec9f4186239ff83dfba90b6765e9feee45688e348d3759f96e6cc46600e6d25ce3d440e732f9d2003981b4c4aa2d4184e60e6b88534f6c8d348ce17c665b62359ec69d882689c8a95545d03519f49aeb386db3eb956cb6aa2f27361f149104f7a39bd3e62d4d96296d7f4f641e3868030d558f0b9ea6c1feb38472426c21feafbdc213eae5e2cb5acdd47d97f9d4d2d3d6a5384965a3034469dcf4a6db58be8a5a5c32c0bf7d3ed4dfd60795b8546a1b8ec05fa89df9d94efe0b71315605cd33ee6e2050495848230e709e7ea177151c554224676d3efbb89939e405067b0c47c981961d82dfe9b92f706770c7b910a1802aa064ec2a14f8b1178580711f8954b8fc3d8ed7d08cac2a15557aaffd126009061206032a093812da7e7c8e143104ac832185f8d52a69daba2d1e70da5be988c1a7c09fb0f8d8bfcc36246caaf0eda37db778f886189c5479419493d0c839f66e06f928b223283ef789712b3df2809bd9f4660406fdadc53c5309172310a073f79e09f1a9f8734e54d3bea5fed30dc1102c04d0fe3a20510ae6cb1f745afb21a340fdf21bddb40e616665e6a11f5c37434e39c437c5e4757773da6975be851b8cc4a8bba7a1f4b67f0e116a146c40dc9b11ff96147c72791a83794109fad0ba62aaca650317f3db7e6f45ca048624d9f3dbbaced8e41c60c268a6bbaa7b5601e155b7cbc9d52008776bcc31a8b673f41c25f3bd1bee9c3bc2c7bea686b86e63c22e97eed6ce3631f765458a1a81549353a7cc23788c59e969ad7318cb969aae3142b2bb5a237bac6e98e4bd326bf35174dfa47bbb4f625b8c95aefff0cb5901a2cea7311050842c60b735c2d15f7c1734a59566dd7da07e9a8f45b782ed5a7ba8a981478efe21450abefe1e21c9a1adb19ee83b85d7de563e923bb51d51d06223cc7348e41e244d8eee0243e61d13df1b97f534970daae5f525dba961e5ca8297db2076da3d527a5d5d3edf40b680a8557250ae33d751ed4e771fc3e3fadb202e1074be071a32d2ad46e55bb9efb35449c714d2c12b0346ee375b8b7a5ae0379e0440d2ef2c7d787667e28715becdcde798c620a5b001c021a431c1bafc88a7886d8489d7da1aed210d2cfd07f309e33af88dfcb88c1361a7fa87a2e8cfafa44a9d086e9116371c78119275654b5644c8053866defe9b4951cbb4709cba071621f0ade1fea516ea9868c988dcec4513cb5862d8c1d60a9d0a831f463409d2ceed16e936caa82584bbfb325b907c0857e5b9f119cde8a5cc35fe560796a4cbeaccc0ea0cfcc12368a969fe77b672370e739c929d4f179805261c498ef695dbab9b997fb8f42394516321ebda4bef048dd008851c96579aa856d12ee6e3955cad8bdb1cf4547ba2f0198b8b851fad05228182db0b1389dd22fbb1178da40aa842455efa31f77c8bd65a8a8fdc157fafd929ac1445e16924a7000f0c55eeb810f13ab5b8c9b497db0f75337c3e5d8b549d4d00f31c1e85f1b8cb56a8f10eec9becf473fb2d8a5a5b6fc80173052195a69417dd0980e8a9bfb7c4c3b264fa0fe630f827c00e4202dc4d8b780f4db14a5cae45f6afdb16bbc44f29de8071507cda2e27e458394300709ef088f937e104df4eee26af70df38ff01351f4a42e5fc0581d1e65f3cf40b4518910782be9216ac8eba06c9b08ea7d83ac311e4886b2f6b1c3c6d39a80683f4c893dc24979c4c0f259f8cd3ae0d1026d9ddf539f6006498c27330e29e69c724051c81613881cdd773dc85899f7e558213baa05fcc25ce2bb36aee6ee025bc8340b156beb0e8ec9e6188c7dca6ffd22df34770ea6e5f7cb4bbd56586804a833763b1228271967cf9e43eb09b71b10be7c190c8c345b8585c66498cecc8a5af03848ff8128f37a7326f4894f87e7fc628658ebe9b10551696213ee9d80a7e4071f518c90edf1913e742256ddbdb9bf0c222c388c8f72e875020e4ab03b3cc285061ae196e78067be42820c6c88a130a3809e581368926f9b0ddb6e8d19694ff70ede4699c1d49ed753eb986223844b54f8f3d6b8045033b2949baa0544128c9f651e34410cd5f27a22c42b70e0186315947433656665995e95624ccc8a07c570aedab14841ec4c4baa0082ed823c85cd073d4193827e60b5894e34a7c9658d5c0976220b47872555de796eb9236da16c6c0b6369c905a0c2cd7fd33cea776e3b9f4273e3054b3072d862ff9224aee1aa1f408ce3badbd85ad1904e29ec6dc8c13db097682537556c88757e867933839089fc12534d3329a3c62176db275c1670c15419769153fcbf7890800a4cfec89009840d1318a3fbdadc1279ac7248d044ff1e3f2f5961853dc74b20b3fb862fd10208321423ffd9e5bc36c277616aef5271b90dc4ffe38bd7ce5f421c1297e1c2010de49bf928a48ae6717e3f1cbcdb88d0af3492e92df24a8ccca15f620a1b2af733befd15c3bc170e09c8a8ed5510ed41077a33ca77c466b711e94a67bd853809a3930b98c1b502bab7d774526123a393ab72f7c635bf225a350b17f6b6696780ab9ff05f000ca36d2752ece1eb8b424f0677dc6607c9fb135919f806b2fbaaeda2f19095082761a422b55a35cd4d2d81804793bc4dd100e75a3c2ded80399fc93271812359dcefffdd415444683b5ceab08ae05767cf5322d9f4379ac7309fb41522c885a0f8c5d782428ea0beb337718ff36c18cbcf558b03054f1d14372a378d1296950ac12eedb53f5263d26529a8456ab9d5868d8587c4c414c35ade552996f83feaf82754ef463ae8b0a8b1999d6f32ba8b5e288696488f42be0c49cd854bb5c9fdae64621d56ba0d7d7a8a41ca37eb5a3e9c83af5ae2d8d9f1ba6a1c9124b9093356895d12aee07e44ad3fb52d5f24e6dbee1b76c7e74c30d36d94c12dc620df01f7a120016dc82a80677e54d3d84616e85d0fca1adac30dcfdaa6b6c540ab4b74af06bd46a212f430e4a5fb518d1ec6b08d0eea30a27c8ce88be7bdd60c3881983155fb3de98429300af9c5b9ebc7d4446ca967f4f971a87ec781b2e4eac499288c149f4ff801ede8e848c05c8e6d543593a4053f3e1e27c60c0d58fbf3447d8d0b94c852d8439e45ca3f1c1efc9fef15825560287c42b6e83ef4efb81853c47ff704e3b6aa3a3e5ab17cddebd51e5e56a6c2da297f7615c7cdd9dad765b20492513742f6a59e781750d83159a10b0eb8fc7481b10eee77d3fa8253de50e246c7ec2e7bb1142a98f7be6c711ef89af74f22cc0b28891311c1e009e51b2de8b8ae1b9a8b5c44ef45f5ffd428e947097c4afba0840b7fc05b7350830226f1ece6611d22b11aa173f8d3f1089c726980f2b06e5db054ff18f73be8b40f73b7c7bf83419ca7e6d660a51a982fafa8b587ff8938b8365d7dee6fc608e39c08f11eea8882aacdc3d202ab07d248cbd9530ea95085e7a404c68fa7825d9813fe721e0b2f3503bca210f897d50ea66bf1afe87dcc1cdfd0f777da39b373024d92c47683619852270e4149b424f60e74e40818cdb9743b4477c26634bb73438635af376e3f30cdc1ba233def97619e6e3a6d181d554f4878348eaadc78355a34716203c40fdfb1f6a496abd4a94c186d536c8fd05c541f626796096b566218d80fe58885798f5540adc56250ac48acb4262650d6fa835a47bf278c48b881985a0e75c2ecb8245aa4a69c2eef70f2754fbb954b0775e45b0dda151ebe3ea174e6bef39f72405e2493c0c9902f2853813bbf4647b3c7dc9cbfb3f81457fafd5e1aff6df43956b72c98d4c2ce8000a878c2450907a72635ce9a8646365c52d8b4bba164ef3502dd616b010cdd1b568398602de2935f9a40c1fa196f7a304fcf5ef60e15e7b8fa884a5e89278863e00d2b447092759938191315b0ac92bafdc7cc62d778387121d7bc917a3dbd1818ae850f4d1f4177341ec2d2eaa2c1ba7fd69bd74528ec457431689048f8f3d2b73114cc2d7b2faa9e392943e538453cae91fd386fe8a1c154f8248dd9492814af5771b6f5d136435a72cdc611532b87014578c031fb08d75b67f2707670a7e674cf400336d570422f4e6ac1c58ca7d995ff463e6943505353933e33cb48f265936206f27fee7e0edd178d4aaf7a26e7e442bf38f5c9a2ab4bfa3b070e55da30f16a809edefed49f1f85782ff3ed10560a516a07ef131c06b1561aa36f9b4c080eb869d6bf6ac92a95bab8e7e522fe7ef7c99edc1a12bafc07adb918951b135e55640d831cfd719cb27031e48dfcabcfe96230e2c519bbb98cb75f00b52ae5c45d0e418a4c079825fec2fdbbac9d6ab410388441137bdbd12e87c6543e4308efc553de652de15329a445763e157a0f92adf94a99916590bfad83d6f86a98de838bc48674f1c78bc97f8eda33e672135580fc8ab4c8e3746642e2a9d77df1775d0c79a2330e0d416af334d4c56f0cc7ef3cf1c9396fb740d77dbe84025917fcc82c150c9f75feba9f32059cdc57a61734f2e1643bd9f87ffcb72091aff1a27cea751f18e1d51ee288c7f0403afd9886e91b2a22202ce8d7c70c649b481fc91a917390e08f2c75055aa3beaff6a1c32a12ed3696647f02dc716cb021d96f519795484e01dbb117450c1f9a904dd5550c0bf00dd4f63e0c3d6a1402918630b64d8902395e4dd576733a0641bf73fef1be074a081aa59310a4d422ee649b4774a84af5d77f2e61b71b8780427413d3749defb68b61f48ebb53dabcfaf21c838c5bfd65643724e45bd46ebcf6472179b15d6608a9932296275e878b8fc3220bb8b72fe97afdbc02fa688e870e13f8fb092b081e193423197b2020a872b4c6e3aa35b8f54a6a2d70ee178b8263da66d517553d77df684ff713cd33191eccfcc44ce58ea23ca8a0a8399a2017d0159163e09cae144da265a0aff10a6f4d4d6993aa63fe10ac1077eae9cdb802586a564a32d140138d68f9053ed9ab5270c8c7ecb26e25621bc4c80056e6aefe82cf8170cd12b71b7290be6d7799534c2d5f227267a6d6d9b18ff8cacd79e34097b5fbfd22ec19a4f8584af164ebff09571e9f2152ff8a5033c010e829d5844f3b6bec8292a91aa080c53ba17d63774b223fc74df022015fb45dc000d3e9c7d5ac710c270905be7c404a88dd8b225640f16d82a36867a971f4733a12aebdf1d87c8eae97b960e37b5506476d96767d04daaaca16b7676c3f194e84630fad98af239c21464a7af63a37020f725acffaa28bd90bf1420508934fd77449a39ac2aa07aab242b3611521a55455fa147add0825660125bdd13f5459442bd6c8b31d92a80081eb7d9de6f08aed011de01881cab230d4c5444cac5d94177e557547217d5cd79b12c6517f24bf9575901e435065c9bcf469f4626c3663979eafe5f1307a69dca9811519bbac2f4f4da03ed88e1294d2c99962247b7aeeeef1d5850c4bdde76f1dc2a0d65d88a48e01a98b8e3ea91ddeba1b23e8b7ace70a2c6c72f51987ec5e58f2f4984cdccc7351ea8504fcb3226fc8c9012980fd0a5116300cd0013f653328fd68ccc4357bb0597cfbbec6d44b87fa7d78cd371f3f9b682dd2117e80e97b474f0b99fb5f3ca8861150da3a1c8bb2dc10bab3cb5bd7b76d2e704adb21a84a108f8baa8e5691e2af66148f5a4ec77a922626bb22935bb36b875e576e74f73329ed817d941ff86df673f41c2790bd40efc1d1b6a6656b77249607e80c45f2a144290a1f18fff0ea68f14ed4e36e5c390740a246851f29c7c9f7c9ae868177be080934cd04a2952598cc145ea98fc3c2255c624c9f535a702ae16310e36ed66ac850c97b06ffc380c405078236b02b8cb6191d6d8f0ee3fff765ddfa077dec16da53217f056d0e54a65bb72c4c8da0c9c8b91b57e0cfc317bad5556a2233a4eab34ab982404b236ca9d7f2585ebf6f6cd430db360d33926e61206a498e6e440f0d120edb80ec2a62387970c78db0ccfdcc20352b6f23619683fbfcafbf1f7b9c429720589cc86d332f52f19113a12ab246f98506c65bcf8d6c6c85819cb7adf7baba7db4883320cefb64591337ec0a0dfc3c809a1d8ee9b2f88e8466b580a9a0622b67f7ab3315fcb11189de8128441ff819a163c8e5de5385cf958d7fb354fb89da98388790dcaa2d062315eadb89e0a35b3ea21ad2dae1b2b445388407e76e37828cef53f13ba77c59e6e59078b7cf86daced69760bf56917a4a0975f4e91d58e6a63283cdcc23a04837664d07b916d8b6d736b6c752c93c2574bdf317299255205a03c8782e66fa32e5d2f70994c4dc3cd84be013dcd5659d7b3233454f408a1be0bf81d83e3251106e5a2d07ce08718dcff2a4df447e79f6173e1bbc442ffbc6647abff95c63cd26e67a416451d49a212fea6bb485432595c810d17053ac34816e9dd1ddf68eb258fba055fb8538a525b3cb6fe767c7c26b1f6a9b234013b0f625de8a01a82f08f21bab6f93467aa481995c6c06bdcdd6eaee84b0a82edc020bfcd78256942fcdb4a74021760a2ed3ca690008cf6c3edea3dc1842ec34e123f13116af73aa53349462b0b7b2268f6d9c47461d28709e35963774ec59f61b627ac7fe77f6d25b0afbae6ab343c00747a20cdbbb2b5c91bb1b76ae86eb6b0de56700951b937faac57c847694a160f65d91a510894222cd38e5aacc9025fd3ac59151558f43e3e56baf372e03ca6284e6e80e3b843571c099e4b7789df6054f64b70503da601a3d8d0834f478065c33c610048e156cefb6d2b699a9ef3d82b010b96eb53fa361b6068d916b75a4ba09905591375300b6dcd3413c64c065aeb2efff1ec9b150d7f23266a423666704422c0dc645cd6c90ae80db13f6a72149d9eb3bf13de022a27b23c109fdeed9953c6f9dc77bcca9ebb147123c7bf5d9b258ef8796bead4a46f92cdb05a3a0592fd8ad04fcac28ce28f1e7e89896717a1c40760a4bf369287fd5a21bf2cd5c741e34367fbb129c45b98e757e7bbbcdc4397f51630507807ac74e088b8a8ca1c3c1c57a9671444f50cd758c936592fac08cc820fe0bcafd22216b124096a44584d47bc1efe7e1c7b1829a4c1be4c09a9e3d78f5b79576b25e536d13d12428204bb7d27d942979134f30c1958419eb0aaa3d07c65647f60155a573b098d9bee1d2a5f80bcb7c93a264bea5c85443b6671c2ffc8fe5bfda98416ded1d89c4b21a55a52cc6a94ad40285308edf94d60a7613755bbe89b19bc615a206ebbb739bcbbfe1d55849b24e4079bb633caeef2aae1e8a50bab9a3ecfb693dddbed3ae3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
