<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9950627577afc0073f45ee895a9eae887f7e8203b936dab0c28d9376b12aeeaec50a39bd384b8025f46c135ee6424692937c2f74813cda02f302285d73548a18b199e1cd813f0f4098cb4c908c2bd68bf69d9d6e8e3227c33825f3afbe09bd7f204cac5cbb7d0915e7dfbce60a7db448e4b06d460bda3785d7a89056a5972ad446cc24fb8376a8173f41d794427cd4dc6b6ecf6f0a33a6845b9b9a12ffa020630165c8fa4ff5d034697d851fbc9f216d1458c403f0899a180fb7b0da741ebf8e0cc86396531fb8758dc6455b204ddc7a52f31e0fb581d1f6dd5e91a3b93347aab02f2589253448e507e3e922f08b427c7449e5ac75ee2380c128dc1de7c595b66ae1a3146d518d62417ade443c2eff203a032248b85f7c898dafcdc15bc561f8c9a0364866710f8b8251dab69bcc6ed28c0c9152d43972764741288af79bcc42300c0814d0a6ad8efe6f14f55636f85d932b221475ee95c415c01704b211e2b3518aa79ebd04ab78cd9066ec2936d5f1f36c4b029040e676339abd4046946328ed133b86cc70b9c735e878be7bd19208f7c0ae61acd8cab725535fccda56049bcb097bb7b5362aab268b1d148ab5cdbdb031fcd90756021bbc15b1dc39b5e04da038e4bac05511bb85b41cf5f697445a242d167dae9e5c81a596c70df27edd667772281b90e5b4770bdee32e176c2b2edbe333a59fbff47b958792e8f95f382c775951ea2c31a6ad1f7e11b8624ef46a19816d81ee863f92e331bc5c2bd2be8558a2c5bf07fca75cd2da94aa36819cc4a4db9d832febe73b575106c21ac1c8cb4a319b5a4de3ee95aa93af76bba656d384c10985f0eacad2ee738ac864c0f9edfe051f400a0fe734942cc139274c9f1d4ccf02c7577120c3ecaa193976e6d44179190833da8b83e4793c38664a6e1769ffa1f5066dc904dee1f297e69e12faf7279f6a3fb877cbd54a2b037788de6ad4ce83244555a13d3c2ec5eccb1b41de8fee31c2667920b4507fa3857b9fcdc8a832034c38673abe86b6ccfa6a62702f3605ecee8b7c61deb394e6198a47c2ceab009cedb3b8ecc36de841f6bfb36136b0b9c5796d50f5fd842dbaa73c71ba1f2f60ae15d664412ad11e71e445ccbeac1a2b45ed31015f36b7211a02074fd17b0c6f712c7b49260b949dbf5b917c3b0bda023f5f08c3ccc2f51052f64cd47978ff67c16200c7d000e1c26aa543fb9e44679706da37dd36bc1f3a47893ee988a213560d1361792f919a005a799d86c456009e61c722b5b38e952cd65f4ad9d2f7911a90ad5f5a4f055b5d95d3106640e7697b54f04323925ce80007257aaeda3fd30cd7215ac0d5bbfa8a2c7d7379e5bf5e88a1e83db15f02968a5c7bfe3f1d5c68e70018ecc5a256f749b931383067fae28847a210e5236605bdcdb60f7701cfb46159c65ca064f2b308de77434e171f21bafd67434ca5ca0e9554e7d119c6f55c108fe89b61ec57215a18a31c18b496d089773800459fc100e39c5b482b3e0fddbbdf09f2521c457ebb1343aafca5bbba8db41846e7855c071723770c6848ddad079dea8238450e512923f6f14e68f70c55336ed7c05aae80d4c6f923d8f4ae2575c288aac1890d08ed322ca482935b1d8e8768b40e791692535b1f4431baa02d077543e0dad19e2ba5a499573bd1c5d2457d149a7fc63e798b7ef0847bb5569fa6a53da26611d9c449d9b0e615cf1d437f8967792a17d18c040e9522af5dcb27d0786a7167abf9541bbf5cd87c4d904992e76ed2cf95b1cc0544dde56739a4a96878031b442444f599cff91a3ab7c0f0cf090f7fcc837e7139970e93d1f898ef8fc3a52fef510bdbd15ee10a7362480af983e61235b98fbe8556823cd69ecfa60dca6bd730d58d10e718abf3b12b00f19aa2847e718d064937c491c7771b2dc4dac4395458a42906546f9a3a2b71522ac4e8bd87121c09cbeeb82b8eae1b73b8a556d0501751259d1bd6352337bb1833861c006af55d2620024698a7795462fbc09379aec10d3c7de012d1596f737c2d6a196d35ecccb56d900c7a4beda7820ddec67d80c982e7fa3f47fe7579369a8c100c3d30ba534b8e21f3f496a74a080971296acfd2f791e17fc44b2c720ef387e1a8060f34162f81e3efab05d66a480567b912083e964d67a657b3e324b09dfa4573d02ffd08233195e57f556c4d407553b1c71fd6c0d120b4d77d2f682dec4c4f5ffe4cea09a0e2f2ab75ac180c64950d7fb0cdac43b23683efd646f9e0b4517dd96a9ebef42b7bac03b7c9309b5a5be24cd14114ec51787b20fbda295c2e9d6af7a7efe316fa482f71498d4865685f5597a2b1c7a2eb17e344a38baecfa0ce5230162dc31527332f183f55b3f14c38e2f5ec6ec47f91859a0f078275ede30474e3e13f480cf37e7e1eb78358c5f218ba0b95a8d98d15ebfd063fc8691a20843bc40c4311581d460dd95bac68930d9725163ec51db12aae738650499c7337708c4437b75624d4d3db4c799ef7a49e1e1ca5b24ae2af9bca7dd91dfb5d94a4f6d873a7be0c34fce4f9bb8ee25cf707949ac66c59f9e70f3d8035237bf8911f25d375b1d2073d8329a053ec4f757aab8a880d6cf559a36e9955a9303b59fc5f73888386b96086dafb143b03c0b1c0e0fffd8c876a20038800a60a332f1ab21a9ab01a2fdf383ddb36d5782cc6f8e269f6432c8cc2e239c81f7aa0c4ddc2cc8e24923c8742516be80fa1b4172c7fafe64ff1d85e3e0645e4facdea81551725ed0a52f3a4d733951f429990bbc0df7c226a7d1be43a2b7d4d11c91d194fbeca5774165c4ff2bf650b26871e13f334a8e1bcfae24139f65585caa41c29ac4a0dbedf232fdab341a2573088618200a220b77c40e270e112099ac229d9175488c7b84f2a3cc272ec02db4efe98d823a94c4b59974fca2b107005f95a45adfd7e00e00655ebdab96185f617ce1f654b0f3e2c8da82358d1d8aa48646108743b693dc1e8c9ee82c3ab2001a5ac47fb943085f7839434a4178f847a8677d350e5f3ca2f19f5530d14bbafc4ac4b2f345930a6a7b480f789c0df6db67fbd9c72e443a39d31e430ad38eba294e3243fa16e64eee6f9ec70dea6efe3b3ba437525919d9077d6ca0f69d7fc5f669b5cdae08d846c970c2f592343672c47fc43a60168cfc4fca6d8a1925b765c94ed630ed677e3df67f987a18c9278dfb79a2d67e59045e7e20557eb658278cc2b940b8e90abbc7b7d43abd91597112dd05950088714f89063a1303c5d748a85d8d32721934f65195f856f61499cf7eb5441c1518059ff58abe5991c238ebe534150f85bbfe1e10ad48c95d7674aa2f206863cdd4c99a214d5ced498d3471ae2cbf3e09effba67992e79744efa76615032c66cca0a12cd7447b717f631473c73d834926907ad5a1fb80b1df65cfcb2ac46ec21e29f41cac67e444073acc25c31cc52b20e79a1299a035d4faec11cbe9c040422d280bf63d0d8a8ea22470120f3a35e3cefbc70b65f1df6b2e737e12fcb02ae3be2189e778795f47d8c34e65184d6602b35eceb5047c9a21de44f2b318b372ac8c06989cdc5989ab6ebcb28425b55a72452e3d5ad1692d592ff60f4602b3a5e9ca4aad85f8aaad7c4dfff6d8f7e582b5c6bdb0e1d8ace1f4f24f6f8232645cb708ad5f0b9bffdcdb499370a34b15d91c1bed6eae4d073a625633b39e8f301cf9973745b9a5d8c3efcd6ef4a4c755c8899abb99861b91bdc51c54effa1a0284e56efd73fa35b9fc832b9680aa405eac3c77eb0833b975f565de579810c7111fdce9f31f3df3cdde7fd1f46240db27b7d2d4c9ee3a77cb8d93f5f2d92feba2ea51dae4f99b6a1b05a7015d4e025fd970df918c138320255b7093e3bf938935dea34f98af12108922f44c126d3f4d2b74a46f980206daf12e454952f65c5ca3c74aa72d84ce2a51439cb320c27878de38156ae32a208382de9c0eebfc1fa661c64e2f9f286ce7866c744100f86f338984f6de1b01938b71f26bb0800fae2fa7a48a644d953d3c31993091a48f4cb653503b95779f3bef60d91fab8f08cf1ad04493709bf911a5b466487d8b0010c5cbae15b4954076f2f0874148be49edec884b87dca26afa0899066de6306a5957cd117f0fca1a8c092d3543d75d3ed65622f3671efa2261b2693eafeaa37b2bf4f501e94fa0abedd28a75ac730afa313b58fb41cdbb00e09e6cf0cdc702df0f6ba432dba55b783bfa3b066973134e8ee28e06003f21f8295e8f1f48fafd845c4f938f01a9d4d5b9edde456d008491e3393ac580bccef12691220fd596f0dc74d0976522b48fb52e9044256dd59559250aadef7905071658135c2a4e6b570d92fc01ef107867a5fec0a6223c12c8025ce9c8727938200d0cf548cec01c3aa657d8b04475a4d218ba0fc3b21b0d2acdf864e9c3ad90543367ce2c3e7cd759cc90a56eb168781d443f59fcf5eff29b8c113f9dc20b6124d548926472f62a6ca1afbc929e4d66bd124406d81ed552c4f256331d9439bb28da325ef03e5c70ef54ca3ea493aff1a3058a443444a07ccf9ac2d5a0eb9704543d6304fc462c05163b75c024e8cb09fefa0c7a0762dde450c85eb4e1c157be9c405da685dc9be2b3d3904d548594e3db6da3084f6e759678ff561f6185e184ca59ba002742e0e891ae06163af1a42af771b6f8120feb46d280569b7c874f879475e073f2746484d2205bb79858fb50b40259251ac5b404a9f2b787f214f474ee4605de27804666dbca43b7fc6ed36ecc29a9334fc5c77ceb8949ebb013ebd2df965310b66a6b75cf9afdd65b39e7c1804d184f52b0643a93c0a8a5bd509b585216b9f1440d5841969ae5be85745b0205fa7f08a42d84f768b95cce887b8a92fdee510eff29bb5fafb47627179d50d112145a2b31ac7ccb9753a13d85e950e040f12187cb700f44316ab4066ae7ce259d44d6b9608d4b7fbcd04f1b0b938a1439ef5567c3d592ac0686e3f6460c9c6b6542131cc625120b3b4548f0b25a28238269c8ddb95b9a348858c47c65b55251a7f911eb635bd3ca4bf397df398040b45e02a4560dce863b4a39e0d30d88ef23a9666d17a0ed409d7434ee04387d89d68d3fb4d16041b45309adf45c3905c72ed324441e21724974388cf58e0dc16653b5513e23a36fb5a5836ac37d2d31df0a56ed1f51f3a59ec2bb3323eb1351f5f57f6589daca5baeee73a58e99e0e72afad75c2b65cf14c0add3484d542916e12bae1ecbac292e540b3e3aa9ca20b1692b0e99113267ded2359a04f46e942bacca5a75114efeb4f195de37c7412b24c43a80f32a8088626d1a8ed64d49f2abbc7c8f8d086e0ece1493bb668c8803ba4ff90bdeff533a9decb5591e2502d4b6c310b372c335299e6939633bedda11811b6e219e3e6c2f8f76932bad3acbcdfc09c15d6464d6d09d8ec2441158fc0e3d6b6d7dcfb0d02150a607b9d7f3da51328ed07aac704f68624ee4ae61e0dbd5692ab35a1eb1dff25f3e058d142fa8feb4b9bf18b7818f4ce0694853b18790428220945161c88f7289986ccd76915d73066b1778cbd968696a92298febf1f090571c21e97ea14240831813232c3304a6db3d917f5fd9231480fd4ea76b62383325d3acd7bc00d13578ec10b308f2fb37d85f0fd8252ec2cc093d29497c83167cad7d33b3ee092d3af6ecfc321119fc2a562d9891b19c9d094e118095b7b33ed9350ae6f654ffeea3c8a829a1b5b34551169f1bf23b3f8766b8fb5688c64c7136d4b0680ccf72ba7123c017a7305545c421df6b7c308e25fe5896cd48a028a20d1d6923fc31977e1d5989b581ba9435c7d2bfbe9665564dd48c6785e4684491328733623576cfa81421c880bc94584fff630fde5f68b8a5a53e53b400cacfc36d6775acd3de66ed20900bca41dcb79bd3ab510a355a913893c18f6da4133426dc981ad4cecb0b02dea4a2e8668f45d71ab2d128813cc553df2bf6749ead53765bee0a6d8c3a60f17bc6b32ab3e170f93cac6a120621744030524e85e119f84dccc40d0bfa86bdf99b5b9665b50bf96d1ef401f57490d123941c1968a6671750c6f0ab8773973f6d7750408284b6f828a13532be6beef3704f719fcad5d6e71845bebc295a706f9b084b50d8a81146f33fd1b8c0c4c40e262b4c33d221a8181c3a12fde6e88cf732c7d64c02879ab6e1277cc2372efd1491726672fdb20245dcdaa62f52664b5f9f23fdd0e3ffea3e042cd24f524e94a7591389297b901c6c355b6e1f7b9a578f4974e61e9d6377436fe32079d901b9f2e07e6fb33f46a2be2154c72616ca85a1ddbd639d3c336f9b147c41da3c93e75ad4098a0c68e698f0b3e217787c169fac69840f620b34b67ae79a816c6a3f3b6e263021fe658789e9e5071cdb4d5eee7328f49b92b36a3c8ef87ce61c764dd2e0d68e6be2c794d56f4bea121535cd638e9c909dd055ad97ecc0e0a4e6b59d3d23decb14c8fe28410300e6a8dfaab6cd0d3f95f15c3c1c4cb1d649438c47e4d0837485480f3510ec839ea939a57ee0ee502e3a23222e0f6b66a65f3e3d8baffa7e99145a3350f42ba1008be2d234983aff689e33a8b09c3ca999e6a790267baa39c3027179311b859fc44b3d096dc0abbcb4b92aa74b7622240a9f7769d9b35824a1b01842e7278f0eb7ead0a491929530fa9ce0066922e7766d6e6c1a1b5aad1448508c06b334f25e391ad08146c987163f0e004d4df98929db45996f5a887cf0456f14ba6cf56afd46e2e595063a1f1028a57f73ef88c6b301d630cdb1d4778dbfba8ab7c2cec7476003ec2e8bb10f4e5a5166195bb2a9577ca97e15125a740aa3eb9573df3457983a051691c0f044e365c3a6fb71aa5c253999b09b4f3731324c0e334450faadd2ec83e5fa290cf3c84b25ff140c4c7c52b0cf92424409047373003a1b7a0b0f2cab5acee5318a6fc1f554ce6e606b97bfa16f8caecc4d6770527a841b01bbed4cf7b371c84bd2c210de8f70cbfb0a8d57dd7d0f57088159212efceeff101c2b0af024dfe5ee9d9c261047f27a73c9ae2168551bcf24a10816ec36750127a0b2ec8f34c8b6b8125eb164b46e0121bfdf8b146b82659e5c2f1259de97312de5df9aaa317ff0963671b4ca23c3a9c99a2954090094366b820a02f4c3c66aec5b1febc96aa147a6b8071b122c404270bb61cee3ac97d37868a0b313426224c20c190c4567ef434251b4882e195a56e0df2dab482f355756021186701bfa6fda527552ab4aa43eed9d1d0024cd33f677a78c0c8a5251041248f540ceeefff6066f277c85fd295be5c992d247eeb644b82365899cbdcb3f81ce2bda3c6267bddfd09fe218f11dad7f7ac64c5360bce2c8bb8c9f7f5ce47b2999cc94506bd8de4212e3294a1592dc5cf6c8c4d3da9d9e37bbbbb1d2ac2bdc36372b56b586dfaf116be3ebf54609db268212e19ac4ce6c3ea0ba898cf71a7a28056aa36ee7c0c57afc9f7e40aa2f1b9d7d6f1eb36a8b07606be48a9833cfabfcefd028f4f9a2798f99c3dc7f5ea02bddcdc0b785c17908d31acea32cf0870648f2e93ae5689d233e66aa88d7fb6322dc2301d8de4fa462bf182ed889517bca8dca48d5edf10746e86c453ace05c6d996b8e5e5c269b71c270e012c216dab170eb259d71d07e74375c6d47a576faf5129b0ad63fddd9281095346e114c7db7c0ee5b5f8b5aee52718f4a12f7500aa2c9a9ad9533332b346a991b06815f9d59b0087723a278aca0a82a7e8c67f2fa0cb1f8364f4a6a75a8f73027a09e1141879cc66b7499d5a22b80124a66385f1cbc8bf8798aceec0a6ad9b639dcda952f9e24e776d5f3908e752d54e48417fa0a4725a35648942561039b0bcba0c6a2e169574197e1fc1ad098d98d07522067d0d23ec09cb9747de37ddd4029308211a9bd7c258ded6a1be0db2fada4e6ca58aaff60221b8a661a60b5f468aa180bf4945d52796ba5f3e98674879b43627d3f09dade19cd43f02456052553616053c16923f5732e370dd2de26cfbb57603db0df264c453b37434695d18cbb75243efd9426337fabd669538bcb34aeca6645627f13dfecf73af1496b159b8403a0250ad16c4d04a2c779026f7fe97f619e579f399ac7c3d65bfee6b7c0935025396c2580aff068bc6eea137c3479a54ef4e696a4df58eb70cddcd321321e3ebdc30ffafe16c0bb2a779460f00af6b91391a62eea64910be9a2ec8716727b1da82a80f9e2d2e6463161624eeafa3cb15bfaa0639b6d5a983c49b4f412ffabefd5e08704d44b1ccffaeaa9e23745dffac4e7461a892a7f79bed4f1f0e2921c01d8eb3bba92661d772bda674977b592c138671cb3f1d4d624a6d37e6198cca9e21ca8027375103586f7e1c59500578d87a3165c8cc9fd6ea9cd56eb336068be9891080303fe7390659af3eb54e6c82e7bb8c069e7825eb33a6e6478e89f40d4c3abd1bca46b3f0d16901fc57b0edcc00dd1d95d6ee1662d04786b26df85a65aa57f536abd801a27db4ecf89332998144353ae1d447e1e9e400588b256456042da6339173f80cdb55f2e34e51586a375cc9be73c4a4c8f1891754a952521579e3feefc2540360dac1c029c88fcbab57954ab6ca487c7862b69edfdc82e7ae5060cc93f53930d1ee73f42eecdbe5cd3aa385588929c0168c5f8b9d53081d815436a32881c8bf3dec5f80cbbf721fa1b358dd3f0d7829efc9492d9b822f36131a34518eb12a7f5331b24b10175d99a0b0a1359d29fcef4a4e69acbf8fe707664d8a78e64c450ac954dbc273383eaecadd8761426ee5bca734df59c74bb99c796291c6db40b1791f1f1caf82d43e59cb9f84980e121b667051ee8f2e40520ccd56c2813fe8532a20301357d2ed0ba6f8401fde714157ef77db29f52d285d3627a05b3fdfd71e9d97a266c448e849efdeccaba5b1773f80644a1ab2d657e46d39f816c0e47ced4bfe231f31a6da568e62ac96b565232b23c704910d9ba94fedda837b6d423709fb993b4e80a03336e7260ec69c990182b4c8190e9c37ded8adbe92423c52a562cde216f50a0a795a30c81aa915c8c487370f9dda9a518851cd477bee1963bd66a957ff277beaf272ea8e55bf971be8b0a7459e9d4713a01bb4b8f81d1723a611b4c866729351ec16a9c551c38897bd0d279d8b382082fc1dd94178537a173e0bf62fdba7d1a4886709f235fe7d885cfadc533a462ffc390e848563aae0741e5cc62ec1dc9d92a3ba5e7ffb1c2abd27e2125965e855e3c2a062922a21dc8737f7abeee1e6d72671882666830202c545880c4fef68691870e1324c51f10fa3ba0e756f5151397a034664c8c54d9ba5c539355a405b9ea73da745f760443faa48e079c93c8b069dcb008213f09f4f2b3fde87af60a8c8b82d6c0520667de82feb898c1f0566861456712b795aa4be6615a01e809828d0c90a4545dce97b79bbfdfb4aa8b2d530b3e75f01ca827d7323483988dff0d9324b43a92f68daa9bd59c5d3c821a351088bf9c64d752c36b8ab7e53889fab606614d0f6df62f457d3055e3b72a41e7750cd5ae4f983d53bc1be84fc3d7a094f4b8ba313e5f041fdb68586aefbeb8f409ebf8315cb47fa853e529246391016915c0baa66618b112adc33d7e0997bc8432b413f801115597aa188b57d7562d2d20534ff3085a1e0fef3b25208de43c8f59e6d9a7fa6f9c1f30be29d7b7d2df79b8fa782025b0949f9b1d89f6c31ac0bf337d8dea2a084bd75a141ee5b019e542c0e75a1773921d8c0865dbf5cb90cb5684dc75941b598ffd92094739b3fee144a20a05b6fc482c0db25400ca2f03e1c0dc76e63db87f91f680c21fcf389036b84ea4f9911e9b79a13747a70109caa702c6845351203ed43dd554e154f867edcd0ed1b1b2007989b6d4caecb26b79e5dfbd279434e4a5d95ce574d653e3bbe2854663acd09ec65ab2e6f6113b81beb13faadc8c851243646c670879a212b572ec97902306af2f64a16a316b81ebae413c60606076f4b3d6704f8dec578dd2f19b3947e86de2563b6a4ee5a3e11412a70765c4e8db96dda46661d482041531ac2a7d0006fdca21d40ca5217d14f44ce933496e8d47f064dd8b4aa15fa7c5dd5d140ebd43ce5c06b2f8ead70d967bd2259b0028873700e08c5964216600bc78ab734b15df5b643a17cee05554e7f77ed6aaa34cbac93b4907802900ad1b56768dfba4b55d18df5d1e8aa0e424291f16fc361aa63f4fbc35811f09ffa712fc3d338b1050be2589e74164153e7901c89b7888ef307d3171f34d69d634cc6ff5bfd3b477b4191ecc8ad6a45c458546f043b99e9022e0f1dc122507246606b5079c0cd883e6d3f67aad0c2370a5757ebd27db02181ee9414f8628191979ab15c8c548abb463321bc6d05b8e23a642b25a4750083f4dd55870f08454cd9fdf113db4737a70a431323f37f5ab6f26342ce44f10e80a14b32cf61b96ac1e92b928c5f0a06cd91e9cd3dd04245c678ac117cda610bb749ff832b7334816ec61c1f7a2f4beb30e39af0f1b51f8208821199ac1fbb588f919be48cb5f362cfb349afff3a26e01158776b549b309f77cdbcb08c713cc185e5b26e4a20a4e8033c817a843c977bf1b30a4fc5ecd27bd5bfbff37e60e6afeb2d261d2c2c0c9a8ff6f7c4f782ea92d06c949a83bb69724995da0e3284accc414667938e46431fa5a784d6c19d0244c5c448dc9702332054a1525871c7456564b841ef22d685c947306515fb4a35adec7165a4665e2179727b8271c0baae4dba413384e2995c895dd4ab695dea5ac7842ae15d0443b144c92131dc22cc8c9a0119f50699870b82376f9dad9adbf05dfab0e8626e67fafea4de38c308db9e491a9a8b26f8d009b96a761273f929634321d848e6facc3c87ec24003c170e2c455fcaf4c76a69b64fffff018b435772004fb399393bc227d745836b59706ef52b3e6468e8ad82ddece5bb0b037103c350766eda57468c512dfcd73cf2b0afa78a081e4a6e5f6aae3effc7b37bb94cd31cdb365571f0711f4d0af1056a2af1e658398744d83b671553ae14ea224b8fd382cf6e6559fd470147a5a82c7bf7f641758d544e1da52c10a089e37be2f7b942caa4322f34d3c51c356f1a0f691e4d90cbd2f3fbdf2d6aaa7e3b5e5c238cbba8d08f023b8b13ad789b0ff8e3878a6484a2e42d133290a7fe2ffe1e6fa44a4d03934ee7f132424c9f54866d74874909bf70fc308977302cf3cae9e044b8ebe1a789a2c0983596e98d65fd5d97f6bbfc28ded276294ead1ab78d268953ffba5c21495ae5d53818e19c42617c0f7a627b676229a20eaccbb2bd5e0705f728f373c946616455834e41baac4698f013b4ec45258874c1d629db6856da03e70078956aface3c3bf8a7b92b4893239c302a1cd3ae5c93557c65ddd4f6867d72af152c0c4c820a5b0fb177ae96a158356c9b9c61ba247da08831ea596c621d9457951d7acb442c66232a9399736cd3ac0f2714f82e5f9bfa6711c6c77ae789dfb4053399b0b4ed069553819303ddf7389ee41aac603b90aeb19ab33de5e13ca4b8460b9873e39719c8cd109ca8d06157a639d171aacd4739fab074f9397f7a509970f455897a6c71a97c844a69ea89440fd765244a7e60bbd7b3d939b40259cf01b5bd8c7edbb8c768ddc153401bc0914b7c691bc5bbb0854cf3969f72e0e855ca0230a1586f741367bb7caca0da7dbb54a0e0977e74b8893eada44c1fd833cbe8249efb48a9a682699a4e524e625d08b7926b30366b749555fda18df1b382acb655e643d6fcaab4befcd3c8cdbcec2fa2a338d4b2dfab5c2043f547b941df6d367ce9b29931fc080406777b5306c2ec72988d7ee864898b10ff395b93fae07fec8630963a15ec8cb14903203357ed571733f91070478971b7d4f0e6b6c196e02f0af47f44dcda7ad3c140fca902e226b8851967f88d21e5516af3cda600dd9b14eb54e3afad33441fc46285c38ae3507670414d5adcde768147951856912f066a682629bbd2a9b6043e9ef4d0be539013f1f11b9fbfe0a4ae360f7bd2f2004073f4cc91f15b16f1fa273731302fc100c9c321dcb4aad1ad53ebb826ec6136d549d4d73e7e860f3451cce69b796263d14b193e92b46cb919c5aba0f941d5f6336c33acb78ed7cfc5deef18fecba93ed212e4f27290c16b99038f4c63dd5431d013e874ec47f2774c3063cb83f148ea6166bbc4cd39c1ac077b28a5da39348b3c3a261b5cf94ceac92d893f94a91be25043135b4668ee2e90ae1383e800677a4588b8080a8d83f63718d3ad137cacbc239ca3a5a4096e5e9ddec527a022a31b3aad613195284c4e119376f4c346d4eea23e040664fe678f2359d2ad77e563f93fa02a5385e0eca327ac724f9344fc20cc06ad5309933ed0021318b34a91f5d49bc6f1ae19e0ecd834be72e234b0b05bcb3fe984fe0737ccccb4b8047b9cd366acffbd1b0f50bb98a694f3e27e658b19c482e165a0a869bccb45f3820eeadb1c8256619f05e5bcf6082d2a68ca8af62fba05603232276852a3a8979ff397503a3d98dff15b90970bf58407fe1327914ebbea2b28aa046b17c105fbfe403dd3a5498b2d6c240dbe8b20dfe6d241fa6e81e7a727ae8e239876f90d4b8b9e75f0e8638d98fa8130c2f81870fa0c9ffd5e1426c84205a26cb7af615d21e1e37fe9615b95b32ab108f7442647093cec322fbf071c6b68e69f237ca92afe4e807cd867730c65591316ffb06976fc14aa1f1602c05e37c32278655770a56397a52ad328e903aeef5794379de3a58c1bd31f4c40d2d7c6fb4966899f382fef74fabc3a3c7d08a9d4569c71102287e3e1e0fa26a96cc65e6975fe2cb0f0c8f90478fc4e6b42f67e34262b86bc14fd095cc6ba79df8cb81b721860d2fead395241d339f97379ad9706c0cc7230414c8abf9b2940ac56814e622aa0c424e7893d6bcde2f5b3faca427aa2d8f4023e2ee2a65796db23799bca9ee337fb96805232eddf52fcb85513e6e2d84a0bc6b500301701eb7c667557a169692c194ae29a6eb86147d2cbf02c3487e18c4aff7e327a959aa6c0ac23e53f86bbcd1170ec650b6f330164afdf9dcace99ef057bb5f64a909029c13e4ed33f7e7415340d7d2476c8de13ac43c8bdf3e0bccedc55458d19f102e1bdce74ceb790b6ab4eb379ce580c01a862391036f2fe88198742dd86fdd284de1a27e2fd3f355b348b405f2dc5513c2c80644bf39120a892569c434dbb67c76f88b146b8efbb15cc06584125a5676891d1513dee10494fb489907afbaba01068ad10933e7ecc466f5e82e5ec3d343b083f1a14f5045720994f3a4041af6a363dd846ec3ca73693f9de9338d776b4c633392520ebcc70475e12802b61fc4619e303eccd96daf6eb230853f86b851708eae562133d14c90335d7e259921bda275115ed9d4e4c160c1e806e5aca4f4163d02a44ec171fc55bfdb928d20ad7281a772681d8d4a05c967fbfed29d17028a3ba880307972985b207a078c4794086b56148866c9ec1a6136e9190d56136d25e050f07dc93db9e1eb7c8a1a6a243a4185b5df0104dd0d4660a7b204faef244d619f86039c27047d2278d1ece4fb57f2e688db070e6a930f5d7c12fd2ee4de797f999e961b7c50010e19bae92ac5fe35330052b8726a6688441e5ced12b0abaf5b08c08e8e006c6ad5787ac5997efa0e384847eef9d1eddb9d1ce37adf2e4deebc81c5fdfacc0eda16530b80f16fd00cc0dd453947679db3cff2b2bb4597fca8f388059a15eb61706644b516caca798e0037f37b803e14bb0da5e73f7c52ccd650a238fc14ec2d54b2e2ae2422b73fa758271d5caf8b15bb745a92874d29a885e2b4829c0ace0be07b5cb3cd38bd55fb1a1d2443ac1bca610ad631b7057d39ae39987cee788a1230b626ea708e43ff16fbcfd877324b08e9df8e3362bcc9c5851585e0d12b6108d5a4a1f56275f39c735570580b278dc20df4623e1bfce6517b63ffec572497c331153326ccd002ae84c19e139238264bac3b0fa0092620c695aeafd8834ebe16f8ca71db9c2064cc6296ccc74df73b171b4175b3bca4d5d3924657ea09327ab0d629048a68fa78661316dc0fd90236cf486c6b63bdff01cd3fc43b3414983324a911cf6c59244e744c2c61aed62be8a5ace50137341bfb76174cb4781e5f94d2792eb3727252bf26bd107af09f9c4a755438f3c252b51f006f3c6dc0350d00a6fea42700931e4c1921760b7d01d0ce51517242493b720d4cbc6d57b32880709e78d7e6cd4b2de28f5ef2e628a30651cff9387e4c806ef9a50a026d613386e06cc6f24b4f92abbdfcd4747000321cd4c23d33bb6ea1d33b1483c4bdfe7ddaa818403a638a417b480bf1b47d46af9f7ab08cb0c097d56b3ef3f856b461d2a0e941ffca4deca1ef7b7a1743c79f9db6ea0e19c7c40d213d04264cbdc8886312ad8ba7763f9d9c97052e8282492706c254f6b4ab47f885a202697cdde9f8e766c9eba9855ccf648e466fb46bbab020ea08f60b14020d66a121021347123c0c02acb011c086d99c013251b1769ce82e13a15b9deacf36f9f31fd572f2ec6c43150231caf9fc1a93e8ff5b57b32a41f4181fa111e3275583a23a24f237980d73a78126b18340ac2c173650626bd78b65e4ac1cdc9e517c5e34c12de08415f4dd73aa163181deabaeae0546c761da5f5625e6022bdc6c495766ca67d96c73ea4c2cdc5e5e7b4dcc073a28647863f6f22ba94b8ff595fba7aab9c8a346312b9bcb93cda8459be5b2e3008a762dacc6bfdff9697cfcc770e55c1b9a30a58129ca82dac0533db8d7371a853e26b4473e646873bed8317f950f9ec4ab4a9ae73a6bd160747d4e2b87a1a465630a8fa8fa6a824f3c8bab69ee03aca3ca1a69a399edb79195aaa1c7fb4626657a264c804dbd3031d0f97399a03a98937d7304acd84f1d3faa581ecff8bb952154c629ec71fdf8a4007ea745bc9674a4bd066db8a9cb8f614ab563d54038641c4953fabd0a821c8fa57097f1f80b38dda65e6f420f6b58873e68fcae1b26f733daad1e1cf9eccfa084ad484570ab0bc472cb22be20334f43446d801fa5647c3fb20523eae2968e889694aba554c5a9dd4d07a2fc0ed4efbcd5cbe502db1cd214c4cc81f700ffab1350122a684dc4fe79208af2aed113dd5a93d29ea69c8660e231d4bce924a2c4fb45dc02826248483273553f17dfdc18067a42bac3137bac6205eb2f7009770e7d89c41a347c2ba63a337862b74a8254a4e33304ce6eadecd0ef7068082b23c6cf49ea92312f83d487f85156972ac67328a3d8610872f652bfae4781631b288815a87bbb2db9cf029de7c3293ac8dc034002c245f8e3b0a880f921be75c9c6980d488327b731b1a28383df70366b3e7fefbcad51a3a44b9093b0c513028ca4f91dc9ada3af56f39a13313b4653c3a44b4bbd1ac36ddfc7396038377fa5aaf3e45f5596369cefd63c2b2132618e242f2fac4351e981c1e51b5b1224d2ab42e3238cfc63a5527de468f65f57c1626593352280c5a672aaace88a977bf9d912d78c6e681f436cd96d0d52de0ed23773fdabc87c91411eb7bc41ad2e3bd857f030e5bb25fc86caaa89d8714aaa8f0d3f3f8f2d85d5675556936fe02d2582053dc634bf9f47fcc0857c668614544bdee3b2c20f6a0e1632ec7edb9720629a645433c4c88f88ced6647b4ea67771a1b1c6a77b98f4318658a0a00a289bb536fa7bbaa149e735307a300b2253912e246defc2b7d1360e100a4ac42d422e6bf517f7015a5e7cd812ae1127842ac931688e11e8b29272d12e8cb8b489a3802af5f906f0aed47b46b0f8e95d602beb04115e4189b9f4419e93bbb64b64e98751607c07186adbe44ed6e80dbc942ee7c8d8642e72d385147b390aeab9759bcc439b52ebe348d29289188ad0f3bafc83984d38d393453782a585855fcfd3d896a0090c09f759318455cd94f513c6b84be524c5c566e69cda50b9f642f5481bf80677be49644f2242b5c85f390cb175ffe5223e24fc6870de8ce86806e0255346d7ff3352dc944adaca89694f2a050c36267f097a4d6cdaeb2fbe81079101eae4e818fdf36290c6246b2873ac255c14eebce93d73abce020ef1e6a18d59594fb7762b3d26e76848c5207464e38d91a16db1fc6afa58f0556d19772092157cd56f2d230143ccaf9f3d89cc1595f6decbcfbe38e57f3021a877eee072cea4f9412960c45a5953efcd8a7ab0afb487b62b90729c5e7f0bfe3b47a7448e5710eea5b6d22c91604f179e8acf8c1f6e720135bd080ac354c87dd2657cf38cd5a3a7bb71af971a7fc3d1025732067745cfb0053e33a03827c549245c09eef21776a66da612d51f3339ba8a0091e5e2957444776036ef4ed1b65204cbb1447aa54ad83e4042f4bafd1df40574dd2dbc79691303170cdb617c2f86440791b2ecbb1f39f425225eb307cf9e93d9b36a98c84abab1d5d67d1574f122e12fc54375f83638117119e392c6ce0f33c497d7d67a06bca932334629aec2ffb628ca2f8c737e6bde71c54dfcf4ad04a48c1c7303762c219f00c5648eb62c6a9b5a3af1437fc9d60a4882f4bc8bf690eeb083bca94181a19d8e5a6c4403bfeaf668db2553d63196e9822c3c11c3cd9a552c9c40bb51bd27d8103ddaf50c477164960b4fe6380d13191582249f9f089566ab469985800a4c2ec921748cd7e98578af99ee3b8f56e02ac7af214d77fa170bc8a997ad0a80cc5b5fe40596eb1314e5b069077b572a9129bbaacb480e88edcbc68ad7a79a6c7808ca19e33794228f09790903516102172b1b38f0072b81557e1ea6f6df917c7a92d8e9ad2f657d1f4d144120c312b1fd4e274ca2ce6078727ce07b1e89b090ccc1ddf6e225828ec0163ded8f74b56cd2a2fe774545abf2666380233d202d6e15ebaa92c9145cf3f20fea18b0a7e00b76d83490b50d0e3d63aeee3fdb3efea7bdd8d05113a691e603be27956ebbdb276d05baaeb0715415540c1ceda99a9f20a97c14a26d6ebae0bf679e4976c64845215adbc8f7e04bf33a7539cf2765818df064c47508ce0b062c912158d25ec0c4faee139d0e4ee870d3d909f82dc70ae3ad45c124ff2c7ed75ef7438a5fccc3ec87a8da0e9c7dec1785c0c332f68d2e0f3f2e95f70b589359335f584f3da23da541cc46d2279e7f3d33b48c98d252c83e6e51b4e298eb1ad3eb3d66b67bd42f9c5c26938137a21b537993e200b4f4a47e95ce988e14d5f8ff3c333789ae845dc3a79af284f0a9030557bcac84517b6c40b6160be9149f72aab6d3783a186af45d872ba388fb63f0435fc6937826ca558b82307355c2f276ce2d85a53dee752b1759b38288cc7ba93497d972cae55caab1491c2a3464a5a5178eff2d6ed59a5373733cca4300fa56db619925e938181d010d0c22737d973ba4cf65656496931643a1b8e172ff3208ef5ca5862edc0e4c6128ef4c6b7663aaabfc0a89f808a8a5f4b994741b207d5d52e467bcb26e0f376e5e55e51daa95c0e2ced18a8fdf312b97927f9142347f2f7b3fbffdfad0a2ca156926237df8bf2a395855a7d9651c00b7c486b9e4306197cd6f7e78ac8ee47726a824bc579a9711064b6935f90091b4dd7bc74b31c24c5d5267e283f76d74071ce2887e31757cfd7eda2836b01a961fe5b959e7cd90d6de1efe2a980e02d27591c59e3efe4be0184dcc4c7f514300481183a3bdf523ac9d715f23b3fd483ce8914c3cafdba996d34bfaa97eb901462a4779ee91a1f1dccb67d454b0b0b76813944606731818c7478523199f9bd46c83ecdc7431429e0eda2325f37c7debd2d45946e460f68e34f5debaf46b86649d863d291c9ebc1ef68e34a5ef76043090d89bb3e18fd8bb1212f7e9138ac65c6be227764a7937471632b9e0c8d5025fb503fbf44f4b74f9bbd34c5644c094d6ef4c5f3b39249158ead6ebb16f78a8c9f73ea13ff6011ffb13db331da74b8cd0b7f12f7203042d160ebdb702fdb7e8c8381f39e7da9316c163","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
