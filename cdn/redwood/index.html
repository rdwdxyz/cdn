<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a95bd8d6f79246c7fb3513b8ebaa8727d53aabd6ed967b219597755218d99cf09e3e9a46b81af6495436e083423424ce5b351e6734b3e96186ae8c7bf622de627ad3637ea1e2c54aa32bac76c7eb45602def1a073e9f4b1fc48b049f1132ee37913bea76b8d1c6958fe88036da2f8eea274c2e0ffa67519171e747a729cdacf4fa3d125ed3a2506e80a82a207a890a353dc7756f6d89e13656a3d4c9b7314bc57363f90095eda8a7d70eba945bc104b9e303311a890c8e5d0701951d9636b662dd3be3d34f1a79c92d1286a74cd5c1dff68c67f021635e0c2b41ce42b2dd88d8ccf3d09c83c8bab1c59f127d60bf1d579185f2b28b01db53131f5bae2a94c58850463af314c21ba3e9d76172dc4381d6aba0eb68a06713fe5950bb49b8c755a173aca0c39239c82cd606b5b2c295d1bbf4bedb3d9b383120a9c260bee9dc8c8120ffc6ad4e3d339effb1b28bee2fb229d287676c5b04475550ad5a8e401c212a84ad3ddac98d3e0684a6df8a7eb2085b8eeafd199cd5a690f5d1e698210bcee7a6137bb249d19b239028e97e77e6cbb90ea54d71d4f8c9c8eea2f5e226f5c43c82d5718af4e431a8ffa97d65d4d411e7642e452b53fd5a706bdf627d60bff583458f7fd38ad9820d2ff2b79438cc9a4a7e8b2397a922a28b474700bd53ce298d9f18653fc7b13faa6c9641fc1a65e896acd7482fb05e8a01c63ddfc02f9acb51a9695d8d748237ee329ebaa68883ce723c3d4429eb4ea0ee8cdf372e5a1a3e4c2e30a7feb3a235bc669831761d47324ae1635b48055546ae6134fe6143f242a8012dab1a9e187e6bcf766b79689c3d517755446c7abf073b2ade3412e790d3eedc9dbaf10b8483858e0971fe94314ffc90898f03810832876db714a7a9f6f0d87e4523eb48a4e8317735d7ded98c7087aa10b9dceb0a1d6d3467d83f80a6a95960c51a41fe89644a7a5c862f6f05c02a4c6f2b046a1d6a166a2368bf0e913b92978d99255e7f5057f767459332c53cdab8b405f55a4befb7bb21b62e2511aa00b3ad595269508cb70f4d4c547ba16a121edbe9a0b3a3dfa9a6a5a56f4426dfab961a3386c94d310b3d7d1aa4f65f60e20878ac2242e3bdf1085d40b8d4a71445551fa56629bd66460ef6045727152742201f5bb8719c76b1e090ab8f74d0ce322b53553530f82cfd682884ad73d9cc362ee91c28bd3388716411decb2793a319005d0c9d004ee31bd3762f1c133ccd4a40a69623f9c7f590517edd94418bd87624fd5c9e67e600c5df14289dc23c2c8c53dca633e561c80f14f8efb13e6c490fcb850c37d57a842f5a77dc0ce4144e350fa139d1453b02abb181185665c90830dbd1a4f2e2f27dc946fc0adf11a24436dbcbfdbe34e38bf1ffd24cbaf4f007ef1570e96a07fc5fbb4123834c16d5ed7b8e94c94b7f8c13f3e5df266742e3965f1064ecda231c8b444ea604206cd61af85a186a824eabe3c8c68279b00c94550b4344e52deae2c2727759cc19d16568f9feb567193ae5fc85246ea8d6705355d0d4267f74e6d814a29b622d206a9ab463c4a92bd8dc1add61552ec8b9840d7dfe59fc9f4844462376f0aab9383a07588bd849489bebcc59ca24a66057d9315121f46530d88f3d297a84622d6dfe241033f7bc45bbf4ce50c410a994aeab3845988f6ae18560bda6f555a131b5a9e56020b2c04e4b402f37f7fce416bc850b3ce805d836e2927ee20721d37bbe6aed32fba6e6f11e23b11c3542058ad321dddc4713088d02b8e34110223a1cce380291d9864589f796d762dd6bde162cf765fdb4f40fafd39bd40c4c002ae202bbeb874ae32567cc6562bd3fe95f55597d13dc49eaa1661ffc6ab147dc896c69b6a7497ff09661839babea57ffd9262260d490d5191758200e8d579130572ff82818b828b04eec24b6b7aee1c67ca33af44f60c4ac663fff4045ba30af4a904d15f02195619be9a267482166825fd2011c53b60f3b5be05b6ef29684bc2a49e09b7cbf7e11ba71af0eab7e6ee853df9a45037eae400463e378410793e71790f20165556b573625fca1b713025a800ebd288c5d1ac1ab6055e0179375b7b56d4200137ef8541de2481ad9b07ee489ef251a3eea5c0c6a6f5dfe147bc5f82349e0b067c5c451a2c3eb0cb7a5775fab6491ad78c35e8db05604ccd31be77bea99db1d31e87c808a2a29f1440b3c41d323684775ecc6aa20f906213fcb419d5ad67750e0afbf5307e071b13bbfdb079f958375fa9cfbae5439175d3ee97191ac93f01a4ba86ddc1bab5dba0048f1d07fd2f6e0b5831f413c8ce7d203fdd24fc6843a4fb6b70e95d3fe306616d181a7b0fd7732addf6dfc7dee45e0dd23bb6def47dc9aa75feca07e38bed17dfedc9abcc6be86888f44c4f19cb5c7ee925aa885c23958def34952482e12561492ebf20c1c7fbab41057088ba24c198872e1d8f40cb4c97d12a1086c11e4561b246eb41836f8ab9332f2db3e4860b2aa4da27ae386618bf54946dd98de605896dcefb6d1542aa5f240fd76cf5f9a1f874165f24fb7ec00c8ba12060ec3c2c56e1911beb019b2afb2d6a343e5db88da884d760a69a0a0a42689076717596f942c626f62608f3195f0a30e85a7a8a071811783a3f0b1945137f1d99cd67854e1bdf82461eb1dc6b11662b13bbb1aff4e2428a6e8c52df7e102d98e3c97e93a97370f500f4947d8668aba5dc87fc5186c650082b710a84e0f5703030418003691413705377478336ad6f47cc4574cb8aa4cec8d10e4b61b715d261942a8764326cdd11e895bd65c64dd35b92666c7d4ff4688c1d34ab4940d85531bebf0d5dfc65370e40d73195ca1f7cc4aa35022b401efaa1e0165cc2f11349ae28ba3e35e0c24f44ebcc62420601855de25d5355928b7c824cb5d0f62afb5caeb8065a32e0cee77426fb64f5d3eef4bff08c6964859e48e5deb2ce6a0d56a72fe6e59457d33c247101e1d35021c0018a83751e609e45dd1bcb37cbc0f38ef084746bcd233b448d821f1c553ddbb5023ac21807566dd926f43400184ccb79e4541e19a408a7ef5817db048efa80c6979efb639738509c50697edbcdcd2b3e802ab88f4427928c19e977a2117fc322bc8d754b9b0d9e626619f1a6ea8ea19443ac29ee5182cc0974739b2eae9f9cedc471cb6093e4bc2dec9b91e4dbb1ebee6a6fba2563ba57e8adc9f8552671c402e0c4f49aa82587e05fe693a5b5281169125478df4cb761ad25ff3255ce55e6760623617de67e4314f3a318464e312152b59d97003ac9c14d657c3dfe9f6e232036ffbe6a236d6c3aa09e627b3065177751887e68a053070410e5b8614f01ea24f19d82062447ffcf117507cdbc5686ccf6df5a791f810a089f2f027dc78965881817c4b1017b61d5c6cd1c71ac8584380d6840f358eb745f160bff1fd0e08ec7ddd66921b4bf27d57edacde074c313c8669e830e5fb17aa33145b238196fa756419b450e632fca529754b16c2f4092c61bfb086f1a9d201870776d8bdc719e00e000c3413a6041c02f0f4a1c20a70a6a6ed095caf3afd607c52706e432eb1b7d3de71a1e73a68044e0f50ffa2a38dfc26e320d893dd32548781dac2d31c4db0da1c6cf746beeec0429b3267369e2a232ac151a09cef042817d45a3c6ffab2c9f5dcae37d6787620644dad9de4e6dbfffadb51116bd32c368f99a64eb4dee6889e8d2a5189e4ab9934149037616abee152fb0fd3f77ca4bad79694d245db57a29a4346c30d5626eca31dd7c166095d8e3e2b7bc8c0293f6332b000249edf4ec01ae5449c303f7f7623a62014546bb7dea8f727301f83d70490f12a6105c5df3665414b9d13943845976f0b6ab5d47f3a6ab44ba144cd9807e3b0cd6cec6f4b9474eba9013494246736e41d727f22e6c1eb225a997a4621ad3230d01b0e1818021f9de88edbfebfe2d6efbbe013d98a46948f883a3b8b76d9f21880b27aa2bf667f168d7ab5570b8a2400d10e99356d3930a394a64eebc2421459565fcbab4b4259825a9767f116a843edaa16d584cb0f295cf15c18f105fa35d61125c24aaec09fade9951dcc2dc25f4aa116e54b4408469a8047662d8c2dd6b26c38401fc95ac89dfdc1a5b4d176ed6c76a231e1ba7c41fe1cee80188781fce739392d3b1a53e2bf553351fc9e5ac6e468f8bdb704b306635545ab356291cfb9f804aa87cdc639c911fbc63b535631aae479bcfbc18f54157bf9db48af186f10d3c17a58670213505a0f45a018c6c24112cf30581f724eb56ad70729f22ebf38296cf033c602706ef64a00924953239cf85b8e0087980a7f52d799986fde3c220ea0052a5576d760dc229b67013807387f3bd269a86804273c0a3e01a8bbedbd439fa29df2c111cf1001ff791eafa6494f4c10442191ee229cf25ce52c7856d811bd63971fd3ccfdc2549c2e878d80f35b108b73973e1c5b6f985f95c89db6d7792178a2c9be69e0cb626702c0abe53560221a26c3bfd3b5ae12dcd19750d755ef0aef9018bc79b6eb179a0ba77b9c82f5c370d19ea3dfe8f2a80339c700306c11273c48c88286fe02d4c5caef5965be1a7adff6e66fbed54d53b3a5c9fa5dc03c2c0167793c54e8639159e5da6578eae2b21e1ede9178a77869d512574e29d4c0f891e1fc3f0d7b81e1aac495a8dd64dff928cd7943f59a046e4bd89a1b7c8dc95ee3d7fbdab1dd82a39de352cac0a4a2e7d05dc453e137cd5b0706cb497392628a3542ec4ecd21eb26f84d5e4eebd1579a33c345086e4e9b94052cda12f23246fc1c2361ff8e7662fae64b04a73e8aeb735a819d1551c850b119a5f4eca885da4ad8b83c55e066d5a6372961759283e41f4ad42dfe35dc3352a8539cf806ae9c420cfc0fc5b5550cd01fa4380e1304ffc72ae366fcd3835df90f22776dd818124ca647b2d0e130606f02651b17c9bb5979cea1212dec2404eb6b09012d5d320e7c861fbabae8e287bdc306587608d683d6859d30ad414b4dc4473e4a89dff99f8d40ba6b0cf536559f3b3d4afcfca743de037c4164e75137da7a02cd6a0985efd1ef37a662534fb7410f80e91a83d5961b5566bf54b3cbe452440081bb9f7f6379b3bf8ff544eaf76fec57726b539e6d75e49e5908c395f019c15a989a2af2795f48d9e928679f772d633028a0eea80d919f9c0cefb353c0d2a44f36f5d526931d04ea830ca95ced223dd88224157fa12fe87445df33dcf3d40faac9303a338a5799a8f428c1b7d1083f4930b1626481e5ccdc33ed5318aaf0a204e6e7f3ca55f12770fad2e50dd93b6ddd2938cfd9a3a516ecc4aa0da9cc1b94f68885d52fbf946d40516be51444b2182e48888335463051a8761871bdd382301af24d13cf2c2bf946837d4d44ad466ad92ecd9df8bf1fe552f31c8eea9cb8282324f4b22a0cd2f6d3762f0eaa8ecbee983c0f0df1d8583ed96b65b73835837a5e5854eae20b7e7e4bd339ebb751c2b48ea1ce46aef40af8b326e01dfef1db9012634edd54c68e1bbd72c377b75ee75d9aa5984fd590461ff0dbe6dd0a2a6b4c6b588a4396a1bbafce352a87db34796a48b6b78d7d4200afe39d2d45e8debe3c10a44220b3e6f331313897b02f7505f70c089541a3d84885cf489e5d0437bb205a0be13492734564b18b3a4f93f46815e674cd2d2cce8062082033d05a2cc4c575ee2dae9b2c29b0038f44340f1ad39dee2ba3a02561984a40e3a249ee170fc28bd681fd7b4017c5a1d8e4422adb03e1627af4286943cc063ded62ae6684fe5d646bbe93c219cfba655b6579b32dd56a31d3636a41ab52f9dc160f4c52add5ada18dd968c0226e2d6ad254dfa53409a86642a5f34be2129d9cd880f13a3a4fd793c27abb781ed0d8926cbc6a4d64c1523e884ac9228073f1d71256b388894b56b1ce1fba0dc5c737b327f55d63a82632040606a59e1959af4a8ad112f2a5302a5e8f2c000718f26a302420844240771c8bf3f8a4eb3bb2a6f40925292c31a594db390dcd269379d0d9b473fef7b6e440ff90a599e90b762037da72055d573ca80b727d986008ed8d65628ff0ef3fd212691addb574e41c1791a45333fb8a6915a8b15c6b47b156bb02b0f86dd6924c1a747aa8f88b9e199e2afceecf0f9818eef0d136198566127fa500376072d360d4e25631c1b34357b52d2dc40212ad0084c5ada09770f9edb605e516d222ec0af3c77d6315d71f71ab702ad03b6f263a0247c0e1584fb8cb69781e7b447c2dddd2d260091ad128c9967ec78dbd3b7275bce38978822b8601a1732d39da1bf99920ba173c0a24240e4699455aaac6577607b47103293b8ca2b7b35c20889bf07bddb23b07763c74f321be165216d2a0b42d965fddbe7f6f1f6f812918ad51bb95b9dccc9d90fd03f814842bad98772462fd19b23aebd22c9def28f7763ccf23a1083dca4d6d6f02277807d374d1e7cc3f6d34aa71073b48565e0dbe0011645ce7c89baaf4a2c4e437f7464c08bc8cc845ea5df9a9c4a334d4e0bf8abe3ececff3504e84e762c794b62f114dcd5d920619159cc10db0b9c32dfde4da2e408a874c750b49a78978978e0c5802121c1634675172a3315185e88ede1ddc49097fdec2741fb07bb3bbd2d445212c35df84162d27a887b9feaa2ad110579180b4f60f969533e36953ff06fcb54599d67f94f9ec0daae8ebc251002d65dbf306d866b6c010d1979e8e637e0a0c681a52752a47852aeda6206eea7f78ba279aea72d07e00335b1644526c1dfde85ae717d4e2a5982aebc84cefddb03e767a5a41142a7347ca76d9f38d37a5c80998cbf1d8b89335cda4d595e46d462ce93ce00cd165a345d27681b3e82b4fd474a283c657fa5c92cb04d3517ba612b8e32db51169f9b9fd17b91d9ec2a7eecdd9929129f2180ba7cdece1a9f973007bebb5488d5ac7d0aded041d88154a8f7bc9bd9f5d65a34dd8064e71a59268480c411ab8aec78743c0b5736550aedc0ba246682fcdc042c2d459264ac5b96fe5aef330292fa5a5f384c8e529467c19da33fdfbe842d29ecdb62502f4f65b7effd4f21b00fe35dfcc3562f81f4744ef76d788697f58e3c342f459cac6fb0182a1f6cb5feec33c777c56434266aa5a7f688ae65c77af12d6576617a753be99892029e22f26d5955c352c797e942918d966ad6169da75e805153d8693ede24d5aed0250df87417af161dd81a300443e50211c506fe374f94842ad2ac53b1027b5259ec041fb049a9cb429ab8c7f0e2165bf32d3ca5f24bd597f7b7a8d7c531d16b74ad966957c7abb12a9eced753e1baa162f9707b56e769ffc51f2e60bd2b1c6a50cbf3660543e2e9eb315f894d77ba4a4c9448af930fa8566de55db06c28d76d0f5b57509368f047a66e4eac9e7124a5c6dd47ac0f41e3f87f0530ff9017b51e7254253fe4d9b47a3b33ca4845a15644affae68a03c1d98a306a0c117ffa5bf0e5cb8cbd85d2af8786866e95cb8c5f86058979a2d4c1ce3a3d4fb6d08fb0addabb5e339a5e17b77af884567aceb9c941e8468d3dc9ac3860d912564de43bd7a377aa16e9f6d1297d8ebf594398d3c511279b7da716ee9411dedb0dd52025fafe90ceb93160d240c0ddd222f5cb23dceb78351eeeba8e43bc8081552f7a9bb3f59d30a052e4c673bfd676636bb7fe2426722a8adb4cdc85f148fbdb61b3cb11109cdc77dba8627fac476287747c1febb1a8ba331e263c2ae839f57b7b24e761ea2834315106cea2c399da0863277882d0b02c1a7d992e388c6e428274649f13d94b057a2847d2f4cbef5beac0e96c45c356548a81a0dba276aecd8571730372c03d2df352d68ba5fb8b9412c6e066801f1461b3e63018f0b7ce5e8bb9eda3ca7a8124ac9bf6256e92607005aeef37935e385bbf84f11be3f09a2b3ddef3cd50685112f2ffbbee85e15ffb26667118181fb8e5088c4033a0e86ac28dedf1e7e920ac719e5b331d71e0652c68ad9b6d30426d88286cbc971a5f4c0553285ed94a52714d021714ca2775d9ccbba765b883154567f7ba596a079859d7067d2a76704354db7a566b147adc798abc23ad9347f89f7ce8366c680b7ccb634840e013345ff61fa35a0f9524bad5fe66608c67de7da9d17e0b9cd03616e25b0f2bdd3a84883f7890e2b22e713d4a18094634e18769e8b6dcbbf135c0c8bc51407f5550f4d38ab6fa31dfdf811a8c15451b67fd4d4fb7927c38dce3b8210c1936e692b4f29d2061790e27851ee56bbb61f09cdda9537642974f6a82385f0aa4883f2a572dcac56f04c28e71e958646230c55b2335a1c483141f2303ca506c139dbafb857fd8f671fac6f97f4789d77f7afe441725b7fdf0b89e264f787817e61679dffc211bdb9cb44f941d8292dc19c5793b25008ba2771b789cc07e1939ee882ed95126a48dfc57a513977016d344052165b73c12755463879fb5cedabd1b354ad99418c85858e91fd00113e93b1e0dd709efb6c6b533a6c58ef496ae1fd595dd49e5b6fb7295b965da84ac39ea2320cf93c73c084823c99b478373d3c8f43f1b319aaff0bec10081406824dabe938f8be2e867b6ad9f475299a128d155ae4c2844d9c43e722bc511a5f7cdec0ccdf518b7dd542a74a476a7ca2084682dc7b1eccb28362bdb1a8f77b5c56cc0744b50e0ce8daeb79f240aac34b3cda5c7221cdada891cf11746a61cc25c8ec0316e848525487b0de4ef9d34cf766055a2f8ea537cb5b3f26d666d03dde54a9606222b84b63b18d0bf6fe17b07193511ad6c981baa5e7482ec4ad1057640e13db283d3bf0b99fe54078f2ee1b95fa414990f241e9567047bf21eb640ca916faa4519e13a53a28d02f10ee9c6b136195b61a499c402f410ac4ac191ff25a9f6082182ce4fae039e4f97c95f8732df954fc6ed0f83ef98d821b903410ef6dcc353e911b9691cc162be1a22b4bb6638ee25900ad3d7f303f0d33b7df4fa57aae27ccebbc66dfe59e231ef87a809bf9faed5cce2dc43a48dc993efaa668117141fe66c63d8f62e95ad2f9e3c9788a84611c93b5bac730d0e4f82a48f486331bc9a3b84f051a9ac80561c9a5783c20e04236497e7104750ef3e663384372ed48fcffab8546ba3453be81a4122eff2973eb12c0097c6f49c4d355baf2cdd6e85ee14d5a57d2491a99062274ea6f55c6701d86d8f8381841f50f0eb0e49546bcd514c40ffb533458c8116c7f8546d65631e78f73218e1a1a5badf2c0c02389cc929af80fe186b93051261ded348ecebbc69fc52c96a9c6b0e1c20cb2b44b530ecf458e9bcf5bab2db7e4ac414b8c358868bbcd17d9772e972046fd3b407a9a74c04bc4ac5f533041a10c9b0871631e4ce6a6afb6bfae5bf266e6828483f54d7950bbf316cfccd9b5a2a02eb9cc60e8ffed1b058a8e782d42dd7f8be1720cce18acb2ea1e78f804e0e4df6c683f255f6f3c19b09d994b1db2a251484cf4e4458461c4106b9c031af1af701cf880cc7da25e8b57ef18d350d9a6b4edbefd25bc6899a667849faff35c075f03c51f0cec15cababd91e5daa3eca106e69b3a3b948d0c495be487f44172a812c5d79a63f9d2b54f40ff2191f959516343c9f9b5e3699e8c55b9c8ce06ce99127455e64dc9335fd0f0407d802d2f1391873e6569fb7d11c025df99fa1f344068555a100566dc7c7d1d4ef726c75e1718dfa41f9c69aa8da37d76228ae1bb986466573c5ea00ae7810bbebeb79e3b4b04558d0bbd819b21a352d5c376848dc7f9edf51fc422eba92e2f0684adc2e96e2bc1c09988cb93555770228f80aec08510461723c6fb201b57bbafc81b029ff2eea0ae8573c59e25b9f8ab007694e4def8d376b915d3edc4d0d1d86e48d28670e417e78768c516f0d9e6a1608947edfb9000dc5e6ad9b9158dfb8805a610215faab2fef61c0557eb87fd0afc2cb9451971eff83a4f782abe710caa066b1263ba6d5b74a292e1216ba395e455f454d76a1f185ac4bcbc0c143557a975ecea1367a41473639f03913db13a04d014eeb141843a0f8e7c4c6fc21e2b6a157d958f72405abff706c25add2d0f921cd6218cca62288318c90e19cb297d3bb821deaae4b3c2999b7934877d8b2b7fb15a18c66724f7236a2e92373bfb4fba79fdee959ba7e86b01a610d740d4404f2f3280ca6fe79a3bd387efbe3292083a8c3296e6457e4c376fb0066fd9121570efca8e808fb37d592640bf32810d1a54f94b795333d33974262888c13a784ba753811a32c7abdef791b6939473e545c16d69d491712653f8d8d6f156fa89a7b57b8b514b16d59c2fc31b6ee36ec2dd1c6a5923baf3479bc485f81112c3ace4eb071456981b1b54f254cb21d51fb57b3aeea5fd30bcaa910ad6691cee42683be821f75d37fff9ccce291c2eb9fcbcad71e879a6a74f8950a2ef06f4ce221dc8940716e610807c6cb60eef1e7d2cc3cfc07474b9d91edd36f7bc331586ccf2c3d049be57737a84110188d534137e8fc48f8f0fdfcd91d591135bfff2547338e0d22f7c25af2f0b282bd887c038818ea71aad55605057a102890ab321cea6f0b966b7748eebbacc43e3b7970db2e3e8bc339810361ac5e3042e863e1dbc2369d60ad0708c087dba793bcf6365afb9889344308f60e73ccbd69726dbd58e98c45282f9976d5e8c56157b072e066038bce979d74d5d8cbc6b835b468184c6aa0a40947c2f5e93bd2873fb261cece05410fcf0c5a3b454e969b23a53c2184391d298a0af87fccee24c8cb94ba8d8ab69651641acd34d864b06ff56ace869e92445b1c3ead1c4a4d279751faa5f225e9d3e20bd2222b79ede13ffdad352adc654000cf3354487dc21171c68e710fc5f14d9def2f8562783319d1966da22c1ad8519196e8ad1654585b9bef645e9911ee0c77f67482501a364f7caf3fe486ed8dc4cbb07e88533fa13434b759c9fca30b22ee14832ab3e30a179b2a4cd0b51d93ecf672e20bbba98759662f47515305fe6c5b669b5974ac533aed42ab6e36dcc88976440f3072c43730b136c0088cf1800a9531e3ccbc2af6ac961a51cd4d66a130eaaea278b79badefda9eae48563ee929197b24dffdf1d2f116953a9cde6ed5f8c1d82c211292a3d7bf699be470f1214ab43a856b8451b42d4269e8e603a4b4e7f3aca9df5c92c3d743a1d852e65dc6d33c0bf1ead4d226f2926dadd3f638ab95c255eeb4e912d5c8ddea63d6e3f75afd9e74c9139e877affb793c77e30beae0997dc59de51bfcc7d57730a3a86c8ce12eda2b94a12a4e193abc63f5b9f277fce3216e8ae8b9c69a1cea7e3915a28d6c66b6d133fca7a74583c9193c6a66e4b39eec5750aec13601ef573ff11a1c1a069d27410e5a246c980524e1d82593bcb47f60d717b3812b13ce574b2c7085d0878255361f40376712d9f0975b5e6890dfafcb33461a7e72d965b3a865e0050e8a40471282de68db0950a384aabc63df7b30686b670ee50257dbcce880431777f029ab6c50d732bf905a5321f8f31222fc648da95695517d5ad99ae47c158afd9548637476bea12df0330361cd8125f6ae9668e82376b4b16c605f77c4d840cf25ecc66da20851431aeb864b85b3d8807aa284bd3003504aaa7644a4fc1d52ee6e96e69df32da392aa3d943b8cb185625aad3828c3ff35b183d1c9d62f5a2002369166a18bd56b6b51d05c266fc2ec975f0f6093a6720a3c9311df345d761290dcedfcd163d462cb318f650644ebc5b24be949543383115c80d3aea33b7847d3a3380962a9036628ec9e29c788563e0786de80abc45520437b960ed9016b16d4e0025ebedd8185178ed8fa39095952c1f26f43671a0836a42287f2ba50db06b12e77a83c3968d5aef00deb1b7b61340e10d2eec91fb47dbb3d7266e3a1544f4629c041cca6543244241c8b54268a8c2cc7fc8c5502ba88f32fc513e996749632da098834e44f56c60adbf34763956d91de553844184db139df4de58a736286e37364c8a59f3df6de4b8005944160ca6bdb66d938267f48bc55e90c03a88eefbfa2cf5a2e3aae396534707e07df5327e0f9fb81ac7ab067da246adcc93e4eb4c39610f85f3ea0bda4e48d80e024f2bf0b2244ee1798e835b9553b8100466b427a081679b22e4923e59fc354df1a7a04b28fe84c703ba53dec20537c68e7ccaaa4ebd258077a35ce2cdf08acae937cac22587080eab31fc7d1ca7d4cb62493377d96adc727d0b8b3ae686b9332e22303eb19f90007c6f02953e6d54c6efda8430d8ba109d740b9bd17a0d2929b4d705207ad0e6fe8705ecc236b9093d6b5eb2123357be69a0a4201a838efe6e0de3337991615b84ade76e8c309f3f86bbef5aa5f949a7d83793605c1f3ebae133bc5d97b043908a7e2e264776639dae7bfc2febc4b24117071393b12a3808e77e70ca10829d533c4136a6c626a18b1880c658b3efeb1262a1e6def130b6f38dfa1fbcf0e0525a34a71e921494c5ba00fa804ec00c10e949091b934417a51516e02d089ef41778d2e6824ee1b600650af3414add08e4c2af5f00be2287534f9381467d7eb58d7c055143f40bc30f0cadcaedb45fc3b7a920100096550946627c492db2adbcaec3140f56b81b06db1dae28ef7257cc461e6b4492a42e1f2c1f4a8d63ed04353c33f261d6e81cf578e8df6a79950ca9468412dcbc0dc9ef0cb7baa39753378d3cd7aac50d522b2f0e4c179723e5ec0dfdbae436ff176bca4a5b603bffe19bf873b6acfc70eadcfd5563cb376a3a432f5b14c890fbcc729089b245a8e15a77c2c3c13103bbe8699bf47314c496783f64c81eaf0d229f1001ad6400ee241795457515dd72d35acefaa96157ee0c341a4f065aa987b970cb5ff39a58c663db596c5b58a520cbef333d0a6cdcc815b01acc2160c7c71f382946b390a51b03135621a564e8d13b93ad8a0b5d2e3f2a2a776c7033e1b195fc623131a4d477196f611760d5fb26c901561367a0bdca71ea262af6c4c08512218418ad4dcf969428c3876b3ce0ae1069a39e10344fd9abac90a0fc7d09d0f7e349cc0e1dcb9b735dde90724bc994bee5c375604e945a71b61c68e0249f2fe0b18b950f3bbaa00eec4996d99c61fac1a49cc1460144378725e4350bec329028f4751b658b4baa78226989fff6d38520c4930a0ab13c2fda8ac5eac998b08f08be9f6295a654747ffa03690e9c1fdddf2d36f2b7248c11e6b084b97608203ef5e6caca24c706db16634b543b94eea3ce17765af946f733b47566e98c2e825a3d4a0e97fe150cadd8ba60dc66f2426a7e88cef982a315f0713ab339294cd92c1902768e4d7414673e0a12b6343dc328b705b1a9ce975f6407e24a54b22d7fb433273531a6060980a03a69584cdf684052ee265bf408e84b2359a138064ed3f1ef9499a9b076cc8bbb9afee02299babd6934233d0537c55f29bad2189a48fd94a5a42f4dc0d78182ad2da3790e551b1a528577a1ae5a65dddea8d5fe7e341868019fb2a62609c24dd3c464ee4f1685981058f5515f06e34c7faab1e83c6bff02025c3c132acdd5b444af903841ae48d2aeca0ca55ba7c28874c623f5cd1c4ef01077c04fdbcc59c4f3c76db23996772fdf7f65450567197a3e97dcecfe7c91f78d51014190a8e1f9ab8ba88bfa20b436b225eb56ffd4a22b610a634fb7c030042cec95449176e63803d9d05a4b9eb657811a5c0ae4b9fcb8f89229c11dcfcd6baf790a6b5eae44b8c6cb16d67dd722448c3355ff31b71830488fb06cb56bfb30d09f952af315410bd6471edb5e8e352a2bbf011d5421765716642f3e2bab548b30cce0018b9f60d2270f7420758291a616285d36fb41dd8789d7be7cc764a5decdf3c5fcf3354e182d0f6f8d94e441456e6e4c14d00e51acb01e93b57b770d242023a1569d66c695c2fbc698faaf4354379f2ce393ab1d0368aa9b3d2072dfa6d11c7e9846143dad3b5c0a97b955dff7f43816ca16ac679482e68b06a69098caa2145cae2832ccffddeb372ae47dce263f29dd97ba25629f290bca6f24aa0c49c577761dbc0c4c1a290d8f58d02e5fe3c10cd9dc0bc8840636cba8968751c247e3d74f7d8c867f8dadd9573757966b2a987e6bcb3519049c4291863a1f10042631d576fc47847f833145a84b21946b715cd316996c8dcf820fd41a4b69d28f575acdec5620909f64566c18cd30c97a0f99dad6c96635353408b1740e3c035d566c54ef136c21b752966ffb92ad5447f1e56d79457950a8057186343ef797393f606aeda72dde82397816eb5db6d7e6b2c9fea2ae8d9e88981803a343060036c495117fc66cb44bfdcec2a7b81fdcecde9d09c385103177cdf10b995dc1118eea4c0336cb5a031966e30c2cda736f9b5fa1291e52b132147ccc11061e864dbbdeae2aef324d5889311d603c55494c54bead56861a18b1efb9352f68375d197167a0deb5b8970f6e2c875d0c8c2d92c6004050e1c36a512d8e31b1d1a1595fd84ad00c74e2cdc98075f0447380efd0493ed26b619b92d071d7495348b296770d5b78dd478e6e9e1e864210702e170ba3e9b500300136920689c887fc544815cc9f54f4aa3fed63544376198fc1bf22f3e63df343a225534e7044b73b114dc1d8141936891b150a63288b9a1f894701bd928b264e4671c6631b5d9b9c8b666fef933486fb96bcda924798ad3070268583ed57b2f52bbeebf4ae13411e54629427452a5b3942a332d5d65a9e05a150de756643d82935f2cc7348c3a6228355b8544000ffebee72eb84b106900f9260c848c4f259d8fb18ce050c0d50a822a874213ce7f2793f5f65a27c1be0d534e449c54a6e124afacedd0c0d308c6ca2da78fa66c8bcc8cc21d5b2850cbb6cb01db8ed98e81fc56f6f5cd12faa29912222267c5aeddd1dd7ef0fc01dde64f6c17bb36ee42dad7d91f7551da9b9be38bb218b80a1338860065a0cce1b6d912ff1dbdfd4f0e583343f4e052fcae7add317303ccbadf19f3239371af4da62c0c34e93c70aedaf250057d4ff9e2f8ae9dd39b2e69f96544414b1497c8701930c337847d6b6ec45cf70ee25cb8bb4fe7cb4a149657d09d72e63c1b389a531a6e9173c4d2c3ab7f6a2e745baab00bc9737a390501c3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
