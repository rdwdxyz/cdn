<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5bfcb17a487516c8ef5bd1d536a434429ceba5c7c7f0f9fbd7f5d8e367666b8165d3ad2f979f249d936c23dcaadc66607ce822998236b6331f7b7bf7967b71f242b50198a2331e8958e469c46a1d0ea99d6dcb7f87b3f18aac50598ff9f2e456ca3d27c881d93971c80415dd540a403cc4d58c1adb73d7a63b98fce05bfadea96d82c0281488a45aaa5a4f0f3ccec7f1491bf9dd3714ae721f381362f69960fbef3124f6dd1b29d16ec7f98a8629055faef11be29af57beed2d2bee403473fdafee7d487d35b76d2fed89171a5225a1b74d114e7ffcd2c2853395f556f5a53fdd60c4fb5b4cb3dc9ff2e1694562e029c4e0cbc854a7b42fe8693d163c5df88109216ae36c19defac4441efaba42cc8193a9a8376409cf60b0f143421743777c59a916b411dbd912c47a150ae053c13ad262a8937457d230537096b1917887d4b5a278e377035393645fb0e089d9c85ad6855b2bc36c26bc43ae94772f4a779d13d37e81fcba3053bf06ed2045f7d4f27b31d8d24c4085ffcbd7d1aa714f5920d36ebdb52d90ed6d676becf825409a3bb11c95c52217fb58ff7aed2cac61dcbd87d11bd0b5055ae286518fcc03bd190da00cbedfc2ae44d28a448d9345d6e54e766fdf7ca302b5afe0e35cdd359319ff303a0219b308ec746b3082382cc3989a66dc5f03771bcfa285c63adfb346bc7459cbe742ca7f526c272d34e33401fba82cb26649b54de355b419afaab16e2c6fe3d88d66bb074c0a182addc96964484bb594f5dadc668390eb7e776fbf9a6add2f6684c0ea4177d93b70ce9f33ffd733b1d64085a3461bc180b0c91e137ee5f742660dc66be6616a651f6d88b70bbf8deec96f4b34118fb2c0b61748796fb55f03b445345184879dea83a40966145d51152ce8b4bdc1f2a2266352713ca6e6abc68199117c600e888bcd4b3cb5774ca62844a7008c91511133ddb5e0fde8c002b134d3029b674099f276ec752789a4149ccc45eec34b90b27fec199e5699c3762e00c60b6baeb1006222f002330eec24d77049022c2a53088b25abf5398c765e025adb57ed5e72b8f72c9b594b642889f86ae97395dfefeab845ae3a35ed97f04cd5079fe76263f1eab441f5bc9baff5cf802908892af5f1eefbe5fb5a7fb988d8af83a00103033dd7bb4e8ebdfa79f32b4363e6ded6336a20d78751166fbbc1d04e9e9a82d64b481796ce94025631cd33efedc85c40190479ba923ffdb91109f5b8138740b1d132e007d9968436f97d8e81656c093c2f601af56fc0c1eee880ed31cdaa56f4c28aacb495bba5e792ae92c05df197db77e612883de5aa32171b4260bc908e8bb65759213032a10a5511a846c1a8d9f12f901cc354bab6237e0c930e7f4e94005aa58e5e0c54beb43888730d27ca713586942d6b07ff9307276dddf3eee70470464802bf62cf028cadc7b2192e23127e4b74c9e74f25e13b5561942b778b6e6cb33a6bdff8dda1d7b0004929108489b66716baa4eb34b7d56ce723341d225acc01ac7a3aabd0e42316d1998f05865ed1dd1383a4da8d41ff19457da0ae2a3c034122f625e69dc35f695eb6d155383dfab8ce03313ad43f433f47b54411aa42bef85ecb8e23db79d2f903d8d9be9949c9f53f95fc30f488c1178a7b0cda3abab3376df7af1c6f5c56aad4a253b81fa56aaf9e58ba1e075e40b5a1989f565915884c9dd638688a672dab38e2685afaf74be3905f9380a059edd83508971b8e38ee58adb54af113837d19b5a9b2b2ba7e7199e69a17d4715d668fc665209b229f6c81e6e6e17ea68f1ad1b9574c0ed662fa913c4cc3224c0a7a1902ba40fcb12f65164d9d6df8794655402306c2354a98b3e234ed19114dd618c3e0c366a928315ed007ef2c7782ff28459373e5db35d9691b1164598f3be3d7c5124be5b1576e57b6a0f3d24ab5d609b7264f93b7dc1dda2b054b671154df945e6ded311ec919068508b9d88177aeab167f1a10f45b9ece8f3b737a10f2c426acf527133b8f50b1913d2001f71f990cdad467be92303e8a154c750b8d1fdaef18eff89fa3ca30413a5f9146834c119c4d897278c43b0ba87fee4f2f8c817812f18eaed9b431b3d8460ec0642d48bac870da29c5fae4ae0b7ebcd30a9e12ddd1e4c127867cc82da91c6b65f97c227414b4928b00862348d5e0707b0f835109cd82795c59162ebd8cb026d2b87f57fafd2d49e2c8f329a231af8f80154e896b77125135a202593e71f3602f1774c4a1217b88542d4c9629b0016c11971d7a5a8faed0b28d469f7b4e55223bc3803f2042cdf155d94c7f50d75b52a3772baf5e5cc3c6717d0962f6abc4496ce87e8c6dfd20b39670eb688b7e5076dc8071a6cfa5a8f28ac0f22cc3faf6ab65a0f23a33a8e96b88d319a603ca1adfd13dc337b9508c96371bedc4849f5c79aab480cd0e97b11f3fd3cd18a91ca13e89d23c3a004d7b71b211b70a676377214cfb77820c13a0ff7633be320f096ce33028004deb0dbc2cefebc5eb0b1054b060df180081af9873f328c4dee801d0ddc715033d5b45a3c9ef3bf392b6f966ceedef0ed8748290bcb9c4ef86bb70264024afa12b2cb9f78e981ae54a04cf35d14058525307b0b3ed64e75b3d8d1c446269ad3e2fe1441909f924844dab8772c44c05559e1cdad8b5a63809bbb4e20f0d57ba8f6658ce414d9f4e240fbc90efc8f75b13ce0a1e1e3e0abf2539dc178124491ae77fd219d47e6aefbbfb1ceae7c662e1ae098bd9c4e007c5a271d1103cd8bf21a1f9f5e2ca01241c3d9e6b28d0c8bef2adebef014c1eb5ed5551cb33d1c2f3407abdd8c41193fbc1a9e14a25a647497ecf72e04295eaba7f0bf9d6e29b16033a9a1cfa04fa397db5a833875326b1128df16dd2460a052db1c57ad23dbbcc2c1b8f73281bc839b9408e7e565d1d26d2d2638ddf347f35759d8319e0ad60291e8a5ccb0874780f9b877ec8d46d82df540c13ce23aea1d32e3244a2fa0b3e1ed51557995ae66d2d22e4d18b1229c56d0eb246026630b636892b9d5638cb2566363a3b0ede956f3c2ba1d76910cba0ad5e94990a1fbfae3e28ef40396fc7dccc3389fcade228213259e51b5f28cfa88954938747253d58bb95529b459b551cf9ed984107211516c2390683813a5ffb8cc246e83d64293db16ea5e5fee71282042ea4fc5a8a77e09b172674376ade64ff95376f3eeab6006d43994c4ba08748e8081aad006bb3b89ce80599d485f8f778da85e41c070619d2e3d51ede6b24bcc56c0ad3361e423b00402ec77a151dda5c08ef2103f226918ce91775a83db75265fde6f9cd3dacc7a3cf37af44420274ab592f9ee452083fd908eab16f3d6f4522bc731f85f565b742f0b46e07db03edf0c5f7f9b9ba68b71f51385cf7ed5cad6d13694db60525153ba2fe15038f1a98333b94f42ede327e2f595505127abcfb9c7fb3c446fccd3629aae67693a47bc3900eb2e887399c4963d1352a7ee9d966e53242a16fa2ec868fd58277b66480aeac33d30a3ad5f028bdc3f59cb2462c1ff5dbb748937b72a4a357945723d4a5d80cd9488b9aa12dd4fc2ab884fdc45196e959274303dbd47bf10365db6da9993de5ac6b4fc5199bd1d401f049d0059f89e08e1383dcdedaf0b6ba80933ad7a1442fb644f9df2230de0edcb1f337630308645bb93a246f07ba5b7eb53f7115f138b7016f2c65e03b51f54a291b353b254374794d891523c39a11267c5193d73880305c7a68285ff30f85d06e84fc2203b72035509f94e7e1b7a4073e4e8bcbba787ac92376fbcd35d255088cb64fc4a1dc28bc2c3f9894a010f5dc08b96a28d537b824dbb3eb1f24347e925a9b858b43e539761c9d0f305a34ff6075cab1d654c24953146b2c3dba8881c1d04dbb08285a14ec330ce8878d6a864993e8a6353a0044c1789876e9fad00fbda08981366a9703a94a090ae328f797fbefa8077fea3fe06c05f6fe603ed4973f1818e559dc6236c72727250515dc5abc66a5889a30daf5de3d7051ff227b3eab41c695d491c736a9600a31b670cc0aed669268ac601469557dc70dd90a9d4174165dbb5077946400393a5ba34527cac68eae1b769f48ec590c727a2e65f0f6597b0c2c56e93107420c6a2df986b4292b604d8e08b542b911015ead65534186d7a63bf1a129585f3e6ad697b38dc73d8ec7175c86556d27ce8749ee9017427c5551542b128c89f56c34a596da7ae6cff27b8c4bcf540780fccfaff17d5bc145a2b539eb0ed06995a0f4a217b588ab5b072b240fe75f8b171795b00115252b632ad36215a08b788f0f8931df4f40d9006ef6613f092ef8d352abebd412d4e14b0f0a4e2d2c3c343b5caaf539054646cd90f9c6adc919ef8a26be4bc2eec3b24f97f7edba4dffcaf6759a73ad121d9ad049902a9d8cecbb69d34b83b0279f2b2da376a4556b0bcc5fae04c80347abd5f63e3f7b34b0dacfadb9413a4846c6deb8b5fcaeab7cc12f163cdafbd52d94a5a59aa89d5388e914748fe2e67e68db38ac940961d822468811eff63cdbe434dd8fd28efa1ac9f36aa5269bd0a665250395ac5eb30428c005cdb4b12d983bb49a912c291cf986eb355f0831ea303b8905b1c5de2ab08f01821424363f7ed69555b3d0b7cd1f5f133ec5ca43891e440fa0230dd6b814c0eb472967d99d8d6a884c58af95dbcd374924b57efb67356fa040bd8f813a5e14ee501eff1966633ba964757f35f543b9e44d3643b81749d5e05623d27a37ca9f6c617d9928e1730f7a8c9c7e4c42666a75d9b1c725bffc8e1d2b2eb0d3e71c95141e2986c8800aeed7a4deceeab2a4ffee753675e1c1ca26c917e42ce5a8b457062deb93928a6715397d4e6efd50a078e06da7d4bb6658c992580fa6d92408137ad2366c943ce4a24efc6516881db3245441ec479821d66d4b776bda1186c2076a7b617e76beff0f9572b753f5add967db95238b4c4d693131d48487b060b6b8d7a6f6305f51c70373f113190ca7e03ad35b1e0bf7a728633ced2fd57e7e45ac87e7bcb56edd13cd6578e89c2ee84e4770d9155d5a7271746bb42bd90850b9706fdf23fb7d119105c8acf013fce2a39cff918a0acf2c11befea6db649d5d1a24a3aac82586ba39f028aa9849e4c00dab67d82861036cdaa1685478cd25e382986225b601da15ff15463097de8b86c0bdd97ddadd85724d266d549498b97eee736da0df122429194e6356e2fb5db1517d8423e4217eb7b83d60c89bb6503656d043641cfc1a5a0b95f331898c2532d90512531951b26c96d3585d2e6595d409442994409eb7c9391d543e63578a77bbfb74a4f6846af2e1a4e9ffe6ad0d8c1e9433678c7488d55442cc1362bd35ed2cbb34f9c4dbe8fbb9736b2e5ce8267c007f94e8550ad27598a65c4c21cd9ef3a8e92755e5ab0bd559576afbec3368b0349b6c01e6800884ec5ebd095ae9de9288d3aab11f2d2d751c4c9ade33f25ae891d7811cb759ac318aae9edeff06be31b263c612ef5c728c1a8c12c445b859bb5ac957997d43147f933f7a3d41568c8c457702f74ad7de5eebad9c16ae8392a1e9b510919e2e01125857b1bb4f7f4b24c02cde6ee1d0ed8a0ffbb460b36a169e72df480c2f54375502cb5faee1b08858128e4c61ab0f9757e38af9bf292d1f9698fb46bb16d363a33b99af398f020f3104f00baabbf03cbcb7b2f831fec1d86e357df9524dd876135efb6b014db1c897a7fca60e00a85def097aaf011a81de6340b0b40ff5a571d42c918f733e8c896cfb1a5048b66ac9cbb9ce0aa7c7f60fda392f44327bea65d21c2fb1100a1c8b0e34956784c519829a1adf413d78bf5e5d73fd60af9de49ebd9fdb61b34091e8cfcd8b3c48ed9b6962caf460c1fd8275e6f2dca18fd94dab8ec867a617bf2e12b84fe3186fe2d35cd67ccf7a2041625500a6bd00dcfa237e5bf0fe5629aa4199894dae0a33daddbda65175c2f099d4e827a3801cf7042f95e5d12e633033c8382ed79d49fdfdab89431d95662a5fa044e1a5489df2aae4c98ead26035b3bdd793b6d0bcca27a653830ed641de201ba5f78535f2d74fc95a6e8cf8bcbddf9a07e1457f37280b10a235359b2896b0929dbb44bda07e84cca9ee3a2160627872bea4867abdca341a74efea58dc8094ac95cf8de84360b68d4e0e5e81445823c91108572744b5249805a8c14eab3b80f51eb7536c2244e66188cbf31617bed17adcb5d88a49d4d7cf824d525e208c8a89c49903b19e2845a6f7114a1f4044d6c2efefd714544f54d86e1ec2dd6c23b03022eea4024733b891f6939f6d17aec46a491e107be33467d8e21201b32fea3e4b853f24a8b501d8153663924ec8e0e1b9f786aa09d199c601302842a5c5e6adbd2bcfd18e7e0c15b022bbd5eda50b4be6dc4fe3a6a8dafca86067b70f336444794c94ac8b434edb233e1e580e5faf4dda5144b99fa5f3cfd9b35160f87d78efefb774d3f0e475cb37a5fb978e66f347333806b6e8cbbc29f2e62306fd21ba9b28891a06b6c32eb7cd8c8ec3c266f60c767b7860820c90646dbf9e0b179b9f6a657cca419c06d8f7c9c7e51fee220f0a584f1b2b3db793d06c98a6e772c904db7ac34ad1494d287a0f614f4ba745cbbae3cf6b0e1d5961a6646fab2bb30e58476e05e582c5bf65a339bcf9d6eeca479c14400bc20c2786ef240c1c3b065403ebb1d583b54ed6b4478fb8f547cf87222fdd4a34436f82bcec38ee45df1443a8777bd391730960cfa3eac6fdcc1b93076aafe247416621ab9322f8926788c8ea831f4b3845f448be3db23dc2758952e5cc67a48fc8510f7185fd8d76296f3d6f855a1b0a1487b49abcb70406925be7906dc5969cd9e321dae2f352f7462c6fcc2f4cf4e734ebe5f5505254c6b231c02a94fbc15c8adddb5cb3e4ed0df1ccd50cb5bda95c052930ae8b73d72b6f9d3e13eae78a3c596456a5668becf110489d45f6059bd13decc85063a74da9d3eb30695c74bfad6dd02296655023548627879b5fca3095519ef00b1039eddc18b6d66e9648d19835703ce1fd13abd9a61cd90d7c082e4c5e8443627871b2235a90353d50306d3e74817d7b5be19bad71580d842b85cd4281dcdbcc5b6ec8490bdf99e6e0b232b04b7ea16546866a1e401585034268a520fdc6a1c22ce6f4a008c5cb4c9eefdca4dae8856f86d9fb8579cfee8aa09da84d5aff6156a2b7a11c46ae193096d7331252110aeceda0af1128e5c6cd9d2c12f7300fbaef499243bacfab41259d9c7eadfabcb5fab6cc1b371ad4e09c1c374418505753a9face4740985032395f35f42baeeb251df08d13ee4f725f3afd7127912d28a4cc34c9a052e0fa1757435e3afa37b0e706ecadb17c1210230524aaa7eb9f92971858d905bf86bd8894f484fd44a341216ea8fec2f5505325a4c50e47f741fd0524ea332a287448baac9d8d9be0513b095edfd3b76597cd97e5bccc70aa8ac0f8eb053e5dfc19403b780f7320f9ebc6eebc5df7c01e7506e446e7784d2d65209854e7df869ac63f7c9ea3aef7093d7463a3c12ffcc19317b8dcffd9e51f210069a443d6965415e7e83798434121d869d258844a40e64d3b29312ca58fdfaed8bbf6fe7d3822e4494dd37b4d5ebf9f62013d20049aa35666fe3e2b35b52bcbaa5727b6f3aac91f6496f0716b808dfab55fa4d501027be995d60c4a3bcb46004bd59c2a4bffbf578c14a64e35b9577909c2a68b3492206c665f6a20c2b428be2222626a8e0d26910b1c1c5e84dadc500845b47bcec9af922a474da33ed5655ae0c5a41080bb2b885423df15aa6fb4f91af12c8d1a81590ece186cf46bae1274c6af50e64d9277b18c77acf3cbe6c0d4800c3dd5b42bef585ac3c4afbcdaaccd4bfc0af5f0e57ad6cc4c6ce82b22d0fed33eeb0c6bd85dea8b608f9e15d10917d6fc6ea2a267f39a0195eb7563ee0d303a8bff48fa76bd3b808ed0ac2f34acfa6fb80867a557b31520fe7d5feefbce6d5a360b1a5e2220f1da77d5a62b715075ee9673eb6ea9de37b6962a23851469d7dd4f3d542e82c6e9ff27f0bd011eb541349702b404e1773f3f62f9c2cd1f6aabd38c26a1d6878875b1e254d6217f0de4585af4784a9bb98b5329f21eedd16f042240116d83af3b06442fb9726f1731e3f1197a29d4a2eeeb08f05bbd7dae694b6783276270a93ae6d94dbc2d66d20f29f2fc5947928ed87e565261ee6ea78043b8e0341236cc54441a0e055f62baa4c75a55bc54b439d98a64a2f9c3d2d631c1525b0d2a1f29db52893c3f94c500ef2b1f8aca422aeb6a900be5bb83c664fff142d5f422d3423d4a8b1375954da880f8ca23b9cbf5c14ea98e1e14573763998babe5a49ae1e773462b372faf3480469e4aa4d9d77ece80b945fbd213bdad6c963e6f3f72c26059603963235237cf30e706cb01b34f1f1605b9a7643a65e04fa5c103c3970ea6944b4d72edf244c46ee6760e0b0506791fd9d312f21672495b919c1c0b04a02f3cfd89ab921494c65f824d7c11ab6c6d8c0acdf92eb6f31642e2024665d3cb40a2c8cb6f4a8dd1bd6bb3420587b58e24cf8a0effe33deebcaa29b77cb3b87d9b75be52dbce3f09539a209cf3de156bfa5df314c0e237c4c66c50949feaa78d7115bb9eac03cc47c1b95c265e69e1ece6dd4e8ca8063da0b7c4a80bd5d60df6487f6f7ca4eebc623d6de6613393f28c00632a17bc6d83999c8851e094f9f706cf688bbc67839b54a30aad5d44f039bd9ec05d5951c9e236baee5e6f23f6a39d61592dae1c0f67ebdff2899631aee5b063c3021fcbe4a2ddba3a90ab26dfc03efab57c4861b7ed34fceed2a00c745f0e9adf8916a43a23a0de175a1321cc4ff0875a211bb27c993656ca4860250d12290b86cd9d719aa04a4813a130e4e91928567dbaef2daa475ed846dfaa1f826be1da7e91b3fd7d440cc9860b4ef4e09a081930346a49e542c336eb69d9e2f20b39b8b65560ac3ea05989f9f91c30ee1bb90e82eb57f54c1fcd5bf0b1f8d59e68e3237866b46e4cd6c637687351ebff81b10ec6606f35d9640c34a2eda47bf5990224890cbd5cb5eabe15ba457807a699e4d0e9534560cbe2278bdf5e160a0faa0578dcb8e4164054397d32c7f765de1953ad13cc74776506cba501e08c52a9b0ef40700da0c0368ebbb8ff46d5c857ccfee9d83c61e16b1b3ad6d65e574721b4eae05d813ec61fa511e8d6691192684eb0b44cfadb7980db5178593977212c21a2708d796b05b8ba33325e7534571286d7e45ea33ca8a00accad20987a1f6534224f22cbd267425692d49b7dbcdde7b5fc745cf4a721e8db7c33e3b296747ce1ff9c352724b969d1576bda2b5864f92eeb6117510b238a68e2d638872e20a008cfb148ddfa3cf2399a67a77517cbbb7f9863b298633931b44b48f692a41aef95aeadf01919bcb16b62b94a7d773b38532cce274ad3fcf4e64be699b63e38b54506fd7e60623b8e0d528b4d2ef854215c5ce1836a44a45f208c4e7d028933f2c52f0960b2e15078e20861be95a566d04470a3534b6beac4c518f0d6218c511534232792f0224541aec8afa45b2545d8f8ebdc2eafc6d2435115808639683f27a6170a929041778149b0df8b9ded47516e0069e2a0710de25d330b252cadd5991ab6b8b63a5ffbabfb6691db85ad39b1ce86110f8bdcd237ec11662f3943f657723ede0c8820303489ef5092cac621dba1999b2d0dae718d54d78be1524c4c6ed2d8b022c6002b37d35fed915386532fa0b810fadfd092c0d039b05b87761850ef1d87ceb3762efe69022dc0b6cdc4fa3696a1383aff8b6abbf0274e9c03a692a9cce1a9c2ff910c5e0c19621e9f7e95f0dce634183bfd77118ba6a0bd71a892b79bed0e9cd10ccf3940f9469be56ffc4343b29a6b97ba8d87622557beffaa267cbe82eabd5967f7d6d544d286cf77cefd308898f029546fb9d8ce56fe1d38fd79338eab6b252addd97f1a825a0484e6b1b6128f43a083da843f2bd06461f1ae784e7061fd728b0bbcc6e5ae12dd67e020b2a220f7c786fbba3aa03336efed9958f75e6f4eef0a35f2a2ee396a1c546dd7bbab7545766c6b4480e598cdf3b90ed98f3fafb9c1b94afba960b914b936c4aaabcd9178c9c7b4b6b5e583118178b28c7df231f505010ae9dd9bc15e18fdb4673688be19ac75a53136c0adadc24755318f2c1768ac337b1e22cae1356062f0674ca84e7b0e9d027eeb03ae3ff8596ee925229301f23d83057da63d5fcaf270ab4a46d95419f697124cfef7d26461f3ab38d07e02aff26ed2713db1e2ef3fcdad14c4b8a4f93891a21e7f411c84b5b6932aeaae99b23e177c0974e7d1ac57ac6392250c45a4b4206d7f6cb8d998c873f8ed2029dff9c4181698c2944fd90c4a537fc35a3c681d059e97cccba5cf825739efd5db854a1176ac4e71ae5785f5ed8912c1c6c403a91b2e5a876d2a4d0392fcd801408f73ee8344680430cdd6637adec6321ffe6c3855f5f4cd1fe9a71e3f2f1b6743e10278314f45d646c94f25ac09171c99fef7e360f423fc133da2f53cdda3bac7744f1c9e691aaa6913e2eee48f900927c3627c634fc9c98d7dfce6f46f1309616ccf1b059f498b6478e2314bc1e3fbda0d55011a9b190ce9c9a0e757e8b93c338839a2a2f56a7270dc3181bdd833507a9f273d594e005be95f1077b6b43462cf0a27c37e5047048a80f3b1128784fa4e381f7489c8be52899a336b084992c31bd560494599c9cef0355a2861b353aaad001cafe654ec986beb999ac4d98d771351c8bb2d8f32466a928fd9215957cae7a65d317f0f538af3deb01972a94d313905f589aa4b0213ad7fee01f103cdc488087b33e0e6dd2e1ecb37dedadd82c7eb186103858fe8eebccabbf51747fa2af39e6bb276fea46c1f3dcbbd4867d7dc9b345366e2e098543f7c3f88ba3f4813c2518a71087e0fac004f9f2da8324f4e216af41939271f9e84dde56ac9837dae786e75a343901049fa760d5a7137a350edb5c2c9d7164abf6d2db3754803b5e0d87fee051da00bfb4d0673d3e50c80f4699912159164e893e026edf42cdf3ba1ce23f78de828fb7530554c687125f8bd1ef85acf1a16a88745c7750577aa19016e9a8d96eb9ae3dc8fb02f17b8f08c0cd08ccb6c491327e0ad55fa0b45f9069ee689523b51c93bd2f913ff23ce4d9ecf71d8c57fc40631c0542ee9308841c187e43579eecbd0d92e7cbe8761acdaced10f41279f9f035c9f74baf5c83955b81079b2d15da657934de485fb38beeee3f0f74064063fa7b7c405e3ad4139aba4623a0c4e568336e6ea4e823fabc1203dc321f3b2bdd8d1cf00e180a5ac8d39d746e5a225025eb16157134ccc0fd8d533bcdb3afc6a047d1f194375ca84e6d57dec761dd1a229f744b79f5f84869abaa8096dabfa34de8da3ee5e3708bb6ac6c2388d59b9189d281b3084f73fa0da8fe72c24dda8f5bc24d0222109e8391f5a07f7f0624e86cff992d45b51a1f1f488a2b410800cef254b5bbeafbc1ef264e0e172176b1ea7216c2430b3548978838a6876d178b00fa691a01bd5b40acb511b755a21b413b034dbb05b37fdca73b9c33342f19737a4e20a7b48634a8a5f64d3365cfe8057dbf567d6b4d4d4c5deaca02d9adf38bc3ba8805023c7bcb7d96ad3ba508834bdd4010c4e92ef1e4b38667fb7fc01b1bc2fe14f90c7cc7990a899ed35764b19a203147739f191a94160edc2b0cc7ff8a02123d07a86378afbc565891e3b4e21240f8418b279fe727a214980de6f0cc0c7b1f9fda2a928f25ebdc1f56371d2a7161e7369e20ef5d708f792c9ecf0f4532af29d4da6e49642bcf95d497bd44a06167b978430f2b205c1dcd83c014f214f85a2dc3e79e93179a66d99910db2b65c545d3d2fef907fac8f7379aadc73075d6601524ef3710388a45999e04bd4f14932fff00a18892ce141b8062f471cc13b531b7fe23cdb17dafb0eb4134a401d8e9114a4c9b46b2adeee637291d215df5bfd52769ee277e31d484e111c78d37fb384ae371bcaf72d42a20fe6fc5a47569a500f9a681704df5423f87f70c74e30bb4b7e8e731246ecaa831374a0d8f5af463e053e70432cf2e16a2e07162914ec97c92a1aeee90fe56f0b6d62c6ea055a5d2b60b8b688dce815d5a68033af945802d9b21a19594ef829b6d1e5c3055a309cd324b050bc0aaf7e02047fe931a0c4dc5ac15c530da83f139ecbfbe45612f016fa84ead6c1a5cac96abbe3482580ecebb8b75a155bc86c19d1d381d8640bc25a7d9de933929d67af900b727f6c88fd8549a7a76407c1183994426790f1ffc6694accb5a016f3783e69623aa8ed71e41242af40c0d4e14ab53d99e5035b77e975d7088ef72858724a646e766ed30a24c066d5483162bab4145712b2420b06b0bc17481d8e3ebd9aaec4ca83df73cb7f6956bd1e17cea605f20fd54f0bfb772817e5f0c9463bcaef92f2b1dd6cf13ddd6db8536113395d0b9a0bf6e0dc6208b3c68180af22ba82b9a416ec0fd8f275684431cfaad96704ff9c6d97608564c2223d1e03e4b626506b7439f14dfdc15a1c1a9af7dc6b41e676da89e00140979e98d4706655071cbbc4e6d55525c59388922f7079056932d7963cadfa079c78b9972a5d43ecf2c92438b5487044599702f940b41d28188ce61ae591a8652be02690dae77ec5a1bf4c333aea9d86287304f37d5fa4d45b29dad822dced221273716d6640764ec9bbeee61a4923dd950b6219e721c57597df5340f79627155ae5bc9cc891a79dfde0ceeaf8e8d97463682902dfce1824ade20e54027a25d617144628b04a73e2920f7e8d4ba047a17ba7dc59716e2182a957ee6d9ad2164043a1c786def7db3fd65ef29820f578f2e7bfa7a82be75a1a9ac4180cd54140b3969298ffd8dc993c07e62850d134621ab43bcff54f2aa2259d9c296105fd655bbbf7d5100e617da5eda1700888a104cd5e9323a0acc278300ecc94c06fcf8d03198a5d9e7b0c10cbb5bbb1d75761432a12534b0711d1c9bdfb6aaaa070f95018433c9fda14647050fe4fb357155f1a96c976a9435d7f4e716a96be08c47c6588be93d5702e2627f72dfb73fa3f2ab314ffa8c51219bdfcdbae24865732fd275a8cb74ee26e26f2c029c2470e090f69c3dd401e69fe260a4aef199b234da78f34141d33ef5920bc1dc0b75ac56354b4675b95677c173005be8882193086c10d2b7a7d2471512f1f86b58be59ca112c38c18722b4865ec7e539bc170877e435b119152b81efc8bf83d0e0e0ccce4969a0c9709d5348f6ca915d1326be7a6d23420e3aca85d4ef77e567be2f95e5350e33141b968ad3798562b7b5b9f5ef7647e96175b2c554453495302a21be623b7455a057e9f76c46e50ddc9eb168b663a2c99fe3202d878c64aa083779fc54c7fdb4b2692b500c38b272389128c52047917703b0e527a45dd3248fd3045e601e2870a32a745c4f75676c5bf07e5b5c46425321a6356782ac4ccd495ca0be20651fee5583db48c38e4cf86557a9feb7620a99594fd221f1c92aef65a3e3e891a3d11a4fe4c7e0389b749766997a62e3b4a9a0f9b23d5eaeeecdcf3e3fe34fd3ac6d8c8b232e2972fa0983b359035ca5e8461ae0dffdf14a6df4b5dac061c4e2a0e57ecbaeda1bd09dcacf9a01a45e4e254681f006f1bf025bb51081606aa61f19f06a9e24c1225ed71f7272de4f552affba54372a227079129c45fb31dbe8e68084bd9e8cccb79573a403aad3e297f7ef2baf27124ca321d88f4fcfdaaca439395b44163cdf4d4e5c7f10ddcec4847b5438486097710f0f2063063a3ffa0fc30c98f5033f5faf678163a5c49be85abd9202c60b4d7015815aa1b0c788f1936e78f0961b1b28d4bfa7a45ba343332969ea82cf95310d334af03e817f697cb221e7260e9d4d5e8ac6c5afccaf9aa3d7371dd98190094cb19ed99ba28843921e2c491e05cdff5cf61e1cd9361ef488628e9753ee8811cc0a0551009f85de73b76dd0d75ff4ee6a3c2c52aa838450ccda05b14567e1470285b0567cf90a7733bd3272007c7e20575da7caf9df55f409426deb4d2bff903d6f22bb15475848d1af46c27cecfcb6f80972d58a838b2d883911d449f36d4b40e134398800d8f6c16499a7d12c05cd0554dee49a20965575269fdc8b5101eb88cc6d0ac3fc9c8a9fb9c8248129f10a3701f74aaebb1006b559ee4d6259532d7ae7bb551cf40171d25e512a8d8d48da4bbaab17abf8601c90ee339e1153fd72aeee47ff752e08178a3875f15945d1d9d5a8922d3ff33e8244cc75f4115a425b8e57ffdc5843f4bfb61e9e8f7b979f08539cfec9a199905fb67786a824945b1729217384d3c365eb9c6030bffaf6c0b5dae17a279fafa7ef557c1d13fef5c389390d9c875e7425e3991394cf57724a7e8ae517c735fa0f09876e019e9f39251f9b79a90ccd8ae3cde59634542cb72b608ca03024cbba83f11f01a32ab1a7b6555ce041fdd8b0810726cc50b87f1e333c7e8923b085ed6d2e4c09a54b5fa82874ff0d4f5df8165fac7938a74cdcf37dff0e5aef2a9d34432c725433802b12f42960bad668dbf71ebd6fe06cff53385ac5ec45fad47f2cde4b709fb1104201203e512855b1bccb446191aae516c839a37e8378dbad6eb66c2f11aede1deca9ce823fda2d1d869228ec7cf803365e1b3b88a59c83db68fee25157e99a2c88cd5c9703fa3ede5c23b0604cbd389072d88a6a37c46e4b687fc5eb3bffc00b30782b721cae094e2e7d2d4c9bb43125db9e8a9ab0b810a1438f4051f6a6dbb36f10854d142fb52f99fad8c14a61ec9efeddd11f1588647a92c505a9842413e3bdb28ba429ac4f212105c18a9b3b9eb35ab43825ad819097a5990f2df2ddeee26f7c9ef881f72129c40e1c2ae58a82a6c86915a5ec6439e744d151629b63223be13b88f9150ee32b667335b87bf9327474b7beedaa0b57e7fc005d7b734acf537828eda8d0f0324f5be0728ace1cc3e833a9bb95cd61c77aebc9b990b3c05e14190f5f3a5a730ef279fd555515153488b3d2705607eaa97a1b7970c0301738f672a1fd580664d57fe3fa1012","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
