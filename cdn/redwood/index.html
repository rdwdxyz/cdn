<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c3d8eb66c29cdc28f66ec28fb092ce78fd03d7239e72e1743795acceed1b21e672c54434ccd2320afc553f1bbdd8006552a355d9865199b7c24d01c96f22bcf1b070a88de3769ce41cdd0463e5434329d9ce4e1f39840f304892734138f5949c0992cbdd9cbe7342c69394a5db1aa4a268414b373fd9e70ef47b2843c1c6de1472a1e73e7c48c3187daa8d0996acc1c856ec3b3dd2e67b55ce1f1bcac40b610574a52f4e17ffa9246c4893b23b2250d6eb426bb845d16fcbb469a7a0f1bfb08dfeceb0d0c4052526cf913e5994683709e4e0817ca84943347b81f83060f225305ac53baae5ffb99ea8ea15906af581081115b2108aca0689cfb92e717f635bc9ef5ef87c7acb8c1072f261f52eeb2b4592b17eabee461c93271ac6a125432bc02e8e79b704900ea7d85839bf30ae9e2e975fd4387b811d31dac1d7bfd48653abc348b2bede592e34a37cfb3e0c2a3700b62c463dc46a6a37fc595bf6414bf8248ad45d495eb805df4b0d6aac0ef8371ccf5e878507cf19b172d8f51fcfde2d59af951acb35d3e5954b58918b94cffd367ad757d0ae5701afe9b49f2c4bb06b3e299ffffa08eea42e92af5201143447af060f9f80ca28f2cbd1537a3fa6e2f712cb13f0a3f58d750eba147b5a3c46391c114393bfc47658ce3b4d0b2f8198ebf313d964056ba897fa57e0cee0913916ad1f7b3969d5f827cf9d0d61b356f9a1c4284fbb9554fd33a96431ecf8f91f59f715d2c8ca70453b37fbddd0f2d97ddfffb49e09a92bd064003e37ab27cc45a668809313936643fe9f9e20032e43b47adc425e7b72fcfbadf4502356ee712ed86ea508fde063006724408c9738adf6e977d58385fbb30b2c275da99bf24cb104dcac295544d2daddd3a2d568dd0b2fbe72ef51fd2330b455c0cf105ce841edde43b14ae8a44979b428d2e289dab099c1084906e25ccea263d37d8a6f7744500ecc5853d17e6a6043dea2a766f7365efc009486536d74f6a518a1118422dbe3d3eb82bcb2cc440dd4247adee874a1253a4fff5816d2234d6abfd50a8a9c9f1315499ba5cadbb2d3592fb99bad83f40da0316f9e2e653c4b13e15186cef90276b7cdd37118a91bc86f147d0b1c0e85397ab7037d2b7ebdeca2d3014c82d10a34ce88cf0910af09fd9af07e6376f6b4e785abc05feedcc3fc928ff580c22967d0f382e564006f987f5b2cd8d4d7584ad8a36bd9cd7860c455072a9c680249cd449b8190ebecb3caa3e1ea84e72f05da2d5cc3477e68182ce2d5ceebe9e585ce5ce474c8f1407c595e2516a553936eae26eb76c42b28d9b417a7efc828505fa367fb5a3c903bf5a990634bbf4785cd86972cfd4c249ccdd03e504b25384e617336cdb34fdcd371a2119e6026e0b353e5ab9f79b488b827fe552694d567dc3960129eb1e740f9c3d257fee46efcc13e875c1d4e1bd0c3d635df25bf1e2a8af1a6772d4dd04a79a5964c75162dac78dcd6eb9f30ac099138b941300370eb799e646b3c40beaa9bb50b93c3b6a5f328e0bda73521ae8d31adbe1d8070a4a28b7de1225f19ca3cf10ffa651975f7f79b50e9801ceccfc7fa093b3dfc209e3000bd933b33a50144a59625b541ab0b28408f290a465124e304f4dcc4e1e6713e9f7d2eb2aa20e9bb2f7b84bb973dc65613bf1f2f695546c59f06ca20f89203fa6cbed61cdf4744ba341eba3a0766078d2c052e26bda18da6d1501ea7d12adeca621ce6bbb7804e27fb811edf93b1020f1253125c077aa86fd5eb8750297751a3086732dabee85e5732529ab6ccd2b2b5c8f2a1debaa1f06f3f95924da96fdcc61f8f59eea65d32f1c8083c61a5764721d6e023eba1a870b5fe8ee33c45e6e691ed62a9e97a658613b643aa9a5aed288d01dbd9b95a3b6be3c9711f3cd5a444ed70e8aa34227d003023e148306006f424359694cc787472e83810e45386563781d14af4f9942ecbe267d96503cb3b06cedff141b321cdb456dc1a6e0b536fd95277ad3429fdf8421096d966a71be569ba38cb3a1d13d33198c2cc44c16d29133b035057e8c4fa076d7bf21a22b418e3f5acd5328c1ff619b5318c1e1262ab583e77476575be34e7b982ff1b419dca17713c7601c3576f6aa94c9669a2ee2e7d0fef7fbca31e174a72f850cf5b079d4ed50962899ad9ceaa291aeff017b6a3c3ef4af6f468ad7e4b965a87aa513560ab34d8908c083b489d45c087fd2d62d2aac76860880252589e4e1da84e7d3f19bec4a64ae223dea912f1151a700ca3944cf88abc26bb11e40852906c24385a11487504242ecbe3d770666e2bc7890814e98395f4647adcbdca0a59414130e2863a87588086bc6a2bee8b8c3afa4153adcc040de4512e74fa2b38140b1c1b3eb246aa695319d0c5465ca3a65ea40094a1c9572853e0860c317624f88776b269531026866b43101201b720901d60e93c406874d17844e0e8f3481dc451fdd2eaff8ebd10f5023fd2810f9910d94efd53490fc106cd72f2de8c582b95a525ff4784af6b48f1da8d3355276d89e9d0ea877db455af6a934aa8c76dbddc12228dca236e170839ce43ed4740aabe2346cc3dbef125d2fd8d0732619917fa64a09e4f447ff2966d2e047af94d674fa9562c85f3b0ea43a5060674102b6a8756e56356450b928b5f17c5cd7aaf00cfef6c127da2d8c877024824d77c5fbb0d501512c4bae6b69192ab45441a60e61dcc64138ba9b8809e734d4064c674804a42b2ec0ce3d89aa446a98576e3fb3a73856a8ac7e244b34649d9b0470390f07bfa0b1bdde517857a4646f034e5d281d84cbf971257b228bc3f5fa60d3882f2c7c6c939d0bc31e6d646212133703466489175fe276f3f039089d53cf3da717869bbafc0861b7b4a21aad67c48239eb94e79051adb4f17b217fc0e9ac37868589258614cf50b058ae8c0db18f7e9bd9b469113ddd59b2dfcdde9095b26035365a1f068acf9ae314d4b45d965fd96c10502cf3729d42a04cdc5e7a79bd664e874db914ab95bde3aa8692a751e5a673d69fd10958b9fdeb2ccae2c819b3b18179e447597d1132167dae344a59b56542b469f0a30f70ecc6a70bcc2ad01d3be82933d5cf5d513c52c6c29cab760ae2db86a2f39d52782e6131fb0684284ec28c5cb615ea2cafb0e17fe7cd46927b15132cb3d51d5cc30afcba5f0c6b0bbb12a027903eb68ffa5f2622b00bb93696b14dc9993ada1d001682bba9d92d456096609e5565953c960a0a984f7ae00d5a16df6ae8e04c1982254947940d218ef37482642ba8e9659cf7e550e6043dc7953ed7c03d494a369af85e67742c8b355d4eee5305a451d23d00ec8321e1ab75cb75f958135ffa9c31eeeeacfff5cc0b978566e9fbf4a2adbfa2eb6f9cd6f73a7059a527216ca67e85f1d1d4087ea196d117cdcfc2e25bc8f757b6f3efbd0e9537b005723bcb10702438fde85443080b75389f3a479ff7dfdbb01ec5d42afda04786e909881fab690624ca27557fee55441d65ff61cdb1bed63ec55d719ce930f9ac6f80e6ed730594458bdb7433c637737aa32fc3a6ade1ef807f09b7ba4714347c926fc92915f53af230771ab048f0dd0182dbeea96a4e001590e14466bfb66ce5d92957a289e249df2b52961ae47f0fb9708453c86bd3e5be575c60706c189861048bf7a4cf22a5d9ffbfefd870364211f6ea6eb84832f99fbebbac1c237452c1384a5ce2893c86f841f20427dbb15976e3e6e4bc7280d33a01d9f78de05ffbbd75d7b69fbe569b8b27a5ca72c530948d821cc095f1bfd4802215e19d4a2398b09352a89e29755e00c5a7f23656cfd06636952461d68d85031d1e9e111e4c0f5c74f5b869d5b02bebf9f41b685b111687fe6e69f3bd9aa32490e9f03a55b82124068f6581c75f765af0824e5bbd63aaa977d61ec36d67651cb92bbc07a4dcc76a6b8ac0e81f7377780fa04711a9062cb08051355c94fa5e1ba4de6665e0729cfc1f0ffdf0d60a4af9e42132bcffdf6319a06b7845f35f8b0d6e985801c6a1d6d3af50113beb0caa0eaaa04751b8aa596a638a29a8872f30f670625fd9f362fb451769ee5c4c4c4da4737017c8da05edbfe68200ef5bed64b2c94b5606b78cb7d0c11c8874f5d55bc54d909d3392c14d8e4fc319d81ed5bd797ca9ec7cd3dd1b00040417de506ca2e5568d17a7bd279b6a5aece14c1c2fe60b6c7ae661bd32356d192b025c48e3156eba7b933ec5d678d76791a36db74e358fda8bf0bf356e8430891bec66e481b6bb3c9b03ce02eb088161193877d77475048d09fb8f975c625e1f90575b42108cd33e2c29b03d2c876944822c1d1ef82bbcffc73d230fc5385d0eee36467b509dc81a02e1eb873f03069fd71e36983ed27af148ca3a217db51bfe9d6c10798318a2afa393f7a8db0c9479e45113d2f75133609fd0e722054f8bc2ece1ec0429d6534393534ba6cca2ac4374bed6ddaf0e2368619e9187e0899d0860aba88f6b1259a537685a748febc9a968cfd06e8f23bb87fe6332af17865f7e6495ae79ffe0ed559311114030878c096212282883c5980240addb65933fd478b248cf2a4c859f9216406ac00d3e798ad768ff75e7805ee160608f3d2f63bdbfbdf65385ae26ac87ba335187cd80a9641e54a676342b58c4de33d6ed6ec1028cfeccb5e6c21201eaa93ca88f8c2e54f17d078bec4b1ab27a58e5e112cafee928d9be36915e3e280fd68507bb129d336b017faa29d12bd535d466e308550942706221000259fa08204b8ceb54b48099ac6dd845d16ca57b0a08674023a905a06b51e27c82f132493ae7e31e7da93af7cae474d88a91cd99b6bb7806b8b440fc48ee266c7e55755a5049d02687efc279a75fd0410fe846ed39b05e6b8286f2dc4a5bf3ad0a9532b7ab4b7e2ccc79074eb28a9325bacebe4a507d413dee42b796ea9888befa49ca71c2b51e4454f6d1294518b8a6c208dc4590970f3f789ddedbf08538aa2e4846e08c62cc238419cb092e611cae1e0133ae33fe9b87f7f70a578321b574b539bd4eeb7b2374b4efbb3379c4c302b8b7dcb20edca4aa8c500d9703223ad9b6df762282480727cad22cb475c9686cffbfb9eddb666f949cfb95e5e43ec88ff080e62d4e199f6f3a49dbd9c16b4114234541af1b1fb4bc1b31cd86276020ae5cdb168b14fcadefd1c1a8810192cde6b5743d3644493c38e46d4fc07ee1b900693eed49a936a6a40cff8c506109471021d5b3c0f09daf2f3f702b59af7bd1c88dec297723d6728de8abda1f6c60d70487ecfd5a10f538676f0a2cafd179b4a2c7cab62b113d5c5a7027cd568edc4df43fecfa4f26f443d207753ed4d86cbdec1c80150617e57246ce20e0f7d6f993a335562c16c37c8a122553533790182b4f8f4d68306b8b576bb85a39c4144ec2306c0694b1283194a7a2de1e06c79891e69cc93f3a4f2729fc5ad6ab63aa7eae735c52e1d9e358fb1d31019b55edddf332c6ea1968142a8023422dce2ce4bb91264eee96d5b586ad5fd450225bf216ab509f386bffd8a9729cab29ee7af747a2655fac35652bfad620d1833d20b55af4c5fa0c7b3dd3ee69e456aaebcc4799744dad0b03d8d6778a9aed4c26f9e400c36dea2f6a3afd6495f559d939c680235c243451412f4d5fe7efa57c0fd1ca34392dd864693abb076f1ea1c176264666a98ea5b9f2ba3ee04856e403c98dece462f18064e5f67a022978342e9e3ec5aee754d090fde35a9dbac723f0156a631deee4557d9f501cb5cc34b0b8dda396c66b1ce4a78642c6100b860153eed04272e5718ff8f58520b37dc87f903cf6c229caaad55e32792af86432dabc45c88058c7c5de76c895f06ca4a02f7151ab5807c826c491a4576223850b9fc3699af6aecb473dcc0241c1f63f743acdbe28637948062c6b688e30d81eec4f5c723540b6d8ec37c401f2918e57fd0931786bd11121effc735c3a682263dc5d9fb787b8e91474f2a704495775a63161d01459d673189e70888d3a3ec4dce97eb4d979e2f1009e9988eaebc2190816faed9d7ab92692eae7680ad9d14b8364361f1e71362fa3adac7f316c4bebde947771e6527ab4789631cedd37f6cbc1364f935b88b6a0e9183334099939a0aa64e813f181492ea86e69c56664ddbe6aaf161d9a474b18f5b03ac0be6f95b71c8eb724fbfa129ca83e70ca02100dd3a875fcc4231c4d0f63c1e00ca2ee3220d2d3626e1f6ad130a3dd4e3d7559a2ed403e46165ae9d1277606257e6751706f0fba1e20a879ac8db14dfe5d5a998013a02572a76745a6be21cb1387f9051dfdd314d6ed7cdfa83c60ce78e4a6a282093c093203a54debdc3540139cf14795c6f7bc5310c1f80a444115b998aaf8ace2c20b78a332f96e479b148967a146c021c94fc3384f0d7dec789da27a1edf52f494172efe2f738d802f42bedf49b9750917ac4843def0ed977c6e0edb7d4031778fcf8c068de0465a34f7950792077dde279c4f5d1c8e3d6b8c328c4524be74d062b9426e8dbd18ede6c63923e0f317d887656d2e0445d59930d80bd2b09a9316d1ad806510f9146fba4c0519dff0d5805b8bec9fc24fa9ce34fc7d097eec0413f4dac8c62ac46cd471d1f3b33fa6a919967c565faea2b95cc4c89c50d610b1fc80fd826fa3a3a684a198c760e71a9f5ffea12eb82007de6e9e61852e2af7ea324430751a04fbd58b8e275d153fe585d65677b6ebe77bd328e1048944d94727ad09992962b10236844afaab5909a03968603c502c6fa6d6bc760220979e0391bfa6381eecb6b99cb9401d9dc4e067c598948e84a65f5acb318bd22a0e5d1987ccb2ab4562202134665432d3def9f9e2ce004918cbbd8432f3bc845d44823b6149cdf0d5a481a339a272524781f29cafccb346a28cc7bdf5251fe5fe674d1e8e30a1b3fd14f9d6a813f96cbc0054c9db49244eaa6f6ed32421c82610c5e35963a11799b08f5e4954108beb723cb72cc918a7992b7c4779030a060bdebc54b43d4c55a3b69b6b077056b0b0c7e8624c613713fafea607684c55fdb7a34d69a16eca43700870e5da77cdfbb525614c531180676df4211c612e52f287b45f605cf51aa9f091364de42255573bbd7e5b9d39546fc5551a854d160094b7b01f8705c3a2fa3aac4edffe2fe35ac904a087a8e1fa2284158f41c6931729769d08c54ab0973b464e90abff0861e46301b25746d1e01e000fe912151c452dc17bb1c4ad37a0cdd456c1d605316af48efd7c585a1009ea0be70e9d387029f3d5f710a7dc8bd7f3c61ea07b07df302e7113d260dce94287af219f185fcb56b5f5cacde3f9719de26c60a39bb3bf2d2472387ab7e9e935e2570527cd42cac22f28fa10ab45a89c6aa3ca9c5fac359005e81579e549fa708a7cd949529194bc4d89e6ee7519d322c2c883c244f9597a45d64fbd6b6efebbb2c0f1b60b8da856a3ca75da2a7f7391eb441a1e9bf54954202f4462e22fbbe855f491f197e19d394c04f6da5824a0227ddba37971963e64bbf1e18387c7aa131bc9413fd6242309216c1675d97ff835b7fab7f13b738b442fde691c923b1c2b9dea9e34c8b7ecde9a9e2b880a09c67424d0c41062d708c38a993fa3f54c51d5db8c1bcd68833f3bbf292b61cdeca574c5c88812a7d2078dc74330eb7995d43a14c0c3c483a8b8ba740537e5d80105f3d07e8ec2850d287b0fde27bfb70218806c7f2786859bb8d9f88a4411a355846d8290687b8aa07b1f728508297d03b10ffed4fabad817c547f2f2fa853178b41c52061ab3337bc2787ca2aa29b3ce516f8a3357719b66c157907e15c37104984e338e3b0ea7dc61a2955b73276512e728f8d633f9ee64dcca239642542ee89d872b3b43b9bc32cd4baca7442cbfb0613684b7b7c9ff151bd01956322dfbbbef562bf74327b80ace9b469c2dbc0783ee2a107e0861e2aed00a10074675151ba51e072376d22cb12a16f7541c3680d85f5fcdca6b85e56fcccc53a63bd34fea40dfc69350df0a4b7620321724a68b5874437053bebc9ff13fd494ef4cfc31028abd83f7c907d328633a7b9c09d6ebdb897772d288022a26b39797fe14c7213d67a79be66250f784594780884a271a49e51f1a503c208c62b7b33f47c43ac25a717750bf18478f8aa8f1b316dde6819621917085ecf3cb9b7e26664422f1524f4657669177392aad7ca805b38d831b6cdff14ae373a411e899afb46cfb13fd2bebcb52da7d63003d92437c5f2583d0ce882a07821d2294e5cdd448af11587fc8064eebd8583d066f0b4b9ef2e6a91fc8f3130e6b264fb6fedc2d8a00950944355467f04782182914138a830f581b5fdb6f69a8ee0e11685e637ecaa5a77f3df88b2f62e90b974ce3d276ae07fbb593060affbc639bf921afdc4041e87073f06012a503873d3b013038da971f03b35a8d7d21f9c95a45396bc2040799bd085a1c53590405825d8ee7f33e8012848ef6a03ddcbf76149d032ab3ff08fbf2bb2702cf259923c1b67a82a128666924c64cf7b72b359ab0a1364afc0f9fb50fcb0ececfa4fe8de4dc1d93c298a3b8bcfa671da55b7117be99904a663e422ee24b5e2606088fa027fde08c7c309386a632bda907e369c602bbca2613069285256f4487e5dfc9e37f475faa5739e19c67b5c85cac40297e808c5f6b1aa068142f6400e1fccbddb7335c808620766d6776e08f3663ec006d9f3133e81a62a442f65fe059ae82a6d32f15e1aef13d9fb2b68d7086f52255164f18ce0a53d4467145ceadc168bfc833e469f565c60dd8cc31b7d1f86ba445512cab33f33343ab5deacec2329fd3ae483cfe1e4bb03265b6cfd61e11a4ab5986cb85d698cb1e20cd83c67c215acd4c0ae46847579c8874744a0e81f16f31ab44d139ff76e9e016a194539b77337de798157bbf73a835d7582ea80e3fa0a9fae972311113fceb4490fc9d11ccb12c78d5a12208ff6bb16b9ca60fccef2633dfa54251a7978b5d97f163519ddcd0b975b65a8e4c706e7c0d06374de66762bcd08b0b7f176c2bc955d1c3dfd0dc289dd88df98cd94223523d98c827331fbc59f6bf0e0611c53609dda4c18a254aa7578ee8a1604990057cc4b3cdc53bc255fa11994415a9d20836613321647361b4a488ce53d87d3c3e13a9195a3ead957dc3dd8ecd69d459aa776f6557699956d9348511d656444b3f5611da0bbf5749614e59c24abcf62e9887422a1f65967b3ae7423a77d74b3a569f7555eaf93536c3808a1462a4e566484d1110a25f0787da301f621ecee50831847b7662344a79a65ca0a102ba0853a465412f39f5692508e53058c52df96e4ea6b3f0b4cc10991e937719aeed0458fda2ed14dbaa606503f04e9389b7fb396195f6ee2e670b96ffd2e680ec288043744ad09969cece9194abae12d651cc213c98c0d16ab5fe694c7efddf3bd15939e7be7dde3a0088b3e525826b3f5ec93ead65e3a97a830c0d8b3d64f519011191080ca6306a4fd520f7b84c8bb1cf56473b348e3061da7e74f5c50428b96fd36fb86790a075b363dbe325f9458ed5e7cec057a912ab41e2423a5ccf170f7848d3d027af4b1d2adb5a2500a5a0e631c43611b8ac5b6d819b389fc886d83dbf2cb66e03f32c0e0d1d43fc3a83d79bc6a8d0ed4cb90e749b249a72850c48d980a61c5bc81981f682dfc11c16fda049a57d108bd772a1bbac49259f759531548e45798b508a39b5c1cc9798eb609029f1c98f2d7630ce364dd7645a26235997678cf92de34ad2a531bbb2c9deef7dea5a0083fa5dc506a21ea069c07d328bc0f3319c7c88a66368dcd6224f6b9cbda584e8785d24269731d328048f02e6fda4c69e50a72f605fa5878f766b6d6ef2ad35720c6ae59912c79f2dd3bc3f78aa3b8bee2e92519cd3331e545273dce78fd287423b2f979b42e2061c864e1a3041c0466f46ad03f003e5820a18cdc1d129be4f4c7f2fb7d545ee828afb59d18ec973f3ec26abb29a7858fa885f92ee766560a5e98decf10388c671aff9cc29cb0f9a49e68410a3ebca84da0b093ceb894dcf2909cb2839decce30b569fa306f84a478d4bce6b12fa275f6caeb84dd2d302e619dd65c35d1b8ec7fc7c8ecfe8838e21ac67a4b37a2033e57b073d105bee4e30c90d4de2e849abf43db256f7a7a79bbe7421413238b38352746cd7cb6f469463f94180483ead5ceafbe50da0562abee738193a6e6aff19689b81a3a8c0e92e27566fde4bdec2ab726b00d0d409079a861bb79f42d31b548620e478eb399487f3b2f2ff1feb5667ef8cbe188881a6f595d3562d6801df928ab97db184552b488ce111efc9ebd2252b0c529e0ca7eec1c0d00fb6dabbdf8e891ac8eaad9c87b4c918c455341de9e2735977b189484e2d6ad117b0ad9abb69079db41d5abcf07aeca1bf73d6a87173fa6e7b7dbebf2506b570869fa885fab9a741ecf53a62e13e78200ba86076dede9268112934b6a79d063dbb4d78506eeb7269df875c1f7952b219f7862732c48726f7937d719c90912f1fc86f3a53e2700f221c850608775981fc814f617962d1f1778a4e66335480c00f97ee2dabf9a7d80e45b0f41d114fc3d3be609454f75fca13da91e014853b837f2ac3eb266da2c5d3563812e585347ef3f9990ffa9f51e6e9f305acb26269b9879ac014777d1a6295c1063a42196f4c9e824cc61cf25410c67280955e53b92c12c0eed0d2df3ec2cf8d471f2be1527cd2dd5e565f49b90b527ee2d47cbffdf5e3c080f892c5ec3c573e96f248db8b28838f704b5a539539d90ea385c303cb9e98a5e5ddf716815822ea5ee108175018936eae0eff1b99de86eedbaae56eaa68af789c6ba44ce19c40c4f01ed0f3515e47b6450390dd0d0dabbcfed2c5099ec8bb84b79d5dd8b739190f997401c55e70afbac10eea1302203945f99028b9be4b43158f41aa88b4af4847ce9d3c27bbef0826a20131671146f2fda921769dab87fb09d8516e2f22de38b85e26de6a0f1a371431b921a88845aff4523ff5cd943b2ee3facad6a54290eb87a2668cd7b41e97e8913718cfccda50058c86372366cd4652ba55928b436ae0cda07970f2432ac3b610415951ede08cb4ab14de15f7e519c90297d32235e725261434c8e205053ec9fc786a8ab0738902166c774d854a98e93e0fdfe6bf98ddc6272de7219f791c300b6402e5c716a3727839f6bb54eb6c26d4e0bd454db2aad0b842f9837bf24d2b22e8b3efeeb00e839d090111fadb6c0f756e040e406f5aa8d66fd5af768490cf1a3e0d1daff0a6763bff2d09809d54d05a7facb91b266109c9ad9ab01db1c203c25a3af67a72ea5167976c4149985567891e4ccf0b58b13fd1c16d332e0d2cd51a245d8fb5ac12cb104cfdaed921558d90ed1b16889bb9f687a088a8561cf989cee161c1343d03964b4123a53f080b1de3d161f3a5cdf24431affe53b4dcae60a15fc1ea97e63bbe8f06933e36a21a9dfa9071711ba6b867883eb558a84b59d5f12b2edbae88320619cb492098e9ecf329240530bdd9778c4bd36c3bce3b4186233f997a5d50703edd7063275d9df2191c4761d3f16cf5de43f5d2c896a9e6610a43828d5ad1c5664d5aaea7640c76d532ccbdddc9c933e96c38c396b236460ef9257d8d5a5514f25837a92b76f82dd9c52928d272064cb3616055fe006974095d2c81b0a98487e72c47283a31c546fb47425ea7cddf6682526dec3a2217e6ebabde1f4ca61b4daf035efc44988a52f2e90a084f416f1d58a412baada0249d6080e0ed6d4a787adc830c211b1e9630a10fceaabed47a4aa609f300d98d4b4d158ae2ac75c2b7535d92a62f8ff766efeada090d5f2790f3922c37db941ee08006d8b90eb7d46615139980601b4c5e5f66c650b06cbd6776938b5623fe0ffb389af5b3979636e1c946b7af522618cdd3f7f6d387023d11991ad2e9b2371315be9dac0fc0660a027be2418b5b75a7fcef1ffe1ac72446e93def577f4ae958ac6071a6fee3724e08ba099b86818d1080f3417aaf882f1af335b9e9140a94bef7ba0a534b619663e43be6e6da40c93a4a587d1d7a723b52c0a38d3f77234ce971cf9d1983de1d6cd550a410314e3f1f5d579ec37f17d3a769fc99c4609da456995b3c30980e4a2a4ceb3337d1a6b23a49cfe0d2db36455fbf34a7c6158f4380c96ac5582041066fb5b7969f7dc3f09d8c3619485fcb3f429fdca3f3362f3358b08b7fc7ca1987ef733a078e6b62f018e791495abcd566e53b7a840042f8938e3a34be0e0d6bf9afacac49658f8873d7cdaf2d4ba9b99b1a1bca7aede90924f9d237a9d6f0b3368fdc3c696011f5b30ea5888273683561010d815196fb7b5a8eae7243459fe193672f52da515d5798487c005e524b415ec41d3d559d34c7f51b0179a5afc21daa4acf9fc3e5546c585eb969f8842217455191d85eafa2eccd9d26839b3cf41181be22216c3537c6d6d2ff52378e7b954e3d2f23927fb57b6af9de86f03ac0b64795aab36b1a2de141bf93b052427c8cc98b9c45c8935f5393bcfded8f78452943fb1e78e6d94b1b1295be068ec4f29f7d2390d980417fc76a156816aa69f2b0526bb12fa5a224ee3d0f752f8276a31e6468f0af89f30fa80e2489c59bc2e6603064d8861fdda478ed226de048584f2b5be766ebac2930d2de8ae3d380625cc15c04876bc84a9308ac5993bcf0ccd577e34fa11de468fd93a020bc71b5b15cf65e6e31eb2b574b9a8edd75175d1f5ad09dc1a003668fafc5a2385506733916b8db27680fa823eb5efde8179e0f1963bdc95ab09f456c7e3c62598ac01384ec863e0a64073b265f4fd369f4c42a0fee2c160d940f284965baf4b078ef62be01c60290eb8c6a258d2017b5866ff883036caf507aeba7b8063d6a9599d80a25738c6d8d6b1d89d3770afdd09dbb0ab609c422c217e80e7775f81eab8f406817b1e752e6188af86e9ea4c5db23be805517fe506e6385b1c4604fb672bb39ad5dd555ed594c7696dfc3439735743ac7e92528876f5033f71a2b5a438554c397203b0419155baba64fb65afd17c488c9299a57ebd4d64b6ca9e8f56dc85c09a24692ab627d138f2cf2f752af95c29a8365bf47bd8edacb088087bab8e692fe108d73ac8cefc7270d136e90326f1b30b20b93e6d7f41c2aea341ecfdb4704bd6d7ab8abbeaa50eb9c9c1f8e766e764c56cf1e6ce546ed9b9c4970bb4bab7728ffa85b365768329fb6eb0b16005f7a35bb11bbd3e63d3cca8a19a981942c945f8dd6b4716be728674a5f2ce0c47da7498dd481e8211c8c9b6550e9d68cf8f98cbe4a0264847e7f8e83db99c5868e05a8e2bef46039ea097cba823630b2c7f9605a31c807d7e378f9f9216c0e6c1b072313a58702292379bb2cf70805c8cafa296039a7c59734a6c459a4e0488ac06e950c6115caeffa6a8ad172d013fe09d55828828c7047f654d2d4720a347d8c101cef561539c8f25fbfada0fa53afbca3d15b92b86ec734c41e19b8ce158d297ba958101358b322dbe6bffde30f24f85ed2eac638b6a3d6f423613ff427634bf2d3e5e1cfb72590f8c8069b207c6eb651081b9851b67fba2d83d91aaa6cee00cbaedf7e9f8e94e605bc17ef6ca3a7b4c84d4424ed872b2fb9884eef65e2365db5e3b7772e220600efafb74840044e9e599da68c367852e00623d95b8eb72ab6c036e14821dfa5d3a8ae8b0e063ca1a4e370dd8a7238e4de8c8db972a2e9cf5ad7ebeadd1cac6a38e23d6ad40b5211dc38434ebf2cd3f3a2597120d1853f7f09e597be0bd8d85d5907c81e6edaf38b759f9d2d2a193e22dcfb3f5ca6a66c37844f2f6391fc652c5ec5bd7408c606e2498b52233234e26427a097c9abf1c91319fd0f79331c1730139e57b8d0032b2b4c76f2a6b76e763baddac0d1cc2446857803ee3d97feea62026c5c6389e6115f4ebb4e9991972576fe93e6b444629221358a17efe7b5dfb7005e45033ada0396083874f30ed9c519a619e9d6d8640f36c1ce2ac2efce910b73793595bb6781203e4357c56e3e351c3f0eba82f036c90276bbddac2cb1a9a007f1f378acc004ecbf89741685e75e2609002d993c13a17360a9e96483edb3942bdecc6dcff1bc25dd1a8de46864c47f1bd7522581375b78d1db97df08b6a17015c2e7b39cd2ebf5e6a2b7ce006e2809c6ffebc69a329a08be6e52034f7176ccd945649c518bf05e2fb815d2d754201f148be61e3a73a3510f50ef690c3e371b1369b4bf1303e93d012568559d0206a4aec0e24857a9148611bdbf38b677ec4c64632a2b105f15cf431fae35480c45de227196be25c45ef6cf64a9b133963aefadbbeb94d6696ac01c42b187b0f204e5547963f373dea5a182156cafba755c1686af8a8601c911cd213990950039b8ad0bf6ca1af15fc55c8ffbbdb3e950eb0ad8799fd09f03fd5632ab8ebf44214f039d7ab73566e0fc6d994c663f2b655b25b1d880129940eea941a3cffef9b7050325265529dcf5e81212ac4a267819938b9f13b7cd31e84ac2c925b51defda30622ed770550adb68088a207fd6e7b8dd769e5c8bfa8fa064d893ff0b84f21489325f7a3ba7efd6ea77e1a2734bd2d42e13d389ed2f8a29b38d4feda649e917700aaf914a4ade868cb5ddd9da7ce7bcb0d65b8a1e556736b7763b09caed2ba52a320ea147406c223d0eedc5dc9abd7f781cb4dc5b3de7057f6f03753bf935d8263f84cdf97cf7a115c9fdec0a501a12c23ca5be82c4071b408c1fc38e3b1da3ea33e9ffe0354dd13b4132774a6dca7f29d12f658addf31e098b17c0aa4967520644272a1e6b25d475238f4fda8382da502c311cf9b07a1211fb285e4d98ae48c5ae449e89f1eebba092c7e1c009f7bdce4ee8a804d18c7dd6798da5bf870eceaa58caeadf76f419452597af62244413746dd9172b5ca08246c4dc2b13ed479d8555e73b94dde8c41dfc1e53527b7342e70553f41ccf18cb3406714e50f18bdb23e9bd164a17763e060d587f7751d8da26ad18bca203dfeb5a4d283fc4c8cb0c6fb66b377715353a72f00906c03244d86624d404c68106120cd1c6d28c59d0fa5adcffca4c15f2313217a59188e2912662cdc6d2ce80dfed5efb502b74f078430f5305699ad30815412da1b9cbce7b86e33f1291b689fa15a2036fa16c76487026d54f196de4aca5db3f5fe5227c62b5b58f5ff9ec096d4e2fde49ab7f297730c6f19c426b44ef8f7e5b8858b1a88a93cdbe5c64591e421e770c8e912f1a5879013317357b21f348c8ba43d396a8abcfe407fb81a9d061b92bdbbbabb4d1e12311717b6733a54e7564d843852455bda644b73ff2ef4c03427725575e8d8d5fb8ab5b8c5407c3b2f057b966d0b141ba62ee94e3409aedc3e711f2de3af4179537ae0cd9e3695a0fe14451411a174e727af32b42ef7f0cc57dfc444a7a853a43e39b1f122e0b6128de6322a2a34497d05116e68d4be5c908df2d06d9be851a3bd0e3811ecb0460590f55942660236134c0dd9a392f4dde96957fbf5b69e5d32eaffe54231d226f80e89b9546de6b771f744ae41c998cf0436c1a7bdb0de9357b49287ea2418c454fd7d09207a4cacbe9ad5e61786d5de7df7aaed571e1f7cc374e19c411e16480a060db554e6428ede97222744cb0ab769c0e479e280fc8da94d232253548008c27d0ebe1af32ce60545266b796bca0c137dfac0335262add520f4a401cd62c4277d1a5a46ab94263210886c1e8a0ebdb5c3f6aa2d4e940dccb8032901600cfacb723ce7e602c151ecf4c304fc9b41c4fe859da17f311fc6122b954565b37a88b3db56186d5ab1aea446c3792eb307127b3878f56233f04fab88e2953e71ab62de48d5fa8e3096d0f647dc6d046522c1bb8bdaaea381fb6e76f65151a4c9466dde1b0b58c89f43cfa693b896f36b22d028e2ffcaaee6f05748215c01b188fd204eb0cc1d7d3702cfb7805c4c6693dbeab0a3527cbf0e73b137c0aa9a8fb8665cfa88f4c3641171e378f885ddd8c6dc325d928da6ee0220d120ed7b55eb69947fdb18ea259b818034fa9f2295089b8efece9087693ac33676985e2f611d71f853b0f9d0b43a573986002c7c074eca5cfb677981c708317f27dd1ffae6913636d585d6f3b56ece2601712e122cbaae5963b9dcc5e14bcd6a97d3a766f746d630ef798480b2919ae3e7f83450b675652d13b5d292252bec21485428fdcfe15a7827ec68416a2f5f240268e766fbeba4762601725c5a5df00f2c0a61bef7a8e13388485ab5e8c80f7f09070db47d83540a085f4a2de67ac020dc4644a1e1a830c9f18c99dea10a7d929928a3490de96f87f5e227e159731a71a6b3838301b8fd9cfbd1a09f52a15b957a2f474398bae1619d35c346796e2905ecb6c9580959595b855f799d73529ca2300bd378a54318ac23883fecc6aac9da6b341b1f6732354f967449a7c7572fd753082fb3b722c0d537b440a4897ff6d2df6aaae4c71f1cb5bdde6de6011683d4e9956d79abe262a23bd04e118f3f7b62147f1e2cece105f1e5066d27d7651a088c7c2e8ce6317c576021591dc0ffdc2dde31f87c2d111db3d0b5fb75abb0dea65a67b3ce20b713cf5c9bd312e3e87b4c9bc7ffea527df269e6564b7b327f01e8e66aed167a7708210c39097f11f196aac60704932ad62f13b09ffa6eed7232d6b49857416a3b634adc8dd7a818a87a42301e55d871fba71f457962dbb3b68441d26b603becc0a637cf5f1e2663c60cf0f1c4676bf8aaecc228d03de18a3b30b7e38dae0e5213c010106327a5336a00248d5228282c6f9bf56d01e1ef74a9b7183aaf5b5ef48fdff7bf2c24abcdb6146d59c4e0b17f8fb0110d11fd04ff66748e0438d29f96058b03f27240862fb79034c108f83ff4541d8cda8b81f7553595cffc52951749e44b7bbc7deabfe3ec66f5ac26e52831bb1022450c1fde801501e2a777bedb5567cd02be64616860a5422b0227b1e423c631670bbdb8ad40367d5d9877bfe14236f9962ef51d9a4012d7c8cdbc97e3f8cc209baedcedc883d108df9bf1445584fc300ec9a980fba18e6ecf37c2a2709dba00c6aed501ca8d162351a1a26ef0bc733b0a2af707bd48cbf0f3a148897c30063819eb0f2462e19577f85550630fe2d9584cc3d9c1f9887befa7db288296c875fde886eeefc7f07efbf437d66a8c8f4aca4d3fb7609e63dfe4ed2d68fdd86e579f6ed2db26957b541bf6f57d887b4ea9ee6d51a3a92197c644bc946089a744bbc5f08109e16c4efd96da01ec7bb502650e43b2ed2756b553a759fcbf7567d72746e56132aec295f482fef601e8acc444b04abf63a33045a1d8b92ca713732929788f95dba4844551a354f877ba79d06d0ef3db055092aa92a56db522d2969af89cad97be8d1576e5642a985bc6437440394431992e6cf4aea1025f2abcb50f5a40d98209ddf7cb0d125415aa775c89da06a748f9d56bdbb5e405b9f9ca20d09e5bfc4af1c6cbf0c7e408cda3a901e66d8c845fc8dde155a00100536def64f751fbb2525b627382eab30757a863672409c876fde31ae193bebc639a1c6b6e5aef40a2b5fbb3b32ecd9877704316fc4178a203595683b1cfb576216e51b11efaed9c414127743045cba628aea5b4f99c5acd1f09bf1380b51b7f581f4f5598979d3f1790e4886b80eaeb0f393b7280c30cf915d4de09a1a469dca699a43d42f7103e3f18f4a4446d26028c1e188ebdf9f0da1ed9b8e09e67130c5728706b40aa093875c31a6e05fda0c0439fa394b95a90b74db422e26a14d4351893b35b6c70049567a9bfcc47ff462148271b1224989c0b1ce845f61a85c856ff10103f69a5c473c5c7e1f268d2ad606b8c568ccbacb49f663db4668eb1a97fbaa84bfddaf1db7c0fb46c7384b4dd54f5e61ade0d8295dd7b228c5a5fc802a781be090f54043add72a836d88b802a76f290ba0f4ca6070191f34a89359e827eeaad2a2e184cd3d3236499d18cb931bdc7af7dce19b1f0969fe01510669ad2c0751a7f5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
