<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69e276a02fd799be2ba1539532770efdea0312a9faccf0ab3536fba17538c465742f85ab357ff64c08e1b165a94ab0062b66bb9fbb5b24b4a10810d8cd7be68e6808d6eb8d76352cbbb51ae5c02b317e99b5612cb0355560a69e803a02a9ce6774c85a6e361f8086ecb8ef27d4983215ef1752185768251c8bbd95adb43fd7cb136af2880a71df146d48c50d4635402f22752339900c5608f2446993aa6dc981f315698c75791f8683dca244d9ac7a3bd7ba023f268703d27749bbdd625de1467aed0944a6a80475710ee2ba755237c8cf2fd376f927db8eba5cfe14b00413e47bfb8be768acd91f5c6d54081cca216ac45013795137022729c01b9489991b3e9bc5b7db0223baea3c08abd20bf467920556340fb632a6a4992acf2825733f9efec4feb10abe970d3a98201119db9d7286ec53df4b0b6d7eab18349b3d8a9e1b26e3208113070b6c70818253101d65982d9aea8b9f2b188384e39efb9906b0541e590cb41a298f2630927b27ed9ac7508d7412412cda0fca82aa590a3724dc14e33f8d9c9569326924da44d76ea5fe3d6c1228684df9fa14f41aca827b85c9243198889df2a54e19a14c096db68210d4d3b5edae2afddc614e0f3dcc161bfc30b7eb1696ef1661edec9a6727be4bd811177069a924e91bd2638c3507f34a94f9743856fafd85c7cde333520d58a82404cf0b2c3d3b14c392208511e63de48cb99769f320398099a64c02b6426a69bcfacefe144618174c0e9a3219fdf7057d131170b5fb01580411cc66a92efd2364ad17f74007ad0531fa22e240e994301a1a2a96ed8711ad8f8eabeaccdde79d1b0e5bc89fe9896ec51b5b77c761d4f83289b2d554d03a8cf32c6ff623b711e92a8784ec6e29193316fe5823705eb5a7918b3b132b2dfde8c3f9bf5f0932f81e42b7649d0689b4c91dd150c40d8c245ec08860cc683f1eb9b37db5a33f991ce714aadec32025cd2f6c368d3bdfa9dbb33653b8a561a6cbeb1496e31c105534bf0b4511a991a76cc2fdfaec933c008100f40113e0bd7ad80584ad7dd9ae40ce3df0ba41bce3fdcdb925bcc241e1e057ab98384a8a31f12d9957f81a4edb3708bf40cc5fca4fc94902d75e24979918da2b9317fcef834f8c775620f84d705782ef5536f9a019cf7bce5dcc0078f9176f669ae164b45028ecf8e67c92e2e24e0fe81dcc0e5203767b2d5e8c3be22ea2652dac9ce795689b3de377dbe3560563fe043b2a9dde064900e744808d3fbea4a19c853f79ecf1df9e62d097cb9fff8362f4fb32c42b5c2636ca4370d4abb032a5a91b6eaeac2c3a651575f2c9c68a6f99f7209a186be28f6f0658e24de5ab5633c7f386bce4e8e3e526a11214c6d45c3b82173a4385d6fbb33c60b791695dc04ecd2e0448c84ac824b5f7a774364941b2a0b07e9f1d6e7dd490d8c16bd9e49ce856ab8fa0ca30b0936e5cc551e51533547e537d8478524b67bba9538e48b1b79140108e410fa5ca8a49c5683146c463819b43f51d304c1280afade962774e694ddf2224f98632346acbb5eb3939209474b7f04b1d278d4656e0de6c712f440fb1dde18841828e763015be4fb8d5487bba68d3f409bd2467fc21d71beddabe3bf5dd53b91811c2d6b2a203c465eca0c9a0153bd7cfe094da829c2ad5a1224406ab5cbe5859f5ad90c0d8ea74d89b0402431dde060fa00d069f3025a2594134937a3cf8001cc202ff8d554bb36b9cb55260e9e697dfa7596cd731706bfb215338f269ef161b8358497dd2ca9ff9553c21944915fa57076a0c6afafb41fe5f52b9f663119d29f667cc61cb6decaacfd5d3c43ba6e8aa48eca298072c871578c53bf9f02944d5b016983839b0be9763ea1aa1319e820c7a1f28110e24b92b77cbf8bf08f96d33c8ca38db3d5c3eb7a3be92fb69f2bfc5719ae53bd3a910ee273c558df13408458036a5b3a33fc4629d6f826df06bd1b0048708db23b62c579ed4ed0d831007ccc148be1d111f69ec550ed239789d10ec6abc2196faf611f47a671ccc4f5d55a96bedac70a5d5d4ea8374fc351443a2e55c1523150fe953df59ee62626ceb59102521f0ab7738b7677758fa3fd14a372e0d22957260231cc7c0a382fff0e1d3ca4c88a0db0d847a33d83c2798173e524c011e094c8667b894aaab3aee952c656138faf74bad080cc0db99ed4aaac76e951a91ca10a95354f73ecba5cdb3e7a9f1d90a82aa0ef372aec4a129a06b548e41c7f7ab6a66c93254627ddb260004681565bef22d1032e874eb1ad593fc9b0d7fef51ce579bc566ab9a2f123677d9bc7ebd6b15c9f4a1ca285ebba5e10d01885814f7e0d32d08cd5b42f1b8e083cefa926e0c0458838d38c3d5c4da15b958e1a4f3bf17894c17922131811bc326c217fbe9b9955ec3556a1374a9297ac3081c797c25982c8b5ef62868f218605ae505956e1d037ebd9b718ece03e1b72a3101dfd88290fe8c581468d405319d46ea2d92fa603aa157ed0c7ffaacdd9f8faaa2556aecda2832bfff8dde98ece545fcbff4b0ed421c4efeb9b45fbb85a38c39ca08e0f2d255d1b13c57b18d457a24c86af77df39a147a260de0133ee306ba42b1884b8c6e01180900a8bedb4aba5255f13bed5ca05fc5803d5f128adcee07549f7637986ce2490edd26f1d869c3255ed39ad37a4ea6d360e0a324de8179e1f68b8fa26a0cc67edd0b2399c6e23bac3857a7928d373bb4bdb23119e80c7fcfe62ea158b6ca428209e72bb50367d780afb0268537bb963949e29d4af0f435151252c7b6244724f9ed98124df8b4b358a3f49be4bad402b036ec223e3ddfe12f9979293d3a474eb8f1dc715a56eab8e0a8a77cea37b5e47f924f7a1bad574a36aad50c7b0b6a4c6197e867e52084a17c768d024fe39242a0fe5fc9a47b711bb895d69c38744896044b6d27616b0655e5b44609a8e08f5be561ed9619dabf8e03ca41290ffd224b045395f67c4f22bab88ba9814ccd33ac0366e48b3395a305a2c0ad100738866b254849430d59435bb7c1e21b74461886886f21d0993b9e8df5383e14c0e120478cdaaed8be5fd65a99e1ce166e4684844c707e059b53fc8db96af031a82a9b9c05e065dbf1709102b4e47690c5ae13ad1e62c1aa734b88047311aac6b6fdb5ac3c6504714be4f0ffda2a072cf276173e151543ff698846575681df9d3b484a137fe1285843727f281741d3c89f24a018f85bad8206c966979937094875d8361f2ca7de4a064254fd5d27827c7a7b63e0d1b7c5f7cbf517ccb886f4b20b7f61954a499a78ac9143f81995f34d7965fa8513c17a61e8c6f8d515c879758d3eaa42446225a5ca80aaffe4e4565e49f961e9cb815b982548bab7c1dceece827eb245b1f5828f95d4ff045e210402246ba17c5b907c2b1876af2b4aacdf15f0cb0d2d89f11407bde5bb8fa325effcef9bfc1431939dac2c256b3ddec14a138c82c23001170f027e5c61c59c0fd2e0e08a6c4e7105138689b38621372d5473ce37ff847817393309d09460aab9e4df590d47f09aeb2fd59b64bfc3cd88763ef3e4af05db0ed09afac6ec04ba5cdd72a53dbb6dd8ab4722c5653b8e0f3ccfbda38ef72a32cd13c89c2ec807b2cd2efb147adf167c6a03003b91dd0cad91c1bd49d1500c46db4b63a2d79f14279f100e83bc6cf931b2bac0c9c52227e72a1fc95952b7ded328f7c935f4af6598e27bf0cfae29a6baac4db33370a5ba03675676f1b1d6d801c87055d72d2b11bca78fc8915ab9b29b203dca124fe735d09d5d6f075ce663d0f31391d9655b4644dfab6ff5b2218a04801b455ab98af90923edb15f1cece194beeb8b094fe36a08a67906e882e2fa261e98220eb153c97754d72781bd5f25df17a87e68b3685e8ba3f4f3a9ee97087e60394db8801546c9a183b427b6af3278f02904834a03070c0561c0d4aa31768597f78f0f9fd61d13bcf62137434f8f848ac7179fe99babdb09d9d7bc61668bffe657bcc2058d0856e81f1768e125056b38926eadb00f8c501bd13e113d1d0b31396306777eabc7f68673fc839f96f217df11f1c4696671323b683440ae6be144b381a2e0b352fe05a272cbf8b0a568da86cb068147349d0c2d30b60bf995ef4d0ef94bcd049e9ebdd74b417e0d9463ceb8982a45bace4cab8c53fecd146f7a71249339ceb736c0400ec6832ba008dabeb03db40b1b56a67df62fac566c962a36bc35d79abf4cb40f80b37a01a3bf967e81f47faea744eef12478748aa1d5a04b1b5d8baad5b5dc574bb0331bbc160f163b5b59ba5f3cf6491b5916d37962780932bd22b07c1b6c35f1d85b449688db02db00d1bdeb75c7fb6a6ad0f986735f619289efe7db5b216be2706b63feba94c829f59824c0fc3f3438262b78a94fc8a18d6a38b66556e1cf81579a4932963be43ef9a0d67505abd2d07dd26f5e0f2024588c4bc181baeb2a439d94bba05e4d848f745361d4e553ffe2e59f3bee0676e5573f8e078c66f1666fe845a4711dcb5178c64d4c78e014a5525eec95225b9f3f1565c4873b35a7199f3775478c6ceb281f1069770bfa38ddbaf6185dfc4ce717f5f450eb306fdc62cb829111c0d13d2298457c7033fdb9cc87a442953f827d633c1882a55270148cf7fb44dd5855a0847d57480ebd26c8d740df9af92796022252703becb51c8166b0a81db353a906d3d14b9a208375e6cbd4c776838f1d169a7c7f1212936d7daf64ffbc2078037ca530d23d59d46cec9c4a472f40149051444ba712579da6cf48ae7173a6349ed4b342683bcef589cf2be4ec2404a5428dcac855cb59ad12860cc9c9f90739263315822cd9a82287dab5eaf38a9d3f288484584260eb9e171eeb2e22d4b75f2f45f76dab4d1e94cc8ee7e11e451bf6682953d72f06f2a270a950cdb5f7d8192e9dedb06653de626ffce8fb348fe53fc85c57d961e55d267f46c7663be9bea1e5e4c6687391a813b6ce4a249ca13e454be036feeca2338ff7d8d125e55258e5780a8e8ae7dabfc5b72aaf9460d6cba5635cc4dda73e916e80d10753ff471c8223b167e12cbe60d20a7b961462e21096d057fb9078e170d7f4d8a7f9c809ff40a3b38d2112913bf49f3a66f0d665139bec395da751408c1074f50218f707b1dd534d3b16624749e9e6644de090a12436b49f0a5a2bc814ed763f6bf6e9a7d78a2804b8c144004cabbcb3fee63f7d617d265913262767cb925c59789156252b9cdb32896f570b26523922956bb022d4be1b1320123c89560982f08b4c9f5f8d5247f75cdeb9e71717fe9a484a0a2a31f1258d1978e4e3f5427b93824d61ecf53fa77875f5cc14f7c639de22a5acd80c08f2604f1d8598b69c929df505feaade0a21bfdd38f405858d23da284f4d30b15f32b55918b6180afa49d684591e42ee3cd4379e39ff0456d052dc5f75af0c20f583b0e300bb0ecfaca9b7f743cbf2e22769edc67b081dcf5199d250295fb138b2b9278e424179302642b3c7bf974cf5864bcc7460e8d528bed00f4283f251b71bdd446e73809edf99bb72bba8dd79d9b9fc1e7433b0268b43ff4642783af7aa17310178f85cee7cbca43e1d87a4a837737e73a8d228fea4967e53f056a7e372e8059152d7f74952fefd26cb47fff8d5d26c1e429f3c355872f70a7fa58a3ab4b32929f5125396dbba8f8b0162faae161dd46f4e1df1ab060a3ef0453d6527083a5e7b18ccdcf499a21a5d5ca857fc8cd5b5ce8ca64f8795fa0122474156c0b079c47b0166839e1f2d72df53dddb6ad1bb36a93b8f5b0980874f8bf40794b5fb737d813d517241faaf02ca4abcedbcda9d023cb58444aa9fb9efe0f7b624fecd460b63d82ef90cdabe02c33ca7071a7cf746efb1f83b7509971ca7233a7761e558140196891f0719695e9e9f6c0c966e809e72de6aa55a02824133376835a38ec1af9cf359716b4b41eed655c9866920c6f6fc72fb2f0606cf294b5aa2ac19fb4c10d00f4a11ccf81c2ab9741d636fe9fa725c348e03ec79137dbf8efc1ae742281bdb10f20739e0df012d9108bdf03cb791213278bb665d86a05bc62df534e66666d7210b79e43bb1b542ae8ac32153709ccf13539e384a21e381f00aedabdb10fe0380862c139f5a8e1e9a98e34883d62fb74510eccda8d36a4923b241f5ec7bc115d00acefbdfdad5c29002185321829cba330ed6c3d5e267e0c9221190c04a05b24833d4b06d2ebdde2c085b9c83c36e2f93e30b91b966677188a1165ec2796ee7c18d2629814d1774693e4cb355354d89739491e8b71813c27e4ed59b0849bdd639534da40b29d66ec7855b3eb9619c27d5997491f685dd815f4f9887391c802b83a880233711d87fb9de14e55b036f903d9aac96811370594e285e39ae3c548513d960bd5f791972a87329b5ab32770041d553b786317a532498418d3ca278b4d536386ea0c4a53f47f9d18468d5ef13ea223be5eeb8ad96303a35c60b05f0c006df7aa1dadbaebf414fba16bb5a7dc680d3a2ccad3e53b5bb64b2c5955b96891cb01d136e3bc6be513c5224a6d0955347620e56d5e4bc6dfdcdcf5ffc68714fb5c95bd56bfc0fac8822f2672753b1b31bc758a3287f23f27ec8b4fc6bfc896813e4b4251cbbdf62681afb2d193f46c4ac25d41359b4a943b35b518e68f0e5fc4ca5fb7d42a2925f40053d3f01e2306b8e7db09ef02237b1ec0b0504297072b3ed0db83f62f753af350db17c5eb583391736e999b72ce027c3968364062479abf58984d8adf8a89eea7598410a93432f98e4a2c858d820f753eda6137b1133afc40ef33b6d5d55f72c1da58b89389dc018f1a9e729c5dd49e31de3a0888a0e68829457fe46a5fde174d0e776661bdeb4e11bdf64a40f872d1b65c2bd68f5f335572ef82c5d359afa21f46411c218c1152fde99d312ef1e9895bb220381b0ddf2f85b083b50ad4e47a4acb43d43c4c2353c53d1559aa3c40b98a2960734fb9473d0ad794e82acf58d9a59a6dddba8f48a5201246f85ecd23f52ad6d3eedc1ecd8b6faa00aaf19e0fdbc009cbfebb97a91273af23d70b1042109e0c9aa9ba97ab9dab8b64b2506fd40ff942fff71de3632866bd9348f6d6d655087c29db8809981386c79c20b60a6fe8bd3311ea3f03ad553d38a2c4bc0ed097d2b5688da200096c956327f223a55fc0df6961af39fda4dc827c5642494a7da8c3d101066309493d5d4b4b2f3de8c79f78ecbfa8b83b6a10b0bb8089d51e1228e0be105b0c9be6d3859c00db60600e917617f8354267c1f070be7d2c94e7a15b6d8de8d57340b0aaa3054dfd7bed95706f16c926969336af48e354ea3a2afe4a27e1d8bba39c2b727ba71ae84057851c17b18f2f9a5612694ada9cd89068f98e9c6fc7c9842cc4c500cf9f674fd64e45cf95a9984ef092e2b697c58e9aba1fffe205722b505ac2c8cfe8994547783feb04a35a45e71d1316ea87720bd8a7fd8b3fda7ed0cdd3c59ec18c8559313adee69cba19d5601e963167ccfa3e26cf1333235cbe046c7f35e86b9a47d59e411e6dfc91544094d5bf82dacbc701a1ccadc47475d515dee934eac23bea3bd16da32cb0ba078346911696958a2667816cc484499b4e832867469bdfb7832d88c9ee8075d65a117ce41a578919c1adaadbf454053780285565b8f6f53873bbabb830a70557f5337714288645499f682addb64a094c1671110f631e1a30a452efc748d8968eea6269ee5e53f3bfdfa9093b0b5978bd1117ea414d3fa3ab02ef89383e5475062d25c0ee6bd60d2593bfc764866aa6e514a5b3a5be3d1a022603f65c2295f9057e38f30cea5b608830eeea3e7cabdeaab0584bf21a70d10ffbef15e355607aefdddc6a7e12a8e462b061bbf83e60c7c7c0364f1c604ac8823979a2a68e80b8585ac33dffe50fcc94072db23924a0b0d8d68b2bb0011bfb341c7d45849a182b5e815a324d3953335ecec9da8ba30e165a5e3362954761247e4e93a7982982c3367aee332a17b17171dfdf75980a55b7a28a9f4015883e84338a5591fff1c6f738a7882b9d37aa031590f5a0fcec95c36afd2c404941f92b86b0c37359b9cf2d743296004792699824d3247101a7557a15dcc014ed692e2780de52c3c17a54421272ddc38863b578214d5b97bc534d106141bcc6ca75a735a9a5f1d213e2b53d8d89aa89102e60e18fdd4b59e2293cc1cabbe401f3b85f3893cec64ae031b553e6a378de90007bd3348a0c684dc71d4f57ee9a9435979cb116908c5ce1a75ec481ad045101613893aad1d6b4415583eaac159c2b510178e7d69dc1b867861a886ef7187ce8bc5c363937597a461b2cf0eb01eee00192dc1864c8cd4d78e09e4698e34ffe61d9abaa6a51c3a2ab68f74560365ce225521d01579105b011bd1c45e8db20f885e93d9f1eff7d754848a1c306f93e60b5e213c506068d9bc28044590ab79e8855c883970aad42dda3faa1ba86c85022e0c776ae4a2c7708be6600ed6c49282e482137adb25fe34cbb31c6ba8b00c9185206dee43bccb18cd050eda250b7ce2e093b8719de61238de196d73d52124dc30c3549c1596162807cbb9ce0d5bba839a7016850f0cdd837582f6817834883bc94df5b159ab3f9453b3d6074d357795cfccf765e1a98d6a6563662d9906fe5cda362bd99ddff7619d86e558869936f2d17dc2a6582164152ef6a3087fb8b74b2a9f65a1af773592579cdcd5be29e1a12d7964613312747bc359725415ef57f878ad5f0802d1dc4bfbd183929f5e0305581546581af673e06a1cd9b1b1ad01de44ed0b1809afa810b39ac9371797556e67c9eced3937df6f674f9c68751e85b5a57696ae1853cba3cf6deeafc9a6d12eb7242eb722137949d65e5a8c7890fa81287ad3f3a510ae22f42c28abff2249229b9a6c0a7dd0925286b1deb23598a17a237267bcf055cfb45e38b0fbc022e95a6b4dec87593074a0696dfdc333a97bf0d187057c48514e752f7d7f90adb2f23b957a620729208734fe9d0d1c00a0b7074771625b979e1b81f3cc1b50cf0b5d173d6c338fe8aa88997c83075d6f1e6eb1ea18b8041e33ad8f2ce8804aaebf86a0055249828a91877be85434aa34d0e63752968327384a8cf5b7f91412d01a6150c026483d831d7c13afa05b2527572c25075db32a9ecf9e51e7b941a3dd5330da1d50781e43c82bc9de02c72856901fbd7e771d8b959c23c384a56fdd31f0be7d1d310d86ea0642d633c314dc0718808e6ecc15e17f4ac65619d3ab615c396abe264a3ea19c1cc26c77449d133fcde1597abe846f3cac8015cf1951a199cea8a1f4dac5af1178d82690d219b19b47d137e819db5355ae40bf43181e848bba140240be0cbeb72b45a9d336d6b5e94d99b9878d29f0a9d8977090063509110ff42b051db526eab221f8c35ea4d972bb5e88ac80ca5c35aa5cef53deeb8d533af890ffe88a52fe97787f540e28acb1aade88913ac7d590673dfe8f74ea07ed38766ea83a5e05b8b11d183a297b3ff3e12d91453ba231b4eb41b11e41680a483dd8d46393d791b54f9d759b3063f7bb94cab06339b18a062990931f2029efe2db910ada3efbdad97e4c99bf899243b88a7b2eb45fb27eeb9b1ae549ffdb45781d53456ace85447bf0cb7b1dd0d5c73040abca99beb73e65bd043f79efe06f3508cca627953897ac941addef1e32302f66342a3caa03f4a4ec4a7e2255830587bcdc85a3a900ac4ed2d5bb0cc3045710291461d7f0b918787a515fcf950a945b78851f8e008b3e6670ca541df9f0e638c315060becd128c4ecc712f4fda6ff512f1e9e29d9ede74bafdbe9076b09727ee2fa7065d463db8843cd259e39e119fa40604daccbe83432d138746138eb48260f4b4f95fe5329875a23e25b60b65fd8da45e180e55d98dff11d8690d8834cb590f74ee7389d989445f5522d5e4abb30eeb61f82b6ce32d56a6aa8fd27a09132b24f8531930d974e10ee53e21b7a47658145484cf676df86667ca2e88d0ce97c3d5e3287a63cfdb4e9d5378811339b50b8bb32ae88f08d2932ab44b3df2d0d643b43594b48be9412e0da557ab4208d1ee23d24a4e054fc6890b25dc4828811d50947bd88ce02b3e753579902415bdb022792b5ccd8262f643cded7b766225de3dbd82ad717d67b90f1e277cd22c2f9d14e59b36881d433572697021c92e4a6870126c6b7f42fc84de9c76f4d10dfd14ff51cb41af2c0b39e76acf9ac032921292ad15f696eb63514c082f9a770feb26722cf3656b5babb933a3a2fe76b7ba54b48ab18cfffb0a73e844e4d752d405abc84b3a642003a1d565ec5d9aab2508069dfc3130cea4a9a2f00f1160bf176582e189ae3fde95d6e2ad3c2d7a142ce1834b344cde4f7b05c15e2ca8c992be769ebe20b7a5bf51d89a3b8f1fd0921cc2aa905f502803a3c36b8adbb0bb9eb5e6355a122283487e27a1809f4d8c7588376e76d85a727675751a95feaf6498a26ef3babb47b177e797da6a3bf32b9754ecadcd49cf729c119f36eb0c8118e0e4b5ac41d71696206db6fe32512f004ca65c08794262969927b66eeacdeddc64244a94fdb9281acfd4560cd6e384d06e48b552d870b440add2fd06dce5b8b23500055e6b702f0b91bc1839e630dfe33292f164e05f652143b9d3ea1cf80dcda65cd4c9b2fafe4af0c78ced053bb89c007d5cd69ab89e98aea168656f519aaa671f4067bae6efab4e4a3c04d01aa8213d2788278aceb142637dc467285bfc782359cba61c6a03d18df7f73750919d31ea9635a6fb0326e1a511c5b9bc234258b30ddb3bfe69c0f2c36ee5b02732e3c27f1f74fb0f9890ca6e83c57cfe2b27478335bc5c9927cab0f74cf77847271f68548e55a648d4f26ef7868189ddeb6d5f341981b40c5d1f7faa62f9f666f0e1a5f4a51c4737b2fc401e4b5c42126a5d93c494318454c11b124801fa084c6698f1f95abeba8e5e3d5d9d1cfbda337cb6beffda9882e927096dad34a0274a37a6a755a83a87558103ba76353d09caf2ff81c7b0ece05722b2d77946a0e3997e7b353b31d4d134ae47b99918b0b6a0540f34f48248ecb04da5c91a8397e0589fb34c3201462bad28547093b44ba7525230cf3fb53e27e924daadd0fb9cb895398544bf284341c98a4c04dbe2ace6913001f32ec7003d760b65fa783ee1ba5cdf31ec4b66d173426ce0f27e1dcd07b18e922852de7c00602b78344e72336c87a6f86f0e97a21c946af34c84654d4e0028399e49b8a594cbd7ba1730a61a5534d66b699e3693f65c9c7c8abcfe7dd06971962f49e7c13dc370a2252e259545d9e3bf8cf5d2bfb05db7c39f2ada5fdb204bb94d002469696d1bcf3256b38a081dce0a9ec896f4059318ea49f90099e360ad805130c7801ed62d57e85c4471acd2559a5e84b48854448f03882472d59009591a0f3b94b363cf1706e7adc2f7f251fca9e84a59ee6b02366b154864a948d0a622c15a5208697b329fb1295773ca7fcd9bbf0c9dd04a758e3a67ba6c467ac313292e626ca977facf0f8e622d1f9336180fc4c7da01b8ceddbfaad22111b01f53d078f2d98a6752cd12808b12c3f1edc7511c4afc9240cea6552cd5c38e2bb0cf63cdbef62c4e652703c616dc4d818de093360df05c1e9ddc06c67efac4ff97acccf2622e8b3d6644d1f0210dbd303f8f154bc50d76bf62438e50076d886dfce2747b97ebbf05d27459865e9d57afc70c594a46174c6d463f5101332c1102e67e531007ab0f74d6856dbba3a926566294b64fe9d58781b2ef9aafbc1bf46260b7898bcbdd3c857b36a2601b3b1db2179334cf37bc2206d49819d70b15dde86df1729d92ef577dcd52211b0bccc6b2366fb62de1cc92c407c5501f515ab469b0aa12f32a575aea123b3b8c31f461a4e2e481efa1a41fbc8d0fb2dfbab71b13f2b3046a78af8bbe7c1c786100a7b18a1dd29e62afc5fa4f7913e93acb31670776928f098ff271ff55b45cff283fcfd4e0ddb28b8fd95a599f901a77ff6a6695a9252767d3449e01e331e952d87108b42be787e04c6914940dbb4c053d0d32e5b234245560bae625dc453b3983b232b36769dd5c3416c99c02629b35c745f0a3e74bdd22e37cfe9558cc08104221c30dded2152a1034330f656b3ef5f735b5066b457ba055addb70c5171d47409ae67477945282a3936bb324665699366ec2941d25e86b2b350d3d5e20386f62a74ef29142ef3aa2f9aee139b0526309bbd1d958c5ee41e0bd63588ed94bc06960fa5eeeb07f8a83743ebee87d83f2036bfbee739dfd750dd4f9544792bb7ec4960fa8b424d2ded9d45e62f7105a3909578305951fd5f0bd02a2cec4732c092532b95f1c8a2c50231492eaaeaa74ba6a187e744a364799953cb6b4d40a67d1cc6840b4e5fe44a2b165ae56a4cba699545609088035c87504243802bc90b7228ce1ea60b602c4e2978bb084e380a5bcfe9a8ea0781ee9e058e76607d8500babb158859422ddda56da57964b710afb7a149ba17dbcf332b000585905bd8942fcd480ff9067f784dfdea6dd3907f2fcc59b8b9a61c24f839c26dd7b6b7d1d99391b4e2306bca742d63f83c5751eda8506e7755e1f9649bf2ca2adabfec028c5df846600dc0e7492afcbafcffbe2a20650c3611784ef1239329905d8e024449e0a31addd16883f0a0fd5b99e54ac34f333ba6861040cc04e57d79131a114b42833ff63db1cf8dd9f9d8312c7c679809d4abfd4d968794faaa3231788a8e7469744de6e2198a2b20ca40fef753493c104d9845b8c7c18b06d03369172eb8538d83d93573170a25f728270bacd038a6895b138193d85055352d34ed1c3dd481046cb7d5c7101ef62f6f2530e2bf5f47d58c367f63023a5ab03cb344aa1a018030998adbaf3b3253a808b33ed8b251967b4adc63db506c19eaa79e4118ecfb010f9940e42b1e97ae44370fb03fe39c2aca914566d100c911940dbf0a7a62e7a83ca7a708fcd3dc8a1118ad9b95e58b69a0eb1519b1c9f2058f36dda15fc54686cfbcee0c6cb3d2ac8703aa1b5df3ea880296c40f8963415f973634909ed72801de4644fecd3e37966957250f7d6cfbfe6bf8acc0b3a17bc718b0381b062bc0d4ed7dd1e59e769f2634e6021e298f5adba0a3874b55953cebb22589f5004ad111a9f6fb04cab61e905df1c61513b4b3cbd56811ac0113bfae8e0b44030c7c05cad6f7529d689296d2744f730230b275bcbd3996bc0a913333d45355dc762bc5c99f3b045724276cad5b986e964e7fc298f4b5b954a8bc202cd1de0575b7ef62f5f2310d2afb019bd1961c7bf757a987b3b0bf1934be15f83030c25aedfd0663e854e2c6cf7d328eca43d2dcb62a6a2e91576befd897c2f7e193ff6f1211915d498bd9d4143f924fc6947c0209c9a5cfa63c51829423728c1409d917cea3530c7e2f8ed9112db17a16f0865bd272e8f9d17d9e5390e5eb0f5eb964c634ebd6668e264e37f016fe51e87372b8c2e2c125ba168da7406c3cdb75cca3b90eb54e77df84ed67547946bcae58fe6a7431a47f64ea0ce12077ceb637ec7feaafcdfeacfc46a13d60e3505b58ae9beb6ce0be19e3d25cfb58e2aadab269d08663abe5e9280afc212fdff184c33ac7a91d622a8b719aafe7d5e03027698d9d1a069639ad9380f0738f5dbc4273bfbb0bc508603c395ddf3f904c14bcb3b723cef0b8d5ca545623b28a805d0da0fbff3a80b7d6130ea42944db6e1166537b26c4ad0dd8e19c756cec731afc9eaaa60c3e34ddc9c9f5e4fc101c43133a6802ab2f66c04ec0e9a890e10089818dcdce1ec142e0019553ebcf08da68ec9512f4efe3d97208daa0ffb5d9668cd92c0265b7f38addfa53f49837a9370e93d8404fc1215d08f846e0c87ee3ec14b4b9b0f3723ec55c448afd93f1dcf1f8097efc4bd516db5a6bb8d94c1d68a92372cb9b5b366c809cdc2f8dec10fbf2c168ae00655ee9dd16a7d30b4da80a536bc86635936dfbd291c02289f866df8124d617c7c07e5a950dc0c7c2ee01c753fe8e4f0e98fbedf7cb80528b553b73f05b339121dc114c958d0b7ad46ce71a167c4061fc81ce0796d4aa22b6619b9f3ee01bc46e7c2683ef2780cd990eaa51ee081145f2bbfa732b5813a25ab377311cc1c7daaba53bda50de847b016d3b41408e3af4acaf9d0faca71e2f180e78acfae1be8ab25fdec0aab49a649238b317130ab14770e36dff10c00f97c1066888b3e426534999bede209817e4ea98e15ce351b78a3c3c19e79017d7657bc81aecf5ea3f5275069e1bfec6543bb78e5ebf25e0864b924b99cdcafde2dc8b42bfde0ad8aa08b6ff7f6732758ed7e4d80a16b999c5e9b1cd5d7a2a067d998700d255ff13cfe8366dfcf70ba03872615eda1ffca5a7189d8089fc3e058fdbf3a74acb78da9df621cf8e78da1859ded8525e7bac7d659cb247accf2e5a8ef22369d303cd12da367ee2cf976c43a313b37e00c49508926cf2be1dcdb67d5fb1a873b66872b1dfaad87a7623c5de4c2274aa711e4a9cd085fb739886e3c26b43944df9ded5fa20b0f3bd56a6af20d4e55bf77f88104ca9aa7b3ef22868ea012cf973864276d5fd45d22d958d1e1b9ef54976d63f6112d041ec96690538dd3a438ea2b5cfeb8ec4d625cf42dc2378d630b9526102d7741d76162d6e53ef842d23de2cb3abdd02b8a3c49bcea4e04b2c07c27ce827516afa36d26ff258dc20882be1e03e9ee20f3828cc162d959056f229cb92fb0b3061b5cee87cace36a14ec277a5025b14f86f6c4167612f46f82262e564e6592948c8cac45140e9404bb0103d37f8b260e5a2aab7d1d1f740ad3ada36769faecee05603431ae07c330efe10d6cfb4cd4af322832e755a09fd36ca93b0fcb8d361af0d3687bff0c8fd1b327410649cbe92c01449b8531c1a237ce36e81a166cff0e5dc7239dd07c8ff64f2f75a1120e37036013771afeca0b8d88a9143ffc3a0ac272cfa5a5125c642644839e155354c657687fa3dbdd92de1adb1b38b0d8e88a2890a6b9641a6494164e1237f682c6cf47c71763744555791208df94c6524c97768d1a677f547637908a24edc022f3f3b144072e35a2d97bbb9d1a23ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
