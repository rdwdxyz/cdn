<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77a2aca95d5374f551cb128f2e2b888edb357e7ef7ca1d6ca09cdeb81d45cc92036a17be26672bbf6a64a70c18a13068b5624859a69326bd261ad3978260b242e9d291289cb1894774e39a8d08f33b5573767ea3b1672a2e4b16a18f6d22bbe2f5f0ae052d6b45eaabad67fa4d1cb470b3df83a1390acc8aa416c32813ce3b970576e29334a3e403a1ae311275fcf3a445af5e01bdc9e9e1c6947d553b9f6c4a1c543f286d6877b11c89d475ffa6c58d1379a532f4c21b61d79cddb7a7d16655d33ac73fcd33719fdc37308b295294c70098a9592210f662014480571f02ed1060801f2620dc780211055fe228774af2e187c3fbea230f255d6401c1fd228d62aec1c51b4a7e25cbfce225f9ae6affc303271f8dfbead1dc1fd28db0b75934d276234ec8f95eef2f991201082c3e557187721ca166ce6efaf82cd5875073bcab850dc7c3902317312145fc77fb89bf063deb4c205ac6f584d11d4130d5a1f9f28614355113ae53c1b78edf8b980fd778ec36ffb8baea4a6a30d1067dd4bee26268fa7415f833059f632a1e12fa56b02a8eca15052f924b400424a921f16e85caf52653c739325db752f0d5b01df65cfa78b576f2b925fae0d46945e571b5e557e9cb56b7a4486bc6f7b43615f27fa032fafd5dc79c7e284000da07b1c83329a3d8b553de8276de4822fd074c7415af09c0547230f86d4f067dabb4d6652000c36222b34551e827019e985aff783fbbba81dd0d45aba0042968f678cc3276ca8f09555ff371cc0651b37f3d69a764f40ddd4f3722f060c2528f2537ac88c74a9054eb9c79893860500cc4bacf6d8ec88d6b9f9cb5565323a43bc08ca13368cb46c8771e3fdb89df1ed90fa6792fa21318e339eac56d88bd9828afb78cc8f7aa44624aff969dbf2414c808de4b2d7c6208bbb84da7439fe0ccbc136c0a035f033df8bc287e9a0e20015d4cc86fb535ad4da3a8a2cabb15bdd1ae98e70c42e967317d087112453058e696451c5f8a60866a9156211908fb3c3981939287a319df57782a20e2424ab8b1c4bfb83a73f5da27dbe63f6048dea9837bb3fe07e1dec8eb943c947547c4dc3778d18bea9451b73932ea691667764d05466ebe7338e0ec9cfe40358919844aebe909871ff6b3f09d8aa3b26d6c4b5f624191a5bdaa82d3c577d2a7741eef612259a32fb3caf6c90712a3a2690635d3c2371054c2f50fe5d5c8c14e6b8d9c620424620f80702a2d89fb05dbdb866bf786a93e9242437e11b6517b8fa18bfcc237579384974387cd1b9b45fc324f52d98e0b9e6daa7f6bdee9481367d16e6ef272d879982ff85180bb494f50414ac7e0c6bfa51d0fc1481099ca93156e93a3d7a580ee9ef7d702d1fa87507492456b300aaacf9e465c1b59cbad98be7de412f98b62d88e8b38d0aff40799db423f3f668230b4720786cb129cd80b2c7ac9328609b16a9d05405b8c0abfda5a8c13d0913fa8790f5dc9717cdf93fa05eeb983161153af46916d7444d12345fdd263565bf88a93274c87228338b9ef425e5d87f736d493b7b3b59e562a3a05b2a5679eb825a5122668066f86e904a7542ab6d711b274b10e20ffd936b992dfb5f4d63620bca0db713b518014995514c418a3269ea69745fa5aa347596088e45d02568ede7b530693182557c824077d5e3e7a5fa456f09f837290badc03b7dbcc5a500e770429b7730cd924719293846872340fb09f345b8f244baa85f2b305d15daacb5831be9ff2592f88bc790572a1d4799d01a22226452c8fbb07201f3f3674b57ab706b6fbd47a4c788bc57696e7c67887525cd6758eec7aa51ac19cd69ddd38cda0b92782deed7ff9a14024db804fe4b03b1b093182ca3cb2014134b3cceb567733e188be804450d8eb4b47628462605699f16266757b93841afa607fd24dd2e2aea51d259a372a5294fe0fe920ab7fb65a71ee8dacb0950d8ef0c08407627f05340454f17f3ab25d599924c865ed8a76d472b3a03a020d3d4194c45146a00dab3ae9513409c6410c0c781b43bc809e30f3ad75a47025490c4d666cc2278a5bbedefc4088f26f23afc1a5e913771b587ed5c01d76340c5ec7e583767288ef14cd57b591c9a5e492e5d74b61cab110878ddf5bf0951d9ef9196fa97ef52c7093bab2655df14e77824c92b4fa7d60ced97f18d821edfa081252b2ab75db762ed8225acdc6c3f8a1084c030cd1b7754ceb94af8a1c7190520a14bc29f8113a98300b2d4a607f2d8c445f6f5d7cc7292397d97a0257a4e46ff1f5cf4f9640ea634d3f8f5ff59efec6625fe3eb731c89936e6787369edd29e313a823c123e454ce25646c637b6130a23359a3b7415a6d6ad161c1ccc94255ce5c7107491897f88581324aac1615d248063fd5a0cf1734cd4779c3107f3902410e4fb197f79cdc7ed04e3d873b4f048629ca4198a4fa23b96a33cbf3bfc4f67c76af6cb433b3a02e21138e56077769af7b69a6d74e7f20416ca12981c3bb1fefecccbf20cebe67588d2d08262380eb69bf82f6896d4d3222f08ca925fa13b3914aa98b97e3d95fc241bbab6828ba72f2c51c0d41db39fbdb18422b48403962fc031a10f5107f646d85be74d4434547e1aa4137aaa624d55bfeac41c8daf2da467172763cd70915b23e22549b47d8d31e50ef1d650ffca9bbc7c9d1237322b954312bb4b3bd75d0b90f278cc621c598e11652a2f41b17f72670a975edec57f360f186be9b91956c87cb3505364bd3b52d0628c1027bf11d3d93b8d2ba3e0fce8a50a1efa9a752aedfb3d9bebe6e40c707addeaf760f21ba64e1348f064bf0e8d887dc4cfc6669f65c9668c00d95077f71a265de83290073287290a52afe98782db0bf1c85c11de6655a234c4b75d06980c1599246cb81c684d524e890783c3a5eaeef7c72a1f7c5af12bc2981e13dc2ca5465ef80ba7098b722adbc78162a5dd21f444eccdd82f3ec25fda4ffefa40ea960b24b3cf3675c1c05d228d9b1197bba32efbbbf5659f43bfbc6026cb6c60bd6bfb7fa06fcc64ee88bc4be7c4c776828e8927d2a42e6be06d2ac0f925f7e86ce2baab32fddcfa6fed91e975df329cb2ff0d89673ef176f9d0cf36c9351d28eeed2ccfc032dc1fb970c02ea0765ce3f094b6f4f7c8953f137fbd104eaa443836033860f701c6b78274e3b3a868b911abdfd59bdfcc6cbc94c63cf53eef607d6e6f075c479024921573d9cddfc9de32d113b97dc6ad85917cf406af7b3b40f7c41390fbbf6b7fec25b16271b9f548e8ffd0b834db36b23b54d87db29d868bf302e1414043f15e2ada897d16c508dec9a6ba94379449738ee5efb67b2f2d314cbd77b562d3fd5efb91d801a08a1bb9aeb043d1d351bc22025c75e83edd67256c4dbfed891be85cc717165e25a43c5fef0acd7beb90efc4b55075f6ab39ffa1a6c10e63b1b1609ea799982a74b134bc32506a36ca7a84c80c7269eef8ebe095761ce3b0b858e6457f911968c5232793382f9b8ef5e2e4391ce5ec46e050d1aa36b31f9af06c208eaabe79e56979ac6cc0a2a3d0fef62f3515905e91e05013b63015e03bb1c1fc6e9ea4ac184fbea7feaf8676204f2439e17c731d82f6ef68d1ddc1b5101b657dc1b3024793c883c9b535c00ee738cc448d48f7331552d53d6ed474a9137b8ccc916bd9b0ec05a0ca6a8ede28e93a77afa8470211f2861011338160e64435d4801b4975a52657389703bb97994a19c7b93cff0a636546e59198a3f9fbc4bf6e973331f4070dfa7ae570790783bd848f183862c1c4bf74308647e07b753ad46869208ecab0df20c99c067ddfb4f96fcb43d892c1ec013acc9d5e47edc3a5b14c7a70890f1eac993ef809e2ee5bcccd8984f337c4f796ab68860c49c28135a65406130933baf88e9a69ea7b4c560696610e9f4152e072b2305f0d2b81e5cd1d0c1de157de115a450332358f414195df3e473db9ccaca0007ae594f653cc6ba9b048389858d020c222631bf0006541dfcae6dbfbca2856486ce9e223a72a12323d52050e861f15d4831a7d1b853887e0e5bd4202d3c096ed1fb30573dabb633c21742312af4c71241296390b0a53b431d701fe42a2872fcdb4748e5facdef7c8a39e377b41a351e922e4bb3607e5a11cbc481efaeeb009f33a89d09cc1f497dc0ecf581e0674e9a481c98407c0d4dcde656e8e5ba122bf4dd49656304cc78a2b00ab982c063d1735b64692ab2e30033e79fd938896922b8ccce01a9c146d7e6be70f3ff55904ddc384ee79fbaf6f3cc0db0550e600ac520942eb039418faab6e81ae23b4f5c7a19be5628aa999e70321e4d7e153f9df438c26d7363ea3e5933c3fda34d8190595c8c17933058d30db46212641ca1022c792b53802e0415c78bf0d4dca3e9a710a45b5b2a183771df4d717b202fe4480942c4c2cab03a64d821a3aef96964e134c3fd846cd00a3ce5a4357874a8c321dffb787db5c248aebfbfea85a4f6ceb52fc8c6dc97f2781b5836e0d6e050c714043632e645a4519ac1f2e2a2a4fbeb9ce9c8a08249a4a6674a13b1927d4cc8a467a06717b457302f469880f1fc355c7fdbc85a15b0726bd242ef31f7a7d576830cf2e6a655da8f7a280982590ba4b1af23720e2d5ec5f57b411224201ed929222705df7e1b0f5df5293c456fca54086f87a843401f4acb1408df118421e7f69b5e05206c64f1df7aa64f66f5b6e780af1f91c4300cdaf8c6eb86d38de5ee63c8d862d6e5478e193151321f52ce76ffe8fee76e6b017222c1048b08bb721c8b25aef734f854acc780367852694a6b468637891765daafde3cf2afaba3b41e078ecdfcfa16645cc14f5d71b05268c8d4c5d68a25224e5f53be35a07a777f2047792b82bb35c93e0f53888b8902a367ac748f5fb24b5f327a7389cf5a991f22adb2271aefcf61b9c564249df5c6ac3c0a2a172636f4b034cfcd0c7cefeeea9a3282a9fbf7e77ef90ff7b047c6d3a077e3cd781586dacb2716f0fad4a2ac5234a4e1ae14356133c678e7efc96d07603e6a9e0fd053edabe38e8484f2493d4cfae61280cfc1f955699bf2361167e33229c661df3dda0dfff5ac7618187ba5a8df13f81a02bfa7a32f5e66b1264a7947511daafe743564504339d5c24ba1ffba4eb8e61108aad878b8889da1be8ee488f42cfd530e09327d6aba67e57050928d8de33eaa0e3f0ae589a9c9697e4b0ad278c1a663d5a8e03eb90b8642eb74d74e97f27d897e90134d103cb0673d05e2b649ee37b88d2ce943333b002ed1de7a509fa1dac8effcd36119dc479a2f81d9a524c302256b9f6a6d089421353e11fdc3649c160ba6f85754ff5b7830ef365019e7e7f7d721e37e0547bf8c2a8c22fc5ea1d2c24779b692a082d6e3e5ecaa8352dc38444c7ab7583a0517699f93d5d5484040295e2248faa88cc7b74a903e7b440d071c71ee0d57cac3272de556131a3052567f5e0061f5cfdf359822e1f86fc8be60cc493564cc72972443c36879c5254cdf9ddc3c956dd6cf726489b9ac31d37a3af3f467666d45dbfc3867ac1f4500188d084b79f5852c95b64e0ff5d756dde161d338bae0231391fed47d81e939408eb3edc161abed1adc07f27e28a0705b3ac37453229d904bf6f67188bd058f957f98b6e36696269ea9216713113093d392b50161433e052bcb836507d5600b17ec9171c9eea85a31a5629e2c4fb98a3b69ab167bf8e66aaae289a68a753ef023b7a6dd6ad965c797421743a1128176349d15838585a52552f5a03ce38a2bd244090ab2cf842277759871b5a6051594afb6576559a23bc71475fe2f2a48059dcbe91fba613c4f76ad5d3e606240ecef7a09750519b434e3a0431c95e1164ed66364615cccd537213edc4d1113ea46e8bf4e9ec2fa9f30ce98893340935963c5c765b1898548a7d99973ec88d72f78d2d8e60d306c9c6f1bcbb32c3a1659afaf3895f2cdd5232e0b44ec6956a2ab4948158816bb58fd97e36b18246bf881c687dc24a3bede28e9d5a2c7efe8078a0be7bdd6aea99a3f7b80070794f4af8216594ae6f9c632cee13aee20c8d00bdc6cc0a81c32a6fc3c21fb2bb6e0083430301338cfb500a210df77d03bb2e8c239a9784fef47b2bb700d19db5c5c587b9809d6fc30ded4ce43a47c83b68e60efc942bb29608975a09a2cdcfbcf73240fdbaed52b918d600e98dd0c337ff13be7a33cc996b48aafc460cc2c336559bfe6438cf63b813a79824c4cc2d07a526c8dee6ce0686fd5008825a6aa50453d0529645b9ef45b12aea466f2d2dace8c12bca5080a118075bbbb2a12320d5cf8cfa16c9e6c03b44113da0ea352edf4f64fe5a89ab36c66aa887dc3f4ae3b759c63d43575ac027f85d1288c78cd7fb8b50e650d22d47073de1d61f21a74a266ab64067b981d26d2fe41d2b08dc921ea959250e71964ea38154536971058351450a9bf6b94860709bf3b1537b2239f14dae3372caa1724ffdedaa4f23c7435a5b26e8974eb22c28b3e0f77ecb8ebbf995145afb70aff7a87eb5c28b8dfc6aee06722d53a02999b91bb909fb8f7c71407e907df795a2adeeb375278e39086f0fad01550ce123d9510834c91ee553ecb717f9a6068bef5a8bbbec2000e09159139fdf31e4f91611305d45c2d9969932e6875a7e03bda0bf0877a01b9399abf2af6142b2dd3f31f66e5aa52a3edec03bb61519b38c0b66ba423ca26846d4aee008f5be4308d77897dc3ed704157334506ed611f0daccd661b12503f47aa32270463e1b189231e906ada62c7ea20a80253a1d9732e3240fe44fb2be9fc14c84c14e52951753dde3d85b2dbae7d9ca1391ce30a952d1de898d07d0c3fb6b3bb1af9e20221c6f335cb2d232f1da2f1e28a1de7ff1d2ca933f65988359eec549c64d9b40dac404f1dd940cffea9c0a1e5baf160ff1038d4b9a190f5ea4cc31f10a86a44848c4d22bc6d8a3380ce88ac54fca381fccfd70422027418a4a53d1def2ee4ec0cf35288466e22d83c8291b2a9881cbc56df2e6a06a7f6d6bd164b2084e5232027a925d3f20df5f87b64a6a6400dc4f5e0a7918207ac8ca307ae8fd7b28e9dd3042337fad93ea3e686e145c9cb1402168b11cdeb3210f0224543a768dc5c381a314e140488a2b7f32fdb1173a723a47fa2c29b412a1161ea11000bd6334a0ef0e76870eba0f1aced210fec5b99516dcaaa001a69580a578443b810a9cc24bc2c5161d1aba802bb9f45b08ed39a784e497457e3fbae6ca5bfa6e8c2e3e0e73858d98b644012c62195baa2e72d3f6c12420390b4d7f9ff0971a6cc928cdde8ca62763f2ac901b2846379dc79c5a1f30d67dee6ee1a727928112bbe3ca586bc547caef8d247b51c8b722f97d6ca77cd4325656c96b3a0cf5becd2200443ff561c79a6ae5e7188cd97b17cdb76201c999e5f2a9740c0954c5f89f710e1cc6fefa977b0c36814b6428fc8a552866049552a945e97840e0f642d761c3ffc0c6849aea997c9418d8ab193899f4608f794c43af907b91485653e1e66b2d9be12d158e375d31d41133fd419d6b08db0306d99f6259bc103f7e83267f1f9933bad31c11d63b7b03e5adb2c0d785fd67aff26b432819d0604261026b28144db5ca18079571639918e7230aaf06c982f92b967e5a9c44b794dd3e92271965e554c7cafdb7683f23dd51515594e5593711dc4d42d78d2d48bb03e4f105fddde0b767e0ef553218116d250fcd483181c8a4fdd8336dbd09449f9b7755f9616c162e8967fd2e3623cc12ac4646638e27df4944c9afafff782d2c1e8ebc74a6a33657c8a233f8c832698d2dd4eb45a19bd95b7cf8331927395f93f6c6b67902c5fb7e85080492f1f1d70cedac910fd00881cf940eca6d1ca685c927cc73e4f2e8f429796b1a305e8360465ac666801185067d2f3ecf5c1fb940ce49f443535d66d453dfcfd2aa8b8246ed28096ac87ab23c501a72418f83e352998be4a2622f9ebeeebc0c33565e1ea89c23086dc8231dc50e89f36cb5420b4ede52bbb49a583cdcb97ff1eefb25219a3648dec00c6fa05011b6876e14df9ce2f932042f3c5ce4180075af3d43200e793419215e0ce4169eaf759e8e9b04652541f6d0fe1ffbb22166636e144481d660057c065f475f80590ff2c87ff34dd319bac76b51097e052ed2eb810139070f072e7b3ef2b18a959833d2080f5f2d6e8787d4a7e015373edbde3bcfceb37bda9e9334191443daed2e620fab68f2128a231717e3ae033ae045fa2ddb8f3fb3d3569b51b7ba34e7f0fd67c39390791fa18bfa741ca94fd359704ab550a7d8eff1b9f0f60686055924eef6ab35c3236a51fbc95848f339907dfff5c46b7bec94727b948b6e94525795b891eb5ff83604923ccb3cc56b4670435415241b6326f68d9d58ff8f9060c35254ba6d52c415912f71467901549f110cb01d16517a2ea3b623fae2d797ef06479faa00172bc3b4f32a1646f85118a68e0bd50deb76c3428c9dec91328bb210b716c3f2eab7b57e96d9ad81ce53d04be4bd555cfaf09afe007a070f4684e95d21fa13b950b91066095bfd90a46dc6da9de3370f57f5d6a485bb80ccf2bcdbf8505c71c96ce441fefc7487c320314f5aa3112d4865bc69eaeab6af51afd4df5720f25f74dc93be8882bfb0b4ed54dfc35f519abd45a958b46d368a4571cbf27190daeae8e5208dd3735e71f6596b3cadf6a0dd97c9fc0e5854cba49dbd3731c7e60644d2cc67b936d29fd7d76694411c3936bbd214a75c7854b7a1ae549a93dc0c2b307a1d36f17b006e86c9bfb10a556bb77b4dc445b87408be716030622d4a44eedd50ddcb81ce02511edbb0250c3c6e2f6ccea121db16b31dcfdd015e08462a146ee61ff4635fe4228c335b62cd5c73791182062ee5f61a8da704dc1cf50a171c64618472d458cfb78c433716034d72273e8886c9aa29dbc446477e6952bdfa140595d7c2ce4bcd3d010fab958d45abe7ed491909786570e9deb8cd4cc138c4700e443f63b54c4ba53073efa90fd846bd27ecbbd444952e5c4c0ca20a05aa0b4eee3bf161b3f249cdb8b22a35bf0c1ba68a9a23018bb28babf6c2f072b07e68d987b68503227cf3f10822b714b4d674115f0f626c62f26bd065cb352740b34244ef89f4fb1717c8b77375a4164daf1eebde8abcb70023a1163f5aacd8c0e2fb34fbe5580883fffc6ee27aea98ccaacb7853451f1fbe05d8570eda3c28fe5355891ff6dc3aa623c22d76573b6d36fbd26ceff577a9f489b0347a8f5ee1173ac9ce19ff580bfe2a8d8594080dd95539d345b5538f19213bbd5d005adb2ba0476625d5b2bfd91516ec0c8988be98368667b7838a0ada2c535d5b39c7fabd08ce94d76747b2c34d5fc061049fb92e5a6702e4bda24c2acb0415aca77926066b7395475b20de5a919dde5d657a4c55fa34767d57b493213c6225ac04690dfc1075fc72d41b177b10fbc5327c336835b7d3213cbda1c858b4a2edbdb6837ae7459d27b1b9759b57a80dfe5bef55f65261bb068fa032122189acc9f9e032f666b6ca8d317ce99ec7d1b89659b757e9a03324cf1fe821532d74e5787e538fad67ee8a99cb46922cbce298cd176d8155043c446e4fff02a267c6122ff02c46fa4609af51e46940cf24b0b7117bcc483ade9d7bc9ff6eac712b014ba0d6b998781fd2fb665469e2aa49a155061742d604fba94e6056cfb735fc3406815cc4f6c0a68c1a0cadf0027fc8db949cbbe6922b3ec79827cd383f854a3f5ec278e15b18db61e2d23ffb3c729c7f7e58bf7b7a93fd01100420aa60b851950c83e97ef3bd33338078402aab6ea13743fcd45f05e0ef304f6461855cdcbafc9b45ec465af2de428d735993600592a721dd980ed45eb9f2a5e7e2abfb75b975fabb6af58425a16a86198186df0ffc5946d23b1b3adb1cf2e39a22fd9300a73a8da45e8fe3c2728587066ec8f14d936a909721e41601f1073166dc8289dd1a32075ff76877aa4a05e3f3735ff2c2c0ed1c6532499ab79b7e1def34c460af6dabf242eeed267f0ff8c32513b6d95d1c549934af51c27d1797c17a242dc7f0fc902da6353d61511bd1728234529ea163b77c525ba19390f7d7d264f153f409b65ef31bcc69223f12c98e3a239af3c3dd8bbb3bde8872ee5aeb5aa87243925e29fabe91526eedfd00f25c7be0dd772cbd221a41d226290d08d67c0843dcdd12af91b49fcdd79c1c9fd8677dc44ed632a6986725fca48db7cd3d32872ab342a98ace2b416f3ab33936e2bdbde53f148a57cb74defa88be1c2bfa058b96dd1dbb2f36b4d5286d6e0770a75f09785bdc0d7447993ccd49380645f89606e0ccb6236ebd4628b810d4967924abcdba65f7409806a0546a8b72f1c7e7b4488c3ea3dbf9766451eabdce9b6b40f036ea0ebcc0dd355feb38bc54b66cdae9200b8f68cbb2540d0bd7833d711686258d86b0a37659e1826f4d9a86b9e79f71834013b1a4fce90a4df75aa323bf1a6d2bdedd44fc650152cec341b39856fcc7302d2a34564e3d1ee3ca01fb916465a000a96b14c194c541c5a6a29384e0b84f0046ece028a78a9d32f0ae4179011e5c3cbc1e9928ac0a97d03d9e101b30e0ddf5bd31cf5e9761130ecc848cab4b1580a5a02bb555a1c3dc2352f1933f4d612f146b9d1369027a8498227a883bf87bd22e5f1f606e08b8215a206b554b2fa53dd93e0c36d0a0b9aedbba796b77603227015f0b8fd5f7ed91d3fc4fea7b3d5521933747395900666daeb4e4a8046415dbd8b2b6ef2a169d147de62a1d05ca42c1790f328184e2c20af9a32c914f0264a7479ef948181481ec7be4969c2d1b7b76febaf10796bbdecc705ab4579434722bbfacdd1c1a28e690aadd7e1f0d7c9c332923ce3786eacce2ee3719ec6f4930803808f85c78ea15053674c5789dfe36fe32293926100f421de412987a922c3e379342bead2f8c5198155408241f2a417b8f2135fef002e78db049ae0ca8cf668730bbb9cb859222fa701ef4f16a8e91bdbb73fd5cf89401433f5cf128f0095e019889833c98da4c6b98fdeb1b2e8d4fec9fd20146ad76cc82b2dc2ccab53fe232411869dc93859031136766b5f53e828e04a436a176763de75c8cf2db43c1461816c59235d23ec803fc0e255d9e7ce5e299bf5c3f86f3dbae80affbf039800f5750ab3a22f8c71d00308a753cff3679c171be39bd63bd4c0978f2653657fc9b2c01b71b7f8a70669d704452c5cd529cae54741a03c4704713cd5214d4d6b589e0c384fa3f615ba6f5513ec40e9b4ea7b36b5299039dbf2f817cd6a5cd1f9b13ef00260728f8f69392269a9786585d4bd26b38fd88c82b280e1b9e9189045e0e924cd4cea54a3da9294f06fd05be5766b14a1517780374edf9e9a6adbc7038242352117301b63c1aa605d8dd7f222f1b732c0b1873547ada8db08f182b51e800c70f0a82d20b3830f0d17187419e15124bc040db7570170f25af6ec1eb1921f79e7a968a15823bad078459659c299b3e952bf631214de54a6a25f5a25e10657825bb4581a6b24f562035a9cf407d0be7c4b8145ea2b53c5b39e6062530dec78c06c4fb57aeeaad37361ca1e8f9e81c09902eed6d3476dcef49151c98e8a031c7fe9bebf90c9a8b62e662a1855df3df35f0957f6070032a9981c23a96e518cdabcc75c0302be156e4f1be84d90d5c207d2623b50963bfeaaea418fafd6d4e0bdfa5312f05c54e655724e59c0c91995f05c0b23ebb7c81350e2c1dd0d3802758ee6bda19e3fd8c701904ee323b4ec5605891b5c5f6853b25943a3bb51d757f5efa48332413ec1c5de38c84ddb73bf67368e601e6fec2b31b1239b7dc0a503dd9e5671945bc5247b7bee63ff0ad3559a15afdbb361493c05b17e661c65ee89dd16b82edaae5fb31f7117e3d773068c23bc8da1f0a7d3cf8806eb87b2d5296ff9cb8729e1f3b36b0828764d896a0bcac3d1069e0524c0b60a3280bb69f664b9295b0eb64d1aa2122cbb219c4b66919f4d8255454cfb8899f1c9b2ea745913d0f14c9dc78b29a636f3ceec5035f786a3d277d80d40816063bdd667c1c2f2aa64fcfccfbbc49d69bc6a2e64ac0b61e807d6debdeabc406de9b6d51e0b3e9543e33be75821273f8ea91b60276f719acac9fbf97b250318773438fdca8dc6e3920fa2a1e66fe095d26acba95ca83b0b745aadd8e619661639c466156abb8323885a85aca9ec3cc206ed7d97df8f0e7c8823cb6883544f5bca1fd3b7607f8909b3395038bb9d5e35a7f12c06330977780779a7a2410088f32c0c805f1304f3ec9a6b50644e48e2b714a1b70cdc73f69514f1fe0d6bb6eacaf20044263e5541389f78f98f3baa4909e5406e13cd4b5c356dcbe54f8491234cab8aa5aca49925e0897fc2678f1e31607d07e0a51163f5da73d8bed62567b19806bf7a101e05eee439af93755b265025e00202d60d5abc817ed626c150344d5d449cec2bf51ba9d6e6eaad9a9dbde0b9e6f450e729ed9906c9f71d87185601db07838ec5088e2879c0dc9c090230e3d22ba7627c90f2e4e4ce4cf16c50b13c75811160c5f1a47c8aace3b097e82dced209e63c2a308fc2c38e9a239ec0f8c09cfca03d19012136da126556c7062e1d8eb8fdfe738ea42fef922dbaacb8b07495fac4c11aee4e4c28d8a89ca3fbc630c93aa8e9f90de37cd50f635f8f9ce4e33f8fc3282b312e8685694d700d1c6bc4112cae795250b01c9476510160a5aba08bfcd404b87471c69be634eaa156c4e52cb75af673c69cb9a3f3df1e2cf2ef03b17fce48412c3f9ae6a58312804981abfb82a26682ff3cca4a2e17c9faca6b6ced75530907365657a5c3bb497d00f0f4cecc79b696d35d0b1840d7fbd7e058b6a5871d8124f4018602acfc34ecbeff054d0aa54a31f22fbbba0740eec4f8b77cfcd79acbb5399ebbc708a60229b58648b81c088142885b65a45f82a00b1be6d8ed7d45c07f199e669f6938d75beee7bce91e0f56cc5397c568ddac9620175b97bd3d9bcd26a702f0a72c14e9d445d751223a8b136e250892726152b3a71eefd1d6fa6f21898ed8f6b0644e3cf5ca56405d0bfe970cf387fc92a1502bf550a87f2a6a89b99571d867b1dfdee7cf5975a39ea21c56bf007e1c08fb16bf9c0a68a8b2752625c09fe002b9f709c2bd37dbe2f3c9b75502816f3c12c12c0d2953cf5805c605ed3ed69370defcbd9e43db6e3b3daf2ece1b0d8fb4ddb9e1a980cc34378dfb7db91def676ac65ca8087daa64d4566e1c61532c7243fc5bc53e1001a316e2dc2f65f223fdcfa1f02889ea468a288c607a8e25df6a1645684e1a5097e8696bfa1a3f0182636635a0abf8cb66a62a0bc73b47dacbcf10412c581003d65a57f780a8df045a9e836cb30e482ad79cd9f1fd0ddead62945dcb31a6f269e20b24185025547649f415d5237ba553b0c39dd18b68d4640ea5411d0d5e1a0f91340d5de7915dba4d990386952a1612d3e8552ff0f2e8abd220a92f3207a60e0f6222aaadb53f2adf23a17582f2852af1493458abe7fa9dbd124d41c31b046dac57cb324e0ef115f249e4473a75890cb88b4d96535d7388bc4b3c81df7aad206abfc0805b077ea9f797a634d2375ea76b237bf58d0ea01277b41d0962e7d5dad4ae9ffbda641d72f4e5f021371413159842b54638976366b4a3d285c10fd4eabb07ad08e37ecfbe1bacec4cc5bf65c78917d51a19e5369d7a412e0b2aefb665a7316516658ae1665262282874c623ee74d56d7440010da1bd43212c5e65a7de277b4f61f429088ecc2c9bba62675db0b5e543d2d1575924f61864ce461ec256c45f01c73621cafe9b24af6bdf43bd016c97cbc15741ecfe95174f3b3742265032ec259e8f62199f869e5a573aba954dfb5e0ff8f9feb9215ed518f5f7c758daf0681dfce3aa98f2f43dba50a5d6f7ef12e4a90b522101c61ff362213079aa41f6462e54a03b15e1977b87e65fba510902846369f6c2c3f6bc824600ca9b61ca68736ee974983ccb18d439c9af7eb2edac0a6f81340a4e514ad3157cad6ebdaf47b529a564c2a7f88f409c68b2649c30dc42cc0495eba6a32a58a73d200f3c9e3f4b493572345039e22e206cec83164958786bf1279002e341c28952c35a8aced0f3bf02b0beb34d7ff8a345df7bcc67e9440f30195ed11c82601e0087191e31c45f286935655c14180a52c4a4a6936a174d97f222341e9d0bc1acc1c31060e7ff0c07e7149327642a6fc67669f894d6b1d61b59b385ac193db9264462ca523f7eb6be61cccde11e1206eb29d541d7528ec586f583f15898deb5058b6e0396113901028af4d4c9a67561e5caa4b438a411480a642ce759f27d10d8b5b46ce72c87c8923d9414e29a14d15203814babb2833319ddd713680a99f5b4702931c78814c2541c76be82b9268cb902f066cd7b0c5a5e41c56fd8ba6883943eb14a3f6265ee2491a053f37a6d53e4e7ead6960feb5d2fe63d2dd855414b52942c4bcc81c717621bf1ee78a855a75b10522ca5f013b9ad3b5a5d0fae9999faccededcd5c33f03b79a087fece676d53667efa627b11667321f2baf679a25175c3edb4f133dffcee3756e665c293cd85d7de84d21ded50513d09689eae77a412f77b7ad6c94f209cf72fc3375a48b3d89f99ff6adea0cf156187c839cfa7de9e1ed281353bee1826254162c6078e17057a0224157a27fd2159bf315dedbf37a4a5044e868ef3c192b61ddcc51adbf25d690a5bc7eedda6b659d4d756cb125a6501816d0bebff1a382f6c0b96be240866fbc3d451774927ef62a71b292b63d6cfb167a27ad9154c9465d4bf148ac000651b01ee881612f3551131462aca30447624683ecd6e2a8a0fc87bc9b741dbba01198a5e05bfb454d4a886d1f5d0e4ef0a451c15883736cddf7ddfdb6838f0ed69f545db074bed99d1bd58e310fe3046f3884f75e9d79018da82a7ebb3ddaaa9a9574b68b0a5fe5fb95fafee3bd633c03026842972c231e7bf117415825c05382e42e0d98618de8f9c422b270d6d8fa0e422b2eb8b63f646585ccced55d25441cae9d191bcbd65f60b4aa727252162a7372069ee70030399fa27f41c6ae9a06b2695807f7d2d78f993b0ea54b5fdf4c6db134166efdc7a0be08d560eb0479796d7d828c52818e974f6dad7631f3ff4a2c2db9d5602b1c1a075a19df200f0f6484ee7bde3841a439661982495845f630bd154c9643c91fc9d1e15150534ff91b0e336f5102f727faa465a25edaa66f1b8936110f8c21f8e8bd138c607905a956bc5e2cfa08f534e7b6139a06338fb90ca32fbafe74eb0136d3cf66b81f1afa4ecd9d2051ffe586550536a6e3201d87189fec2b44b1acd74a1fc0f983c07e91c74eb5084422546ec988f545d240beb566d085657dadac737e7da9a14373de603640d055e8be450ffac9da95d65731a64f467ef42883baa3e82634096e4e16d429bae7ef41e1632fcfbed3b81171984d0e152f501d66f1217d0c41d979d3e220edcd647a630b1f746b6ef7c36dd2e9c607239e4835c3d607a9c7a28652c06f348e847133db217948ee7b407197323ecfe918de9eb58f8a48e697ac0c85ec7f590361515b10b546a43834a86820a8b306b5f0cc6a198f063e5c7b056350c185794f9ccb20afbbd2457aec3d9562d18cbcdefad00671e58a4036b1c2254c191bb7199c266156a76c64246b9fefb03209f7b8a78eaf016f92542e22c7885fb81ec11ff5105101b4c24d77b53ecaccc3f4b986189ddefca5ec54ad968992cd6cd54c9d6889fefed3dc330b5bdf7d5dc13cf55fc603a1fb12d0cabc7fdf1c6fb3d66e92fec93eb778069ead2df5bdc7862d087875be4604584e7acda55c4198695dcd495e475d117b6c3719d6b966fe2320be10a46d23ee363bcf1e81227c5d90d2f46cc5f6e732ada76d5676c760be0dc44649c1fd67c8cbd9ce66a3b2c23fd8ae3e845b84a9d9e761f48b21ef95425f58e6e5144f40a813addfff10e17c0db02b58ee869d0c2a2516f7604130b84149ebfb0aa9d7ec7d6ea977c23d8faf7b6ab84c67106e038e411c8c486509b0d8be9b846a1599295fce422924443c31cc7a5f227a96eaaf0f3962f09f2da169ddd4c843e2e71125cb95bd87c71283bb3c1e0da2e0d43b69c7e596a3d056b69ce449ae9cd101ecd200aa608ffeee9251494b9ada74a972ad21a460e259cd0655707ea685ad0d508f8b68e9b516c166b94872951b99e2c9a57887b7764301c19fb65572324ecc60ff568f1a487bf385b1ba86facf895532642553656cbda3fab5ba3fbe361e2e197f6ede6f09ed24b7b9ba211acdd2e56066ce7aac61b517fec3f7554391f1fc1023c297bcff218f89c962ba851f5d5a6a9dea4cd9f79760d40555fe6b5a6f7824b27af34df58e1b25800083b55d6e93371143e8fda48017d64f1854a9f17ddcea7f1e0cb69ce4a9ce4a3be3621a9f91fd32b10eadfd98637a55b94081c40a555a4d2f628beb10541886ee2536f5c3e361cb8bdf93915981cb1d12bc1ceac309c82af387401f184d3ac559939115b811ed70b92ff7985ef1a61711fd12b2accdfd3ae9efc4783bfafedc68f5214af6cb13cd1abb227150ab6b472f0b48c11c2caa255563bce5409866520c417a87f609810b20f2f64afe3c70cc5b845450cfa7670ad8e49ae2ae356a4d6ee847b4c708be291eb08cb7030367c1fda4c742038a24f4f1d0c2433893ccfa8d64a4bc24ab3ac6adc25688a8536f2774377b73cbfb0e4592f7bd492b23e667d047afa6458dd29f320a12e02560413edf712cf809fd40d19a8c1f5e2175171a1abc856f4e499fae125356e34bc2e4b96a927a83270bae92a2a5e22ec3b12373ed35c05425534a353d8bef817bea3194e3ca2cf8b64249e1df81ecbfda4ec0d198071387300185c8ea5b1689f4fbca37c754559e30ab2929425c6842c7261c4e83e50147fa232e7d260eb999647ec70202f45927983932dea4f42114d69a357f7c9c675c504e63e458298e83e9ac67e3fea3fc41274642f13673c700ee0f0644e48a37740d13d3e7ef2f76441f675bb65bb5be46fe68bc8d5342c0f2c2606e33fd2dcebca08b3edc14c23d2457a106dc0154d4e3f7a6a54dacbc40d56051f74585afe7326160aa901d76813f1a80c5d5231072768c1f9d68b70088e321961076e2852e7401f2c0d76c8c015564de95dcbdd5cadcb464ebeddd3a321b6e1b2909eef24732bb81b1e8bcede7214cb309dcc483a511f0c82fe0547895de9947ed3bfb571df4aa483d475d7ebf842592d2e7d68490f24fdbfb71ca68d4c4152218bdefd9f3d9ad08b4d034f7ee83327385d8bd0aa4c24932bf5dd02c863dab9a17704a2058f6f0de963fd47fc901aaa3649607e584d6098629c09d5096b7a79f9b93cedae3370d736ccdc10fb16ee175a6ecd0ea17409ee7c8b5702426ff4bd00042744802cd8e045de22ed545a1e47b938933e1d200c60599f45624e5d85c8c864b9613863361775ec73f44a2d10480fb3e9385aed2d4b722977f2a7392737da8cdc5e8c830e022db23bc48ce728573b7ce0e6a105391e62a336690ae7cca078a2a640131589686c7e317a67ea696dfcec4f7807b9707261bb7eeb72fcbc03c82c382b6461972db7df3c3245e48f4f86ac14429e3d0e7fa4cb03100f630b5653510b7957062386fb5a71c5a0d4beece635d655006269ed74f59eea488bc40538ee06ff1ba48ac60e231bc4a00617efb967d63fc8f831d49f8a8bce231257c527a6037175959e860154016e0b171cef1f0ff7b52f6e45a5ba075e7c599c396698cfbb9d9f2d46122a54858b9a323b7c221596c016b9b2593bdd3d68a8c6504627a596003db05dcd4b480bed9ea2bf6cfb34ceb25361a90c1c592db946f24c3ba58a14f2401f6561b2373081b8a0ceee58155424ab559188ae4df7f40931d6c3f92fb332147903f5b44c00573407f307af3361d02663571eaf6aa92e2f83b1141f74882459ee9ea25963f69ab250767737cb394e6457586ed471f9dad54b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
