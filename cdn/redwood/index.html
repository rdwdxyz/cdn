<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"038a35fd03afc33036f730ad0afb59e3c1e213959ed4c0ff30e94cc780487985a948796b9df49362dcd1c6f483aa4aa7eb85ffde26277853224475d7046768f635c213bcad648d24bf64827947929d1567c84b5082c1f31d06eb7e200ad5fa871b9f6e94005f7962a4b76aa7073dc50706be22713cc6e2733cc0b8122066c4aca6760b6103d74871d0c44f1bb4dbac9e99f28980860b7c15f4fa94799a30a179d8e5005b7aaf66795d7aafef0052c2a0e8a49e7e7cd097a44b19fa34db6f0ef2a1d3cf985c61ac7f66c2e6c4d504756ff026c94e388c0f40429601ba0a67d6dbdcff40e05398903ffc602d0de6f795ad583052177d46bd71fe74268b496cfe563f188616995eafcb959c03c0b5cb4aeef8dc157069c442e390a7d5a0ee53ecef19e24ec253de19ab50bfd940ac0a89d57e72a92939f266d167b5c7bebcbbedcf230af1372e4783066c41c5843a37589994910ccb6e8ff2ec095b8397565d2efa815a1b40be89cabac7b199a545ed329fc472baa4c926c61bc1b250fe55204ce8f57b76a7c8d8cf47671171cd3918c81cc11fd6eaab60cb0fba3f18bd56ae5da2eefc1129468d4af19c71b65abc62a9824a492805f5d02788644e9b4ebf77078b41abf2802b9b84b5e35a629c7e3deb197f4591d037fec5729d284e7b80b17e1431bfa56f5a352315a12ccfc2aa316b8ae096d6ea1f5fb5e2f7fa3999a8f2fe95f1429ffc35307dbd313521b5a29af7a9819c3742725e9691956e96ced4c600e174a189794d8cd7f55a38b8d1c386766b1abf6f19a8152c25f491a5024c9d60ee65317f4e365c80d9a41ed16d7ec66f2bdc583688bbae6e4fe1c26d5dd0aa8f9072be5dee4e2ac7936e10fa84b78d92713904374270aacacb5c9bf481a0d93ce3660303a8724f81cec5e7fc0547178bc44b70d36a1414baf71e2435e20f3cfba8dcc2c3e9a84cf51caa0953c0aebe66e1f5a74949a7f4c0f0a10c293fa0576e47bb672b89c2b72fbf75059a1ea952cee100ebf6d23a55c9327626524fae772fc369da77df81de5b4c7d3189d15dcd92f3372cfd9aceb155b7b92ff0c42541deefb4169e00f15d7a07c44b9a0d4967e573dcb952354fd085f28d74d4307112250ba23db297f8f50beaec74ee9f9bb0a541f24d1b60d2d6d7da623550bef985fdb484609b1d16e18780c117e20f28e3be5d25c78e40b24a6e2bf806453b9281cd5a7dd30b5b46c91de4217867a8138b970cb71460bf73b3eec4724460b463ce04291f5d261efe02d052969e52994c600f501593fd916eb49078ec5626cb148bce28d2abbe182e999cca91f90ddd30f4c815e7bae875638ab112d3582bb996747ce5c6357bf213176ab997ddeaf99b2662bcb1ee93e821677beae1234c0e59926469a6cf75ccc29d0008d21c7feda4cd5fa7328a57732606889cfe76e745252be6fc76d1e70934e957cd367212aa89f5edc1fda6c05895a76ccf698e1bf188953781d5b4507c015b7c5a25b6cdd963076c561af0c0a4ea0707c8968eade032570f2f1d3cdc967fd66f108b208c6700637ed912da4fd7f1f42fbfe645e2b153d6763aeec585b19ca1a609727832797761d317bddd1b59ff3947cb070567631dc67a7c279fb3905db7e7396c4e0c09b17fcb5ddd1eb0f9c69474d70e620f6404940ccdbd90aedec3965966ac075b08437b7f955c361cdd46ac00d07b20ade03340af8fff88209ba0cf230f9d03d1a1dad7dba68cab8592ef964f16fbd367c9bc0b6e1b4886d3d7675a4fc42057c0984d63b45bca1b44b106ca5f121aea11d2e8f09a27b1fcec20a969880f6d50084bc65a993400cff826c8122cced297faa845640ab04d2add0d3a21fb1041418dcaaf98246c1123f38ed6e1734c56166ddebe034c8cd888ac794766a13ba562f9a7942e423cd4b64748fe8d65eb2725764fc084d38d6de54793d44ab0bc9fac53a4955e0a4990201c4a1dbc69bcc0a49ee677772b7ff6900b995f81f9e12134cd89b8112a96ffd1ae9363ade9f064e849d9f059e1c3c367deda3025a849dc447757e34042dd49e45b232d93ee953f3dac7c860473a94c4a02bfc09dab2e53ea638623797c2f1df927cce19c80d1d76320011cbeb67e55da4248fa8297504812b4188f9c98ce126bf5896660bab2d2749d10fc47a101524c5402da6cc41b73cb0a16ea9d64e07b724f32134d68c74929677be07b3570823d959234792d5f56a6e5a32f5872a22a0141be7f141a1bae966e4a9102c55ab7c92f70db3bca1ee6484090fc94572607427b37981c7a0aa8de596e7dd8f2529ee0179683cb2f33e4a1148040e17a9869d2e1f61d22259f3a1f9e7c908d3983873fa8cf9c606101a9b754abe1088e2654b54c11b3d071e0f244faf8d25925fadc15467ba99543a240db584b33d5c0e40cbd42d6527a08217b493586497a86047ae3e0ddc0d992839debb5f2864dcd39907045d362c607dc6036b015858b40b55d3619d13949353147948838be4b80b56a12cf7410d38852624c436df135cb78f4e98ac532abc6a705241ee5471225a0c71afa94dc27bda79d6b8805e0e9443a79bdd1783769ee9a5d819ef20ef88162b756f595d26abaeab4ec766f634dce0af6f30be00499ffba1dae5272cc56f61b66d9dc92fd6f691676982f14a418da5f86abbec68218db2aa4d73fdfa09194d4da4018785a98529c88087405c3be675dea179ec850dff330a975aa70a38c00293ec2c9bd3b4d00ffe180df3cf74a1a60b1d01a8fca29ba11d47b7c1c3a169b98e49869ef428ee76db95bde9319d363b2f021d4459e691ad7c170b624ff5e5f0eee3332fa091897b25974cdcb3e3b3ff5067163611a884da95a0f00c5d0c41b213ed5ba76ee101de342e2ce696027d3c38642a93327126f8f5a852984793dadceed7a06bd097d1b4ab20970140158e943bd6b5302f77cae3b0054b51fd2cccc08c8ef66244f6632d7fe6e4d7d22f125b68f0b7102e78b4182b3e3098c04f283069e8f4518bd0b54f37b32c6e2dd8804c61feda715a9343aa0c0ed9513097a4592801e76839aefe54178a2d6810a301bfb7e4a4c3d547b2c756aed732c2519f4fecc6b4e3c322fc0207504db433e7ec50c268dcfc6449eec27699c1f8a867a9b2f3206428afa444e1762c60b2af315a29fcb441f15cdef4a7ccca155949190bc006f8788874beff53995a4ff45d861b50b53642b19ad16e528aa7c2cc624c46199713468704a21a86bdd154a08260b5d5afc8023f4f964ad068f3c9d142dad25ad1c8f674c25bb7fa454e44feee10df8c2f8501ebcce1cd6c920ec34452a99af9fcc81862a16cc3922524dec66e4d7872191ea0e4da039d2e72785982c4a36f95e564e5a5a5013458929475e29f04c80bf4dd084472e8498ff2c4eb702fee59453c1233ce11e5c9a1b27f54e373e9c3ee14b56707c9bf3e31ee4a4834792064cc92b932696c316e531d3d3217655220db9ca6a8c38ab1b1c9d6ffb1cf0e45a4c05986260ff30ab265a5f5cbe2c66b28db8004bd349e893d2c890e52470d7fb51339e5daaa02cebb8d08df956b170cb3a84e44e4da8b1eb493ea01cc177ae0b644962a165852bc8e08e24d2b1392eb6ffc44461c6c4e4ad7724c711c02f5638182695d6979cc1bdfce3c4d6f2bc0d35a6a68e9130b2ed50a1024eb3b37af6ce6cb07b6dbf51053134afe59050d0b4efb3ec0d8bce5f34bec7389c0136ff1422518d6fa5f82dfd57ec9eaa3b4a45c55434e28b5abb1d99b11190ed1d005533a43c6c721682f3cef32ec870310a8d485f0ab07f6de47a069b1a6d42439b53fdcd68056b38adcd6e172b5c64aabff233369a5ad51c8be69674ab28454115fb7db4b73d82abfb759a4a24b60b0adfc47b4ea9d60a55e91d73df3dba9b2940e9e1363bb373b5a69cf49f122ffaae8f3fd6789a62d241ae1a3a6aa024149bed5f01a07cccd384b1f90d04b126f6f24c25d3ba2e69dc7061307a1fd59317be8b98a3618367ede13af1589571c388dfcdc07d3a4ed508d437c47adf94d2571ff5a6e34904d1bd8419f9d7dd442d49fd2c1baba6b0c5f5b4df5a80ac39ac0a431a30759c86adafa2275bafc83ae733e62b5b4febec953ffb783084d5a4b79c0969d4998b219f84185e3273135659e893796a957e05a394aa3a9f74b080ee12ea939543015de715f783b02b6a954f02344fe2ce638a34dc066eaf08811debe1684604478710bdd1d6bd63f51be4129dbdd3850062941bd6d34fc86332dd0e1e155834a92483ec272c361006002b04c07b88be8544b243c54a931d2fb872f311eb80436d9dfc02744bc9f66aa199ac61bc3753e48f8cb1c69aac4debc4cdd03a96dfb2148d7531a31a3654819c19045e9ee8e62b7fca7813a800c47080a5115b388eae4aef9d64eb16069fdb13ad580ca198d6356fb70c403e119d281c8ef02d3046e253310f76e05cb4c8f3de5fc2345bf2db630162bd1414a1f7a39bd2ce4c5f2c9af173e03f7d59196ae29f6217cbc9c00f721f49cfdb4420cc5b26758a626906cc12b81d8451d9740ad4d167b8e106d3aa13f8167c6e1a2890db8516e3658695c3321a7993cf0e7bfcd67ffbe732d4550e52cc6be5713687e11487b19c2e8ca603aa99c2cdff65f049315656bf7ff6daef05029ee679b1c2ac61e182dde30c73667110373eb6af3ce97451f9b9515010c7fb4b3e2ce0abbb74358ead520cf02edda08b0568d87a198075fa17f50f85e0ba7dde0c5aa43118c7e89b501d0c6f93ff75fd4aea42156d6b12fed240ef26f2871ad894f86ec9609fad7bb7b75500adefcb90eaa43db61050ba946a4f8c78afd0490a696e4d5b27302840d26bf588da12966e81fab71d30ffd3be961a76d0e8d2bf57e124857ea868754fc9a4982050707c73e4e8b7a1a0fba77060c6ebd847ac4e420d24943eb4f1ed6a154d2134a1b7669631c2d0ea04bbd3b63010b7b2eb935fba901ac2d55bedb49cd9330d7e028b0b1598097ff3bceb7d50fe31e374e0b7f5ac153ffb27b41729b5447104b7b3abd3a3658e2b1d42aeb0b35b33f03569a6668261df929b272f3cc103242325047c7539705fbddd3f0ced7c33cc11195af10d86ea2594d916f0d3ee567a2dc630bbd2a07c9519e5006f933e12e9f8d3c0990d7a8792cd4ff632d2fd3b0c37c2c35ea18c0c2096565ce0a7d18d7ec1bde143a5faa38755657749df66caf046a4c3735bc98241d2d050681cac5f018f538566bc0ae3ea1b2469096525d72185f4cc5d4fb673a028d4f85236e44a0fc016caae62e9d7803144e5d8159cb746fd6fd78c9473b698e60dce823b651e7debbfeb651c7a7c08471584a0103bd663afea8bd462d2a236f91cca0f33b35d003a096157628afdd495a238f29f61aeb1b04a4de171a027670dcedffeb6d49db78065266639827b37e45498ee7724bcd63a01b6cb3e75a1e4fa7dcde36456e04a13b544c7433fc10dbc70bcb12e345bfe9964bb44c7353ec0fcc22e100cf552207d337902c66b898b0db04a54724d0d0b3199606a60caba25055608d98aa26b7e69dbd734cf4b6088aea3d746d68c49d5f7bcc8deec4874878cd4954abed5f138f73c75cc6c8ba04509b3cf52ea8bd67cef6566598502ff35af9dc80522999f7efdd16ef0eaa2eae1ff01a1e576949133e9c3cb8f50323e1de8b66a15bc2f65a2eeef85534c832c2aeb1d3ddb72947d560a82e8504dd480ea07fb77bf83c252e980a73104a45251cacca981b975a74b4061c81b6368db78d0d2c26e249eb3c403565f2256622e8580e1b8737d52d95ed4a4f12e84af88e0fd0ebd250490f9e96a42f1904236d12e598a4d3082261deff061367d1438e6bd9ecc513e6186dab85d5029664833d7129d4f042fafa357c9195b4b96855fe31cee146dd89c62390ed890872997027f20ecb14108a9ec14a9becbdef2da7b20576c195a71cd3ca674bf96242d149e4f640803a2db7bca721c3b9b11695a9910c75d378d5e5754c228c9d7dda5b946d8118511b433b49431e8aa99d51954ab68f41b64552e1542307473a0956a5c3c877bad8146df0a3f98ae76264e3c01a78dbd60a587e88516da36556bdcb36efa510f3e409bc8e3a636173818fa12ec6b3fcdd6b191454b9d24479d13a93548335885a153aaa2333ade0c6091068785ec74ae4757f3016ceedf1e833993d5785ad9175070f73cec09b543909f15a6403b5d0dbdaa839fcbdc7b635652f8ed13647f8fddc09ab4bc6e4cffbfe677789c0f9c19b32224685c81921523dbebb652604c948caacfb8b151b415b7c653527ae81982f717586ebc0da6e93153502d7fc5de4b26b6d3257d6b9dd3c67eb7a216d9a90922290524eb871b6a2378d6699be1bf555aae204801d2af9387a5d19df49d4fdc5ea93782a5ee876c20163f8367d130d14ce8cf8cdb9fd303d9a7f7450f4d85ff61af0a66a6b5540e28bf3998a3bab491eeab0e6578cdc3e9f3be07a1b7e8d0f933e55d2240785e2c6649e385809e4fc7d8bcc7a350fea9cf79eddc8942e7049535e99b10bd7d658033e7dd99866b1717757f476c35035ed8b8abd6f58741745231970e99d8ee52b9346fa00b6450f312268a3b7004f2d9f621b43c95e5c637585a82a9ec40684223f3bd8ca668d0027efd055306cb21752a45f3e9eee21d46a12089ae317fbd699775284e69d0d13311bce365589f4af192035d34e681ae26badc9c1b5bba3cf736f21dea10d7b2663baa05449390fb255d84793c656de11be039725bcb41ca9640fc5cc5d9903fbe99ab0b668b85295eb3f34a9a4f05b820bd16511b545dd29f350dbaa13a466f4ed387aa6d40f2cbc413794f74774df4b46c35507686021afa499b7fdef2cf7d75e87cdffd5e6890be1cd8b5738ae8a23a29e6990a4f238eadf55909048fe85c713b9f87dfc6d2aaf9d47c0ba51ae46e889126c241dbc1d9cda6ccb0166bb0509d73b90586e45ab5f3e509f8b0417cbce2daa17cff39bf8b41c04a30392be341dcbaeed648dc0a3aa98a5e6387e1a92d6b4d82a52fa38774803849782275ef3ab8fb746b967b1253049a7520c1524fefe2e5d0c60fbc7be1774a157582bf6c159e4dbde54e46dcb81db6b07e76bb4d37bdd568b1186af9956b858a1cc6ab0c1f5618138f275db7e1d0b702f8cffd6ebb8e4dd9d1af22c6a56a2aa376aaba7034b9b18d02c911119e69fcc0d59029d8c78ba3a385ec2b2b8c0123558369b150038540832417630643f90e07b404c52f657efb6218da43d590e4f9dc545de1e4fbe8df80b7f33ccc2c9c6681e639f5164fcad357dcfd9058e3d65c897aef9b71d857a85571adc4c9a4e6eed0818dd0dace8ac01f552fbf654aca44192b973d69fd51e9a8916ebd18a09d1d83958be03e08fd1c294db6b41cb3000d7cfc6ae87bbca755f9148af3567da41fb1ce6e0ab57865e1f4ec42481cd1156a31fdb482a7fb7cad0a2e55d19be05f016082ec1e169aa423da8f2bd6d42e50fe8e7880eb64880519d15d9c28c4f38ca83b2c3bd3a6ec12c3f975d38eb37e3e0b8f886f5146c71123d6a8c67815f6cc448aaf218df087a9a3f94c4aa762fb3680224ad1b74281b55c1cf2a67afdf4038ddc3411ba20f8ac324afc30a63baa497d377b8e457eda7c9f8402e066ffed71c398d4b12f71eb2fedc80dfce90d86c4444f136a03a27f4e5388cfca5a62ed8c5e67f899c7e14d5900583a5882357c728198252a4892f74960d28b00e2770a8d7ef2d9722a7e795082554afe7251d077c37e9e1912c0dae9fcf12a500ea1b576ad9f1deb57f3047ebc1eb10f89578b4e1f7e4cd98409eb3c2fc3049aa291953ba1355dd7b11a75c071b22a5e9d8acc3185532199372bb4b631f8d0dd9e1abec61cea5d130ec089bd73cb4125460b56de8a44dbd98fa5a7bc942d07265cb5760cf331ad315a394df86d5df02a4dcfbe0c83e45c8717f77a284b74a9d9576d26efa48799a0cd17579412ad33b20a6eda52ab9bad089b737edf7f61625d3751edc2caee5571cc574ed62f5d5487ec2409877248f7aa2b35006966350df7ff3e3e5f6bda1bd9f3b5109b5d28d9245670beb9051031f594944da9e0c84b6115611d6297409b3ada74b2beac9cc4eb15dc66224633c6015ebde10d2d9e43ce7e8b0be33365c7423c5910621b2cdeb53467f7acc46b39610e43734a4815f5adfcfe419220eb93e76f5ca99db2b922b7dc79be1e61386a381293d8550aadbb30d1ab265a6cc1e81bf71aff09c7e53c8c30e53a6d1afe025ea4c43cc02768c4f276143143d7d0740d1396f2313bfe78836278dbb927af4de9b73d3653c45bddb12667fd2d68c37bd70fd34670a69589b951c979348222611f8583594d9728381a2a0a3ae3890376fd507e08aae7d3164b3d746bc7c0109102f39689d10926b5d9d63fb0a6103586441f5dc7289f2f42ab3221576890b6e33ef1339e836f11e6b1652e3570118d300a4f829f03ce02edcc372aed2b6baa41ac7f64125e65ef594fc78e38df8072b7efccb5e02be11ae6da8e73399fbbe0c4fecc223baf1eae67da243c4472eea953aa1640ae0dec85da284e393723cf071475820ac1334a036b9f395591e8ec145cd9490735f333d88c3226db8275c686a450f2c1b169d60b786feb4889aa0b76e01adff0aedc1c8b01a9b8fc5b3e33a5b024ca0562d930b3716020d4019f70d7cb3977516c1a59f5df98ca75559af2a290fa9e82dbfb7485fb1f53a10ddfe4d502c6195371b0bc0897e531d817cec66fd6fbb607eba4d196ddd18e231ba631d88bd33ac78b7c58618a56e96ea7fbd8884683b812b8f5896738841fb15699420dd70846e76a103904632311c78bdf9060debc13919a10efcedd67695e0981207cb0ff55ae35e71d077b43f78ae5f617d4ef7538712a793dfb5e16d8f63523af88e1b8b28783fd5f9389fe4226700053f010bf80672a2a6075e5a825c6f48155244d2222a79b61b2aba6501cca3114efaa34c01b41be0c5d9652e43c7400fffad8f8db14e93a9d07db85a51aecb6c29b3482371b4a48ce80cee05ae3674ce681bd3e2ce69aee4b3598a700af988dd8e7b440cfcfe0e28b667509fd48642705c2035c0acfe588d1ec3fb71db9996cd0017193ff39080a6cc1c9f7fe340fbe6f61d4fd8394ef58218b24bf2bd9353c5bdf58e354185c1f5aebf6d7f2597b3a239fd4bcf0670bf13c9bf011a2369e3d09f0d043526a503afaf23e322e89fef380bc4a4f3d00282667110e269f34243c8c199ae9ad2d5ba4aefd6cdb51f9242a4c22ea058b9a555923d7d826d536dddb9ae15f1acc04f6a2033f48f4e2a25a204b50d6fa3e1fc91bb6d8bd5c549ea51ea7af2e86b217dc72f1f0a969223f3909d4b18f92f09a68be5308545b1dfbecc784e378ab45bd7679011dc65bb930315a182e02bbb371b34f9d197735cf7573baba5d1661d69400a278177e2e903752a9fa246a79b7c68e867dbe10ecbecd25a4d07b1e762c7f28b180e33b79e244399609d9a78833a44dd8a9db9db3ad2807f954e3ef86275d968cdca88e84be31b81ee7e81c7a69ba16d25d0292ad21a01e3fab92567fe4c15d9e65f25cf5eac3412805e291f72d6b5332183557809428c1565f0f0518bf543d4f42cac99e9d13e75e217385e31363dee348249b8de6624f0a7b1608b27f32f13114e5168fa368b7bbab2d6b438d6d1c36cc79adc1776dbd2f04e687cc5b34e5d86c4bd5b6bd799953ede0f2fc17e8eef4b04872818eaa1e8181cb8ac5f88cf9ed95c417639e82335325252e0e58df155e8c9b2a951b4fcfe0a65562d7bb17e5836694cbe67d93b122ecfce019268f882716f38c3debd1f192e0e266dc1bf861033d1d0a19a689dc4f80291adc82188b366de2f46c94e66310e0cd49eee84ae50c41f69d8621ce02b0027ad5283f267d36bb3354eda838f7200f79ef6a46bdd80b03945cd7e00b36abcd19a9aa2960e380a3d68a9e2f663bcf280bec5e6ea795bd75146d7ac74e068cf67dd45a0c3734203c6f002e0a60d29ee4ea8b2f8e3b84e5dc37a531f61da37b6f424daab42e13bd945e692e844c133c3bc83289b3d74141a61e6f642f2c1a4b0640f7fea472cbcecec725edb4f90334db1779a25e462f1323b272c951c20ed2ba36b1beab78f16c45ee19d1e7395017511c6bc8c4685de511d811b057cecf78f98f78fa6ba0dc45742c2dadcfb7de0d5246bc1152f175bb6fe09c6c50cc427166dfc055b272f1eedbae56cab9c8c09816c1f94d5e702b83e7ca74d0614c68fc0fe9d3e7247e34122755700e4e3e650cc9c3fe08be29cf5db8da0a4c0e2467c9e9bb037028dea9d911450dd46b3e42215d94ce11ebe432fb9a6ca82e064f36df371d00bf96cf4a0c127e641a3edb04995ccfde1428ff4f30612961845f09fcdfa0dd2c28e2b7a5d41247bf24d1464167db85bca5451a249c113d6829d2e973c0df114902de9e9ef324e4533ae24bbc545c335493a74760f17417270b2ed09576bbab7c16b012fbbcbc1573700a8b84454d6b193b40f80ba4a0d6b3ab1600e3fd7dc32c68a3ff1138b069120449a9a52775523a7247ec9f57ed2dc0e77eb09fd0c35d2096f5a50c650eef5021cee5ba8288ea47ce1970293511c4b748027db26039e7c083e7e5159c3da315dc11c6a6d03fe769d3023737a000264bf598e7be16b824e28971fc96aec902d72e412bcc7d1f3029409980c635e47607c39d5009482826e79efc317b91dbedc2cbec3e795d6f3278c07007ca29fdda20ab22083e5bc8a351953063516d5c0980119328ec040b9bc536be138b468fe0ef1a825635cfcc2e76189e692ae9cdaa2f144284e872880de79a6797318146d2cb1246f3a17f5b815647c20ca85ac6d79d0bbb55a7586becc630af23dd9d4c20b368c2c5b114fe7c292d93c4eab6169691067f6936652d507e6a166c2c9eee604dcc1983c2f9c96d2f57fc66f67df7dd554ef1ecdc63db6861269be79045fa8445cb5a0234b6cceeaf9b073ce76b36c449f913872990720990176b6742ad11b2a66e61ff4f570b943db104622848e07c61bb4af56de2f7fe8c026adcfef18baa87ca97d7b29ddb377b1c25bd09a90e5d8a11e64b92e80b10e75bedd70636bf187ecfe47f69a561abd4cb0a26304a5bf22a3f59f1bd65250ad9f3de2c649e69b403eb740428976d4082d3ff733d6bc4e0b2ca47f00d6e4a3833a1b4220ba72449b49b2298f3a9c10420ca8775dc4a402af302a8bc3b789fefca859cc77c350f2f0d651a98a070bbc47394348b3e3aefb3d14578240ae2297fdfc47940f6cdc29146cc9938fea3c996c797526cd160070e72efbe813d2536f6e1581aa2b32a9f4ee1c4fdf0f0ce124dab1fcf6bd316de06cca3a0f02b3634e36fdcbdf409767e1842533d8e46737df009bf0ffce28e40e3d2532ec44a32da421f0aa15f7bcc528447bae8e742061e58b0305588f5b58c936103acc331194cf00f89cbd8d49f1965ff90ae3a3dc8fafc3412f3da504d223f335a64fe27d37342fe1447608fdd293c7219ce5f1849cc7caa2bf37d9cf5cb917ce322efa668c3ce4c371147566d2dc45eb012d4fd59293b86fb8aa872f3d3a374a1754ef9884eaa32ed62f1901b6029ede2b5c4a3956a02270fbdb19da3eaf9af2a95f0c5e2e197629d89ea06a9f8ecd0fbc9d3f49481f60de2726f811a8548144b7187e9c4a97a12f223e0e2b7929a43496839d12ed6034668ce08f2b000177a635af391449d0106b4074bd3103b5642a03358a366efae06e794f4f36885a28b38dae8484d89d8a008ab8b8e079ad3bf0e3625b57c53c50ab4145a2368ec6202eb933f7de10bf370e09a168f34c1d1ba5bd8daa055a6772bf5431aeca6f84be881461db7d9b4833e605d6945b9aacc09a99fdd5631958232598c2a857618669a9dc1cfd635e199a5143c2a9552f69c555f28e854d2362a3effde4bdfc3caf373ee4cd9d451b6533f7dd1a7fa0a0ff457a42b3c768e31a1a92412821b05a9010573b94bb0d056518326dfb05d1ed8039451349d0f6d72e82e484d32f2cf71923e1854534765e4374d97dc15f9a17e24a11ec97ff582b1c71eb40779a8a4911cbd48e73da222d1bf29a2eb1413f17592ebd12c4ff6c9e7ad379a4ca6692a79178f4ca6a85823c83e716833f5ecc2974871cc9cc474218d8de457cea7478e09b735435bcd6e2673815e3f073d74f931fbfa3bd71d32188cd531aa06424c032072762960028b92425ba3774abd983c6e1a66cf1fb94aaa856b02eb75e032790afc07131d9ad3a9616b3052515da69c8afcc185cb0a12a29741734e4d26382eabac3bb111c2aaa0921660366be92c0ecdf91bc814c930ea8906e2384ff73d06fc328e4b31faad65475281237e4cda71eeacc0426c3c5e835a6961d61be4721d328f5e3b4ec7a3eca02bdcb84eab22f8adf1770e37ae3e80c9976661d71c4e9b1fa409e9cb7a7ac76c1a73ce9f7af76c81d853c33155aa22024ca61643761b70c9625194d3cd60c6c339624cdfe7926cfc3fc681c8179c596f01cc8d03992f4557537d1bf9e6775517e94e75e7f3173ce196361b3523509aaf508c4a9914d62c1d5cdf1260a91a038f538228599bed0015be8e73200d63413f0e3b71e04fc2116e92a34fefb771f74ca137d97a17badc8f99c65cc457c08eab8ab69e1f06c287f75d9d14d2844b45d4d0efb37c530dd0c1e6145d1ce3e9168e8ffb5ceff3e839e2744d939e83b83dc81302508fd0937a467e945928c6c6291e341eba0d441a8fc12b1c5090a46302d255b3259951275d8d566c33e9697c0cc3126746054a32d9527a6ae2f82ba2bd3907d5e779da37939733a991e5bab92519319cabead5cb4016f2ab6fcfe4e96ced1035a9c960aba19ce447f311b4d68400d37f728375ac5ba759b72d9a42699cd82e45ff98606d3ab7ab68f0df96a153f5c7351376923200387c0e41774452daa6682a420b7a9a1465040d587626585666a00000879ab7087e5ab9cdb38dc34b2469634581cfa688051ef756d409bc5ccc3ad3515e4c4af020507130b569fcfa72ff4204312d230fbd6b59b6c7cfd78384be6ab637f766650798cc701a1081f2764a95396dde711084a2a0c409dbf47b72083294ee03a8e77c2953f8c3377fb764f37fb673816fd2ff86153d366cb13a7bd1968859766e7886896faf8ee4fce8c52aa66f4394354f06cfbe38bcdbdf276bea1305e7e37a4b3cf96bfa1fb508d6a74e92d82ef89d23f06ab657c8458a20c06d9b49634db3bc53c42f87a56ee12fd3e7cb3d257a51d53e7a673fc7dad7de3e93032258e57f6304773ab578462cdb5b0534884a74279667bfe64ab4721dbea95bbaa5775075ed12db3607d3ae6221e83ea43635c94c41ff4dde7c07893e73c7fc16130e49db856ae7e86ba1bdf3919744c15008047b2ed23af23c41c40ff0cef768c7e9d893ba224d024a48bce801133ddb80ddce650c3656a5d5ac49064919fbf18b89d745d945725a65adb2af931d0695fa7c5a66311146559293c7d04e4e792cd009724c756e4e4aa1845f091464f418d32b4fdd0c711dd77bb44f93ed958ddb95ba2dfbc753baaab3b80b9f2021c458cbbc7c495b18c212c3d86d487e212624953f84fc8c946c5df2d3449b591c85edf360fb29c5d883f8489f0deab25fc0726e1931a9c354c1c3e854f8235f1e2b368d938724715231141295f145ef6bff8fff4894149898b677bfaf2a48df87ab134bf196043dbef0f6879b553841455fed03cd8a1c03b62a26c4365d5f98b05f4fee92ac37853235e108655be3d46ef4089a5d147d7c0cebe9a25bb1bc04ed2a11da6a66b4784f714e830ca7fac2055fea5369032f69608717251f4f5d98198a2f13292bc9e63da8be81d03dce6360b9548cbc46e5a4e92ce364bb05e34981eb93218fdc7ffe78c4195bb380c4936d4476a26da2d8af465c8bec5d6e569e0dbfae9bfcf224bbd56851d8aec758e126cc65141d3ce367fa2696ef4f86dc87f06ad1afe5a06e658c91dabe77b148cc62cb83ca368261635e2b8998b5157fcb972b7127654e1c769ae3347e2c04ad1535eb6ffce5572f665c9044a1cec58225771f37936ae7e1472d9194b456b58ac600e131aba919ee91d032d01a6c75b05605f6b21bd46b7c9939f6deffe6a2c7c87db721d59283cbb76a7dd3f9e98ac219eaec12c6e5e6278462a7144a5e6a857c77f14ff0e469ccd964be3c516276c1decce18985780d2fcfbf1d45553b1d9be52087b2b094fd9c5bcd734110d9fdc87b4fcadb9fae8851e7d3ee503f8bf461de2f28984b94e8e2f802de90daed49d58734dc4616e85c91c5c00d435752c90989892014d652a20c86648e01e4a8158db8dbac36e32e9120728e254e8bf4275bb58341e885d87df3f174d95bf358ff33d7ee71e333a86706667ad4b38b4a6113bfb00fc1492d4b4b1980a5b80b96eba8f3682a3ce1e700179200509b1945df45302df77ac846309e785265c7b5edf153da3ef0b351a937316a64e82494ed6e183334b14fb080ab5bb9d395a61707ef39ca84b6cbf6c8b20d2e3a1bb9b64f884edc0e388943b860d34ed9cc37082ced0c9d78ecd73cd6a0d2af26942610db962160ce00f2fe79cf485206b1ac8a46717e8e4c77f40d912d4864385a5dd56ca462cba38f7407e979b2731f57d68676c9e2246370b58ead8c83084d4ffc556b0b3705ba04baf52012d55179d9c8e4c988d5866bb3ea0216a757b9aa668f4fcc3fe664a38ae2c34ec2699b80cf6b2470c6bbafa1a206e2b992c46777bfa662459b4199a46dd69cd2171641fc62978e74ad337aa370b03d1000d1d928fab4db0c05304f4e4adba56f1f26a1cf1886945672b59214f577b2ddba93da7b95216a526c2bffb9aa703a11e758fb82bec766ab05e3bde2a31cb37554fbe718b6df28e3e1fd4fd077450d8d85b3b225719fb11d35c3a05f37508e8fc0b4fc82ca06650431bf5bbd2d8509a8184fbf87b2a67fcea5012c6fa25d9ceaa432b0b6dea54bc8709d1c9b79ee723750f070503782b897252af47e642c4da547f097d2911b1dc0e527229026811beddb5f87d9203a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
