<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75d693ba422443cc022e39a7914bba98254580e9a8f34a89172d231e822a0032a031db33c0c31efbedd7f52c6a221e7832d967aa318c9562c5d6df66b0aa77357132e7204966ed84a6cc68a156ec1c7380f7af385f2acd3e73624cbacc4eb1f0c7f33e9f99be66a775af21dd66309a8226a4f17efa41e1f1c333426382ce7228144a320d497ce578e83aabe0c9dbee40c77bc7dbc65c242489d11c5e70c2da91c5f15fe2d36842440735ed1d6217832a1733988f573289d6b18b36a97a53a94e9965b28d1806b1abfe74605cf94c709a1abf43a80fae0668f002320438192d22ab3c73639e291ed1d995f7508eab5492bbb7bfffda75024f920f79c7887cab73abc37b9c53946e607dc7154d2bdca482a6413b36fd05c298cb7f0f400ec25ad2e752b6032e5a94eeb30a8838026dbf67ace9ba08519b372443d45d84525340b6f25a660c2945bc26f13f76652b318d74293d0c9d2c24981718b43cb11a8036eb2d50404e37644d5544649ff1394dd20b85434bb13f96cc237ebff40171fd93670302dc705412a033738c17c9fc8621b4c63561c5a2d5c91a9804648115fb1b4799ff1e210795de9e2cab7c679fb054c1ab841bc0891a4fda30013d89c7ac5da9c00584f5d0be8eb0d7e8b4feda6ccb90f2709fefd28a495af2eef5349f6d624ba50b97966c8c2f89014f7078ca9a2313c3a5d01e29fd32136d62abfa3a79c1934aa6f2fe33b5a465d6eed6ece502b2f92934c3fbb392b53a8a8a827cc841b126246d074e355d9beba6b964d1085e16ee8a33f6404e1b23353629cf9faa3cabf2a906bd2cf50ec78b47999e326674fc82117e61b4d23f5b24c1536bad5eabe905298abf63a67535f6be9e5cfaabc6569b50bf850af8e6db124c7172e82b7fd9fc90762d9faee812e92027799a3e0e31e15d9d13af7212599dcd5365c7d04c3ab7f18bda34ceb1ac4076fe7ff1138c3dd6961b1c527a71fd0ef9532fde97bf8b7abcd9f2b4654f233ebdceca6a07a1bf6680456db03711a94a1b19659c6dd8981448662111fc829a45c8ce5a3854150435ba3472bf36c76a65a74f77cd79baa60382dd5463b97f152e56e78197972cda4b4b9789319cdf66e6d59d5963142c90805463761eff847fd439273a0951414ac94bad1e1a39c2879da9392516cf9f6a3cd9654d0782493d6d6568941a59392f2a331ea104d53dd8e205c9438756c566179236963248356e778df2f0f3aa8fe7c11fd9f4866bd0c74e96dab16e3c51e31169892df62b7a1302a7106a3835ab98a2a841079bac1498fb5dc4321dafbbf11b6ae30030118d272a847ae7be35da368ddc113117d6f6695fbb544a4ef6b1cb50de331043fedf82f0b922b89246e18ba2d9bca0588ed5bb8787738974e22ec0dbeed41c6a7d155c1d57ab1bf51a21171de0c039d5fbed4e7e7a2e03cc802909bcde8e3eaa933fc7c6ed041de1d8bf323c01531a251aa8b6a4b0e8779ad04efc66b4e6d4aa5027a6aa645fc5949d2c939a3d870f6a6e895b5df9890c46c9e826da077d47a31ac9044c951d138533151aefcfd37f8b019393a6b45820941c29ad7ca555e6c783daf096ef4c9c68ccc92b96339bb697dce8d2dae98fe6a0e521e8270261224daa4c8400b920295067903cc2a61ed003e3f1b94b4308db4b3b9a30adc59152ef72bf4e148f11c301d5a2fc48b68ba94d68b2b729ff2644009efc6881e868f74000bf7834e5bc19f94fee3d3fd01f00fd82e6e0fd841c855281acb1cfff035ba0fc48024a7c571a58e9d8479c1f88f6707e647e4b31927be82a50d028cd2b33ebfcd0275230a0127076c254e5f190f1b166746164e0a849deb70aa6b52df0e43d5aa45a338c52d7fff2fbb05729b4c2274c652ddbb632d4b13978016d7a392234692bca50a718c664c1eb3d78a1f36fee9929bd7702a0131f0f24d95b90ca622ec305cb61a4ee631cee56676767641361de9a3d9c15a1939e372fa0435bd9ea58cd7e203d77ffc68bf805fd90465f22fd0754ab27d2f998a56751f8505ce37262e7edd5226ff9e77132699f49db3c747d900f33cab64342bf29448e2e4f8987f9fb166caebc46280bae11d693fdd19139b0316b00928a05e84557dfa57b837cd4f128989b3becbbc46f5bcb24997bb5a5f2c3a0d860a886587b8530eda1055a21cd3a3736d1ca80ae5228da88ba97c978fe65801f525a51462f99ddfb68487df60daa3f45b8d218bad36fb3b3feae08c167c9e98e1b0260a6bbdc82330944b38cfa0097641c2d32475748eaec8b545c114e4c1aa4884500eefcf9c68c12f2f82023195c0fe08bd083039565f3de3252b50c69aec3ac6d9fa7daf7673abb4e9b0b3451a8bfd52abb810a7647f9936232ad1966afe7c31d682520ebc2888c6e3b42a37199472c7c33603328535d148aefc97e38ae316c40b91849843ce4115f74f4cb59119462915daafe37eaba0a5ea21ed848672b4cce278d09930ee4429e4819f7fad97c1b5463fba0c518e7cee001e6206cc03b86db48dc280dc23351771a8409dd2f7f475619a12c22293c09a88137fab33fa8393da8e17452c1d17172254754ed6c0b4ce21a1e2de7f48b3516c81779fe6f8a04cd353d15789fd595553fad79564765c8bfa09a937ca77ecb4f8ea276ca62bf45d803b90b0b08fa7678c38bba0e19502e032c0ecc0f395b220e689486d71b47d8ca3aec199f34238099bbfcea2c0c9030442d09ec59d8f42d90762410ed56fe74e87b389256d1ab77003a2e22a6d4030c08bb362f15ccf7b5b542fb61db6f13d90ae8bce10bdacfe8c974b2f48b8b4c7a712dfb36a7771ab3d045d63ba309ec9338ad04fd9d3207561481e0c75b3359291c261b15ff9815dfa408fc36cd736e3ba4e75934ed07966edd318a8aa309128d567132e8fb164149ec4f49de5b350abdb8b3a4c6cc6b052f40fd67ace178184dcd5adc395e080676b53159423d032f12297336f2c391a354983c46ae5b02bbbf96a97edff122edb4993921c4aedf5373e0aab59573cbeb23757771a87f5db30bf3bd9166003777bdde5f84861b6610fc8ab4b528e84e8ef8680cea6b069427a061315c6889b27747f5c3f9b97848c7ceef78cc091691891205bb6f7e088ea4dc823ef344160df756171b1f992d00c7acad039039e0bc5924dc0252c560731272a00075e3d002d6d5b20ddc5b3292a80f8e540b980ae481fc5aa5e3146dcb944e9ee8202c70c4b3d285f38cd3684a88cc4d45399cb5795e7ddc09a84ffcd3c7f11317982a9c31134c009ba4e0c8f32042a02537a00115419d24cba1ce9a667ae73884935a4a3960e60dfde494b4d06204d204c51f2cce2ad97a6ddb5a250466864acdcdb5be4bcb3aac0f014b6a5baa442abaec2076e7747662b816b34b442005d808e5656f7ecfb080fc3d18f6934e6bb1989d079bd2c1565bd5138d07a0ae03699121a46902eeb3a5d711a0d3985ed563429eb7df068e922ae371a80720306055597ae82cf4d9925415aee1da042784b031be4eabc30aacd422fe1ed2ca6dfd514897e9238048b84bc9c67d70688e00ecc591fd71f64e214b4f641c99e2d3d7409e302002e40f85bfcf2d689c5eacda306ea9949dcee8a7edc14af54766e9251a95a834a4107964de1f7c0920da44455a4bb4ac1547610ff732197f3bb25f82088283a2037fafb7f223e8b183c69c1e5446ee959f6094a57fa87432c8699c5fec5726c06add163c8038a3a3b6f05ceceb3ee655bc78873dd5df4c3104c00a3208529495b49b137fced2df7e5e442e4961e7fbda46146f4d50f5ab6f759350f32a22ffd5f52b42bc6417e4b95ced0ba22151cd2bac0495f3dbb4381f945b2b8c940eb3016b0bcddf0f9b226450471c479cbeecea8dca838dd1bf7c566af38b092dcf7903dc7d346fd242acff25f0557a4d9949e7e8cc279a1bde7ea07bf549cc2907166333847856ba1fb0b89402dff9cd8782f52a0815a309b99853c0730289fb38c3c3cea1220539dd0652a7ff85e2aa14c3cbe5547884c847684d0a517505e9bc7b305025da2322c779f1db4be9227438458fed0f42becff692bf2c54d4488f52eaa3ca1f851bb1303e7d2350ebeaec4b510be1a12f6b2a1f0b8a21c571aedc06cabce3a0f1b2555dd8bb5af165f318e868e4a4557fc53ac64342936aa325039572948371a8b5d3a30974a54598229d69f1096f8ce14870ea0c8f6e82a6aab5adb52061fc22fe6de5d195dbad83a55e24a348c1d3a5e767b2b79f3796f73a946a54389f614b0d158a672ebbe8fee3d39d4763a4baf793d4cc63483a598736f2b30e5d5724457d9f0ddf1ab7d1f8ac08520827a2df8daaff935ed1b04c996a99fb1a6b5ce46efa2e8410860a5fe9c9c6438a2c0b895fe9bc230987f8abc9b4bdc5f75b4f3d2355cc91b2cc02c44cf335b97847919b56a8c77cc86780b59bda90593b509ca04ca9c0f793a106d026c2ab852303a2da2776635e8dd6e439dfca7487c5b46ae74767a4cdfb1050ad3d1e84ce7f4a2b61dd13e758228bb4421929efbea184a57bb21a1a959f8a4792f4ae9e6214a7b2d8fab649584dd8135f8e87ce0c26e362addb7497e01170e24cfef32674f73ebcd4a8ca3ba67cc01c4e0fe352f81664a27e907ec71208504094238e8befc648163355112d544c75e5823f0d4856c0093e33267786c02824e68b81aeb88b06be2fbf4bad858757e5e05988f790e7ae9e3f497be365e9d2395017824e188ea528dd120caa2ca87bad3e54be02fdea5ddb03983fd43d3c3750532e8b16006aaa1a24b3c0e82a5c87a72e7dc03b68d78a613c85cc8955e3e5b0105c62fcace76c1a93d2d2ea1f9a0cc5634c919bc41ce8f9d5630e0d07e8e5cc2e49f39e7b5023f2a394c8bc60f398a56c21b8025169978a8364ec62d21bc5cf075796b97b229758ba92dd79dc2d91ec7783138bf92ff64f72c104e525b5055aecc2a175e4332882363632998e57dd31f50c34482aa6f682ac1c4ae223e9df984c9786f15179c65debed0422760e1f3325b7c7e5920ee992a063999ad19f69569df0a449f415dc264b21bfe700d172b50ea752b9ff5a032ea9cbb33ee087799f61f63e2c3cc591c252d70b98cb4c4535a79e24ca98f5bb1c0d093c31344e028a47fad025ab70583c1370a185f281ecbe30b9a728e7e29623eee0e92280ff952d7106ac6143c7302465a41099bfd555da2273287b5af3ee0802ad04d9ae02e2cea4fdf5aa19193660778da692b65bc868ecaf149db94447d84e6e9091242775019ebb2f04f1829626290611895b6eae4052d51071675185c6bd748fd0d372746210cd1eb13467c8de1326c49ba56d80e27717ad12029a93984d8d61eaabc20938c6cc4ac40a140f1ff33361d5b3e66b8d13c9fb14111c09e6ceca6b7daeba084d24e3ddcdaca9ab483bdf1f9fdc335cf8cfd9e265b8651686723055cfa4e1bf744529adc9ac391e707d45977f11e2175e3f5d5a5a709ad15a9f95b793b16033f395442dc78ebe4fa734868b24b36677d6f15ed7a44024b31603859118f30b52c0e726adcec9e7976fba398c02cb6b7895cdf12335a556fffafb152fda9aaa4564ab4036f4b012bb0d526255db7aa97b5e59f9306323d04c8f12efe3c0dfb2ae80a67c78067b3a7628bfd92f50296da680eeef78f3c770ec1c1ff69600362ca3512475908059d3d6bfbe7a6f60b9905d21d2ba39c9dfc2db9eebce3ad50d536799fd8e5e56cdb40fa6f56e8348e6a9230313429d8a317a18c24bc3d8769fbb8d29fd48f11def7300d59fb19cac7cebf3507dbdfd4f928266fc017dd84b36a7045a00c73ef2c919d4631a1555cf933bb466718346e46d2684ad28b5e981bec2e6f7185d10a6afd880d1c56435d37beb66ca5798330457495bfe862845b7eda087c6a46b38eca2f26751de6e73baced8270737306c1f951d1163d3a3d30eb7a495282b8c30c19ff42ccc54d7a517e34b0c94a76947eedc083a1546ba2949a92c38e0424cadb2319a33d830aca7f81b268e17111cc5bbb2da9f25fda197e8e06ea7853b6653de7ae0dd34e04378ecd061db8962099e4a0f5f8ec6b7fa1894a705d1cbfa50b60178384141913c02bac2d50fb422ad5b6bff2a32a6589b87295841a861ba5954870c7c885e41847b865811e9676832d507a35b3639d43cd451e8ec8ee19057f9bdfa2d2736afae545b585b3327b3131ac13382867d87ab7e150c25b455939923631a61abd3f4ba252f78c9f3db10c261683133fa8a638b091ee6ba3dbd1067d254d975c9f37a0ec40fa6a7684069cf4126c4eb7fbd0caaf5c317814a22576fbf30fcb0455fccf1b2f626a577d549fd77cdd673faaef0bc46b0983d5e84b9167925b4fc6b054dbb8f4897a0b33bcfdac1af5e26c092f78998916990e1ab72af0a531f1eb877a7f465ac33c32ce89da41e753e07b2a6058142a8e28383ab5f9f8c6c19e63142eed780734edb2c5db737f209284263f4b07efa1a74fd3ffdcfd2d39c133faf4a1a810c78b856994119bdd5bcc53d1ea38b6a1067ecca5f97037923d19d59b174c3b363276ea14667dc5a5ae639edc21f1f551bf59fbafdaa3f250aabcf240fb938ec1159263a4e6ef9f8c8ec2d64dca5f06f8a605dfa3d40cf5f7e5a1eefb8fe9cf877cd92e05fe3bb47094e787965bee33cfe1798a9b951898168ae78af281931f13ebccc5f7ebb774d79e95a2323191fc1c8400966063cfdd3279c0cd235175c79831a5b2eea52e035b7c77a25b112886c5078621f64f842f8fcaf331de9a3280db052bc9d760e50e3741d0b7e6bbfd1797467381f3c6c334f2d9af7b81866987bcb1ed5e4af85a8028adcabbba5f80bb2923ab2abb79fa41e61c956c1c3ac328f864b108819d9acf038f20cedf4e43e8bf32df790eb33dbabb1e1f9bc409cfc415e24970b4b2449fab51bfa70bbfdab5736b33b14f45eebf072afe0d6435adb89204c6dbac502d38b2cc2de9d35471495d670fcd2c94e5a7d10506781b4b1d862b970f382ae421b6b6ef0f15914ba1fc0d5e80a899eaf0d805859f434cf12d823ffd4965e9125b6a6c2ce59214b12b2370cf9b8e08042b81d7f97d8fd9ca5ded1e44917396e6aa3cee867897313eab651bfe12e60b5bf7103ee0bc4d4f7f86eced8253171a03c658883e3525c1960a4f0b83823de38672247461bbd1ab82a2b24e733e23d1f6d839d2e6a952fb9137f7779fe7166541ecfed65a97f0a0846c7ae97f078849849503c0ac09d08ab6ac9cf1a3ab61863849ba4a33d93170cd7ad24085ef8e424ec131554a2bf0bf41b57049c9996e91e1350be33a669ddafb005ac4747a76bd6121a14dc8979132e166e0b25be46b77bd5b1520e3d1bf7fc565e2a0f864dd9d8c462da5a9beccf2946c65c9212d7e948ccfb665a8286a78625c9def5d982be9d82e13fc9e6f26ff4c98c41220cdb82db2ad45aa584098cd6e276ee846134c5f41eb276d3d358b004a375287ec45793c5e11681a13756d968dcdc5b3c9ee404afd78904478a1c6d0e8ce2de37d9a7e3b2be2c044e463c29c65205f85cdd96adc0f0f73d48d40b471e9543c4cf39c2b3729f80ad9f6ee031579eb2d928a5c0c3bb124c2d4e2108017ff2f88572586420c8533b4cb824a7de1519db35b8d1859216584dd98e98f2a4b0d0c38a8bdbcaa76c9e415810e1ddf0be48788820952beb0cd990460390d3adaaee1c03b9bafab26fa9e747a21dc191945aee8520df041dda3e23012cc7ee68ee3c1c290fda35bb4bd79e0394a58bb1d55b4d7767ee4a940954b1f21f40117e995045381e070234b6fd8f12c50519983f3c7cd043a9fa9468d37c61adcf77cf61c0ed052a27cef75f81fc426f6a9fc308fcd4c148e466a8dc92ae24897a7837acdcbd1fd75252aff733dbe5daa37a3fc2e445a260388021396761b8cfba16aab3b697e8b36989dfaf941026ca64b636956fbf14d7d12f2f73fe7ab5e4c53a5366a0087405d7dff9a9b1dd6ffc3215bbcb4a338d97dc41daf7a106a275da48b6a0a54e24eb99d28698e7f2589034208cb30ba961b3e6912cb50a48a454399f37a2768fbf45ecaa69f3b4d698697bbd429fcc49f360704b0872ba068a63b469e9ae6b26af1ca1d9c399741bbde81758e1df3b023a088f0beece0874b74689671da3aa7afc6ebee89c77132487544211e6f804b1f706aa10f71b86ec2d40529286ddc2328a9c0865d5dd39cbddace4c3315e60e5e21bd6dab52f4ffbb67d822fd702db5855318541630263df8caedb4e21c6e46f4144ccf419950e9d95561bf7dd6bbc30c026707f98ea513e8200b016e86586aa4f5182b9c9ec27b0dbc77629fa00553585ad1aa9257ccc82eece21293bcc7fcfa87ee71d6ae6897bd13c7c7b749384f9cbc2c686283f71f519bfbe6ac3e6dc30138dcc132677cafb2741450ff02399e96920eb018bb8ac800fcff9f7ef243a5ab51d79cad70253ea4e36fb27d3752919f018b2c37f27da71d112d01a9b9682a56382336842f45e80239f1524201b379d9a3fca9a87c347e7ab6bb36ff2e0142e21858f5ef4087c33a265dcca7b9d7d1a2ff53cc95f1bc2ddee5aaa365587146cab81737759443c177818d9fdeb3eb3f2a6980be7242617bd2abf5dbdc0be475767dc3a9523167b30add67eb5aa1e94a33a5f713fcb224c8f158348611dc5aaf9f4900637a545584f1dd5e2b8effcce830915da5c474b62d4ea2e9e6dd9e8751d45976df816c74da6c53f61c300fd46b4f4b60eedde5dc44f130567ce43c0ff1c7e19fe271e9747eae039cc0e235ef7f777bf386a836b2e02ff6407c3445656188876af54f31ef62ffa35d63682bc74b0d7d46e0b0d4fcb7d824f13d306f2206b6f88e95be7c68363fa74d8fa0054ec395e0b3c0284f65251736214b0c3e321988d8f35b9ca2d2c0cb4d8720203b49acdfcf054d9e96881b42b65b9cbd3ff8e8b23bec5358f3833d96002914bc623de9f34d069ad8b8c0dbc15e30587cb13acede129cf13d6caf59a25c326f2f2c39a71343208583724cb5df1a26bbb72cfdad1c887d60a766f9d1725dd7bcf6b1ba420b6a5e82f9e5a1e7161670e5b9ef6d10f85d47ce2819ea7e287ccee5f16ba8728fa5b30e5f82567c0ac65e34a200d736757e767a6fcd1224386355a84d751f7b6148f879d30062b0e4d97fb3f493b498b8bb1bf82bb99bdf34adabc339bd45c6517c1511fca7df4347855eade6ee31b94b4b49726b7b3fe6e7dd724bcbe762ad0a3a880ebcc9ffe2b6c7970951068ca34f9336dbd0ebdb4f1dd72b44ef515292c1a3cf96adf8d1216119001d868317d32656bed9ba89999e06f40b76d85a71cac92dccfc65be3954e22a445196bfc4794d55d5d9a35a9422d7801e2eaf40a9f4b9bad3d6d981e7b6877fca3d25633f6c2769286d24da915a52418fcc7f5511b283e8504ecb14acef9dc5c30caec3912cc7446e39b9687703a1b13c7ebbc97575b672797e317d73d3ea6bab2aa1d48f213d6244d5c6bee576a93156e2d762f24b471a742c611dc0ef4097fd9c786464d2a46136795ad28ca62d6096296ca7295903d2aba0dc0eaa58cab299d0e83708abde17ef20adecd2951faf20dec92b69563be1b2b528df3e2024156700b6c68aad348444b39aac360445a4dca4ad6bc2c2f65dedd4ef1ec3871e828c32e3ee1e3434157fdc459d912ad3eb3e5856e93e2fe5b03043574c249bcdd0a5d1a7b136f2dd7d003a886ed5594825ae1ca698b68c7826985ae7b2cf88bf82cf909c5f5cabbb9899785adb1aceb0897de14a382601d7f227063ee181c474ceb20238bbbf189f733b77821e6970080d592914a5901f34a41df688f1027b774b6313bc7d93d37f8a864be641ce4dd986037135d7c1971b940ed74ab81eb274cb38dd2d7a50fc5ed72e9fa9a2f0b30dfb17ec671b03abf926bd734c0ec338ab01f3626fb8fd74d27ad51a1553678cd591d45913ada5a2d508f6f9134d82026dda6f84e4e3c9063c4938316118d2bb4ffb89882da2f99b4503cc06235c087922338faf44344ba800a99c9fc4795b1540e9accd3722ea4575d123ea450b312dc0fa851635cf86556d9433918efda5d0a6e2ce5b927fbf91d620062b0900ca5920547e1ffa67d3fa79d3712627e51a55bab670cd3e6b6ffe02cb98042569daba3539810ba1f4f7fb43a0a7adb75ba148b8ff0ed90ae2e6792b4bea9cd6d36a62ca6885d6b688fdbffb8890645d1f1b3f27a9b18206b2e59da9627c66b7aabbc65c5ed190cbfe6376093fabbb9073fb548f7f618c5a88d87e4e88446946d06cca8a4aa949cee70cea1454a2f4530596b8974e4a03b260c4dd513ae38cd3d215e120cf2e75d2e91667933ea31264c3a478a50bb6c541a9686e9112d510e7d5e6109b200dcf92735edac9013605ada22c029b1e0bdd79d0f503dda05031a2d3931761f4118583e8ce111a48efc26be1c53a5dbd001b5d8748c586b9e07f6e3e176d8a676bbf4c06472443a5d104db48792b305f2feda88e82c1ac1cd9620bf42d96648df401d663a1fd6fb7fa0effdcbc9d44014247c1094a16071376ca9c69c625a78307a8f58d5e3548a9b81145b14a95ffc66ca7ed71e2ed2459cdaf96ee7e55d5ece18658caf0d78ab20f879756be1280c75037f0a03d138ef91ae391e831779ecc026d7724e38da63bdc0aa49a0e2a95d758c2dffb30288e78baf99572a9b6169871e35048dc64b5fc41265e71a428eb6e7b59fc90eccef9198fb2806c99c17d8fd002f1300ad86d12fb485b34c0a512d4b9e4b30da75b7e6047ffa77d2c74e0e9b4fa5cdaeb765f8371e7c6775b63f7a5501671598b987704bc51b1d3209e1110de3af7cc77c71906e3ea01f823c364640913c640e7ee3a45f2f6923939f3fad0cbd794cabfad6a56805a4ce0723b7c977659b7674a6a6c4fe4004c34ae75760a008b18ff46cbdc436ccb86663d3d028ca569877986dcfad389a106836e5771eee16c34a0c7eb79fb2ad65b295bc82878d3223e658b57996747f838ad9b6d4a88474dec8653ca67f5ac16c207ac617c895734c7622a6e52d0a90d5bc6340710da362cf81d16329e8701068c66e5ecc937db2760fc66fb024200ef53e0d77d780150e1c09a4d5f0822f8c0b90ec4d2a440db7cc061e8a4f2ae883c47b33a40b2c1de55b3fd0844c707de19f11a73fb6909601a356cc8ac30bdf6ef0eed6285ef93964b76b42e45279241f2a0d70013a3fb17301afa988428af2d47e8da053c3f8b5c4c56d2625ae951f8142b1a56b3d276046aa04e06452bed93761db5e96ae87b41d6a6c109ac41fcfade76e3ea710cfb87511749e0292ca2f50645fb54a7c94ecf977e579daa238fc47d124091ea9abadaf238a9ffb8601441a0a644510bc7862eb5d2f967f2158bdfef85388b4f5fa65b440b6201c89e19cbd4e22be102c922339d6cb88237ded93111b595b80e607b70a538bfd1b2abcc1263252332fbcdf806dfd2ddbb2b392f9c291c7aa823c4c4f462d49eaae8df5abafc57e861a62f64cf039a05c7e15d23280fcd31834c1e1ed06320f3bc625e286a352e92267a1dada895401f412c1bed5f8d0ad688564f87f4efbe4a9f35193b3c868e2d5405983a934347d330a5ddf839f7d0e42e778d2ded79d9106ed05c62bfc69a456967f054513195de6993536559afb48d82e72c91c09f252ae9f0d06a76c4a433cf76fc5f6b28cfc40931fdae7a9c364cd3469ff9b28803aaaf896fbfedad670740e8b011bff1c714c44f4d2504a34fba1fc60d95517e49c9facff1dabadedd457757b0a3d6ecfa353413d34e754561f7ea4ae9cee6308c731dd78453c3cc4777d8dbf14a72c280f8e3ce78a5762f29dc3ac5cd20011ce7daf8e7c6c3e2f2b4a20843745728d322fd36c0dc7c04b56f724e55ded67d62c49dda2a055e2334f6a1c90fc3c6cd07670b9b0da56d163bf266f031ab9f67cab8d6092d410c85a34ddb579c7fe0ed047f4b68e8239122ce5f976201d13c41ef17a83cc286d84c3664a81e3250e21886270550ac8151e99e0fc07b7df5033104283dcd380e14eb01a3d2d11986efd6d226d8bc6fec51eec1d7cc23f8c9d0680e2ca7ce3774692dbedfd411929d9d42a7d26362424518199c1ea43f4a0485ef43b21d13924b374193f239235f8e05bac077971db6ca300bde6623f2624d463e88bdef53bb915f7f2fe7930dd0f56e0c17b1f555c745175ed38bedcf064bb455dfa8026f4e9ac28e062f8ec028f0338b959ef5b0b9e7d176e8f3cde9a850e546933df31cf5bbfbb14eefc570b10e4a0c226e2dc9819c72ec87357874b16d42f74c71816b4c089a4ed7c6a8936dabcfd613cc1766bdc5a9c7852114e11e7e192146e6c530ba2f490f50c0c02bd6830d8408b3dbb4d148d0f248999edb3a296a83adeafdea0fc3f66cc7f9e3c847bdd08208ff7de99ecdeae988958b4d4658ed51dff6340c0ab2d2ae9de5d7a3c2ef301cf0e616862dc8c6e8f6551aa3ee8c142ef93b6e02884fd2b527635c48789520c2ca8b0ba3389d35cc1fbeade5d76c97138e92aa30710b4b58170a35a3bc8062c98acd5001881e04af7c680f3206f53c3a4628524f7ad92d2df77db06790ddc6a84b4a674e2ee269455c3d172759de8ecd5500219e1cb53d21bfe65dc3fa84f4029e459204aee1685f5fb4673528b846b5fbe2e22f022b006a41d1c9290222d9ef61eb6ea23d247d48514475cba1c3bd8a894f757f9a6693562c8f5c63f00d4b363fa602a59a9a3551d1472dce065e3e96431f47a5f32bb1d9fcce6cf4c843e6c0776ce2ab07cea4a30cfb5fec4623008e6cc33982a79c35b06b37e1452a38b746663c71a03bed9c4c7ea7fad83ceb9dfff391f863642d55a25e93ee4248ae2ea1447cc14ee200927268ef8b4e810461ae8555db9f5003d9b21708a07da9f405dc9a31924a566b21a1bbf9a9a092b8912aa03bfd530a075a2c409fdd1982ab29b9d7417856a90ba8bdb8bca3201b758ea6d6f3a1e7b2570c7c3170b969acf64ac35bee99dcf7d65e12e5674ff6dfcc7dfa15aa9471fd54d78a035fcede353df4aca16d6b8e41c00c81308927758574045e3a6681022614d348c70088e088ce39310574ce16b81a92de16e3cb5183cb95c2d4b6f15fbc4f985d6389c3a33b83df919370545da3ec20357ae953bb4c01c8c982f4b402db510bd2b9f9a1274d338512111430ce519b5493970c81912ece70fb3e3cdf5f4466d27e9689ca746ec196bc635a4cdfc9005739e9b2db3eba76fd6dd5d32231cf3f3b5df49a04d0f1f59ba491d1754ee8b6129f271b24d736c6e2dbcc300e2d5f669c4ce96414e5ea0f4d2b66960161b77e99dce39ad778a4be78d27925fdead9135392a6a262e9f5422144e7c91967b2f204a8269aa0df8cf134c13f77b63d0277352d4cb88dfb6530606fa778518e9404284377123a726af44e4a25a86d37b682f7e84e85a309778efcde3a35454d9fcd10ce92828722a74eff4225dd48702d16e6324981776baeba4ac9c28e532bfb1a79244232db40804ad00704242ad9155af8cbeb529e80f00c7a4f519a49a23094cbc891d6296f2c543e9c50d7c51cd5aae4a85036e48863212e1ee9e50ff4d93c2d3b1bf5876f0c953c6360710fdee16adf08989e806b739c32a4d499f85db6b621aa2281e99d9c03804a4f9f59c36313cf7f936815860286637cf66b2186e29609553d9bf67fcd4cf6a5975d026dde10e731b91d9377423be5801a7aaf42a630601dac481a3978cf86347b77bd13f4a0d01e0c2e827854bad10fb59677745836c84ad9c2aaf773e11f2a52399eb58a832fde4d15cc3bcf0ad24e93f40792a5b9066c477930632f70b72cdb9c2d21823bfdfa585485bc6c8f339cf2f396d76879908f2348ba123f5ea4e7d7e1f442cb1629f445997a0708959fb5a66560619df7c23bafa7039074effc6bf1dddff749db476e12af886c83000651f5c4b2afb7e4872952e23b42e869d87afc5d9854eb09955dc42c1882762d01f987a7f1b5be8445979f2e8b183cf66f939f4c16b0b4dac2ea4668305cb4f94eb10e80f8d111f9f15d74e6aaa75471b1afc59aa65e57ac8ba88bf1a990650e57f2a07d08cd44fcbbf5ea48763e074d0bdd48bfcaf3f1ec43e23132e7716f06faa834ac5fe04e31ba7823011a307517803049301d0985147d03aad78604c6bc818dc812639f1d412649cefebbff2f5645d0e7b9da6e6ab2aba1bd55eaf4643b292a2e9c71388176795b6a1f4265e63143f2b9c242425315cc0c11d926a385307261cef2e07368e68e7f9282af46d7546d8251358187c8da8183573582af72da43c2513dc6a4e28c8b69b642db060d6148e06f46bcad442ee7e1b8c6334f4cb0163a7dbc0cd54774e5c1e3a98e8a7d0c6ec6b942e713424d4914da395338764b3def01ece638e7db2d20028b71a433ff7dc3e792446a0ef879cc1fe72bc4fccf284816ed595f34292a2b706b829c48544b9cdc466b8b7109e22bb12619c4608fc863c5e3b7ffe8d1d665f97f8b29d4174a79d23e53331184ee62a7167b5297070eb565d07288373fc0aff23e06e057680fca0c1e648e7257b9dfd493b1a41a69c48be6825c91f2972ec00d29182279e69bf30eb68cb2172277245e842cac51ae10b1345dd19cc822a637607cec9225d84b0bd7818303cff29e888446e274bb6c96888968504af5ce7655d82b533ba2bc70194b0d69afd9359667bc7d0ca7a5050434704ef8d540dee5afc50793f1440f66412150eb7d02af79fba40f3cb657e8a6df984101ca429719f85bad689b93595777b390120dccbc7079ee66b96f11033957ea87c2b04a4b7ec9a32d01cdaa735c6fbb0640770de4e04504f05f4d96a4c1a08ae0a0bd345b10332b6438464a3fead13d448419b702e9bc74ed46b1762c3ea3033b218e750040d33a51d5cd2f676f57eafaf640b18fc364c92db1cec661010ead180ccc53263143d94ea2526908ef7401fd269b15592977f9b1af0a75d5882af6d113821c96e32eb917d7f12842f4e7f954876944edf9874662ebbdca7e42728116ce1740c111781d12076550d5746c2bdd67d1a20b5f65db9f064bebac320ec4f4deae4491d420409e6232b30a722d0e2bfea91f1d750360a117797dc271b6b003da7b955a3829b60213549c3d4a6126d25041e4cdc4b3fd4d6be2939598599305621a2465eb0fa8134f466eb1fc96373180145e9830f0b96217cb3541b0b1f034b681cb11d6ec5be9b8534605d44dc2ffaaa501f7caad6586231d72baf4f7aa6cb2e8443c569be9dea0ed6cc91c2a54068a67382120219ab784ede4b0a3481ec8fbe468297760353a9f1161ed77d9334a045c90822112cfc2d7181132c0ae27e511c7f0ec2902f706e776f970497f9c992a683dec120e25900e7c1956396e8fa02eb314920702f700567c574e18e6d7f91f0b5821d751f775f828b0350cc862e602eb4a538f16b380fcaf4071c95cfb73ed6fda7cd162fb47c58a9d2997b9a9fc11a70589eecc5dd685285c72b5a641551d925a4e90597999626f38023f7e7fd9b7d8787d70fb538d656c60f8dab7a4a90cceae578f5675cd84ab42334085dac2752325340096aa0c4cb02dc1ecab6519646479bfdc21925be9ce8315cf0faafeb5d2a90c5447633ee9a0c16fb844642b106f8bad437301cd3695b00a72b5bb6312d8a21f201db6b200bc892ac2bd4db8b0bee8c3c2603da2a135fbb6463c67fedec05506099865edec02adb7adce61a9517dd1dbf374229aa9c52816c9cf32a8681e972af0fd0e4a81fe19cc876850dd8d6c4d4f5ca4c01f36cc19ac8aac7ee78d2a65e28cc5a7451d8289c7e98393365bb9d9560fed1c16659ad5f5133bbc15b3c051ea4448fbb4dc82f15a056a5377126a6561ed9a78f48c21bb9334e10e8fdecbedcbf0426e58cf317718bf82430d54044f26991ce06a3c16b0149ed5ae9810b70d3cec15c6d163b880b4547f12c8b37692451600e49dc4030a428376a70405648e63b3245e1be32ca536de91a14beb2230601dafbc09643d66d819358e041e10d490d2a2e0f61ef8fac96c97f4d3586a862cb209121b4d541051b4bac4e6062f03e46aba26e60a03e96f32a57f77c2d858bde3a611c8c99a0923439facdbb38898e90865fafaa43f4205207588d1b84971196f26f296ca28459ba44ac48cfe476713d7dfb1640f2f6cab7a508fa1298c3c1f617922567b6c60fe460ddbc1b83a2619513f33b7304676e878382308cf9a7122666f33efd690e9a23d29309db523959b6328ed43ca21c4861516b03ac7bc270b3c2e6bc56b81446b1b4ea1e0c464d636458978bcc8518303884070ee8629a80ad94459d1e8755e0c378ba768940cf1ce9526ce0969758b5b19c816a3a6ac7202ed6272ab5af374d47a4840ae5e34666f9427f02eef9e3aa185a75c53c1dbe7b94bcba31c10f4d847d3a72446b62fc6326e0ae2a9deb0dfa5f7b5bba1c02be6e960d15d536ab2528685452ccc2671df3de51d1fe83e2da51310dfdbc1e3ccd22e4b2badefa03ddc9d093a5e7ea1895face992306a8f8efd99e234cef21e6fbec7018eb4361e6c837f48db50fbbfd684b32d93eea27b7884bb5e63b4a444701e81998701b2b40921ffaa40b5fb7077b2fc3310118c153b3e2d07e60013f1ea21eebc3e372ecfc32426b30166f8a311050310e348d59cf3368f4e5b77534b3af41298543c7d097929080505bb2425a732874ca08ba3f2daea01798f54def303910a43a9782940064b2cb88a518a3e25db1541418a4498e5cc37440026458914e8f769c393f388f137b9c1a0ed0447fb3beb43074583ca8eababa52080392e152cdc08391c5d6dc8ae4aa6701c9e6ebf89bf1d1f1a4472356dc4e8b8f3beedafca80fe1eb52636714ee95c06e3f32f3463c2daea10e035e06cc6f25b7376a8c008d8a8024ab20a47bfc087feee8120dd02d1f4e4b14f483fb546ceaef9019ecc71934d769560af62e2f45b4bc138767e708358e75ff7c5ff457310c928bf59b49e2732559058cb33d16efd1d3234110fc84b1f2c388d5ec6e825c679eb4ba1409a0f1f38adb543fdcf2710035fa0834253cc16ff3ff7877b1e79e01fec045324dd0fb537d915c20622f067fb88ed87015e7fd653e803153c8965747bdb0625f05f9b37adbe5372c998e10256ab74194496ba3b54fb8c57c6671d161bfbcf0ca23462337caa8d4da39beb9943842502934493110f8fb33389ea78f5b27c2f5a18d16ebdf70a5b3be3e5a41fddaccb9b557313cc34619fc8854bea1d23e745842b6e2088e0032215732df5dc0cdd9de903cb84c692eddc73ee2fa3f5788b327b1cd3ec5897b121a12c08c3ff8d1ff2c6061fd1b2c93dbda63b22a92c384ab6964de4c8479513e679b3685bf72bc9ebeae48300561acc614cfbfc22911a08dbe5e1f9f62361388a59417779a632d34df9a455a41eadfbc96135cfa22cadc94fc6d8657fd0509a821a56cef132bbd7e22ede1d138cf1a21077b99fb26c341b38ba36951b856d2119aa03c6f876f5fe8bcdff62b5d0d75add5a6015be9d51c9d0a1adcd0f2df3cf8bb0370c22ca0873a9fe335ff254e833aee7e2ad40e5db80eebbb9b26228e41ab3de133efd480f6eb4b5b4bf21e28dd3dbf49e26358f29b9f747a9cb25057532ffeea98d39fdee146e4b29874389187719e06a0c23881cf1fd6e98c8ae11231b9680619367c1789780aa8a66c9280ba31f10fb1d157f183df5eb88c8f23bc2dd670c2f6167c49b87932efa4a3910aaf1f264f4d395bb9aa82f1ad0c31bf3ed03fa4cf8c9f6235dde7008c1c497a7af9a7f94024da6b6163b0aa2250f27a6fec242210acd5cc99de0b9603dc0e278a5f8f95ef2a4572607304074748914eb4ec7690718b1ddde3f4aa7b58bf14909d82f749ce3c3ad660d5893f0c0a8dd86455281de068f9a4c0f9cc5f5737724dfbca694c9a65555e0fcbbe2a8e3fae0946dcfd4a54e72e83fe823b6e292318e246","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
