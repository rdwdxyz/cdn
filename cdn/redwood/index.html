<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35a162e56beb8883c5ce3b875a11817f5db4cc2e233894ff4c77e1cfc5745238fc5acf3603e176661d54ae7f4f14a124a05aeb789eeb8463df6a23d12bfd7b524013a28e79a47bea35c5a53a46ae4b64cfc90d579a4c5d90b1c418605c27ffced9ea1d5665c17ccee7125a5697cbe09355938a0fb31194f5875fca8abf7998d8625c42ee3e8f0cb925fa1084deb20dd5649ec3f591bc17de8d753b79c7476e46b2ce79d8f7aa40e9ae07c74584f9f432960ad80d28c2200f185ffe60e4da6e04128b9e741a9d28e4827dbb72df5280148f9ef6f02d4e380a18c7ac89c39332bef9d56dc8366249d21901919e6956bba318b0124b28361ef467f1e4fce4cb033cfc8a0f119c243c3c413ac2559d5e3060538ab6a3f28aa60b85a815165df3b2192bacde4720aa1a8f814ad0b09ebdc23054aeeab16b92d040b684c419be9580ed7fcb2dc2a0093557589895f6d2eec50183edb5d9214a70e4ec56f7a301a0ce96c0d05363b75ab9e77632ed5aa6ab1fb8d7a149a865169cd9a7bc32c0467f7b656a8a83104e84b57ddaf330ef1b9b9b068bb3005ddee3aadd95637592714def3eeeb2ee88f227a9c8eadbea103ced1bf5c23bfe3d191edd7508d9217dfd8b306a3829df9118c86e1c55cfa705460eed38d8924db607cd8f1109eae46815a951ea17f16cbc9f488a1d15cb36bbd7ac2affab5254ffe64d2bf68c63190e8508e45aecb9126e50b38a44f0733d4bacb35bcd511ea59e47a338adf50d7fe28c7c540f887e2812d052c53a26f421c790906946c54f875dbba036a8b184e48d9cc0783dcaa41a6fa56bb256d5193232b755e7d9df82af110fc62092bf95fa5c035e973da3a28e0855c0655d0f35857b888fdcdcf39766bbbd3781081e1dd4dbee6513e43de26211aa2698c439cddc50dcb963257073552f13125aa21cb87002c450cdcdc965ac6315f3b0458fbc903e2953b3ceb33e630cdbfa70bd60b2ad6ba3bb8f2bf6ea84fdf1e91e6c5dd4497f205bc01069c982036c6745d944a67cb287b85731db84c3364367d62310b4810c1cb9955f631e3c0829f7cb0d340a7b6f7f87092ecf56979dbecad13acc181a25f88d51ed863b9c14af5ee02df77e27371a545db24895ca28ca9f8ddc919eeb1dd650091d05388c77ccfbe41673f411e0d1152abed4ade4beb26720781ac7265d6e9ab9dc665da097a50812899e5c9761943b20ba0377747d8df3fb64e40444e2c6cc9ed89bc2dcb1893761b473f2b74e618b126f6119ba1c766757cae2b11c6ec179d7b694e115758ec34451370241ed9e13a36decc8e128e91c9816ce3900c71b17bb49797fa1f3233ed726e4f47b84410f12321fefb0c8bfdbcd79452b5de45b22ebf22e5f58f132368aa53ebc0e49383b68bca6ac677f9bde2c216c827663dc2fe41ac40d9e0d69728a0a76cbf68e21d3126730877cefa7c81cd0a5e157b149de4c7b62de5a387ad3f3697014ee0dd2ecbba7e16d855a6d6900517230f7aff0400b10e5b7f561693fba1fad2320cb73928c81ee1d1ba1470a39974f08cc1b07889775acb92b45f818064c56d29c380e317e4af9d38c0d14eb3e3dc1fd8372b25e0a8b2da67c1204ec61c47feb3769eb932a2320c02fb4a9c5171e3c09c482f9e3debdbf4b9083d6c0ace94998e996568e259f83f6e31e0b032b211b0cd00da39964f08a96700cc31cd1c9b42b5065455cfead220a740b40f7a1a50cfc96645a6c99149b4736ce3a2a2d49459cdd9e3e0a499692b97043f7d6c96633878e0487388e18c35f63c190eb4c77e8d633e330f9163b3631f306e0c73d234e3c4b33970b335609e6c4d9434efdeeb3191db5f34fe808f70247f0fd30edded3ba3213bef8efb5e5b0a9186733a729c897b453e614b556707808c595d00f3e20c2c963c898be88d19cca7f548f63bd19ce343eafe28f2c5106d4667bd5bd49f9163eb42063003ac9cd7da2de4766558233bbe243bfd46bcc2448bab4cf0186f5fb286a56cdd411bcb65275d0095c13255ee6e042d689ab86d8d5404c23a03e99d0329e193deb4a799ad5e1f2c96267f5614905120419fe212f8e2ef3c9f961b4040115643ae083d7f2c162d8eca691a8c802a42b32b3f52d2bc9304e906edb3067d4fcefc979d8fc19ce4b1ca55c0ae9c7423f66d0252238cd911ba754d96b7a9c9a5a429fd363d565854ed2da429e45657836acaf1c0ce6bb95f69619c521ea9917bd0bb0a061f264f9ff3f25a7f884f16e94e8ced04d7358c744d70e3310f8fac1dc906a70cada9330b77350d5fcc6db637b5bc1213cd4643183e60f7fa325f678f48faee2f5d316ab01617faa526c01291d716b42167ec10a8388f4b33302b6aa1bbc8ad7916cc1975ec8130bda1d224d8052c7ff3733175585c1ba49dd5898312f7f94f414f37e0ea6e181b61f51ff900267076bbcb26af617ea93530405df6aa798e7c2bb6e443c389d99f7b2544d4fb51b144298848d515da5ac7e08fc959780c520560a5cb936b4c9aadd5593bf6424fb2dc904f0f0b12e5248dce86bd24ef1482d838b3eeaa4ad0bf832b737862078e74ce01a132cacce99028b3b05ff8616a9863e2e886a3ffb7a1c04bf52f78c7e769547556d5419bd7627ee2b99920d32dd47fd8d111e4c53adf7369a97621cb922c71c4a40653b230c41640f93406011274441ab06901ecf2fabdc7843e2c1c7a7efe0ca0944af9feb32878565108670cc2e0fcc0017629fd014731440b096b6ef2adc49f463e6a70eb14ea7d4c577f057bf742bcf31acdad14e3c808292c20bd22d425a193fcff6fd378582b04093d5196c3251a606d20c23f47924d6c463b7dbec49354813a490fab4e717e7f5dfefb9e5df288e2660d6485c18efca0bcd1719444c3696b3bfe1ef4c9894e12166f64cc1cc39086bfb2ddb104f1e990de88f0eef716f92110159f67e9d81cca413971321e7ef539d90fa95c5f81c1b18cc2311b5df509ee3effe3e247543810cca7dfee6bbe23a09ebfdf9478311f29727d10de5fcbce25b563df9c466575be26d51d69edf5aadfb941f03f6a507ad525002e94f7810096f04e2de5b37c5f462398ff31bead40e7e1546891c18855f30f23137f04f2ea654ef50d4013d4d7b5ec34d48bcae0106c6e32936dee4cf02201fb86823636972df8c976f6bd5e95fcc1a20e71819e1c658089b589246dc6c524b620e59a9c9f6a5f4d8287ecca9ddea2456c0a762ff16546d6c20f3f55e16fa9415d8082f21530b43bf4b517cf28f7ebc49a58989ced5ec63b67eaa6edc129c330f01c8d0a7dd4b64b1b10d78be7c7d3b0dc85f11caeb5d6a1e96ea3ab0925e422d77c9f55958d6e6ecad1a6ce18d64fab735fe74f4f49331fd3bdd12b7502a80fd942cb85f9ceddf28121604f6db653dddb61d5c08676d652a100487dc184d9db002f42b4fd6f148d7ce0a5fafc557bd3d0a7082901c7232deb210f87250e724a05c57d0de89d122bd0fe576797958e7b6e71145c7fc5c5bbef18895ded84f024cfebece264d2066fe47200c8160fa3acb7ed6c9025a6185f55013836a6ceaf400c21838e89e01f57fbafb1c9dac52b814f54c60349ce771306a508bf213b2411c77f8217aa1163ad5d3d852b5a0cb4b6f622a9eb787b73a2314b9da8d0834758d447ad3b96990a8ff4ba3bc3ed3a39de4dea6ae2d43ec96d069c128e7edc64a7e6c8243a115d460c062157e183720171bd99e972dce82ac65d4c5d21ec99e22b662f3ebc3f5f73432df2d01c053efa09d591d941771b97c0b86f672040541e61a6837658bf3da61e1ee6af1158349e96cacc280d0714ae1c0a037301ea1c9e5487b4a960e23f17023ce94b4b3bfcd5111812938d33db0c6a437c6f8c2cb29678ec08be788cd15f28ecb63cd474c1ceff6d1b17b9a960d94c9d31067d3f6942386cdc539934279fa42173934f8a89c1647b21253ac7d0909a0d3caf33413d882765a62d20f3e4adc7949db9f475c06bfc8946e18b1731d3efa530b7d0435533f798966f28fe6207cfbe8a2dc1db34c47eedae407a76c8cd6a71dc8e4ce9a14f78e67799ef7580c37448615edc7314b8531ec76ba5b897dfb9a0079f727cd770bddccb17db08fe0e6cb9817ed83b871bb69e74b7a32cd22f6ec32bb0455bbee4eb8086267ea3203ac9ba1463be4759e63076de67e931999bda0bc1c54868e74eab1ae5409dd8886be487324bc06948a6d1411cdbfcd8945b1a14fd05f2897e47345bae36a79c3dc4493ce3c0f1d77c9a67be3c6b14ddf1f0e815514147e556f064ba6d6a6f78c1bde12497e4b8a373ec35e2e44f0e4fd1c06ca5953f0dee677bd916d439fffed9c038e2753713d56ee0de9173e51c8c87a21d6a6376d5a5bcf5699781ba5e59da684e83ea88acf2b3a51cad1ead3fed881a130b93fa6b737e3d19e85c01d51ebbc0ba521b8133f65f5b7ed8bcfb367284982eaf7f72c70ab8a46af88857ab1c5437637b4d4e611881197d54440c73f375e08c6a82db45a0cb2e97216c340e372d60d21cff47f7dcdb94701ced9b86a416351ff52041d94597cf665d3987c51cfe7ba2a6208e1a5222977b2e3331e9f448db6ac710d4a03e03c928b9a12f41d068440f7399cbaf3e22902bdeb00a8a359a25b21da7adbc49434ad00f5083782e62c67b11519f0c12f223a94321d98fcda16cab598db96b45ed82ec0a223abc08cf5d7be4e5b80bcb6a2aeaa948c2828559172723d0adccb4a28fac7612d03d684bc8bdcc0d1bfcffa9b98c6855aed7f194478677a126466fc17dfa2114e478cc20af3237dab7a765cfe2514f45425c506bb081a51c1bb3c81278737fa298d813ded49d77b0f98dd254e2512c4d5fe7677d66aa046f3ebd69a7dfc00c24ddcc5e5b96efe38fccb5c28ee5554560f99346da480bbfe4ce48475eee0ffdbb12e0ed0fd68dd1774961ca811731e1f38967d5d754aec924d6fd52fce979fd9b383dc656a5ae6356b30e57da73182b7df6338a5286379ec7dbb02e90aac353accea8ca6840a1e1caff9efae2f98c441ac8c0617d182ff7e05e08a476aeaaf12048b3ee733fac4bf071f39dcf1f17eb9da8ee5962357c0088c858f9ca613855108304c6fc404db56acc34e9d6ab69458606d8bf31faaa1494447240218265fce88ba3b4dde925acc1344910b3b1052ec0c6401c037febd1e6a7f2d7a7272a5785c10714b278a5156cd359e23ebc86c2188fbe27ae97908b05f93ae22d8d450fc1d38750a04bf723a024378a6f6f7d6432d199f8d3462d38044e13ee57eac71924adae1f3df202bf3cdcb5cf72dc515dabc9ab14145ba5195db52329f11ec943be0ff56e79f35ac82e80f2e5985759e037dcb2cf7dc11a273e410bfd0c27dbeda1c99a801e7f4ee815c6204b9a9eef89ae9f0fc19b7c856dfd69a9c2f0ff4e1b0b1acbdd074c836efee721e4610257145387869cab8d99557249d078d147ba9d85674505b508e393094d91dfff44cf9a925c0d8926abc268233604bdd3e08189b9bcac8d4d95d8fb4190cf6046c0343df49af4881778976ebe1553e984ba010cfde10ab639b16ec5e8cf93b415df1a5920c31464e80653899e9ec5de636ae95f71e8ba1dd793c9f54f70277ae1f4b0178f619c1857560cf2894e81647d989aada851f6d55e7aa0d7627caa0403e7eeceec81b147c9e8d42a9363b916d3c69c45d715286debcb8a6bfd8c517d7afc738aac564a7eb92b094ff680f67a49ef648e5f415e8268feafcc234ca18e908cc48641f1ccd3b9857cb01b3780909a64d9938bc3de96d6dc07fc0f326081011fe693e65916af3c10ca72833439dc672fa00209e5437fe6d35ba6851f36f2fd8fcaabc8b170f204f1d602aa2ade6108c8ba26c3b2add7f6ac769ca90309f64279fb76273a39a8dadacd50a3a7f07370a081173a09ae1e9ad3eb3975e89a46c26805c2cdd53981ef3da60581b6bc7eff5cf2ef2a0f163503cc74cfcd3485f98d746837caede3b95fe8c0f4d9bccaa201a409760a10ea091520db1abaed16c246530f35d8adb6a63c29accbdb0cc70be6f25281abd71ba383f0eb6cfa069d1d542274e61ffd6cf2a66be52268fb6fc16c98278a14d1dd36024218116e562c1865686fc080c8912bd1b2ddd9dbebe82fec1f1a74400f4f2cb72aee28d871f9a6be23fb92ff71b450175e959c1009b18bccc713c7145ce128a244076b1d3b36720ac12150a8216891ba368673527a50e4e84d926f05413a39aa692e6ee4a5726a26ee9ad5da7a97271fd0773684cb2be4f3220b0ac3350f3c5aa6b9f2cac1a139f271aa34155a28bd80d6d48fd0e4273d4339c197dc89917b54b0aed99f206ba8706163bfc235bb07b9d538d07bec07d340728386b32d9001017bd10f46694e8ac9d3dba75e786569ffdb05cf6277c9e03b7a0e914dcb322432cfe53e0e5a4c10c25e7136d830a47a1818f94a030377f0f154ef91988bc7a90fbd0009febbe0e8345ea7259036056baa1154ea4072039914d8cb5eab5457ce67b6200991bffb75a6f8c4519394c93cb8396d246d766e00f68b663a922d37577dc4278f16c6c407da8329cb28366fa45cafd14d467e90682866210b6d0251de5a202e5cb6e481269ae95272799f73950da0649170971ecffbf43f2afafdfe42306cf5b6f00bd2deeb440fe5121b89c59667691d659a5184a02fbad40911b8fb879b46aebbe36013c446c50ff716a61b981249b7c002daf89adb61ca5c7ec245a39d904a1fabe7f097aa1804c1c6ef39a26453d447c6e9bc6bc5e313511a83079b4ed5bd962546bb92ea2455c5d8c156d595a89feaa2755c40f3dc20afd086d27d188f1668e2b0dd0f1056122e823747296c449f9611ae90c07ea3e9f5c1891d22340ff162be724ac28475065adc89b17a3f25e7f13af86213ff167ce43571121ce3aab90a842d2d48ccddfe8ae1274b2c7141121915a5ebb1820e1a9bfc728bdbee22ecaabccb952023de3711197615d7daa1a3ffadc5f624434fc1a965333cfffadb493e26314a170c8ff3ce34edd310cc886abdb1ddd82a2a2afd5cafbd5984894f046d2fcfaad7ed1e46e359b509ada9880b2d26c613096f936428b6d1bad5d00232403937d9020344fef279397ca86684cae130dafbfc802bbf2e6faa0de50299e1102467336a6cbe4076540365437ab49664da3c3c00d0b0ad2286f30bca5cc26125718323c71dbef81770e244806a565bfb4ed090ab6e02496e3a65c8ce3a6fe1ff6eae08a190636646f592542117ac14387a4678fa4f2880b14b9920ffa0465b1ee62fc8e668a1e813de1d5ea448d123d6a80e73cd91fb714fe178c171e6fe7156a9ba0cf591bfd0c2ad8a027fc07832400659c3b54b74f3e293a5d575e64872d2e02c73880a7e26e050cab89f638a4404b5c8b82d1f79ae185a4546deebc2c0fb9e6c2783b074e921a218c3facae637aa32187a407db875cbdfaca7b429951fd66f67e1e035b6dbeb3f5e337d275955f9eb07b33e1e72350ffad025fcf66d688fc526888c38147cd66148ee4bda6198d005938bf38af153ee661bc0a99c7cc7872377f33458ae2eb0400f813bb86be0fa58d19d64c56e594c3753cc87d031ae267e6b76ed3d0a756f41c446ad6a8727131d672644302fffa37736a2c816985b7988a237e89250ff793b48daeca91cb3cd53e085dbf7656bef328ada0dd3ceeded466e8216d1771e9bc1a2dca7b94ed73aa4704f02355d0c23d13b7ed2fb73ccbd737bbc371d7f6c54f155fd177bdf530208cdd0d8fe759e2874cfe4420c00b58a6cd57aad024c544357dffed2f362c6961fbce2921cd1f77acb7de545942f3fc0782469516983d7b13ed6a169089f3172ffbc6a1ce158b53bb59158f18a204dee9fa922514525be40071b3e975675a7ec294d8d7d9dddd57019e4e7f2a366644cd90fcf06656386b1fbdaa45cd64807c99684dc5e4602e0d10ee7f4120057d44c1b7668de9ea753c5f8790ce465bc569d96f5dda7d18c1a9404d4fa801b3cc2ca675a6c8d84812770b4eead0eae4ff5c6187fdb4d3dc97b94ea6911ccdcf4d8cbc7e0f635870d9eba9651ea5506de56f24d1d4e9e71bbc958ff75af2541fbe214f2aba78319f097173b083c55620cbfbd2b6808c7ae131e0f0d735e65a16a125132bac1e8025c4c5402e4cb6c12a5de220931a9fdc643b4abb9b299cc9dfe85b5478cb43a5d8b7c077cf225aad86601c848237423b70fe027c965da3ab5ef16e16a188439883c05a092520ea21076928c46dc8ba5abd4c9b7d4afae44a5ab8d1c3cf1010fb0b5986721d61e593103f86dc1cbc6aa1f867432f54dc8ba3731198ef9e1e7199dcb0225bb16713037bd59db695e6bcb5ec475e41f7a4c8366ce16d751476c335d738996e9ebae7a116d94a5dcb4b66b4cde0fa8e77524be4acf73494752e9a6e8c9b93d2dcb6650e68cf44c12a6c3b602b583241cfbfb35b2ad612447b0dd0d5d5f712ff232427ee7bc2cf959d8747946e36340f1a80bd653bc1b65a8b15c6cd10e7971391e4a1382643ab841c50c7d21abb970d2005eb602f014f95c674e32372788dbb5a2baffbb437ba8d4ec4ac44f379a09b1fc29e9afb0b84dc0ee316bdd63eb4e6c37f6879adb261991c845adfeeeae82904b4c789a32574067ebe8c92b4812c0b3d058564586a4564473a90e556bf6ecfcaa9c5ebcc33b738bcad2cf5da88fb32d00f96d10b4ddc81d2ad095bfa1c97d8c4e1e50b8e2f10ee675d23e785f2c27a85c2b41377a1eb1515358e348053de6bf2b06ce609459399afa1828337a2a4bbf30bcc0eb3af25a08f2e1e42b922c9098a6ba9ff17e388287751f287bb568cd0a46829e329dc79983f1d5372910232274fe2fce7fcc1140a38cf044eb501e1302e0e1991d07a7e8fc4f8351ae8b8d9890cd413ab49875684ce5a6896758d92fb5f2abe35b0de2ce56c980b2c960446d2935f0f127616e003c7d609bf8e4463a065e2089eba92df2c49fd659a7902b02f9f2c7f430eaf7427067dc4e2822c6fdfddf0814d89c26e2764037512e240d5b477c1e87a4eae4693f259b0027313149fba90c67fb2e06c8d50f2455786622737ed9e6a64dedd341205a95709d50a77b387c592dd438eb2f9de7a9dff1cce1a03908318e8c2da87ededf8efd873ec65e805251af394661d6ec23b0c7a726227713c5e8fa80bcc838624ab5d86ab9b6cdbb536e293d44dbcc466ad065846cb147a4a315befd71dbbfaa4a01298d31d40e9df65737548659331e121f7678d7225d7b4cf171c716ce81fb68b84b449c71e6e23bb2a08c2ce23366b423b56bff5dd37c08534e72ff958609641ac28c206c83f57f4658c3599c7ff28274772a2fd831fd807fd4c595fca054c0e1226dc2469767c0b5f889d978dd02cc84bdf7199765e3069e590d57421850c24fe8df573e67f57c8ecc3a82952917e1c8817b5734363e5718ccd998d1aad4f6e2fb67a214fc011a0c2d1bc866c6f0457cde977cb3a559fef8379011325c973e254f8a38ec94fa244d52d6352d8e59314b9a60a575c4f55c09c3f5a573e1749607336d606e6c4b51248093c33f2212886c0af877fbc787106b0e12498f0459848aeb5a6c3aef6d24e54303734d7c9b4e44bcac19361e51a07224273ddb5185323f1bfb00802223462e89f3340d184338f141c2e5c2dac719f9f9aec980de68a7fe0aa7a6d4f71008dfa681aa23228947a165452a82ceb03bbc65bfbafe4103e62dc858db8b744ac14c35655a6125ac956e8a9ae1ac2c516e14c4a5b5435a12f1bb86e974863e21f9390168288a3481f15fe5009cfb1bed243ac81b0844ceca045ae9bda7a9550306b13fd16c32f47c4423342df973aed699813873192419e3be2353dc4a6e3ada15adcaaec462ac8b7b8dce82c3b5267472a91f4a823c8af69ffd2b0d9d10c41f5e6b6d28e782aa254d782d71cc8b7a9139879c201bf557cf777f30b7cb5a969e12c84647a9e0db6d54702bbc66742a8f97db8a3818d37a0299fb154b51366c94ebb435224226178e6a29152bfdaca1af600115a1624acaa84757860a233b318e6039f672b9a5d8878b3bcb2302c14813b30d1442494a33774adc0919b0ec074ab3aaa31b81dff4e1ef2b3c2aa1e9ce20d7a1249d3bf66d3fcb39fd1d4b6872bb2f8c229c3e0f9a97de0f438cf018cb7db2b65d7d177e07c81755964589ba81678fa8c27dac3517221aeb3a920eda71be4dd34d14de88ce2b2794b8de4cfc3c359a82914a61061593a163e82bc3252c71f3c68d4438591c8a70a5217fc68d8b04af6a70252e327fcbea635d77f7f10a92a156e9adc23e446cc92c05b069ea05c80dac1ba9a43e723d0fd0b665b1b4c2ac2141a76b575e5e405150e2a28a3ac197717769257159ade799219ee3b363f42bf28be51ee7f1857fb28cad04e882d4ad408dda4a832cf9a86f0a3e6303781809437fe5751aaea64aeb3e731aadb84e2605cd9c3882ba66e69570ae1cbb20715339b98740fa503a8a591de01fc49e293f21351190d2cb8b395dceb7e4059aacd953a44a2a2826b82bc398ee4028603a55a373b3c210d11ecbc366c72b412293f643030d978922ecc2b954abcd0c246885705933cfcf5ba6707cd96db194ea493e9a47ec7254ecf1ab1f2ef8ae0be17c27946b05cfcb67bce2d88b9bd926584b406effbb97c960680f349d944397a3f303e5790f30c3b8e87046fa224c05f9ca4e6f773f5d5ae957e15c39dbdbd39f90bbbd868bd6acd1622c712e081f168bff1551e321a45289513fb5683d2225dcb9ee825065019d8892e578ee154fca175eb46b18305f42ea87212c3f7f60f176bd27035d48748081a460f3fc85f3dce85e704c67131a83fd02120678762aca1025a41439e2e810c07f3a51768176d290b9a32f2c9731e1da6164ea8227ec75f3e145948fd55987d326c6aa71496a52aff81a79415be857670111ebf76aa1b106069b8c2d623b5339ef2db302467fc4e1b0e3c3cfd94679aa4c9f6d70778f65b5a650a24e9da0e18adaad0bab0ca5f08346183e21595cc0faf031fb470a4f6a1b2d7476007e09e4d3c683fe94514e5b321cf5d2f8e11b0dfef6edb54e786523d965929558ea7f9f44f2216b1d3935f201e96526cd7680b14105ab6c94a09255ee2cceabf065fbc47489c37d0b5050d6cc1a7b5523b705c9ef19fc01f79554ba2904f3fd07c74bb8b875321a7b1be2193e8302e3c6ede90b818c9682a24e16384a56cbfd864501a0e68c056649e47c1644d22e6081fcb1e5630961dac0991f77fe0622fb46ca7476051e89e228e857362d250a32fd97cd050cc4438c1940abd2f812b7c456b147f21913ea68605d13352555aa220e79df5a5214504bd14948c33862735a47c7c609d96ca0f37c8483977f517f530ab838072d63160e25315692f04eccd35fa4afd80a679ed9023af0df4df7f2c32edec335c41e308046b3e50ab4c1171e5f4dcf87b08c8b71983e8bef17b22d6c73b9089020a58522e172b73ee8a171a64a7cec807a70325545bc9c4ebc54866119bec68d05128b289cb53423aad2b1411dbf78e43c048ce7bd5d681e261f1d351be33f6b79348a10494e3803b5b96761ff4ce029a3afc2ec5fd42dc74557b90490f40e88c4c424d8c476290337125d7be4707d2e48f7e4894d09b4a79df0ec003999e8a3c7fa9c41ba0ff9f1009f4d4e573dd5a2eaf82a0a6e8dbdb94bf7f9e7813bd76cd2d248d854962a6743685b3950f50d8aa51197a6c4f1972924d376c34ad971d197c4376ad75abe2ec22e6c5f43d66fa89ab85bb9a90f5ed3979877737f36fb92c8ccb01219da4046b8d32c0d2ed57c1290aa4e5e887ad089bc6371677572afd22d96d2e664ec6bb12ff49a4f975925ad59fb0f4b93f8d688be93b323346b8cdd6f644e436080b0843eafef17c69c361455d70309ca94dc09ee35460aa0d0b4129673bb582f4e49d8bdd2452f3187901d8b6a90378eb3e3ecfb0f965541b2bf5faa70f36519035d8dd2a5572c2f0a69ded679568fe4f0e774fdaa008b31b6dfc82b300857cc77c92a253595b2404afcf67dee16f8241226fcb8ff6338aa1f4bd2e87e127aac022287ae292948afe36d12e75f8e939643c396734cc46204a2466abbd6a01fb1be77320d04a40896b43cae9e9d349c9fdbfbb40c48e1ce00a6ba2800b420d0006bdbc77c80f6ed148c7601c00543645d6d9407529d2f9bc77a238b5bcfd61364425662d09ee5d5d879b610559ecee3ecca1dbbde56f3da80bd56653a921de7eb86e9e566c1718a3bb7135ce4efdf9aebaed6b3fabdc01ed7a6edf2864ea5b62c95ceb92d75a4fec306bd0a501bddcab4a885f38a90dbdb46b0370a19837e087cd6ab24848750b15a13ff2d31ef74f913daa9f0d7e96a417e9a07fecfa6937d8ce3325ebcaa605d80a835da91b7668d561116f4f3b56f1a26ab3ddfeb7c817e95dee28759a68396ff7f5aa1d35789b2c6ce101da432a94ca04e4f10c324ee0b00305cc979b4e6b30ad5a27486893eff48161af90a3530a50744b4ca5f2e80e689af34e409c3916ffcaed55c72b912e9115f9df3f582ac8fe3ecb0c15d3697b29186a2040e4b80f653540f2f5ffa60c359b6b09514e242f0c70114b5d30b31998c57cd353bcbbc8a6c1716c9ad1226b2c06be97fd2ba8cb3d8c61a50d787fa0520f70a3b291125bde58143bd83ba42ecc21a782ea760482a9717cd6ef52495129b7a34240fbbdf544499a637a397927b061bc7c13eb246769cd7aa8d0f6a915b42a28088f603ba931a564e22bbf4cae4cbeda31cc99d8e1df7270c03d9739ada163d492cb62856b5d300d748eb6291d4f8c833fe21f6c7e91ccfaf533baa52e43954d6742cdbaaff17598c45e242ec7ca5bb590512ba5adcbd464b9ce853704432c7266a915f172bb0d4a84c9ea957f88f287948b5c56ccfad4b443b732a7c09c0a460aa498c03cb75def2b674341bf41fb8eec6ca83b13af3bb3ffcb2186b4776b1c4ae9dfd2ae26340b4727659a5eef8dd71bb7103ebfee4176d7c2acb0df451e574790cd3c6a67fb12f3002841920cc1c4bdd53b335421a395fd43bb627d3cda2f6f539be01b71f8c6a2ab6dbc618cfac26aaa26ebf64819f052934c74c8266f0d16de22c84d2522a4c687acea4593db8a873ff279a4e5ef5de925eefc52b5be7f439453f8123c7ae5a1e9c97ade00b6206bbb71cafacd607fcd89a1da04676774ffb440bacd8a816523788be1cd14dcd13c505b1b5d942d3c2f7f9c3d4543818246b5a6a1e43938325b5fd239adcb0ab2c5ec1f2863eb8f510b0c87862fd3747ffa8a36b4f315b7823f07ef06e4eecc37eb8ece063ca61b9efe7eca387f1befcecf303d890b7364e05a0831249ea61622345d3051df6f0a830ff6f83716d75915030ddfea4920b1d17abf8b2fbc7dd026ef653ba286280c975e9215a16e9080f57b5ee4f17bf68d1285a5f7cfc5ad75d325ff6980048a3e4c9d997a48099e572e26efae97ecf4edb39afec921ba33601e1937f6757f5d833bfb5e2173980a7d49fc0cd1982dc5d9d16faee3f6abaf1dddcd5dc7317ad04f21bda645deae9cfa557246ce2d81d63b6286d51546ef8a5eb0e7726b4f111ce350e41b3b1fa6ab2972f991b65f7e76f6d13e3a3d1733e57a6b516088180162f1ab55c2a1f56c21180421ce6f24c4b823cace07a3923f156286b465d692d77cbba5d097c14d81723dbf9e6f9a7bf4d2a892091b01e9683024539c8d5d32ac2c1f80a75786c0691b99fe5f4661e5065a829630faa7f7494542c45421b542dc99ac95c08d7ba5e76d26a03f4bc931f9183c7aae0e7513aac34f1e9f7769e06fcda741dca64da4f2c553bace1af6b1261f1770b5609b436ce9b87d937b954736c669c161545353043810b04ed62509707b87717c3ab48d34d72852efd1d85742e32fddf397f0720a79ff3dcb382776b46e81c1202842495f08c475adabad4a625e40c58a61c4af796631490d115630b104105f0071faf1750e86b5807a47cb28b68068f355e9b2781c3336bdd950085dba7cf9b3fcaa15c1943875cc53fe879a2ab2f05b047820f361d9da33d2622f133a8015868fc27ff44ef936eade65aafbeebdbb9a43cf8f6b27a7dbc487c559ae60299dbf6f253d6ee29c17e9da63b24b365eab57efc8ea96aa13d59f5049357b54f53bff6fc1a08a484ecd19e842aa5955e246ff7fcfea0d47cb5bdb39be7534e359acce2f3d55190c46160f166d900434bf7a23f5856ff16439104e989b4619a37217d27295d06aab6590b24a2791162d1c406f50750ddd059c5ea20f58ed26674696d97b787d7d9fab5ee8ffb636ce0c5262a6d66e2a69451d94e228bffa1517722e30500be7af7f793aea421c4867151c20d396f98955e7318727a3dcc88649234871c403f281f2c2277afd18ca969290822b6f0b70e8f99599176e0f1c9bfbd971bdd6a9a07fcfa5ccc513bd4284f072e015d2c4def07a144238e0c5d8901af36de1c4f8e1fe357be921135cb36fe749a82026f65dda2294db8fca3ec321afb1c08f00d42bd6148559ee9410711fc7ac867f71381f099f11af4c3aa8a5db0e46af4a89d9f2cd760e27b740b5bbc3ce3f246dcba20b9b4d7e3fe022fe4507f0975de9a41d6aefd61c094d8b52dbedf6a6607e22ab45f10f4c4c3e327f499d49aa270ed0b1c4af1d903d627b5a275da2327c188f50458b68a01ddc92ca0fec3d11b517bec6fc3cc6150f4fc2f7aeb01b48f7b4e2309340b9f7fd300e422c8daa6af4b8719a02dbede5f93fb0d7f380c64740912b1e71af2330065d3d6dac646d615bc7534034310d4b67bd61e203ce7125d4a7469b1e6105b839d0ba5664e2160d475feae1c37d937d2d2924079a59b1d8fd4d689db544663db3d623084d21b218fd6017874fb0e60d09d1e1a7d0a610c92afd19da4f70d83dc96e6e9459108aaf219ef477eab3d91acecf21e52aa4ed2a2e5d7733245c514f1ed1f92e8b51f96113238626d11a228dce8a5c334cc28aa660dc75ca30e9197a176ac9eb65be88c1da359fc5b326c3c6b9f3385182d8c9d11afe4e0990dc5cbce5e115f0094d50917e67176269088253bcd6ae01db218fb13b84ee5050f77c1dc17199f5a42cfe8218402ba8933297c80a85cacf9dd1effa92cf6e6348c4d9bf4904fc1db44d611a5be554f0c1445c6ff4ea6a8e79c0e90f815de9554b52ad32032e609356a7a94a780670f2d4ee9373adb46042740f9726dca5be04782d9314446f532f98c40606671835376a9ffc3c24bcbb103ac177f0bf86d0ff27a821cbb12f25f4313b9339470767756702f89efcb12ef9ba2caa3aff7deae784b1260cf446b013595020e3c0e45e4788657abdebcba71454b1e2339b646fa1146664ee7b7ebf9e7dd6cea68d17dc24958d89b9994ff9210e6dec0d26efd98a0dde5f54bccf814b63a27a02e0e06b9c64404259303cf0d3827d71625e73b106ffddc2b4350ba02478c78eca44502cb7d10db7426513ba05b4bb22251d32a0fb5246a48d69729d9707f8f352806f282839d8d4f0cb5a3e77cba8fced8da3dafff4db15639cd060ffbdeeb46d5a65658e9027e5a8e691a664df30f2fdc94f4b84e5b5df4a0a3df76bb94a692afbc81859d776e878e2e9290f15b4a15c89c998b5dffcd3874352ffb50e7c3e251757a896d630cef70b26f4d3b50ea519d125bb36c3df767d0ebd440e11f7fab61163caed1445d7ecf77d655dece5f738acc73372c0916bca7ade798210f7e9a4c5717961f641ab48093131350fd2f7be2b317684d23e8b83c87a3a8a5011e19b4787cdd268430e30ae09a3c60ff786dd9c5313654926c437b069366b656f56c31a4715031a5f0dd2e07b3878d4d619147eb4d48f353f239e4ce29e8d002a95e099b372499bfcbbe055a1145c27718209b798dcd40a48adbfe94942dc071daf149b99de1995a34b9541782322ce451b3c93c951e4e4dddd2158bc98b221d63da5ecd691f6f171cf8cb1b03cac75170f613c5ab270b212062173d2e3ba0fcb1a221eb6f20e8cdcb4f0b316b8c700e40ccb46598ce919ef35ce5ca98ad782e2a43f21b296422f1801a387503e8c2d0c0aa780f35d75a4e0d990d97f015096f8f10cb7511d6947733db59296a75dd36b301680133a12d934a808b8f024719fc0de21d02b8d560641412063709f26159111a2d6ec5b9014903a3ac3ba29b5448226f3b35ae4475ce11d821ac58dfb8e2c30175332a27768763b525ba7bdbdc6859475c3baa6cab5ee4ff3fa031497ce499fa58c01c879380c9ccbfdedd2aa9744171c6bb76a9c20b5ee949cd3bfdeaccd8d518ab079186b3cbc1879ac138e55edd0246ca34a609214b32a800bef85410811113754a23e2861dde45778107be6a43bee139763e75ffaf08d83fdd9f9ffbb371e2b54b703c9e35fed2e2346a9040e58db62e525bb22f71273fcdcfa97342487757aaf08e364dc785e68dd5f546d8dfded49cb81cde903c3fe9df35a75f4bfd10a8b7855f86a4a14eb1675d2102c5ec010f7613cf701c0bb5b271200c0d8100f1a1e42e959bed9b4d41949b0deceb7247a1241d9039c4bf967cfae13fedd758ac36fe6a740c816cbaaac0f0f0c9a9aa237f6b128056c71155f7092160e5a2ef3f5135a2899a12521d9fac5eb69b7b9c9b33a7a63077287a5c380dbd488b9a0df3ddc0acd29a4a7122fc596c6af2405d15bf8e0841c3204e88dad20022f3b1a91fd821303a09576a1d44ba412818711df7e22a0b433962715e34bf165761942381107b31f6ebd4460529cef33bed3d2d0e16c217360e1f0b9f41730bb760933ee8f6fb7691da927f687be93fd32c61feab7f862fdfd0bab989364a916e47a9f6362e86bc8e40d2e1848780c1a198645c780b44a20add23c98da39a5c6d452577f1be6bf992b5a4004dad0f7d069f97c0b8e917edd1bfbed64f0211e9934a7fbb51ff6605f752a2d9318502a8f8c66cece2bd522f630b6ef7e7cd5ef29c02b4b6ccdd76b6e269e699cd4e361e16786f8506033bf300f948b5c104cd4f6e3e215b758a4c5351d0f1c24748af354d74bca78df9c307bdf829a4c5eade193f4585edfa462604a977deeb4e37493b1406a2e370cc7db7cf66f38a2daec44357ea6d27cd2c3be236b7963775d519743b746e2963568ed99e41bc0ee801b4bdf89b806f469cbb9b7f5577b06b5b7a3e99e62eca2d94df27016f7805f758f3fd73c008c7ac3554346b5b9798a97ac2c4f1749e2e4441fa9532d9bccc3e6cc1c2af30245f5e2da5a25e397d10e94aa81bbf6d71186a27885c52eec1b5ea70c1a7804dad412bde6f0809b6c59e5bc492eff33f615002573e8a593d7377ec7d463afba908b620c1d18f2a99001cfd201b24000900142dfdd4d54415106f77686287773cf4e1bd9fc55b83009b3368e64abd85da638ae756bbfd873455b629fae55e72a21fbff1ebf703b83fca34f9e6c9ca86fcb189f12bccd1764fe804dd9b6e10fda9f929a02eb5bfd9811d2e9cab25ec6b358c0c4f7073b1e48b9520b4b72ccab8f188bae8c2c76bf1d317de5d2f8798386eeb6979f214bf769e0cc87ff507b2f0dfb8bed0dad32382aae6e99bb7f5beeae9c2adf10242621b909c92560917e55bd7b50599d825ce819309e9bb0bd785869b5bf58b84c3909475fec0e1f9aee5e5a0021ed644b99afb57ba7e2294895e3151c501b68fe9402ff20ac7c33c32ff72373a87b7d189d78778b659776cd515ffa5ff4b7f4f5f7f69a9f1f36fabdb6853eef3da8ef6374e5f81ed37caa72d74c103321138e45dc51ab83408794daa03093d48a629067e360013d631f516a9077b368ffa1f5c405c22b06d8d3d9de38b21a1fc8a58ea567f318245f180c767012cf6da9a4a0a60bdc76732c582e3a7769b2fd2d66b7378942ae02724574037d437936a38f771e4e06dffa27f215fdf4f45ff270b404111c963e246842d29aac0793cf18c7143abaa4c91b085e5e4f19a38c60da3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
