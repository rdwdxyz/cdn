<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa28cc5d5584896f277411c849af645534c9fc2f8559df493b934b960dc4f2e8866f0b95d4ef4e675559e65595c855c0451899c7b52550930f531dd7de816bcfe9687ca1c2f52469551392403c245c0e4a38dac4fea98563a33af0ac9d71fca6679c2e5a02a8a399ddb3319e9a7e11eda9f91320055aafb7b7066ed84802b5c9eed3126bc19c664b172c77ed22e19a9a3078d0c37c2ac47ac85735cb3250f1f9d25096b1f34138861162315e64cf03202d174460b30761ceef24fd3dd3466a71b42344bb4657095a218f1994d10106b8e85f0cde961ebdeb4aa6ef9624982e18058256384c8f490a37dd6f4a58ed807bd1839fab7df1bc4e64979d7c24125073c9453b9b9e95957268cd1b8c0db98a9ed82ce4a5952e13b1adc7b3d43d4c974cc056eab16a8f4fcdbb098e9d67d370ae4aad8e8bea0aeccb624e92875b8e2c74444366ed1f00a0ebac9277b6bdff5d703e42c5245586c11371a7f2f974d7a27ee53a38bb02d99ef672ffb1cfb48655ee3d601b92db8a9148aef2ff99c47e45a411981b16200c0eddd93bce52d232032b6ceaa79d0d534df01d7b9cd1fd9db514420b4b428425a36f2786b2c20cb870eebf49c9e79a8aa0e128909a4ed816ffd9110b8f0297b9b778a1fa17c104285d72900770e1aca39ac533fdae39859b20501bf482687b2398e8ab29668dd177b2b36eb4cf7aeb8d526907374e57ee75fa3bb886040ce1d2f86a0691914e2c6ed66790e7ff7d87c4c38f846b5d23c8ec52c0a3f1c9387a23f2a5c6a7691b9a338721b7b68830f695b34d544868f6da9b2a50193318594f2346aaf8695ef7f35b5345de59c9d7fb9375c695ba9e10d71df9c4a309c6ad6b7cd5040db87eeceed426c67ce68a780a67dc1f90373b2d9b78023427d0330dd12467ed6d287e9630d8723948d27306b5d2498244e6ebfdd7f3cf6f6af5317abacca20467bab7e17cd136ab51663b8d39868d6592e14c016c89c0daaf2f8e617ed94661b6b2105e0be8761dbacf59bd08822e5c7674ea84678783dfbd0632a2c64485c920124aa53e54622a2ec1560d3b8da4d764c6c2f56d33e5d86d73b1c552c4450337a3e5cdb8924a8bedea63598b3e5bb47d32b625f833a0070555286ed7705a9b5a27fdda737efb5656975f7f61de33779d296adeb5ba990e4e024daa8fcc44b7752008e835fcfbaaea123c527f18ee4ef29fdbe97f3e23d0eed5b21cb32ca926b1c6b82132edc2450b7805fa7ed77ced823e1c5adb3ae665a603b50fcd7a8d42f57068c3e63375c97d7f89994ba01ebca6d945651352023cc616599b798050b379f5245a915cee84407cba642b6e7c63196f8fc819559d618973f1134a0c1dac29d7db9942e75211ec4b62fed9a99211b555d9ab0a0e405815f52eeae8cff12107d5e12090463ae66f46f2792ef329a65f3f1ede6898b58cc0bb4f47517b34ef0faf4cd1fb9f879a91a3a6b7029b66d5f9a6880f285d77cf35b8278b13519ececbe96fd65a5c51bd91b53b5e9ceae66429025fed88f3f48f26b4b33abbd7d687008d62d55ff5da9c2cd9dc017ff4a72da7a514534cb0b641efaafd4ed32db72e8a077696d79e0bbb430f6fd684bc63d81b07d848667ed583d1b23dfcdaaec859c841d8ea659d48868584da82fed5ae3a9021df6db975f5901b128370f8b89d5439542e556e6df963684627b466c67ce1dbd0ad4b23e1ded513fc85b5535551248cf51c1ad48a94a678073a4bc8a1ac84d424e80e5a3ed9f66aafef2f7e0db8a69c029db48f15af3cbd1d9c9f665d309ccbf6d8f880eab55e74cfe8e18db19ed608725bcd51f7bfbb88b8e848cdad27d3017f217865109ee31c4be345093cd84419d281a1d99877761e6d7a7fe418f75f09a3731f62c4af06969143c8da9d103e90185a6989aa525f93dee938d70729cc2b4c17c6c1ac4bd214bde89ee4ca1271f8f8eb5f7c94938e770a51121c3c49002f720d78bebb0c22f59ea0064b08e1cdc071b5e79c953efd0d4fab53ad8e80ef20dbbb1ce372df645ad20408531820664a77db97ee020c2a473a36381f4c86c921bd2ebeafed05d4f232b422cd8797e5726d947c6f3ed27538445ca5b0a5a59e0d8d5806bb0a6a63bd9fc710fc793d151f9ffc9772e32484752d5731fb1a2ca371bd120355b4155e9922ced71c1502a799e429fff64bdf6db6270dca8f2a4ec4a0776a49767a0ee08260cfaf05e50b5bd3c0e17799c70d125dcb316de3c462e26f8e25ddd37e0bbc0883eeb8c15402b353f462b0a132643fee5f1e4663f3d3186a8c27aa949da303e7a1fb393d89816291f784ff3faacb6dbc09f540a0407362063491f1098766f6b84f4808fa2931de9475e23b0db23c6ff8e1c0cdf5b4edf5cedb7af871d361ff287f07e78ae554b7cea280db254790b6e6a632da0ad04fd31f12411a7b944522d08381018848210a1c2c68b7b3177b6a107bbb6812aecdfdbae58c4f8b298c3a3d56ba7c3736f15a4a48e0d0b4979b562ed005075da39da2f67185e13257df7c8752b5401e58d598ef16a224bccde5ca8a08f7ca85844f27498f61ee55eabe1d351653dd08eafb0a0a7f1371a6bb629ef3ef2ed701b9f7613a4541373f75564a80318c360d2b58cf53e522759ef0c49a5b8fdae031310b6cd74d49e2a37b54907559f6763b4f13a0fb99b24724b5b958e77b737959d777c43a2712e04a1d04e7c26f154d24cb30fae2eff3fadcc6b35faeedcdd201bead6bbcb9f2680b9913450ddba58b3deabc3ac631415c3668e3907f4eff947ef7146a8b19e289f0f94660f0fbdcb7bd7abb98a098385bd147d7fa05af91def25d87849245341606c8ccf452b2da8a751d3816e488b09c8a1d0073476226aad67dccd83ff218b6312846a056190bf6d2849f7db72e5d9734c275bc479199800ff09a543f558ceb265c55c27cd0d0f48d661f80fdb62882ea8d8c23107d55ff4bfc5d1aaef15daf2a6d36859b48e7e9c77b0036faf0fb859bafba7e9d7bc81cf9120d44ae22439865fbac01641b3ced83802a8c6c6fdc760cd5e35367fa98f6ed1269b126d3c192ae785d0005285d6970c6e2c6da756436006efd03ab43efb31ba0cee1d9365ccc73477299c39fdd021782913e55215435c312e25c78a43b9670b9cbe54722e6c141295ad87cb83d5a0e7999b34fcc2472467997eace7450f08c903f807715432291ac81e2a7e350d76f3b200353d763dba7b3be8be13297a963df7d8e17815c343842ed99c33ab1709360d52dbeae7126272cb6b732866912314e472bed11c28237e9015c59e0ef59bb6608283bf4bb05b855d51f596f0b91d7024d042485d9343ae06e4b5a9faa5d2a39cefa0403d97dc06ab4af8283af483f3f8837c15731cb55e3f8ccabd8256579237a8a17b44f6c7868923368998fe674ccab5ae99588e55f6849d5fd1d8ff184f88ad46c4b354e7a15638f8eb89887a068d0697be1c34b5cbb71b9fd3a91c4277604d784972c527ff9114a63e9cb260ace8bcf58b1d1e9324d23b0caec19f2b70bfa9c1d0d4bfbbb133ccf6278d5d81aafae21497fd787e1e8187e05ad63400c63b8fe2b719c05264be629ba081abe412a0ea2772cb06a3730290a54bd48b6c9b8bf132556553a4756f48c4276a1fd19c7b8719bfb5433713e8871f79bedbd2fc9232d4809a531c6cdac5b74b96c7611a53298a43e1570d0b40cd89a5c6a150f7989784210dc8032b09d861457782444be7dd1f7cf3e759224c4f4d3d461db193e66fed3b0d9298f00fc21b78065ca222fad1d0c25b39d191a34c838abbf8c236fcacf201a351714b33bc0e05511db2cc5d4f67f070f61361cc9cdd58dc8d69c2550e2fd71658acf79e891929db696086b2d6c42a589228d83c1da64552d4e8d1c70c175e46b4960a8fa2deee23bd6dcf13c9e2f88dfe068bc8b814a7adf0a392c425aac153b211960ed8323aedc1597570a11d4db978ac5a7e841db59e2b525d42855e6d72c83970513062d00b43faee7c2fe4816fffe75f0975db124b8fde153d58ce79888a7d668e25a632d0752862f7fddcf639cca994aecc3ae74fc97a2d777bf6f1ae9dea63e84cd231bf0c13c6690b10bd7dccf6ec8af6da93b7fcece225b1eae59d9248c165d4692c84c3cfbd77e62d76f3df1abbeb8630d08cdf0a663b61656bd973005524920d126869a4e6b8fc4f7881dcd6766df1cb9effecade00e12cdf19411e4cddf1741adeee16644295ab60966e92a4fd60b5361dc9276d417743fa63e3b9c3f2e758a0940c775dd6a9a79fc09d135d907d4d4ebcdec322573841b6d38f2cfa8f9545cba0c6b3c85b22937ad929cbcd739bb71682a91e64fb3a6d4a6d6dfaefccc84e84e0afdd3a00c6459cb0025d7e688a5545787ae78d10b8fb78deeb7b52c086e70f2446b0e28049787348a97603ddcfd7432924a3cc242a1a376da7b32ab56d8fe83400ffdaf28e3b95089a67a6c1cba1e3cde304936321d5ecddbd0654463e58e264349068b9dd26f4f77407ee44303df25635cd281814501fecff66fcfc00585d3e846bf65e33ed5c5cdcbcd04e65073b86d5c0449712e82094faf3217f18c2c789b62a5dab416d6c8b13d07508f75bf5ac3587ad145e15f0f2f869d00078865a25905ffd73454ae875c2fec995ec740ea8d244d2c6994082d07ca86bca11a1359ff05196bb5b7889374f82e61f65ee8a911464991d6fb979bb6128337539b1540be823d1d4b55f16e8402ef3bf6b7595df4d7a3b22b93651e3bdc7c276224fdd9fc1ef50b2a3dcb117ace88a90ab28d96cdac81ad299c4849687085577f26bfa439f39e12aceed9092d8354b9f9be8dc23b06a6b4886792b9f7f73f46c18357eb5164c08031d0a09e5f818a35f637130fe6ebf0162109c2fe0c8b042d7849814ca6f8e6801c233d20b0981cb2420060e37ddc168a578943083d2fd668245484f531471874ccae41f66bdee9434ce858a13153fabe4c921b1327c184e339b20aab279db6b07055b8e5919ce54af29c4f254cc25a452e3898eec22a8477c36673a4991a4ceffd8194b63f266bed2434efca2af3b8e64baabce98b41f12ad87c49e41865083a7cea305f8514f236a28c9e314417c991ac4c9556d6d0519c138b572536dbc1465a3458650f21fcd5b190d3cc836207fcb5b07414a6b9b6c360c32e7de9a5d2586559897ce20239fff3cbfee7b3e5a158424dc7af7e419dcb35aebcd4c925b8c90c98254fcdd69f465371ee2307fe29864b6bd1182d5fa15fea54d2c5c8747e6cc3442461521ce871f76505dccd6320d807a2d2c1c730ae239d9f9b9bc0b3f2e3560f9a3af509894e3aae19068441fabb53ee9596bdb4b4995f77d16cc8facbf34a6353b24ff232c0cf8a90f4d615308fa9b02c4520d0aa69e5b43816212d0130d4daf55e34d2d9ac17a0d2b1ae5c3c38a9109bbdfa9848f8f71dc50977437ed0fa125653ef4764b4f7bbdfd39d78fbdd2fb3a73b92630e8af284369941271aef3f91a60b1f9e2e3f0d7c709262872edaf87913dfff39e98aa9cb733accb46145e3dbd2ab400e793014b7c821d59f22346aaeaf569208eb3ba7bc04537072973d0bfb5d2231455df08a18efff0efa9a877723d62f67dbd6d2cec70487ff99ef4ee8db4c947c6aaf373ed0e5ac4cb29f768787ec515f9d3dc3a322152f9c1175b8dcd95a90665715c57412f55a07c8d60bc3c4e929dc18a4e44be840da49e6d5a25b326d84c5b3c4809f7d96795f6e1a8bd622eae8b538ff8bf868264d4a22f734a3add432a10222b2b22a058f9291192003f06c5a1890b7e90dbb56c2712d5dd5d88f1c486b8694fa2f0d2c4fec70f49d27aed1fa5045d8e7b4dc6192124d79d99e82f4fdeb4a65f8e6d560f7335f43c8ac70e9e4684438053dd07f8b4c27cb9053b0fdb865e4e78fe1c870824b440b5f0d7d1437485b25578fe96a0e05c305f895db1f282a28f7f4d38dc230f7e96b7036934b7f387b9c189a5165dfffa6bcb059572ab950a21ab10310cd3857c7e8060b213942bd856c2a12c67b1c9f119f8ad8a394fcf9ffac4c5b1cc8d28bb2fba2deaf4244429b49f61cfbf36538d84df48b7182c577a7c56039abbe7a0e4b637473e5eb0e9b7b88c76f35dbf4da44db11107f2cb764bbb3fbce05c36112669f196189c164bd6f93066d69a8091a7f2a19d1a90bceb5f280c423fd73f30ce32e8772d545d0ef04c56a219a929679b70953b291b33ab2bba91712289cd2f1427d54b4f868c928748ae3b425fcd3f28722fba5585e2c7cfbf1526fd2f562e7e67e44549d6a60e512b28fe0c1caa7c68533189543e10ff1b8fc34fc1e9388c7ed0227e52501ffae6d7586b7875c1b395cf59d21b997fe228761dff220ae22ed0ec3739f3738b918fff797b00c419946ecb1cb779a5e95a40276c1782e4e03e6cf6c85c6de9e8240c70a60aef7ab82373d042ef944130916ca6d21d21e429b2e4818f15a64de57472551f913aeb41403724746a4760c976fe3a673f218df5307b8c8f4da88c39be5b20d94df0cb3bfca272fe5af050dd5a905fe6c6fdeec91dd134ac5264d2d57732ffae475211405a6f31f00a1543b4a36fa866dac2ad198e62666bf693a9fe62c2b308912432f924eafa9d4bfe45fcbda58187fa2046559aeefb9995a0b774e25326caae0842b4b4169e771ae97729340f9ad2863967e3c8e235fcc414ec9ef99d9590f6e8efb68adf763d37a749dcd3ce5723b916ecec2a93e4210b578cbe290600cec28575d33447fe0b32724852ca6d03c8a2481bd112b098f8d77c5c4cf01983dce2a765a94d22dde925505b197a01494909a4db6e659561f66134b4528821c550f549e80d5c665436947ed5d6235014c228dd9bf886a1de778d50996f5ab411740a38b6dbfef613c252aed01e3e6d236f8306c3ad3abf8f000180e7f125d5355094d32e7f2caced08f36bb9c9f5da813fdd94dfa2bf22b72d46ab5187e4b50f079be729e67274ad9571189f615607ecd1d21cfec6b1cac4ce9242d18a2c0522f44c4daa427a85635a5b787e9f6b32c39ed9febe79d59b7c956fbbc3dc90fb9af2909c48b904873a7f44ac70b5bbef57d16934c427d2508fd5e364adb91a090d8188cb4184825616616d63b4324f1286be34a73101cf2423089f3e5c57cb984a05065858d8ccec24b9d21f6d3d4f68126dc210d448245060ca74548fff46c3edb67de9586f252ffb293899c1c0b73d91ec8d35947f5f5785141f985827db6a0b39e0796093d3ef4450426b42c6469cc60476552ee32345dd50beadfa197cef4e929e38894443f2379629a264b91006ff731f6d1bca915f1a91fa13024f169ae3414caa6ae432cfcb5494562c588a348291e36f3e67af3f3df02e8c05708d10652cd37d5ea73c819533fa305b7c4ffa32d3065141b8925ba4eb94ae79379f936662b55db62ff7fcee186892bc7f4eb4358306ef189e5d5bd6b60c2186e46b8fbcb0ec935d5928610d779ae84c750153b31be00312c739d8f52bb231cb06abc034cc902c7bda3c5b719f3704f99bb16dd9df09946c4d1e3eaef53c08229cd9b4e1031168e1048034118246667a7bcd2d71b7ca41b332f31d212722690a5ff1e1f8c47592792a14ea67c7d9fb2fe17c753fd67710c2098c55cd94c6b1eaf22648c63a482760b41aadab78bb933fdd209ccac7d8236811481cc337615a7023831d0bc3ce2651be08f77ad3ac0bfce014fdf0599d7f82969eaa17404940ab794bd3fb4f25cbe00b1c846accd669505f4ca63e9be0f830f202c9b14f46e43ee26460f51ad5f3ab911adb13fc83670a6beb0e5855f8f416961bc25c35564952381a61f979525fe465cfb4972d794516fd6726e3526b7f85a89bb9c25d2bc4f5d928b87a837ff969fa35da764377f5a7b859d0754035f0ad130b457ccb2d2c5289fdaa7b6669177aadb2de1d3e16a686e473389ce96b6012ae641a3eafb7aef556264e02e41002efdcc4a7912db52bf0d03a6bdffe9d49b0d63bae4960f6a1d72f519207d400431f222c18e2289f6675abaf0a921a26aed5597773a6aea9ece0be5d397f92863ebf76934c6386625594dcd0bce63a22a8d0b3480f39ff07d23076f9c773b2881c8efccc99cae7fe187b539395d84caaf88124880dbc5c011634f9e56617554463afd3017625b17678fa141734466021b70cfeb12479cfb3eff1d25a3c9047f41df10266f97861cc75e02e59c2a684394245a83cf98361514fccbf6a1da5d935490dc3326dceea31b54ffda28d3ec88fef7a6f5462d1c89237d74b4153a64d4180337ad779084b514ee03fa85c0c5af939aa52c45ad30686bb80db000eb0edd6113eecf61c8de51268bb9bc25c9b34e49f1fd100c6d7809929e1d0abbe2f711888273edadb8691653736d7339ec524438fc9da01875c28d45db695cf40077bcc1a73d1b56c03bf2038b0ec128d578a5c06a2856e59dcda2f3bd60cb126a55e24558e9dd11730ed8e5f19681ec8f539cf6907c5cc3e537001ba5a137c5eaf0779ccdcf4b9e55ccae30171d0fb3818d7f46c93649ce208cb210a414df016ab3b4be7f69d626de4f6d4a58a7b91be2a69fe3ba6dca6af52d2d5b0917cd78c915a2613fa5bbd7c4bdaa9921bdc0a61f9c8c8c6ac0e839a724231736f234eb209a32d8b98f09399d420169513c502b3f81b49892fdbbcd8ee32e478350f2ed9e8cf1c23c21338f906e2b2758e0a02623f755887fd3e0415e6ad037bca7ab415aa96e42c526bd0ae89787ba5c931a024261f774a2369e9ac16b26178b6cb45356cc183036089a19a10da8083d5802cc03ca80d91f1601210be1b57a5cf43a6cac7c6dae068af35badc71e922ec426eb8370e31a88c21faa4fba8f4b02288458d18718bafe5b6d7cfe5359b6eb756f9f0aefd59c68c609d07b0476c4237c6c415a0d1dc828e8796bf2e10a2d1bac35efd7a24e9d9791bbd012831693e9ca4a5585e53243c0a4eaea5ea19cce938bd63542f3e41a89017a7f8b2d84c0dcf13ceeb413590a3dc39e1b32eb61ef73938f218734373d0fe9f8bbba67745ceba229c3bf5cc981f3d821cef48a749367f6b48ca4ae0667d7ec443f513ee36f96d49b5666838df59b0aa992d9a649e8f278958d901261c77755fe8c48b0f12dd5e6fd5bf0611d2472467a3efb82978112602893190a9c98a1a13945ad0d105710add7fa3f8bf2c375dc07c3d8e7b9a329ebca5d0770ae42a9d7b22bbc74c233c188123997ef9d9774d858674136e7bca4588f2d18b8d6efa2dba1123b659b98c465a070918a18807ac5b6005e3ff3dfd20a93817d2a5f26b5d7dda6bb4ed998fb093550d1fdb8b1766fa7d1c9881cee60f99adccfabd7ee4a489ce35187e95195208c2964b730672941d0cc93b8782d81cbc047620a598a4ef7625b8c55df82b0ca11265c2db238d6e2edb97712b85e062ba1fe27d335150c9c4bdb1a49456d2f2532f839e3525a2631ba72ddc602b5c923a0bfb353140a8f4ada6df28ef6cb20c3a1464c5c57cc04a5791402b35fe268af70cc91bd06d1ae3558a21c99ad87e9ff1ad541d59c6620f55241d28b82aaf30c5ac69fe86ed8b4877870765d8bf75fa116e9f156694ee2ebaffd4868cb2537430d0f48c9220ae6ab12698a159df5cbe2c73e90a5dbf5a7b1c48c7a3a5b61370c28de6330a0ef411b16f6708d1d7568b460f0a9f797eac1e5ed44bff0e9a55808b5ccc7d99c8ff69b1b7976ebb7c0aebf7a3186b3ac7fc4ad87962b71fe16248f73a86e5e9b6739e5941428bf16581dcff912d6fb157a7d74857d1e3c490757b45ca03c863a4f49b6c8587fceaef952f733bf683f4df957bbd185ccdfb094ca49ce4e7cd1740dd3bf460b288bdbf8b66f85cd92c01405a9bea4d0c88f9410829ae31b2c72c3e8a6401ea2632cf1f2b570d79d8311a881fd177a170bc6795bcd0a09cdd3e9d66b0a537ccf9f013526779ac6d6a9c44b606422749bbd3956c887dfeccbf112ffdeff6258d392d9335e84460ff79c9453ad584f1187c514ae27fac8f3c0554d97d8c4742fa57b9152e3ab8a30e99c2d8098527b4b63be9bbaba67b771af43928ce8d085c2165f65f012377ba40b316f55c9699f523e3b1a7fcb88262b1b98a8af51b6dba527a5db9e46b69a683576b45ec42dc1e792a21f9682a6c316afd13eeada9ea1f3f0c2cf432c102d2071fca4ddf8918631c36c8fb76d924abafb8834fd59d0e24be118fbc72c1455120b6abf4ffc451232d739c6a8c4c171aed54f6f3fb3f53670ef4408335dd1a6df55007025140677d349f9090f02cd13c7ada190da597e6bf2af1f8d05513e6b7d63589f95c7c6f909e8369a58d027209537d87c76ed76e849633892c9a61149b6415504414e905da44ef06d3c134790765c97c4c2aa4716e7ea5ac53d100af3e662a266f16d5b44ef9299d4c8f1be67f0a1ad9bd01e940dceeed8282eab21ea4188570e19989876e487c5dc73c3ba8b04252e542adb10b32bcf60f2d7af2cea9516b15d63fe85787bc73fa6ea1c6c9ac28ddc58749a9c27ef126be6eb038eac6ce5cb6b84309d88d6ed5045cb549096eb3ea183677726e68978bdfeacacee19372b66285301126f578787b02dd8c56b2b78742df7d3dd49a8cc9914af0965b479b942bf71532bbedda09159501695e0a5de118f0535922847a91e3d702763c0af4a18e46fa3c389fa9a1d4976ed1bbe0adbe78edbba28aeb29e6230f23b23e4ca6c91171ad19a9813aa040b03ca9c0eab1c9963fb7d49342bc02415ef1b4788a7c8df5eb4a4693536297106c0881c3cce95d295ec3ffb6616c72bbc4632deb2908672c04cd85a20334186ef0e28a5c7171ca0b33ac2ce64b943fccd255a8384c3d64fb23392dff3658d6982b4961e946726083966d49391e4c35f2f08c2a6e59d088698288125477fc43de00f7e3de4f8075dd0b66e492e2036116f87aa609bd492d3db22240084e2a18f49d76de71214ba35cebe09a5caac0cf598a0dec61c372230d060f0ea70bcfda681b6ac735f65342f37ba733fbf50621882f693cbc23112547642126b541a6127d9eef0da3688c90a5d21afd293afe2dcae5d4a75a693715144ab5fcbe01892aa736faee476d6dcfc781ad4fef687992975476178277dffe9c5c1c5a7e7df23367516aab3c371dfc3ba7c57bacdd5fb21b1892b12bdfa120a96b9235486dd71b0c24b17837070044c4b1e0d5a475bc3bc4f33ccfd7ce716579413b1b39f371b54281c5954e625a5cf9a353b6e0027654b78848ea8efd51c722a378ff29197ff28552d40643b48383ff91cd9040f7b2e8da2aad9f1922c14d10518e659687295eaea0d376b5527ca8525b4f645645444703178e97dc254b564d9a9d6013bbaf640955718bdcbd950beb32d6b8abce95b86a615167cbdbf919d5ae46f2b9c5c05ae428d61693c43a369a3e61ab5a555778b7cbd736a768189b1b5172dc3d73621f27407d985cc05ba1bffc7b770fd1c340c6eee0d79aed4b8e87a872859c68de9f97667750013b2b57151a9edb53087c27bc8da4632f43f2caf4aa4d36e688564f52d29dc72ce4203f258dd0fdde8d87dcb26cd699058b708faf7c001f2592ded5bf216bd02afb9a505a33c25550ef67c875bb88e57354842f3ee08e797664e84fb8bec5168596d1f62f6a432ca64fcedbbbe480b732fbd13e6597db4ee09104856540745d478bfe051d406b0d7ebfac82a0da1df5646caaac36bd626960e970605958fa5e266e87d0676494bcbd9df5046cbff5d849f72d7a86fe219c307b6cb3b33c53dbff3993701ea00ef3bc4323ef7e2e7a513752c6ebb4573775ab5c3a4d8b5e15c259ffa6fb07dd69f100da7c66d53d06c0ea29d90bcaf67e73b0ad74df2eeb548fe9058086c80a2d2a926fe4278ef15c93431bebbbfaeeaf58f79a40e123fab7b612e3109769323231582b86738a0a0fbfaf86f5d064fb6ba1d51b676d6d759c4c394102613aa95cb3c570d34f9994d346c7dd23d541cf2970101ee466bbac75ca7c14fab54463bf218df4ab03b3c5fb894eb600cc6c49a751dec0be7c133bce3e35870cf263501916a9f5ab2ffcd0d76146f4c68000002428b702931e2c90d0afbe8aa97fc86bb7c118b3450d6b8ad48077d03c43df4117f0e279b349ebd47b4aed2a8c712c3c6f310bed96d37d36651de3c7df789f784f243c672c76197452a729e0fb2e86b731076f27659a18ae81ac65eba825654594164f6f6967852e043692804ad911b2ceccfdc8299c16f6460a275b31834a47b7886246a33c9b5d1fefb99ccbe05dea3dfcbc8cf699cc5c0007da947e4d26b13e4d32107bd0fa3589dcab3806a8f099cec8e310ab6b5439c2a6b1e5a46a713d037ff8d239fb76a763f10fec6cc1650f4b63bc84732631a63e6048ff29d89207aa0fcc35b35fe97e42dfc057e705fcec59b5d6465116961d028f1c115880cdbcd4f892057922a728ec1689ba244c690fd5282e93f4edfb458659ccde7c9885957d7c014c89dc74475feb4f433ed27c7c52cfdb240705e88994bd634d242849fa0eb65775bb2b795983e9cf358248d5ce2d1e31215a7d0f2a803974e301e9c956a546dc5c0e4cc05f4e4adb3141ddd36fde09fbc8cf69376f975842be4b44aeaf2485c8232eb4102ace966cf4e682eea6849ab0ae9b240892d20dfee8f1b2c0df75b7080fc36686cb7844c640b05adee08e4bcb524da2d0d8fbc235f3769e73371399f207a61700aa8aa4b172819dd3776eeaaa82a409916464c55df16d9cc1384ddbe685b4e3a28d8006f5ea8f42185cc3c1cd412c4a59f0d5d685ce58535656c076a4a302f7eee72ff7c9709bc5f2adf27c2d70b8dec3d47114666e603fc45edb2a6b8fcbc4bac6775cbc98cef2f41e04a3537bed52eb7aa2afc41bebc5e5456c3766dc9f51cdeef3c3deef7a9c7c8682eb9e694107fb5e119b0a9cbb1dd9997b7c554eea0fd4a4816460d8a0502ec657b3c4417610ef309868ad71c307624b488ee7b009c75adc944bc9bab1db7dbaf51faccbc53d256720336ed92bcfa6360af9df7207a0f3ac7399fa1baeb9db71e4bb316cde0627323ad1560375acc3a9a389fe6a1c0a503e9c02045fa1f0b65cf40282bea22d9817a98ce11e8a8c3a917683af494caaa41b6b67b5ddac04c97fdc07112ba57a587fdd507e5729e6a2e70f40b5bdcd38dd38d603a97767d215e0f7205d83a0d2dd5c268e67df033a1076a1d5aa2cc6dee3ff20e998d3fcc7ed3b240cf16f4289f5354f7451d66f711085492a61120606e3629211688daba1306e4e1f0d9eb8071c9b436e143cb3009545adb3acea5f5aa216cc35e31a8ff874b44369fb63c812ae7d149f2fae0f307703810b9023b7f5f4d26f0e74e322ec9d66ea971cfe1dbc5a90205155f078ef443dbe3e46af3b606732bb7b82e21212fa279a21c6eec057f952f34deb020cd7a5b0dbfef91a23cf8699b7b326eb56a2f06071b1e6f97294fd7ed151558c1cd255a2c04dc163570196b3fd58f1df16ac139da59de2f84e5b9ba04af88909793df6aa478c804cbc66f5cd4d4409b47b931203d25740bef1f94ca82327bb883dd05d1a1858136e6fb96892a2d42a32fcd416fa04dcdf975f508ca6c8547c3f8cb166ccc43420ea1021f302037790e1557c9c7d6f7b52d58fcd3bdb7f1220b68bbf85c807609c638a0936f04ff775045ffe57331448f2b8949b41228ff8917b3f11ee191c52b21f076d6ab8bbadeb5c97b6add0e125e7f4732d94aaef713c10402abecfe8d6f51be71e5de298756ea494777ee836d3d04cac946cc4449a0854bfb99aaaf5d4e002ce21fa0503d6b94a0873db5c18a02c3903ed187bbcc75505c5b3c4a1b91541f1ca2ce6d5dfb1fd4da60a1d525d0631f37963936e6e984926a4eb96eae684412d260ee8b4ff3579e3b1b8e0a407dc4aeb7f96319cdf478544edd5f8f21619ba1afead2c83c66cb381b749db9bd1336951cb1d65b3ddbdf4b904d91fd264ae506b7ee33ee57bb883f8f77d57c5899771567e3bf809a93111b3327c11be78c8a8ed5bbb7273b479856b3ca9d4fa0313ca0240a920d09b9d565e6ada2c3c62974f35b831ed80c77d30dcc24beb07f4927b1fca45f353db047f2bda4130d9b26e77bf8743176a166afbd9a1ac285792669213899e09480759d071da35ebeba869a551c7ab14efbbd5b33bc9d02db00518d4d865798ef8a0b91622d9c211b6471e36660f404de6349b91ad4e82034d67cab1665f3b54c0a74850bc3133ac83b7e3423b8177d6d9f7692f33a1d250b012ff30995109c189c23a33d07c620ff4550225384a1e67548d6dffaa8486c749e2f6cab2b304edaab321e93c6c2d8f525de0ecf936772c848c014c65cbd5f0f1c475c5f6e880c7aa5036c88e3d627ae15e31bb81182260e6f57eb7bacb172debf1bbdc5deffb48ef71ea47b116b6055d407fd071ede5de6ed1cd137470d000476f687ac4be389d661ef0044d4b82bde766bc9e1630e4084d08be675a4561087e4b05cfb3ca79a17a4872e8d2a399093a7bd74c09e2a2109e2b00379a5b852091c1e8e84bf411347efa9fe86a9b04610a78e94e9792471a21d11567886a4b7e21a2509e26626226b2840abf01b4cda1853a284d5474cf2cddd715c548e18b1f3ec39c1054391a8f4ea5658b3613c688c4082cd31cb5a1ab970d109c887157b6bfbba8d23457e9774f376067720eba50920fdb7314f96685f39fbabc0320f5f04bca715a5c75e0f849312d3b619759b40935b6df9e58740316ad53e05145c5e460ebdcd71eb431a70a6dbb19dd551c364ebdb082f8e4ded804155ea1c71c7777e3b7fc4bf07382fc842b9b39f831a0c7796de624c8983864224a1a7fb3357290863f67bf0ecec2218d6c7de00cf36e99f8521a13a1cdc4a02953cd0a92b53ad7ec16298a8ebc1d8a95e1938b9d36d4c620d0d485839cf770c7f62878418e04066394450b4780cbec6e47c56be580c85b790ff942641073753212cd5e20383b426d03a1c9549e5f35a3aef9d94db4f5a60332d1aa811e273d5aac447ef47988c270e1ab482cc8880f3ab6ccd155d605f7c65f5608e177d9990b814530834b5a7e17fe1f41b0bf1a82c1fc6a058fe3a5dc614d08d5063e8e4f464fda75693e986ced6e982c9f2d5cbf9339176a0b31d0cb78383259da453661d498c420dd92cf31f9361bea7f1d6daf93d7d88f0c0ff7eed20bea0b6565ab4c0928dba77ff0cdf66ad8681a2387d2eb3bc65745dec0f95efbddbc844d8d45e73305de689273fbb0eefb32173e51e00abd8179864ce55b6bea4be6c8620771ccdc1832819fd40c43a256ab68a85be577879f37a1a8ef22e9712aaa58c0ffe5321d912df310c86943fb20e5b8452ed6fdc57889601277848537a3c9d4d53972aaef94f05bf46ec4b448859c3391613eafb35e224190af05916bc2dc35455e532516678162bea43f8f6628c041938fd470fe6d52eb336ad750b9d5d6fab3b2429912ec27db71401118b0c25b49de0c2aee9594bb73fbf3b2463708dc89aaf2fbe60b078e112cb7f8492abda94a772395a53510b87a04d8c748c4f30306857585c19372f5ede9738effe6458714481eaaa1e44586a5a8360a4d65c58972180d66960a25f6e6e8400d01fbb006a9f59a6c5a84a92092e9f82c5b3f980416ed1d3d01913f1e51862115efe831fca192157623c9d42844efc49961ff76e8d109ecdcb4ee9f37c4e4265a7016dfc842d1736b63ba60fc7709b8bcfb9af04ddd099ef343938ac1c68f2cc76ffcc4c7af79451e4587af1fe64eef9697f3b7fc827614a606ce17273efae12015bcd318d0467718d60d6a7cddb879d2009c1cd51687967db905db48d0c16f93b7edf082801bddeed6a1c91904bf7f4d9e7ebdc48e0875f129840615682875a6610d15816367b0e577fa965976e6a384602aebd98f797a1471e2b0a50c28e03755595f679cdeaab039cd825e284505002deea0d3f42ab7e8c87cb41628a1dd01c0d053040015cba18dfb6cfc2ee6e69b379540132b9e16e064edea514981a733f33cf658e3bdf79a135116de838072b1e40eed6cdda0c0a8a1abbe3e96bff7f80b5e3f203edca549f737f99e6c4a0ff443c8483e5d0dcedeabdf73b2d4517adfbced1d578fcf36251ee3eead9eb692825acfbab620e3c277c26295e17040bcd9073cc773e1012dc07bc75e4533faf1cfbd1ce8da1b5dc851410843af95a0f723795fe561457fd901a9cd5034aa73bd782b81862de3d264d3af37f6695f05a54196ee80ba02a97152b39c39acc292be3f0924cd1db3aee46b589c86114124fc4a2f9d673e6e4f6978c3caf220304a19d5016c51d34ea6064bd63fe91ad1b20a29f8de4798d22e336fe7376b855549613311e381d8369a17ca0085fb98575ddb8ddf7ceb074a2bc85aeb09c49dc76c27fa8a5c70837ec0c4674b73e6a69df32d3b25920e58331f9dbe6e576a680079a10e2b7cced85deb1cd28f60b73a0651c68ab201e1215d3518ab8093f8d2bc5cb17575173ff1500213cbf5f7700c0e760bc4e5a3e9840f97d4f6e11e79df5178cc721fc4d30f332a5c6cca76a082c347c1a360c665d152837a36c8d9173ad9a0cb188d9f536de0cbe83f20f5077634b6033490a90b6a0f845dd7f560391b6162c4c9d51ccba59a98c8fc11494084f684dbcd882e4b26714a470a585b9f487accb875af6c6fbc9130d5abf7d07746c1d1a2285b20493df8f8c70a86cebf9b8e3cc7e35efa4ef9d7a6429969b6a00559cde3161e48f33191304e1f39cc993745f53963aa2c768d575e0fbba2e943a25a6d5e80f32f800817511a4e54c851674857eaec33f58c8078d2bf758edea0dcdc5c49c6bec7c29bfa02a445310c8e93d748f6c4ac4e51e92e9f13348bdfcb8e7df2c384a82a205d007fc81b7e1d566746d955437eb6cc0c0f322af2962fd8fa1fa9bc825a2d240630427a7bbade27ee1db696d604f2d7a30d666cf5d75ec9f8859cb1a4605e4c9213ff715a31a3f9f15cea953290e06c1f1ed9766c36df767b857ca917cbe8b498754f8d67664541b0eae8e8768939d2a81b793a14b5441bd0a6b359a5d4cf1a5a8c3cca03dc8115fd59176f5c8e270beb8f1c1999c3e0e63d10bbc8b3c6d662f3bf51019096079702370558d9cad99a830057d014d7275827ba8f9cf063e66b268781a199f99e1793c1fa780dbedebda48a7a9f3ce9a539abae872480957dea661e64ddf7a43e55759302701ffbd276b3fc90f488ed4afa3a572efab4f9b6bbe166b24427edf019c128b484018d5631045cfa9bd0413630ffa011601b23d5653c0fbe9d5cd671c7a7fa0213d0b6ffe97a9b2a124affc4014b9a825aa293214ffb34abd82e5ad5ed0b113c10f49bd41bd9d6d23814c6f1583e36d13f2bc6740dfef10b57b1483038f58c030c7a612b906379cab8726112eacdedeb0e880c822fc0a36e3a0966331cfcbac4b347b3b53148969196b25370a46af6071b5d250ed7c05882dcc2f604baa6305c871fe74b29b9b6212a23ec0aefee94a411bf0d3ecbdc7afd6091ce7c732b78d3cdf9d730953170071b9bdfb73e0dd48a5ca39cb929f7f0d46ce9aa006b919458e19c24a8ab2b56f4a198387e5662ac0169f8057d8d2df142b82292d3a240d15df1e3141885392bd07be36ee95f83ccd275e42b73e473c3bf75a7f3967c3bec7fc255965eb860dafd466c76947cf8820feec4bda03545aa24fb96d957d70488ed33683804f21cb7368c6555a9c7f3dbd6a3278708d9a731c89c6d351f7a31019114da3e6e49fc5426cfd32e42d05e3f778cdc5f506df664ef0632aa5383efff4ad8abd00501d23ddbc3c71f090300af1482f1f255fa3ae8945831e610013c846d5ba04dab10ef3d04804f2ef4e64988555aca0435ba9167ee1f0401f9a07868e778e445963a442b25c4f179c8c3087783616e17fcc7fd7553b6752fd96f687e3dc2b08b266643b01d296f77ddae3e4e06a6c89491d2a959","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
