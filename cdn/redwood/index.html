<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c06b602f070ec2e64d56a92bfa7d897aefc02f397ca75463f0bee13b750f78795f878fca09928a2b7ae4ffc18e92b12330b242e424b659fd0cbb7f4a41e0094b7a2d4ce6ebc4bc331765d11fc2cd3bd12dfdaffaed6ea8fd9c3ccef74b68fd6c574d02497ea51c26faaa1ee1aebf448d8748fa1c414ea7f5782e29fa18a6eab42a5ef0fd0f725272c522c762b94b94ef5f2c727865475600fe1bfe0cfa9e25993f183cac3196100d045f09333ba1cb02d0ce0d0d2c155f3019170cefeca47043120816cf68e2a1d6a66736f7aca293e29b230cb81b52fde7832e4e351c8830b31b7282ae3c52c198757cbc2eb70fa6c19e89bf725727b1a957e37769b5ca4a0322eca6365642f538b3e505db46465d6814d3117e368c231c48886ea3181a04d249bbe161283e9f207853ec8904df8225cde8d59c065cfb2ca63528ea028da62f63782a7dc52ea356977519f85b664e0e24af24a0a2d4f954098d844122bc9e99bb6b5b585b6ad15550f5cc83c3069c13ed123eff4e624135a6fd128881b2d78ca872f3299bc187e3d1d21247bdc7de71083271bc2f173e9fabefc07f1d2227e230b14966b7c58f0c5f1a4f051e7470752dc245c1f1750fee895a089ad4c47a3cbb1d944d36d0b847af276c0f909ba68ef253ca7211050ef8f36d45ea76c1cf425c90ba16106502ca0b0abf78b9225335fc556d63a61249908000abb69c518eecec4b7bde49a45aeaf5233099d91cae2ad5c1f4c9de2a6aee2e8192359afe02a94154b2eaa5f5d9387df1d4f965df4ba31032d340da8931b3c954ab892e37386b2d0f5ddf00d9e0e83329bfefc95986bc535bcfa429d026128281c5d2dd5c097dba07b6c9d2f7dac850614d508e2f34c11b7bbc8eca37e6f9d8837c8d62f4b8f1dd95c6ac9c2b8172242c2dfd2552bfc4e43bc4ffa9e37bc12129779a6d9a9fc0c9619d4b7d6a5b9eb77c35a2253b957001939e33d72ac1f3b94b16934afa33e6546a3682f49c215d0aaedf78bb632bd554a464cc1dcc8f7d7b068ba8abe2cff11d86e910f7f97e462e48108502fb8ddad6c75d3ca9ba126ce0d85b061c90be8867c878f64616b786de8ce1a35c5859ba385912d19e6e000c1619df5ee286808d417492d3ad5fc9da2220d9a982e1fc3fd2fe9ddae92f0a2fa0d3e93de808b9b60f60a2164bfd89f579e5d9bcf64a7658de134d87597d73129e33ad757cb2485328ffc8a9ed16c43ecdfa883033b6f85e15eb4d35ebaa59ba4f42e65242eccd614cc63445d0f275e0618a0e82c51030cc4112e4dbdabd4772130af2601eb45de54b80b1e81a5603f33c18f4249cbf5dc2e4cd303631f9a313bcfb442ffcbbe13b60e615c750b406c493a1eaa0803b23cf0471bf44ac984464168887474ef810c7615e09ad701aa30e0fff6bd16a8da564798dadec3bb438c389fe39a25dd56ac280cf32df4dd725d74b545a67c791bedd02575685095306e2ed704acccc397631190ac1ebe0693061654e2fd56e9a9974f717fbbafb0cca288999060eec0213c527b2eead83e9396b0c07a5641e9ddbce69facabb3c5f207eb98856e4247a2ced939e12d6c896b6bc23f1ad6303d7bb69325257a7e8e29dd910daa71f08ee29568bd8829d7bba7c1ae8119a6e3fd2b9a601c0e3a4935bfbc9c8c4aa63f4039d9d2fec61639df8b1c7aceccf2ef3a717eb8f9f51735297a9fc55cb817e5eb1eba4a5b949c26494179517ea7b064e67245b062ffdb3ac22475a2e567ee5a3c95ab7e057c13de7e694fee7b1b66e4a234fc02ab61994167c430a88f3c23c09213ac808d4bdeae76ecda863b4022dc7b0dff88240324ae493eb5054f546b31f4b4c68e5137b24ce470095a4b8c6e32cc44214b13cf3ef5969c45740092ebfd5a22e22e0f8788ce2550bfd6c6b9a2daaa14d690d3d2a6c9519c1a6587bbeb33d3c1f097a4ad599a1012d62f1ea6567a928837f8efaee32ec8a4845df4c0e85038df8f6ad7592b4180a2fe7ccfbb70ef94731e44a8d136d101f100279d6e9b70f2381d4c61abd545c414a773c92277aa8cf10976a4cc521b871272af7d9a8dd898d5e0c575085f1f91751c3e0fc7f857392b8f2286050f10ff616e077947e19ff38cd44140fd246be73918f8fa95810542cec9b5e061d4899a6586f3c48c05f7343d54df20f0c5a366d46d1774117142c2058e5e55ef8b7664036c245251d0e4b4419e29747cfead1ffb0cdf612bd499509ae724590147d1e7dda650ef94e27b969135cd781531f8996e68a077552f9a89cedeff0f771565efd9e92941b91341c43ec4cbc8b93db58285ae582ebb777e95ce25bffd526b32ef537adea661980daed1715cadd6dcee1c3d765881f854f993aead8e9c7b8a18540c81ec3a9ae052abcb66b4f7837812f5c9c67b07b69209973e6e5c9ed3bf87cde6be967bd85817fdc2f5b9f7e435553e22bdc82e44d5c5c5982e4a8d84b843643b44d94a92495b5e8d5b01cf794f06297a6af8643c13e4c7b5cde32d17f14df3a1ceb95732261f8a590b51b9fc54b9739b8be8b57ec975448c9f34a98da7bd26904b49fc3daf3d8eec173ed88d334c2b00f54a45189ba6ea230023df72abb219d502c070d7a7cb66f55e90d63f696fe63b5c0449be409776ecc820028ea89dbaa82b7414faf13a0025223f26b18f5c1e978d5340bc34daf54fabd1d58ce30a5f89cef855b22c17cd43e82b944c655038bbcd6a82325bae45456dcbde17fefcbf8accbea0d15a718bf301ef8f94db0adfad9f8458a8c1bf28d8d1bc9ca110e30557828511128ad6f4e0c19d397f03c966b7a544fa934605083dcb9a7e623ff77980ae4ad3550a2391b5bcea049d486bf90c5228c7a4d5efeffa79b39fa33410445da097823a671f6f81a40f84504ae4d22da5639833fc32d66d4249374fa3d75e5d9a56427e4e842dd8ee3a3326520a69a4de7fd3bb8ca686ff11985db18be0efae77feac5ab71698ef306caf9c62d97c2dbb930fe3fb7ae923d115a84b8790e315ac1328421cd9ed7965e6057055ce62a8c5dc43acfaff65ac9f5b042c1adbcae3c8dadf4d633487cab455eb10274857431087799465043ae7d6f5fe280db01bd901b0cf0cd54ce8409e9327738f4f3ee9d6e01c6912ae6f0c0e5a7fe6204d1950746c9ce33232e53e786b71870eec2a5bac963794bbe946bf38f37def469e6d3735788cb006db5703c5318cd5063fdd305643908ca272362fe4ae5fce5f5328ffad0d492a12df31257a0f50e727ead87c6b350fe59a0effed5232d57fb7c2fac044704860d72fcb0a32e88eb855df472fd47de723d66296a9ed9974c9bd243ba2ab9b291b11c3fdb47330c87368660b39fcbc803a04be7382b9b709f7db29492c59a75aa772620b9709f14f28b313a43731336bdd661c4c345062b343b4b8035375b98452398d4b7fc1f3de1ae610a414a798425c8d6a6f3f289ad6e5c1120234b0bae9478b78ea639e99991d9584d1a225043ffe999fe5fc90d1330bf5e80e00b2b95a92cb153fdef6e661b751f08feb0d7f24943df82cb63a121a9a8284b278dd5f09cfcca31740f1a42e61e3ef07cd0ad9069d8788d8afccc60e62a28ce58cc6160ef53e8251dd86dd1f2b4ed7e348ea37ed6e6def9513f066d7e1d4f06e56574082036f44fb876dc4ab98086f9b1ca82b22d618d9b90071232997443bc4a3f3214ec460dd55aab3e4af5a1b1930bf4f5a4ec468ed890a4c350c7c88bd48461ed4bea70818b46f2fadfb38f1759268bc50c97d99b14093ef5ea1e4a1dad1f8e8d67d7a80c69ef4963121d52d31b425faefb8ab7e6e3b08141da95838bbb15292d0dda28b2a5c9c1b06d26950d6fccc0f9e8171b4b946d7d603457babf2179d63598967ed17e9b0e57cce390faa0d538c3698fa9eb53f8dc9523178538ebdc31dafe2ee1d0624b22302f55b5423f1aa90dbded7d51a474f89fb3aa0144bb061fdacb7b4e750dfe3d197cddd3db50896752f389833993bd29b9a4063a2d7c7aee5e727f9a50375a8c5f1941e88a14359d5f2684c89277ada0a2f3acce46076965880bb36b890df85e33bc4f7cba6cc884752f612277dfb5d8ec483718b8b215502d37bacf127058a3b7010142313324d167fea494b2c6a86735cfba90513dfcedc8de22d2dbca97ee934977ecd0a50edea62259999975985aefb6b4f346b4cec288fde5484805782c896169a7788f62f06c74d2027599229dddee7907f2b12cf2ff16fffb531064755550b208deca16e048d16258c22ec2d4f56c49e17be6fb57f59a53a6d43d0680c466e4bdf37427db8eb88d3717f6b0a3b4ced7095f98bff093786ab9b862848313845e9ec9006ff14ae492049e195a6dd6d2742ee9f84246606cab25b7ba6923f6266cc7d8b5db9ab98dec87601011c81ff81a3483c8072f81c8f68bb162e7dc9f1dd4d06759b08659b2458b8358b50b268cefa2c7718337572ee0a1d4e7246bfe440ba152ccee076be6d998181bb39d165d9aff2f7cb76125eeec5cbe18ea1622bc7b65a4c27f2b49562c2cd2237392139a45b2f0f07dff9eb3a63afc92c1b3565fa735d651457aa71292052d214e4e66203b82faada50843e9e86911f83cd9c49ebd0f6cd115e6b101ac8090761dd250faad72a3710382d1e7439f22c60bbad7973a804ff9166de5a09933dc9c1a80fb53c40d74fa63314a2f8d8ecb03a21a7e61221c93eafa93d83d64e91368055d1b84b419b6d8a3e42d1a116e7289cd88251e6795cdd603f0be1ad148b994396a9c57a306344f40417363ceecfe4d2bfa569c900aad767e19830f26ffdc0be5cec02ec82d7f22c3a33ab4c3062ee48263cdb208b01cf84d5628308404db50787f4fc17f69a6e35859a901a2996331eb5166843da09d69859889f273a515e6751593e7e92b942499aea9c376ba19c2a9f5049d7698b42ec1b26951fa2ed51060dafcb985a8ab2fac488d5b541c049a1f802ebe466702c683c948b6a970366d622079c9dc575e3bf84f65a50ae579ce4a3f7c036796900ccf9ae10d9f12a1f52293670948da47d3c4cf0bb16ffffd6669cb3e35fe69e99df40bc72243213c790cf75bebf173d61b2f3972e61b8fa93e94ad91bb5191164ba04ef43be2aa8c53c9c33afa1ba21fe199fe81ebfee6286d60791a4ecffd9def927d19fb9ab7ec39e656b0644358cb2b270c69e846456815be1fde6b9c2f669d5bf6400d04bdcd4ff626b3affe1da386064b4c5d3cf16ee24d1a5bde410a86a9302c603e0bb11f76b16f87e8e93b96f6aedbd450c3e5764b980aebd695da7acd95e022752ecfcacbdd8c29fe8ec7ff5bd24474c2db858a4069b996005214e7a111e68e2b9b2f5f9b7f7fee5952394f7bfa0a3c5f76867bdece70c10ce5d1cd18afefd8452f553593ef9d1d627f3afde46bdac49c9772f9bac07357352bbeb6f1aa2ea1219fcdbee88e06954f7384d6ac8a6066284edac701a6ab9fe6d054744fac5e4b94caf8fe81e2dce415c09b1be1bebc4a516e0b817d58da1e5d334c265d01fb5d9112f6740a04bf2c9ea131359df164898ef717d9f0fe5372d3a6d7638ac9e595502a07f7215034324a22788b4e1e01b696b4776a733db30a262160b4d50ce66d78a7c3975c416e772a3f278c51e9a7db0eb4de99e3baa09bc9c923734d455bc05d4b5d8ca5d614cffbb66f2660dec405a56a49b9a1bb50b5f851a2be3dbdd8a927cfabcd027c414ee4529f3180f9ed396f758927f14baa0ba21bb9ad12dd335a23739ce871e71e141a0948dcd5caef4292a2a2d3fa4bd359f953e8a938de7f9cf649655a922aeb608078af392472b723b8f3da6abd99e41ed464d11b932c6c2549c0cc53237b0375623ba4283170c32ebfde82fc890ed3bbf926f08356499f48c5c813bc0a41f731b1a6e39cb377000a8e231333bac5b974fdf91fad198c839b191ae6f65cbdff925f9da90518019f1931387edc191f47f7d6ede8d88b6a16cd3598f6e729dcdf58cd2f34cc364b3bd382cdfda7d69ca473c4db3c8a52e056deb4ffe1c7c11bfec87248db3e7b5957ddcc7f22458b43bba303924b1649e1e111c767302480453fc552ae2e281d80184b3088699c21f14287e1247591bdc5aaf0d555f5500b0a3e2767d61f7cc12e82e6154d4b018456729915429988200cffba1244ad68174f6d11c4ff56930fa9c4ee1f263c4a2e2288c2ea1a174b3414327faf87adea845086bde54309c265e057b890d874f189735d3b1b6690fc7112360a8b99fae42f0b138f5865e09ef8ae196ecee3864623ba0bc287f83284878e30f59e75d786267f5be8f6f4261a06e81f2e0a8d6217ab797c1c1080b926597b2a40090bd010e594cdcf7c064a33ec792502c46475aa1e60849ffca4728e28c2b3023e70cf63e09f6fb46d81ea451da9f23e70fa8e0f3aca54b86c1d92544be61ab64a31686b08eff3fd273dbf1839d0773b7ded1723509e474ab47bc2cb6b3d56ac3eef38c795983224dec6c4369f78ed49397c48588aecc4c4d1f477d69450c0934049571b809aee2b6bf4b62d0b4d0e2bb4549ea7fc6f6fbc964b409a7506216789c52358e6b466499baef13789d01a5fa4825831dc1ae0f55533f049159b0bb9473abc4c2304df3a8a0775611253e633ff4b71f1a4d2546fe5705de55fa44c82e240c6b10abdbee4787c62234462d53718999c445280f0e30d5b1a7dcd01bec9adf2768c533a709c2ed0c1aca43f0eae9c30764e11a7ffc3b4009eeb6f2908a55d098b7a06a988c5dc38a9c042b99a32d6895f996e4549163dfb6283af250d039afb7771aea3af56ade89752d3e4d9350c420a9a8350efd60b0a2fca92f1293ede56bb07881d75075219bba944fd45e492b5a5c8bafbaf7bf028d712afac68c73d9e367fadb0d13dd98849b164e666c08e04ede84d97ed4c9a50fafe0b629d1dc1f152bf917e0758b31af7913a1874798cf131d068b1589671b65d1de45806ef99dcba7d347f7549875db204909606a71c4d94d1c9ac399b592d7296583831dba31688a3ce52d51813a216e190eeede050580a837317c440e90b720c1f3812a2e066e1d8beef5ea04c2eacd24f0864e9cfbc779e9474df52df974210fd7516df8263963ae34542a819358578abc82a2c43ca480ee522989d63237097942b4f30878c7608cfbfca57f4716683c69c17150d04dee7c862a3ae48f8a5105e36d1d0edcd1c8a171a3e66864448f60a25f5fa50d677b58ac365dc371676b401d2e933de952e31959887d44a035105bceac5035665a9a9c77707cb38bf2d8e17ac9cc5bc931e3877ba7db2b5c9cc7316f00d8abf112772642ddcca008355de91d6fd645bcab6d183d320b2a3bd683a3d5cf4df010e9160b302cf51a5e9acca2fc1b0cf10c358df8dd7e4d64995bcf4b0b63686d7cc6dfba73edb30136b446fe60da02bc7a9e524d5ca8fc34cd62d029189915adc0b5da4bc32e7cfa5629dbf0c1721466c5268554d793fd1bced50257b1eda3ed7b04e46b27ec8bdb06fb80d633c8660846f398dd92a161cd92dbaee9a38f105e587f195702ff4cf25ccbb06477abe2abd4f623e33393f230113bca7ea5324fa54087c886b4143defdd3d1f093a6227d909f91b9b71fd83f6aa18a286d7aa340cc724115716e4afd5219f2e7d120071f45f94263caf5a7d44d8691f475f90faa753a5e4b995b7e0ba84c331ec2966b092b652f52eb69a53e46c6977df463bbabf63caf1085b85a37b4c061422764b1e1e65b69dcf509eeb94233f9b3b8677d524adac08c760ab15906e3caf3ce8cd730d61014d79ab11ba5de39018b7e54ee17c55d040bd72cb63d297474f559db5c7cc846cdd94328c5e67da5cb22cb0cbe4bd4195c91618e90dc326f34b6122365aade53a5a0c91b0da23b323052220f6f823cb858fa8202cfc645dca973ba1cafa70b888ce1fc9216082f7047116ae9749f189f44663296cbd2cf527cbf105d0c9b8e49cb802b6108ee6a27fc016a9084e3326efb9cec182d0e62d6f31961dae12d69e753c33ac4cb671de4eeaae696deb7d1fb5a0384aeecac649fdb34afbd67d83efc42ac3d3ba0365bf424be4a6d3a04730fe527efd4a6c4c94519af4a2f87c56c958e2ac7fbf39f6d5ae2d9f9998742fb0ad486271974a1d9c96ba114e550ebcc97917046c5b7858f37dd350b532b333d650243c4879063265c0afd565b4cc41b5c621a17a99a2ed7eb1c25bb45c23d0d8cec9853763ea106a1ab6260f759a23cf42f9de717186d73c6db83e7c2b3cc454d07a7ee9d5c0836f575eca0de96f3f3ccffa690ebb5ee604a3655294318e5ec46777f9a77e038e09116907a9a84dbfa2ac504d728984bcfab3e013b159c6b4aaa2b0eca75c1807f46fc81c006548a9fa0f4b7d4f57ee5b58a0d3c63647c67357615f4a70039d7c3fd142a9b41ec1a6b128c0c3618aced0ccb2d32f6561f7087e549281d2edcf1ad7029a63ae80665fdd98531c4f8d3a2739f469f08aff79be224d4f97251ebab4e08687bff9a9e39f9b60351a9d39003198106114e28bdd259378d1a61fed9cd8f033c9a21ac94250644161a6064f33c3fa22c0cde4eb4c190128828560194d93e2bb48d2e0c86d6df79f84ec3e75ef85a6e8cee09d2d11bd259455adff986948eeecf6cedc5ff30b897ce07b20223d6635af32181a368b77f2df41622c40824f0d661e4d72126b1bc17e2058324685c011ee64b31f12c0e7d0f7d92474449c4c1c6023860d928a9f31e7d5f50e7b333e29b61dae5c237898bef4581cee3109d0986850223e8d8a842d9087771a122f5f7c02edc4c0f01bb7ea6360e644542bfa505b07202dde0361741e66c48a94ac0d1764129d5f41e277f9248f3f608b3cd344138ee5dbb0b288deeb21dfd94d91c645142115cfd1da066e7d0fa455432019322b8928ee0ca5b6ab49f749020b45f4e8230fe00c4f995566a6d6e9a3713ad661d6a2dae54c1944ccc1a2640d995aa1234c73d3def561db14690fb31d0bea44c4d6a412c34e181ebc59e02ff0ecc2bc860aa9f5f195571e6093c3fda33781e7619f2c4aca989c777e8bd09376251502f2840cd295c909e3b30752648a6b061109cfcefd182b4ed25564bd6a9101483be5bb6b559e62355cce4fc523aadd5179e2dd30a89bb844f9574234b2d385fdb48c17414796a1c1723759fb9febffc0f09ae74c0ab1fbecbee223261a8454da88f9dbc74aaefd7182e14954fe68397501db66922365ef30a1d4e37fe06d4bac55343ce6017fc9836f38cede08cfdc9ba343d46516e4cf1149fde6b52364e6c4690ece948979d78f943a605f5c1d35209a9ac0d1985bea51fa898b78d6929b2f07a262db6a347eb72059e04403d42838a88006708f120fad640e82a169a082a2e8f91884c7e927a4fdb4e3acabb3b0eabfe12c4341728e3606692afa3066a2cfbc3326b4daba03580b0aa13f8fd1655d1b4030aed771e5cdd5fd3e8e0b724f0e67b4fd98975615758db26a665c74dab8b428e37de216d7bb31da3174e975d18150e69b6b971fcb70d6ea8c5ca81a64eb750f9ac74e2bfc2cfac6268392a0cd75d8398370708e1156278b85b8d0259202718bc4231948d44fb7e638df1553886456267f46e43799fa50038366d0e928c9b837c8c8e44f1ca2b2b132ae66e8d80d4ed442cb18747748d6a1b27e6e2fdcc4ce1505771c192648ea9cf4a07cf6f876f73e03daf08b3802f3bcd930936512f7600e481041423c28ba764e06822904762ddc967e34c67aa02d69747bffde80d5be9f4dbd438f3747a973275577f004491808c769d6d3e6699d4cfebc2541c63301f4770aba90f1349566b1b60fedf8bb2dde9c50fe7ea5630d89cc2da5e532581494d6197ca1cc4e34cdff6418c2d96b8448effe0f8b55ff45c81c137bcb7334a20beb22121cd2f36012d65c0dd7737d913d3ebfde1b4fbb964888e8e719f2bb46dded2ffedb481295540afd8a9e7d89c2e19044ea8f2cd9b1091808cd85c0b0c9a89bd14bd84b9dd7c79cecc5631c5f259b2d8d56f74bee99c222e10a1ad6aa2f0fe624380c07ad19c28484703ab1b8f3c78d23b6c0b0b4c77055d18424ccbe03957ef84b7f0c82cdcdde917d986458d644bbd8928ae4dd81e0b44ffa17ffc582ad3970a31fbc4963ee09bfc1af6402db7872ab72686d2879c8626141c34c55ef293b3ec99bf56de4773b1227d061c81fa1b5edcfbccacc2344015cb750e3c3752c5ee275c7ae7d7555d59d3459877775c405ef389f1d8b7f4d06202abea35cfc1e9262e37f388b1c0f9b766f817eca87385438a249388feba40dd8900dc942642d6fe7a9c9c7886f9d24f1a5838feb3e0e94f1e23a0376a766979be1427574680ad2467307612a90145f1221fee845146433ede73586628b7fb4e94bfda0e07b2fb60bb5bfb01c08a0940ea00d76cb693221381ce192d348d8cd64415130d37fc27d5110dc72a24296007e79205de9937ed46156f33a6379430b9a5a964c12ea15de28a706490e5febc6321bebe740778668d2fa6fa1c829a3bcedf74cc3db417b802c8c3bb248d2b4dc2917b34d43ef74c4d5c6f5705435753e8e68be5bc3b71db078f9e8d03b24a931864186d761b701554a12fa479245508a2c83fbc070c7c32c681694a1983cd737ffd469ffc3c692ed7ae9966706bc0526fc479b0da13c676be0943eed9de361ffbbb8c54fc82bf3870829cf7951e60640f02757b637eb87b30b0b0e04bfd6d21136898c0990a59efdc50d1675e93143cbc0ccf8d9196c2c741f4fd12ab974964061ee62317be0cdcdd149d5ad490977403e10574228a9ba5364c18130c05d68c801757cfb2b948636973c5c06657c690e76a05f8581002eb2f68f81efaaedcd0afadadd108ff8da6016d623590f34290d3a6a4e910843c23d9f1810b514e4937a135c7ff1eb2964a67286afd266b3acabc7eb3308844675887637690319e84cc34ed5bab52c0b34114c3621be53d0d5ae54a43363b86759474849299e15807e92474b473c1af5e02da6ca60c20db56b5ceff5e97a15d7f560f6ab6e1fe2476f59d633a5bc6a2535ec90aac9908d293f1e4646ae00d683f0592262bcc690372ef8b34df15b6415f35a222cb336c710e33e1363b5b5f642225754b619dadbd841f76e19c493b21bda25bbf3c15df311b4d2551ff82cb82a0ffca34c448d1cc3df91e8cbf304e321c5376ad7144d3e61254496a2b70fdc64455cf1da1415b288ea684bee18bb3db2a69e866cc5495eccc8debf4db69025355510b2c843553fc8882e641939564e396b8a3e5d9ca66a13e9162882a60a5e49aafaa91ab29e98325a858a2cf67f3dfae3d0991e68d9ef819eac1a475fcb0d2e1de7b7950ec7bd1ae4e9e95f2f5badc4999663583114052f8b2ae541885e9298ae898e6d5495b908c62b5b295db37a57cf154d0cc3279ed290a8e825fa366ff332984350c3e38695a6697df6ea601cc7efb61743d2b97faeba3ac6ac42715a9b941d6dc1393f6514f25b81a1dacb834f0c4081a5e4cb2f33eeb8b2dedfbf2d589fd9ff016f540c2552d97c496d7c664dab62e21c333910897eba971f0430b41e0e1b0322ab780dee3a01e5f4eccfc8b1f9a5a9221ef1e505e0129d89f661cfb7aabe0bb6f12ba8518d9c454aded7a6de3304b1bce7778feeb0b0ff389d7fbe2c3e4620cd5262591fb34b6d9f659257b1367c377141d194814e17665ed992b80105d8042da180044e543357406b66e33054ed27f10cfd19f9ed78f0f95a8c6c68930c3f20e60774e18de4728901f3ef0c015d190738a7296fdbe95bb3d91ffc4c100de92deb902c26964dd86178d0cbe7086dee17c651a561f5c5c20f2061c6d4c505936c08c7d47f25ca0e0eeed8ae5af0ec171c80d0951f946d626f7daeceb8e13d293ff6d2397a84f221876dc201aba036efe7875c5e7f75dc75859ead5ad283654ccd9271f952fdf0c08cb72af40b0c7c9c00a07a068fe0a5326a0475a22dfbf0a0129d295b7d07ba858353bdce03476d41b9710474d2805e23ef734a6ccd05ae050b912c5d6ac04bf97567daec82a9ef0f6271c6f36c97755e04859b95e4520dc380a8f7f568161d8205f72a1f2bd4e5daa4c916367c1eb53aa03468bc94bc09195fefdf5496f29484e637ff2797bd5646e529936e89737ebf748964daf43dfa1d23e326607403baa9aafea554c2a0b0dd7142d14b88412d6dec378537efa532f64db203ef3f1e076ad6bffa229a1d43153513a763c4b8766c153f09866cc9783879c6ab53173749bca881e0fa6a91422a5ea84ca75e42bd3427cedd912c69d6a25ee15e4254f449ac2fc0a57cccb4ec06e8e83fea4e3e62cdd863899face7d0e0bd52ab8b6cb13c811b5ba725c46889f113d6f7062662b87ae53ba953964b0f1c622919553db58afecf72a894c9bc071c7a9dfa12151ff35cbeb568d4498c5f085f8fc2195fb4461ce9dd2f9f8d3a244aea3baa1a4007c5de6525d42e93f35703baa1ccb72b376e47e6a68349e721a81ba58d591409b9c2271c0d26ddb152a29f2b2fc1e720f14b0a04592e0b801a44cd8240137fd4931b6b1a0e51711267158ba8df3eef5bb641248d9e1d41b14121abe26834024f33d62d6e92ef1d0a7ce4d26431a8429ecd4a4e7f3a3c548704237fea8af107530dc0a36216583c961939cea69f4787e0bc067daec2a118bcefd6fa66d9bbe69defa9f8adc692102d985161d97a9f50dfc392f8021cbe8f7622c22364396104af1029e74cc01c63846afc779afdaedff69a2ed188a7c267d081aae181c5c0ad8abff22ab4e9c39235e402fa6c1a385b5873acb03672a0b737597aecd6b9f7f353180148fd586ad6ce0bd4cdc4257d77aaa07a75c1b184e6f95da0b5b29abec24612a0575ce75b2610134dbfa822587a3ee2d2185339573d8a4d8f21213ff94a0d63a6887ff2a12579ead10a307cbebaf4ae4920c304c4fda321afb44f9301033d10d7f1c6816d52ae2153ac03fdec5b020df1156f5bb5c41d08a318b737be58c3734d64ca16acbbf2d4a3cd63a65b301f56d912c6ab037cbd50ef243ed3b8727f0a04cbb496ff4420bdbd6e7551779a29a1d406a6a1bd046d105ad750fd7fe325704e3df03bb881ad08734bf57ab085fd16ccb176ff5e92403ffa3a7baf894b56beab27f2c99734295acd67095d855a55603fde78e6b8968430aec286f59749f70d698c0a97b25f04f023607fff7e2f9ba4019a630a318189a91bc453c94d97c36a77821f9492c4a3070f7f1a17f60e49c1f1107ebdfa1f53665e39b520737c23782b0e5fb5fc125e2aaf259367ff3c7f7307a0f8ec9df1e42b18083118764ab49ee9d8fb81d91aab3fc5775817ac0f05f92363a8a84b4f70822cbd6ad20a6b24043c0a830db16af6740e0526d722a2377b76196889e1cbc226b3d043cca3e13fcc5e094a5280277b0c0ae7e09a94e36e26d4af98b13ab005101d796b62be6ccd638105b42a8fce5319d278f054f481baefcfbf2b2f30ad7d6045241dcd3e9d5505587182cf18bd0976f745ff4d505347ed169a4e3ad1c36fdabc20b9416ca697927d88bd4f57a8c3dcb92a1bb7692d8ed99cf7b68dc735e66de4196a45a1a29d19d092c515e9fe784bff6ca98cb125f0b0bf7cd362fadb8406a0bd1e0723c606870cc82d9c8446b3204bab40b741bdecc776f150e7fe57c4de60647e9615c7f151337e0415ae85f6a1af41e1ae08de92d9da9ec2e2f2c3cde2e9728019fea659cc7a8c3f5c6991a2e3dc0f90623ff4f752978301b9494f28d6edf11281357581d3987f8d23a532414a4e0c999dfb9049376fbeff10fc3564bbaac545793dcfc87a40f739175c93a74712f56d67dbd8a15dfc0c5cc241f0438afb7665aef172a3a14196328deef1810083f9fcb01b8eb3bba375e3ffd948db9b9532256e08e6d977f822653a576277184c5125410bb162df689a38fed23a6894f82413e6b04ece4cfeaa056f2728641e3a887b32456ffa031ad6a59072b0fec49103c187852bf4e8f1566515e64f74fd7290293ad3cf11b92f7e367040e7f259e0ed533b12847f7465188dc9327ccfbead2457d6dea86e3b2b52daf835a9a4e2b524904eb1c5534e561c4f03147e5bf79826dbb46338a09ec1ac15e34f2b122cc6397f6a203162e3028f0f8315e675176df2068724f4d0f61aa141bf54f3c1b39865c82411aa4ffe4c67f25b0e29494ea48d87bf7c962f6adcba4166b85f58a47110ec8663e0a1dea1864bb2eb5670a3c8a3b0a4271ac4f9e82bce48f9a3ee94a70cf2a108a21213bcd2868095ead7e2b3cf192b35fb21e93f60971b7eabcb3f493f592d6a9dfaf768f499506249da61859a5f9ee6e81228e4d74319659a9db3a219c38e55411206ca0e90a5ecd5c5e107d49b2afed71d9d72244b2479c1b3ba000f6d909ce4883ceccd4b96cc0857b79549f769a2e282a635ad4adba9b681b82d1c3b7d5695780ae1443bf240c652c3b06a9a1f7870b909755eebbee42c9557b7dc3a0cb2e732423e339e16743965f7db3d826bafe2df2324aadae75f32f85304636930d9e36d730d73bfd1c4f144c765dc37800a5af6fbe1f711449452852552cee24f55d9e52c9a35db140930c18d48fc074da2f253cdc2205d017d8da822ab8d6a90eada11b04a4c8a8edde08a2b597da9a7ac6e736086e8d08080e7639e6e0d0d7b7983d34105c755307b3b88c231ef54ff6c157745ce833f24389248d38df649cc4aa5a43f84026891a8255809af9e041f57acccb12a9e7363ccf60e64ef5b3dc5037b5cfa11a5257cd077dae2ed39d8a78657abfd4f14b4c688ce744f46a2190fe32e8bb84ea48d669c6aed5f95ae40de93cc3526edc6f16fc25f602d9685bec9ac44a7bbb50afd5d0375ae8d28e893a27820ebe893ca77ae7b9fa9f76d88fcb3733274a7167ffda0b25f64caa48fa0b4808a900b44015dae6cb4c968c76e76073443116511bba4cf98e49ca09398207cb868ca1691d466ab46827b7e619bc0818a1688da0d7bcf30fd61ad09c130808cb01ee7de185711ef9e1caa4bc3f275c50c0bf8d03441c5e1dcf538a2f5b1137858f44f12420f99f634651d16b0941ab4c8e7a0ee7da63f42b2c19ddee4c14ed923dda34ff6946b6593fad97142ab2271915afeb7c1426ea1b13aaa219e83a6170a411b4aeb19d2b2a0b82da1b39a5b6e9ce6343b7822be578e2af15f5269c7f4a231d5b01485868bcef0afe4d9b9ba26be2ac90c5a53fdee4150cfc2bee147546e986dce038b9d5a03899648d2acc210f44f17c358c5ccde23361283a56e9533e2f45ab7d2fc9320feeeeede3f6bf13341ccb8253128a8c3a27dea2f750bdea638f56fcb83303894007b990268e2b3c828410f6abda0785f1a0391ddebd98b56e583f7cc1f9a05a25baa13021a90df67f33a22325520a0633f7bd11c0421094fb988d5fbed7b1dc6ed940b64fd94dbb806b066c1149984ee78d94c6fb333fa32672334c929fa5a70ccd0ed3e98f8b4e2437416539b79d102094ac96ce42377fb9f5dceabf584a3d680bdc4f5239c1541da33db0d1973029a4250302250f7759e54f932d6939bc49ebf674d3c4d5364d992e67a562e178a170820ea29f291fb5a45a9c88e4cb33302adcf718e91965d2d7c0188d40619a87a841643ce85154297f1aac483b1b38c6ddc3da5a8d327359d278d18f93311dbfea493374c44ea17c4ee74712661737742eb3fcbe8489aa1202e69189bf869a9897fcc1cbab17cc20b6aaebf5889f7d891fe26ff65ecc25a8b80277958310688ff9e607adbe176f9561e0c78119da271c7ff9c3660f703e972429a450879dad237daa4135cea1a31ffd33b712096ba9eacddcc7b1a8da6437a36e003f71aaa2c1be1ad19f9cd484c2fa6f095e3b673e13e8f04500c0fd58d69f95de631b0679a33fd6af2d05da2f84d0fba694d5e2afdeaefae199e07dab452f8f37f3afc6a8969568800ac9034227958e08a163d73bd102e10aa10287afabf297521aef30a638166039c196091f5c3b61dbad7feff4e0fed42bfdd3e934f6ec66a5fd598a2c64a8937615e7f279ed47ac3dd2f4ea80e648b4a4f2df702586f8291f02b57a5c3a6f6faf78b52777cf483b5246a3b4d43a7e41cba6f44a257b6f96697ec36cd8b01c3106b378a4dd8e05a0dd02125f5b49f039bf7bd734f0244a3045f83671ac8989f70bff296820d19d92bc339c7810b38436857e155ce9d01e2f19f2ddb63092841e4393205dc0088ab96d03cb0cc6309d2877484099e930894e50a4400fb3f1a23817a112d2a8511716e1c3bd0971b725bccdcc21eed8a80cf14799447e87feed0e1004a3914fae35e00eb0769293471901a2e0bc731dd5757b1cdeee5ba24d5305a672f113e19bf2624709f66a7700a5ea37601f54ed5b57ec66ad776bf052e143e820921d44e6f7294761c72dca2fde1d6b087e9a1fc4ba7b4613596abc42312942d7b6df14fed357e1889af938731f20cf18b0d6f992a16d637bab1ff93e8eb306a5a21d0c6c059fec7b42d3be98ec5c37937420dee03ef20faff4df946dd85b09b06a7ae7cb08de37024fa017dad5597eb0290335852d532f24da2007b560c2c289e0350e2b5f79797c7665f03dd24c22a1ab7a8876753d654f61149e032c299f5d653e3508e8d0c69a7dc9164d9f2327c4fe1e7f965217865c8e50eab0a805d01bbca9e73038d0f10975cc3e54e432fadc4994458e270e76cf08c03ca07396441738e8febb070364baab8223b425f53289154a738ebea1dc1aba30e43310529a013f58900be53bf0d615cbdac16190b71615f688779d06d5cc380adcf5635ab00e4c8a67a2f77ff48e6fd11f704eba72937e8e4aaa07bc4c4215e9e367fb670029b2a0b21d0c170710c64c7ba56befa437e7384234d60c01a990c6850c1508d93dfa570ce1bc19164b8f5763280c3928f15914bfa74b29dd4635cab55bf6d9ec8cfc7bb7003f46f12ed9e8efe900e5e8cea61da38ea310009d27625e73d08d3215101d5b7eb8df2a0c4b159331bbdf6e2b19a3418011366653ca3389e332105a7fbe90b2953afcddbd7f25b3471e35f4051668c5bd4d975b2bae2299089c471387dcab4a17c53a070983923d4aff6eabcad0c9c8abfd121bab9fa311c55780ef043577e16c716036735b1da9169b24153e3c012bb9fbda33572fe2af223e7a75a8792a9ca624bb0404de2145a83e63fc2003e32c1ee70115a3d0dc247f66cfdff77ae7827edfa2aae88ac10b53170e3939eb939eb95e192f7d0285e630407fc530c752d1ac5280bc5d58981efa442abc7f93d201fddab2b43d6d387bdfc14589108e68409a0fa5f63cbaf0a69d4927d3a5fd1458a57d6831a39a6f13c6d6c4cf0c3a9ea56e3ab8df153b34a5e3034a536c71a794cfe035912ecbe011eeed0e3c34a447f7d42be31461988333e03ea1f9abb4cdfb6cdf9d8d7e141149638032f99754fd994afefa50af9ea2c6f862a14e38f1b8c3654a5ebb2655ac1e848cad66841cf64642a9f5bee050a5c32bc44aee7b492a18419ebde9f60569b4e0835456d4b75de8b6238a24799db919de932a08fb6cdd53391977495b6e34ed6d3e6389574829416c80bd147ee555b46348242380e3892badfc0732012bb3163402125ff17d615ae384755cca620a1c0e72309b55d7bd633ecd82e20a188b1a08085cc362c159fdb84b887c8cf8cd63073aa38d6850ab87da780bfa04648a0a28984d1b03b5e8811b4da42c373daf6dcdc8e244359673cd490f7efedab119ae58f66d0c0c320bd9e9ebbd182723f31ac20794267951ff055dc550c17dbb970f346a0f827ca6de2781634e9b54754e3b1b1e58b892a32d558cc95007daa9881bf3873573db05d657764a8d863fad381d47c832a987abe937dc990459f18a8cf53b137ae9766034512edb7e67aea06543f904db0513a369816af7a0d20f7631436976681b1313fc7f0b6c5636bc73ae6f5748cf8d936f7efa9e67bada66605cf156e5ac5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
