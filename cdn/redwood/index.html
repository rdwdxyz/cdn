<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"579f56b0b4977e618116684abed786b505672bb927acc2b1a49e6f02bf657aef2ff56b0a64147679b23a0f6033dcce001ba861db2deacac6e98a77847b5c68f739e8f3918ac7cac80b4fc15e6091bef6c78bec9808e5b61a4c4d93c419bc00f15c8d632f9d0bd7b0fb206372b8225b2a43a5f4781c28453ef41a26f570e5fbe38c5df4e26559571ad70913832594bf57dc6461d24f57c2b058e3409d3b7a5a72e9fa81eb83e5d8cdd243525ad7fc38e8d54c6a19e13a294c6cf91d59d1ff65ccf2524c418a7284f98af61eed2855bb9594fea5601d977f01e3420916ba2d9d846b929341a59588591893cec33d5022e26ae23537cc5cb3cb23ea8401e3fe17ddee507b0472e80844a529ca8e6ae075e3167792fefaafcf228d326e2556ff3fdf66aea52a324732de6ba331691d9905a1e1aeec645dc7c81a1c5110d00dbe44d2fdd56c61426318dff1138e903c3c479e07239924df0917b568746c856115917238b8d17c7882880d1821553610652fcfcbf2c667a16f30543144982ac420892ab2ef4a68426a1db61e618baf3440edfae07a0fbf6e69295ca8e645f3bfddab808eb5ce01b7b13954833e014d7a77c644b738d0ff5737ed0fa30a5f8f9eab3e331c8bf5b49455bfe44792aaf24ed7450e6bd9e2c12510bf77c801306a7cdadd03d599ab998cad5c4020e43333fe8fa50e73c5df8cfe1b458247f2577dd1e6ea8287e41b8813d909a39da3b1d2c4b418cbedd2f4c47cec3c0caeb3cb44b3c875ae6412b831abf3f8fe0e7eb840c6c9aa7756920665fe514d5c0ac343aed1aaf75990e3c0110abc045bd10099017c72640b0b29e811a24e45f814c2c602d0c743afd2fbcd7e7b968a9446f211bc762f143e2b1bbd41905a0adc813ff9f1f1642950387eae6cb1d229bb2978ed99f78b672f523a6d4b01db53be342de50181a88f76f28ddab1049964dd22cb17c0fa2f87d10e75ede7a5f56ef9ac94c5acec2f1bc0ce033f8cdf1423b35b2f4bd0d280a4e73292c931b3f75d2234e85964874d8bbab9f5922b2a6aadcd698de6ea12fa4d12a3bb3f0cd130625f0e877ef3774c01cf7c5b889533e3edda86caa873689a440b8dd1387a0fddd19c24197fe713c52b846d429b6aa9787b5efae840f98d39105af6f85a925bdb7fa93c8148622cfbaaca16bf77b426f32d5eb275eef9a68243c706a7e2cabc62cb4546cc019c3ad973830b704e42bf37c7645740b8359c6443a45437e13b409851617882a374811eb8d9f5975d591ab469b8da981244195ddb2e4da3405e5dfb374ec1de1497ef487f5c2c331de5717ff83fe664632856b7b528af2b58af03b03bf70c9a618a47acab34108fdfb251ea1a10a5b6381cb495fe6d055a7fe5c46dffedec4961cb01bebe4f9629a07dfce27564158dbc1492fe9d102f0204771a711819c91daafef49e8d685f29721d2305257817fa7f45adce52591b6e8a73c85fd0785d8257b68fdc8d4ec023fa1489bea317ffe3eacab377999723e2c82649389db8b68d7e0e1447310bdd1c8415ffcb68ae3bf314429028174c2cab3f9383b26e0df2372b7929b4c7607becdba0da30d09185157c248269cc8fdb38991ad4e50c77d01fb9f831671a35473d16b5cddc1123e446b77feff61b3dedaeee0b61edbd534bfecebd18dada63d3143e8fc89dd75d107cf1db1ff66570e2d6f4a631c1f9fde61c5a600a43d2e889de5502836a325d396f71a5938dd1d8f4e52427ae108c1230ca31a5b1ddcca5a03018e906c41fb8ce71029c4a6e387e7457bbd9896a6de89420ba45453a74ad04b641b577ac12fca5e72e66efde7c3389f594337220e98bb39bc9ca71ea87a7e78c1aa8aa15fe70d6d8fe37115432e47d1f81abd59cf575e8f513d05b4b81af86d0fdb77307b8c85cc280fd896ca7c44e4ebbf164e1af4b1f1f2957a5f218df2280baea18baa5886b150fe7d62307592c4a5260fa3bbc0ebed322af2f92712ddb382550850ce8344ba9926f13d6d7abbb34617f150cbefea505171b5816de2cc6d8d945ca18b17e201fe7861bfce760fbda1c6370cc522671f1438f0c0692f02ead8777a4eb1d4b5553ba7cc87fbf27df69ae2bf5ca56bfa7bdf66eb727d34c4c1e9273584ff2d75ac23af379f8894574cda963161b9db7128c7d90339e2dca35ded9c18a0df9c9e1415338358aaa7ccf888f277b669a2b38d3235bfc868d03ee57b9af1ff8517144b137411c4302d5047778028d9b4f2eba43fc4e7f1f4fc6ca797b8c6bd8295cd56218f73150af337aa946a31134c6070b27fdcd35b649e8f12728c428f1f6be93fbbab96d4f42736dabf1d56f4f41220288dcc296b0a4d5c3277ef7e5b1630333436ccb5bd59180a35bdeb149831403bb1de8dd643995ae8c48d5783311c7a6d3c19dc9736f749e81f794130f5aff3560cd86c619c28a8fcea1bc5ae6f29e71ef1592336208416d1873ad081273f862761c9d4e9174b8a38898b979e2a27bbd7bb6516277f929b5d82d3b289423d75ad50468022b95da623cf69ec23c703bac28dcadb20c990b704677fd2998ca5e5fbf96829c13e987805022c8442a09b8125d4546dc1b23bc2bfcb53b820c5e0b0dff28d78cd11a0c66ef9433d4360b70766a697886a814f70be83706ac525952a5314fafdcbde4a653d3c8cf1180bc0601ab5a23bc222adfe77e163f7668079ea18dd511a55bccb145c3c0d839c9e3bc486bb449e70411eccad47d63f70c17e78f4bd6224c1f0b7f917dfe9274a0d6534472a986a27315d5436946501a219c1d7a939c9a2585ad74999e100d50eeae642f094d496c496b24690b66ce83d76e4983e6b499d6974bd77656aeb2eb2339e5fe6e0a08f9fc18ee07b8e8c185cd43ee20c820c89c2b6da45c0786df99e9566c8df09eafd1d720e36b3f87b8057b9ef5754a509dcb6928b1052c81c02d5e3dcf9f924ff30a75b32043925580209fb9104dbe14e3bcc17d0c0468fc4c99781b715f711284b9224780eab3615411fe1067711dfb0d2c3f398814f69804884e061732dbb7e5c10af677c513deeedef86b2921849d4790f850e182c4122fbe529a8d55a486293b259760a7529afd98202e48cfddcdba0f80f6bf973aa06f8fcc3c4d64ad3b5f146cdeca7ef4da2d775dcd5e77c37592465b6bd9827841258d4f63caa5ea0303b3a4a2acdc59e03e91d593e216b4e6f65b0e942dff66f5a787b9a15ae5489a4f6048afcd942e105baa22a6905309fe8a650b52d4079286ee1e2b6cdb0e778b46804af78e71739ea4f00b74bcd09b76e91606397f0cd483e1a0889638820b7d249ba891eeed4fd798c89d202a216ec504d5717ee621e7f3d9abfa3470e29f6bd80d65a58d5367a9fa8b960b0365d379863933f7226740d175e2d51272f7382fb028a80b1760462c5c8d88c603051b8f85f0170e7cb31ee05522a21c7e6781512d44c27b805eefbc4cd4a8477c3ae7f8d58b3b1bad6b941cfe0e9e38093a997f2e903c7d70cacbca333401b201716513a054c67e725a4a328b43ab726712ac4693092b68d0f1432f61286c082b38faa8e78f5d97a750a3a8bf1d2ab6a5863400471a7999a53038c87412293e834af80a816be0d5524d55955c320181ed32965e0a881ebd6713fec9309b1de30b0c6c374ad8c2c3a61635b231361b26736c57fa3397b0483af03aad55e8148912e6cb8af58a5ea395d586f79fed636d6f7b314860deb54d61fef80544896b0e74e9a8ace13615c763cfd67d0470f0b0d270a13fc6ba45338745a9135fa37784c62cfc0ca754bc9d2c2a4c6080491a9917a3d4db28f54e7ced34720203f61462deb2a0caa96d712dfb4a1b692dd345fb3f3696c7f18293512cdfe6985f022550ba85e188a815dfaf9de86b6706da61b9a84dd20ed433220cb1b06d636c5ce73a417a5bed1e98a83a1859b7559c2bcd76a4b078e3a4480a389225984d8bbad8c93c1955565d33257eee726bfa7c1c47a890a01d69242217db523f61e371afbe1c4adf31e0c05d8cdb4a084387692584cfa6259dce11f7e2a877a69d142dfa7a156db78cb7e6813aea8df0324a8a0397a47282d604dd3172ebe47cfd15527326b59a30df03531062c13e489cf107942f78a0e57951b08f52537d45bb215aaeee9f0fcc6767744d716128e03e45a368f9ca875fefcdea1e8c42c6456bce503ef8f9ff3b99264c4285402da937798ddb99feb831a9d5d4ae3665faf4c021a537424684291961dabfc5752ded58906a73afb2892cb2ff6ca6d99ae0d0be54a9113b809374c4bbcb5348355b09e27f2bc7fcd935d12307535ed8a55df46c135c9dfe716a35de8838dffe9c2e0de49abdbacbf5ee0383bfa0c79fb13fe38456f9062dda04f4c4ca1d87363a18fa50d80d9c51e221b825474765eff119249ce30ed6847ab53b0248594bd07f4b6a52d770d500fb8047607f5e61b7c0998df97b85d2c4a3c60b123db3525af2ec99ec2f40421bd6af74fbf08164efc78b3a8e8559d5d8bb0adf9d9d6b3c113facc817a96ef57436289c7dabb690dabacef0b2d915dfb8003763da12376c43b5de803589e4970e1614bb5079f8aa8c8cccae53078750daa2fce8031399d1582a3f858e40ff3d821a77a39444d78449cf387f91d12fc7c5f40635c041153ddf3b81a8a2d1ce08cf1f96395f581bdc0e70d953944d486fd339ee0bb51bafd5556f8aaa00116b289e71687a5128d1996815721e3fb9a951b444ccad45e40bc85989475a3df6cf45ac16c1c539a678ae2a65864d16c61697307f65f5de7706c3b79002e5f7b35dc23622def7b03512879dfe54f89fd3144610126506c03beae2d9de4ef7367c4912b9b26372c4a57b9021971dc37cffaeefff4cb7d2749dede0d1afb3b119a03d628da4d196bae21ce4abff9a7572f3b9b32d5944a1a92981d7c01f76d1a07921e8fe8b32529bf9a969133269b48ed29ad13ecfb4363cbfa89509301f06d17c16b81242469a263b9fcc668061994ca15b660aa83f8e899fd28f6b0bf285c54221c7ffb65be14f9896f3ec46574bc89896222546936a86cc4052bedded022c97ed54d01e4cddadd5231f05e9b50e80277b28cf9afa7aa20b2b86f2dd2e7119d24c1c7cfbd3257ed8d8786d8fa6bcb82bf0e543f7ed947aac1a7071e97a3c0564e3154d925a9f9b4ee860bf130368b65da64374505f17126196e558e8f1c9b20ebcd84861dd3aa2115bdbd8083e21f504c0f210c22e815271475b1499b93eab5bfb5e489d1ba411ed8b5f8f82ebb086670cc6aa8a97156ff266a3bfa78a696137cc0df7003247076a65514ffd25cbf47759452791a921082977e0211efaf6a6f5d9bffa89a5d116302135a93247d78ffd91453a45ee8bbf15094442159c8dffd74409708b4a3ebe85dc8fbeae953227d847317d31d0b7a032516b435278e663fb4bcfc0a8680a97fba812294a8800e6a90c0ab91fbe59091a16895777c1aa14ab8fe5c39837b212df48d23893739c0483c062f622029f9f76bc9733eeb045efb8376a97a3a008025ebada894c137372cf9f21d032bebe3d4a270775a3a86fe23ee334e5a533c37029aa5e63a24352510a2f434c5f4dde3f32d7d1a9d885ef0ce6e0b6114edccffa0e8d970b84735bca4a00a0b3cbb094e81b302359b9ffe3dae7e2babca6bbfd6659395b4361cc511423f2bf92ebbda1902e37b095df604962c7571bbfee28f97025c5dfb719d014a8e88bedc461e62ae1162b929cf880374a2a0b294b53303b8f893872c6e9590b68a3044f4e359fd1a905dc1c9318c634221454ff1846d786612453395d8b50b58873e57b1a32b44fba1a26ecdc5eaf4623b50a65b09b8a95021a5a4203ba4cd8c75dafc598ce65e8a6fa16637778d6792102072592fc17cbe53addee29dd0deb4fa6a42cf33b738755cd635c720235b3e14ade097091cf9d96733e6aad35377b0e41830c788ad31aa457a47a8a499e178f840c6640b5e84905e02797448b1394184ed30931f8107ed4c10613eed81c7c309cf5f2c4d4d50bec2f0338eda04605d4af6743e3e044394b7ed0a99b90524d68d3dd2be0827681e4c91fb5a3b10b3fcdc8bc58e372c71c6fe088edc392ffea7dd1a4c1e4971f489b9948e8b4d2ef2cbf36e431f0dd303991d26ae34662a4af94937d9b6da9c4276250427d1f559d0f6317d882d4e162010921f84e7ef9bdfebb033ea6148a017f00e276a26160dfba4ef4043436fdad816aea29688acbdaa2393da888e337a6ce63977b593be7b21c84a199bb4316361438f4dfcecce886802a67ffb6d6d91b601d64003109ff53cb89c32fd5a625a26a8d7e1d605fe8b0c4d2c719e91bf024108069db64506614a8d038ae89fac3b7462cb7463769f59942183ced112ff7cde5e9deb7123ca87abb170b8c91a30762d326c947e1d6400116916e190a86e19244eb19ed9262224b0e919d41900d376b29537a9b7b4ff774462230b07fad9f65e92116fa3ee21f57c0a635c5b9e6f19381d18c6c398fd038cf4091873579265767f9704c963088722e27ff19331de9a8595232c6d3b6e1195ed67fd734cb84e5771710970a44143112bcee4ab94dcdb886ede4dff79d6f2b604568c2adf8a43f8f60aeffaa1d7265805e2e5d92b17e240e6bf7e31a02acd6df27320dd9205e4ea569641773d57843e76938375e74044a8936d2465461a34937758fb7a44b14cedcb52d05b3360577fef61db7743ab4fde839aba8c36cb06ab526be1706e524eef0448269f7635eeb1a953d2b4f450d00f42a8c31c9b826102cca76cbae2f6214d2d0c994fad7ef28b415835ec49f6adc9246f83c84dd1fb90417b174c5099d08a6b44622f807f4f61e31a6549b7beb99cf908aec66dd07df1c1828163045acc6dcfd87c8d8a5e88c43ee00a1423df763f3074690a343ab0e36ef0c954ebe9ac45f60da3a70342bc744fd33fddcec3bcbceb6d7e82062b3b723c5482b71d465f2628d20e59a3dc4297ebf5f2694df0c65543a91affd6d5a984a4b78efc3a332ab047e05ab8f6b59665c1b95a5576f1c4ef5158c37423eeef80f646622c2ab7d83819388f309526af1b982ab6c393e8f5d11e9e94dfc4f3fb494afb6042bd5179739a47ba752d61ec07b06e82c4e544052620d1694d2484a276b113006ccf4d4eb3b9474ebd09af63ca8a540d89824afa720a162529f559347cb7ee6461c4a124f92b0869987bbf31c5f947fe4a1f6156fd08213382137281edab2c373044637d1fc6726f5646ad9cf3391ad526eb5d0eb9fbd3099dd58ab0cafa09c7a3c8b0751d9e96aefe42f50baa92dfec5ff984d4e52889438d2c778704b00553cfedc2587adbddbfb4d2db3287efb4ccbab22a49a21c419ba0acec88417d73f31f4a40500ed924794505a4b5cb61c4c5ab4f4e16e66867995c9126b24b8e601b4626484381538b35425d10fccd7805417b46a732a95284b060bc638ad691e99361e2a2fa8af49032d7ca8d2ae2d3b35191c313d3293893faeaa7937be6fd0a0a0790ebbfb775ada1300c5749d653fa0671eb3cd87ba8bcb5f65191a12f7f98c41112f63a7dda0925dce03c49602b5f5648a5fe1c3ce11d7755959ef45c96b4351c0c9e820dabed76d6a37d8406c6415f8687f6c2c44fc511eff030b6976e8f3df369908783f8743b92605325b092a8b8e2099d4da0621d98e4021abae28fbeedeb3e81bcd381ec8cfa2f389207ad0901b20e700c417bfb174e2782e7bf1c95371eccf967f4ffcddedfe5b6a210facc6353a0195a14db681a8ed1558b3f1d1699d8645af2c69fdb6c8d6a56ef5fbd0084133e2d170090f32d6b4906738b59fbe3d860f249eb40ae20e7dd586dc9aa850bb310189566927bd73742cc42664d4342fe801a36a31d72d7b9f73a4ee811ed06c0b5fab1caf02185b6a70f948c01d6a55fae756b238cecd649b2eb8aafc4a6e2b2835223a7bb2792bab38e10875f82543b8bc016fd595cfb95f4bb987e5d1e3d62f8918b35dbc4fec385ced2494cc07e3c8c8a902db0f808d0a896b67edebf93e7b02d4cf5e709522b857fefb79b03ba7bbfcb02a38ed4b80363bbada90c65ff7ba11beae2eae573cc9ff059ede60d9b5fd4a1a7e2cb60470f42377e2378908e7fa2a505f1a7f9421dc61a115940c85b6a004ca0ab8a1705ecf7cd2fe311a33d4d09b80e9d9a788c9f547ffc7ba2adf1beaca7ff154d409e6d5680ec6cbb4fe33fc048965613f4079e570d885a8c3b37d91e5dda0629e32980670b2ba7a2a3be479641b3ce43911ad7a26d72e9aa76a4430c783449e41f5a5a0a24e95ce22a31c18798269021f7a1f31af730b9cb4112e1135f16fd14a087137a2482b84c4e4c26ca82f4cd21771c8374f00025ab558db8f4314636dac7bbf6323ef6bb22d7c6e23ba355fb0d4e096f935d259afb73c10ecda271965d43d57e16b62c2dc558dcc3bfe8d1709e2274bc0b7b640aa9161650603d7c51065c531525315f738de8fd127646e5b261e565457a3349df8a46112a40dcb425f5d0153bd2e3f865d29476fb78effd9a3ccac0af0fe415ab13448a49847106114e103f9a71318e4653a92a57ef4d35a6b9ae0532686d87fc7fda1356e3e6519ca3d94dca3827f5a764f3f30563c760426039bf57ffbbc7241ad987ab3c8e3d70944f41824bc1a9d7306a98feaadc96aaacf69e2b4ed21153ffe87bf9b96f6cb8a4071023f4cb0146af23479ff83826f07c02f12fa06ac614df031084c69ec0e213ea258d9525614c3c36a318ba503b1956fe9d2d0b230ac79d26db935e58bfc853e38946e6810c472df2134b2c4de10fc6b34103ac7435d4998ca34dc6ec2ecbfa57416cc94f439afeb642045a79e50b8969766c4c18c3ceb8137da2f6c608c47f36475e42a55af96511edf9db968f619beb8e8c34472df2572d6382cd7ccf0fb85315d08419421fc61381d6098113fab7e74dd4aca8ca8aab53b65cf28214c1261fd6773c027725325a065cc255057c01fcf6425816b87498b5347ae12f22ed11647d0e2685302998c7d2d36f831e250640a45d87890f3040763fdd181d9a64f87db4b5c574b075c6ddffd733121d7ab0ed27ac534cf01da371ac34ef64cc6160a479d5d565a513dee1b2e3585d5217d2b9a1a061295430e20819a60c5ded20ed946af7049eb6faee23a0953f5e41b9960ba04d53b87dbfed946f44286f6bad3aa1d9b71421bca4e8526afed70f53ca417aad83fff76ff72844d41976a567dd059728569ca2980a45adf8c5c8efb5ce079c447a3434edc6b477a6a2d29f1c7cbd1766d102e89d4e5e4f6403a2dd754f7d48471fa66a1a98dd31d025a7a19093bc80b0e6026b77d86999a1a154459932cb50715a73e9ea40223f8f751d7b3af0b4bf2bb34d3188f4d5e74862c26e992833b0e07e283a364b718eea751fcf2502cd881ce58a5c58e3d9b8f21fc1d2e070daea1c8f5426943d3df70ea0b8b06372905cb954e016953fa17ec2dd335b92dabd10072cd378305fe7240d9004d270136e00f4a5a1c3bb4fc91ed6ed2f1b7cf0584a0a2e13902e38f4ed1bb31fc5dc60b1534079c732a76d9d7daaaed1364edf5bd29f4d15eb57d8f48ca07734513a769c66cc596074f6bc25bdcf727d0eee63a7a9a2e49f37a28dcfae27e231a040fadd6fe47e6d16d3519272acee680e79ae0bb5324cbdb45598d11fd7ca80dc00a86deba64294e147c6cbc31f6b4b9e6a74fae5d8b6906de238d91e2cb870c77122850503ef1930ad2e13407ae4b6469d61d8e71f98621d16cf97bcc59ff243ee477fc1c76b9a535f07ff7bc87209249a448b307e81cda8f3b306173eba4db195966f8fd27e21ab115bc3a210381e2fe8183909e0eb44c83927557a7d5ea9e6dabf7e2e4b71bd2f10ddc485d18bc4367f2b586f5bb7fc43ee82eae1108539ecc23eaeec883c0a0f855273b9b987497c7259841f6acabec992d319b7c84530a7616b42a7c5170eeb599b360f4113c02e1a25684b33030d2d83d4c2371d7bf15d1d7a4077ad83e24a6a093174a3100bc4b2a08769764ca66a835634f5a92a5c93edcaf06655f9ceb5e543177bc024a28b6f7e2a49e80dfde01196da024712ce41e3fe0abd2957ffa4c549379bb77ac06008b8d1b27d20b09ff6d278c752f04c2c2b4e7dad30fb4e24671b29c31ea0485941e668dc1469ecb4b3af83e0c0a1ae0e505dcdecdfa2562577cc5c99b1db890e05d6e5af9d1d2d2f583464482340c6dbdbca8dacd4a46cfac431df5b3f0b92de7ea8f664b69b68e40cb6d0e17cd4d7400568e65bd92232235711fcb20dcfc8aa8dce4ae2a4deed4988450d90eb9c06d1a0c997f7db9181e9fce4d43c39641685cba221fd0304b3ff86be0ae54408df7b5767d429077fb63656d3149314b9711a3f3fcfde00604d6dc4b9885131e4d32ab8f5cacc8e994522d4fbdf9a021944fb11c2d1ca608283f9e2955cd3f004f28b4ef694e47c6aec2c1c4f362d8695b92cfabba5a975b3847bcab956d827449d46ecd8dd43e687b79d1d5d60db28dfe6124acb9415fd4195606bdbcebfa3ebf58fe22d0ad237fc39276d0d684242745616239fda5fc10c58643e3cf446c23dca53774412a692d77893498b7885275485c650e22ea845580fd27c48cbede635f0566c2dfeceaa2e4ca6278a887b4a89cfc47e307ed2fd93d1f42e7c8077a1f98c9e4e4cdf305c20b17154d573e79139249952dcbdf921054cdf1a8c36d211846c5be0dda29fc5fee34ea16097a8441636ce1e0a0eeeef8e72595598b69d9fcf8439dc8dadc6ea72014a04e3a5d671d86116ef1583d28e32fba81bb0209933d65f575e95aa1ea2a76835908e41659c34c061c162748d3c4cbebc4b54f5ee18927d71d8321b8020700be8e1615470e1f7cdf590b6e0644bbac35698cec6e93cd06c13fd17d486a2bb20819e06bcd40e9018d9f894d861a64806a885ee9f2cd22382e441f142e38984b8f4fb551af8279ef87774f154517260105cc3798ad29784fa0b220f7593c5d0b1af42105a694ba0e2d556ce57763f8c3086c9f2429e245ae9c5e5e9e6004a8c693dd934978c118e481d6979c17e5b9db7547220a6c0379212b4f4bef69c4b25cc567fc7a91678f044078a1883ca13ba5f0c5e134c48620fda5ef108b0245a45fe7a84361e42c2b9efcea8e9da5a466bd065bba31a894548879601726cc7d7d86959d4a9151e44151977d4ebce05811aeefa412600b16057bf0b3ee8dabd0fe9eabd70740179999dd7ae9e15bf6b29f7b15d3ce701ad1a6b409896ee8fb380b94e8376386d78fb976421aba328541ee40cf22026dcb20424a8740e4b9df7321d39da92fd75f85ad1edf08a86f896890147ce72d408cb3ae09623a3cfe8ade27e6128279dccbc47260c6da18bdf2016cf223e4467f10979c387c3a6e684c0d05752076625c7240ea02f119cd9465db0487dca1aab23e1190fca08763f35b3f451292b93dcaaa8fdd228e6d1b375da5d11471b59278b65a4c14a8049307bb0a390c267a48c0aee174f815af5d017f952c273ce2ca233c76a31852e50db6cbfedfaf8852dec63e134f31143157872aa0c66fd4436fc27f31332e05dd6a4d4ef99173dcc6122ebbd76102a504e7e41d9c17a19717dee2113b7dfecdcaf5df003c6bba9034b22dcc13b1d9cc81bb817dcb9d784fae72981a3df3abdbc2cf52974e27dbe36b9ceb3723d110e93c6d8f34f8139418886bdd7aacbe416772ca61b49380db22f92f206f23e9aadfd759811e53c76996faa4d2965c3002a9dc6186e15f03a3e9bc6b7cabd01396160d90476234720bbade83e841f02296384302fd486579e4801e8df85b2cc9099a7f247431517270b0e5ffc060fb22dc83592f8353b42343994616771fe365852b083817e3fbc1d13b2edc81476d70d915608b1e87982a39bda47c54bb1ed95288fb249987a1635a1ac534e35641f9052db6fedfff2229f48eb76ee17b90808efd398e1d16c3309477a18655d561d89eb83d90ab7655be7ceb80cf08278360706676ff935387eaa29f82280f711a06c7d741f2bfe1d61e7d13a261caee8ee009f19757a5a84b9606335ded18a06c611a86d075c498f30f5d8aa08477e3a8d24c4895f6cd4f59563bcf007b0dc9448e9da7a3cdd73dd0cd75dcc1cdc231d4f559e5dff82f589bef2394fb46609a03c893f5d8ed2be31199f3969c07f3fc11fe8f533a2a59f30bea9164ad5ce1c11210398d7b8ec6bd8c258d88797a92df8da8e793ba535a2327f9ac78d57dc20b6ade438d724a94c85cfd65130eac9d73786044422636aff5a08c6b9922de8f4173f74aa27ce29b51af1559d29a07f802e006f1fcd8c67367383662f8bc7e3334381da19bdf7f8db50e61ae633c8fb8734308072490ef0da05f11f453b436a3d5cfb5fd2039844d15bcdd4c8ffd863cad861d3d3bb15e07cf85f2657d491eaca04b399677d6e9efc2e6aba69025188274d6079c3073c8e362e07f0b7e4fef6e78dedb70af3da203bb04277c34486707cab298dad8d9d2ade106e14511e26d931db288356889c7fee42c8c38328f429c7e44ad5ee2cb73639709971c27701ce4cf42aa45ae5f2be2e17b290f624edf66e39e83bd323a06586cc54c3657cd7a18f6ae1a707e0db584281269b50f7db6d6edd965baeef1d020dc743116c112a465403cbce3a05652674c7f01dcfaef199a213f8dd000286df76b23d923fe4e7b60189bfc417f3f63928c5ddfcbb67150001d6f667720c548401bd4fbbf0b4b15626b6ed97f553c8e7dbd37c2baec92637482f55460f399ebf09e695b38e8530676106ccfe9b5babf749038a0de004e61a05eb5168d5a29c9d0c30fbe130dca5b4373cfff09d8f0882ee3c69500de03d4abae14676a5075185ba7e62502d826b7a3a0dc206539c98bb0ea2170c477ade5d9c252935444ad2a0e4b29f59a772b2a4b28b3d26c51723056728a4028b938c34d50396ee7163fed8998c1a1ea7549957900ff4e7cc62d7909bba3209020b9a753f4c98a87e05ddcf8848a5f15616fd106589f0c5db47859eeffad2470a623c1a68413ab8b46d3c7c936b63a9c5bd95041a248bd8328393d6af9b9e10ff25a31e712b854f8ebe622f22031847ec460da43bc0d51555c1fc04b95a871bb805274cddb9d7f62226b690efc8c63d89a9fd71315e0e401ebae703f9805d74cc6333038dcf24a705ef5f7cf5dfc67696bd4e6071abea7202940c785aa3d133e751a91fae250907a253bd410ee4c339b34e1d0225383172ec74b5ed1f39d6cf16f4ec283144a2e0f241fd922c5c030daa52c7d7c8850c487655ac5465124f7534ed26faec9221b8d73101c1bb1d6af04c93f958541c9f80a560da2bdf29a4419d0935050e5a7e158bb9447715d0c06f5305b94d2c9a95ef1c2e950d6fe387b331833b806731866829f3450aa546dc423c2d149726ea1dbac292038551146a5747f0bdce5ef601210b9baf753ff0fb3e993012b00cbcd861a4edbc5fd62136357024d8baebcbda54c5f36f44fb97485f014464eab4dfcd284dd4626ccdf8519d53a54aaf950b5d8f7d6804ac7c9bfe98fbd412f8befed2a26cda15bd3784f519d14eff889cbeafc9a3b2d51753122a3424d9fc7e3dbff0f1115ae3efe8673c8b1a04bedc9e0f2919407fd13b0230f01699466a2854943d16bb2c6217aa1d433eea5e6fe0eaf868660e284946e87d398ec4c04420f7ea85c7d687548e53c8839648c923bd7947c2468b4e80add19d6a5d165c8c2f350db60a67f50043ba912b7cc5572894d477780e12485838c8fc99b8bbf45c44187fe1be35f58a73f0956150956a555aefa404611d612d4aa092458a5ab94c0f362a7f7bf6a7e8cde194fdb8797c5dfe9fa14bd8a1719d71110a1b00b1d493bc8344062f08d2145594384c839f0f31b481fc7796e79fae74dad82c83af42d6f745c402a13480b61b491216c0676ecef1648c4eaea05ccf01d2f0d0728856e510742cd0271fecebbb41ab5e5ce1e13801fb6ede809e6524311d3cc28f04ffe01d46096a70417b37d1151fce370527e83f38be78182729e3d1d08b0058905a9e6db9cf17ac2e743e55841253ee0b379e53253bf2ebe0f60a78831d23c7a964ff4aecad8012d2bee06ef37b428bd4c1b1e7741900a71befa79b8e2c87f28b33269cd66eb45055dc094cab286be663af1ed14983f6570f211cd735792a19872f49988eb241141381da1389482783e6c1c9f060c90a13a0fb2cc75cf78bc08c7bd4600ebf0cda3ba108b917f4ea85a40d294d8b14fbad421604612b6537736004e4a2746d1141691f1d887e37daf9ef312d6770b86e995ef9d70928daaaef6ca63e74693166de7f20bfe20dd6d042dfd53e541891b8fdcf94ff1f914eccc6a5849409b78727b502b966f3fa8c642362073f3934d9b9bb2ece0d92dfda2cec236857b2846cdb92e748461ed3704d6f8fb2fffd7a831b10847be5dcaa001bbba215af4f212120ef4cab587c9233fdba0c217319a1a0af2bed1f4cd7fc78e09f0b3e8db099f61e6d52907f9d6fe5bebaf443e2677a86c0dbc146e295a523c7a1d868f07a6b33e32e30b35104282f1ea2580a92091e1157469c3a3067516b02ab63c6a117c2ec6d298eb7e9257498258d709c94d4ec5576e16be04018fd8554c94e3d4e5347e67dbc2cae6ea27fcd4602a69d1865b603402186f3bbb348ac491bbc016b9d8e3f74a6aa8e5e50f69d9f75e3d4f76db8f7ed0ce361da6e66ac3b70f5de817d83c4cdcd8efb824f523ba66b66955412f1560427c2ccbb5c77a5d2a2cf1a6c1e74751d6c610753516fd276d340b13665c15d100f5dfa583d91d6bea237e52b055cb83d2b56d75251eea39c4661b88e5a515206e83ae0e66119b81488cab153af41308bc98a43e0c576991ebc47de247733166ee7f90fad298ef1ca5b456636e98c7b11f16afce6cd6e1819437dc33a3f883002206214c838a35be0883b3777efb45f9acf2cc5aa43cb50b9954400af4aca21dbcc4f02473accbfbe096f1cc60c5bfd76bd72ec9839ac9d6f9e7538c2a0d00c50406e1c37b4a900703b9c8570796e24b148ef5eabf0015870c0cf625f0aa8b681ff10f63307db2d6afe93bd5c02be51aae0ba2cd691774593a51205af6e60bd5092367dce2c11cd747619470e008d1e73cf335650f4a3d53aa01cfce147ae6374a03eaaf5f5c905ae744488b86c91d367829e67b8f4bebdbbc091e29598d39667fc976bf6a5121bf9cbe1c93ba11c2d153437017f126dde94904b66922e21a2b74ab3e38bb051242812ce3a48d1cac1bbe215e53597f66bfd2e6d0fd7af9edc9577b1d1d7b6e3a0882c56451226d168bef3702ac7096a08e4bb008bbda287330945378a6e363ec97862b8943b704eb70a012b5a93de462b466f9069ea823acabacc2c1ead99612be932f4cc7732f9b8057883f7a3e47e5cfc9381f343c988d50aaa85f9617424a1e54d436dae6da948792705bcdea4b8a82a992db547f449385f63bb5a2d23f52ba90792ecaacbcdf0d0fc3c96b7fd78409e3827d62a8773898c1899ef7a256b7a40faf8d30570d845a707720521122b274760953fa39d9665f31b2e42285f1cf2063d42472c8cdc1e6be2c8cdcd5f807be36dbd4a8ecf46bb6cb0562f0a9b994e04fae81dbef3e11a7fc4c0bbc14b97908357657cb723f17eb7c3f017badacb5d23bc663d533f6277a13b93142bd31f00c3f24074b58110ac518b901c48386aa1c33b77118053b7362cb301136a844bff9d63c5b437a52d8d66384ccd498e2bff15fb44277fdd42dc0c81333393c7374438c5e726568ececc4c54b6059975e6e20686e73ad0870aba1e0905188ca945898d05de4c8df4fbc5fda45d0e578c43593819b917ed63677fab66d677c261d84fe363c76c25b36faf62ab5b5d620726531f413f660b8b65d12b4e5a6fb6c7d82bfa0d341aa477b06c67bea712cb695850734c4c95e1501b12397535a5892e18bd29530f86e7d45e4d7b6e1d0115fd52ef17da392c78192480c29dca58ce03c2b1963ab21f5d9e5a43cba65e4e0780b1e7e84fbe5cf81ed678b1435ba2d8e9c944765ba3c98c0dab08802af0cb4245736ba0e3f081ffdc65fdd66e1c769af1bd2517b1da8821d3156be48f67c6aa63fddc88dec867fa2c2ff35c239a897123cb163eb2d256f1ae7428a21f5183bc6257710a97d5c9f4d3b0275e2b835d23ae11adcdfc457aef7d5dc007c507af33ae11e3961568a49c616f4df7df9127164404bd939507d775af1e9c1c192b6a6e1d80ec55ebbb35b4b1c2ca9c6ecca085fb551f3c6a749241bda3c3ed38fdde07bf49e8dca98140e3861d5a9e6320813b6c42e6df74df8ab960fc714b930125935566e45c0884492827f45ab68e2db54a01db2e40e31c3fe27aa3fe1d4b44baa0c375231a1ed4da5561dc38393a95a431f6373500cdb758f57f7ea1262add9dda171c4fc95b9fa721b755e73b27b368c47a9e350bbfdb510b934591825a0a64d13c00e663956e49dfb35ac619531919d990bd60e76d1358e109a09d0c98d0819e88573ea434316ca5fc8dfe27efd1d0845277ce4657b4f2c96349e10b8748e5719667910222f3822a42c0dc6a554f31e1db3f655ded9733a4e53030b6b1e11033f459ae1625a7e81011d9611b5c5b9c35733b9e1a248eb365edc1aa7bc4a34e73a0e2bac891d87093e927b5b8c4e6869b971e3c0b5e04d6c3b87ff9a80428a91c130dd48e843f79cf1f7d22f34651741e5e34a246d04f3348a8438448b429c06f77afa8e96a844abb6c18b0c27abe5e891db5a6bb5b231a7977939aec9a7d18dfec5daf3355ebd629e3982872b26256c9d60bf3fd86b8395699e43ab43f1824e61524df15c71ebd940c3f670d1cdc645a9b19f90360a9b76598dd9462c8d0b860f1fa81bd338991f8c472bbc0fa5f172ea433ad8e2c73b838a9d23c842845d2e9f062c4e0915ca64e799823ce9cdc4de53f0683f2e66ed4e4e588035a8842a14833d7a0801ad18d32901c2b9447b417d3e653d7d8fce5072a9fc48c194219b502f092e7605170c886e57ab75219a10ca2309561085b1f79402b773c5b7ddb44566627392c77ed4f95c2a4c6c787488fbeecc5e16f87d35b3342bb1fae8c5e7755d09c62c02347892b1e077f79a829cee9f58e0a68e7f7f6e6b9cfb9652fdb718a6de001dcad322330e4f45189312f64e37780639a3a020f3a5a59a78023ea4e9cf415e411599e542c24aad882f6f1da8bd0e12b2bf4ae3b43f9585e98709424a27bc068c056f2afb90357a2bee8766b276d05112502a50d6348e8b8dbfde2e9a9671ef5f278008a7f378dad7d5ebc84cca803b39e0413b968a779318eb00d3a3a698a1e682edc50ba6be13b9b3eb391b4eeecd8910464274b61123e44b038ce96ef9898db75891f472e678db830c3cd3e86a3da8c557785b20e6bce92263a66508f5de951ad6a7c78e600daa3c6c723f85e1b90c287071755a622c33a1545def2f6aabc2e9ad5de710033094d2996c0d366c2b0eceb4050cd5857d8bb0f3f82e3dcc45c67cec6dc440aae0864c2b39cb2ba5daa551ff5fc6bd342ca0ce55ea3a5afec087097777a00a80ff54c7152b35a27823953a2f58ffd97f2d3ca5b6e95c0540b3cf58b013ca97d3b3c375db0d5cc405041196a1b53423f56492e8cbaae1ab505ea766e0dd454c482e50af5155e2a4df9143a9c75868238d988ac504dc40bf2472127c3992474beafeb59bfe8fc255777c0a9681a1aee0f84c8880e67c841260631c9326cc08edce6d33d6a783dc1fda145295c859acf0fada345bf1be96e9a43d411bf8eb173a30fee8738d54424713a0cbef943fb2c3e69e6a65233d2028c31e54f5b91263ba10501cd57f62d803aa7b83e03fab39ce8702f68d6ba0f7fa4cd5a0cd347aaf854bb938502708909600102e73dbf340e31eb2aed2898dd8524a1347170b99bbae56aa2d34cb28f6e65b49d919b90a3de3cdadc63baab580b847cb39db7c7fd7679d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
