<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"401720a53aabba3eb556c04cdc548026ca3280ecd5fedd9d60a0c5b6f2e37664c6f9e5e55134671af5e73cafa4287786f5e40afe8777fb384e6aa1e6399b092b7bc9b18fd09e34e6be7c2e5dd12b7630bc0c34fa53873bcc44dc25a82f56a73f1633cbb3a89315cd4df4f5ff079950c43cd8633ebecc3a93906926c2b36e388892be177c5d6797d04feac441bed532fed16580d8ff92757e7c3d32f9cfa48685d7b8fd772f35c470a42a9274ea81d12382d8fd918d1656ebf980964f2518077ef32ff90a00236b69dcd2a8ae4e060cec012ddf9732368bcf2deec9a986488f3bb15ab064f2663d465747601137318222bac5cc77d9645147693143c669210d95bbac0b8fc7a8c4afe2b0c447fb8627758d204f04c1f5e01b07e5aa785995825dbc7a00c84027c173d7c1e5a5116066a25b78ece286fe3ef4250ded483540e5c65953fe37db3857eefa544ee9bdb68c678392e0d5053fa26266c8a4b21ae89d6cd55edd238d640a01bf4412d370c811bfc6b9a4ac1dc079367e09da151fea489de61a515f8112da1e4c93db3df98494c7ed4d469672b559ab418fa8272c3453c44c822130681d67cf04cf37f22f46228b1359625b82a1eb043fe18c05aa2fd22ee8976f72bcf0869724eeadcb942becdffaf48d80878908cd83ca304a4531f1f61f8a7152ce2f79e7f8fd9b97bce7a419664e754649c533e1197e87bd236cc0c04725a7a4941d70d1f621aafe9df7e1dc81c776050f459a577480865416148889f8993014282da6948e8cfc35a5cc17783f19082a86568470761296629efde830c5bf425892e7f6e69d04cdbf68f42ed8072d069dbad069669bf314ad134883afd284e9a5a9cb4a80109f7e8cdd95866171664bd1068d6bf7a8b7ed45f5cc6e5a4956f8f1220924f27ba1509c7d3da658906e65de79282a89b87abc81c758d0a7efb4ec0128b830a55468d2840e0893d82900cbf461de4b63080c5a6f79d3e65070da73659bf961b10fee0d938e34306e37b909db87c696d7d26e898fdeb5768b31c225fda4e70bdabba2bcefa8951e6a3e59d17cdc507c833a861bcaf3be11b919fde677a496c7b951b5a3c5705abc45cdf48ca8eafc7684b8ad6d2b2579520d2e35fadbaf4ee18c8f67144a670c0c05f22ce6bde286457295ebe5b7136cd74faefdd366dc5678e9ac5e52a6196bcdb6b3ba5ebce6742932d4c34c8ca21b371c1fe4ed22b168be82a305b212899d1b70dd1dcee0b4f405e954c904cc27f39cd37988d77e8065341140517d684047dcfd26494f35e903a1ba7bf65bfa1dae8165a8949d978836e6e3a5c1fd6330aed5d1230d543ac8bed8a4e006595c34fc7aa11673a79b1a36d7d852d8edae7c7ad7ce7c65729be55b7353b207e7045d96bf437a3065b8e077ff34d67900c248f1557ed99f9caa469880e88d28e2d09f64751d44a2a3e5e6a5ad89e53baea6186a189ec20f0835fc97a2f625708a9ef545b255d0cf3c3111f2cd1c490165e8c5eaf2494d960a702480e4d79f4d5507df17cb611d8ba0ca5dee9ea649c70f9632102627005d53c1255a78588d2a73e9fb01aefe655599d04b1a79219ceae28918dbbd052b72a41701e7fb5cd95a1c4c4f6d35ac0fd6c8546b11630f95212f8f8b5dffd2babbb3bd67956b4779dfd48179c4c55c7859f5ea9657d1083b797beb37f4a3d281181db9069f409e08ee40d7769dcc2f5acd321344fd73971236a4ba7ef95132b4b4111cabfa8ab9447bc2785f02ea4f9b6d96bfa17caeb06aa9669a07e0b13e69d656095f56826e1df6ddb7d38b33af299851a01f67594bcb430011108a83b45e5d5b854b7b9d5c0be196ba7d94258b5f853dd91b4e3e05162f61fa611e61c00e0439182c63c1e731477ce730491f25488cb82df4ce439a078894899fe85da47a188bd6286cc01d712dc9b57d4a6ea0e65209b28490a64b4e3c655ec5c9775ce969a70a451f3b0264c01b334eb6581ca4d3df59b3dfe0c2caa9abc447422979f343ccdc0668579c103b684c76394499019ebe9ca3a9a584b3970871a982c23d54d2dd147ab323733a309318fa00f9223a95cc3a57267df41e4a125d6ee3a7ec2d7cac9564dbecbeff371f0e0a300a5f3426d173f669b9346a87c253049d960b077738572acafcd622ef9f8fd10a086093b8cb35931e4280981cad007a96efcd0a46da492de93bffec0f3edbfaa32a50fda8a68a92aa2db3d153be771cc2daaadef33ff9eddfc0c7ebbfc4cee963ddd09949bb844724a4209049f07dd2933d2d468bafbf655e66469ff7424e339a27e21f6f33bc86fef5b162014fcacf33c4c868f97d6138b76cd5b98f286e288e5661b093c7d578d79cdc6970e4dcb9d07d7b38187da7a6342ea9ed6a73088e40635f37671414a24ec39d8b29616270c4e1ea0174954b5b425ec9bdb2cad129bb198bd67049a581b790af71cf80675086bc5df2f738a76d59e4681222e12ac21ad9b624f88ad7cc3eedb520df1ca9e537aedd9aa60a09b240441d46c211aac4a038dc51fbe1bd61b604af63fad0a66cd7216c98198e99fc4ee3eab304abd0d4a93c05530305c94a5a31e59d6d8e165ceaa5b988e349f069d4192853460768eb5af7233a41aced4015c1f3e0ec7e034cdd4f768f2e11044d1409b7cacc947ec699627d39fde292bb9e3295b46be53288215ecd5803bbdf45a73542c34323ffc06858efbc5c5781c6975161ec9c7250a790b9ca8a7ff5b8705efa2b7b3af6429a5df58c48ae0041b776302404c84ba018bbce7c727eaf3879988b50162dcad55b5958670cb1074ac776baec328a6c3b7b9082fcc9cd096fa74e3da14d42eb9d2e85b84d2ccc8afefc18200a44aef27e0bcb0e17adb9261eb5e0dc1bcb4e2007d670402af626947f3b94deeb5bc0bf8d4084fcedad4c43b9b407cda0e784f99e919b592e7656bf447cedf7729ce8796e85276b32e1a3e71322b8fd905dc547e488babf6bf6959bf07cae2ccf6cee69d87ecf26281176b62b0fabcc4d593143319c211a43e34e30757d841eff5f276c1c98e4dfd13f25a2638a8911fa94bd13694bcde65ec36a57c6afa2d3794a923d03844fef04eb92c25441f84cd085b44d74e214166257088667dddca5d814f7f3d891b6055c8eaeefe59261e87abf6112d7a33a86c94fc16779eb86ab6e4635ebedae16712128c2ccebafdddbaa7cecbe112d70d03aca6c89735c8554c22d9e6229ad5994e08dd97f62bfa4e33101e6aa5c48cc2a92fbaa2affc80d415bed41ce5593994becb1569a758dc94571b99475daa1c5cb7ca0a84a8042dee32c6cc0c1f58f90878d07840fdb8563da3aaa49a9d068a059f8f2a4ff4932d011bcb85299ae297d78c0721b88e41d052bab0da596ab61ccc8564ef0e2665434ef34f48bafbfa11f715e354e4995e62ca0cc6268b82f98a1cb21f293e4ae0dcfd1266a6755ae266ff7da0892a192f455d4fb10fd8390239274d272613a1e70168a9f5b426e117de125dbe6de1191d664236b213f4f4c0471ee08cee9e7196cf5deaa5acc26c906e42f997f78bbb93aa96c9d72e18b86d42a92055f87b3a18cf4fb44c24b261bb84f171cc58bbaea5919cb42c230e030c524ec9e6bdae3ce8c6a096a9819aed72579138432e615ba7781554c2e0655b325b2a0d48809bbc1de6df7415a60a1d7e7797ede0ae41c439ef9e5b8e2bff0a209428db9f0870f00e338a210dd9c5a6fd6b42823ca0d17a910a4dafda49ba0cd44331328f7e0154a3a32d06be38720faff68cb804682b498b00d1b9830817fca57fb2ee4e08cede70b6005b0b3f656538e500e9e973c8c1f919daed2c36b109b04ffb909ae34df5b49cdeeb47706e2d777ae80a437563c2709adc0ee9dc1510d3aa2e31a6c1d5b65d9d0c0f03e53586c1b40da7655ab55ac041c7760376c926779142d6376c2ee9c2408651b38ea80c55dabc8236c5607c1f44cb419f3777c480f04823db6f69a0167489d2aa76b2085d602c62d6a025bfd7469a7401be6bbcf6d458a80548860bc7f2292d2b7a0e71a11c635381462f42c1b3d49a0eb344d8e19f5429ee85040d8f3e431fb9705b6799c0d6446461ddc117f7e3f885ec9a4c360fe3da7df4bad008dcf045dbe18dfea6136835204b91314b55103f2b04e79598dd148a6a54b2452632bcfcc82feb895dd1467713cfc04fadfbd72d7f02958a1acf44913254cac36cb3c9f68e3105976335aaf2563dda1b64dce7209e0e45ab3b3127bef24a40f94a89373bfb88a31266dc7b13bb4dbb5054f101d8f50e6888bd46816fd875847c293e160feb550276eb8e561873ba477195468fe28eb14c527ae7a1cca404a217b6a6b9753ef473e5ce7e22853b268cebe1df6d82cbea5c957ea7f42a542f096ed2c7cae44a2e07b0d392ffbfdd12e8ed35bea542d3fbdb703810df53fdf67ccf4d2d636a5289c6ed5adf8252ab29fa20f9b89f02dbbac09956818f370c7fdcb9ec292346b3f185618d296227db55afdfc7f3d04a54ef2b8349baed53697e8c127a17267bb70efa82dd290239f1e903c21712606de930c5f0cae9471e6bafab6809e6bd2abdf6036dd7c8b45c54d9e9662473dc5e26e4f364b74ba5c99df68a8de7243ab37203f97834667c24f500598cf5d89478ab2b45737452823c8a74f0063405adefef765820e0eb9fdaaa0179ac913c61d413b1f3966f379e3de84985948d358f5a028a711ef0d33a947aac8dc0ef7bbcb42f4b8ea3c34fd1f89eca897997062d7181143e8384c679cdb5e12e2ccc9483884c1daa6d1a57d76699e69bc48d3bcdd85c8fb7e76c5a0c9bffe9f94bf5d0da6b127d14c2328770556dbd6723d64243b2071b8834329ebd9ec07ae483d706e5aa8ddac217b4e000ff420f1ea0e3d29e11b17d3961c9294d4b5dcca1e681bcda3372083711caca26d66091e8f4c4ec174c392fd042e2fc702e4700001c33d2323e93065ad17459f60b5c3f608da5e42c2e73bdb7c9928ad4c20f7bab8964efb7d5b4e159f1e654926212af7e960f887b3d905cdbd97e5316b1686e4dc32a8d7bb9d18cd00f6e1eef10ecb290239b6774c07b95ced7cd9646534023924c16bde883b81b637862642bc4a596c1611eb9a4dd94d93ade28ae977caefdbfa2ccf82a7ee3b991e6f3513bf37b514fa62361578e628ccd9e2933c885cffd0b72e4153f07a52d4e79abeae60a2c0a4854e2af2114692833e71de998efe1097e3a12a66f3a39bf03d22a0e175934673b333e3e3050f65cd0c9083ebf95660c293649cedeee2370e2bc18bb1ec19bae7456a28f1332e6090ff499bb866bde015c8af216fb51ee052e06848a21361d5c3779e4f2ace522516793c09f1a02137787c722ec59282f3fc0d6e8490a014c44fa61e6a41c6c4796dac3de5f6d27529134ec719decab6da1a552c1ccda6d2cfe48b92624aca6dd6495c4fa1589e614a044a7185d14f26d0c4a7a2b0702ff8e8680ae9cf8de51ba133dfbf555891ae22b61a10c20e3cd57ad6bbd4650b1c8f92bbfe8441e1a70e81e12d84d5212ba9d0e9e00d9ed86e5925cbc087d4bcb6ebd6a3be1d51a4c682e5634d8e56a4ae5dec61a420f8d072fd5bd74dbbe849e53f7240e0853f0f28adb110a311a15040671519cb189a7e6ac59f3b88b4b295a3647de3f9d333bc9f00d3e5df20ce00b1fcba51c4302330ac268d88155751d3a85fed9d1e06f69b78e2498007ddeba27a08780b16497d01dfc04210a5c012f1b3dcd7b8621e48c09415f25da82c742bb158c935ffe300061ebb250db391e10358e73c0889ff4e0431ae261a98f3dad9374f57b2edcb975267207ea9590b2b7e3b473f175e26584a54cefdbae98c33cf2638863d9967cdbbe29c8ceac22dd16e5c5756ddb9722b1c316a06d57e82015f5aece13af6dbeacdb6e128b8344dbeb42b6f671545755d261fbd178f92a77ada5ce5e7b6d9a1e9a64fa0a6cfa09ec14971b9c26c1a24ed3670bab7c26b140143881c4244f792c0e6f627174e26e4662dd66021408c717326dc3438c187c500989337fc37b9800678e643cfdf167eaf00943eec1aca838ff5d3fb41d012737f786db84b19a09cbe73c14e0c25cac41a9bb47fb2c04d7531471792c302ce8055a3683c72908e219187598c85a5ccd303235b31b809768f8c63497b55cdd1acd3bc881337ccee17c6cd5935f68df2dd1cf893c32f1e44b3612ca428c4757947e8fda03142d78357874e4cef433bc4db216d36febc7301c27dc2fad8f1d52899634156053e4871423170886284597af7695af1eda198422763d3e4b130faa62b4dbf4e5f9dcf19f33995865a6d7b40317a23b526fb226cc8eb2b7decb2f526045195841c2805533e04c28f1f2f854690a3eaeaa48d0a69790d3bf2d5db697b579849dcfae16dbe548a8ef366b18c8d530c4794ed21e585a3b6f00308ba02f2f9594420705d948b9d12b19020927e9e3e3adc8a97064b34406988615f18c5f332ef1c13315203acf8dd3b9ceaf97a94970106df9475d90a858989224e11193f3f012967b3f4d53edaec24031898915c71dd43a3b3952f4422a71e628cf2f9e06cf0462a04047527f6b0b4a214ffbceadc5e200647967639f06fba1eb116759ccc94ff25d658172174ef1dd5149b213f195f5acdd6a943b053d68341642f39326cffb90c0177119630324c5fb6de02f9eaba86b9f003454611d490e674619e623dcc37f8286021a9b1a516dc796ed31572eb4a4efebc5cf81360262deab12bc2185c483cb097788b3b6c11d05be1a5204ace52cbf0e070f3123135e26e9596e3b402f82c7f786e6f537ac067e1e6e2d05570f4bb78b6b2ee1c3861e35ed5ea38a9ea32fa8cadf11abee6e4597e23fa7cf37db60c0923d1243d6ec1673ef45e84cd1b064d60c67f52dab2f052979cb7da92e8e791d78ff090575e36e2af7a1cc1068beac4606ae4f8fe69b2461c0a81a1a7e242bbeadc759a1dee4777b8613b03d23b4ee6833cf40e7495bcbff85b6e3e2e2c682573a0fc1c72ae490ff61d021d3c4de48cc899cb001b6081c79c6beb1fee903bec61ec5beeebe5bf4db3b5cec9a05de0358a9621def1f2f5c7bb18e43d4b1e3fca050702c0a614d4007ecf9b432f8f67e306d58b6c16df427aa172a6c17ed260a1404aa02a7fe25b68b2c29c42e8fab1503772cf19c7f93ba0b819daa75f6bc2158c136c5b7f1263a9c3b83f4b8eb890f95eedd5736561870abe76cc1a7c1999e2d37aec2936bda9613437641eab05c1026bea55dca84892b8ded94b18d8f56e560e6cfdaf50a2ab0a959b47bd059522f2bd48a4ca7f23dab84a790bed928536237bd329172c9a4c9d2cb4d21aee4ee3c4e53696be6f90672ca820258c4aa748d8b365d1d5a656b2a8183fe509c14d77fefd6652ae5d77586f923688a95cb65832239eb976f56f713d989fed1a3fdc39fcfdd8c46a30d387c9e8e5ccfa643185148181f347be5d39fb64320ad87cfd717604cce70dc7146da0f71d8a9e045069ca4c6cc1c784a2040852bbb10b5e8c8fdf8497c520aa01fa11f8521ff8d1dd416066e02ada645ab9e14b38cae9d8cd6208bff93af280afa5825206dc55b33e0cb0e5027ff510abbc579e5729265da18995281d525ff901183a30d1cf1150209a439bf20acc2f6b36f932388bc3fc0ff430106740855b97e886bb7c82a5928a05687243328e833c3212bd7549e1bb98c775233da3ea780eb334a18e1e3e820ca19be0f3d448432d1618f11889c77ecfbfdc6f1d9579c6b79c57764cfa44b083b4512cf52a54dd0811a7ea09cf4a913bd28ea0d2fd9ccdb5f46df6a2b95ab96e4f9dac8d805237149506266fe8439c66a76878ce6a7dc4dc1e4721c736fec3b38d48661b8093baada50f809a283e5ebe7aa687a79edde07e0130d0f85967b84df31a35bab88f1b42de51959e057e16b5e222c6907fee244cbd9198b8c8b9db2d7abe8a1d81530b1f123b40332cd2a373cebfb4123413b5dc2c776f9b5aae83579a4d047cfd77ca34a2c1100b7bcd1c90c23cbc83d577103275dc4e9c158e7191480c09789246dd4598e9118d8f31801cfe97c852bdc35a1ddbf20b4c0771718ba0e3675f5410f84f66f23e386b790f296822c7cc4b74e909313a3d3be9687b237ed0276e0c6fe6e6bb9b1b2a7bf0fcb4ae283de357170dce47e4d7f3d5757af6c184a92d5574fef1c378abe8abb4015502baf07b780b9580fbd0f481b7281017338e27addd0fdced8c638c145778605bacef91f6ac2d8f58b7b10cfa655b988ad3b6bbcef0e9a21ffa626d58020a39b421abd9f48880936fcb0f48dbd31a0c719a3eb8cd63be957d1eced0c6939ff8ba2246e2e8d62b1af0274e303290947d83767e99fe7efe00c9988c4c60c414a86b72d1d5a5d140ca589013d0f4a8fc4a8912adbfea36c1a299ef0880c69b9cd1f31f63ed559d685b594f252eb3352d532e0fda2b9e36611fe22ff0401fd564fde23d729bee60b7e6dc7415d275b836fe7d26000e55d6ddf49019cdfbda14ab3f600d96c8a226ab25fbf9d08d192dbfa3446bd94d724c880d858158019c1ed8a32d22bfabe98a3a318761a274f79fdd55194ea2a79e1c360d07d97e37f2eed4d3ba715ba966218d6615cbf08953b0391cc03c386df796a118391562f9e4d70c6004a484fba54cd978f9640123e8c675722350dd1926046329641069efaef61efe263f9b69c3140c748f272846038de0089d38a50d61dd8e1ef81129860a534afcbdd685252d3cc1dbe983718341de6cbf0e8a7771a24a608afb167e2b011cfe8f2da186281c2329409f1a274be32451b3ef0c44ed11f856a7179d23bd66ae0e132cdc08df6ea56ba5b8eb96c8ad878f0c4f5b6dfcf6c7f78cf618c189d1f4be495d97ce718b1eb19e9569b0d8a83b48082d645cce7516d56b4598e97f9ce7dddefe619bcac96b78b7ea8a2694be0f71293f6d25b3cb0fe7a89c31890d8c40d92e96e67473e833e5d1955663678edaa4f2e647f77f447cec473bf8a80a778610a0f9831bf4c72e74b47bdbc91a5c0169485feb7df7ddee8abf92a2c97113a750f2e69927d721235efa8343ffeab9f766fc2fecc5f28e53b256fe1f48873490fd5732f265d9cc0474cab94757372d295bc920067a715d823850500767b88c370f61901817d1f611d4a1aa102dbabfa761a0dc16ba53699516d5b04f1a83855b694ee5881c2656d1079ff4dcdce29e4dec16bfe99acff7a03eba3e56d4b9e014dd4da2d7ab1a44998945000880cb83edbffc53eb019db69201d248fd50dc06d2db0946b84f28fefc4e15d4ed0d02baeab5398f05131b9ff1e103e14947fc9c5a66c378c4e04eb026e30c1b0fd00e1e03aef2a86349e4c1a0f284d26e36e562b20da7a8985b9c527c2bb5e17804ea45aca8cc109f26b75b04b04ea9c985f4de418f894954c3a22cf893f279a8067b21e09f870df48213218ae352723c5edb200c5f7f6c80dda9c0608d8ac531d3f4d6f847d41033a74fa3efd34d024d6ccc98d90003cbfce38bad9d6c3606fb120a2a0e2d65ee0239d52ac01bb693fbb0306e1c1bebf55c6069990b1ab62127f6ff53e1c0211c7ec378d9ade3c5a076f61065dca0722cffb7aed98b5fbe6ebb3a2fceb45a606ea54fe847e9711dda645b9dcf7b905d78ac489be17e405c3c71dc0d7587d12048cc2a671dcae45b6dd0c4aea27c538156764373d88d26d8d4cfa46ac1e0b9958be34ec76958eb99b4eb7bae999970af4053624e393c18e919a17bc2f44f7ee861dd40d6059e4000f0f8172fdd324d5f572f0cdd4644b1ba27c939b98932bfb935068e6f65e353e35ddbce90a37e36dd86c073ef99956c5fc03816317e9842758e435b71cd0bdca66e3b292c566da45933da51379efb6249e8326a7cfb35bd1ddc6d5df3513b39df49bd0a8d975b8288e40caa0e4a7fa5f05062e15fd7090d8e8f8ccfeb6a02ca52d0ec79f8188b9482439ed13ce5e6ed73416910179ad0ad61be1679d843ab8fc5fb34511eac97131d1dc78cfbfb50826ae9c6464b7aaf8668b40187db529f7e2a05f8f8898af19689e0ee2c09ec93432e6acff132cd8e40890b7a0b735d617ed31845f4f315afb965f252e461a307ee7916e54a8264fc2fdf18c115e91e39eb483374829a16c81cc6107c420fac312c3df75182e7369629f63a9d8b9de69566ea0937aa407744889340c64429496e979a673b8d0bf59765efa5dc89811f99e7c132e24200683b1223dec6fe7436c6f0cdb4965a081916ca2ef44a2f377bdb3fa288e1a063289d232d86c68a81ae8ca516af0e7dae848b73304629fef32bce869e915bf2e80c8749f75075beaa7eba77706763130a7668eaa5971f7748a57b96c8866df915393369cff4ee807477f95d5518dc5d5a829bab652782dbd12bbae20343844107e8ef04fe03891bae25aa8c0b7cf5ea397675caab6488ede1db0c31c743863faee4b87c185ebe94bd0f5291502a380c2ec91b82664237c12010c76566c6dacb57f4e8a0ed64b592d7b6acd736842c96e544dc0385c2ab2c194382c7cbc9aa67011924a98c82b41a7a8fcb9c97e31ef4619879f63e2dca57df48b4e47a88fcdc5256924f221186ea9355d330a4282b0ba01cfd4f7cb5d3732dec7791daa3e56e4745d3b32094dfd7e24db7a125870bb30e84f53b45f981caaf6e597e9c0ee9508dd8b32e0ba25fa600558a6e2a47b63cda0bbddbaddc3db9a3d76b9365787fb10d14f1a9b80228add5859be3e7fac12f2948c48261b31c28189821472a5eb0b2da523e28c33b26323a830f9001278127343500b54c3ea6ca511ceebed3fb357c54e363766ece2715df2ff9bcd52bea22ec9c3ecc57009c712b962a587fdfc877a9e3f3cd2a575e61e46fbbff40a244da7940392a5b2ffa1a3cc65b588846bb630fb5f0e2b1fd8de36b5c48914de290eafb57f48f516adce96b4a1745c5d86db307245f103d084671c8ba9f33a75fcafdde7ac4d9eb469c7adbe888ae6f77760b413a3eb5818984b0f5489bf891641bb01c59850e6f6377977d2aebbdb513271031a0154d616b1330bd9dfa45d9ffca5c070c0c4a8d2b9653f684e081a753cf04c97c291f8a78de43efcef34f683c1dabe5c43681eb7db7a9a2f33691a4ef8f7efb7e91c572d9d2be909100bc1222377b8628961401fabd3de296070379d299a51b7e8a0be4a4615d5907591997c55f0671a19be75f757e43a4a536a56f8ebf2008b01f8107b82559d50b8254b1d186f589a9cff384b2f5b110837aa97afced79f123d52c100227be2c4c436c8f3ac6eaff3b17df4b85f969c307c40eff3cf97fe42b21c4b339af1db27c47d9e3b62d58c745f17be367c72a81ba2b31e7c59bfc2f859196a23d0116edae9c5f0059ca68f88869f8e2e5c8f89eae9a30dd5df9da2dc887f06c2b9b0d79a56e9657802fbc331e37e248558511d962c3a3d18f3b1db853c3c385e8a34ff3389f0c1910f7f7b3e88ed88d40df1296bfb312b91b2e2bc2581fde18a9ca5607439de6c17ed0a80326a2205cae2ff25e3a0a2a1f4e7f2899a834c16007837a262b4011326ac5726fbdfa251e0ab4f7bd316e6fdd77aa1ec8f47e87512478b21c137f4bee08a9244a47b8d7bbe67ea7259966e7f00ec27f503a04e904dff68f78e8f41f114cdb1cbfa5234ece6ea3215911aaf3a3bd15a3990808b93015a1a42e322e2b8d61da5abfe7a52562a51765222695e56b4b451eea8560466ffa729df8d2f89516f2b88bc1cf6c63473076c50ad4e6fb60fb9f7ea89579bbfb1cdac167296664a79a78ef105697a492134416b396305a881537f1b707f0201c5df4a32da0d0b6f8ba11751534a1402497a08c829a0a44ebe7582c991b41cb3b82f8c5e76805dc903294fa9ebd1bcca6a5149f8a21b3e443eec5f6d766e965aabc812b6ddd5f454748d607f863151859e0afccbd41d143577f26d11f2953ed547476df6b5eb045a88527082f18fd70b18287cdb91a57c8d80171d43a8b17ee2cc2b65e7f869f6cebf112e416f4357049151a5ba01cf30f27415992c891b64601dc5c714dbc4e9b9b2636bdc5938adf11499f217583fd4829a922e03371660b9d91caf8fcca083afac1ad4e8a3e6716f4c2f98d815db26bf4e037be044feef0bbba3ba36a14ab7c9ea8ddf2d7ed5429a04413fbf3e8474ff8150435433975fdbe65281cf73da021032a039c30ab328808561ecc05c61a8a0f26b900bf6fa5a71c206a67d6702c295b755bf58df306094c475cbf717bd3f37448c4bc3eba06d434d114b4297193a7fd260066d1b1389f3c9c23f9842a09402dd9eb3d6bc090635fe3415245bdad00100d4ca0073d86cc1499151d6a2bddfabb3fcc38281b1b1f096714b3fd959537826948d94397d4943866c178eafef7721780bfefd2747a6491fcce432901e506102ddcd4f34247b2123c9695bffeb30d20a796c07ead9683455284d065c46c0197863d8037da691e2aa64a5eae5c4b86115eda65b5e29be7e0f456144fc985bf472a89602b2a725a384e0aff2a24871cf5b92059fe4e3c97e9211eb8f3cfa7f72fcac2b2796cec648a10482eef6e6d7e9e7bf7c5cd364cf53e18b55c4b6779d5ed5a70314f36155c42d7bf5d1984981f8cf516059252430fdeb9a54fce41b10994cb9733205a9d26c46db7b52e1b1dc8e805f6bf779f6efd60a17b1b95958624f051c2cc43b91e22a595e57c6f27f1d86cc7c63620907b364ad9ff47ca65e1446eef71848357ce2a4c0266f31904944b045cc412b0d654a147e4e6f5b4db98180b494d3b7cca1b1c1e262bad7be7b99f10b49d8090955c466b21190048517eda6791ee02f5cb312afe90e9dbb0041ac6ebd3aa90634bf0b45dbda0cda26fce9d0a84f0025f0fd520fca851e381d8ee59f6206c3c562063916a74eed1e04d2f9fea54273a4d7c58e73f3336d510874aa24d496f4ff5d5ef8f9c8aa2c520354dc566b872d5b590c7b6c682f508a27c18e50961309cb793fd5f9f58ab569546875542ff36d7c29919a284ee67df09d686cd868a0c8c5600a624a7cb56c46cb405adb2d4e2d630ca655a5785b5e7dabb5f8ef2a006ff3bca2fd2b5ba2ebfe472c2eec4bbc9e5a0b84305e367a8794c71655777dd79d3545190a5394750aa57b37207067134e1dcabe5723959cae71219798ab86481538be96a0d556f26c56c1c0284bad56aeaf7f10af22f82e1fc221366553ffee8c0bad3bbfa6c21917ae5c9967b812464da21552cc465c766f34607d22b098d4609502df16147329e0e2d4c71dea05cbdeaf5a9c1fc12198c239bbe9ee540d1d48e7bb6f320948a2ac6484bae0fe8361d79f5f0004afb8bfb5392c2f94be942bb8da2a504b1042b8d26ef01fd91914bba4fd946767d44be7048b0fbcabb382a15695d7deed34a352dfbd9290d3527f304b76558351260601045062537838d45216291a5ed80d00161bce9af642b71bd734db5b515178ae033691f9c1b631d6e03e12f819d6a3ac8fa73657423e84421994a747c62f74dc5da977f5c4ba82f99e846df7671f6be25876df59049df8103b260ebb63710ff2753a020ed21b7719c2d16d6a0d653af40731759ab19e6cbb827240bae94c93db8e431044989ce245bd6d331378ecfc8c9df1976d6571c34e65b1b0c95991ee1ae83c4a74f3d815a23152414ba2f26a34fcc64814c20daf410dbb8c5f3cd91de22dc111c060b4839ffce9138b8540e55bed41cc72829c209160e8c46a58cd3cb353947a1a033e7bcee00cb380b30ac3c5f819b5e3691d99a7887c14936fd7131096d70b7dc9c8090d4cbd3f3418a0150d879e65161c78e43d72b6d29558101bc61812d7cee8e1277eb8a394999af1dc11b9588904331fb6df1f5a0d7f6048c5fb9ffe25e34d9385ad02f92547b613ddd80382825a078a8bf63e2824c6081637a3d5aa1452497f2c028d02f3de0c7ce4bff03836fc3063297d510a368cc3d2a6db0b99599961f80418e3f528d5f250423edf6fed924819a10cc85f94e72990ca062531713f7f088b079877f4a840f20f7476ee7a3393743b56851cd36211063b7141c522971eef722d3d7c8eb1fba1b6fde678ae88815e78d98573bca6011c598628cda053c93489e2d139ede816c677af1bbebe894663804630eeca2ccbbdcd1209c725fa1d70bcf4112101ae2f2e5d7ebce7e069ee020f575d5663bf4d5afeb1a80730681d3a3d7b8689ca7acbfdad592a9f0d43e14028a8afd9f08e75bfbe5f138d2dab11fa75ffe224171f9080c572acce9047e6198b558c4e244da8d5c78fc1c8bc46e5e414bbbe2537be996f3abeb7b835d35a44c81d3b17d303932f93a9e9a39bccee87f0fba3e96820e6298640ec0b26fef1e5b4aca0fb75bd661e7ea1a55af42fd2545f2885d804fbe456d0e9a1f4370a282b97b31a6edc38c7bb66c5135a510c14c40c6e6424db0685ac93eae5f4c257564e11d276df70e5b4d479c364547d31bc8f1dff755de7dcaf2b85f77d56598fe7905637e296c5d3ea4557a0551d91c056d2e1d65e2c7dda5270e7907733c656491224fd90a537e6a14b66667424c5a49caeaeecacdfe7b5f2c9b2fbf687fd49951ca59a2d2d4b1f04e5b672b8c1d993b3f1c108c8cba539b4eab0a6d7a21627e39c360fc411dd2b381b04d4c885ea87e2a342b4e627411502af5dea923d8bafaff4b4a8599cd2e637feef83a4c1858148b73e01bfef99b1a5a3b5c3efc703807d61aa053c3fd705f32afdff7b2b7e2177ab4a07965d2592822c0659de2114fc562fb43aa33a52b30a4758f8f4e402457d36a74c4bf31c65774a9fed0219a9ed79248f3732f4fa9a3db66e83b7b72335d017bf11fd20fc07963c187f0516eace2a72b23cd346095fb14f03070a72bd255e219af91b913e8795807dedf0fd66b595c06f1db8b105d0cfafafbc8bc41092a39b1443eb5beaa0c14fa5d1791174a92ee9011c02f8e07d0cbfc81f21a1035261ff0f07cd584be2d1a7c56d328efa26984251080581381ac2152d51c9d079c5cc917698f2240d9a95f3a3b1b011eecc5c590b8ff36272e37b62f00939ba01c40b25ed9ab59306d4b0793b337bff212","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
