<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5e9bf2cec467b1323125fd40641ed9e7d1e7beab92b654f47548a3fcc4604cef5565696ee28b1a87fae88d502870f6828a0812e5e2afdafd744d5784f42ba54e070527d8e57eb5d458f690247629b94376f4121d96b1373a3f0710555d4b4052133b303b63746653610537bb52d09d57925b7933773d3498855a0e2c749264dd88552a5f6abf2f198ef780d69669e8ccaa7925f96d7f6f93cb115b38cef06409cb7e93fce56613e8517a6231a27b33c194c5fd00881624d9bae10b3178c990e5d9921435019e8d2dbf407743aa16523559258d5e65e7be0eb940d2c0c9cdaefaa1a3653fb3489ade5379d14994c095a50a0b0b9d09ffb74599513c3cf31703f595f89d5b9089fb8fc32dde453dcdb59b682b77a65c2e9b33a67873694a59db35b69f692d5d30ada429ac93e9bd4229a791b06f9f809bbebe3173fd82e81569de7837d01c69cb0e6dc981b1ee94a86149516afca872a2dadcb49a058067db0f4272f717c7756914ee05dc8b84aa59668b82c44cc019458396d9f3e8c85af8c7d65b72086ca579093ab1a030db4021de0222cfb83309331bbeacdbfe4ce13428a8d28768ee631a9132e1a6408cd9f688bdf56f70d1ef5e923f9deecb24067a22c0ef470f13d58ed89ffd86684713550e27f07941d0c2535e18b92b8212f1c8a0f48bb964fc966bbc32b30dbe3e38e371cd6948ad6b1182aaa6d8e3d1172342909d0e0ede86ed142a9a7ede63faa5697f2b6ddb6c2808433bed0387145f565a1633d45f20425f4170ad4d7c74feeda33289ae0c22c385936b2b9465f42c4a239ee5c1869d8b70a4701a328d6512897f4265316c25b0df8b567b6887ff6aa2478c25eca32f2f89d3a3b6f6be30ac9ce7214ae0f2e6be9acc8c92da4cb9c475002f03485004cca58335a21854577647b4bc458f36a444ea86c29854ceca44e232766ab3befbcbaf7bf78ba4ba769c736775985603063e2a2741fc8ee3b3eb3885b6fb4fefe83308a8af7a36b6beeeae3dc2191fd867c7779d5c7230373389d9be6b2bea1d48813459880489bd96b67e81f0ef55c76d100c00c43cbff61ef161931a4bdc4ecb33a231dcb7d8fbc225a835f3c570b6a981d29b65b70d9b42f9367381002d896c78141d7fe847a12fc91c83dfbe6c89f2a56b50f525c653175e87ecc62e4cf8e6f53bf7a9fe3490ea77778ce28596bee4bf070fb7b27e5218e179b8625b3d1ad9bc8c7d0246355821996626a39d61f0a97e81bdd6fbbbf6c5d3eb197eee9a4862676a1dc47c61204c8ee06e434e61f8afcc30dfbaff2f5c5706d19c663a5f3dd136dffccf35d8e068d9e3c56ec1a727aaaa9b7aa36c2f72750dcc7da430acbcd8f86681d277311c45b16fcae45352d2071af16afadd4f40d561cd8bd92a2320f4d0f2a98b07436e5ec7653f2a608f105f2d07243f2f632609d6c0a22e29885fab80223ad06ac92c57b44cb2ab589f3a6a9a77c7262bdbf346d1c15f14ae485a86c015c079462026d1b2d00b0b38c0f3e621ca59f1b6a803d14dbb0502a9c73d1e64310edc2ce113998090b6fa1cfb769db91cf5a7302e545ddad738be3821e18e14cc60a456fff63bad8e22ceb554c5473254dba1924f86eafcde3784dc17f22196fba4b4d798d17be2101a7492433760689810f7621b9da35529146e770c3c374183d227b21c0a12472aa26570fbd53a2bc31392315ee7beba6da380150d4340656e6efd3d00925c0d716724c3a002e8ed79c2c8eabdb87cb8ee3aea3cff6110fe1b911aa3b6e652ecbd69a143befb9cee6f60f704d9220e89391d64d0104643970a6d2b2a8afb72b50893fc38e2a4c174b355260a3f80d75bd958a26d474f5634dad37eedb66a0a4078a13ee9ced29efba2cd5608dab83f0d497d36672174ec3aa667dbabae94cf1e90916974edae3a725c0f49d58aa97f3374c341e0dacc93ffd6c5d9b76b03676d0972d46183c62510cdc4e47f9ba6a45eccbdc326202e014993d101c611d6a6b6049d5a00c8038dd7eba8a10580b41ae2f76684558bab5752d65ce3e5ccad65313cbb0a669afc8f12c93d84297772d7658205e6e0cf1698151cd6b23956f118234a3cde549eb7d73209cbd6870669a4aca6552974d32a8b6a85b40db875927675a9ae9239dff22a83243745158561a6f57a1a3c378b92151dc49bff8317f5eb13b90cd8e8931980c739ad8a4aa7cada52948da744424b6db25730ff07604075c0993f231a66c910f9179b8115810450ec9221302b5c9c0e5c0972cc79cc75ac1671404f6c6313a0f357fca0e36dffba10e0ae73f6937ac72e529079e7ba5395fa32668e7c3a81cbb93f6fbfa7b6d959bc2d66b4db455aee459baa3715f5e1853824a24c856f8895b0cf9f670ab0d27b2dd0a01ecdbf93187858592de92af12d182cdd7ef9f1ad58a2fa0b9499c0d6c096278f8a49b2027e3a3470f783b1df3e8cb8f1e22efeb566f4a0f623ea8b48e3876a462dcde39245394e5bd0400c87dfc47bf031e507fbe7de5a5b7501b96c90824ef6d8733a4ab17165e1b5744ac33fc9f617a50b352b0cdc5cecb8d0a8385d51dde7762db78dd6f5c6203a8b0ad0eff8a0adc8c7dd08b7ac6fc365b63b2ac0399454a6c705e342f1ede10c4408eddcec0e6f1e553d8474cbde9af51c23655bf6429aa1b57f296ab321be46ba52e012ffc4f247c26d97d0432e422a661f3d4d6dbfab9c98ba5f5fe1a99f02f0a912eeeb073e7f34733c495828ac7f58cd785a862bca34c768e960e3789edad4fcb3e5ae2530d35d3cc541003c12e1e4d93883bde1a877793a65fddefdc77ea7d6ca77db6c6946a4442289f79c108ef1f674666a5e353ee8a80448d01c444e94fae2494bea4f96792c04b18550e6e9de8ed16249c8a8345f810e637b2609e7fb37b754bba8d7479c85dcd9359d238671f3814b2bf79398e90bb37345700b2a895ba6c742ceda764c16ecf57736d545c40be55575056fc03238c3b50cc6286b9d60e29e1b7495dbafa91f0554aa636650824876f5a5ae3de5eae08d51e28b99b84dea840649e4be833cf39f6c4ab3072ce839b81ceb291d6aec3a55fd6eba9519a8d168a14750a3339dc4a4bb58a7a2a32c0f8de34222aa513526ef4cc8a09d6c8448ec21cab00431c2ebc2e6d963fba56827a800a4407741e76150b30a06d9bcc7a83e15ab0f492bac5c18363b15e701ad0742d189ea9f484818838fe78dc07947f5db0e9f2f92a6fb40df1dd5d83db0024d087c0059312681bc95d79b13e601d76b89990cc48c6df23fcdebf2ca56ade186b590d9f95679b06b6432575e9ac91f597bb2fa825c493f4cf8d49c65f030de22bc3b85f8cad674a141c251641a39af86a0b60be6fdebe14fa8be77d4f21b3e7b23d463e23cc85d80590cec1e27150f7dbe173644b3d53a5e13356e425f865831caa39564c5228759d3e457d246ec49178e782f2825d448730c735d1d64c3d1df7b82aa8a5f5cdcd1a14adb4f2f9a55a928fae9280a9f0f8394d588290500735ba1ef2e95ca32f21a7f909c82df21da470fe44dd15e6a1ceb5f58144a9ee6e8732a1dbd8f211591c14715168991c0450011efcb29fa16d06621f9aa0c42f1a00e9a767ed86d4c5dfb4eb8609af87beefc284b9bafbab3af4a80034badfdde1221081e4793d10be242459c77da0355bd4c2e7e8bd110698c3e39f842375a9e51a9071df0c785110065420e2c4de35db72312bc757ab349d6ead6b2b94889caba1788df7251e4c35ab9041a8e60da4cbd1b830f7842088074bd5cd0565eaa7c0d5d9395775407ffb8dd07364b1cda4e6d6373654d66c2292418888572ba2d0531e5476905a965b43f00e03b1353ed83c53d9a75e8cc7a50e8dce94eb8cba39eca32dfcc8dd1b852947a0c621412a29f3aead4cc3de9cb3a2f28392c44e27b3d00388a684d8cd5b3206acca295c7b7993c4a85e9b15b5de5027007c84a08067237957a3785cba35b89f8a0e005bae9da8248951efa3e443e1cb7a59031a511c9cd1d60f6274ff55e33f5de838826d651b6505af8cd0b2b31326f3a42a4cd3c20eae1e6fce7420c4052d490a86cfd062f9632527a1b5893a83094f7520f4dd31be65625bfddb356cd3d3bdbb8c24ae9904b7ea2e33071b8de08d783a8f178c87e4114019b27d945539e5358a92c2b16c58b38853a8c486e10ba60ebfa54d7727e8b54c7089041a22a95c9b09e9634ac8a5b90ce03ac5973253ed41be1988965fbe552980ec40506a6037f9cf47181d26acf5f989bf3d163bdaca9e8923f607f86b65cf0d2aba3958a9629d1dc446b3fb2f111dafb8eee679aa57b29da04f9a618d1f3fc55c809d7df1fb44f59894e342721ae1d2569321cce73c0ec354f70ebf877cb90e53cb6376143da5808bd3d30b3a8f76b08aa69e755268d2763c0366aebe220d5b5582710103023266a86f39ebef39ff24be4f873990cdf1e6c9fdb0d096a684d64a6e577afc222dc2f3e29d79ff37e9ba5032ee19fce48547de02b77b61f1038773d39aaf829e9d38586f053a67684cab7db059f5a7714696d15218b5b05bc9875f4934951975dae0c696bb5ff8621d165a27e30d6c0e71c15f66a644567cf999e28845fcde70eabf81fedfea883eae91c974bb19cac88b347476a130925d816775a7a14d236edc2238ed0543954eec9e5056d1b81ad3abac5a99890bdfe36b9e83be26408a5dccd75ceaaf1f73950efd569159f5ac5c7641b157e2a1799bea0f34ba8e2b6ad5e34ae8b67e63e3c3bc6bc1a9a623a4d2cc575e1c3a4e3fbfac8b28c4013bb0a00ccf4381c4cab040ced67c78710bedd299c719b5827706b8e80867d86d6c478ea8bd57bc8e9354914613f54ea656c698b3db9c527fb624829c03d2d28ebda665dc14556ecbcec2f598ae6ab89676336f6662e1120f8fcb183115029e24c4247614f4d7c3400ac0d56fe25f019113c45c0b6e73bf9a37e6871c13cbb7675af8d37247b52bbb68050b7188b294c94bd7689631d59b30938f09c6f5d3b99c45aad030e9b286870776997602d9fbf7431905766676eaf8247aab2ec63059cde403e3a4f8e405495acde3834284dde21da55fdeff2f7cec9a4d42f3d7afc209426ddec9086dd12474e1e476ea3a98b46a9b4353b261342c1a438209ca7845749bba2c6e23ae7580d6208bf0af3ad6da6b3259013d12c2bbffcf8642147542d32148e281ecfba6edd378237395d8bcdb0ed0d6f93cea53cfb324b7eaa586b1ba46a65ac9028a1c8b22c85d7c983917cbe8003aced557ac0369d514c9ccc78ec0f82c6699f858ef5aff6004c2cbbb7ea10ccb9e6b211d878ff6030518e29e40d01b4b66b9d377730e92b46d6a66736087c9408b8208b3e091f7b4e87d8226480d34004d77c2e9af2aa7b035ef02f61bb7b11962bb270bd6be1a9cf85a8c490589ec6815b36944c8d42467e1864deb8f3aac053bc207d6def5e20365db8a08086c3d4949c39ebb1e7cc4a3130b217e18b1d18777eb5f25a7276d5e97f1e15840b68d41bfb5d808455f5a6d6175b97bcca7cb583c066337dff83adbb071b12998086e16062e9ca4af26aa93e347af4d5074a6b66e2a8d0a86d6d20fd521648a77ba05bd1078a74764671ddc48e3ab73c0a0ea0f371dfb88263a011a17e28bf613f8206e981872f0edc85a4a3bc4f059842a4dbd2c16945ce2662e80a19270efd2d0a45f2b0ede527061b659b8c6d6e8c9b2849f8a5c894231a0d375116ad79d019c5c8817d3b84db96d21542a2d3610454e3da1ead47752aacdf944dc82695c81da77f1e329abca18aa49bb4db9a406e6faade6842e6305c7d79780d31eb779a52f8d5c6c8431b8f2b865931b811663ad03b4b42dc560f77c325d8937b66cc614ed54b2e55904b22a148aa7321d21484f5b01f73e73613feb4bc98d517977dd84daaa8f7709c678d030f36efe22c116dbe6f9bbb9a00b0afacd06651293107674b002910edc3a37211c47446b21fd750f15a967fa092b48d0ccfc5befe116e3063baf1878a0ffb6972f9dc553c365b68c8052c22f0a16e8c36aa8092bda94b397d2902d0dab4c9c93bb0489a93c8f12a64674ac76969287aee59b39948c5bdfd864393ff16232da5b08a498fd7f2c6bcc720846b7c4eb33b6237050112d07a9d72d5e47e94d6a4d6915d92e06b3d4d8030526cd194d30c8f2e752898ceb131e08651b570f5dc156fb0180c0eb2955cf64496de0c3dac634283f02cfafb33b5fd9d2068e628209ee3be93a7a8b7fd66e409dfc79ac32274d0cb4c7828223d6438b5933afd36ebf9cec28b1d7338d744514fcb760d6fe057f3fbbe8ceca0d478f341333c00b02ab385623abff72f7f936f054257c3c5369bc4f7757ac7f53cd176ed3d1ea1500da180d9e6ce4b1c6b7572211b758ac72c53e3000c45096a2272569764adc320f2147c29a838aac6a7eba3cf96793724e38035b15628818febe9865bfde6efb898ef9596664af3d6d1ba5a33f307ca7ec15a3f96dc76925a7bd4e6315f361adcfa9609f199a7d2f1c4bbde84e83dfd6b2c95f4524a3b4a486cc363341560ad2e596563049bd7c7884a880d4465f99755ce254c97988183fb13601d2ea092f0a6e30d70e3978415335b268f551f5918a3b79329d4209a46fd8bf103f32fc65bf36c878c8b737ef87ee4cbacdaf0fc4cbdbf7f185f59e20a1efc55139a2b6562f178b3e358934ed8b6019b5a7f054db48ca702470060176f8dd90642c6867763a7b858f8f76f6fc015fd68a0480f1d7f6a4c219350485cc59cd0d8adc9d602ed9c62f9ad82304d127605a44717dcc11592c36655471d68b89fd1f3367e7f298998ca4c84e49d8e7cd42719183f5340c3869b08fa9e985959bd9451d504d0ec1052e194aa82860eb0af51f097aa3a663b1ae08e5f12f3546b481adcd57e8371b3abfd7ddfba73ef5bb114c445e1e38e79c2f1d25384edf4baff09ad4ec515e5e8e24353f7f7ea55d2e20e00ff488d683be5b7c371525c02c7c12b901600c39732159ae25130ebbeab64dd5c1fb9af6299522e2654a74f32e3576a3052334a7179e6edeb7175dd6dd4aa70cd98d7a703caedaa437dcd13aa6c1d07cc144ab3254b47f3a0e83441959c7ba094f95a7ad7b800c35bbddde7fb75beea3d0c7325992e2c01c4aa3b7ad05e3abf4d48b16e142636eff3516f2a5ceeab51983aa2203b950eac7dc2207dedbb57a992e58d53b156dbe2e82a5b7e16ce374204ea2e8b8372e0be08db3bf3c46df38e2c8bf0425a88006aa35c0c1c52d4409e258fa654dbc5db5b8ef6c1763686bedb22da9ddd18a85d6f3674370a3d7930d5a94f435e64ae6d4f651b905b3fb437bc25e1b92ae208ca54bbad7196ff424da0f16880c59c0375767ad85f8313f03aba97d3aee1654175931e596d202069a94dbf96f9a705035ed344217f64b011dcf143be408ff6907da01e25724232a64981547cfe3ffcbc607f04c7cfc174d6179f53dc850796b0554de5f077d381536900314203dc2097b34b55a3c269b995fe1bd63c13d2e3691cf299082aae3cfdac957d6f26d03e76ddb0197395c08503e4f29efdb82c3c4b4cf9826c0d91e698d663eb0710b0587bf50a7ad2f3ee0cc0084ce0e33c66845980385690565b85932f2b77ab2ae991085244278d2aa5e9dab5ce28092894c52a4c7545b56e0b461f401a0a04a12b86ae3385d792a3ef38369a4ad094a3bf6376ee49c9a975b1fee6672911a15b43c1d15caefa357eb6cc68708e8e37574d26aeb7569db03deb67e0224d0cbfab1597c9a29f93d94720a6b91d849e8f755fcfb1a6fbafeecef5e7410be700601b562e2bf9121599055eb30cd0533635bbe4d277c856df03111acf6ecf5a758a1eb74f4cdf31a5170fa29e0e37b7688eb9262ba931e40ff8c57df0a729f360b12f45dec2c30007de7937fe552000328f2c8abb7986f4093dd92245cdaba181c9a71c6d0de80245aac4423c2998ff7c800d4f150552bad7442cf8b6e782f85be07b10ae636d85386ceb2ccdff5da606ade17ccac427408821778c583f363642c05e2a0631dc33b6eba6047ea954e82bbcbdc9658d0d9dd4901f79ba4782586d8fb84c61edfe347571bf91056054c87ef45d0bf630b8af10b689e4897f17389454ae42becfd5b24c4dc894b993c85f96a1190af3bca91587b4489bbfc5db76842a0784fa83274835ad5ed4d28126b8acbc15fa4b468450f93a50310bbd4a3e4e5ed49fefacce1ceb707a4093b3c424444e8cb4022c28cb9fef378a641b9dccaf8252e5baf7df8e02a73c255390de0186e973324448665e434b7405074576fe22a6e9ba21ab3275a800a813e1b4488965ae211a9162311de1417f4020cff641ed8da31fabfbd76ce70f428c22d956cb2b6344fd60e74ac4e4c2e39991a755912a70eb527365188a70b995fc8ce32502a3219b5a00d2095b26fcb1ed7a90dbce21a0285bbc067f4168ba5e939dd57a260d76057a70f609d7c31c5de25527afadec761f6fc9186155d756a37ecf956d5793a9ce5bfa259301ef9cc4b0397135a6844f3e74279754c3d0aecca123655905a33116d976a102d6f2df22460075e0403e4b123fe9ae61ddd01dda057f5f549d8d4eaf82fd5204b8fcce82b87b3f74cdb7e0977243285dfe4ebddde2b31a89d5ba4370537230c9445392a98c03164095c3974651d45c0a4ce25a55d1c7dff6e0df252007eddebec000437502eebd54994e7e7c31811c52bd04810c2aa4fcc47ec7ea96f3e79a98083987d2adc8d37074f7c724e1510540ad983855dcf6c7ec1db5eafb32ff89e0cfd93555e5500fceb2edb4800c2ecdb0bc70d4d13cd547b6d4364447b3c13d765eb96d9b363ccede005a2ffed03132c1b41ba0ebdef391f42aaea39ae88e5a3bdfef9b03afa869732280a95ad6fecb38dfa068b00a86009a541ad253e2bfeb3fb30010424d5744e39d110e718f7026d60ed014891983f594af3df1e9fa9287a650246d80aaa0f22a5234d9ce6c0efffacd26b07c4e6e61322043bb5394a80e98c78efd74f0ea899641aada375c33f59723e26641e2d399e68a483474b3dba1815503f89cadaea5a55b85972e8691a16723c8cc077472646270e45099567ef2e90f79dad9a7b147a07b88da836f9dd8ddbda226b4b5ab79ffb3764eed8ed2be020ebc03a4eb242df90b9c234142c4d17a1fd4647ab5b9564fc0d0649853908224f689dd1425eb1dad70116d948c3cc32fdceb199cb16730f3a24144ea0334eb9175b8a1e0ba13279a703c2cd5e0f4ee15e7e75c682d5d55eee3eb11c41aeb0336c93929a5dfaea30ba73dff7882c5528eb5b762786306152bfc64d9e8987255678396c39b43effacdfa293e2bf32bbbd744f860b88196241488c7d0cc11bbb8df4b9cf124397829fcf1a86780321a5146bc11991301e0c68a252b931d229dbd387be487aba9735e507258288e8b93559a3b71ace29d79622f95d15aac4869752c82e4e0df49aab60d516f24a16a0fe61fa540a333dd60c7ba689ba2b3b70d6995a3b9fba44082a2b3bc2dd0ab6dc4889f2fe02f547a878c4b681e544fcfa80f249732e1bb7292e606ab35fa16f1bb8bc326f5d57adda4d9100ac4666a2cd124582c149cde6852bd52e4c08ac38b48b57bd1620317bae1491d5a7eb919761e5edf3ef66e106153004dcdc529c8b2d346e81af18846dcb5d80fd8efc1a0c44a3c8e2b02a87da9e0621bbc32ae867323db9486f69c3b48164ecb40e7163cc4d57df843f4dc488be70f107fa6ac84e60248460294a30125e9e612dc4aec672933a4af22c940adf37b5b4b85771b1977f0a237c5b6406933dfb1ff9a061cedbf88b7d8da320a8a562dcae4cfa3eb51905a4e5b06f08d1237a9572ff13549c8f966386ede885ad3907f1c7d46c5cbdfa9c83245f3d004099f221fae30ff141b892f0670f25fc9772c7e631ebb8ab91ce64c033fb5459d7d2a348d79722f587c05d437ad440bd5c5a8d8f07f07f7d2f616e27f9b3eaabde1816e743cd42e855288ba1b4ab8e5dd3feb76f187a3cdcafdac2033edea18b851bf24db7d06bcbbd6310d05d18bf90cea923e4f3f9f5c890a5ea9cdc552558e1a81adc1734455e589354e25a44964e503b3cba5886936938961df895e9d1da68b9da2b8f45a59479b310997f4e9e4339d1a05fec5038e28cb359b316903a36fe7412428dfd29f908a35215695a81238e4862db702764d90212096896f888cddcf4b3ca30c1aeb0c6775cea3d5ad06fc1371f46976ba5e635d43bf048a96caf5e15efa49a296a3532011228c6ffc0d323961d4ed698be3c2b1d53e382dfaf96b07959890f0cee68868e8da15d5f618147ac6625f9aef957b0cb6164776c0b2fe096391e322a9d48d5e8cc2580b941fcfec2db898d71697b6d5e1f34a90b538bf0643b071f79ff4da2ea208eeb0a85529aa15bda8c2f72333413f506049ab3c9b92dd7328773a14c70cca7686d9ca4f0f05021ae1311b53fce576aacc5ad14ee5fcbd875699c6c752c81a5737faff5b4419d3eeeb2fc50f237e290fbabb5dd370b34948676737cd91654053db8a10c399fd764cacca68d86509bdbec37d5b927d2b215b0175c3df3968b31a64412ac1646ff2138fe03e5c6e8460d160d7121730516aeb3160d09ef21bd19da9a7bd098bef585a34f934c776c183637a3337e8576b0a8853c02c403ebf1a3c15e738c03c6066d93918b06dc064db2d7e62543ffd6deff6779b681b827aec4c47c23d2b7ff9d83ac5288307ded60de031c49ba1747fdd99012d51d4a7a67bad37c11caa1bafb4864d7c3f1fdff756233eb341d2313b3b0c8d6f516aea5893c9a2fbb9b722108ad5be0d6442c65835f778cb471d80ebd888b2239d34d5f3f0dedbdd4ba211ed24fa23b94f94847c015b19b30766f09b738282a2db856887b234235ced7a3f3ad2a5d72288ffdf91824099a8ca9a79fdc66034c0137a757617396041be30ddcb58388f1854b4a0a50e77c7f6c6769cb5bb7aae66325c3a84b4fe1e172140c7aa435de182f92d34527f62d143ed47c91b6f909f52728fcb06a11dc0d44030ff0af0be9cc59e5e3d8586d0e9ebeb433950f226d2f2a0bfab532b3de83a0f587a5954c15ae2726da76624b789f13b55bd9527d90978b7e022fe66df17aac68b46c589bb0ea863269a87ff1ef69c3d9cb61720a33895ec167bccad1dc654a0c0fa87d9521f14575012f3e1a7f6be0f24370443321e1625cf4bc3920b7bc12a2449232af210e8991e6c13aea5caae972c97c93b095d1c06bbc8b24fa5ec43ac1e1a42e2b5dbbf492a885110573ba93d316020f305011c09a6fd515d5da6694bc0b1002477229642e60273a2f56226da3632728fc2ef5d3bff1178d58fa9272b4f53d56b3bea1a24ce9942c0e89924dfefa69fd4eff4779bf989617566ed3c84810bf2dccb62ad90b8dd365f71c54bacaaaa09341f3c52fb219edeed3414d0a82ba494cec458002b1e69bac7f22025b5f9d329cf49c1da85bb18857cc7ef58c7561a40f45343e621228ac911eb3ef40b9709290bcfe3d89db2a25169149e1acf13cda2b526e70108693919d8fdca29938e6b2e4dc7c8962b5d7719846a0f136d88847c954aa4c9a18f4f11846aa70940043345d681775ed9b22c7f70e6279fba6980161b8dc4aa77dbe749013ffa4ac0ac8bcd755b2eb4fa90127222add7e4dc2b50815adf45e42929777821e256abe94ee81e9fe5d61442b6b150481af554a88293b3f07fe658aaf289a9705213594c2b0fc5a0a520890adcc9fda4e062851cb0bb202b907d81ad34ad25261815928f91be2638b0e7bd85abddbc2f5f9e9eecbe6931cd72bf613d5a5c8c9ae5856c72ed328b3699b8f600646edfdfe243bbd5de8fc27b35353ca719cb36a64b606f967d59c5fe4c623be6d2b37e3e7fdc4fe7d63c2dfd66ead1fe7ae1aed4d400735c1c7801762a84e8e830e3559074a857b5d57d821c70a17642e33715845f2ccbf22327f7f037191e7bb12aac01a37095f5bfa73dd714df0ff877de877b9e3ca2d6325d9794610c0ddbff6f31addf27fa71a3242b7b5e002fe822d6d73681bdfc713686e28f947539e7afcad416ae5d8b82a06eb4adfc5703e3363ec1c826ed9d6202434f7fa1675537ec6acf772b58a30778b7c2690e4df336936e5de9a72d0dd7ee1965e9d3453283c4660362180928ce3e5c82a9bc22e280da478ec81a382ce683621eec0383391e7f6d28b99907c8172d97810cd5ea5972a3175584a02b1b8b5b4747e33b709e56606ea7db280782cd460f051067006330bf400f866f38208640ec03f4d14108ed87faa7994d7abfad30bf9cfd8b8e305086e38918977e0448d49193d2063b1e688c936931dbced86af16e1ebe1b194b3b04fb5b6d753c937580e9ae143ed0fd46a458b16a02c9e9de34e4348f19de8e7f4d520747b65a3e2a18999e60c8f5cfec3cf57854cef69483792e98b965959b09d56d03128ede45855f48087fb83286359a0eb0e111d6d7df8172416d4bcf9b1bb736786047e0918a2e2db85675766acbc58ced9172055a193dc4c8fda4e83048a7fed072e8417e6030f2dae472618d6b95717a5bc6d22e6dd161f152ad958db6d2d3c89ae4acaf6bbc36bc11069fb82cac43199fd04e372fc47fbfcdd46d766a0f294f9f76a59eb50848ca226167f80e6c8f93dc4c8ce3fe326c1cc6fb3aea4c59653c4d6a4edca22c43e7e9c2ae16a946e2d2a021b3d1ab345b66521363dcdaa39ca11d6c6b602d02806b7811d471fea3c5be01ec6abf2700d3ee3fbd863720302b8d38af2a80a371000b3906b156516d881c8dbbbd6314da8bca05d32cf3d3011be1b4c33a2a7c3557601191bb40a49524404f4aa5d404054a9fe40974e3678bbbaab6e42c6692959ef689764e7b990e73d079462bd7dde52a03bc0e46fc26c4bd4177636b209bb5499e1bd719ed70cf04881e9a2f3de5dfaa0543444d712be576b97a10da1bace11ed192983e05d26588e145dd4b7ed488db3f6f51846b56e4aed785759284e9cee69c8d976e73c35ecabf7778a86779c6b07346473a7d1825c218649a6aabeb004c6c632832ccb9afc1ae8752265e4bc4f17fa76ccf195f31c1144ca1975e0e1a562875dafa7647f725a00de3a932628bdfbdcaf111df3c09f92abc14e9ba748cea51e05ff3ceacaa0f31f4fe922885fd78dc84d61da5e1b361dc01785a4309d9e0503e5c7a677b1c2dc68652c0042b2a5329bdc2905b7efbc5474b31e552e34dbe4c2a86a4e567a367634bb615328142e93a4c27e9c5b506d4e5afba26482906bbce4a49c0a3b49956dee63ad987fd22b3a3b79e2fada4c817cef0f0305dda3e9e686979501edeb83100ec3430eded4506646eca8ee611117b0d44dfb6bad3ef071fae3e73c4120710724b6d1062df628c34011b950e08d29dfb4badc105781477a13595820169ab53857890b9e9d203d1b9036f48731ac86297e77d625065900e71d213dc8f4fdbf934f0a6a5ed16f7ab89cdfb519663b8b79c6ccf2006de10d6ba4573af84186d85dd0b4004b2e3c987149d183f238b777a665823f34a22a8bd711306ced8c9fce62c73b9c8e53c47a6494c766049f9aad00b9ceab5981f930a3d45a39b8809ed54de9ff38a26ed5312d38de4d5f1695773fcc9eef1546c03ee53b5108859c9af01f2f9e0887e6de6119aad4c83271a9095e3a8603b71f027d6b5730818296bfa06844acd36a70687bd465a570dbfcb33067c844375a91dc251fb0ddcc48f60f4bcc4f7ff48e690164bc6a1e1fbcdc73d546e3a9026a12a1100aaaf56b060bd543e859edaf2cd5bccae96ee36326cd99dcb9ca5f51198c2e3b589b7f873802b39f04f17ef6abd8cda7bd8ab9721af3972f85e8d692eacb883d62cff733d6c35bfd014e90032a61b143e90f9ff05b5cac95a67426272edb96f2e0ef367de667522d77f6b1a46edb1093655e081a879e19cfa98f4f8f8dcfbab895c45f124dfc0fe4531264316ca6f3885cf8eaa55bad9d6b28f6cca493cdedb77c8d3d98a92573b45e879873f537f5049769d5558ce2e45ec7c377e0e6ed9abbee3fe9a7e2d06cad5cdde831c7bb9c01861fde55ed959709c953b7b2ec4901e667fe4c3e3c09b37e72d1d8998efa5a7ce78dfca0fe1112ad7da24b98d25b1d90b8f56e928c11dc26b6f5a2778fdee8e3bbdc35fcd4778125a1a92e594affe5dd8ad9576e51f7ae96a3fee02f3498451322a23546224b84271f51cdd38f734a71bec978bec0f6f0b9d17e054c8817069c48d9ee015fcc31474f9eee1ac35efb7f0c4ab8fed3a6904e7a93ea5a0edff5250a6e7e4824ab60c38f2b4303505ca653db74658df787f36a7bbd067f1b72ebe2b812d950d10a35681488bb56965522041a26fd82df31bccfde0980aab1e75b875190ee68ad1921d31914b61bd733031cc0b72081820c723a249dd30df007f52c10f81000c0b4f3502b53169852296acdbdf12f55ea927d8759d8990b2bba4a44303a9ebdda5b7e19c2aeed6c3c5a72f794364dc808e0220861c0febd7f14583a305167b02232074e863d623e3df3c09e14eddc4566c6d21d145bdc0cb4d20feffd21434e054c561420386166457caf463ff8a181654a3138e295f83d81f76f65b454cdbbacc1b94759e3e31b9045bfa64325449a60c120010c2ec07559416aec4a63b765ebebdac35e7de2d54edb00d7845d0398241ece32c9240ac20922f81859e36c98be2da492c1ef57bf4de11addf52ef3e7f94e874c11778a5fb2feebcb07af8105305623ad754bc0472418bc7e35a3165f31319c9736a4794d3589d70a970247a4bd79cfc09d6dd76815bb0c2acfa38f531181e4ea9fd92d1d0e895b08b42c3d71507498e2a00b927206bce4e18b06f8d9a177d02280bd8475e74c950ccf56ddc5f176d537882564b1fe6cc8cb48f152602d863f1c11c52b43c2571413b8a371892600ef66b54656e668eb39cd1c3916832efcec5402ef16d403a7da1460aee23b9de140f02d3958fbaac157712deb64b0ee94f87da96019a4b46ae55de3538a88bf1ecb26a6d789f8f259cf7c0bfdde52401d4d7faa7c6153d8070f6276259debbfea749a360cfd05811755564ebdf828f4e614325e22389359e09556d2cf40a98a5555bc708e67332e4f4e3ae220970f1f66ecd709c3e58979345ab080a6146447710a30fb7f320f13ceea3f5e7af2f195300cd104d8027a84e47ba265decdc94662806350cab7c603a16569adc79abf7ff924f61aabbf0800649d47217a80d638e657da069563344ec6d3d80e5e624934778d74d06121d84ccc0f57b5cef63cebd5c0edbaa34d11e347ea517b65c7da5568726554a8e7c8415753cfbf970dec43f4b0b9d515c42e9a65e4847d23f2b155c855c9fb168c85ce71013bc5d7e6a4835118b39204a6688d3ec7579ee1cd2b2c79c876e8332454ff6fd1144c8ed445cf8c8b28761dc9d539bfa090b519df90b5ea79aceeaa6986715455ea227ae2526da27197b8336311e428618960a2a4ecf3429c149e984926638dddcc378eac3706ab904b83ee68f7487be2d21108684dff2c79f4aeb5cd80c2cfe0df627a984664aae8c184678de23c0011f5621dc8e4522e93c926cc6323e8838ee1d2f9398260144d7f558bb467e4443050a53bda5b6478bf3b710989459dc9dbaa5b244937bb2c9c61f8b6b9e4ccf5260f28af5da6c8465b402d0a418200942eb4185835547230fc4eaea60a80cf08b7c365cac055f0fe2866cb0df673d1622cdd2a75536de702b6dc06a0fa89c7c7ce79d0dbfceb001b7d0c04fe2f44001d913b1ea8c9d876ad250e41146908aa20d251a3d4b8eeb5150a701b6fdfcb1aee87219d5aef06804b6d54ab8782f7e7bf54baada327f2235ad11e5d95f5af6cf58821f2680a73eec9a0a5331980cca3fd897552f838020a7e3debc755ac11e6dafe45738ceefba3c08a37f6f8b41617919ae39919065e35738cad1ca96d4167fe42c69bd519d0690c68f95a95cab953294b6ea93303ad92df35244aa645fcb07c8199acf852f1d490f3c291eff8f5f13e836947cd59c1ba5d1890610f5df8cdc704abcc39cac6ef3b1ea2d34ae13135e52a5632e234dcb213f055ab2c4c68016d2ece76c559a65cd99b50ae7f544b306bb23b327731181544e6187b30339ece141f251a83181d67bdbad1f5123fd48c2a00fd7f741bad09201f5b40986c86a7b89c2f380e7ff354fee3d895a19fa5c75a65cb0a6e538581a3853edab8fb62273d940f456efbeb491196c8a74408a9b04bc22bee95af761efd3a64c94f117040dbaa0549df6944aeafc5b3fb0899d8a33f07ae125a24166271a9ebec72ad6a1b9f6c870c283ee952aa8d60ddbaabba9898b2ac1ba164f5b33051287f6c6beb5fa66e24e73dc91354038aa94d30b00724b94e8f40ef8b97095a00dbe56a1befe8c401c8ce592225d6b81896c7713ce84eb0ab38cc8ffd4453e4bcd1cddfdf767cb9da17310405c29a00a6343530b13a88a1b91a0315eb1cd59648da76ebe4c885ad68896ee76be8ece10f4a2c60db1c20b64438455567cea8afd652d4eb3dc1d7d82b17b4708f3e9cf9df466ff17df48f5997e9c344ba57cdf08f6544886695523f020443635833692bf4de42091d6fe7e4bb0a162abcb0cf03c984dd29131036500474e44d06722f4289d6e76a977d2a8b1e84aeb4cde1db37e352f268a8da098b1dd70f3d830cbedcd794258f990a519872cb003407bf5bc03e677b19630eed14e5206077669a2795c6ca425b78e1db0598bd1590ba9e0995cffda8ebb8cd3557dd237bd8841632b223aec617a709a7835ae02c4f98c57b18c9420acb4098737fa14e67df848eddafcfabd5a647683040e24b5a1a6b78f162cb9d5ad832056370c53ac65e1381780db03b7d43cc1763543a230f3297cbe93fde02d7196b827a8e7f3706240014b0cd6fd40b6d605fbba9e9746fb7b95993cc03a501d7c67488ee964680b1406fdc3274b540f918145f96c8a6818a1f667a549924e63c3a9897207d74409e2b26755629f82813edd864bdf6afa189fdee25e4d700ee767fe761b69b70280680561a23a63c9cbce1a93c9e6c8ab6ae32bbb3a90e741344d4aed9cd8ead877fb2c5551cd934557854c2310251e407b3cb37be08d5291057782d61e6a6033c517480fbfd7fea2aef01cb00357ba7c01a6bfef06271ebdd12a566761f232592f3e57b2ec0e70dd4e5faf090e3900effecf6b2e825a0bb136f63048c10d1f594b34fe77596fb1cf0437c48c711f785f2b80edac28c838303eb81323824429fbe08318d71c7da4ff5b313a7e4b6de2e2d9929d6e8fe9a486b2eb3493e11e86d41f37bbe05144e0de412de66f7081ed5036baf95ca9f6adcac68ea3d6e986e53bacbb5cabed139e7dca845c4bd65e1366eac9d00efe3806acc94b377ec0d5f4d8a00c8795191cbab0323f4fad1609d787f3cc879e635fe0fa460d0404216fd9f248d05f6bb1303fb1fbeab88adba7a6f2b614da9e21fc9f468b191d6cef9cbed7cd4604b673f98094d2282955c8d7e0c914236a9e60a9229437ea047d19c40fdb789d5bf5fffcd958fdf7eebe9d0873c7421abffb417b94aed7d65944470b708d3e0a7c0559338687ea53837170713e4b46d8e7cf57cfd8d656063f03e6daca8d07ca4a427b6242e7784d8c5edf108fbbba0acafc62f0e06f98198487a766e743e87a06c940c915fe6ca958d23d8f4060c9fbf7e303711759c965479e02a8baf1f89eaebf04ac981e7939032b7b65971f4cf51a5e55e9849ed92ec05533f609dafa25200de4b3402e3d0e65f054a3f4fdd99046cfa88206d17d97e6fe643b1c405b8a1aa59a0fad90c1da25ffe9c86e942485235a08a4421cfffc665a3da3c55d1a4bae90fa3513fb0a0d19c4c76a98b2e92cd30ac8499344361a6f24fbb638f1aca215443edc1e94eb874e5958de00df6519634cf1b9f59ef8dc1b6bdba98b73e91a0c42a8401084a13d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
