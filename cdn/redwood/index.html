<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46767e39b272d62c4ddb93d16675b4e49bb529a71858f7b5512cc350f99ffa50e21be5711d3e624acc6a2ab1528e15b57e193aefd51eab0ab633691c3923f97d33ed7447319520a567e2f8acf85f85e561dcad42a45995a416615349a85f623599cda6a069f3378fd3ac666b28036887d0f6635eeaeb316cbf032ca98322da2989285e84249bb3692f2a475da2760a6552f87b818635bc94fcc3e92c19f14e31b964a62b60c321a7be32bcc79fcd4d9216c81d3f346afb4ae0bd63849a443a7d3f863f28882e32502b2de192b2a58ee9ce070377bf3d868c47f6e16dbe7a866a6d2c50f75e1ce2485c33a6c4f53778d1408d3c80e24de1e23c5ad157e35cea632cea85282f8591f80d5e9a24473849a9debb2c5b926f424563dea0ecf8fe66b26c18d3ee932bc219667b369d223518be27ee5e12d12389077a52c3ae3fcebb8cc3ce19ea622186ab91ae1e47605057fa3d774db31aa27b80f052b8c39decf8410c4b794273d6a947a6e6a69654edd6fcabfffeb45a82e4c3dff3a08c77f876e095a053a26fe323d5e9e5179ef01f4f7db0afd3a147bd74ecc012459b604196fafe97998384132c1efb518fd98d2b89bf78a8eeee1db0309d3f34d660202ad7477745f87f44c520523ea11c9b3dbf297a38898da79b2d398920458635fe8dbf9e2b4a2cc4351f6292a1abfd21bec67ea9caf6bae3cf82052e72ce257e330ffc58f737419d48480f169947b290a1fe7f0b0af1babc81a7585aa11fe7e9e5c09fa21ed8b51eb98b54a56dca1373cb18e685feb56e5e5594be2b7f30376206029efd379969b1c0c04e06c818ca51c67845c9a95b32c09314ff1a0d1821a2650da22fc0211f4ace4640485b2adccfaf0b03904947d31bd5e031adcf1da56053a7644af937e8e1690b21142e6b9ea0e0922dbbbb9e67ca02c1a274f11b853487625a6d3cd83341c807ad7bef96b589d2cf1b20dcf577a53943b94ea849a56757d4a44aa5ff2aa46b80e12f6b7ac0343d527802a575e966ccb4cf22e5fb6a56a1d8b38047bfd454816413931be655d28b07e6ad77f69ed5e544358bf037f867f2fdaf605a9814a392fb4e5c21b26ab32bf2f54d5083bbbdc17d5a26dde2c1f439fd85cf8a395a35376db1df330c5addc98f6c9a0cf2cccc205a00887aea7133d82df73754e3820932e1429c6818522be7012a2c40caab265d2ce48f1d5b61fe683a0ba45cd655122d32157b0a75fd984164e9b61dc401f3342909a21831da450c55d831a0cbece825bbec93250411f66758b9489a4e1a537dcc8678023ea28f473398f5877b6ec8168faf9cd010c43aecc9d53085e946338d9a3ce71d5e2720ab8edd5549e73b90c19e7f834291e3dc8d003d480b9ea08b2aba8b7835f867da73ba1335b302563908ab5839c241ef3369d24321c8dbc62302865decaae0a739ef68aad314441bedcf69be07d47631492304939ea1a65983dbd5ac0e06fe647f956db3cd18ce606d162cb70bfa2b9e1fed78df7de4e59e756afa0cebcd6652a352c42f646d866343ea7bab5a07fb74f883edd466f19febd39623069e0b711249c5e95743b5799230bbba6af15e5582b4336ddd043a2425f1cb8c988a0566acde19db5035673fc03c4eb9006eef45ac0da2025a2687e451e0790336a19c71f9fd5f80e36081b847132dc6a13ead01b47a1bc2f22042babc37e417ff812f59ecbd01aca159aa0cafdb6a80f7c27d497d9bdf58e486c25c25984bdc746de37392fedcfd2acd02830bc4dfbc2e3a67170df0f7c3854d871683063030d8a5d30ddf93fabf0c050960b20d991d76300bafef9c44d75d59c0fe48196c04d23a052bf2550766e3d3a9e0836172fc8f08458e475fa4662d31a81c4fb77a9830e9167c7d6301d4abe6716a43ddf2266f561eaac779a29ea2ad9c7edd81ce9ba2353cc9f6b7b366e3fc36a5592f5abee677a3affb57da9ffc2d7c703c521b1f04a6c44c127aeccaaaf3f13baa20b73979d3775c5563fe86de46e812221dddbe59a301a906b8a8b69ac593f9e00d4c6c46b8325a223bf3a7d010ff5116c34351382da5634795f71979943cf9f824d79ff693c06b1f1f8c05666b9a1e892371b8040c8ec07f870c7d979df5fecca300f693e4f6a0b5142eb2dc7b74056fd2d02d009e008380d82d20c9ecb57e2289e60c0fa856035ac08e3948d5d0e118e6dc0ace849e6433512d6bc6ad1a6422b21214b0cee5cd0440b4b49e637e6a5c6456a0e708c3c17921f9ec1b56ca83b062eb2325dbce086cff7f70a2d01f93c715ccbaddc232282b6e38919375160dba8a0a7716593e38158d68cef73ad04de3d42ed439cb3d3923137f30cd10693fb2be4d044d35e693e257abbe88f0c38828aa222d67039af535a4ceb902582db5721ef40077b21a6f57851b665e0641a7d99b6a4b2e0bce598280d754d09c2b2e28adea89d265be857c3f25b52a94f98decb0f5549738afa2ec1528b630ababb541438428351341448483ab15710cf63a4daec63abee3aeac00633a6f882b00034d6d20031d32a1150a45a96874407d856f137b42a169d0e3bec2be0e21577e1ac79fdbe3f350fabf7ca52aeec79cc093269555c0c2a0311e6aa0a3957c5b0ad089ed778c7b875459ace4812977fc3e8a01cacd4f139415bb03705733ecd37287cd1650b38d6bc1d04bd178ad446ee44c95fe2ecadb06bd3c4603b4b30e738375479f9ae5199e9a9152328e1e9a4a39f635f4986e730f85ce56fd016de3bbdd85bf8c5e1807e2b45b36cb3b63965dfb7f7fc045ea14135505c379958629131886d2f12c5b2af091fa494255a7496f0a65af6e31f4a508b3b607ad926e55a277a3590b4bef1a6f8f055ec740abe8037a5f6f4dcda580870419be95e1da043069e5111ffebe685be1d6ce9b608a4438d405aff7b550741eea1ab641d683c736aeb95b4c13855e142fd5bcf3e7472f36907ca23043604635721107a4c56253970411ea436627b2cac8e3c340c3ab4c89c2bc7dec3b9ff5e9a1d6933119801911863a61f3db2954144383f7844fab537c30a554327c1d430df767ad6b590c15d628e2e7cdea7ce603f4cfbb4903d82b104b231390c65945fbf80b67f82b3a7f3ff3aff054dc4d50748fc71ff19501955a61987161361fc4abe7ecf9e0f98bf431bfbf10f6c506d5838bcb36cbf5222f3018cf911fc50a2c2c4201e28448dc8eba8b2ff814f1148296648e8aa65c3422c04b890cf29517b9b5a318aca82711a33340469f15208fe3e8da716e0345bde8bc36fa96aadcbf5b564bc34772fd63d051862567d1cf99d621088f7d1f81404efafe0574c646baef78988b5709d001fee060717d75927eb940f36e3ef934ba7c1934f6a42411a3dc0d883d2afc12299149aae47dbe630b34e475082630cda02ef76f6e05797964b51cda489d96b67e6864fd8d565d898b2eb98cf9f7f9a37db674ff44672586056418d19158055691034099feafda7704911ee6d0e085baadf8f0d240a8666c0459f6e63169a623da8fce470a95ddd5ec70cf3330fbbfcc2e34ba7aeefc40f692656cecdae8b9e2832b411288e7d0ddd14dc888d34819525d2b18e957c4102ad28f13ce8c34cd905a02585f399c62dd8f2c0d196321f417457d453934db50ce6be48b0e97a4cd292fcbdd5644559553d2d3ada5c425145006af4f9f54dee44fe370afdd932f310ed10d2ee8026427900eff5e7a501b44b1c75397ccd99737047ce127c797f0fe21a700f77416c49ab43e730a8c84165c4de85e64fc68c6c0d99e126f11792a3690d6ee211ee74097613df86edba78cb2bf95fc2b880fffc6d471c153e4917adeb149efd60271d91ad2d0d01b64b2d0bf5b8a543ce0ed131bbc3a0d2025e38b358a82ff72e17709c5aef4c5831ac51339a00d8fc1ca3f06da373ade2165adfa4d71e0a2fd0ea2b1bf61817e1e587de3424c16cb86b55bcd82f4c08f00efc8a695e3019366083afbbb0732653b7a14fa995b3c94897cb1bae86eeadba4c5967187a25453f14687ba9cec9518e395c31564acb1157f3c83b2175930d471e34efefa24f2bb07187922bb35b30b65b14e8b7173b024ceca3bda356c23eec78aa5032c49caf88a8d4f49a141feda40d0e6ebced065460d55a4e6c65e8ac5925017966473b07941bfc7ebf6d6f7c274546921b018854920857bf1cea1c2702d189f8f0e97ec38d65ef5316b8181cb468b3c7c1077a444a8b2d7569f970b95b7200ed9c08da8699a81f98ed20f14ce2fa56bc3c2bfa52d542a83ab32502528ff032c43aa45f6cf8df754ba82c0e65b59ca0e82e780bcdb6b5080963f221f51c39203d32520ce15dd64929543c8a1949bb814985ae1a8076392b938e1116e4c85c579745fb2d8723f41cda4d37c1c666ce859be24f3cfb2992eb94df9c68187d3f923ef7b31bfcc9e10bcfff5f39eb9f3dba1cd444e9f9b74e3b1fc57ea8929c2ba6e2c46a57cb39427ba824fd805241fa3e32dac37efebce02730221999e451268d11339ee2dfaee081168d5468d6761e94ecf6b2a093a90b8641a19ccf8731413a1805a19df7358bf1fe3e58d176bc5e4964d090cc38bfb9736c1bfc80d94671df07c55271ef5ef285709f376176e24259364629f60520cb4281628930cb0675b668c479a9085b6eb59bafca310c1dcfb2da26e9763a47d430199abea920448643574a9a895891056a1c1b51b090c84bd4f03a11d66ee2c84383aeec8aed19d8294b70deb192eed494fa75adc13b6c70539808647339f73bc0181f01fa3000c0138ddecb736831e585e0ec35f0c9388a5084c827e5bab274f222aeb269744c5f4e9eaa6728edc22ed5e503eed1b5636efde8e32040ec307001ecd96a7f9894c4ad451ac7da2802c4d22f191d38bf8ea14f19214edc193a153e29b9a4f6c4f09c308d1b37b5c2b7ee62bec66291351f1c8c79f316b3ad8f46c0aadcad62020c2ffac2193a65a3ee72adfc0a49cae38ff2e69202c1b0ff0a48267b75ac2888221606142874a9aacdca7babedeff2a8db7db5a81707870c3fc9f541247dd6d7dda3471c27b3d0921a1a4063b4b0ca403c2236171fc6e672c69e8fff028213af0574d0461fbec6e3107729d0fed2e6fa1ea86ae5b0b09bb05cf7ae45886dd9c7cac05fce51dc8eed3c5ff565cd70fa4b045be585839f5bb1f4b938b5eb3662e1b5d0a7d9cb72d396f898b9d65937d02aa033ce652827df863318e923adaa7d885a90e96292a8f474a1dcf2ccccebd358bf8bbc40b86fd2568ee2ba5aa4a9e6d6c1207b944955768b45a86715bb0ea0a53228d96cbf1ffa21207ae9308bb74019fb803818671fd2ca72634ba664dfa1e66b66e50bc446d351d37d3a385e011b1ae3d0bd6991942258c34c98b445bff156564b2816988c0d231aa3f5c97f6b7f16b5bda204e5f3f045c7c8d18448eb95ea0f88cccf55469beded4f33024f31a6fbddf9cae7365ae0b22000f1249dd71ab685f8917c862800f87ab312136d66995c0d9bdf2e50fa219b969b9d17e0e7511912893544b85134d3aa9286e3aac2473ff2790fc8fa724c593175833eeb9d38f2793de1e6fcdb5a21b8d8262ca3f85f2e97c65fcb99363889e3686a19d831ea15948eafb255d263700ec40a37af57cfdaf474cc62bcd94277181949628a477d20021155ba5023e39ea7b6e051b97ad7812ae8c4de4832419b4887b35954b29868137b8bce57a81d28273be0800bcf988b7813f5e0b99cf33bee4698ca43a6498949db8c998737a62d98b1f955a8065e6650d815c552f2e50e630932eb3c775cdc72f9807217fa5b0437f910f8715437ad1a50de2529d9e7176c22b31dbca01124cbb9babeeb0e8df6120fa3da2be761f287414c7b68f9f5c95b7c5882e42921ca72fcab1f08e4bd1fbefac43d86915606f72d16db11b01e1b1f32528a35e1396b25b4a22c7206df6afb04c8767aac20209f086832f6ec2cc3c29576db4c7e12371b5b0b4870d13e89f4dd45d866f3d133ecd3359ddfd53ceee6730e42ef7c2c1be2a414924baeb650197b09cbc38f29563c5dd300309a6f1e28ecb7071e17333b9f3900790ab21ae138b1b6f44b84466fbccb74e3b22e8ffbbaeecbb235d0dfce88e9d1030316bdd311e41b45f078f7cceed4ad300c9fc366b0cfbd771819bcf76a9a33dc0f45b281e78a80761b5796bf894f603175b9d2d39fbe6854fc524e66048a77d2693953e0a7b5c506084e7626001e8de4255143e9e7427cdaa1d600726b07f381385bdc0eafe8450a58ef2c76d9f5777bb5c4819ceb3dfe0b41c747cbfe8850ee3ddcb3a1e2fd0268b669ce36a6d38f83356009be0ed55d0f60cca47bc006af91df13ecc2f70361b792b68b42b9c684a537a513cd25e84364cb107939ee7f7e7708017bff555373e9915099e905ec3c243c4fdb58c3ec07e35d38e52914eeb8d9020c9b497af73824d4811ba07a4efaed30700623db3a1cb7958f0a6ff11357351580fc8e8f2227f79643b5fb72ab2797e2eaeb64bf64612e28b1033ba253e4d5b3a0fdf7402bb9d53979a754de4dfbba768dc1cf58c989ec0ef493c886c78dbcec14a72f203797b9782b7b4a4ae88db9abaf16396ea33e3f6240b30aa7472f847f8a2b10ba600dad9d28e4d7ebc79020920c83d0360658e015130b8a5ecc613995a197e935e252eaa97cc5b2dd05b0df0c02c8acbae92df5318d11ac4a6443ab5979a61bc57c686bb7f7c4f7cf994a8b468b5314ef711ede05b3c7881c5db3b0745a314fc7815e5ecd712d39ccdc5b435e97fdbecc1024dc3732e01e122ce32c89a356f3a9c10451a189383930992ebd035dfc68fd87f70e66145550f925a07d3b16ae5733e3fe116183bd529eb52c958aa8088c6cf91bed73239c74b9ca145b7cbc185f944717a78f78e665ce01a0718e695d51f08d069523fc62b5d21331e02afd27fc02d1f14566099e1a8f2d78ec0522ab0ed2d7f39d09cf9f5d10acb0f980276bf47fb87c9d7300a75a7b99408525a62b431b331be54546e8e68719119cab28f5bdedf6fc302cba531202f0f20d7bdfd420f0dca3928a08107e0977389e681eb4e45af8486acdb4e0928591589902317765ab39756d8ff335972e68fccd23de760d15337a7af0a1af0463f6b6354293ed5b303542e4c1f1db216da9693cfb11b8ed47acd85a26cfe3456a760e72b02098ddbd977fbbc2c53152f88e63e9f370000bd4068ff6e1b265379013a0ad424b7c41f6181e766dd8cab100368011a1ddd5c243466f5402987f8c1bbcb52d5526eeda027265927d1ad1d467addf1af4deb38810270ebbad4eb24439d5dd4d0f7545f1c836a018d07654f60b3fc91f3f39215559ef5715d7eab383ad1c0bb5dafdb910c1e8cace9314a360a82a7967679b0f40306c1478ce3cef1cf99cfd46b9e606e16c06ad3948f010967a827c2666d9cbe2f1fad48b6e3fffe1de9a37b97b29912ccc90d7a89e487cdf158266a96f6c19f948f5d3abfb89467c804bbb911945658acb0214b75aa8f22adf7637406aebccaa520543a665b301e05936d3cbe16652ffc1a27e5ec14c57b1391f62147435cbafdf542e6f329260302dffce4f24c8e4b5bd932972dd69cf8554f6de5078881483eb342397be600ac607d469ce5167aa6f1ecbd1617921dfb04813284e6af1e9985d4bb6390cf00923afa530d7419d61cb836beadafe65ca6e9b61c04b9f0782562c6b6614ac010645525610b2a45c1a7712023e9555fc62dae196833e50c93a958117df0daa9a479cfe94818b316ca1c0e4804ec687a74c76b57fae86cc25a805ac6e04a50491687c999eaf98fe1970f5bf303df0f1878e981413a907bc725aafaa3e161109b71f1a48ecab8583d05806679337a1da754cf920964e8f9a8964270bebf0ed4c0a448866489b0fc47f77c5e5411525aae126bd76965a3d14b536a3809f6ab32d7110a961b0322b69b9ca48aa795792163b9616e5f66e1c40d1f697666312bc9d1beb220aa425d50fbe8983a16cdb912c8e745429b27c0d60df662d731b609a36078cb3a69aae9f3f20e41d78d98bb47ccfe8f73e73ffda856a5ecb4bf887ac6df499fa445f0bd044f7a177de7fc54fdb8885d04d1579ab46538037db363ae51ed444dfdff9e9ebaa64ed56b60cf53407039aec9c3f4830280a360943685143462105d77c7fa1ebce2201d7244a6990b243a3b04cfb8a95fdd45e495a24d013c6d71539c9ecfa52cb6ecc93d27168b0d0c1d82b6c1a52c91ffc0d7f8e5de43684c20d6b43275880f0a53db538ac36ddd093a27288103720f093aac65c7e0b7c41cd4453a03e051eca72f0ebf2f63cea98cacf7c92dfc04f3047552ca7ced8772870e30135533762b099a70c2f277cbb6f5ea26bc9cbb6f725ee24d32cc4ad26aadc4b42ba0ac25e9bac2cbb6774965416bfd3e0090f817c640bb09e79e02fcf77c28c32da219970b327f88318f362ce5b664740e913a462ea4f3fd9188d203b4a452a78e12502227c38bbcadaf3ee7cce32987f66208c11297c268167a7b1792dd91643428184ee3b8553904595cea4f889d0c6b6e3f96c01a3ee044436f80812f417f35d39deac8dc2e48172cd953451268a4bcb8de7dacb41ba6173fbc6bb82bb93a14fc296f28e3cb3058b2e500cc7f1d0e04baa7019d78a1cc93b9b7f42ffd3c6338d98b45ac2b6103cf35480c5fee19baa8285432ddcc52050c490350fa1b4c0e826099761dea92368f174785746ec056e01e079d8b7328d65c9df952c4b2e49e8571cc2fb69a950e91f5696d2618fd5e7a717f48aa91ff20f4e74e6b4fb49d7b27537420664b16238c68e668cb2b281bff31d2195c6a44694d76ed0dd1dcd1dca4ac83efa714979826481e679b60e2cef0bc621e94e2949e08ea8a85251b941e54b02d2446d102f39c7dfe26eadda0b04a4de7c792cbf780215249f1aaa1e60ffeb8f18adc823e9109a76e049c049034f0d9bcf645c9b2a10781a94c8a1b9490617ca2dee3fd1e9dba39c08d3be81a77403d55c6229bc44923b8bfcbcdfb59d5c45747c4e78af7ffcb7735096745facdaef8c765438d433e6dd8bf03f1a3f16c708a92ab836db32ee87deb2c17d65ae4f506d7a5dbd6ee8a50ea9995943441a961a65e4a2683f662b09d2b2a2c9d3621b3903e3469f5a94bd6de72d943d8f732e356de5062891b48c35c77aa4e468b518b0e653b4eac9ea2ea7edd1c77886cc777b9a5a2c8d518609c3d24e58a8782cf06ee04044f8d2d34154b1c22b89240a52e50bfab9be3f8ca1fcd1ccdd2f1041250f60ce3042247706cd467043401e3f960631524224694321649c6ab0b12d588add26297e70aacb6bfeb54229129ba2daff7beb7a00397ee416b7b50744836a065da1bc6703553b3e0bf8b2d251735bc204bcb36fa7b08df8e91e9396f0007c53bda9b538a82d99f834e8318e0d964a2f9064e6f1c5a7a4f5fc243906bf30f279ace86a747caf2e6b45a36559608a41cff841b93bfadb52c78df4a85aa4b6ae30facb547a2c3e8fd8ca80cd2abc5dfa657f88070bfc4df3ffbb7b5a0088b8c0fc860073900f61beb249970027515c0187b32e7c893d2372894b91a5e1e6936945d8745a5c0fc4ecb197dd14260d06394eae83152f1c7dd39f68577055d8f758ed4f27a57d08d30ea7f1c8c9e3dc84c2858cac4a90826cad9ab07581befecff94ac5a4a853aa1fc5e6c92c93e223cbf8893ade2b900982cb532f0ccf131a4e680026b80f16b37503aba4a8fb33c44326ce152451828b6b8f9cdc7e5f17baaed1035c6649506e65165ed5f5d512d591340b330235103d7aca11f3dd554f6902e15305de39958d303b9f0e0b206406f13bb5e33dd0cfc08e53adc41e70dfef6f52f10991b30edc29d28ad0b9f5028176fe306581d4ec282e153c2aee48b46277ac29cf20bc31cf0dce2703d766e7c8b3295902d01279e8a04ddaea866dd4e57a0e243951e582a5d7157cb71d62fbafbf3bdd21ce9d76b05bc52a94a4dda4f0098b31c96d250de4973a2c96f137368499bd67688e358190d12da3a89230bdb8b2e10543f125ed75ba60cdceced7ebd88018017feaea8d4698aa610063b584a82eb60bdd98e5264f2a07d8ebab3d6ae593586293ab80472c62a991c81e5aa7d0637c8fe7b475dda431fe0e8317990db6df3843992326b44d729e43e399fae99fde0b36fbe9512b48df2375aa00394a58b0a0cfae3ec427ae2d17e09cabf13bc5cc6a7ed74dab2559111f0c35272b733eac286ed48ff925a4c1ef2c2f6670291acca54fded227eec4fbd13eb68dd4d79270183d49f533f4a9ab539a1c042dec14063ba8eff1a50b41b152df60ca54f193ef7168a20edaebba74f310b980a767a4d7226b48ff4cdc74f17dbd9bf3ae6fee98b812713984986c6f9663d071132bb87b59b1ad82b5e576d3f0c9c3c18c560a9ade1035110c9a1e3cfb34670c6597861f53c60a1bd9876f5d4781de95fd47c5ffc3f7050f63a26f594a070f03da77a8b676da33aae0947298f71c313b622cc6ce2ec22434eaa9a23222dfe1e29fd8bf5d997804a760d6934c7f21b8515b62b48e9af016dc4831f4031c6463b6e9e5565a889a3e90637944d23ac64354533407ab422470f4b7343117ef25cc30237eef23fb9bc5453617f0177fbce441342b3f20491b83f499c23deffb8fec91289db13fbaecf86d3c4f3f0d7b07d511825ba01eadc4c82a85b95deba27273e4fe00f280b21f99748a91ac1b41085c3200cd68469b97d3cc29b184b7756c229b2d2edb157c51006347a52c9f5b72fb2c9a09a7557adebaa4f3e6a60021b12ec4cb15e9fd790ed137f00bcced6ac2e0ee80496126c3a80f98d3eaa54bf89ffc0deae1fba0e63f9f63be1dd9ce89d79c2ae217f895ed61f965ba329d524795898e8e33dddae3778fef0577c472965b532c6e8ebbae7f477ea7f6bfc9e0cdb144e798009cd1ca38e70da4fc7fa045a01796ce314b4627eaae2a6193223516a49c99b18e45a2a89ee13b6a39fb19ea70b6f15c7212ed75135829dc6015fe3db53f9cf51a01c5b92858975fa9c9297537bbec273abbfcd14b669f201881d3e0fbcd4ac8fa8fb0c0b177c1d0ae4d4b7bd49c98c7416b0eaaeb11dfbaeff6a991f5168e71aad1205d048858bf17a59b9de3461fb3cbb148a7d8c65f5e9fe8695d53def1376a14feb329b5457e640d9438ffa8806cbe929e80f34282432deb7ae51ff0cf5ad5f5ea2652ee7b3461ae23382c614e6c5220bbe223ecc8a16f8a65228aee306fec1d5c45e1f41353bb12af5d44cbf753e3a433478cd8789c37a0da4af5749bd48941bda579a82fa50e0bb32979f62c12291a1df6f222789b9b30d6ecc1dc9f8090fd33c39cbcb168007c8bbbf06c7940fb74fa137711f375aaaf18a9b7b147a327b10d6b67b45d2ab31d1bc95e8b52e1183ccd980e38e9743e1e854c17916d0352973a2cfc9180f0cb0cc9d52470320e6fade2bc549466a78fc077df922a8e1fa38b98acbf94f6bebdf04876e95c22614b9f640c811427843de45e596252f218b3a5c9c77c4a7d97cb248f837467c7d7b2841d8419b4e879a04c7674cdd1bf5accde0e2fcdd667e2f8d275a17c7a1fd8de5b33f6c567dd4f3c48d09008ddb16137975df878d0efe7377e0b8416ef31dd14213f92f1688b976427b7e64e2fff72d0cc2fc867bf091e8ffd710e54a7f856e0540bb0f73ea22d9c2bc0a1e055d1c9b6ccaa689f41c53aba9fcf26e7f8e91a7685e3578c515dc2c653738bdf1f8b426c74c677380ad0dfc2a8aea2dac5558ba6c0610c4f1ea42d2dfac3fba7ab5f240832a353257f32bdb96cb062f5edaf0f93b26946a45973cc49480bcdb18b25c29f72974c8efe68ff6577adcb463750b59c2a0ceb4739e793db01751baf5830d18638bfe0aa2d6b4dc14012a3ceb0a31b44c43f9a9e0037257a48ae6c7754f491fb8b4f199d59976a6c663aba383a10a3d05df64307a73cdd6a3a41126ac515a9da5a04a536424c535b125e28472afe535b2cd96ee043b6453263b275f4019643483b0e19faf54d8d6698a978c44cf2a07a97f13c368869e0cee2ce425767b6dfb16e059e31b0cba6733ceefc6def7f8fe5140456d0292f9a8ee8eafedc530dae4fda94cac00311030b37d257e0bd165c8939de51ff7bbb4f1ef1f3070d57acf78284add702f681e809ae08a754125da356ca510858e737068cb0385d44bfd51d21e2ff32b8b42bc4af041335ed2dcc68ce84e773ea83be713f840bcf62e037a453069e127c49d945a42a1541c79ef88a584ae7e38e398051454bcdd8e0a1dcb77623bf681e4aefdd9cd2e92b1369fef67ba8bc3400a725f7196c77970adfb9ca5f38c13b1b1b6c8fbc5af08a7b034029c698b759b712b5f0143c974f9d68030edc52bcb2628df3836b7ac5bfcebe76e91161d422e9ee511dfd20b3bcc41434d3a4e0a137222c365b71883980e871a311e0c5cb8e8aa82eb147639b967f91def7f8f528b2ad12ff13e62c59f6d21084bb7376bbd9e9dbc36194a646eb06f0d3eed5cc350701786c235b9e0fce6d40ec68bcd8c6a5d3c6893ff49ec3b5590874ca46c9db16a963dbad4635ec599fb623820d90c8b80ad3d7732aa08b7ad483c164896b88f2bcdb508649de9404ba5b8109aead8ad9162af8a124e249353b4d93efa3d2a3edf580204141f68d6cd2d790043c450e506757e5f18a4e20775e2dd51b902141b9f67b97ebcb8a103bfe13462381fd0009d03c4dbebf480de9053aa48dae8f9c95ba7be56b5325c5890544b2d3156414e697005d88e7c01869d271e526cc04ba0c41c9e48d851765618dbc44d2d101274d86847d037cb60599f4e263602b100bc03991c746d6541882c580ac308b5def8ec7445f59a2ae59bb68c4dffb3a556ebfae8a07e3bf6d2cc4556f41d5e6297157a8e4d6c0aedd3b66798f6a6bc16debb37c82ac00c24c80f4bf4ef8eaa39aa102ffef953d3b361a352c3f5eaf496bd3d24461900a88e972ab282aa901a6a9c620e23ba3021a01f7135ed7ea94b122c636252c71ba3fb2e207a9c86e9034b4775f396bc106103516e7b8035e48bc750001077fb3022b0b3e718b610748aa972ad9b5a2e21bb3888d16c00f2547943993b0ee0fffa6a8216a6fcf9a75aa76120324867032ad4456d03a7775dc604217dff756cde6db11c3a5aaefedcd4a048014528763c62b81568cf050d939095aa719b4ff780018ea043974d07455b6766c78c0fd96656c88c5dd0228ace22121a90535021e9c98f4cb91bbcb772632808b75806554da3813e049884550d60a9d90ca7724d8198bc2be41801fe7e8666f7150256c204013362e6090a88304efa8ad7905b3af60db48c6984c9f6b9c34699e272a9247d61bc8c71a813fca61fafa5ffea97f27299a57b8e169f94dc90a7fd1a9ce93c7050baf07ced461b7fd0f2997e2373b6d27536110d77261fbb6be62a86c9223c7a3ad7b0b0290e0f39a28355ab07f833afbf7abd5c616092275e258df225b83d258dba442a34555bce0abe0fc2907b99c0833ef052bf22092d87ac83edd93240e7c764863abe12e4d4f5985885699552a15fee3f9faa364654c4613c8351316df508f26dd852f207a93e4798acaf3d2f6f77f9ae28109e6d08cd7e31518e14ea66c378a4e4cba911a8a82a9cc4f23da02fcef37c7e433e4c471b058e5d0b149ee2fdd137d94760483e2f45f9d20ee2614b7862967eb2c35dccb943d923387ec4c3a70e1635186ca1a692aa8469781386ec60c11f282f1173ef92faaf4f4a4571f350e9d714591953abea6074006b22b3f2cf8a4c09a8cd37a935040fab24612f9a6bcddadfc5f56e859cca689162a247aa77fbbb339d04e25e1bf64df7e8509b8fb826fa82559a57d8d651533e32bd68d97c4a34b80d7cf1b584943bcc028a8be8bb6579b5c0ba20655b2ea6f324dbe50fb790d37f9699d4c975cd87bed9457dc9c80d347660a6ea32f5ff1925ca0fd09ecb2695f09b4cfc54b5a7aa1904236c383e88b992683e531747ad58107a4c90f56de0ab84ef82cbabf5e44936d051519cc21d04e5f320ab13611aba6b0ed1be64a97df0d3f02c42023b876aa33b281aed699fccf517de83a2f3934cd6984ecf19f38390c51dfba00c8d352793120942c8412d45b310f8cb42fb4391aead12d62e795ef1e16bd9efb4385fe31a3564279eb7c72f43f4bc4e68d86a8957ec672347d14193c23ce3e0f6630e91f011a869706347668803ad92d7344132623c9d7699eb69e24c67e5081c1ec2320ea8d13ab5ed8bad9be3acaf9f4ef10237ac5baf20ed2b44cc9dc5a09b2ea6e8640646b641fb59b07654d8eb7e3b61235c0d7e7daed732155b349d7287397b751dde7508e0a50fe59879b7e49c62b442ced757b4ad34600a9d12e83cf919bc654d20c40119b859134e2f1118f4495fce61442caf055a9c6a2d3d481ed97f09ad1cb48aa38d25b0d9701d0285f5cdbbcc631943b339a92fccc3bd37bf92e1b52aa867d7dea46f76f560e5215608240e8679eb557fdfeec3d13a3ac93f0c65d4c66411c28a017073d80021260e17d520f41fa3d6800501191f94316fd2fd2d43267d851c56bc0609b392c67f28a5fc5a051a9ffb299cda43f10c56211502c9dba8c3b83684424f25b95a19ad200f2a586f6e6b50095e7c2c4dcdeb28002cd2792d543f6094c05555865780b73740f535268c6ea2f3d1a9096248b580b9b132e7dbbc95df03ba2afebfcd2bcc0a4e22882471a619d010e52b3623e3fa0c54d988cb7a47c3595bac31ffd85131495756ece55c7249ceb3994cf07946464eae88e9785583a634ae8616cdd85778fdc75c3a823a367de85748997b75d3151a41a8ab4905cbf02fb410297efe025f3e4c3e82a4a7e9bd43d37e1118f55519403937ab2a010a9a694d22bbae4b2d1ae8acef5e5dcbc2597c88c1b72affa8a1c5c31f36d5937c6e5a9fffd8f874db74765bc1235ef6262ef581cbf2ab7408008d32fb75e891ae49e3d6cb5f497faac5d3b6ece2a4890416fdb1c0c9cc669b9cef1580fa67cbde80903192c05a7f08a1579876e4bf0103337ccd6036e9b0306ba2d56f030fcbdb3f4a7e74df82c7eb943f625c49e2f6ceb389cd2a8f9cb3258307b187b7080c1227d893f6268c4fb91294a982864b6a7bcfd8ad87e348c06296d5e7a7f656dcbb1533f907b752faf3c756ff34baaaf2f8517f22ed7f956ee9e6a3c98d5049a7fa2ffbe4eba2fca5018c0b665405a0bb471c9051f5e12609e762ae1f1ecbc75c3ab7056465593e54093953205cbc41af2a754e8f2b6a95d30a47aa50c073b95af16ace1e2fc3ebde2c5afa24037297cd15ec0728555052ceb9104667ad31eb3974cc1ca09ab063afd41a6fdbcbf79943fe927b2a0b00d6cd03530bdaff382807f1676988f7563dbada2c3937fd3d6ab16656700ed63a207ad0053911f603f6df5cbd966b9db925b8a3802b6120f35a2cc101ec145b0203ef67ffaada73d2566926aa593447e4a29cd28526fdeea636268cb2cbba213218e5f8089d8301361149cfc916d0aa87b9156eea45cb0681dc2f87d8c4bd938e48d22e89c82a3908afc9c5be311ee7cfea8098e93e341e72d7eb8dce6742d5b6cd3dca1451530f339226f0689a01ef465378b96d26e69a770635b866d7ae0247d1ae1162ac65009038a17cd465045590a6e798af9ced050f54351b1991789ebd866d204688b59f839887e16a289d9fc66db033e9dc3db3c033e7ae14aedc65fcc85c2894ddcd4a9da01b205c981de31efb4d5dbcec436337ddbca55581e20dd002a6adcae172bc13eadf30f31e2a006e2da3cdb9e96a21f373d6175c0ddcb9c940dae498cb667bb634765c481caaa68352c3c489ecf0522b4689e8e7512245046272a51d06b437ef5a47b9e2e4f6b9b696857e0de4574ead30881b04e5da7fcec82a67fc21f452edf59f20fb4432fd9b039ceecaa4caaf2f4908b6354037b7f76e387958f27e985f0cbb10db616059ff68c828e032933547bdbad29e2cd3dd0f50ceff50381e4dc056f169e27eca1e9079ee6ffa328514e70a0ce843d26bbf4d9fa59a1ee8849ff4e287c6f4dc3897c6eb20d5f1441f7206ffd715f7bb40be0353818cea0cdb2d336df9ac489ec38c324196e6feda0a9a913ecd883c2927ed57aba31795fe6b31a41657ccd88ea8b89378faf550138a6d5c64e31963e2ac5b475966c231007a38d3f0659eeb4cd28f77e4a13f882ade9269747ed5671ae9140521baf457a2f2f102920dcf5dc49ec55329e0f4e2c3b9a18d0b232da82bbed8ec7182252d08c3dacf649b53c35802e8a807b7ba784cfb654c99b6072d9d3da5ab8e74c0738014ed40af5ff8c1d53ce10d5b5bf77559a267be24df214f88ce50fa2e5fcb0bd604e40113dce7573d473961359183cc1e2a93497ae08730587720d8634b989aea7282e1fef1465b6f0db6d60d50d42f12a431d4c72e915b8d8116b2f521a7b9afc80c3fd4bd31c959b718d9524a73a06ab6e9888121b59e014dc3bfd497dc5f679dcc7c43a0a31be3c43da0a8884402ca6fd2dfb9b758f964a7552e9b4779dd401e9a0feeb15c15018635be11488d967fae5257ead859dd345d2df7f4629d01ef233029be0d39be53a3d5346cbca61c0b6ff00ba7c0984b02d05ad72266c6f6ba765ea600be51e3bd0c6d269c282b7e4b04615213de000a6f1c5a7d72a0a2268343afa15c707d61c3eee9f19a38288727b225224cb75f0c0f072433178715a088e0e72f053738c175f69b9b0ba8d76c61627126eac7c1023adc46bc0705a075fd0c420fe36385616cffb06b48035a4fb0bffec8c5385a41271e9b759f6e42cacd10cb7f97580e683006aa7c3a8894f5d18a6eeab7c67ee6d5c23d76cecb5338f3b58d20f5bf6ffa2270226448c3cef5ec12e23b7e1992f40bc542fd66362c70d0c965203efaf2d911fccdcb8b39e5b224605cdb3672e7154b802c3eb854a259987af2dd7745b3a60c5faf2d040f3c37a772266936ea9887b65d35acf4917e592c13254257ec8586b2d543437e28f2ffc2cf201e8750938651fc193a55cc6090095ef046d87b5e4d3ad6ea3daeab63bc8396260dc3ab3e88cb80cbb888233ada2454b88545dd06cfb0aa778c330cc6b9a4ab446d6119a1696706f7a0fbf75fc4a8c41e67fd1af54a2b51fcfe1050c53af3ab942527f37799a2a71576a5e47008fc6a6a9827777f06b0bfc9e49cbb25bb9008157a80bd8ddb278ad670723eaac3a1c6f3a0fa471917f6c38c76ffa9d5f70af0733cd38dcab439b7f7ee00b65c68f71020c3db5d93b112b5ea8a8454eee7e6eb49f6062b8e70b366662563aa2a5b525a2fb846402e3cc79d558b1a21047b5d24f1b239de857f57234bfca0a6b3105fa172f9152a8f100dd44ca106f2861a5575ad450c0e19308721862f0e8f7a61e1a33d9aa3e88c91bced1ee7e80f91b3fc23830adabff2f4ec699aa191b85547cc4e9c50ed8729097656192654ff216d6c0e458f8d23f52ffe286b0bff35c2717089ed311764856df712600c509efcd50beae55a15e7e4c2481f84274b7a8ad7485819c9066ef515bd3dc2738b414138b069a653c1a26d6409a839f6ac6d6acab481556fa323f6b06b24269c25942850305a1aa859ecd43c02292ed86a00bcafa3c99b7815f8867705efac10897745a74c2956ee66ddbe59dcea5828c7d528efca41befa8c0ef1ef017dc98d9f243f43b32a4445ddf68730ca8227ebc7e19bcf3f3f8f2382df9bcf39c1fd2c55c0b0c9c5f638586b79fb4fec1efa8a8d4197441bf214068edcfa8d9f3f82b230f279c5682ac2192aac5ef62de0b7c44b0508273cac2c6d703ea4464d2c03dc0c1cb7d4fd53c1779bfca24aef1eeb78b17c421427ac109025db9f8097b32710006b22dd09ff814561a6d041eb2f75793b9c30981d6f4596886c168ed6a5c5a0fb2f2bb232d98e841b42263d70af8c7cb6cc8d41e130595d6a88f1e1c56f217978589ebdac65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
