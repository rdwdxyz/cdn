<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c1103ba6603e2e640125b11756b5efaa9fe48452f7f5a71325b9a68f41b9a053b4d2f8549086fde8c0b010a58be8325d88eb3cb2817d465a1667572ec577fe35f4093238c587839961a66682825c9f447f9207eb34c27197757c14b9470785ee2929179f8da5b13c465ff7c70c02c25af8171a022c108bb014573bfd984c2ebfc0d64ade4112a70e74af4b3fbd52377971f01ab7a9f6bec69e5d242aee914c8ef9325c4ef074b746568ea35f25ff89fc0b304eb866b619c7536757c30c8cfa8c86395b48a7b340df449e1220e6736001356f0c0c598ec351f71e31cf46613815bd33f1b485abb1b9b394c463dd236687e3af9ed43004917896fd388b62ce17800f532b24d0492cc2affde81a25e420783a7a83bf68edc3fef5b3fcfc1769115ad879ad27f9deb8efff417912443448d695c3f8614769cfa17d30351557640b90e8cb45fd23d48b60aeafe0c8926f00f9ec3e8e17000c543cdbc10a763165d0a1eb31558086c10c2d992f506a41f9ce0a31b79967f00546b1b496ab54942e2ee2e206366c7646100b4c651d08508b223fb8bb6d5e8d4d3093fb981c1b656a1afbb9c7c1712a1f3604da98a846a6089963598e56f6ef0c034577c34ff23abf1ac062b76c910afab90c56912a21c6b7780a33290c825044e2f0351f2560feeafdaaa1c2f65fcb5244adffe3250466dad1afef2083551f7f5d470c8de5066594fbf9bb134f375c5a2cba97e515c2ac96dabd14d20b76d438f10d49ced923e7abfe069ea2373e611fb6f7daabd62e5404a4a09f38df9e891b7d045dd0a8521a819babe917cf21f2cd51e9c50ebc7719d92e38e52fe3bc26dc43a917ca17a74f698cb3bdaee61b9b73b1e034a0d8b5ade318848046be29387f166f9eb812cbd5e20c3c41a51cb4bb2877bacf36e79cab224e3a46f0177d9de70d5118ba9384d2beba9c7b49a87fd599af0b3e15e970bcd66f1accef1cc1a6e99b3d903e66d4ace6307f179fb999b4145916437eec26c0edfdda6826b7dbede7537ec5d10a4f91659367a9d590b7ad386350bb388a5fe7c0302b1518c9d687b74b3de43d4d64e96fb5c3039f9bcb7cd9605f5794acda763370798606a57022f0cf206b9bb2714aa6cb697b27d2a58cc21b581ba0f02e8ac27ea18140a8900e617052dda072ba72523534c359233938114dcdec790af52c0709f5ea757f1ea98911587f65fe087cc1322e7e73bc01bca15fac12e50817117fc8838327a735831ea8da301963ba4d8135f5acb6406faae72f8be29781fcaae4998539440dc577bc4a97fc8e791430424dd04273438c1e47e21ee646d4ce82e766a091f46d211b004c20d31d4a4842528fe85c4c41b0679736d9cc7f9a5c0d13126de7b326854eb0ebda384e0bba2594d7ac2ad51d1de91e427a0b3cc110579eca2b51320fc4eb652980c9b447b565850422596dd0d2bc1da1cab28c36139b50b22890ab61be1ba47963240dd097c7a0a215c2b3cd8207cbc2c0b28f9ba04f04bbed1be5f0810ce5c7d1df69e51b85534443e2c4b5e11dbb117c4540148a7830abd96a3da6a5b832c38f563b065978ca33ee9ff558f479c52db9354ab226b095588b048da395d4823c457fcce1df3b10d5343eb8275d7474a563bf66d4cdcc519aea860bf93460a934d39570b67bf77cb33fccac399b8045278fecfbc97df902772452c3d94d2bb519831e5a68b02c84aeb33c43e94dcea87509b04b78c202da260b600bbeb63b64a347bd0f2d9f92fb6fed0507c02de612e25420df36ee037b4cb99689fb59da2f2a672525f339c6cb1027cca58c6be4e2f3e3afb4622d21ff11b6a35aa1eb25a806be316dd2449bf42f97687e245a9aee9f30f24a8f632ced58a1768a1d2007f7fdfb9622aa8082551fb6af53b9b908cab719188000f20b7ea80045ca762318524470358edf8d81d646bb11db774d0e94b8597f5ecf538b270f02485f84e8e26830ad330200122d9a549779bbbf428ae6372141d7abcb7f0c9d63648409cf0b20c14a0de8c92efd813953389ab574dd5747d2603972139f0d3fcb1bb4c5187127b34812b3e9ccc1663f272ac9029d8703eabfc5817669454917450b6fb2e949d6861327c8806a97b05d86d8807daa1a552558c0096f726c9a3280c635577ef1c6c8c82701fb2e1143d5c86da859586fe494c9ba094fcb013303e2714871cafce012ffbfbe3a5efd9cc6045810be29f2ac2681789efedee10061beb33d8a3fdc15a76cd639b9bf2bc0220283687321c738bb9b12e9cd913207a81fab0b7cbab624e6b4976cda1b7f7a151ed725b551e29266f07968f3862cb4f3578796b7681cf2b20e8341ba914c41d9a95e12707dd5dd5630a7bb7ff948251fb3270d6f5d2bf927b47c8b52a8d9e92f9fc2f92e41601b3e00163dbecfd6e1101c3353f4c9aa7672a6e5e945ccffbbcbb90da35da7d48bb339672edab271334a9069fe508d08344bf69013f6bb502f1609b112bae27a775ca6fd962faf2215ced77cfb294b33278f919f21f77d56ea1d498e8010c093ef8d9d8f9ac706d07bbe93ff570fcf5b8fa00b3b793895a73a5a206f0218c716f01057ba688f90df5aa133ac33b483e01d78a9dc267ec9c7097205454608ac1084d5dafa7ae781e69c5ce6a4f587e5ec88dcb0fcbe6b8da0d62365465a0cdc5223c1c9e3ee06be15de8617818585eaa3e098e4b17bbea654d15de186079d561a9846a86dc1a7ddc5e113d34d68e60ecf155263815a28fa2c0ebbe597f160b5bee305e3a4afe4f9ef8c252d09f26bc8821dbd6e14817cd2256ca997410d6de8e6a44c7fefcaa3717b4ff799d562ace6055b170aa536f981f80aa935388b6b1b3bb624c1ac568b4b0eef8537b86fe13307c2e38b569a421894a5b21d4d3d2bb2d47b53d104af604aa1cd9742c273362bc4fb3f0bae2486c95a6ce0d0f0cc39f20f9624e57fb8dd6591b367a23b6a9ffe262ae40209c05c77c075f1858e567b0273ec51cda281e4d46f9fddf921ed7320da14c564dcdb55ffaeefc98601cacb13659268d9b9ea4595ab91b32fc21745b50af5e2032c6a705a286d983898e8db401c6d1eed539c1cd4931b7ae027421979f93b61105e191dd4de5d233e6629da6f78bc192239b1b385823a542c77f958aa99ae1e63c8b5c1d6c7f85805127114701b35d8533a2cf63f9e4d7ec002b867b17c715065c905b9bcbb09f854bb420375c4e4e669e5cbe0870056354a9bc6bf40bdd2301afc630c156f0e1fc7b4836be4a621d915e24a11ea2579454c86a826781b34e6dd40742dd4f95aee0f5a4b74a7126f62800660337c2d559f3be3158ef202679dc241b81be87a9de9659dbd7b61807bfd64f0bfbb76432d7425a3696218c54fae922f9ee36526f97bac76fb425de83b607ed858269c15ae0893d5b3b440144e0570b62d1bcf1f8f8903a38e84a87c1dee56e57059de255fc90d595e43214771a38baf768112c6a0ad6f74302c7bde38aeff4e5f0ff0caa58f2e36b18f088d601bee7beb6daf3259f7131c26ba67d8bc919048df971e52d59884f2db73a55b867c3ed0539163833838dac21b1334a68516e10e2b2bc13e9d9568bd0a79a6c6c08e553378f1eceef41d92659af368c37fc586b98eafb24d883d918688a35318087f477836e96227dc978ff2721855fc5f80d500f79a61888124a1cd0ef2f3b92b563bcaa2dcbb377e7d4a97593721a132293cf197e9ba766133e5f99da8248163732eba2a615c684ae298142ada17a55ca2ae3d224732b1276bb151d0535898601751fd34ca1ce7925a0fb3b3924894c74bf542b5970e7c7d7ccd71e85d4490c2db3b798b7ed6cc8692aff3dd5eb3e422eccb35c856dc91a6be96bf118171722145c79cb9d56a01216fbb14ad6e2d4ccc783a38fe35e3599affa27d8c0abac13e1352194d121e097b494eb27dc226a4aed90a616dafed7c6f46a6cd110c7c410b98a53c2e46b04b6c9305823d337a16c3bbba3f6a99d5164e89159537a48dbc93c6027989fc00297d9dc2029201653fec58a7460a728bed317834cf9660e186cc8cebe692d21c16472a7c4a9b899c3087dc48c7ab87fcf800234e7b71483669acd86ff7c4f420cdc9253f1fe69be2b64000944f1d32396ad1ea65bd236463d0edab0b694b5e60770876dd1bd5dd85b4b251ad852db51c02c9945ab26a8f16eb9ded33fd665850445003ce6de9f7d1e024960ca8d451e5eaf70a2bcc0558dabfcabe46bd7766c500b0817e6e96b88441e4fb1579da65276f8edc239b145e507bcfea8c2324a04bbc29aec4cdd63ce37e3e3dfec61010bec8922d1d15bd0d79bda864cc0395dc1a18e4889cdc6b9146b7c72ea5716c190e388d4add1196796e862114256c3272ffebb4ad7a0bb9457768eecdff5da20d9159c8ca63db5db78590a92ede6345cf058c07be827c20e4e24d995dcb542b57ee9e17350a96acf79b8c2287274ea60f98cdf01bf3f4eed74cbb09ec96bc2747e9439f99883a981ffd683d07bcb0452f06a2ffd6190bc750237cd08d10c020afb7f4e8b56fb703b2b2b900bb2b05eeb0ce836bffb310b4a0587c67f67823b6c6f4b4a8c6587e860bcc4b152ecc1b35ae219d896f6aed1e9f58f1ed7719dc54bd3b00a40d24422a3c3be449112ecd900f4e2952422b70dc18881deffc3b37b7d3145772b8492e66fca0cbcef37e77294fd4f8bd61aca46b283b36198815dbf506fba320f7e3c93fdf5c728e2dddd0926efe7618bc92d5657d12541f5f6ae58cff29c3bd671f575fa644aa58ea64a7d24789b3c3d20f78c5374475d369dfce64888da4aafee7bc0c4e561990407f1e44c96e6185d86a83d23edfae16298589bac22c97aa73e630b4866c7fc243021560aa06413b973a138c04fbaba770c7f70576b0f178ecdae5270c90dca80da68e04607067e52f41a89421b06851490f1957b83b07d16cec98b42a6e5e9a4ea7395bee3989b546e659b7db772db644e8ceadb3488061ad0e2a93a7ab30b5ddbc21ce256e7fc016a8984d5ffbea42c7c3a97a821d5ed18c9dba71ece0f326c9c811af13de461a99d38a87cd43b8a90a61b100292369db8f16a6d3e5b6becb80220ba80457bac83ff770395a5d7099c1999a3499378bccf8640b83578cb82d55af6e4c7718920f88da4d93ab2da08d5723a5d17d46bbee6be4d8c6bc0faa48e5df37b9a4c43d51a5b0a20186221b74778ac38ed9a334a82c79ee90768ee7d0821109d6fd34872bee79a12c7ab717d964c8c72da67d9c651ce58bb168222cd17d69821865cead9121f9497b097a33b2b9628e718ce3c608e435ebe1dd050d7c6c82378a398c51c959b962811ca65a006ae4e8e20943897b2594ed429203c1289714e278b8c4fecf470374a322623a6442100be7dced58781556bfaae53d7b07139a4bcb3b3264ff0663db6fee2bc75e2293793cab615147389e2f487388bcf23ab766e090ffc96028fb39d082b6e2d34e84edda01ebea2595e9da08f7bed4388fa5267e40bd648df557231bd41df276e79af3690890f98ac69d758b6d4d34369df309a77c2f1e2ccd4bafbbe1e841dbdb03b3dac7ee136446a334f0b6f1837ef9543bb44aeaa5f8ef51802a8f0b531350f672cca9db56c00640d538eefd9c6b712145f46a338de59cef20ea04def951e87aa2ee111d40b372cf58379b27a27a206fa4b7f49f1f5bc99dda8309a5543643add6409a4bffc1d28fb53de6852cee7e180318956ee4888fbb154796d22b1390a57265cb20141a2eb88320d85eff0b9eaf6c9a79d16f05a43e4336592080fa502a9170f713be1eb8da3c69de2cb1378e812472f2a22db2584175ff6ba1d74f826dc2ca0f6d22607c8365b0fc7e32b8778e333385de538a3ea292de5c35d6840c249a2f8fb4f75e06c927ab81404f0ce30660fd0445b5f2d81666e549abab3c40fc9e1c973c7976aa7aa04a620fe31962aebc5c9bbb2de4f483dde38850af0d45a76c59422b2ecbeef9b073cb637a0c7f9f0fbf2b22c927ee6af4e300ac03fbf4db418a6ed048ed7f3f9ff8610309c3125a7c05e7fc5327a10b891986e93b3861e6ff5f16e9c1d5d2ab456892b3cb4eb9e94055e3e57c301ce6df0fbac7f3f2572ec1c15c337fadeba7cc38f4e6b208361f3647c47e1a1095f6993c0b68653f14b747c7003648bddc4e6dd2a00e7670e536e6ab0792ae57bc24aaa96887d867d0b452c1e69314921f5db06ffe1cbce7164105308030413a1d5dc20e158acda7438f80676461976a5cc75678772b5ed8969cf1318c8dc5c2dd7d49290e97a432d216e85f2d30c82ba1fcaa1e8cca3018d3c18183fe79e6dc616ea7546cfb022a4d1a28f2d084c41d19aa958a3133a4f4c7b6b454d3497b8ed46a70c410fe84c79bee31c9f3ba9bbf43f3f31623d9af5990a5ae2a34a6adc24a5598397fe83569ab51481319bbf30e19fb625a80da7575e9314e54532670ed9857d8135d80a0f54704cd0c348467302ac0608c2de2f6e8c69b765c4551c74c55cbc2be8afdee21301f7668e78d1f3ed5595873df44fea6fa5c0c8351c5cb29d021c1a5199124a921e8680c5b927d84b7d86b82a7056b5e20e6404c080763cbbd0615561394b64cddee12c1ef917e697f1c61b8acaad7a1696ca4c4e55ce9e5db37d89a556f06d190b83dde12bd364cbb20cab69b9d530ca7d345d925eaa6c6bf9103102bd7fbccd2140a4a8a1b3c2b315e119c60063068777658d774ae66f0452f4a476651c64723e2478e42de2219285c5d732b8823840db77c9c8d75cc4d91c689de04e5382d06d6b100d6e4d6decd55c1d2e7f59e1ea201d34eecf35ccf9a40103c8d4d8415d846e7b6498da4f12cf33d7f2c2453e8b058345d47b3f428ad854268ddcfdd32ac05460467bb5aeca3770a1da3217387ed8f0c1f73f12597f2bda3f400c6a756eb49f536eebe09790ec9ef1cfb05b598825f8105a8a42cf647a65036c11c0adb81a5a0df2347a4098a34263bde67a8a5fb91e52e7a163386c043af1742f94bef2467ef37685fe9113fdb514e313463894ddbcc006a6974bc6d25504e42c5cf30162a921fb638fbf4e399363913d45228cf2b4d92d0ddf1ecbafd32a376568ad16e74af3709b12ddc0a0bd0f955d0f19ed8338f9e661ca487cbd73f8aaffe21a9fccbc202b0446b75c761ef88437e48304ad49b0f2e1d4fdbc2d19a81703b7664fcc3ee23d6e2e8bd071df085af1df77b6f3e85d160a5a332d93a4023c5724e375e330d9988bd67746b01b689614bcda8f8b6f181b2b660b4cd0c2764d9a258cf040b3b5008724a535ed89e52c65989fd35edc52619b2199cdb96535cc8bf15f2f85b42c074b37806383f9880e2aa0372ac0499cbde8a3e615ea37a57028bf6a486683e1426b1447e30a66119bb80b6e6539d47b8c0f9f9242f4c1c78789cdb019fe04a571c9f9e1a5e0ee42a5b953b0da6894e59641e8b792c84af071140aaed545f3c32bbbd43cc2a19aeef21869c0fb6821d7a169f2335c9eb0103b8c53609f000b197ac40ba36884f5d1aa69317e1e899893fb5588da115948ee8f997b22fa0f01e79dfb27b307a563ecfd7c37cab0e00df91192e1421e71c7f3a7ff9cfc418386676806ec2c4ee58697ff036c231b01320c27d3321b227475ccfb681c28d7fa477e23d9cfd034117420664492719c0e1bdc8e50b43bb451553a004985d769c97ed3f125930037b4b92731e00840c2e153c9711391de515eb44762fe02c856b5e23965acff656c98fb6cf0e3cbfb3f947492c10a8b23f50c1b1da7f76c82d9bddbad1872120725c6fa4a8058c4aa138545340b5a4a9bd91b0ba95ac91e35940dc689dc8352bd634bd1415c83ebf67a53cb8f56e55ca324ba1201a542eea19b61a4460dd20036d05f50991a76ddac10d5843c16934361c438683cfe54e170e41b7b860c398865d7087c0cb9f659fc2d8ed5b5d7b48f90f7b4b768edeac26cb3386c205195ef410877f37b3226bfa0fe492dbfd7c36df64b388083c81a2a91bc7b958d64a2ede8790caf62bd83661d9fa4ca9f455982da0f744e40ef380fade25fa8b8c4eb555b4af1728c4e70c63ee73ad8683fad3f1b8369a9dba3691f92131818f56d10f1f127bd5919e2c69cc59a68cb51e9ae7e7798064e1fa10805c4bd0b1c2f3b89706f405a90cf8ee4b08e882d8613b3f601824b7964ff525f173788baaa21bfd40c17739134ec3e4304215c99c6f53f3b5840c37cdbb9e1c0b201b44265597f9d0d5d8cd9db900d9f2893b988e2095af6790c2fe8afb343cbd5d2234ae26d7c6406edafd44b72693cbf7bf0e45e7cab74f56cd3dcb38c84faec7df550032cdb19055f56b579cf9243149d78b9f46925c39cd56f3eef415bb4a84319d07d9a92998a57e75ec1c335c4da83bb13dde50e087cdc185812c4cdc2d78805067db940e6269fdaff6a7142da37677a7742e88049f59b4273abccaf087e13d25368abebb6a688abd3e0f32f8d6f1c8cbc5bf6e95121fe94551a67daeb06b8272cb910b06d368f96e8c5219f2e48a90c562b19c44aceb459a5f64717d7f0b95dc27742bf68b589ad5573aed03a4f91fadeca58c52825a34fc0d4b3476ded08322238190971dec8deb2508c5d8595af0d474534a02bb7d3611679cd33db837492188fe8dac42d3de3761343c4757c5dc8a3c6461978208971c1ef5041b53ce6c0c24bcbe462ae184beffb8fecef87b999e855aec7170cae768ff2aad3de2f27950facb31132450f9d71803e71b4e801d7a029d9570f88998f653d75e1375eec75c85a5c3571e5cb9ec4fc5a6b94247f126af6433e0966718881a57944000718dc2fda7fcdfc94c9b1742db83b29c47d3ffd181606624ab0b7eb6eee3d722998eed5a715eeca11b698fc29939e46f30424b883736300c6832a3aa6b277ecd6b2fb62cf8c566c6dab684befb53fa7c3e07e6465cb1a51e689cf752cbee02ffbf0ff59dee97be14358c8c4dfc8c08769b7fb5519176f4b83eb5a8e04e197a82b71324df478c4f6353d3b7d363fb13f4864247a522c066edce7ca9ff738bc2662b96ccbe2e5720835a15eb2c51bb2e3b9e359a990ccf889d521da77efaff9882aaa468a786b038af006375a5dd54470c2bb1da49dc745ca7ae4eadcb1b143cb524e81443fb2518dcade288d65b40cbd3769ea3bd2f346a7cd586bf48adacbdb7cfb4024d1b4d53d57c1d998786f32a5a9ee88cdbccf673608204a856c3c0dc79030b40ce49346726c6e4440c69d01cbd9bb03551bce274a990fee71f10550b81c3cae2581f9a44d5317dbd3ff1fb57c367e987578a628366b4c11f4204680270be12d4b8e501c87024064460b62a57a1dde4e02eee408304ce960a3f48c205e36a8f4ecc2f0c89f0acea0e6b50871381df173577ce47c2caea52c92e51bf0db641ded261b1f58720ec606301e64c778a3f068ae23aa008fbb97a5ec25c9dba2aead50a436f024574cf879628228b3e02d607bb61e8ba1636062d10ce6fa64eb9d849add1f5d1a99e886458d6d911078589cac4a927407cfdb33308bce7d749e3862087e1e531abfeed085dd5c9fe1e6e905da55e2af2ed3f24b0f220cb413a90a9a7b6b65d804c048f03c9c15eab5c53cc7b5df823c312709c33f29bef15cdcf10ee4ed180a508dc55206928067227f0b1038a5f43d91711decd5b5d17c2bf9983e75a08f8b2141900ac5924546459daea5629cfed2324a968184f3bed7faff6696d215740857431125f738985b295be98d2d7de734f5717b6cb8a6c533864c2900a1a872fb6e6549f5c15875e03fb5eb5643fba1da534d17cdd74b1f2e08e8c523f3b05f50ece386af5e43862da36c35fa66ff8653c539b0d5a8422d529836b1179bd13ecfad06af56f4e25543be15d1cdee1d27aee51506a3f2cd84244bc765b35fac9790c6e773cedd29b7d122ae9afcda00eab53dec50962ed5fbc9c02ce8c944b298637d414874bba62b321ff214dad9ba8f9d8533b849b61f802e000050cd034512a834f64974a1e7853df089110bbc8d9d3160884fb0a671fd90c5ce6b19d2ef3ea05c39bba8bcc3525aee85e3cad055797a0241a16cdecae083e29d83e872cc4448e48f52b3daa717fdf60fe5b72c4bc89e4c3a3b6df7a3a27644f3634b7ec75551dc71c991758186d64336a4b44ef5827c9675fefe2a2946032225f6eb740173e12e74943941648d9f8b79acf994b4d575c55684ea6f046fa9f81c1502dab1421f7561f7ba9589a27bb7ba229cef7cabafd7588e17d20059cadfe8b20e42c096d6f25dc01d86c5b26de924821ccfca836f9c9b302ac0d021d215a840df4b5d6070fc80939f72946d6673f982e1dd8225ad7af1cf6ee05e8e5f210a33ebce4d503e019220824c95abe8a5e1990ad2bff318e2ca4042d7f371d6a5c0b2007d8c5e5c3bfe622229418c29217a40125c5dc2a40c7b5bc6a72ef0b67ffdc1edc042cff5f4fafaea4e2cee6d2f9756c52ee8aa0e8da96f8b48d03a200e0124672a0a40514f8c7c97335adc22b6329169ce39cb715987bea2e247d08ed3be44b08732e1ffae664cf5ac2bb5c1fd6e0330703707d294f7e7f407498391b41b0362c8b7f2675676a122f593acb3056c690166abae1f16dedd414b528e8929c0fd3d946b470917f0d2ac28b77089b9d9e947d9d37507b691d8a0c0c00963e476bcba59d1bb56f5844467c6aa95f8d31111ff6aa8b2850fcdf0ae62c15b69f0b737b65e515b5950900a71ebc437844a62860947913a0d7992a5e9bf7bbb44cd43fb1a1c450b6ae41d4d2c246263362402a6ed68840730159163338a9403f4ce91bc06455387570d6f7dc1eac06d1bb175522a1da073707c6babd71b01184f9f024e76358fadc76101b73a93840ddb762f2ff7e3a1652289321e1edbfd83c62a0f46524930c878f23cdf68f97df9bbb1a3c1795a3ab0ee8fc4893443e81bbece89a8ed8b8105b25a2a484654f03263c2ca6a83f48b78f096abe885afa1d278d8aa60c5fbe518800db0e9cd4ac4ae078f999ecffa95c56c040801f9778d9af415a201ab1fddf9f34edd21249332ec64010fabb72a000b2e36111c64b2e5e0a3b4fa366f587b7f21a196bb3bb4c28d6a2faf18076363f22b0c78df57d1f5ead5ba552c5a3989e59a33254b79400ee9f565319988bea8cc0733e83b9a6a2d596b088fbb64f345b0bd0e677917eccce3d352de3fd46555a9e6c8ce089b985e7386bb3af7db16e91a0265e4d1d4a7ca0b25c1c72e8c2bc1a1570682cdb60f182e97d8b8ce0e7dc33868e9d298ab602196165bf60606d4f721e02b705212e7ae6ff834573b5cc876247b4fb336262211c2563520c0261f2e5b0d5d0afd105c2b5a8ed6e69c44826100c7d0bbd930a4df1a69965c8a5a4a39f0712a34c4130265dff7c9ade0a9fad5a2f03096dafe62b8f66490b8fcaae544ce5216ff61254d5c785cef2f8c8faf39dfa6b0dc6ed649db42f94ac389ac0ed89d642bede863c61bf43f5333e66c770f232f644df9103c8fbc2d77851b842dceaf2e05d6df486b723222007735bcd83503999d269de851e5d817d06abe5da0ba0c77b6a9bfc1f524f1321b887735dc83b4bac8c0a1041463eca6dcfb50e782a89cc13c4456a687e904d9880bc44498e9c590a1e4501b9e0723ebe99bf8b64cbaf0fae696d32574b0429b223838a7e15190f9dd21c9563b70a1631d5f5f0d8213c19ab0fe4f5a8a73a0463fffecefd1287a64165272e4fe8f928db9b395ba8a2a9208331aac0451c591099482a7f8c6381b0e8bba11fcf735bc5c1638b563804f00123a60b64baf2ea92beaa717d7165ec7a3fe0789981016b033f8e94b4bc7dec9fffb42d3fd1f00e1d33541f9325b2adfeaafe0959c8cec2d22cc271f7738620d00eb22e26d207a299379f52d8c8b71a98607256f37d4af5a51d0fd71163373e9ca4c9b56974235696a756280630f9726386a83663246e78b0156a2009ad58f6abffd0d0fc839e80aacc052c13227d4f9f44d50b60166276b46d9f35205fbc3e41bcd2868d3847585af89981bd569bd77ed46a7e8154d60eb5d248c2f3c9c2b4e7c1b224b11a68a56d891fa8aaebb73c32738c44eb2d49c3e9341ae9e2ddb6a0b9512d2111e686d33215e7c0ce2ddcb15f0325979fde543c4d1805a5db0353dd3e374187bcaadfaa3d793963b99ef40a7415e6ec2894452cc5fcd50cbf8144e031d6e43a938816678827ae23e3576ad7ef62bfdf7e7ee36c403626238c42975785e913bc8205eb5258bd13943736e1119ea82127281463ad2046c69a25b071060c9495058464bd463c73aa3c1b311dcfc2847700fe8728391a3a4608792e57c88a4c0c13ce069dc9effc385f2b9023717596ac57d21a174a714556b368d8e4d3ec77851dc3c8d5ceac8f3de5344521e9be225b532693d2775a71b0b1cb9c73fbd7103dd56a7ce234e44ab7ea0b36284689e00136b720088ea05772b6a48a59af78d8a6189c66c2ae3ebde8253c4fd2ab0be22dbe8436d69ede616102c6a4278a30eb5de68876645cb306230cc86bb0cec1c9608562039cb4396742f3cc7138a9b55c1ae6d6147ee4424d6beb33963cb3b239df5a59e2c48f1880404cae85b6275ffd5f1af592a04469969206e8824f44991a2214659a3d4119e948be3e70db36cc510b317817b6fb53a325c525f3d8508d1edf4a79adcff187d508a0049942f8334160e7948d011ffcca08860cbe9bc64fe1fd85a70b2db60c0ece0e0ba80a07ea726ad2884c2c4f436e46088639a7dbc9d3bcce6a0cecf4910db0b7c8cc0ebd905647c0721c43b4e184177f2b9b962686a57aa21f9302016b215e8a56225d41005136aeed094f0949a5d0d71bb46355aeb41611ac39cb32e4b2c154a245855cb9be04f287d7956059bb36228c9841a4060098e8854361b06d7b972c853513981d95628b445152d07f82162b88475ccef239ec44a6c3b9a84a3a45b61b2fbc9fa19ac44906b033270c2fd1a18c8ec2bf9efa251360467cda8983783d0b4a1c568f337f75c67e26269f6a4c92c59e11ba539e0148d8b2fd25a9c4973682b0eb42cd14d5c7d94f639919ee8a8c8ddde10b1492907578adfe37c21a456e6b1890f64dc1c13476ea943fce82ee8e69afdf61924478c94f886261324811fed546a3c0e61559e738f24a51bc25a3e946ee84f705e1c55a22a0092b2a687f89a3af7510d7fa4338f91082734d2b72e3210d9221f47bed7f357d9aa3f5980fcbafaf433c686f477bbd5969bdcd69f68b176cc70ef11ae974a0374c8785c64f2dd951c89c6d857259afb184a6e0c508285278f1557a458ee35f9a1f97d3a87904c7b5119b2214abc00b2457c0155566c51c05663d1ec24262bf5574f002a048c27dc65f0d0b85caad4f41bc5dae8d463cde6ebaae65202a95f723f3513a5939592bc6687293fc8e1cf6a6434ebb476e23886e2af2a6f13847dad4fe60cba1a40c0561b68ef5e018052d0cb44ed9c324830f736c26ce1e8ff5ae260b2d5096e52e5e892fe40f3e675d04d206c92a3cf3aa3010bc957673602e12b0d7b0271397558c24aadb93b724ac55d1cc8f32781ee06206f9859b6c201a6744a16269c490bee589ae15131ace17a6d95758c8e73d7b0b92169f77ab5a08145588db4acf5221a7e4d0b6c1122908c1d7514cebb02159ce3827b2d6bcefcf03eb8b82258c8fcec104808b7a6f95b93cfa1f453a5cce53892f6b9fe5010e8e96102423db5ace39c29a255c0a428f5c7b460af05f76395ada6f8636ad3ce011d4246383662ffe80151ee7d1879cd9eb4e951f051bc3a43c25350307e7f3a053414798c33f8d96112a5b62245932e9490603d6b5d48f62aa90e564ddcf4e2427f2791a1eedb94b36e804eec6cba22a348759f7eb3fc133fe39b346a88365b2142d988badb7bc7ceccf019fe2a58734750d0d3279a4a708b2a8911fc5c85d130e8df3fc279566fe3199627fee698365462d605e70c65f142ffbda3dc0f475af2abba5237ebf39c0158c9e7516f8b7b2621cc0e555217f44fbaf3fe2a8deb31da718e694a684c776fb2205b16e3a52b42a6497c5724af81fa0625a98085037269556fd7682e6b1ab59fb8dd4a63dc198d22bb03749fc0c5298de765c6d0bfa4cb693d01d2158348e23fb5aa65d0b7b85f5fa993ca55bcd8495678f6115e02e9e7d6c5ba5d1622f07e38278eb74ae0e8135fae4ff3c0d74ae8bdd2b1a05e4c61002e48f5d7ba828c57a5a3d00aafcee51e16b44388fcda8eb74664296831f89422d62347cfbf9655b4c898c893424a4375afed8566642c871e3568be7eb1bb3acfbc34d68c7479b62c69963ede9a80e5782dd3b2d2bec7ed1129afaafad5e3881b258cd495db02513401237cb16008f315b035450c7e040fdfb957baee409a07c3681ca3fcb7b844464c1472b47265b961cacb5f2e9309693da49859a807ebf1dbdd6c3895c228c27c7e4792d0949ad99ff60f6cd198f0168a16dd0afbf25b3a3a2dbc2fa402eada2b5aecf58f6305a7292c04e35a490c6216252776e513424a4a237cceeb451e16a1fd91005caaa98453456059fb371d7316ecf78cad782df07e82d3d70693c2080b2c73e5bda03f684a3476c3d3aefe1e6341b6de672ae799502277ce7d13cacff4dae8127353e8ac2310c31dabc4d07719e025974617c399ad53760878ccac16b5e9697feaca3a8b5916e2feee779925bf07e37c88b6f1acaae19b8e4d018d3ed23b53230d8e489b83225d3cd59a4637f5d02647892414267c257af1331a3c6ea23465bf3f882e22e8f90761473d15942e94da7348688871d763a54ed9534cab05a8d2c87b82d5adaaed853d1157791e1f5d64e6547b2b69e15a2a8d0cae6802ff2bd7c11c929b5e3e2c00649e27bffcc65cba18c333d997dd4470a3384de517aec8c934c47d1dff731701144f27b45c914edde3a11ee785d60092df53dbbac4f1f963e5e12d0a5255031445748b22b50aa086ae7ef3b98b72c0dc60c58445e203368cf2f2af37234f73faadedfc5c8fddcf2de65a1c85c3506f4865e4ccd2537cfe3d50e3aa86afa0282b48d10c81bc44b0845c1ce5b828271c5965c3efcd4050a9fd256433c85764bc0489cdf0b91809c460227dad51ba55e777315d2a31cf0894f7f89562998602d774c6952f1328d702c9422dcfd93c0e53122516dcb5bb078a70bfd6d6019acc136397f1609379136fb50a35ee20e681d30881d08c3177f5333b976849a2aff77ccd5397cdb45b47687e3b678aa1f6341a8aa4b8b71a98fba79cb6b8a86e147ad581e4c1a16e5291ab4268a32182a7aff140d9825aa20f7fceec067e57aaf2fe44110d45b0a2a4c807dfa8c42395ecf654602deae6db739e9602bd92c6d5786aa1610caeddab9879b15df63b4744a81ad1704879a4fa3c61e7bb96ae062a0de293dc6d00ce9dbd1deb1e288e6204781914348da7eb3d89df1942242ba06336f403f585a525b528db496638e130068314b44e53a9b12613906fe4b5fc59cc240a288decf3dca987a7841c41b5a4ecd9858de1bce01d93b829800178dd15aa14b40de41c6347f490245e906b08bb12dd27034c9c950070bda90fddec4eacae47ed7a7d7df1e80e7d205b5774d37fd543809b2d2721ecd32e4ba57a84ecf784f531a9ac3beadcc377049a4d3cb1765d51da82f2962a548d80ef59fcf333ed275a41e2e44b63396f64f86c2d57015296c486e77bd2802eac0d8da76f4227c2e282bad6b595ee22d58a2e1121eb4f90319949cdef863309a7efcdd700c4a53987e66fe5f83e4b37854ad69d141939f347e679e9805b8ed5ed3bbf5ebc40f6a6c804737de75d9dc38b74a6411ac3204aa1d467eddaff99d9f45b5e9b9d13ebcbeeabae54da4063525c35094427d100262e577956299bca1147d33ebddba312d1b1f7120310da1bf70ed51b675e7587aa7e9bf47de29b0c4f2aaa53147fffbfc9a6be2b7899c3b58ba2cdacaac7fcde235e61c8515a227159bd773f936af29cfabb3ced0f5996470eba335f7dabb7bce456771fb588e3bd8bf1f590874a2eefc16e6a43cb639e259a171e4d2f8ae5a8a1f119121497e241aa75f716d63e54f5a648e3c1e181c01505660db98b87ae873e87a1cdd51df0cbc1c8bb23731cfbec8406f3268721e3021d91f0ef7a068835b03c51d3bf36416260279b064ff8a499a508cbe741af1a7cdb4a98d5ecf29c48390c022b3ff1c9f25436484651bdf9fc0f26de405fe09a8e80b0fd421e7996825ee9cfe82de807d809596aec92a58423e0f43197291c10e5b2021d120bbcde0197aa5f600b463cf7cdb022ddb1fda67dcd3e759ce0963c7512ea800524e0084b76e75ce487a80894631f27c62138cb651e6b79fae987c699b849952ab044331065ca564706bf5f380b0d89aeaaba1e1ed4e9385cbb166a03d7950c82e7196bbabda40cd3fb1bb4bfc259baf7d4bf3b44b709b9c1152aed6e1f25a89a0aaa4e8ba5f76779b2154f5503ea5cedb803ca6f565e65586521dff2c1f7e3e844f9cfc279724790a60c8f5fc6495dd1ac4e2670a522f80c737742487a3330afa1cca18d341ef575e23f070b4ace604d02f91567ebdb6e318df99da37a07e5b017b10e1f3b8a34c0d69b2f87286496bfe35401c3e4df878b79da111dd5310acea626abbd7e46227a94aad7ea611084b8cbcb470b7a1eb34fa2b49f32b6dfa9ac8048bf94fc0a61004685878742575b037e376b91142fe98a5b80b1f3e57eaf07816eecf680b25aae89eb751f7fbe0d7a79f5ea569073b208e60c5a82e352ba97ed2c9032d4018e8f93e101f11b69684c78bbff18c24a52ec51a730e3164c022dc7b4d723ecb4f9a0a8b333a357717f8bc933661c182191cd03043c81246d6b353d6ad6716cdfc9e5ed2ffd0cdc2641bb7c8fdb2c6aeafbd49fae733a6da8461ecca4e499a9ac45d280c81df809c19c935e820426db30db9a2452ce6983c72c9f43972accc9ed8997781274df27c9f54034851286bd24e906849596e9b6dab37adda8a3610e307e5a3d9ce275a66ea97e99d7e22267c2f213fe3943440aadf276c84758ded5e250373abd82b1e9f79ee79e1945b8d0e725e01f90dea083af16d4472826575a71b0ba30a955511031040a411cedf60fd6da8f2d5d77d38369adc6f84068a027c79dd673502ff2f8f581a06a4f1582d200a667f56bd6a7e2f0d3c359153b8596ad7f53377d8fc018a06ae16a28345a41e3a46b1e7d62182c363a02b8b144bf43bb8915bcb3823acea1bfd62e897e2a1ba3f40ab3ebf83cec58e2691b80a7141f56db5cf988e90255575caa527d63a613794f2154681e0c777ed316668d7708a2782dd8d42fefdf8ea93bc515d17750fdeb27bf72eccdeb02a45b2fa884f045c697118d8175ecebecd4965cca16f5b2adf51ee48bc4fbb448f672acaec09a328e3c7f8ba801224f1dd23609f9e27c2b1c8077ffdd91e7621514f0c19374425f6af515fae738a6b379762543edc36ed95cfe134157694c333108c13aae2a79c45e3a154e874e6d03082411627fb2bc071cba26f8de2fd384f0010d34e1d4f7edd8ebf39abd93c29520e51a5023725d6828875410d06ca23e3efa677f555ddf5b0cd7b7ca306d3d49e700ad2c834ece8a13c47560fe27ac6c98c604af19d73e666eb477c40dd7c277beef395a2a6b61eadda598da6351962fdc0089c970aeadc3b3d5b14d5670abc70f9ba2fc4133c591fae93aaeb020d1e1c3d37e62ff787ead644f782fc9fb0730bd5629690f6b46df4c71fe432a528b1c7263eb1c6958ee8ee827a39ecf97f2c88845acf95701271ea92eb53744b43d72a4148ea51552b66f71e5de20100b372dc056a0ddcece59eaf7ef0ec7946aac33beac46236089dd5056598b6702bf7f56350fc776f5d9573605b0f9cf7dd1cc55633ff860a126d07aff79085c41da09853574f335b862c84ac968498868850a6526f45108b9cc87dc0c3d99574f656bc749fb4329264931cb723a50251d0c7581a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
