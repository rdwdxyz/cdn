<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"546d3aee40cf7eff2f7be1bdb4ed970752c2ddf4c68a5cfab62754e7f5866b8d5cd42497a3a3a9ff3c0cbba361303e7da4b456efdf0d72780df19ab22127d799bbe108546f2cdc8cbd8ab5135ed62c291922b0f6f7c4e20ceb42efc8a5184f32c08ea7473f3b01874b1cf7e768c4bb38d55b95e5a3b772d1557f34b3084c7eb9e99b30f70cedb9dc3e0d73a86899159aee75f3bb6c6285b61361a77b1bb2e70469c945a50c25a87e1d3c30557f6d35df03eabadb26458b442d1bf44bf02837a6d31d68cb9c61aa3a49ec13c15625c38fcc0a0c48acffe7f748ea16c73426312d9301e1a80208550b59ce3399de20115f84121de3284c7854c1403dada754e5c2f53af0438dd33b2df31a82bba665ebf939417fadc0a4319779936694f68674e3bfbd4938823a6666054caee983cefb3d6125db544f37d9e0d4dc6b654dc8685dcb88fcf8076301870d85085fd00447b4b12552993c31baa8c2ec72675d9d1d0829227bfa5315d584bef11078a56b04efb7019c6d895dda90143c34a455231af1df65f445ee6fb572aefcfd9b844cc14e788142629fd9142b08b6249c69c4b753baa0f3fc250d0d27dd98bad0ce7b02ad22ecb4dde21cd0a041c6f9910c58f8c8ce427ef17abfdce282cf054597f34a8700672ae0015f02a2ea879f2a61605d4b691a0917f34f7322693e8a26fcdca5a0c9e2bb789e95198ad6e72152e03f1e3499276e0962c0777810abe819f66f5f2fd29966217b845fe1fcd804a6a701e4e9abfc6fd00c00f2ae4d4493657a38bd9ddf97c8f16c797f2f3cd03b93cabfcb2b35450b458ada58107709c4515dd9a3b1fdfca62090fd38fbede193c55c078979d4906a8cb7f1dd5fbdacb0fc3aadfbbea937f1273ed6e6ab1b6bb7c556aaa3e68b21855a5e2310ed4799fcca188ff0bfb01f754535a48e7478c9a3494f1881db2334a1d94df694845e405b99ba126801fa702af5527343a12451b2722f46967d88cf2b27926a953533757dcd130c8c8647e00af569cbb96d1df6c2cb8894f776265a849054a7887a6836814e7cb30534fe1c9dc1d89d042bb72f1c05a147cfd321569df8c51281123c0f819785739d11492ae3fc2b2f7e79ca72dc60d9e48d7c51c14279355a5af1bdad7783db2b6a7e4b3f75bfba4ad603fe0d99e95d1cadef70325c0f0d6077aa1220bf85082ff7fb794d7f298fc5594ac1e14a08c19e3eb69dbd3dd8853d539a71d8f931802aa868fa4a478869f51359a3c894abdae26d8549487144622f8c7500da4b968e48e6c8a465133c242d64fc1413d043907cd7cfd9f376f50fa0fa242eaaac4383e5f76a989e7af1c5266feafa47276e0d127b50cf9230468062b002dee143fd64d4d35691f48314ca90e9655dfcf44fe7a852ee3842324239484cdc3cff2d67b14b5d8c8e169cc22e18040460021076ba2ca8781f91fa4e8a7cf7e9301d0ad7ef6fc9a65fe5a72643b6f3eb1f3cdf27f7da41ef342e2eb8ffaf83dfdfc6014b0df091a6ebd7ab6e1dc5b21ee113b3d522daec903638b10b1bb310469eccf6216318702f3615b2cdf0183a96109aca7ca76e0feea8104917c9c3ccf56fcd436f372abc6c922d8df96ce5953b3e3720244c2cb563ea86ac68777a9488e6ff2c69e981d22ff8ba2da8152c865f7e62c10b7889558a3f7f599a89f6b5851fd639e72558a1b9c48fb9f7e30f6e868701950458b9ee382083765e38daa7a1b9234fa0bdd309ef4bfe00cde46c120a6653452e897dae9ee645299db726634745046a4edff35c700ad10816e86818be19ab7b7260787134a0fe7cbb1a91750f1f4ba16ff63858956c6ef7ab6af7390d40038888b81f12b0b454f6572cf8b1214bd34de39aa6936dae36f37494d827cd20f8021fcfe27352a5d5ce80dc0e1717cad1a479887fdacea570f8b37b27c3a6960d4768650c0f401dc305a9ee812ea68de458de2cad8a53dd1577e59217f6a57ba968e1594cac368268f2fcfe7a8579c2834b3be2f0d76809b5c373bc0d081a91c4fb035e40f7d500adedd2710b10d25884552b0f8613f9ee1cac0854a3388b80dab26e5e9371e24e619c1dfd93c17b30d57f6f968d5744ddb68e43a891f40a6827dc7e035e542e705d4d4e861ca470682faec9bfc985d7b4a19de8b3ed3f6e6b4adbad6ca5f48a5b39d93d809d9f93cf724b367a91f44dcd3c8c0fd4edea5fb8439e6dbb96b07932e41778d55718e809f841901d392b7e326b4190d9f4b1d21de3ccf6037169b583917918efc8fae4d636dbf8cd5f931de6fe644797b4fb82a1972d5ec111bf218897d15b8c28ee7f8c7ffb8748314e7d9d628cb8e761b3d188efbc95a06132cac53140877eba48d1327234b777dd2b918a4a3c57d365537cbd4ed1a904523d8e4a6b49f56defa367a0886261cc4cd6271d0ba4fa8c5fa0203ade09ab3fd6a0423152294c053d4709d665ed0cb73e4048e78f560a73225e7f65e159f11194b11df90e7647ef53c6ad0fec492089768b0d5c361731dda9b0dc25f0e476f556a97d2a9d01d5a9228a8122f95d4dfeca78691d1c1f0bd4fb17b97adc00731e09c22d529cdc2d03fc39f62c513c539f392dedc25d6e1441337b7c0fe75ae2e2c036d81cbf347dae04bbce113fb848ee6fd52bf342472668cdd78db5f363db551a59e5e32c5d4b3fe5d806af24bb51294fe4015bc173bba51e47930f2a412ac5183ad39cbdaad5425c9ae18dbccac3b3447276954a1382bcdd7705fcb528ccd713678648203ced43202ef34958dfbb5bdfe70e9bb8265002d5390ecfb16c8b85b16c03bdf51afe00166cee43403f1f2fb3b701e0b66ecc3192f4493f541bb15e26032874e122331e9b0196f1bab27746a6ec2f6f8c2daf70b3da6c104c871ded613a75eb2fc4aec5e07434c7bc01eeb1483a8ba5445d20619d893e3dbbc21afb22b7e27346e8c76803abad8bea5f33643a9e30f9e9c89f57d30330bbf507cb8499dc7b1fa476e5d3d555b34fee7e23d1691f08ff23a05eb0c4479e1df2be4577258726dfbbbaba30b3d978eac0693075d63968500f5cb2430ab606f29d9ad14094d9bfae1d2e5e9ad842e2afea4a6154b4769130424c3dc804473df43db22c313f285acf677bebf0fcde0ebbfa2388ee403d16034dbe47a5d9bbbb4b11171169459818b310a90681b5ee56b97b3e56cd460c50f3cfa3e3de920e804c5dfc1e7defe209d440d29de63f0e258984582261051e56fa1e9bccbee38b013ea6caed10d52d92240bcac8a07ed1ae9d594a35837cc175eb0ceb746ac1e43527d09285eacf8f068cda61f6971da9226e8978eafeda924be99dee377534e93521ca9fccd1f0bc569eae0768839fd63ec74b28afc52d94566a363472100f5ab8c166b4af1752edfcb44cf2207e2a7f7eca39d9f11466d134fdcbe66f9d2f8779a04542e58827b3cad1e4ff675d88a26a7ad5817b2cd586c69bd001caaa55006f1107471a693ac7c5aa63eaf692453a67f113ceb66501ab0bcd61a7b56365f3bb3dc1cb75f50a19dd17a86d185e7e54b7ba447e2d573b5c847a81d587a67a7375de594611208efd35bbf5b42016b5af3f755f5f16670b3e1f96b3d73ae5527aee661c5023d1d35a7aa8ac4587f11f8ef5553d71a64d54869fc818833a1678580b172f2388fd4abe27515d1796d10e4118d327aa572bc74e5d6b78f643fd29b71b5ea8a92979264a66a0f7646bf40bdeee49fcee9e6666a32afb11c1f3a2e077d15542b05ea5816b12fc3e2c0c357031401434ce05ac48cb388c89ffbfdb7b2ccfc534c1ae393b0a6a2798dc67d2accf752da63f933b76be45cebdbe5bedcaf7321758280c437e93b7d9a50376ff279067adb87482c3663975d8fd0a1eba2c36d378ba2f1fdd43f4dbc2043833ebbc44864f71d7f7ff779ec08c76fdd48396f2cda433861c841d384902306ed0157e83b74213a324ca818a4e4646190c3e1ac001a1c0cfe84435e67f0f8d98be0e4e11c3b5ad83577377f53372174c7ea878e4b9b2b9f6bb5cee4a762005067750452663dff330659edde54304bea9a5d5289b6a95e9b61d17ab8d3da117ea7013a1b592ba71c2053a814e45614d1e9761b1dfd68fc79291a31c39879b5a5c951cd79edd789145921cf9d907b413fe1c796b47e85894d9bbd119abc0eb3cbec1749e445d4965e2ed35c8a720a60c0a011918a1298333e7cbc04ab7386f63e1b6f19510249df3c080d11ef9b03b2ca12e385d70f84e4450dbae2ef751b7bb237364e6cda46d543b12ee4dcf3f9dba34d4391d4634a54b95d226b8911e5261e41843ca5c6d055a50c9c5640e2644e94542796f495b3a67345d0a5dd317beeb87017135c1a1aa7cb5b60bc77269638021a2cb3a61186e56a39febb8402040d1b760a09d0a43a456a86c788c3de3da4596a9cfbafc7fa86e165f7db33c5d1d3d3535861fd9e47e28f15527c204cee96bbc8f70f14408226c0454e064bf4a46f077df6ee6c830279c0643c5906aae54742549d178eb97f3c7cefe882c57d40b916a9e28f916004e4dc743a137522296df45d79a5a638904c4afd6fd533321fb1b0765f7814ab158cb830dee3a18c5e494969ba06a7527346a319ec5404ae9bd1209f32aef19e27837e3d46f9f3d381745da7202cb0c15f7bcabb89f2f586c4722b9e18b39a6df2b41fe265257e6c44667fb715ab1edc011026f3ccaf1b0ede6d9d0226dd40efafbb04ed9dea581712ecd6386b54b129484859330e63928e12b8d5c3bffe0a53f84d2e34ce2abbcbc797ae757031953e6d62593c3c56a8adc6a249abcf4022ec23c8556cf267fe2f195b6ac6435de66fe323494d8af948968df2abaecc559087cd77eca0e80af9cfad4f850792e871e80054add8e615f0a0e529e615ed4e072841c3ce98d93da9b9938ded4ffce7fccc4e74dfa45e20a7c8bc6a7e1d6f344d82e7449942780b9d9e99461fb45c40faf941affaaf101725ba4c550df9c059fe97a787b24644a50d4c6c33811db159d9cb305fd6f828c12e446d64e36d68a562ea4a11c62a8f33e30de65d6a8dbb761a0148175b0da5971a13f21c41c1918ef33f7d02b913e6e4153545235ce8bf602d0a7945d32fbe9246cc99ed5c049b4881b6b99e3296250fb7d621b6b9e64aeee42e8fd0aba8238d62edbddc650c1d9410578fa6245b3037f628592e14b9777c1d0c097627861753915a789d1d3837fc8fcc49fa44cf0ebd7afe48c842b293eb6767976c6ecf0360e8640a998138ebbdf7d0df0ee638df667a7b194ed412068ed5a224d68a185a4ab180bbe4df38e7624b9f80c353cbe2b3aa97b14b059caadbd19a9a30bfc8b826cac23b1a9a12d6ccc13c456a9047568440ed71533a38054d0b28ce4cfa44f50331a5f62ed5810ed5994bd1e65a2085fb5f116e70d3980e86f285a53fb0202ccc0fa8c68047c9f30267b661c0151b1d51f640bdfbe1dac3039740657dab99670c0562fb1acdca24a03618a66c247b7fee2371807831b77761d230d615a11fac569b8e338764674bec5f76d8767fe9d0e93f0451027191edce54e2085f9e356facba56adda8035ae7e09b9b8107fd2c283f31fcf87ebe1d7b39a767a3037f8b23fc4c2bf89508ab1f1bdf82e07e8e619f792f7bfe0bce95b04f00a5f9a4ff2f1befd42cc95eda00ae53da03efef0b46c9f3048a74afdd0b267695a8f1c7471db841ca290aeeea91fe370b616cc690d36971ec56b5b52d1f0657946dee56e6ced21873a20a6906e3d9fc4f6396dd713db06ce6a904f7a8885671a62ca9b4f7e6550711edb1621491fddc5494d2e48bf352ff410a520827d9747a24cd5a7921b246fba7e753f67ef4a436a9a601595c095f075f97aa6813c0986c0cea52a22d37a469e173a0588aa6f5c2ab3e73968057ca0c9d7d44b832015ab6d9c31296373b6e2d13998ebe1a59a2d98174f7bb1d2d7a18ce6dbeacc0ce3ae9b2eaa7fb8b11d31cb8a955717d6dee1ea66ae9ade6549ba6d31040de1039958288feec0778553bcd614dcfc4eada6f3638dc57e414c8bb73c9c6df26ca8cc3686560eee6599ea8a0a8cc23e19051a6b8be40e4c0807a41ec9060ae37bdf8b7148b4d6363ec3af8473c226576ade98cc64b267f4be69f949e35a4c3fbca7abac8789aa8ffffcd974c0e78a2c1a1ec1c7ec10380ffb88855055f638358cc9a3405417d8e98e57fb53f8c1682e9c8773a11c7979a6866e2fa1cea5dda7fd4f4d1e33ebc6fa603f616396bb30f6b5b2e281ffe4943580ed33b122352772b5a2f25890b6b9e07716f6c24d20c9cd0ec8dd040347b94afe0d975b84e2eeba748bee208fe1f90588dc3950dd8ee7afb97082182b69ca9dca1830edf0d4a419509736affedb9b9421667c11812dc6d4fb7c5b2dc09c7244d8f9e55241478a5ee398f248168ba3499a50720b23a1c440187fce1517f903834a8c15f3a520e3afc7f864fa90b8461c38d46836addd5060964f12eb651d25ca074f783c8b6a42a72d62a4033361d0d8c58ad2a28c8331df8c7e95ff271deddffe8c6c231b83e97f14713e5681c40e4bfbbf2a413ed53c89236458819907a13639e2fad16d3666ae08c012ff777708d9d6068a867f0cbaad88ddf9eaf00f6507c92083727ca9939b57529b5062fcbfbeb7d62cff505e472bbd2b17b1f4cc58f9d1d1647f36e1f13307410dfcee8ae3aea2c097ea6b3586bde60f7edc271b1aafddbe0a876f3de7ebcaae13d9bf97dfa2ee90e1771bb1e66ac509d4240d0179616d4667c20125f7f432523ef510d3ec438dd2fcd0b8781a8e71a88e86bc03d967c99a06e8449a14914f68ab7c5808a30782c5cc646b8a2a25e07ab24ba8833e76306917696573c1dda9985f0afaf7829e1ff381e72eb668d009418e51aa035d56cf364a26cb6126be5cf32eba90ca0e48dd6ee1fd12ba2e753066e10a4e6d0ce33f982aa76c828bb2b8650c69fe12d1da4e57c1e07e63d410cc7839d8f76e0aee003a3d570e4ad51173d9434b467c7fbd164a89573d44b70e85c9aff441d9b262baf9f441192de273063d26711aa6011e83fec8cb34553c9cad4ffff61ff1524e9ad6c18a6b3ba732a1fd4823c11fccf3cc5cf6d812b541b15c557cb2d6f9fe02d51e9a8b9774bef08a5de6a03442fb1ed1c1b97fe1631b658739ddb6a2deff096027c0984283ec2828494928f4a5663292b051cb6a0dba92181eef7ac0fd35281af7d45c617602ae4614f2f007310ab13648d21167e1f49304ca952e3d60e1785e9a2a1e3a90653e031bfbf0e097f744b1c7cb57a3e6b919865723aaf414aa3f8f08c0dc72a3c1a67093ae14782949d7f3dfd332ae7e048bf3d307906869ea6c22d3948602279f1b6b2e2b045cc8c766e8f080686a5402c944112ad08611f1aeff5a31ce04b481dc44d638fba784ce47a3ebf6cd1f1ba53f7eb3e6e5004fe5f0bb08a2889eec888d3e9d61a2599c857e182e024febf178e32a91498e13fc2921d8f349559edf6d93e9844c75cb38dce67f953cd200fdd03e37293d71999cc51f2097ff00a121b5667d2f71e24bb15ae79eb4ad2dcb2a137404b312e31d2cfa2be796144664e7aa83dd8e706fca3fd1f5fe20fbfd1c1b588fd95081a592405f18c16bd92721721930b8ab8575c8af103bd452ed9f90b66bbab58d79b7d991db368d09e156f4bf1adc595fd19ba32ab3c435a981c7b41ae8cc7929d189e31f920818affd99649133237b6a8fd6f39783ed817f9605ea2ffe4fe5dae152684e223b62226d75184ea266bb700a2b1584bc2c9924c017de134ca6aac81c6519c38ff95e2e6818b6262492cd20ce35e4f0a37fa6c9b324dc38f7ba2c67450e5983095013dd02ee3dfa692bb04ac8f62ba4e5ae941ffbc05688961052fe08c97481c8574e71a0e393143ac74e5e1ca81c1ab75d1a3121ed22d351f07918918f5dac4dd87fe1dc3d63e243388ac5154002f42608cc66291973a857a81e94998046ee75e7de002f466f75e2b453163b9576932757395efafa1fca4c144471adca63480dd08f00f7ebd03688b8fd5d585d197be283866ae38d0e788b5252968d73edcbc8bf0893e36116ffdc23fd49601e7a99df7f72838539bd0b5243c90495b39e7766f81fedbabb3e391ef806fe9f99e56b2287637d57bf425be20b47c5e18dded97c3ec238a22610c1157a92360da0544a86f24cbcac104ffa4e13132420441f2d8a0c21f87010ae7d5f3def4b987e2a5279982d2d5e317ce176bf5ddd953e53b00cf72d0016af19d8f86ee5ed96f1c39296251fbd2e9ac7fb83d1bf981195bc989e2f322be920fe1649648dd768da9280ecba93760e7439e725a0fa54a4c88d8caf9e7f47cb6217112bbab5cbb0ae2254ffbc8ae76945d4c114d0b250485ab1791fca3328ca793ca83a448fcd82a8fee0804fe90484ef7fcecc344508a84148114dbbe9420b44ba749db35c56c7ce9e35fd492d444727146a68276b37a83791bace5c5e512039cae374b5147debf01b078076cd251d17f09a170799c2f14e780692a9384287a7496cbb3b725fa80698cf52b1f45eedb93e04023641a41e1e197acd989951f91887fa2c352122f2d51f8073e85b00f04607e6841829ec7267f3e0be593754f5734799583f8b9d4d16f44a6613aaa849cfa06969120f0dc014a28d3372dca85742efd1fa42b55a137c957d589e53fb585f1c303f21fdb49a4574bc964464e64c737c6009816a5305e2ce325ee2e573ff0d3f61107df71bba4be0acb4199212cf2203a8a0201d306c1d53fce5b6d71e5121a8bd6d1f8f15df810dade901888745db07bd14f0ebb13f13f71e029e93ce5c38de891a9bfb9c57f964096771dbbbfce96496329d2ae3295361287132ecc7e2f3218f25b9bc7c2d654bde1de53fd5917df3310c3abbc0da9f9ed15992d14db93b92258684565f9ff292ec62825a1201817550d02f664195ba7ae77868d430bcaf7e95c11d3e44424ddbc9e66eef62cc5c4ff1479874591ae949e7f0707f26948a961ceed3cfcc52c715fbdcee8bdf215c64157259f5d080b19570b948e4c8b24bf3bb1a19a882d74e98183094d34b6afc1ca7b5b55d449247a8ed2d5a0115c6ebfc6f4f1e28322f058ba9a711426e89676bb3050ad5d18d6e8d082b8bdc966a69606522b4ad4b5771f7bb5904f9b2e9c3c11ac755a8ca765da136660e1a7bdb82b9a95b70855703ab2ddd9f761bf30cf22c9101316cdfd7ada8f8c253f1923d7b2bd864c0d3472c7b6552f36b706ad0bbd95a2482a6ca14432c147979400c1766b321bf4bc50427572ab659ecb04266a364266323b8fa598ebbdb259b5a111f45853a680718718487563cecb816adeae93b2ca2d82bce10c314e3167730c525ce3fa53c1e7397c700748dd8b42939f612688a2880a00a56c326c4c6c960853fd4c2beafcc7ef3b2892bf13c03cd92b8f27325a503ed5993afcc080ac523388b3db0cdae0b1e29393ff372605f9673370dbd1b60f74349e3f9bd5dd3222345f628c36572eac9cef433b71df2b1c2bb76c6446775e857368f514cf100af7a7e258d610922767c646c63162915b9e37887a110cc6b6e593c8e9a00102344793ad7424c76112b0ffc539cd034925a1feaf402c0b347445ceaf71a10b2b224a8cb9eeeb9d5dd208d198363aebf9b8d707f71813b335e3d7d7f2be6db9c80a099ef2327846e5f04c45a808c910ff736401c0b70e396dc68942f093b84879c9013bf15300e85b6a8b69c355b6c490e3ec0dea52a39653e60e7397a85d2abf54e6c52e966c4a657299e4246d016cfbdaa54b5aed6d803cb2562c2df473ced8a89d73bc00edf468ff06d184e2395271e1f63c30935a0269be49a4f02454f8a388cf0b136e0b8ea742c310b45f558c0b6ec42e4c731d9841fa2bc81bbfc77cfb226e8d03f746e1f1825d7ee79515485f096ea316f820955c76a34a5782c5ab61c9ae0896634660522d5cf31e8b91645684ea6aac106606647aa3057a824baab2709e88950eda802cfda7147f11891c6ecd94c84194cfa744a0d30e2c6ea929bbecf6ec7cb4e46e825f9cb22ff8be5047023ea40ca2715ae4458415ecff962db8bd2d3e41c5178056b4dae5a27b9ec195f37978d07b31ef3a97b1720925fa3deeb930d49b1b3325dd45223762447989ae69838b05fac64d348e5130b831a2ba6910a9aaf6292f90514be9fac2da1dc406501e902e6dc8b46accfe317da0585429a2277559860d9f14b0f76f405c7c0c4d267b02769b8360f50d80ba393bdbd2c1a4bb9b073adb5e56cc8a671568e0230c85659996907bd3c3896dc5a6f6a99a06b9b59c8e3781d7c78b5f439e55684e44f6c3276172b24943d6c2ee3ea892d676df507452e40fc6e515f3b4eff478ca951f37c297f03b28b067ec172da9de29908fbea445f68dc5d167e9b26daebbf805a4074eceb1079e3569ed04b8f96f188aa0583e262f4df2591ac9f11b3a2e9814f6095d5bea6dc1cbb107200a643e58d749d2d1d224d5469bffaa439c7843d0aac1989a907334c27344481c64e34b24fb6ddad832326bca4492150534b044c3a05dc06647f0339d46818aa0de5cc5da0d3c87085beb11788b08074477d308c2bc3ef90db02de97dc85a028bf828d118790a13314c2f1788c78251d05ab75d50edc40f6cc33050935792ebc09b1ea5a871e1f98be23b772240c3036c80975043087b0b1ccacab82c7e0f45812fe32d35d8f21f45af6589428abbb929f6783a7a07d0f4b2bd2cc5da34afd06d75d5b1411a5af0b62920b00565f9b6d93297558e96671151404b5c3ac50adccb3c5c99df655bf299bdc23027c5295ec3c659e05cd446db7ca83de7c4ab5b8d2b699884ce0f678f255a9f1d57e39f7b5ef86e41b5f73e24b6d16609eb28710f102bdb36a7ee9f1c39b2a0c0fc2142cf2093d73176bddee52d148a80c95faf3e35e07f536ec73c98d9cd5b6c599d58f67131dd5334d36cbabd1daefb9a79d9da9bbc5d1cccbdaba98f21072241312a9b334ed7431c571bf5dffa8c18a9ccccaea589212c5efcb612215e5dff0664ee9d8f38d22e2c09d3074b82dd311835c065802f698e4bcc45841daf9bc27aa18cf4d6100da2dd68e40f744169179b2d8e4f6e6d629747e43f75c39344be8e80a36c21159c86373b0a2833a32d833b41f356be13e8e3b01cfac3fa8bd48651c26f43f879790a61073b798185f62f9cf439511c3a19b7c3c75287eec6dc637cbd48d4853c77c71ed8d8bc5102d1563909a66c7c21c1dbddf0a5e6a8a8778021d320270e018ba4b70d52424146a76fa4e06d29719746fba956a29b140f99836dff951dd15f10ca66a276f96bd77945853dce7f621479887b002f7129159771cf8aff50e6849a512a7e011fc7339133870fecf4b665cfb8a7b87afe6764686ec93e2713092f95fd06cd70b2aa66e134defdca8ed401285d0d8b92cb95da68143aba0e00a5eae6676eb3135da7d0e0bf565ec0dfc23c35c288e7f3b770b645a7f68e381331412e459cb26b40d0737670edceefc28d53afcd3b1fdf8ba3da92359dadfd45a2de76f38d565a57ae1558b2b9db87144c4e5ebb4af7187623bed1d421404dc6a168e37c833944b1499d9fff92aea67c73fa443252697ccf6c1a85154cb9a1983e3efcbb399044d832eb978678dd0b81b262dd77d4040a3baf5a4c8b77009816e2375d374176b6f64dddb1de5ea064932f5c06168c516cd4dfdff5aab5c96cdf11db9bc5a4d34ef78e5c82ee49dfbb07a888b8ccc325a99c68917cbd097b2ed1dd89df40c61ca151e67d67ba0e501029ab3f49458bee4acd9c88ebe496d7ef0f865b3b6c1bfeb72c8f942f5957637050c51d41d505b461e591fa513df2fba567a1d22dd6bcba7e699a36c033d9c64b396be36ad229c0750768ce5f6e84cf5d038ad6a1200693b461242873c3a4296b87dff98b8e8501f4f356e332e4be30e3f50025c7ec42fe3c2adf9cf60d670a23f6c0d655f3b3419cfd8e327b4ef86ef586598c08e866e0323235af446661e60222d192eeaa613e0e184a1ea067d136ccfc5045ffec50930cad33cde0a72e7fd1960959ce704c982600ff6b92ef877941bed5f9bfa3b2c59851d4116f452025a5b017133cbdef89030166459b0ed9a04bdcca6ef02890a07697cb8f92b9c14a39f95b3c4c0734e23c52dbe7019c6da9ecb28da9054712782c8c36bc1b63129c8387b7dbfb438a18ff9beb7ee2bff84377d7e01c41cc720bac01eaf20d058de34c49aae911123be62e06401a4b4c2aa2e74702e959f670aee825296d56a0b9ab763b1072d270904a7fc0ea2046113f820158e4729dca32bc5f650a94e3f1c79702a7a8c062ce45e42c48a725481a8c11705d57ee378ec5486b2bca6974279b12753cc43da7b75cd05ca46ac50780f4c54be50a8a6f6320e175a5e0fa48b192dfe5b88985619d3d9eaaf8cf6ceab8ffcec58652c0dc602e137ef735f05de0593b1638f6bda2ef2aae3d1ec25a8842bbc391ade763cb6439826a444934aea559e5283ed256726a35be223139d03395c6015b459048a691bd0d89ae8b6c48df735f88d0a2f65dc2bfd7158cb627ee71ec30bdc058103db974127928f114fc4b77fbd3a0c977a699c2b492f749c8a42d6d45e91ea5df44356d64b76827049a0e1aaf022b82d0068914fc040c7f64462ec80b4b56eca09c9e1e077c536bf8e64e6bba5f35add8ae608f7e86c1614b6f085dbfd4b3667413b43a5574347da35ece8de802384fce05bc32b12f42adf3550a40104ce430dba60cde22bbb31d37ec48a8f38e18a56b0a9daeaa03c3ef179e13152fc7c7999728484e7c845dce9fd35bc84121adecd472fec835c577f49f3441370446cc870f7c5df4bfafaab66b8968bc4104933674f8999bbdd788d587e1b694b953041ce34796e55717af666bff0143b1039e574f6f2146116d2f849b0f8d94b98ceb6f1f5b310225995385d25330c44cff6cdfe1a7005b3e42e2d1c4c3f0901691063c440feed449b9c0135ae44e64a24979ae49ca6fccaea0f8d7277d25570bcd99e5e7dacd0951b6228ba15003e3235e786d29fc893c6e99d5bef7fd8f84d00a7e833d900dc10bc0d41a373cd22d3f8e71bdef15bdadad83b51781fdaddc7050dfca90a28b2f19cd32a258e6eb8d3f738a80afcec59ef771f1f8cbd3ac16af8c11e24a666afe7f5cc7ce171e2a8e249629205ef899fd0f50c11f9830070084d7269939b071c1ab40c2ecb6fd76b9fa5b8c45cb9285c1d5b1b13e885560698f3a0f97e2f2ee9014751cb264212bb4dc4ded27b1e521a95b95e7605a8d19fd337a0547dc8b87bd05b0983ce42021690feb64d5728a45e40a19a3191c395d2b2ad084a2092ec59aed1ac6a56353610b083c7af3912189e1f25ded5e4c17e74f92ca177567831ef86593588285350582dace5ab534e293a16e096722500ed17794e632dd3c08a5a5c027c02f596d25ddeeb19ada57f60f99a55b821e814e3de1aba547f8a9103bae2d7006db607197d09c04060c5997ceca11f0ee3a56d91b9577154f5215e84628843fe9498f5e7e0d02e4f7d9609adf1a758a0ee85849550bd61c88679762a018daff56cf9fad760b900648090fe9a0d416a6a15ed8ca0b7521986b3093b7c956e2663d7184d4d545c3c2ea5d1d70b54fa4c17a3e169f753765f40c297f49559cc02c3159d8f918241d52c5e6b62356223c9280d634682d28ffe66e260d067c906446f1ade31a6efd94234e2a8da13219f96fc70a5c2f050060c581b695e8bf4f49ab84ae56b35abcb53e66e67ca1ac004b5012196adc76060f93c2282acfff09e4b27ca81be2dc36dce7fdc12a62c041a05e97887f52bca342adff527a2d92989a6427889535ecd47df821ec47f4df3e71a222b32ce951dabd0facc31a48a9125e7825e99565c27015739bf56b2d9ccd339aa8c2b718dcd25f775ffbc2fff52acb15ddc92437dc3b0f0844c1e52a3f8dbe704a7cf42b82657df7c06814b91691caf88645368d0d68060fefc96127a49fb37cfb731a1c09231561e78e73d045e81f19c8bea74c81cf05364a61947a1e281fc3e8643e2317c90897b29e5f3cbec94a056bafb52f767222647b2f1a2d0291bdd7f25d16831ef4d99d9e456e69da8d9524bca59c59fd88a68497c70f2272c20bf2cd41652369331ff6dc92a1b7f16ded29e0a4bfa52844a66e93e3570901d53f6aa2939107f3eb5e5878aea81eee8061f1a5fc0bd8d08dd84b14cce89a221b8b6fa08b0f73ed29186c56b26a09a8d85eacf07126a3db634f94f1829995968d49a8a064e10752fbff7757ad26adb69a74feb1d6059e41b92439fa690c5b1e48522342b6e077b6a91f39333294b636c430d695574a2df8ba7182c63f00d9d7bb6fe3d5ed5c5c04adafc039592507edc1a01a39bc1e7efe479c7748b185cbdbd391e57d246e8aca2e5fbcd3ae34c8f6af2c6c01fb22c0c60a0ff9a3326dfc8092fcc247899f2cb4b68c54e52c50617da77da02ddd1a0b3d5d895ed55d912ccfab348964a2762cfbfd1a8e021ac7c6dbbff0665dc78ba6f7d1a0955cd6eb41570b73dbc3bea07f8137b971bd5d2776b67842bd2dc2bf5db2633729fa6e036205375102dd223e35a30c74ab32158539911f4f9b6529dfa4271db9147f31a9ffebc9f01ab537b37e6e5a90d7cc6ee968074f4f8a570bd603c7b9f25197d755e92aac7dd58a57aacc78ce513b7420b6ed08f53a615c92a3e2c468bec1ecd7297e743d01a999a7bda3d013ef0f04d54c32623c8c609afb26d4c03fcbdbccda567d8164bf6f370a9d95e3c4a500e1ead26922cc4d6a309518f9517fa2e540b039bd5c5e9b1a2b829f91c584c625f7b28459b41fbb01936f8e4087c70d7de84cd2a74642c1b4eb45915460ca6d0e2e606afed9799797ec76d689b153ac8d4822a92e96ca2a5e62e826d123eb766801adf1b8aa6c591ff7f6016a10b1d6fab962b8057e847c234b436a50d955abb72a22230d6770d668a594cf44513a29b1b9d054f1c9e50c905cd5318a0305b878f9505e7cf9007d57e41ee5084a49122f2fce6398053c7bd5b6e593c3643975399fc8a2bbd11bdcbda53b6c8c1db86d097f427d1ec9eed2a27a3513d61bd388","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
