<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcb95109f9ffa2d33cde034a672be669e8c3b10decbcce5da27fb3cc6738be0246d8ef7fcc4f8bc5285e1a13438df594ddb1e92e29a3ede61899e3716c1a8ab4546435fcda550e6783d0d17c454cfe27a027995033ef3d9719a425bef8243d9894bd49b55770b3f36e74815c3e2704d19bebd5123ebd962f865f15bcef99b8aba475e16bc69857972a914c411855dc9dc6deed9a8451d5c656ed810eeb1d11ec297ecc2b79cafb0cf569d5a2556887f81e6c08edf50a309af62840aac12aacd7fe1af0a639e3d62482a64aed5f20147a4f40682cbde68fbac5bd49dd1654e25c8947936f28362f8ff0c296f0d3ace8ff7c3e11506575f22fd37b6d05c5ede5e7a118ca5c08b204c0870dbc96283754d5268d85a6aafcfbd6b0d6a29e2c8a64437482e4cbd628feef775f210b7d8e5488766c61909322993668e85647af40ad42b391f08e3996c1daf301412bb4be9cf7628a76259ebbb5717370e07b1f653386a5d6594fce25458f2468c045d0be265faa72466f06ffd129344ada67705819581e7c52bdffb7eff44ace7d30438ad9954b5116ba619987269ea543f22decfbc946762a2887bfdf5382c9c0dc60e3059f418895951e0c48c25d957bee2cc4f3e60fa3230ea8fa46ae8159802a6125e48c5a18d0a8fe7c16a86eeecf7141ca46d337a2f1be9b2c84290211b6b7a2603e47783f39cda886ef129660da5378e32e5c168753fbea82a42710a925bfa88fd9b11abd2f20e50c8e10fb6b2890e48d2ed1123dc42693110e5d0f2cc823fc93abfdc104925b8b381db7da9457c7db9e7b37b485d7942c005e7e162ac473d0fecf01a3cc4847f9c2eef1d10cb1a2830f407825380be3090f62c1eeb36b10de082f46eec9853959e1e6a999c9c3d46a205b3fb5f2de40668b7439d7597262be04b0482d3080c77508dd8c33ccdb6988b596466e5dc45013e56cd2740a748fbef9b73e9efc067551236d1217fe6b0b4bb4e90dae2a4f735ea898e5577de7f074d978467c8e6adfb307e2a04e75cde5ba46749182a9784c87388ab4b8644e604a1836e367619e0a478b6d99055f3cca0496dc7cf5c611a26c285e7bc66e44a1255c12b0b871a4168186f0977e179b61e305cba8583c2fb4a7cfa5a7ed0c59ef30a32661260efb8c13d64bc91825154c7633988f8c70f4da461f4fc251e0d35d42c3685b158f7ab7de106e08ea6f64c60b9c5f70808efd05bf2c393dd3acf234e120d64bf944c9c1d073d33ca1037b21c05f62d710e7c1176cba9a2be51d38c845c75de06aa07cf79679ee742f7e2c147d7bbb96b44612c1b96ac8c5686f0cc4eca2849150a5dd4bdaffee0d2f87e8f98a8740842a2ee44e7b77bc5bd0551a03caa704dd04189b54488c7100c7865d4bfc7ebec5d46379918172f0ac012da6452bfba2bd362110a62da26c47e672c6f67371a17159a4e4cbce94fe78e324a7bec5f4a5aff09ad12d106eff78846614782768dcd9c196b0f9f0c02954917763e52333559bb686376d9e839a2a13341e65f1866e596fb88df6ad71a59c37e2ee5f0025a7bfc45906d08925aafb97d5968872a9f1f1180db191dbc96bfc9da105c429dabc6460dcada6b41ded09c35dc1f871cfffd6cac6672f3e8573e70dc8ae84a85cb615c0b57591659b6bbe8f248350fcc392c87ddd4d11dddab5ed5bb38c595e9645cc8370e303a6e2031767d510e03f0c97f81a5f69fa3e23e9d96b876ebd53c73f3d8fa573c42894972c2d9a4002c8c6a98f6acd4ec4f0250434c37a1fd254108da75d639ac8203bac743b54dce892a727348b93408972af9f403e2e7aa39b65ca44df9666a8b2f00a4beeb251492898332caad02cbfeca68c9e56c234c3f593095f0558ad929a794407401297269e503078a74ba0717de1688ccdc940c98f4104a5881252196a4adb4169c81f6e2b906e840b7b7866c7c2877fe341833b44c51338da4dcf42127e9c8b63b1ad05e85c2ce22ca50201dd2ecc71c9a7dba0b81fa7b5e7151ab993851fd388fb27dc992f012c4190bb6a3319a8a981f7a73a4eb09aecd7e4128d770e4e9f1f871956305a156439ca3cfc847a1497d43afbb8138447561c2b51d731c70f7b4d7b1bd16d5d7f2c4addbebc7a5239e7c08abafcf44edae4f3048d3f10ea4b80a60becfe6e552c32ff4df4ce0f57067b5488df8b9a5175357379865db9c95f2387d7b33759d20af4c43931a489bb23a2917705d4f6e415316f0e29ad1d36cae096355df09d3d9e837ddbbdfd29341b9d9dc96acef1c1e692c5aa32c188cefb844fa161e554e78f92e1b8fceb82933fa356adbe10d00df61fada1635f5f17e78fa1b99dcf2375c1a2ca352fe6261f2317e8290bc87cbd4b80f8d265fb067ab758cd250102048e92e6cb635a54c85d7c4f3e49df80c1c72b10956e5a6df43a2853d20a6ce2599cd5ea336ea67d79f8cb1fd378d2c2db3486056fd658d3f70b11f3f35832cff2e6468cd12442fbe642fb1cac79f6dc75225fdb41001867ae06717c93fd02a12e92c35dd7f56199ec24c43856e0bdbd2cb0dae9270f8534248fb427bf385a1102007d065cc1de332bc317b626f0f63c4a3d99a00b1260c48c1465e3e057951398026e977b2e0ba8713d6938d39a78a71c4ddb3953dd29a9b9015c0a1f55596ced863ee5e2b6980a65f20622428b6daedc86e2e2ab302dbde950289352481cc232d39a82bb00a461d2ad449a37d3764ae262fef3beb732a26ded9ec5ac819cc96cb313970f95d8baac73d380d84adf7e6453d62a5722fe139e26006612bf7f8cc69fedbac0a1e04dbfdc85144d729a728f6319c08c012bd8a4a1604fbe8313ab42400fc383392ae9bda45a2aa226c84c150e1bc016c381fb0c6d5cee299904b21ca618ccc3f272edef7cff1c76a4f1c465ef043b4b4d9c20aecb03566dc6af5124866147e313b2321238e5762c09c79cdeff5867de9798a1dcc93269bdf88d2baac86adc6ac0b028ace2e61db070cfa111052aa57b0a74e2bf80965f4e19b8de035c405d1fee0f3fb2900876520f3883a9cc458961acb5506f87c62287c46d5ab04af4ff24c81eb63224f72c0a8f82bbfb56d606087e467cdb43b6842af888ccbf4569d7df93e80df9b655ea8f7528dede28ce18e2ebba3b720d8d4326befe102e0e57bf54e95298efd60e0a809519c1e9cf94dc1283073c27d4307ca2109c855728d50537556f2eb66f45a31178db5e6861919cf1ffeb2f9d2ba95974bb477fa692a10fcaf8190fabba5dbf3f54b1b53a526d028dbd716f77e6e80abd322a89edeef7b54df4a54420875f06c8e26c907debaa32abf8c2b4b4c42c92153791c0b210cb4bbfb74eac676b29419eecdc90b8447083c7e5d4f75df843df59c620ebe5adc9ed1b5364e91783e29e41582ad95b5825cc597fd132657b79cb6560bc1382f83d5b5240f2fff9f9a1211ab8a51119f884ee370df8ced07924158497846d64748100fd032844711fd4bd238a35e62bc8419f454a7d038654cddd6101d2b1a31dba5e788d5bd22a8ae55080a1e90a62faa7469d8f8ba5a0ba23480ecdcbcadebd65223d1ff1a97f6dbf62bf8ce3126be6fea323aeb81c6b5bf53ea8f5e5778d17fb71def67f2c64dbe70b1c757f0663a1826a9e05f944aacead94ad40ba0cb1d90db6c1c2cbf0d6ed0595cf2dc69e561ec90dcab763d8b89ddc010f182a2cf1075c5c61d1204f1505d5d5bd9593195772fd68f8d8dec58ebe4058cd85adce5ba0c4f0b22e7299b59e7f413ea3e7aae257dc808eae84b49850a9cdf5383b166e78bf54a8d82210a0c36e356274fa0a73bd92e87eabf957dac13134e9b50a38b9369ef75e3d77a88133010d46111f53e0598b134fc2dd21cfd4e54ddb0cec9d54bb1f9b7b56c3a3f53d41b02e2a75995a1defb7dee1aa2051b7f09586554d817a16ac7a288adaf5daa848fbf0493d45ff029dcafe981f22834eedb476346e680b3d3f9d87a265d962d769c68b8d1d4db1bb8401df2abe9f91759b7c0d576051051e7e33ebf14327797e4ad2ff0575534f413908f624dca0bfaecb83765fd200ba238a762e27c789d280521a67dfe1f9300aabfb1d74700f033a20ecd767faf49999f7f06235ca85e15aa375652ce6938669959c10dc4b169c60b5aa487dbe59a9dfbf38745a8bb48ced1bc0b24df3643b2a45b7570bea43bb58a1d3b7619be76c10d5dfcc29ec130d9c5a7f92ec65c44df5b5622dbf114e141f3b8646d1533f354fc4bbc618d473df3fce3cb161ce298bd7423b74f442a97814f435d8a260252744737b226e44952d18c9953e28b23c20490e57686e9a9488944a591fea0b490df92c065d08e43793c39e80292dddbb59150bc743ba7a67cba54a257576e25a52e3b5ffdda5d2b271727ef76446c9fcb42d141d087f7dcbab7f6fabc698636f20e101f1793cfb84fffa86da571bffac16401402e4f9990ff183aa52b1463b45a591f3222e31030b7570b5ecef06ebe6966708ae77ce326ddae703d06cda238a70d4516c38e0a9416e4e9b42d597fb8dd940930900b2279599bd1e05a36cebb96f1766f420923a4c170c0a52c1a5bb5035a9af37eabf4c44a553eccbc713dfc12a9a0544ddcfffb58041dd0c0e28a7dad25fd10577d6cf88f266632137f884dfff963fdd2559563d8480696ded575eda25c187ef469242b9da47b6a4bdf8132c04064b8d695bc1558bdf08c92d50b4f4b17162c85fcefe8be04abd1beb8b66b978e57d71c5f35a950eb60e62d7ee9f26702eabd8fc8eb910a12aba7970f492d9c793934fc0e2960be379a13b2c10efc045ac122f87c93c1848dbc70bd13e40948d936c0a2a47786af56afb532eab24d87f8b428f35989f3229373db6e4aea238de1e549c489549059e8e54f389d1d80fb48b2962ef2663980ef6bdf8fee00b469a1eee2bfaee556990924493c569dabfae9ea991e6f66e7e36dee8bd35e62edc19b0467a0af2e44ca0b307d62da7304d0daef045f81f437330398f36e8e8007aefdb089e0b13813804d649360564e734fde6a684adc2aceba89322427b80c231aadaf643d54728bec3085acf8c61162a8ea8d7c8db65c2e25c4e777dcabdd482d81717ff019d091b8a06b10be7196ea2b220ab980a2bd01deb3ed40e4b74aff784868c031034b9c5d789995ade47122beb45cb51d1ef46fe407b877f2f64b3ceb09a0c778394674c015b9f040db403bd7c9765cc4a28267c1eb5bf882f71669ff0992d50db7f667d049044adcab8e42385f5ae57fe1feb2679bb6311dca8ac76b00b1a1d5775f54184f686434b1a2ed30c2bb600330c50965187536fa1c584f773c49ab10497cc4d7cca66edcc0b3479d65f48a86b068f26da9f7b55db9061b882f3d730d004af8410be44ed41f37628e4ec9f91beeb75a0efe58230254f6739027874afe2b803c77ec24512f158a05dbfe07eb105bfb35bbe003cd394b9ad8e7986a3f5868b44cd329ac509957b9182bc972d4379e687f6c871ed86efb5f91e5fac9d3d8333a92b84f9dc399e84800fc9849c4349565c05f7bdc6c596238167a9a408c64f515f5e2564a19eec216ee7e96bd3f01e804d386f5092025d831dea080f8b201badefadf932f441dfe95fab81bf56636c33dfb99c886b0a77d8fd40d597b217f4d457c9db9ea1ef3e273a6e50d67e75b2eaa0ffab581814263c57c82ec00e2ec155f5d58f5962453755075da28074fb8fea438e60573420c1cc898ea70ee30fcc34042ede3da33cf8a2bf493539adba6435963af6703d165e92414b45fcb921c984acf83f73dde2a3e16516f481867a396163d82c47835327db8375daf8a5eeb12a07a63537ef0e04df431020a5c40e5edc54729a9d0599cdbe314ce4f7f2123b686a7f9c5b7634286a4ae4dd864cec03057e2132d88b99b577c66126be8441cfd5206c809ed48bf3591d879d5a6b3e7b40d6233fa02ed1a91a7d2d2786deb306af9e7e1b053fe7a7576c7271a644c5b49c474dafaee68f3d5a747d2d5533c81dd90c5db63d8733571e8d6f2206561579948bb3d6bc90bb1dfb1ff8c65f8dc37a89f9b51c44ffe6d6f7cc2300651bdfd637189c4e3f00454e0abae10b2b4f08f1fb1ab7f0acf198effd62a585b3646c1f612d36af46a5dbb04dac8654c602f15cdecda125cf87a88920f38bb296fb1d3d9c619476ac00ec119e95219b0c3fd68e3924cdbea0ce2178bdb1eaca12fd09446b97a2c2f3fef1db462be1b7bcf936e7a678e613a022fa974ad8bb3979cff44fc6c1ca06d5327e4b5e9649d4048749bc985f675be88b587c88ba33f31a82fc0aacd5874bfc4688a7ac6fc888abc74ca525ce574bb4becab0bedf6dfcf3ca63d5ff8fed704006347c357aa350b55dd06c010cc178cde28a497d4fb5d76737ba0d13ca23334189692fbca7367c21a4d05aab16563d66a0163bfa68669da667192da15b16a8f20b39035606462841571fd770d10969f0ded31bf7ddf16855154a440bc849042a08279a2339c34f11bf1c7e4daeefe3f2f8ba714181035438a3670b77ae4d3a8635b9ebe29545ed70dc315440d349e3431128a2075de57936eef824bafc3c70bbc98e98e5b1aeedfd6d2ea064ec1f308984e2cef814e4045651eaf76816963250a9b178a128a953741b8c183b6fa5f416d1ed9d80bd87f4e7ad1a75ed08a3662a978cf21e92e5d50a3086f85e3e267d50ee05e6abbe11dc270d64f7dea92d0c61de944bc0e230f404f9353869bc03d6762f958b0b314faa0abfeead60c0943b7dc3e541641371e7c3f1591172fcdf893e987f6c5254bcf01a652c2acd7b73bf93197d3c9999159f26f371d0a730e3ac4cb4e01438f33f29c0d48f9de0b3da1e911a85f5947268a8d8c05fefd3acb998c9d167010315804cb51833f6764e171a3eaa510f263b3cb724fd43288abf08fe603c91643272d24680d57603bcb4b8d701d0f68ce6ca17bc77832e23d9cf47549a03b830e134a1f8ba900e2b10b31f43a4825b56557ae7e2a3139372ec8ac437d1f1bfca0da2a3ebb72126b2a34aa8d694423bf002b702f359c34e56950d0931a8afba419a5827dd25e5e6dcc45f4b219d4df45d5082e23b6a9b293a847e4a8411480f5d35aa23bcd351901b318c38ac2d19fc17cd25386fcb3390779162dca5265924af4401d332c0c38f732887caba5e71304a406c0e8ef494b05ed596213923c35f720f966fd4f3164941bd72aaad2d48e55de4dd455c2cd45727222bb25530fc5f7a9ee17bd3a26b38da44455cdfb588c6b5aa7bcc108a2b7c2ae7d6a5899d3184b849f3ebd9d76d6b8af7dc464290f20692e0c1a429a2f79eac64c9c4a7698771c3f8bb188209236263f560a65f93113e2814ef465f0f7a01af0bfe02bef7c3124f09803537f56cf10466c8d7f37a7757c51d24d8d47b2bf32620e4380d47707d887bf89a002eb9c5955b56c4508ac906e3758721ebd7e91fe4722c20a76835a1aec193116ac8b32e95d5a61c41337856d85b0f5f21f9d04e01604c065501a8a788ec305d1449db22fe7bda77a56ff781fa8b584c7db9e95ae718c7c1e8f5fa2365a19039ab2d896aa115e5c21e2651311cea4bddb1eae942d58dd1fb47fc0dce59b6999a4b995f7ec4041f3665d6d682184d3590b3148c3c05520ce5edf8fa221cd26dfbe38e543102da745932636900b94223eecbeadfb057b6946b3516c31396709cf3d6fcf0e6f453c6cc488336abf0c9a50eb05d6ae2c8de99240b5473a1b34a2870a784c8f9d5ce8f56f9b6f9e683eabf9b1b6f27146d49d13a82f0cc00f4ebbcdecaff1482d8c8672d4398d3b4ef2dcd50bce2d6e161a38615072dcac800e880f2fdc0455637f65b7e2505da1a88783a6a76ce03011bc01917d792078ce4223d975c43411c8028bd18613ac346c7739c4ba3d081b1998018f97fc6b99579e29d88a966837f091efe8ae5f845ffc8756593a5e897dbfeec43e0c3fc86f962e2b14c738e7d5b20dbd5256fd922bb709f81cd63d47760f563cd03ee5398b65d134251f562c4d8fa17913dae8d12718da2d26a48ea5d178601237142c684a0980451720310c7da118c05bced628f93013227daceeba09bec00c61e0f946fe2100fbc47857bc820d64096a2a5ba560ff6684ce449dbb0da327d6fcd6bdd1dd6b3ecfa24a1ef3ec58e0ab0b012bcbd53ca8e6ff01595bf2ac3b44d518f03afc6c92117fe59bb1c45f60b52cb91eabf4a5fae57b1c56ec4dbcdbfcc354e7d9ccedf4c792a43827987569589874239265e6fed88e5b4e23cca8d9a6f97e96cc2df355c58a64172369eb9d8f5139e0b0b68b9d9c4cc147cabfa5fe9488d5366e567b29922316134a694f332a5191d590061432e127acb0558389dc956417074c0eb2984aeecf5b1f2144eee386e4633bcd5f50b60b31cd381def1e3445d96d74708b50bf058f5145a362849f98a69848765b5c80838b252f8d3474935c04da45453a724a3213e3d9b4a7ea116085f951f59f57d3d505334f10dbe01a2c76cdb12db7ec805e7f6b2c857e758441b337b98efc3c4d21d108ad7da7b07790a84c3decd4592fb97f3e9dc62911582a3e3f2d22188b4bde6021ae63bcbc09cc17379c5a0bd1ffbf5bf317ebbc5522b09c137fb9bf68ee645fcdf8a11679f62b368693a1bb3642b4458714b35c98bb48e409b34b24339db2293ce2a3d744a566267c6d91da67e154bd4a27204e652e9af0d1e2e7e86b0ae190a3398b774ad45146548928abd0b59677a6983a23cdae5bee6836134c71b70023570e1c2d460a0f8feb59ce642d0c6f845cf8cd43dc817711d7961c063e894fe6f97ad21898b9df2f29292027a5d154dd918196136e4c8a4921beb645526ee5f8fa5b9eb61e5a0ff416ab99b54ae6cb84d58d8b16275e5e5a4d80b917f8a7474f892f6b25c446d523008ae90e15b01c498254609956284dad3b4c85678887cfe98a075d5e5aa75a406c0d3d737a5984ce10b015f3beea632c9d6c4d213bfa64282f9d480a16e8b6f9ab134f9a3e91053502aa44b6811ff4fe687d1af813474ab5db11860265a3f5f7b8d28bca231643b2b0522fc51317663e81abff07ff9a74373abc6826675556758682e990a9b4e4e8b5c9f5f24a8debccff8449988ce9e3bc992817529309cbca4d085c9f230cd521d6c7083cc47f58d666b65f493be7183595eb319cbddcb2e28d09851a0936c706f42921e0eeda69b272fadddcdb7e0278af0f69f6dd98608ec4153178f49395f128709c85c6f8d5cc1631d2b8990e4ac1e08e13d9e467d3780663d2032648de98800516dc7750157595a48489184d0a0a4b900dfd45abc8096ed15915320a64ed385cbe919a6a6927ccdcded2acf789e475212ff0f3af761f7d35846c86f77375ea97d77c06ba33b7de361236570098cdb9f78657bd0c0a3de6e2e6dee1cac69fe98832a63a2a68c6c84ceeb04cc42370941ed185dd5285b32aa36353bed4a692d099562c63cf1a81cae0a4c7a6c90f5a3088e437f209f3230a7292c1b792bd2c0eb13f006aa4f240416309a2132bcb53cbdaf820e8ac3c079f139a8a283ad602f212a5d1dcb2e583bbd353ca666f433bacf087c5074499da63ef6923299a8b5426dc12b714f4ce354688be1e4f9ec3ab934cb5baf8087bcd8c88ea18e98ab4e9a24c9c2b7caccafdd24a047521c58f1aaaef4b78fcfab2b80f880feb6519bec7c1aef318c6f0874fa1f265d40a94feaa3bf70cd82227b1550ac7e34afcf708d188cfd492b93fa31feeea2f9f2c70b91d6c7752d8d2650a8fa817994959b48ee7f6bbca059dba1705e393191cf24d69ab36c816d6de5aec15d196be413131cead81f7a0481eb1b1b241dad8536abe7becbe71c9d082a84dd366de374b0942c8851e3864967a5e43507489ad4e4a71dc214ac1442d8f83defd8da08d1b30d911c92ca780f9104ead612026046d7da7b03733656580d6fd719169b1236aac7cd1757e4e7aab1300f586e027d8abe0822c6822913c2cde62bee348d88f9cac50f4aa33a338eccd978ff9cafe9af853e0338039c5921d66bc68e6fb4068fc713ebf6f505c5f4401fbc5ad7f396c44e05567be67a6c29480f5b10144bbe8cd79f20dfb34c4f92808ced77f6d157a1091084a3030ddcf3c3f7f90ea9274f922d4772634ed18d7fe4cb70665059448bf93f0a28a3a5fa077a8a8b270b4a5197a66d2be69a260069fc2a2e42743c928ec46df0eebd2a99eafb83c5f7f2d7bf6af2d7b13f15ef32e52589cbd135e2f658ae78ab6b97bc1131a02e938e2f9c77b4534053e1e57dc60cef6c08df5707ca49d4c5c3e230448e2f0ee18d9b6446bdc5b1cfa8f867f7e728bd8cd4a4577c68a06f93a06416d43939551b6d90cb5fd06b90a84c1c13e4545671ae555026822dd74524a0535829ef3b124df3898075d4b676275caab076704dde844de138b5a6d9cb8758d56487be2fd0ff78bc929bb3dfca586b83d48ae8f022ab198e07f4c670efd28a3f30985a23eb836d7845aa2bb0d6ed4a29a190a3e95773ec86fa9aca03c1da3a82597eb8bff32184f90f0816b6e5149a6cb7a2fff0d536dd890e2b5af4e7a980858bb176215c74c0116a7a359c83b7ddefdc8aa801a7277933c8ec8d6c41ededf515e05b15b153f7955a735f309de55feb5f54ded4cad14703c66cc79b5a01a9069900c03dec6b519f6136ba7e7b0f984467cf1d83162d8e14d1a1f775e4901c0f1324d04448b847d2de572eba0d3852bed56ce8a916ae044e3ed42f759601626703031194994611ebb084361a46d54678ec8c5d6948dc43468222f382049a14d60aefc87833bc30567b760137ac2cf225f91ac214b6af3beec8277a41dd1adc89010a0a2e283c765a52a0a738f8d32e32e503988339efe2ddb3f6ace1e81e7009e2935447b8f4db9715afaa2bdce83d1972fce6e9ba43337b8983848ab9b02ede21e2e1ea1da3a121cd12c8b82c7b502fcc5203914cf858500b81ffb7e741ea757e3a9325d8c83177d29b076a24a3531b41a97c743fb55f7c5081ab1278f44374b5da230511dfbe1f0cfa509a0d7965e31c10f86e90a8d7a78742f377f042ee8b3f83618d2ca43b3249c9c0065d1559ba2270237e74f3af9556d076d508193f56ca09e02c1bd407e9c740d9ab861cc0b6c3e51f46b66ecf818adebaf0b2239da3f02ec683b11218e753cf01e67e684f209cfebcd5e0efd85eb7721e7bd06f5d65b91c94ac0084d40ef4c092ac1d74e2853c53a35c31769c5b6024ee4cccc35e4149b2932793e60f963dbe5ce5b803b4b99d6298adc862ac4bcd508365717fa627d9458d648ccd6e7b9cd595e2c6e776c4013c68777481becbfc780cb2e3d9b2c78114f17c97995c44f04035ceb044cb4c088ca9d300efa1a327fd1daf19ed2c2d5a3423ad4ff4b2736b7d6adbb4f23f94b698709ca20f96ad6ce1af5b95eb537295e4e646d65b01ec1b393cd6fa26cbcd56666d302c8b680544b747f94bee16fdbd0183fa18956a9b9b582821d978659a94466f20a9b14b6ac120c918f844c299b9c8b0649f6cd169d1a4a8a962365fbdeccad7e21588b94bc084a1c3234a4bc8d264cee076eded86a504fcf8b412cc47223a2b9f6d8f61affc442196564e6ade753965e76e30a4cdf2578d3dc7416eaed018293a7ed7477fba5d048468f3207d45c1f3536a9fd1712d30191b789ef4082b100e41d1369162f9fce81c73967d0598d4b8337555813cad8ed6370b8e78199766fdab04b62bdc7b7dac1996119c27155698d1dbbf31c9fa0f032227b833a9c165c768dc7d4cee153cce3b58858d88563af4eca55188be1dbc8e7341b718a476ab8c9dd232ca2abca8eea0e275aa1426b8fc28a75e937bc050dcde876036062a3f3ab321ba4c2fd6dc70bf2b30d9251e662962c9086de2f25e870b4925102f8fad96e26bb3cfd7adb11ac5bee9e778acc907915255bf149d58a0a0a4c26ec631059d3622c7eecd7b76f3f4624fca6bc6d1e5af52424fe08c8103a0fbdcbaf55ae2bc724176053a95f7a6197fe3fd737334da89d1734ab591344f4f4cc0af5fb9de0511b93a84385eebb0c81a4afb64f84cb55bdfba19f7eb019f50eda49b94dc32cff5725236ae9fb00d3e601eb00134b63e36567c20b305e5d82f9c82b4b9bd7bc06008d4fe310a00d00751be2d1c67b2b5c92dd909e04ca935ab8513c94892c51a99a8846e0999704d5f40d743b7401ce10adcca5bab21f1611a04e567e5896430a43c417b96abaaf863fa9e469d39747477cbef228e8f3a95db54c1b89c8d3594408d821fc85c1d8b148e153ee641a84635aeeb008ac18d4c34fe0549041cb4e49d942122d25907332833abf4be5098dae66779bf627c0fdec09697603ee48972ee308e4c3bb2a27a368534b124d0e1b0e3b5b05a4a2190b0149354277374d94f158b8654498641620b6a64e40c444dd235e7efdf2b269b81470e10f096a104ab779ed4e1d0245f345d7dafccfb0202540df2c209bfc94a6eef804fa37bdab36f062c3cba848bde4a96c8915e6c0c2342bab6a35caed8551b7751faf0fc0e552e9c99a1f87fdbff645922ab64ec74e8342c1aefd29e1a16d6a4f3336c3c8afaa84c510923023742e736244db63c32e68bfa53a3f851aaf1984430e6def01c0bc94e7fa4b63a8739d0d0a819cc353ee14570938578fa43829e963a3d0a4bcd485cd1d504bfb2a05f4187454c1cfca51037933c57593d4662ffc0fa573371832e4b958fcf8555457cdaae61bd88a9587fe82a6800c7b82e92c77cb66b8f766c3b17819c0310d40becd1e573182e7b25504719343af402d69c48a14e03de67d5a79484363d61d83684255c45a1d0ff71d8b7f06098b79f1d13fd26a8321b0dc3b3453f84194b62e5d422dab9bb0e083703d7a0967688f77ee20fe981efd2c888969c8ee9c2010bd89effb76509d649069aef655aa399379795780e3709876ddd086890431c3b0bc0176fd98e08a8938f3aebd5df3cb584693e41e96bc8ca0a425923739686a4a171070c0850515caf88e35d3ddd4234953a796ae738ee676460741f4ab4d226468f46a0b13e18536c914e338ecbe3414b731ec8a9b02a65e505684069011b1f3a2f970457ec661044e2e7ae455505be8f9e699a5af373c26844ec1116ba92f6b5784ee69911ef977a6685e9ec85c233a730a8f0352447e664af832f9368b1df88bc935a415e83340c53079a2d0b9bfbcab4c9186a57d4b9a6db6de427b427d9fa8a6befc36b760ba66a0ed650596b8ad54fae1496ac0c738f4fb1cb5b1233dbecca1c065ceeb28650e52b2082854b9b2b52ea289a1b053212f5216e4ca68da444bdacb5cf67827808b9b8e9161997028ff108bc9e7bfe11d98b65b5360050958b99603b0b5fabe58d26d5d68e2a30e9180b63669c25c30243e4e1eba740779e0fe530d978d33bed2a651c8a1a52a7458248397f7809699c7615ab6641d434d31a3814d1fc3ebed7b0a79a8b2b1236ee80540432838496420d807105cea86d786f8924a7d9616e5bb4e8f1a8aad0b4cbc34189b0d617c7d08ab85002367760586bfd1c6d78233e254ecb5f9c152e75879a6ff0a3727e930e56736a351ff304f2dfac38f0343f830ec3937fe3fedc3d041db6c22ebc37362f39de174d91214abc5cd3d95d0ab80482ae545274017303dcbf4a9a1041a1fba8e5cb6f105f08ef6cc1f9a0ae78ad3ccfa382d564fdc3a457b9b37ff0396c723b132e557b013a8bc6d7bfd3964154be9808748c92b9e4480d8046a2298ceec68f685d8141e6a13bfa6034409dd87a4331842bc68e11ae439659287a44cb94a9dafc61e2baf34d81eaae5b4c4963e39814547610c863070e7f4c56bf465df4fc550e71cf9e7b249d044328dee1135cfc88829100a558079977427f9daa137e9cb98eec6898670f4c5b3d4ec58166d9178b958a07d7cc567d491e046ccf0ac2eb46ef1f2d84ad7a4e94ac082b02f73be62d5e25fc9f4e5e4a72fcfca04e3bfd306c5f6b6bf6b07e11e50f99870bb6a81eea0b6b8d3b42ceefa16062c37045ef1c00e7a874372d8353c85c6ec0ab13b1b8d9f3a6a3d0ae96b5f0bd871f99bb3dc5052db29185ab0bebb35ad136d9fb814a75c09f8539774a2edae01e4ae89978c62204c5b512714fa4e8fa1369a533276b545dc44383547eeff79d4ad27f5ef7ef8c23bb594fbc87af1cab107adba7cd81922f618ed1c32e2a68d301e9f7042dd2158cf620fc0427086875eee1ae5142de4dcab2ae8dcc40b666e5a140061fccb6edec8d4e592469fa5220100e4107082c73839db646b923043494073cbe411605319aaa36850c1972ad5c4f7669bf70e206076da4e9b42e19550ff59dee6601ef763cd679a14472b04e4f2226652abaa3398b73598546b5a2ceaf9a53f47cf4a87d7761e7506054e591d6d01f676dc01604e9863d8da8aececacd0580b727659908eb7965edd37d27b684267dd819b36645feebeb0562f889bd1e0335791603cb69f27821e1e61cf59040cd1d89b159e9a789ec6cac80149fcc100ac342b12c9e9fd319e682526caa91365d3d8038e36c6ccce8f77919cc3f3343e9285c72db025b9808a0b473f12838aa2dffada0a88c459da95f1c6a00f0f3b00db3836408a7ce2b498a331f78f1eb459f22e66be45bba5ac2f2e9454d83a8a248f434a169288461b5cbbead29c1d200b51900716503f63e0c569aef394dad24f97858c3f44c13f792b26f1a501ef3c1f82422fa08856f8b2abfeb59c451608da46ce366ee9474ecac45ed898bc1d199e4cdf083731f7cc49577e8fc795cea595a423a78bc43974a194744c083742205e9b4d025ab3ce7caa426fc2a5a65b986bc45fded7eeacf932c2c5f7deb39be672c77bea961502bb07c2b21ad054751f57cd15d380c14dc041f21d39893f68dfc5659995c1642fc579b9b9f8f0b46bf97633437c3fb9d1a4eccaaeeb1eab3ee1513814e3106ec654e4bccde82535c5da9a7b644ccfa18b2cc0aebe4c8695c7822b997838f4bd6ab8eb31ef3be706751c3cf60d618c3d956139e0cb285075b6e642b56a55b777c5bf0edd3817e213d7049e1da4c07ae643faf95f689f02a7fdb72afcc59d11c232b11b87a6586b5589d41db58d91b0d54a4aa92cbbb0f958723a4ffd852d58f5c044ff25be86a3a0678a3a40727880af70f5ba6bfb1d9261ae3ced61dc15a0c4675e8b6440c189a403dbb627b7e42ccf07c81f055621d549c40adb718a17b9e031f4fca55a9b4f82ca1b290e8507af94e1eabf279d1a74072b1980b78f2eef5266e1e792b3b090a8983d4da93e473878dfc15a0fa9f20392d2af86bc9665225576f95aa5c5405196b1baf6ada44504b730eaf4c60e2c67dcda041c8f151ca31e9b5f494962ec3c8ce6f976b314808a7e2f62c27d57565eab9c3c77dade211781891e35689175b6cb260cf664baa6ebd62d54fbeaa01f6db65966bc85855e6d64037c8b73362533cdafcd5f48c63f857da5e011747e72de291eb5969062f208baa781832ad97623d1879d5316cd9ff9f0b3d75df68adc34476c1f94809921162355a659a86a6d919b71384fdaea95724dc08241d61b00a630521434b1239f4d204c57f39fa7f26f024658e85bf142d42a827bc4aab54f55942ebe76bfc1b09e68b7050c89b6e4bf41c2adabaa2ce288cacdaa841e98c58fefa9c559d5e9c47b1d8c274f68771ff12d634db1c4eb3f2a6876c4375f696a6e6682fcc2f5f0a4ceab724f5b4df97c96777d8d7115cc0bcda300b30b8d18eb70bf28a05944fbbb1d27f275280124d80efeaa3b56964b421483ae7186ec3f36a162198940323fbb30402913da95164db4b885eeb5d24f795ce97228d7bfeed7af050ec78b6f8c015766b002bb4d9ffa49f89fc07a6bed83ed77b0cbad60afffc5476cc395bc7a9859abe5d3be6de9134a52dcfa9147a1bd6be3336071b6c23ac8a3fa1f4a461356dc59de8d0ac5395d8340594bbe8126de4d0e05201d9f16a104bf14432deaadbf8982f7decce3e08e3edf665bdbd00e0c885102a8989484220db702cd168d812b9246b7c84dca6b62dd246145fc876b2f0f0cc2941cac18496de79281128312bf744bf6b949441a6640cb86c1ddfe29057ae8b6bb04b73d247eac42746e491fb9df21e55072202de39bde8e1e001eae6faadb721f53fe718be9337a825721e651c51514bf5a3ebadc911ec17945f26e4b5b89b9b5e3f6a818681df9d16bbed8fc6502930b19dda169806109bf972e5b98e80ccaef3dac4501446d1f390e510b076e4eced840621ce2e24cfbc20cef74ed56596bb7b86d70206ca490cebb1005cf54107774cc855fb6c9d51a7ad9a7f4150aa9571ce61350e56453c569aca5f0ffba35f0f514549d3f4bf5e59747b601a82528db8196421ad0f74341c3b169992d1ec9d343f89f8b5aa50bedcdf97799db46ebf25c4c26fdf3dac658fa83d8f507076d407f6f7612a1c95e2bf75b23ba148db39f97fb8c13ff3a59bd60892462fc714d63db854ad0034bc4c1f9e0c9fa57e645bf26aecb1e302ba7f43417e5d1076d82eca74d77edd35a94c4258efa4db6a738cbca155b88ddd8017367084d7af559a579147489e9de20d3462548b4a565dd77680e551945f884851b1c1ba77e5f5ce6ddada7fbd07fcf7dc30a2ff72dc11271aad02dc8b3a20d01adc45fbcd7b81ce32509fa68ca00fedb795fbd1e58c805407ddd6de686bdcc2cb6ca69c6a90f71300c4351767eef8e573c4ab650306f91e82904883e4dd718ee20a78dae6529abba2c753c3d1308c83c5b8aca3695c3f715a846bf369679464afdef3da07ce635956899cee7730ac9468f00139af1263cceb24ac13141c0d4282700ad39e1208615037b3ef579c605cef3de8e7c0d9c9d226b2d81846386277cbdba864086265d20ae8750aae2af11cd5a4bcd394ad83c0c26ed0d6fcc1808d3499b1280fce3bd4517dbcee234018c948f777758ab4b329e023c7a2a3e4979df40b6935dbcbfd6e3b97d9a30776436baf92ee325ae2d76371c1d9445589ab83a7f9e25e6b1ddbc1a777c7d553b06d723ed5e97b55ee5b27dccea4ab2e7ffe3e0853f22f82c9a4d473143645017ee779072afb37d817ab288153f6cac73f82689c74bbca0b23390feeaa0d198158fc995c2302e91965cafc23aa2d4abc9d735f082dbe1d627c891ad2ada1437b62dd6fec0dff35ca72aa4d48b454fb3769f72f9d5bb5f1b37b0b57c32e582efb7f0ad38fd44de8a4177afc024cd8b24035b8d2bd30528a42405c0ed106b599a370068ae1ffd8777425914de32fa4aa6c4f50342f0dc6d8ba9e4952f61be81bb2606dfe4dae9c0f0f7e8ea79a8b0cd2f275b625888ef361498c791da2d7e6ffb9c2e12f89a173662dd1cbfe5589ffcf313dad08e1538defc68814ab4cdd540a3ff86472d05d2bca030944624e37563dd1a0f450308e355f9e7bd9b88712172c9a78b19db0c733c7b89c23821e7151f8d84ead48caa58f3ced9fcbea725a0a42e1cb9331cccc43d885f77e88d53e2ac7534cb469ee24b2602fb0289aff20ba7ec40e83981bcc9e26f81d44747ef30d1c57ab450488768b1317e2a1c602029db2a57e42f4f0b8908f4d6a97099bd09a04460a3a32b3352bf051ce646e3782d5c1198a7f13b58c8bb1a3852768df084804ccce35198dc78e09dc7b71a366e7731ca14f9c9675ba886fa82b727834ee6e7c1d4d53e2acc9b9f54b3809392f89e82560592a0450ae13a557a8a00e84798e3e62200f354a5be9bd3c3f5968908992793afee8874183de5a2fd5e7c957804abd12cb903dfce4ba6cddf130a0e702c4246e6e2b270cbaffc37033e7039e95fff5b044e26abe8f92aa496769b89731b70d2ce257406bc8d24121dc114e6b1c0bdc41b3191a3874aa3c247925c9d31cdc397f7ed360028fab760df751472e11d3b34f467ac2f6e4183ff3d65d3d92c4d648da7415d13e052873f005ff6f3d08a1d4bc3412b09adf2ca2aac9dcf4bd701d53687aff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
