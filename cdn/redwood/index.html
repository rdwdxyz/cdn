<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"839e6e5bc0d5ca5136a727f38cb17e8c62b04d19fd920215ae110642d724c9b46d051229f14e46464b6f852244bd78b92416f4875fee471c57a138628ab0563b52ccc0c8ae9605fe35799293e656130df4d695f471381ca5e1575bcc98b67ee8a44ce8ac2f5f011a0fa26dd9251f138c9a41d63e247f311ac000cbb9b9ac08a81dc6f7d6542bff85eb1b786ff092d72a899cb55dac2995fd4745a084626156544b0716b11bf4cfd7af15dad8b4338da8abe26d7c0759d916e3693bb1d44310531736a5903f00943aaa687c25a644cc0a81a6ebb7bbd475b7aa7a818279e6614f8baba8a2b899e0c04f67688ac356155a3962d64d89dc93218a462529c1b78def0292c351b992275087c89f559f8378166f65d20b6c40f0d30a239656e761e34b27bd244dd21572feef749c2db82c0c4beff7259358cb98f4a98708640b63f3cdf047b800f5931b5de4268f80dfc9c187301eb1b67f5d7940a5adbf5f6f8b06117bf626babd9cb5fd611f8b4692e27fbedb9a3df249a5fd3b6422e54f31acd8c35f32bc90fe9c61d1037e3dd05ad24974b4597106c65322f0b09e5fe838bb7b4d930aaab460c40f71e01108dabe17bad119b1c32c774e248b087e8fd50af9bd47e845f9e4a25cf70b298890ca56cbfa3e5d7e1b10c6f36bf2d9baeac42ef7643e5a3fe01959bbc4a14e92005eeb52495063e6c6213225c487e28c61ca90c2d095573cc6c31c594128a26a9eb52c8ad30e221198cac4fb80b659fde14daaae99aa98deb658f796ee6020854104f468a0b7b58716321f3e68bcb1039aac26461c9164c469d360dba292e449edd9dc601c3e5560ecaa495af2f53e7d510194cb3ad9789381f62382cd4579d4acac04ad8d75f955a60935bc3bb22e7ef1dc0c7c5470ad89d8fba72b3733d9f14df1ab371171606a97952a8c3828cff5c829d7ab07ed715752b3917bef5fef913b5e3f8ddab30d369d3bb51b187eedb3041f62008386a23ad2ce87a22c00ccdbed0fa4bf2918ef209cceb522c84f3c9ce7a3f728445cc95318c1aa8c1b73491a7495923750c92d0dec4d50eaae1fa709f5da65acf30f7bfbfa57c9585f94661ec7f1dee1552f5e02a32495400f106ea07db2678c502befd815a741482ca7a217bb7682bb064c82d6922ad728b97e962b0bbb1fd58d4ea07a88fca9c21d982be5c9e9306bff32b19d86fb7caf1911acdc3a8b761f60044edc5a5775683cc7b4e289898206d95b37547db238008e5d1773f333e70daa1490329c776cef49ff9dfb42e29ce6a0df82f67b303ee957767559f9500ed4a0b99ac8b83da307ae5a40a05443859e74ef42692094446308cc8f78490bb99282da32c67900087ea4f151d7884853818d9a65a430923bbc8cf2cf85594f9e69a6cde01e602ebe9976fffcc121adebcc6ca5fb6a0009506fe21d8752eaf0c74a9db5e9a3908f18e2c00e10f35a5c2db44e88644a24439940d3c7d869a7154c899f23ba2c5958620b764958579787742a919fc84d63b73c99ec4a13673956fc9c95619a171f7d3e9cbf957c4c797dd417db8b1bbc65faf58a0dbd9a6b94de40851723a1272bfa59a965c9ce9cc0a356c27099817e0be9af5ee6654626703f0d5383ba179f50a49689cb3601a54d20bf164a9423366b0e8a1baed8d39af013ad27da276f79e3ac6f4a2a03f061b88cd8ea9f5880a98974fb52b5ad4886b2c7bd09ce4041010710167cec7a0ff94608c718889937f6335512f3bcac88bf85f6ed8c950082add162db253079b85d976618cbb90bc6cef75e11c25ecac1b9126057a06cacad66b954595817fb11241b63bb233856550e33fc856e78c68352bc97a0b677c448ee68f12f5bbe0ac23800c97dd65527babc66301c43fe91ff6f6fb8878721f80dbf876d9838fd565f0ffd96fc4bd2be86a87feecb32648eb08e8a75f2a06f4eae495a0a2fb415dde2bb971e60c1129fc9ca8c72018eabe78bb7e3db8d8f6aef0b01c293875f38004789c747a99f2c4ed206926157f09098473db830176d6c8068fadf4090206e5e9eea4db9e3760266925ae72cd554b47eb8d81d028782ff4e8d0b42f311ddf0574bd8cdef4f1e9d4b0f83067c27ac17f2f062ae4fd653285f6d1b70d5a56effa2219fa8a77a43a63e2da8ce792605a61cce31f92a94f0a3f9636556a93008bdeac236aec5957182dcc9aaf0e6bc304cd3707d819c623e1b6ebc9817c9a0cfc88fc0826720ecdb0e63ea0e631786f3de1383e9f8af78e36fe5b0d88c7e0665100abb0947172060e588f196ec25ee299c30400987a2a8d3f94d45d5e16f2e46f692e1577ffe9041d251249dbc5f35883d90c1291f61f84b5acfba1ade20b2438b7819d2071c2ba00f9dde1efa87ad975630bc215286e74a051cca95ea5e4cae91375e2f2fadb3174a7013fda28b0cbef67b3463747b5407efcd52c3a8bdf850bea6e2d627ddb6adcfa94814aade7a0e94f9e211d462d7357bf7d6fb780dfaa54f3dbe40576beb15586bb2684446c448a97d609bb00166095c1c90df33c0e6863bc97833296d94b5f4269c8b7f1760f156873865ffcb02d10763223acda3cec89aa307039aa86a0f7102b00c02c04fd765dcbad592a9f49fb7613f213a15ede2fb4b21cde3602708238a61c3fd24703503390bc2d27740b19afb42d4c461bf1405dd14f60e0d0a675bb18b800e2df06b67b332768e31d1a6f43d1a104af7304a65249d76ed11760a9e26600b5738a654c36194cbfce785787814e4c207ab0587fc3c64f718a38929d71edde65f80e909e8a56c8dabd56ceb7b86ce178c960d803d136f7df66aca1727c7219fc5c24e7e8d9713d15ba2cd56d16d2bad498ee18d004957ab6f98bd50510361914dac86d80f232b38c66f0eb7397292d54cd620eeb9c524ea64168e1d5525e98afd8c0ec411613216c00ea90ebfc3068ca4af3610f73eb2e98b942ad85ce42fcc28f9556e2f37734e0501cd2ea953222a6a6f827bf67c7933fff7a0e834614360a6138bf969c1f1baa1a145513cd3e90ac7cc9333db11a7a6ebc82186548d0fceaa1c9343cc0775dcdcdd96597a728442e10f820dcae8fbd74dc5af385b0008cf4a73b208cc72fec951783f994cb43bfa86bc5c6803aaf482c125898a1b6a2b76a4d9ee7b4786d37ade359cb260939093b4bc68ce8ec0d67a8aaae9799566b50da6bf514b6b103bda145de84752f5f4478fc5885072e553983dc1172aeab193481ce928a3c5d2cffc45c5e8e48ada3feebbfcfae1255c07e9f7a313f1672f6a179652409098cc43384b27b47d2b8573f628fb17d56a0fecbe39b1e6213a7f514cbda1c152e553b7ca314f782f3e776cfc6d2aff431d23461282941c3a4580edd1e1ca92bb570a6770c82b10db69ffeb19757be545dd44244cc502c6f24c8adc1c18a2988b422cb1a0df2956f71c3dd013e1ca1f5a4fcb3fee9b9f833b4fac88f30080c37995d9c8d23360144840d9c9d382b61f51140015997484317f88934f3b981709c8de7ce7c4884f321224e0ee26232ee625395d7e2f3640e6489a5266a5ce0227619db91d7df1795eeaf449b984695ec7d7f28f78743a471c711e6f002f6abe4422ca6f8847eadd13502322e791879911390de100cfddf37a46139dcde6eb3fe3de6335c0d0a3d5f8dfd2f2e1d7258204de9b71b2f9c27693fe44c5222e1de87ad5cca8f516533934358104c1fc0dff3e248aff805884417ce852c532dd00c5ef97f466850fe3edca0a6c4764738014c7d891bef056e3b8ed7aa0aaae659ad34f13401c137ae1c4f551cd96d033d176703db8fe4c9b143de5d1809cfcc7a02811bc96cd8cd6d6d88d77f52421234443574ce7ceb8a69822b6586cc066942277f2efbe102e478d674e03f5661e4a1e247aaf523728d10d3b0533e76777a2be0a74b15f25272e7faa0fabb900008f6cd1ff112a3c52c099782d546594560dff89f0a94f68da7ff8af9930c15de248e82fd34d19abc8bfe486949640ad3cebf9c4c791d5088ac45a86fc278caf861dd565bb1c6422f9a3a385e091049d34e2e99f3cd1258df1c2f82619dc25968f4e68a2ce9ad33a4823acfb7d3ede3f55ffe9dd4d42aaec2570776e635d8e0d0165923ceeb64e9c3ab21928f131f2e48caac26b1aa8fbcbbd83cde0c3f4cd0629af30bfdfeaea883556ddf9e3318d8a66438dd117d1050d6ba78f7a161cb80b102b71486363b7a56e2bed5690b3900edee3e3c63f06066cd915a57b05318e90ed0cddfe9c18c6742f7a60537817d68254899330a59a41e627b4ddae940d57aae2e2fdaa9fb2d2aa6d55d54bf71de3baa92b66c886c2e8624abbdcdb1a017cbcd4a9861f63dac60222d09ad9795bec72122740e5b4701512b252aa6c56a2fe0e9c9d3841d362bcb153c52b9291c811c984636424f6a8ad10c5d5ab4c962f57fa2a07f42819579bf22ddb8a2a13d6af5ef7e52b74aa466ab72bc615c073e381c058ccf223a70718d898c5e751a6d2744fda2e59bc1d9284ab7e8855c1f315770b3a03b8c9a1aeace5ea395c80caa1b1b3e8b236b3e4b5974fe1f7872b62658809aeefd44bdff69b4f6452987d8ae68229a98db95c63dc78515e7e9090bf57ebf69af20010d5467b3bd5a22f72f6a56e9a3bf08142f3d35880a1eb3009f5b2c477e7321f7c6e2010275444e04ae03e872844aa501259f69e7e39045033a85a556071cbc7975f12c29afc5e8547c1bb45efa208623e826ae6431ef57d880ee5df7c7a98e8eb2babdcfd05fba60b851e798f94c9eb884c8a6fbd13b257f4abee302965d88b60933e29d0a0e3f0310967767ed884c450eb1f6685a80086fe5ff9cf86fc6c9f46dcd1cffbbd75a74f18d8382c58adec553a0eeeae8e667f0d7d5febe92211e6aa58cceed54f4de0286e91155f6e8872c3267f75ff14d3dba6646f22e142fbf130040661b90c2ba55e79f0bae8b1cde51841dbec363674fae9710dc6fb8c3a196567882611f0c9486d433bccddd4cda5305bc3899382307980d89c5c4ea4337318e558aa4af1c7dbef68b711bbf347ed647e1fdc5dba1bdcc6ba5e529c3bc71a67988e528c09c44360b45e2e4632f17034adfa3b63e07302be2331ccfbfb13e301f1cdd6f6b9699a83968042fbd8155418795a21fe60167ad8e09eff6ad8def8063f4a53095c575130904ff0fb17fb82bcd2a6c4a8a47d1613a8b2c64eefe7b4f25e90518e4aeb9ec82010d93a7cedda686c421e7ce6364a431337181e743f95a265ea6af0263d899d72078fe50f6f99d749cb7c7e0ccd00041a33580fd943ba3a5045054049cbc49bba94ecc0f1b8a1d1c62f5f2408dff01cd5c2bc0d25b28f86eb2cc672b38ef7725e15b049c31c8a0c095be2e84e157f536ce98901555d490212378d66f341c15542f4b4b0e444a77e87bc89880b291c55d17b500ebd0c9db52ce2ad623d3894752576941a95d0f6f17e8ad54e4c5cb30aae829cc0c82fd26fdd9e006b3a858a7674302f51fda266f9dcd4259f26a65ed5e7bef1233ae9c2f5b451570b66ae02af81a0cea71b58d949da443d0b106c0d700dc3d362be1677e52e5a57bb46f2c9bf8133ee4fba6df0ba898e8e0877abd0f3e2a17ad23fce6ef5fdc8961e73bb3560c4ed72a6c375ccedd5d79705ad2696aa2e840c9de512aa849ee5413e42f75d5567b1c6d043fec1efc3af389675d0935e55d0b045dcca2ca55f8e7d577364c1cc80e8aa5afe676d8db0736761c6f1f1fc35b6ea904aa1baddfeef1d285d92127d907831b6710bec16e6bbcaeb45bceb9ec362fc263dd590d164836187b9bb467dfe84d33143c773115d647158ae8f31dddc4fc3a43c6fdf1ec7ee19eb2a58a2726757e7866e54e78a886fe51a6974937f4b2d063c12ae8f6421954f3470d976609e1c741e4afdaa5c8f637c9d7a6851cc6d3102be01f8298e4a4c4531775b8ba33dcb3f78be0fd9d103ffa00e8e5def4b1721184b3ccf43425480427aefedeeb5fbac9ad17f1f85dcc8a977c8652b899093b56866600f3330a151d6f571bbfa2268fdbaf10aa0d8c4b8f85b30b4d125cd3591992f65f248000e25c36d28f3fcdea77b6c0a22578f4ce4ee0f285aa3e6535a70cd5ed4d66bd63c76f3132741603036a141c4b5d542f550534ce02dec4bbcade81050a204d4af911e36a2710a163d2359f9a6d910f20453091b3f25569f8dfb20e61a1fc7df962997f22649da469d9846c3bff33b826d1ca19a8758ea5f870eec6d1d872cb15c9cb348ce89ed2a0b2749f5e8f41f0aae673b64aeca16a8cbb5560be36317d2016f8adb5406e644af9f0a08bdf78abcd6ec3ec0df60d51325c4543d4e6bf922cbb6f5c92870572321ce7e98b61e7d97e9b48f6b2cc5b1728efd6932b0cc633d768851c96cd2fe53ee985ed9efc0bf621b9ab0a72a4d41d83df7ab47fa7fee47b6a2afdd5c8735943e4f3d67b36b68de4349e3643ad3dc9f5e1a9bbdbd6d2ceaa247c8fa8c26298d764dd1f7d94c24a76a531562185fb931903c7fc00edc01e2451116e73054af615c5ba379f0f9fc76f043d28d5b4a75d6d6716d8a8ff1d56688069e5afc31c71ed4e0475651ae6bfb3ed6e209c32551e82c344899c4a398760e3e4db39b11483aa744a3a93171b0fe92ccc696f718fca047260a09a16096a40a98689cf1e5c816ea5dd03814b5c02459da5ab1bfd38953cc9d156da3fef3afa081669ca39cd784385d4314b657a87bc0cc0eb793dbc76e0d4d66fe2836b95f869f85afad1997e69e29f8010f7dd4f49e1f76a7ecd338fa9b0f421bb0416a7659d5045914d2989f258a38ea9494fa0029cb4d5dea93335144d56fa18f0596ec5da76313aef2325d879e99af0ab777e2c4fda3629e5d90e64000da8fd9e5b124753a0c1c44c1ff09c6372561b5c88b0a7a98186fae5696f6136ed32241319931905d04fe03eaf7f075effe23f9c841b9b6410b99a99b6a1b70d6609b02a2ff17988b1a1885a6f79b269477c6406a926662ead650e8885d56e8e16b6c631739594d3b76a959ce35f2a56f81bc65646d7505b96380509943f1224c332e846ebfc173df33a3e8bb0a56f9a6815ca543a45f1242343bccb57dd2fdd731dfa61b656f81bfa22950094ddc536ed0e3ed93e582a2f85787c694693d46c4cdc9c61428dffdad9c012cb88503832dc0a0453d7ff2eaba1802a5a531dbe823a356d8932082a4cc4f9ae890f4791d86192d7565f22f61bb7703171a2c7ec8f6b3b674f262cedc8254facc1fe1b01d0315b83dabbaca8dc847642db1c676533d63d3326f013e2140fd150474707550bc1bf46fc4215291ec0d2fdf523a9621893479a56c3f603c113db6290bebe783139a8c610ebc7b4055c4898e0dd14c958ec62fb80f075275d02d7c2291b37f145e3df8718ca5ffc9c980b914385e306e9a10387229025aa43a732042535e11a9254f7191feaff9b8f4042307e35e0d8895ed83836d3a8135f246b9e8537796047a71f40bc2fa99903158433f9d0fcd25024a86b565d32e7d77db2401228f13b6a694c718ac05fc2688810249bda05a07071a667f8ab16ab4157454cc01b1335c03960b3b0161647d5f08fb4346f66e484a67e410b74823c33aaa7960eabf07d82088c59de59747600c019893ca4bdacfdbefc8a742e3c7041dc4366aa72293559b89423ea13a75d401bad1ff783258b53a144cc871de85fc0dba9d3973bb2f73b4002c3a758cd9863c5d3e9a967cb58f2e9ea2d29189cb50d5b9c8c8aa7c4270a92d123803bf545bff357d0eeea854037bd596abc260063c0f36b46344e7caef3ecea2a3c65e7e224d0b916ac25dcdde23743e4c0f4cadb23be140fabfb9b071a2ac5333292af5e793ed2bf826d3ef93b543be83e0c718b49f7f78d93ed79a5a0afb74fdeb9631ed8c797413990dfa3be8ede7aaf10c80ea5c632c5cb2a1dcf115c7c77ac57d38433c9cbfc81e2277e474527c9c726598e766357ce84ff13630d6c9520eef658b0961fa7787be883475d41bb685aacbbf39f5e3ac480441c9541b7938256c7af7977a8c8d71ef3fb8f2a9268973aee9ac41731f6380d274d4c81e5abe8c6596b6fd12f67f675caa47fb8732a13c2cc74993d93cfcb1bdb22a545d7d3cefaf1c3d8845cb005e8398f1022cfaaa3154ca7483cdc0a67a7fff814617fe07dff9efebcd2c0060d1099a55fcbc841d0fed7efb8f5709cc6649ea59d5fc8e7d4c1760aa794648f8bef068f4349de24da9db819836796b8238cdb5eaa1e5863603f082bdf16f4a384b447b3d90e6fd9b470b3b0a6627710326356eb5683950e6c44d7579086336755415349a68390eee63e2b49603a1effbc97ab327a34e84d0a205afc5c8b0c5f50144ae61b1be4a855dbb3631d4858f790d91f610b3cb9668c644afe542950c5eac57cd8ee5b93fdd8fb31f9102fa4c4858c990ab7e340f0b05356a08e6ec6b44d53a92a1701fa908ed34edb5e93a661318734db5e8af6b869fbddce4850e0f39c2323235b8e45bc8152c2a2f6c64d6c778ae798d9a285a84eddce4fe3247fe3825fa855bd6729d9e797f7eb89d52cc3fbb8f0dda58db014442dd05e027fa107af4b3319f5622971affcc6a497ffa9d61973bb0ccef0e2ec8745f1f29c67fb57bac4f4772e350bd6e7e8021d4a5aaff4e3ff05c0494863c10f14fe6fc8052a45139918f82560857392ee23247d07ab2963aa5ecb251ae571d9e34d58fb193a3fc8168556e7622a3a3180160b4f28d2a4403c346f1023a76cbef64128c233df1cd8c027b021af11ea19c84a062423002cd0e30186732b55c2db8f4a45e1d9193b708bbccbec0617e6fbf08e99bb865e7a4742006be7e56613b155aa721a21b233298c03904995cfa1636f436588ff1f0beb7c653653223bbea9be1cd6f5a9ce95b7446cd8c0026aefb5665f7ba9c375fa9f460eea529969c7af041329cad08ea9dd95a182e0fce8239c4c520d5f8704db76450c50f42794aba47cc8005faa806c29e4a61b34e0fb8d332aa6ec2fd4871159f408093dd84fab5ca5df339df8f043e3a8dd792adb64e9c79c89d8ebf207097f00226358c1aca5a04dccd1ae48892fc908033dd3aba24abd2d5f2b4c5e0eaec6df64cab6822a7d74b562f3ae626dabbcfb1649101b19c769e8df137770893d9f6aae292c5125de62ff954e884b16be7fc2b42e756a296c479335c281c2b9f76422a0e6524c00cb12e1951cd8e06bdceeff504e43abfbefe8c36d4f6974f0ab8290c5616751329014fbc454ec9ab596c24e8bdb610441a6cd48002d6dec4cbcbe6c6ad16fcf0e5a9e84b3bc5970db8707e7a61bc667d635babf136739a95a7ac727032078b425e61d4c7c9117d24cf2f6e8f389a3337fad168a2d2f7adb3faa7e853a2a99a0223100c486454ab494bca4514876bcc787edd17ed09b976bd53d804cf143ddda12fdb0ba80c6214bf33451ad6850a33add78b8593f7ab0e82de1a0bdbdd26c01738baeed481eeff0e63bb103048ed7fb05dc2fed5d5dba522f73f00e028ce93557cd1dd783b2138cd1bdd38bae2060c942410a2d6d9a1b99ef79dc5c42bb691600e23435272068ed2cdb1d56d7893ee1ef0a8035d532884fabdd8432126f553ab44328c2554a21d6bfac4261f05f593b2dccbc828f9c8b01d5606201e9bcf9e77ac720f747d6d255ff5a44c1bc0e2a6a76dbe0edb4c86ad822285bd0a5c070c7a5ccc60bf808973fea576e9e3d55ac618851a6ccc194a7b52c4b1e07394d7d950745070f8227438902fadbc5ef5fe8860a7b26401e48728f274e34217d711b43ee998d6ae81dfdeccce10b8ffce9cf735b5b8e1727e0b2c8b0718e49ed26f87667fded2bdf6daf534799b8193436a7e6644bf6a6ccd30b22f8bb64bfa2fe8979757517e9f365b4f135c8660be66592204cc37c9991054b93615c8a9a52c12f596ad93c4f5f6e0ef488a4b49d39616ab61c93994dbdd4b2ed4e4fd1b99d109295544ec8d4b75acf309b2772cff017f0903ec47df142de83fbb1f4bd826b815124d397e68f892cffbaf343ed0645217828ad4d92b25b30090f9008ae9a495db7ee982ddf3e201bb683e1492ec236625726adff1834a59c522108e487125e70bb5599ba4d42b1290cc661ebd38a25800dd0727ee91dcdba3c704088edb1bc9c52525db45f9357246555bb24808ab4526d9dddbbd995e047dfb2a88a7e79e3237244350ad1b2e75583e7c7f3e752586fa2ee4c73ed3931b0f753da5980895c7423a082b9399c564577cca4cf1dcc390b7111bfb6c127338897d9b690249326ca18fbf506735e701ae2d99503537205968e88590cb2ea80ac268ae68c673c5e67c5e05a27b2349cb5306ca4681cd04f3cdf29b3d04558e78d5e7e95f5c64f92649265ba03e647b36d13cd98e045e7467c170260dae36502b1b8e5ebda37a47dacc8113253a0f5c800773038e9c6ea0ff5b5da0aa05d31a05806e544587331421a93d2a0c6918f1b6759e42b96bfa92115473d74d810336e68cc0a8da7851fb513d15c0d9069cb2451dbbd851d47908aa4c63033c27c073c98fdecf66498f43e02f16a889e767c2a574196c19911edabb277bac1c4cb12e8b276fdcc7ea00601482324b2004e3f8856c519d29271a7a4ad8f097bce50ecbfa1aa4da1d9ac5d168e0bc512039c62ac7185011000c344151f5c3e689e88dcd06ddefe3170772167cf139221eb4e6476b5f3aae20f2f700453ffcf087b6a031735b2fb3122c8fcb66a1dfeba06192161180e0e8241d1c52c6ad0b203f8bf10a4c0c3ad306d010521d1be31ceceb16b7557743d125bd70ff71fc80cfc31f5e95a4c90fffedc09a3365194b3ce7c863b2826602fbabd245313a21e8e184603d5476e513de0f4a0b410bd6a96cf90f21b507af28811cf54f26659589ac8630e0d7540ea187540987c36b45274fc0bca3833a29dd3e2e54f97216ea80560fa2be367cd5e5690dc1a238588a90b80d6bbc4f76c02656c6e3f0ed87dbf269cc5be2dbef06e598735590d86c3f5a5b984c8d01bbd27c24c33600f2730ec4c014228e8df8c62bc17bc22656c9aa8c01db49293ab81055fa81647f27f5e149cc15c0a7f9c3e5af502c4f780d27acbff98ad0895e727918dfee6e60de66d421b37752aeb71b370c5dca76d8dd89f36449c93b1d3f6102d64521b3ed082b0de2f6f2632a8f2c995d0f16871d798c227dfd3c273fe52eff163b85164c1d07f6161d4a7237478336de258c0b7a0a043256ed5aa5e3c8eed054db3b9d1122c0c8e77118c7925d273a714008b2af0df4edbcfacc7d9c69de8eafd9b0fa72c920083ff190b6734c43af59ae6e402e791eb1ff67354e9d3124187db7eb8e17577dea4d44cf8084b870a4a3f33ceba79865b74f4ce7ea422e47192b5d575198b6428cb342963b409bbf349adeed936107d30d9459210cf69cec7e476239d63b99dbdf176740213ae2830c7751771fdd577cd6bc5d56ce89ba027c9de66f5df943345b83db7d9a4aebe891f156f4f8f25d26d06c83d06f19f4bb883cfb53c31102d131a31aca4fbb755dddea4f95783208e2b5ef1264033b481287a065bed03d733a0fbd7ac697049662ac59dd833af6ac6dac677998654e8c77dd84f474185d16bda9c5090534b2f6eace375744f619015c67c3de95b44e14e05c91a593d7c597c8ef2e4d1d193bd113e44217de346c7e7d33c95b74efcfde3811ef915e54f36a5454b4cd83f84414a866838eaaa0b65bc60c0e4537de563c7ea4aea5ce835a02a1c639ce96faf9496cfcad404e26fde10a446bac3c406aa5135ce60ec20d0f5baed7e63a6b99958df47ca8005c4d72046832fd6b0bc7f6913eaa38142016bb9cca2c9015cc1605fc23f36fb9e3e83676abe20829cafa938e808bcb3727571225d7f7e36802599d1cdb9dd3ca0fbce730105e52ef5a31cecfe2b49effbce5f5ae1c70293e97651acdec59557a6131191cfb1ac8bb4f6177e2d84166c13e974d47c5516c0e2d10e03d111681bb7df53c10d9f21bcbbdcfe57b0cb9f9f3799b54431c7b46b1fddb915e073ac1ed26b60313927b9bc2837593947b50f0cf5b18349509e96d216936aa1a5e517e43c4c79d1900b36946d29c5fe90d736d25099f9f8a2769b256e2b5d6508cdcb74cb2269ee47ecb508eb8dd408e4a09557ffde460999b275a1cdd434446cb05d6adb5e985cb9d2b8d6d05cfb7966a0d6edefe973fd8f6471a6635befe11e82bc57c7dd3806a847fb4c6221d28d6ce710ad56b1169b75fa9996e731c762c55a08bc2d5831f7bb63cccbdc26e091afd60cda314c037238f786afeeea0a832d95f69836118cd5cb55fc12a2733187d7fff591f970bcbc093bee7438ac60aeb0e030c564fccc021b91859d6e46720131c1d9c15b0e5706f535bb1c89ae31f3f836e60e1cfbd343dccd62a4d5e23827c13e74f65dd8b7dc47aca2fc10d15be22adc7aaef73125abf179d1a253065ef15feb6e57bb074d6e227b6e7027270ca551469efb247eb3c2c6a8ea9fbf7325682a0396df724849cf03001f47394a44aa8b17d403b820a8346368332dd2eedba35b0383f59e6d215c7970c3d184e3f8ee4d5e38ebc20ef26ae00751a3c1db26d2615334561935f382c0ed0334d77934a57889728d89a3434cf9d626d34115d3378582f819272b34a43e849f8e722e6c2bf2595e087d0daaa755b66d93c80e75d75cc3825d02228974163ab89599bb8da4acfca7dee0bca1e81e1b0181fcc954f1ca2ea6708427feeec092d46b0894c037c4e6c5579f972f32310203db8292afc9b6b7848e46e9dd7b03590b41248e32983ff4ea02e282a22c8e7d03de3c6cb54bb957b530aa52f9a8f7ac6c251cd655d07310d65c404a8ed531952850e3adbcbb874321666c04f2472f7b913f4f5bd80fbaf7fea9776d04bc1ede14d30b0d5acfef0c8f045bf9345e43d58dc9f4e2a29af0aaa04b6bb3130c631e04bd4d520efab937bcc327cdf0a15696d001ef306a12adeea4fed999089c02fe00c9c6e657f7f7c76c9aa13bad5896cb6d2a8c39d2b726d86297580e601eb4f1c3fc134e285921b9faa65f37ff3153146ffc51f97e7b6aa2a50007899ce3a0801fcaf25224d386718f726bcf66d50e9d24d127717fbb136ffb2d44b4689a6ef053ad41e864ec52b27e42e3c25815ca3d3a88ae8225d3d237a5cb84f1a0275cb838b5c917e68d8f1243c46012cfd58ccf26d860653fc88fbd278ff5a0c52a9e13eb12a3473e6417ac5c77b9b787f7f65202a42a1817dcdce3c9d218b52d654a02bfef87259939cb002acb7f2c9b2a575ad6e1c261f2c99862929dfce54a0839ca54609e90507210dda5fc27982a16a1ba640fe0284f816095273d040ced745d3c49c422f893c2d77e9e4922a2cd2b1f677ecea4e83a6188c17cd49d97a42bea30d7e804297f05d94ba3cb47c231310dd3af8088647b89d77ad4a8f8d2c79485a682eccfc125ad3fb93ca8a43b3b37e89282edb3824f26b7d75ff5131257579293347ba0d2c61690e85ff3ed6dd2c8e2a3d527815cf3bd269d5a095d3138b38298f57802af2ee012bb1083d62a33bb12daa6c9a837bfeaf663a789e06b83c1c181b276af0032dfb8acc751aa3a4fee874cce569b9483faece722a497b25c3c31800c81fcb7ee747a39fd826990636e6b663a3e16e56fb76118692654996b8d138c51b46501b3b10e6220557b24136fb77fb9c8c7efdb9d598616a768bb389acf4997719e4d7a726be6a6ff72fa144ad5f019e8968ba85ee059989bb0c4f67215519c858c5e304cd518bd733a315f23030fd34276d27fcaeafa1ad267c90e84e01f835e26a8f6ed2aab510371f2f68cea74d39dd598e1c69e60d73b9f428c9b242aed15215ae2d51f511faaedfd90a696144885a68124e94539f8c4c7a3cf4b0ca7932c486a00ecff92d8e0ee4cc1dd6b8f96910b11ebf46347c9e402258bacd9429f1c81d992aa91b1de25454638a654440d5038fb8cf54a6346340bed7d3191bb2b2d1978502dd4c50cb9a0ad0cc1f6250a95d86979e0cc57dd24ec2cbe4bb7c05c3786431ba2fd82348224bb31b7200e95c8bd953f30737f81742ced100fd46514e2792f2e40fa12de4f7e9ea086afead4ed3534faaa2c6295f47ac4cbf1045408f5eb1124a1686990fef0ca0d29fd5d68bf1bf6a06ff0fe45163ee1f56db0aa1bde9d40b71116ed2cd17dabfadaf66db6761f6e1c30d202d579bbaa813f6353e666012fd23409db70a44527036466e180d32b8e77690f41f7a325ec1827e9c81201f7062e912bdfef8a6053932db485dec20aaf64ec3df1cf07ba9e69ff3e165fed767844aa096bcfbdef6d7e07f5a9c8a378b64ac472e4e51eb7322cb7df4b91d0544100b50c7c8af39882196b08c315307fb34dc668f749840068bf8b67961e61d21fbc48bf9834b52c751e6bae4df1d1740552c961a13e8026166878de7f540e9ab9913ddaa819cf0db26eaf810de6771fb53834c6e48b891ad228e1fecb5b4e8188202d128d8f048d011ae182703a02174f4e848a8aac827be63a5206ab16c259b302ea91827d2da59372feecda1790d9dc19166be5c5e422b18e8b57ad1f3038c331ac8fcae4db7525b5898c7110271b1bd4c06e8fd9b548195ce9b11cccae8e17e5c71824694b957e6428e324b95df83a8a546278951cca66961532350ac7aa23879ff1d786210b17f7d0fa4686373bb735ace2d57b6501b96f02fcb00489e93ba59a7e0f4a896d28b6c24c2bd4892e4209c7c5b55c33bf38126d14239e1da5b2c653d1d687ae33d592ea58da133c2b19d7b164aa6027843876d34d7a97a45618e78179d3e4383c63d5b5715ab1618fec69e944d41f4775de15d61abb75888256f510c5daba6d34021317f304a91a2f9d86317fef0b1e79e9105c51f05d2d615e8aa502b4c78bdf080d2dff6abe4fa87355fdc62f6ee09bafc6cbeaf4a4ac99650e0e3082151b36c8ab3330642b8f3922cea55a89181c917691071848417aab4211ce14ceb1024aa8b4a03c253115528a47223961b7a9ac06e933fd61f2da54c3a850aacaf333dcd6b60d0bca833f2d38af2377026c980f1a02f2edede5b926d6187eb8843f965df769c752dd660e96d00630390c09eeec5a412529852bed501b0f5b6690770bb40c1dd4c371a27a5035419237d1ca4ee9e31107b6ef0fca78c810847adc19a4d71a8a5d67d781375b4908e1a84b152f2d54dc0fbac58ed79a746199852ae33e9d7515eab15c3313459cf0265d7050ebf4f81158995f2965f844e1c272115d9f75f97276740fb42d3df8037789865908463207e4e12c084913947e40713ec3873ad21c2dbf6cc14b48b89678830717a67ef0f1f1667f81415f1c5a232e78e75cb0ddb557307f09355e75bf500f2e3dc5d51d5c1c067ca549c6f87d42fcfb201fbb64a137ce2df2e7227150af0af41a21e8a329acad8546c3bc6fbc8d3920775ce158fe8e0a955a722faa71206f1ef75f6132b7bd5f8cd3bb86bd406ffacd56b20dfc4877f056c6656c6891d914cbf58046ea8fa295b9b3a65712cfbdf491ed7a082ce6988ac7a4c14a36938b2b2f5d8c90413e0f2d20490a253352f98f431a39eaf4fa7517125d74ff1b73206371a7c18ec480febda06acb1375f13756dbf1b39da4f09d79011f2faf47035834150f961154a4cc57fb1e985638bd3094d396c9b118ca14bf8450e621b15a1acc20d74c10a6a12684730a9aa0b956e6ee37ce583e379ea470f16a6d80faec1df6ee8312fa396ff005f58daa6b1eb1b46a12bb6a25b108d15e81db357d1ae2e78c4ed506d7962ca3d95235083c3b0a473909c0d65d87506d355d426cfaf1896841086959ad5cd70c86c5d15f7aab31605d9e80b6574c3a408160c27a025ef05d2981252c0383a3ba108b46ff87349f1d52abb210413c439f24245b149ad15d9a11eb9c7391805d8fa20b581ede1d6d81c95296a72cea232d376ec0668d92888889cbcfa2142332ecf249fe1d706e06d08591b3cd84f813639aaf227abecb8286f3ba2a198230066f84a0efea12e4d72a55a6d5db36761ce9f563c7e48c88e077bdff25ac0d66bc6babf8960b3be1574a9749ccb4b9551c0f8d5e9e099773e166caef5a7f7e6a8f43061fef290f029d61eecdc0be910ea333cf53c8ddf9ad790918c4fda6a3710f29b200001b7aac2499c128f9ec0cc00d63dae98c705b312ffaa11485901e125616a3898d46b18103247c165e2db143989acde77cd787ae08cdf3ea7a9e93d3971a7137b36ce26522d88c41a55534f4604fda14094341c95f5841e8214791e16437b837b8383a31e338d553fe28463fbcd4aca238ded58dca14a027d6e544ad98b020751bdc56df9b111bb52919c0efedc8fb4091c12bf9b40cf2ad9442e99c9e65aab794cb0e8f9990bfd737d953c4255f4076c17af9da81d3321201ae173e9e1a14246dc678c1bedb1c6aec6ff242c3b93f74e032a249894da30d115d991eb999da26dc79e773e030c47ee49987fe52b852b591076bf5d759c9847e05cf9520faaec219998da53fa554625881687ba6a06c7fbf088f79a00d384edbe91da8029ab2700a4169c5c18b97df445ec4a34ad6fefe81c587f22e04e409418d9646fbdac62fbcaf333d9e30489be8b3965dc4aa33aaed622bab6770ebdad801c8e896d59b851edd4d6fab67eebb296df43d35ca8a348d3a724d514981989c732a3093ba30dbb5afcaa5688b1c3d2031f7eec924c9acf22542589e703b0a1f9162b03208f6b5eb70fea67a86f21fa2f9b48c015d4ef93224164aea81863e10e95cd93663a50eb853fa003f938d6a970b758ee4a031da8d4edbdd1988bb0a6379cb912d7a82f8f4bd42a28cc9c6c62711ca8a04318546fc18ad70d5e769133b8c9d0cc505295284e3362764e1ec070b6d265e3b4e1697030d495c6768abed397c5172afd5755faba6fea18f4f287e338992ea5b99eaa732bb791fa5e562c607c522bb83db9967c054950a9f7b519aea5201c7991eb567daaa045c2e4e2a70f35ecac88e626f42c5014d04042c685ac9abeb05e9ed705ac298c0a272e78249af2017dc4eead34e33017d41a972d29c7c2b2352a5951a5a2b24ef4be7f2b646653814e011f90e843ffb7c1b651b3a1e58f8cb849c13778aac53092852b7c6a33586133e373e8f595df3b15197a948b7e8b018cca36272083fa90f72f4bb0a3005f032c423f5908b7772573dbf1ffd7254795fddba7b126e9369ae54a09ecefde8936b2b0bdc02de1340fb7e9cfc49a6c7be03211c2dd9baf68d60d857b4700478a55fb6655ef975e574223ca8bdb00c8d50fcafebc75dfc24c737de66f6cf74d4ab156037fec293edd32d89570f6ecfde18b2b460ba51d80966e553d1d6e2fecedf33546e1242be033d5c8d2b80a26b5c220ac0c009ca80a17981517110a1d6c2062f5644729e9b688eb5f483d8b5565b9484d638ac56f0b7bab106e6de20b83c411ecf1771c29a1ac145fa59403250be0861d6e857713c844e72063a796bcd61cf905014cfcecfc74234f6f7e62479a1ef9d143579eb0687db0fe4376d2298fed77ff0f0656818e55e7260c73d60d83f6c2180323a6e6075de57458597205bb30b839416984f88b994bb5264d806572960984810ce306853553e812f273e1d9319bf51b06f702c9e27038103d4442f2699081cd8a9b6d3cb2d15cdbe31e7e8b55370fba7d8b9a783200904de5e679b5e29dafcde9bdb4d42274924d8cf20012778d2ef377fd715bee515da484b9c8281437c8ebf2b45c7a54313f2a13c19eaf6835399471752da403b322752264a614a1c18927e00fe27c3def01dbaae440ac0a4cb168bdae501f689772bca52afa2e60c2beaf43cd3f4ec097ff05a8a891b5baf81b1df54fe373c086c54029bf91ddfd1dbdc3ee125b35448acb27a5608770da2d32f3a956042ce49b07e6f0a943e7ac8d66527739380ba187761b4f7a90bbd0ca4be76adc6882a8d65a243db8970c5fdba9b1fcc2389712b8203f74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
