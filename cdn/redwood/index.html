<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ef53ce789780be9b72677f954b4a288347b0da24c20d986980d1375c71fe4bdafb367eda0ff2496cafac1b4e565e09b872ce665cfde93885a103f478582b683abb29720cb08c2415c379169b494cff012f4eb3388ae5538aeb95591081c76db98ecff3a5e36c0c4185c556d7ccf0327e66f75428a609e10663c5acf0aded03809655360400c295f401035467e4636bd1f26bf316d240253c1ffb002cc6ad4bddec747cf054404516a9259146523b9a4bb5305ee1d1f888b5ee3603c6d92fbcc78242d44136d1c6c33cc02f9340f143694cc26c0d6f2cfa421339f0718f06f1c0c82fa06de417fc062591bee5b5f4ae6864421a85cd3249dd456b134ba36a08a731119ab183fdca5a6954243b43f0bd91f4c734fbbcd2c82fd59ddfe72c0d8ae2d9f4c999e679bef5f799d8d8282923cfa822c4ee590ff5a1efd7bcdda27929d72ff196bb5e2e7e95cc0429c8ae98a17bba227659977f4c5b5e232afa7c6aa8c4dee639eaa9f09c9e25330c5b66ce0707e91bd4863c2ad2faef8cccca9642e441e405d924903a02a6b52f1b4ad9cae92f6ac378ff3d1f46b7bdf94ca43547be7e445e2e2f206d494358807a862359ed2b342060a3dd108a0f31f432407f0df224d0a558f6990595f4462641c5fc777c5972d560ec0084cb515669d99d5271c078f2e530b6a34b2bd97143426107c91a0796f7b1ac543132cd6621cbc3486c633b68ad91550ba3ecd0fe9be84ba395a5e1863ec4dfcfa20122df5fd86ed98bef979a04100af956d0418596370eca0ad7dcafef317e2c64db8b42e969da468c54b3db6c0e2c1f459350d8c1aaa2ad22e1d6b029055d9d23c9fc1619cf5d1acf2a3563289fa330c3f4f29b53d3fef2f49aca43c17ca8f80b8d1a885a606cd55ff1f149a8c6bf5e8c44b4e3a8e2954a58a840b124d897c11ce0deb7a8309708f7bbf61a0158152f7071d91741d037e5ee84fd6111882fb76f84671296c03cc6aabf2d9b611e2b3690a164c4d641888f14e509d5e88b708bc77f7aa8d122bbc785a5b50b7bcc3923e538aa03ff100572a3a5824670e66a9c622659aa07617cbb5ecaa6d54485a9a9b06238b19108cbbf30c81f5947934b5e1e7a66ffdcb7cdca1dc0996b826b8092fc2afd1883fc04f18e444dce8975f2682611b5631a0f3544e0d3796377614e7f5b902201aabec50246a5df26f4b21d9e2953fed344ae90730529198f06f7bbd5809bc3adb8e1e9b9e3efc2fc93cead4d4db8a57a35a98b521ccf3047b9f56ab97c285e88d2f684be93ad8dd39774bbaa30fd283fa25318a4301d04b31e8fedf9fb498e438c5f1d338a43be80a8bd5bcbb3e1c13a786a3ea0bd57eeb7abb07e2afbeb2425b28e6539d57ae80eb2bf52cf7b848fff3300db43c1e97afe695abb3d13bedb3302ed3e8e505f54a2f5235c14c14b0fc0b628ae95affa8f562896471b17da24eb10da8377c4490170ef9049d77ae22da4ac31e051153457ef8088da9430d8fd4df09bdf11f864bfc774917d162f19d1c71c2c363bc0266f4964c4526c1a0830adcf660f16179bf8e8f72eb7ee8e2d29dc31660a11eed7047ee11a29c64de9347a62a31a4f18f17bdec797f1ad11ebc5fca2824ef3441cf71ff49efae44adb1639e641f253e0108ad231dfa877e5ae05c11104603b4307a668d52f40f32ac8d3ea56df1bda4b328241df5da75d2bcbd4a8b2c8c268e2ac1510faa235a84ee28d335dcda1b900bd8eea12da37dc80ab229a4454e5a228d9f2e5e1f7c3d40df117c9891c42167e6efd2700d7eb5f73b23b9361d71f37b80b27dece53c6d586384b52176b26d472f996db411373cc4762dd534a2f773ca82384ea1f7ed10730ddc61f700274f5bcae19c03b43441856dfc5e9bde679ee87566b22f1e8b4940e8cb70f726a77c757469d787d48981f6ae0b2695ca128ba330b870a88fc052cfd8b28b3e3354ecfe19110e41936d3e64d5a890f83c974de94640a8573af269390eb81cc43b5e5ed7ca803784176c63b6b9a4a9219e948a7d3afc99a124d4eb5427c7ee1a9e3cfdb3bf8343863373e4b95aa78d6ea69146bef9f86f8c5c58d8a59124005f5a0f48a057545278fa167923ea0a7ef6268b2db26ddf50fd955c0e851ed148f2649a0e868ddd23b266ac48bad58b179a3c7cde9ea4112a85e40d6e5a3c9e4df93c02764c15d2dbc7a536760f9c0d9a3194f68a73021eabda6ebe93fb6262f63fd56392c2f6c2f1afe0fa27fa9b43751f8faf0a6a2abb44a76a67a959184c0be3133fad7095581f367c3478d1f8435624307e7894149c67390465942cc22df3333e12a1ca44b81972d6590870e9f57a5ddc6cdbcce0ff01eeaa716d32a7aa9f20e7c2b7052227c0733c2c65cd798b2a9130b0063d2b90c4ca075a58b445f5f38301fbd1d7e7fb28c7db8193ef9e42430f1f11bbc260e1dd3a5851fde7c67a7a3722aad60b064d870c2d7e9935b3abbe549ccdcb22a31999510ab3bf7a64ccb6ae65cf3f09545f5ed711afaf403ada49ee876668524a5919ba967f01e785ca7cf79c9f4dc313123c1393bd56488a3d3f33ef22d2967df00d5712185bcbee9820eb8475cc93267856cc30b0c90c774805840972e313783fedefce8ed4dd9bef2b5b66c4a763b2345ecffb404f692e8402f51712cae3dd02c4ba22567a8b332d08c29171cd5937930c6acfe2e1aff7fe33eda4a1874a9660a5ad9f8678059840d45e04c8fdea3dfb822ce8cea2c8d28833ca49333b6fe5c874024cd8d5d520d6f3446d0a806ad9dbaa182dfda52b09530b7c6cdb32b81f5893150ccc7463a3b74bd6b5d4f094fa61bd9535c7aaf83a01294f67d0fe508674d603c07db6652c36f188b0313d7cb4f8858c0a49f411682c465b05560dc4615bd529c08ec3ad3b946573c8406e8b4a7d96317cc105b01593c56e3405ba4bf2ca43cb802558a901653041a0e29ee0ab25beda04b3bc5f12ab887d314649c1ab9d047647dbe35a6d76aba9ab82e7b3d73c5b168e208153e65bcbc76c2ea01e48be9b89767b47d43900370d5859f403b927889ecb4222ab23eb4efa97d3c60b90b2da78f8f2b285d6dd009d3772b698acd6378e6a4024f9f6adb01c45c03c96bdafef4d05365436942f318198f5f50f8ca81741469af8f99795fc1e10ff946c77f5522300535c5b4e2bfe2b5010026577f4808bebb84fae80a11f47ea89f54e54270460f47efce8a9e956bc3410527d5897eca00637ced3df030af707748d2dc089f797ef3a576c106ec81231e6449e04db60824f07880643f9b539c360c244e373413ecb98fc4250fe6ec614ff587221982270ed8740dbd4d3b0a19a897ef31b061bb21f2d7f7da5e8d2f6ea3a6300e7b216c9258abf97d6c2b9b3b4ceb3119c079b88b92ab7c8a7aedd03d0c6f2d28117f4bbe963266de8dbe38278b4fe3e498e431b8f69b55d10aae96f1867eef5d35621e493a291039ff53535d033cc8b5343ffa2142e944d58f4f5a4478715f72ac834948e085dd68f374b8af926c5349c6bf396e098c621320fb8d73e82c0f5c4f1288e461c801fafb9ee5a4f3dbd8cf29e2cc949ed40d82e89153b0ad47df4ba9ef4d436152269b976da667cc87ca6c85fe72f0f161c31aa7b67c05d53e7f8b080c72574e5db97190a0e0594e29fff559106ccf3aa9c00b69f32ed4e0431939939aa2e69ddcc8a8d8e2c62d0fff982de5cc7b87c43ba8d98944da47f055ca0217631d1926ad78d48eaef77caf1c9e84a1626f11e2ebd61f3fc9bfbad8ff4f969f486cf607c288fbc18c6fe0b941a62e8934818143ea050d22b76f91c4625cbab9c23a01613411496cfc1c0f8b4020538cdbd15a638b50e0e161951f53569951b72f556604df45397eb023fbdd2f590f4013cee932725e7bc2bf9c6e1ee30e5b931174ac4ebca32c95b9ca4e7a1124fdcf07f3b579765ed55e2cb0ebcfa7dae5647a5b2765fb58360e061f8565661456b5d203f9d2211192647c429a791e5ff1fbfe0bb6ffbe730c6ea88d8defc4dc19f5120fe30981801e53d5bcb70ebfe8f7faf6685675dc4df93548b3e3f9948a06d1999135b3c395a50f1d9c8874366301bd4d121df6a08842a8711a78507d20881fd067b3559ebb5c2db724c871c92d640ec6a4b602f1bf3ed3321cbec5b1f7216eebce1b0a83aa4fe4056595ead423aad98ea56770ff9f3e4cf7510d4aa2f2e63c0ee5c6400dd1432d0d56bac2c38f6bb6fca4bd3ed8c91b25affe1852a77234c8f76d563dcd5096582948b35830ffc535676cbdec58ab25c85f8194ca9655189d550ec96e322d3622b782c5be1e42989888a996ca52ba95f7a1a007b16e02e7d7ac1990e24785f8e2d3f847c8b96fcaa245a3332c512d8a58a034ee37abab5032b6ec5f17fccfdf67704870541f9322e0c3c827a3789b758fc6145b2d5633c205b819355e023515198b16b83ab66f007518cb072668ecedb5dfd211cd2a25824a7771c990f54cc7a0572c0153e76d4a3e934e2d5ffe3ca2630763ef442ad665c456dbaf73e954d3f54f71cf34d53e35ced60460069cc4cfb48e8072bc20a1f512e0bb5608083068475ee00f2e28c977cc5a7d04c96de626ac1d46739d2f5d13ac84ef642831ee05d8d5a46f773334d8c4b908c2c161f342239baab3cf737608a443a5c5ba8b06f8dfae9b5ec3075612ed342230013d17cc724148974d31d08ff6d2afac4af31585159ac19b8757599c1dccd395dec2f65acc44fccc4e2acac597d370b17e810b3d33ee118514e57938f663fd62671be02df234b68ba00d4a73a45a0b995c17a96b7a98d0ee54696d49de25c7ccfbc9142a9e22f60ea77e11ee551ce93f265730133d28c40b2b549484aec41542a6701d21e71d8f2b7a2429bbfcb84045f29b7df1a612a27cf212c7e1f34ba73474847e24330ef9fb2a62cd45090f34101afa418f55367d8b0ed5a102bdb4c87c6e615f4fd48bd52e4dfe4d959d9e247ddf04e1517d101de1e44ad1372b622605f9dfa953e0e924cb9d03f22b2c193b93d4ee32afecbfad6f7a458d9ba98d3f3db2827e3a53459c55314724dd6f9a5eeb8d0cd210d8b85e92c0f3a75b5b6a4c959b1575cfd9de01870d6762b33c5b96bc2d6027aa9f3b2b061951932d19103029fd3ee22f2c57d1cda0266e1eba214d7300e24ad282d6e9232846b8d04a8b1241746e0d0f8f580860b27a018a87e3e12e99a31350d1919e2f447774f53b97c04303cd25b3da2c7725277810dff623e9f7a469965b762a4265c87503d98819cdca0ef32af2f77f85302daa3b842a28f0fc7f7c9f334b8df41cd2732274d849f5be60acaddb11873bb2d7c976e3a4a6865e2d56cfce36ee0100ba9104b4c1ef74908a876a168860c033d79397e9e39dcf2ebfc4dcb44f3e1d8d35d733582227406f82439d1714229303cb222eb99085de7ff1b37214029b492581c5192f5e245b10e7bd7ab2ab408bbb73def7ab36416f03a3e35d29c0389a046b8834df1b8090c193aae6876e32d16105227e5752887eda78e93b99dcb6aaf732c1e5c0172b46ed4abc1be0a9e5a5cd68b5c79be4feca0c6ab1cc2ddedd700f96576fec2a4023640ec8433e123e4a63ee66dec264305aad31a541ce8ba57b169366bfb1167ab36312ee8bc2c6ca78814556f95891f008cb84c3cdaf74e612a82fed0790b4b0daae8847d6a7b89abe172625c2003ec37e264774953a20421ad6b7f41f3f10bd01c28810c729c145c6a084b78f108a97f27f0a66907f1a8b78366cbb2448633e8f9eac910b6a95af30e3b218e400b6f348abaa53d19af7fdeb69497479a1b6f0d80b54a9ea5794efbf9acb3b6d1f70fde35a0f9223bf262818cef5e83708c6db0e85c2146347788eb740acaa0836bf49f378a5fcba26a8a13126e3b703e8cc8b424a8f97054cc37a40e40449b3bdbb90d381629b73f6f3adec75b69a4f88caf546792ce2857f21e78ec4b5fd088774df229120eba9f3444d268d063430d30074def64f0b438bc1bec8aa70dc8d6bb509a4b00fd32e86657ee9cebb953aaef2b6dd0a16ae6b62384bca0682aba6d97b92bf00f035efce5470ec217fecf2a57353def60e543d18abe3f45cb9e94e620ab7bb7b1502ef6b42f0903e4e48262a3b9cb4d3148aad7207c416d8c85f27ba55eb4414553bfd2a058f1adf36eab52b01790d9cf87ad1c371d1366021b36f02f4a94cb035f73a92a6eff53fcac76e1c6a36405e8c845ce0c1e4aff8778cb8d5172bf7ee19b32b9b7f4a7ccb34e3e94b8b12bfc8276e1f74e45c53ce6f8c38fe7bdc1a87314bdecaf872da8a25a8d62fb2078e039d82ec2fe16fd0bb751e68bd6088df4a41596631e33dde2435ba9223906188fdadfb0cb4c40cd204e28c5dcb25086debaf37f6bd1d90db9670d09d25ff7790eb19fd8b29fbdb7005eebcad0a670058ec4759cd8542a64f9c436a59eab7f30afdb45249e933edd4829e0879d1c4edf546e7988e6274b0d3550a763afdb7e74e9350911015359dd3c9fa57572425483e2a32d9b730601b0c95544bbcaac4bc01b7478031c142080988d554d1fc4ff85664c86c0547117678649661448716f4fe2dd937887975230f875b44b729cc3d035d4807005a4836ad83a7d2c61b2cf9767c93a2f20d15d051bc3a3ce05d8481ef1c5db6d2fbf5d8df5809b9e68df5034a024fbd332c77c7714e0f6abddae7ec584a9876aa028c1fc285c349004b10b5af91e959695eebccb39c493ea9ec0a240250dab19352b233aa41b90282007db1119acd6928b0918043ae35c5823bcdad0552ec640737b23727ae002ba217138d1270be5ba985fd87438fb0a1cf6746b7e5f7041ddfeb22d5da78ed8e175f681873c6f16598697d177ffa2a4e3d4286cd4b4ee7856ef3902792832c74376cb89e6d4b74bc1f4aecba00375661459e8e6bcb357e9258fae079421c413d2258cec6072c18591b07b336d5e731e66085dd737c1ee6b3c4d92fcf9eb9bf015851488b7830900356b72c0d555d5000eb04308d2b84d0ec07a0ada2cc02f3730a0d3703d1f2480f3c143f94252aca3772757c6c641a93af4f7b178e225f3d2fb4d48c3cf2721fab18a72c8cc21e6553a70a8ef855e14b3bfa7196b39aad4c31aa2be98dc0e128fe9b1815c86aa94e2b251ac9cb9a7b988589ae55e479cc2dc9168a7295eb95c6a8aeb5371af6ecdf4e0b34fe96bf2c0ddda72940c53562fbd918098dce57771b2ffeb1914e33a373d74eb3d0e96d4579b10f9c8be835899bd723a427b2038db7241aca38a299642e5886bca862643073ea26095f586f83e1a2e794efcbcd43e34bb04c6b504ef69fd7bf82a6ef4140db14295c6260825d59f72a1a6260af62bfea2a4696f205b6511f61a227ac2f0cb28b33d05b814f0538a7427d232655e739458267acea11d8bcae2877fe16f92329a020be00235e9a0c90d881ea95848a9eae302bffdb99dbd7db5f47d2e3c01b447a3d0d7d6a47ec60ed58e28746f3ea2ec56816536c7125e13cf6bd98622b219953e9cb55c2e1a12cebd3a95441346d690073df86115c807efae933381c8d6aa9e6ec80974b38455bb09e08b1b96f60ca6d9718101f26ef3459c40ffe6b171e6e56461168847dca7147797918f25054d2e95dd74ddb0b8e54bdb5bc66fc9778fd9bd7aa1fec5930c883a5c7341b3b690208396b7c64a4fe68ca9f237599a8356843d636ee9bea48c79006efab6370f367dfdf762ccc1148212863d1f3f98af20be0757411c80e668d6467813417197a45929cebdf8a98c9fd4243bc028be4f808cfb8de89c3e67f1205dad7f9ea0d3d0849bd50f90605d3ac826bc8037ba756f1b57fdb8838c425c123f21a222b16361076cfe5593aeaebed9d7875642a9ee224ab1887f65e4a396f11aceebb37102dcfa4267b2c9c6a6fad1758d81a61f3c551346792efac7d66c67dcd72d4f597c7761ea8b87ce8073eb7dca944691bf97ec7a52d6edc230d1862d4cb2b55593c8e1fbd574c0199db89317760403d08d14421b2403cb40d63029eabe35ed4d2be050cb0a5e4190d1d6decae07b35dc68fcfa8b1237149811504384d2d5b7ab25b02d050e4dfca9d1f9e0412e2c321d9728dd0048a78ff3c01e778867de7f82f9f8e3482ef601f6cf252dee2013a7a904445a4dfcfe59c994de3b2e207dd37332b0ce45be4a686ed73ee79d2df0129cd122de322942b7fb7458c15cba670d7d7edb5e211a0a6f6b894e993c622e20b019e25c6bf151d18cfdc2825c9e8b8516489808d778c06758311224a30f431b41ad387f87c4bb4f90c65a59d95dbf5bf3e28379ac3900800c3650e7c96cefa9bc77a1a5a4bc1a52c58383239b96f0452021d426771f9925325574293ce313a86f43c8a7f8c2453df357613a11e03741d188818161366a8126fcf3c683ef0886838ca565d8c78f589a8e80d5f587da350fb899d6a215262f769af2482e18b6220cdd4c6ba8a3aa210e64270c8b8a0d01bedf9f601ba41f9390fe0af2df3726544773ab2c604dcec3bb4495c47fde63d2c8f19dbfa9552eb0027851cef50948c1d6b18da4b9777ec0850b782c6457fef8e72b4e718e85a9934807ca22d3e2cae141f42d525c839b15305004c199d12640bffb852dc796cc9de8a38a9bb70d0ed188aeede4c1ed6b897370dc8d0f92a3d3744f7288c6a8ee63cf840bcfbc810ad95c2dbf3d4ce3833fa8c40d201853e4a82229fb04e5003766e2731e98db2a7a5745ad9a1efaac15645d39ddd36a192bac11039bb784062faa7e20ec29ff90162e72b46a371397e6208678ff582e18b7ef5f64e817c5b17481cd51eac047a93b161e51e456b57e56960a6d08f030527c7be2577caea70304f4c6c886f082e7aa03b0d0c899d2f60617805e722ce962088cbaf508afd81cc896fc4ed74e2d95c6fb4e08504f996e275785d430fa47d2b3333dd6050df1f7d9c9d1a86907a4f83ff6debe67beb91f472be24677fc444b67561105b06d5ad328a601f9d98c0acdbde95dd152ee9a1351626ca4a82b3927386cfb19ea680b1232faf6e5f93c5e702dbe0748dd584d9ad0b60813bacf1f07bf091007da81e3148076e14a7b8b5b127bf44b4b5d8ed20cd1c9b6aa9af6c9faf01be468e0b34cdc6f7257d55844346ae213b71100dbabfa7ecfeb3ce43db5a4811204c4a6865005f79f9aa8e670a7fd3c2902abc5090a4c6ba16af5afdabab6dfbd14292420147801ac38ea1f6b3230b25adb67e2645d3091bebcc88911e83a73b4a73c7b797a002ce637bdce494358a0454e12de46e635d26280a4b8cf43f6abdec31988337f860e17219d0522b7c15389896e6afea2a9fb989389ba25122556cf354993d20f14c19923a53c451d7b3d0aa3a049058a2d628b35145de5ddcd7e5d62d2c713ce3064b9d4cf4b3a749bfc6d2839a82abfff2bd051925fb56a5411586d5a2b876e3319b0258895de4a456bdbaabe682fb3313fac029a2449f5662f62c9db5df13204bc52602ec2fe6bf19e6f1d63a6c85cad1af7af98f34cb0fd336d907da2bf7331f09e3e3f88ca70e260bde12f8a6feb70ab4d700ff14981594cfe1bcc558305ac191b618ccac317897df055528fde32438ddc9bf56622288e4c1133b7e643f86e0437cc698d921bd1dc4f9d71c58c17c7983caa256c3d334a06131242d900d762cb0cf4ce39a43624b7377e941781e263c21eef91ef1411a22eb9b1c2f978d3472a8526d4f0e4ebe8c95d217ef4f61c9a7b342b9edc0bdc08ff70b6d1551bc61fce56e03b9f09e4337079450dd8644da46b6593f83ad801ee24aed1fd89fd3a7c8f4288631761345d83a49ec6efa18ea711b1aade8a85ed865181af9499cc0071cfb00e25a11fbeaae5cdd7fb20fd9eea09b42c7471d4f2c8ea8224196812c6f8362164b7d446ca48761729d3366fd2d39c4fd673b3ee5ce2e5e0c8843d3d5f3c78bdf449dde9219f9d69b49274d94b2e2297ff19680e62e06231f17b11a3b5350180a946264537761e070bfadc1cb726179e3c7e7bf60c6d9790d63ed395ef43e423138f499a8e85012f7316ab83659586dbc501b8a00a4a54e4457f58200489de1a5670af72f80dc22f914c416e159416924907920f38b834a0f14add31ae70a8de70d7daeed246de1f9163c51017d03c0928e89feae29720683cf1e594d0d0be3f5649f866514709f9685d728c0f0d088346f43a19920813ef12795473c9e62b9a6b9e962eab281fb42d0cdff695664982fcc17052d6937b98e8f2c86af2f2f2b076187a8198e5e9ef75e5848c5ed69561bd1589d773ab6882c219f8e765a5f39a6708fde1a9c93c6d1d77ee4d6fc9270709b657b3e0e6f21ce565009140f2f42df1aece1b718589b7c72e3a7ec90da6f1931ef5b2e87d5448a89ef1f22919a417bb04e6bc03c58bf90c494278f6ad289e4390e60da67fa4fcaf580b43b8868b324bc054c4d481d4fcb5f5333ab7ed9921a7a0ea20c71228a79ad5824bf95aeb4613aa1dab34eac2bbfb464e711b218d97acaace4c81317a6afbfecb633d6fc7162654cfb229333084536cb46c186edbb5bf73b4588f1dd9baaa14a2a3c3a816a29bb72e4bb38a944ce1ef2e224d25b9208bec4dbbbf19726d2734afb841e19da1ef18df4dd97aeb2432de07e0441515db671f59196fa30a5d40019ba261d06e0cc1d73ab4dbf7dfc8ef7aa8314f45311f2858eeed2d064d28f47007a8caab03bd6a5f427bca131b4bc17e4106aecd257a4c4509cea70c684e1b40bd32b24a0a29618ac305db2650fb52506b38c0a2a2f83f0fd29cdff36768a505f5899d3fbef9f329498c0426dfd847d9f15153cf7385a5f5d0e34a0c374c18074d603a74871e498180019832ab8dbdf1dc21340c85f5e3fefe87551d5f30c94f8cbb2acf457a43524610586cca6ee3349130a6550012255b9622bf75c6881aaa860d37da9ed1bcd19338900d7d781b8b3da2c162d0d3f8bcddac51fe6e215d9ed67604b3be4098f782a5f776f0bef8741cf6b6d3fe0e43eaaeb10baa57a3e89a95289dc54d4495f017452a369adcf1d402b620ec368d4f4ef42f4ba00345d23c800da8849c7879048f10e22a5e2c96db5565e3ec945ef1ef4afa518a79236255a00aa366c04c7bcfb98bbb8c637c53eac23c7b6eca1e9bf2be2ae62b0b507f6626b41017fe2a6b669f95c732d540c5a6f0642465c932ca9e3e494ff8c948fae1014389c71a590f583e29a6605a35267c0eed5139fa7dab7dc372e8a7f2816c1ad10bbe8bb5a1459490e37f09ab08c7cadeeac276eaea971cab416e8457c127f74fde542d8950253dffeba4e6c0d844652111c47e54427343bfcdcb6165cc9ecb1a8947830bf50aee57a2612780b00a712175a6ff727b4b7749b81220a3c33bbdac4431213140b3c42330a672827a7d37caf875dea65a9a8d2ce2391e6f99d8271e273b4ecaa7c62cb682e44f6f36f93e0652e57c97b05f44a7012623917fade99d05ab98bdbd69f60d747e1388caac7a5a4c3e64a6d8ee3cad503848f2e21d03e6b36940b2ded40269b6d6b1c840649c5ab1adf623b7bca1437670e95c16cbefce3400ade470d4c6b8d262a0063a72a5e6b4c866a26252726d9cdd89ba0c4405f0c3c2d0463c90fd406701229e1673557e3101615a607e0df2fb89314c6ff8801a5acbc826399ee125c383ecd6935d5e42e82ebbd90d5f50973625d9a4c105c2f8e4bbbefa821c0f5d6cc37f6a805927fe6a4cc7dd25027c539f8e47c0ada8d414f785e89287bf95339153015c2472e0586c3959784b649df003ce1caef7866a9c28c030fd0e2cfe9a4cf1fc5271910fc6b4f9365b7c83c83af06dff970b326998de3908dc97da395a5e5a56a97d91a146e7a6cbf2c62c1f70c486bc2ec93a026288ee63e36a873d5576f8c9be3a7628d39e38629d1ea732ca7b59660cd32c044263d8c6439027eb90022de76b3620cd434122de5909ee53ee904b44b265a88d44e48b8871b19510726de3121b1db9388c1b9c71cb1261585013018fac04f524809fd3a11fcff4d0cd7eac99e9b0777d1d4a8354b8bef287fb3009c3f66a202f3469835a286ba29e3d8ada88b1d7f5d2488b14d77ed15ee8fdf0a74f4b2c4c7d3ea9c56dc7ce3896f1df7af14139433298cb6c787660315e7b55a314e13d2d6fa71b480ad16a31cdaa96402f252c72484fbc0fa13f5d1efcc0762b85885870199e300fdd036d5d5f5f13d2ef20a533c85056c8fad7f56f72f0e993d5dc926bdff5e0af77dee139192bc9b6bc3448e9bf4d235aa84a677dc39764fbe9dbe9719f208ad086b3e59b43c43bc87b0b1b74b23d782653066f543fb22fb2fcd649afe3619588416aca82949c45455520fea796ade2ae930cf1435037977c7c9b463ae868d9dedd3c7d09f44a39b4947a45e4a475dc786cad80f223cff84d7b0b29b8e4129c57de0e38754b9e3ea985457103036b300972a72c79110c5ba420b3b5e5753b36b22fb1d33348176f7d4544cea24d92ea45973f680670ed50dd4fc17ffe126b84ac40e2ecf9326fce8848f86eb8bd76eb1f5225ff5e012688a23b302f40f7fa1d70c4a4b7bf51d194f5ef6e32b9bf24c991ebcf3b6522c42d290c82e477d4e839523d864a9e642956f648c05acb979428faf361fd01aabe0779e4d0d8f2e677c09b6d904269c17a4f3248f794e2a4da0ae030bca02a0c493852a1b285cba2fe84dbbd4fec57309a15b052d674872aca9aff134ad952dfc9ab525a33761bcd873d5eac107b9fe715aee19cf656b7596dfeda9bc9e5bd89775bb9b2ed9526628d8f3bf1d0d860a6c3067556fce95d67e99d0c55a4e75082dd813ab4adeea6ce16bd887effde5415a2e1a737ee909f877c0ebb7392f5f04935efa765e3cab856da3bb7a913c45f9179370b5e9d415faa6d8d211b245853a244564775262bc6fe454a23011249dfb88bc30de3ed8e4ae5f4a3f3b0709642e9f27f4d433c9d952fa57c6c98248d7ff202338a26d878a4089c588ad73eaf0197a559cc420ced5322e813f476302605ff242079e35f00026368925e112c201f10f250ce7fc8d0bb6b0ccbbf04fac96dbbc761931fb0a36201f4a4ca82de2c9ad92626ec902c5a409d51aebef422f13825903341272aa616742f37116cccd4bcfe5b4af7aa292a4b06a158a6936a26bea2a6bc473b8d4138ca484ed89ef2e308a4d95455318e715a0808a99a4cf70338506c99d797df2874513baca74152f5718555c0d724a6e41851eab47e72283e92cbb6a27ae2f8ecebd5c3ea065ff129fbb376ed0927c1f4c9ce2aa37590df8da19bf949e5316d7eb9f8699bb2b72c22eca1c7b210c19862c965165e91fe1d590d33938e5d9b98d615c25a395e68f1e46917f35d6a9ac941c3aa562c84342059657047ec1eec28755ca01d3021a56c91b3d47fb16947cefe7df92bdeb5a65c3a4dfefc327d92bff6ea3d4695f0717d4fc6d50aab4bb105b3ac8d25cae26eb5bdc57815c87727ca25da4d5ce9147e7e49d5ba21f4fa7388d25ca8f18819a51e321e94f229e6522c568a5a519816b3e5e6d8c85c90a0156b73bb150d0ade16015c6d4442a0a74218109e48883562568ae092331fbe7b4e37396131b7c8c7bdfe79d29c46bd1f80e44cff3f1a2fd60dded2a832144c1e6c74870bc69589b9740d596d6b8cb80778cd521fc0885053083d5390f02538818e1f696f8335c7b6c4aa033eb5a8eb39a6f6ed24a703444da0f02f9133ff516e48a9e8cea79c454ecf702ac9394281f598b25d13c6ede6c645a32191f48455d44e743bc81fd2740a6990ca55e5120b3adb2870d4b4272e0f51d731bf95492f4500b33ba8a8a8b3e0f483e785928be43191bda2d46293cc9eb31587bb5f590bd11b6c73121e8862e1c257210adca4efe817a43e6ee3a0740d3910638bb11b8a7494823b661440ab3eeb69d072f7b45c2e2733718e285cee4e466ebde93697f5f0fb530bf1eec32b81d5c04f17ae975139e5651c403dab7be005ba6c373b67e4b014a351c68f22e2d388311c4a889506f9dbe9bc326c15e8da717e640313f5ac1fc61fa6e54e28a81909d293561784227d9145dfacd1b87ae1db2c77cfa2ffa088cd28a92100dc1e90ccc39e1a0404be66774e5ba8761e8434b1502f94ab0674875ba1b9ca4cdc76f1841785e1c3538e510ce9da23b664037d4f7eaabed48989109a90093c062762410ae784b57c660577f3ae9dc9b2614b57e1614d7856ee00c4f5da71aaf87b9124e66b655118448be3e3fd857de5408606615911e324f84324b74cab847bf041f5c53f34ebf55e600f442646e69d8748fe4f55925463df56e424f716ec986f8499c239a96b6329de186512dd6d6c52a9437a27a8868a6c9faeb972b3488ec96be8bfeebed5205d54fc9590a26b563ca9c7a33e2477e64b2817bfab66dacd9d8a1fafcf4c76511d93cf730f5a8c2070cfcdd872e49c8c1aef5a98ce930316c92e559d6a7ef0e9f1e1827043bb551edc617839d6de90b802580f0bab5f696d7c7a3f3b412d2eab2820493c0b2cb14f5916b259760cc0c6b8073b76faeb9e84245ad23dde17a66372d6f313ee7bd0af2e650bc4d0d1493908e3e8c8b4f4999cf69e1277e3d0b75526e21bf107f9ccfa8ccd3cd9cbd7fa6b3365f4c7291cdd5da3af95ac2f444d1f8bf301db60cc20a2db9d88ae88e3bfc597cf3848fe0263c294f73d0869620f8cbce3de01c1411fcdbb69dc185238220347c879e255e864e7fcae3dfbd04fa7203829246a3ff298674963624424a634181dfc07be3b0ccef2e1ea8b362ed21981a5f335030f6f89f0a88827509c49a407f3872d1ae8dbb6360edcb164ba716aa2dcdd734b353f6f826ff7ecda7e390f25d1dc95477ff608d1021fdfe0c5473dcf757bcaf865d6a6e103f0cfb1ebf8c6126740f2d4df8235479ce1c0d65cd1c23eb8112261fc486e44235dbbd6a5a2ab92c7a4382e0c58ffdd2449f7cb4d5e7b201f5d5a0f8572027cb8575e3acb76c077e001218ffe27d74fccd75f5d1325e43a8a9d705c5355628bf3f92d3b22a8ebe925505310f10ae61455660d7904df07dfb0cba405f2e9b3b1f9b3e9a21cd9c2387bc584ada8ed2a95593127209619a516269c3955badc3393448343b5b9639606509f142e7aa58f54ec6d9ab29d94d96418ca1a4a2b7c8c0c94b4fd601a32d7cc9ac5f021e56fa19cac7db4a0445df7f86e54bcdcc83b1053e44723d9ab48eed33300442c021866300202505623be6371e61e98ad4c6ecb8ffa5700f9aed2464fdaccc137f17f06a3880b548014980335a285d5978551e9d4decf2bfe4bfca23cda82c48003cf3af2a659b6e34ae129266cd1950fa3b5e196c9ed8b424889ab23477cff1dc4ca0cb80b3fad8b730b7bedfc3f6f6c1ad654685021eda6db808dfdabd5b43e17e783e4fde7081db9e2d51455df422163bcbcc2c2565be1c590a5e8af81ed336d33f251666c1a59987e1112753c23e19cde6d36d0d466d51b37e82dcf4f6537194eaf0999e87e609a78fef744665573e5804d60a91590f0c49dce6532909766cd13a2c6cf83d43940aa7650b8de0bb0e2f38d4bf3ac4a4ba2ac27ce613cee77a2658dc651b18d18806568847bcf2b9d1235053086c0d332a306648466a0a962ff731c007ef41fd389c53aa9262691671cc10963baacaa48bccc0c5472736906ac9b86e6f39b195762db85580e553edeaf1c9e9abe483dd3684a2ceab2682f318834d95c53a5e544b1364037ced7e792ddc754b95515b18715790a5d72a323f6045c821ea43fb8014800d7f5ad3b50469627eb0dcd775eac96c5cb9dbaac280ba3b35c0e43ae134552acd4c916b743b94967918683c8723a4d11b4ddbb3996eb2b311c133ce82464c13012aa3b7daa89c87fbcf8c64d491df7feecbc1201b8de4912bb6b07d9fd2ba964a374a35216c19adc46a25aecdd1455857a4e3c33c4536b710ca49672761cbafeafbe6918f4980e568b630ef63702cd1d085a0265eb84d58bfa9cd9d8a92c49eefc27dc5da8e6873ec5546ae014e137cb47b1fde427c46e37498f7031d70883c05242df44a2c91278a29fb401752c5a9b47bbe118385c8e4853f012ccee47562596a9c1bf38fe3d686fa55ea50d9072c5ad3e91b1bfe18b6266c9e60fd2a2b17969ac1edb579d0b7df5e3bc1718dcffa0f9d1c29d97d8cf0873f380b958cefa70776cd9de1dc19be62439f8d2c210c6f8b1f297ad63f13bf41cca00f3ccc82bf353de7ca4fae9718098e168014162a37c726a605eabff36ca71f83d79d6db6dd850edf7dc432272630117c8f16518c9d131941459f674c823f35733b3bf2992ac3147e0c785d46a060ef571f27217a478aff0f9d86a11d1483767a91359e6ae4871780979e5c93b412523a13327f95b32838151a4c672011ca902983e56bd5d2ca4238d043390d51c2933fb12a60d90bcd216de76050fbad4f095bbd125f46a3f71759f7e123afe3e7bd8a6a8b9bcd3392f79be099844fc2185b87fbc34e6514f9dd643c4114c6f35a0abc1e05c19b9fc7791c5f7cdaac5ad9b26dae8f8f0de9a5eb952211e0830bac9b1675c6a8dbcb106d79278fd040ea03a730563b15335070883fcd2f49712dadfcdff590262341baee7fd58a906c5d924d0123df2c55c7acd873899ce532af0950bddedd198d7cee8b3faa235715e34c21bf3e7aec476eca8aac325b7c62227e2123c94acf1110ff0e6e218e6df0e2dcd4e881f9c7114740159b0e49169ac144e65521fdff80bc7f4790a0c5737324596c8f7d289ea0c115be5480936f3be9bd9aebfe06e6b8fa4978b6a4ad555251604c2cb887f4c20a859703cf277b692ee5d1fd0e7469ee9cd6b5a56056246485e626c4ae875198083a8f396bf88f237e97c1d7992bcb53e47fb055c8780cf236e612ea0fa256eb96b0fecfb2ea2008dbff8726aac18b63105ad054bceb0a304ae83f9395f7e55039c584b686066a2b87e2c0744c5aed779f7b840ce7248bdc0d2ceed2cee502049feadaa171fedcbe811167dedd3520983200ea0e2c371b219d64435f1ca5c908b44f1fc330b88abe85e400664871fa622c686b7a2d27872c3486540496c2b43964f028e287c9efcf0fa610ecb94256be58f70990deae66431b20c10114f3d673c264d96acb70d13957c55ae46d9e8adfe7470609ef6dcd8d687472f7187071d8535ff282748b7db73ba7f9e83dadcd58efeded858f5117ea12d9f5687f28d2c3d4c6b9bc657cc5f09359499c8fe807715cc77c73406563919317ad6bffb187a73a175d81a95904bbbef8cba8e08556eba57441010e0bc3fecc978bdbbf2ebb75e78aaa5d516103ef88de96c541d7998c7166190f06d579c1353b731d074e1ac6a5bdc51320cf689de39ae7ada85827e78a98ff256b2773d5994ec38f9d8a05fd453205e16c36a2a291c97c06803517919dd1ab1ebec8d352ccdf4fefce66350fa5d73e3e344f82bc668c12e0be8d04aa80013c723904aca59419631a3c9101807809709f213d59267e864bab7f2e7619eb3e9096d6c33f5a1b04185a13701b7343564e461c81c7a3ca7d6b56647e0593e4e3667546b1d8c6ede58e70f5948f6c324b8839d46f5df5f5bb27bb43fc3f31f0c50b6286ef9ddedf611ee1057c7668108a0a824cb6e758fad475de3be0cebca5591181ff1fde00f6968fe84abf4714e1bf3436eed325b6975050f360aa1ad15b0662a59dc5cd8d8439f69e96a3aad1a2c7257f920b64873cb44ca8a1ee7186d32b26a6089ef4f1cd3f5898006f4b43d194e86905e04d0883d1c9984926bd1c45106b929337e6cd8bf7b91d3ac5099497a19ab65169fdbed3ce40b71c7534fc4ca0087b5833ee5fa3339f29cf9c3915477c5d0cb3ea62108418e2a53d606260996d8170a771a86671361bd6d2c1d7d6ec6e6bc66564b3a1d745a3bd3ed9458c509c5655a8efe8d47c7641ab91c3cca2052c0cb04703609cd447a6672cc08444a75d09e110a0c1e4c4f4ef10758c16d2f61eff4bf687f4743488a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
