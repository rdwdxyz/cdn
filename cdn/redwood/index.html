<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ac3d0dc445034fd6cd1c18de0642bb7e5b048296e45a5104d318e1027a19c6900548f5b23571ba9943aefcf4d141dcbd24f4307f1006b8621a819a49492f39edc7fe14c67e4f0acf375a889ecb4c7e322e6fcad0c0ba25deb57a868ed65b57784f99b216827d2bb02349f94eaad7d265235b2881055f90fcc1a56ffe7b9a1627874f96ef424f94aa256014980fd0202b0a0cb7b1b921349773318480d8d42ff234613ad367a9bc01d97ef925aa50c9343f3ba977a769de019f45cac3f0504dd125d76dba3a88428ffce134a208431985a974725c8f1554f2e10b40928be742bfbc56c245400cd57f0393913942ad40caa0a2f1f3daa948daf9e67dba843a00a862273121ae614f0590e26411636c5731ece164f28e2edca59a55f4fef4594ef373d51bab22a240da58cd975f8738ec06c01164b88323e650f6448bf9d31edf883e5a694c83a47193ec896df7c650afe7c245fa1558f2688f4e156955aee5084ce0bed514af09f544604a873ab3f9533a83896785986fab214fe5fc6e18551564712c45828af62fa0e0520cc7ee83afaecaf29c41cd5783611488053b7a7d40c2e578c6b9fd43ca45c46d56923fcc3934e4ce4794064718cbb6a3baad06bc0b83caa574ab271c37bc0984efc3590f0f2507066397dc32aba61489b144810114876f6c56e76cc4eef2303ffbdcbe0e63c3af4cbec27b6535b75b5cfd2d5f4e3888a8c082c43f007fb6c9d164d60f566c73f004ab53a39ddec3f2fcefd2c5022fcec5fbacc872346fc9cab70ddc486a5ad3181e968c1e1cc2f2ba57b478947e39da6cb2ef5d46f3cfa341c452cd36c6db6260339ea38b85004d8d52e0fa05aa1ba3d5ec3a89538b1ca4dddc520ebd76c56df3177dcb01135739912f7ae797f4513c93224c66f9b2eb0534921c80a7eb8e7553b9092bcbd17ce62d585f23b2f3ab900b9ca84ee78daf912e85ea66bca8315f3f0894a732fe49411bb5f51bfc1685789bc09737be0ac84fedc25f31cc12646c8a234ce57d96ef1d8e207a5237efd42c007bf06d6e08098b9e626b514777be0cf9773a13b2521ad8bac4de571d58ece43c0e62a63ab6b5a3f089d96d6c86ffc0f2fa745ec72456b9d77f6025dde90e501ad9c74fd38a0bb25394707364289fbb7f683a2a8fa0894bde838101896a5104aef010f27ea895168dcc2a38c1522f8da792913c312f7f91b947ee39fb8ffcd2013a36b9adb08fca3d5582805c58237a52721f2ed4f74002a2bcd09b516762445fae3d7e21b7999a2b064e268fd402c0fd7a57a63cd2653854b81f811cb069cc8f20fe9f8e6f117bb7eaec4236086c5b70d4b6e3f9d2c0d718663ca2d5362547b8f530ab2b6f560db931124f476597631d0035c9901bb5d74bec665f9c2e32de9a27a8e61d14ac2b44f8a600133c823fd28a4ca48911955a95700cdce29c4c738f264dffae33cf1f9bad067fee4a4c1487d77b3e18b302ee05844ae2ee8a01d8893088f7ac4ccb60bc33a1c0dc74ff4c821a57a395b77cb00f2649d7c1d34561b06fe3a822323d662ff8e20234b99993123f72a1f6fe6b69f15c9abbcf59ac9c98970c27322a51c6f4b81f532c73d941624d9caccf677778f2e1f30ecb0f2feedab8f3a712c4542e2b7b0ac30d4a524766b31b5841c6537642a7f93a44cced6509bb5db9b5e8bc74774744237718c27c735c6d7f14731763fe1fe4ecfa0ab636c7e818b490522c8dae72d9a8949ba7056621ec893bcf2a15928d950ba91bf58f442d857cadca4038f3662d934f98eb80c25173aca787f6363454f52e26690c515e6b007f47fa20d48649aa59f587eb2fa9bad08ef97acd6ad8564ebb3b0ede12bf654acaeff57e61317a4b72356ced6eb9f563cf7034257776e2611afdd199506dd874004e1ed2eb8751ce9474662d10ede30bfed840226c0ea83704aae4565fdd2b3bccc04483c58751900af34dd08b2d707e4d333455214737ff22e8d354db164e3477a0b2c035395ab2aaef38300760e7fe8f0d7a1e2b8d3e65b167893aff285a17749a7cca36c700444cc3f689939e8a7fc150c4e05d8798c6c81cf7f5908f7ee1d7ce3b62ad5d7f9aab62192b49412f43fc9bc79610b25feb5789ab4fc31ae859563d093fa3f61b107dc70d36dc4c18a857a9abe1ce1709dfd0b0e1b74b870e45829e0538867e663549ced2e5721c2de39b293c3f6c4707ee2e626372a697b3e7561925f64932d404460778aa8ec8b91599d4d0074857454afd07b7c5d87c1fa0ac6874cc0c98bf76ab4151be2d58bc379598abfdbd709386a602ece311257f991cfc0b0c1e698e41dba3032c056c7313990e2cdab1ecfc8b5fc0522d6154c7294f8db0c874c0a359049bf2057b9eb265aa74cfbacf2a8f1bddd3b27e4621f66d780d32900f190000baa61049d33990545dea157c43f6a08d631a013c57c74ac408dad6710916d244946befca7743776d7a351ddb85e7491d15220bf07343cbed6d897b12ec512cd0e287eed7d1806e3d5244addf6c4c0c111a9259647be85364a7e364ce4332ed786d4c48f0391071d8f42ad93c672fc27e21aadb82c2a25e8262bed6f5890ff09cf575a7e0582bbaec7958196ed04995ab09e964a5ccbdc9b297e1d781bd869ade61c44549fba3ff79488638e6b23034568ee9f0ba88ef758b4e4b9f2aac7980c1ccd8fcb1ba47660073a680c84e3a5917b4649523b64c8919099a40a2a127e98baa24a33463342b8f4d9e8a90d84fd616fd7f7f41c64160abbbe4a1ca3f8014bf70c74c06961c7f49270ffced31a86b93acefe02e74519f414166e22d75664e886698f0529bb6015bad8bf66294ac926c3377b5fb21b0f0e6d03ba0619b04e9bf855fd9099c3b4d2a7f48cb1b2c9e806f76e61ff2bd7945942327460fa7cfde34008056694b490c0755d6cd3054af7c2121dddc2349af49fd9ec8b5bee9f8bb381a73440d6233deb64ee602b18f5524dda5f77c38223fa6f82e8da4ec8a22f8b8f4bd1710b7f6435bbf0325cab8dca0cea2fcf66a62d403fb4227553ecea9820e9ddc389fe120614c3fa9366116e60a0cf7836e1db817c7a25e55e1cdd97bdd8608a7559fd2a530b0d11efb056e05e6467653d64a6726dfb435d62f1bb61d104884c98db4a9250475a6cc80f75b3319bf8a95abd5556a91c84585d01a486a171f108177123028f338f985929268d6f197fff050723aa0fd808856db444c48587be95c520872c063fde7e85abd8007df054e946ecda37b8cd02efe93a50f79b8cbcfcf57cd458ea1b591119050bbdaeffd482227bfc584bb504b022cf0437f5577767b287eb3dd5e8328b03ed55b04652aea711922abd241e64e449b7d26494231494156795fe175d6c9e8f359b924a0c0741329ceb06201e95ba6ad191df5e947445001894d578fc2ccb30f759a7462084301c9ff9bc101f1fb23ea3e774f50253575ab201af7505f21a5bb49ac524968fca460342080499e68c3b1332fab7b4534415f3f30f0af6a710e859a7e7d7d66294743ff61287b5c025c5884715dd6178f37d344ff0a38c500c56d5f2125fc530f40b653e980136fe4b712c1dcd4309b281f696364225720a163965f4eda7604c64ad14840d592f6940e09c39c6bb4f6268361911ce5c54f62b34299808a4d6adb3d6f35964f006ce64827c6932be23ba3c042c861f506eae0767f3fe4c048ae0b8073ebe6638e0fbcb9f9c5d1ac58496d635e072309536dc53344aa22557f0ab123b2322e6e4f28f32154fc785aa6ae41c2eb8a4318933c32b8d7331985ae79e3132da54564a4ea9b862fb2076eb239b39dd02754aa5fa990112c5288bba109f76682a51f372e8a2d314db9ba7e695c21c5bdb3dbad55ecf507d3bd66d354b5d18376631d82dfadeeda73e047c3337a38b66a3d8154184896f7e273e21bf1b484d2f68f7228138f4ff8bcf67f943830c0bd0e05e4fba6a7e56083ee72be8e5540bb394adaa6ec0f87905c0131ed29e854ba0f268e697b5d6f1245bbcc39731e64f6e95775741097704f238c079ab61d5f7458df11416190a4b9a060ac19f3ee5f99f0c0d0fc28ee2c324009405370892e806196dc204075e50b0de20638d8988604e90247f37960aadda3ec7e08f63579ec0057597961b9c69ac6b553d07f7f43e2195bcff437bc65d6486b401d1d94f28562ff86341da28df1d074aadf9a7d33e42b85d072bffc51d798bce930d43b2b88de6dfdecff564f3c16a66e8e30ca68c3ef569f3b0bd741a200c1368c44300e5e6e1b3e57fb1cd7695c47df49164fcfc02f2e36691c3c535cf01f104c7543f92cc8b2f5c414ab930abd4b34b73ddfe45d565b585bf92df647c3cf1b6e9fd29e812a1bd67f206bca8ac436b98625ccea9c861457c52b90a86d9777151c42aa961d6fb2546ba039f1c2c82928aeac926b4ecad40d4d445980cd38e7baa6cc7168fe0486f55985b016a27a9e4b178d177e7e2011393a69d03e4c3a916ab77c3a83bfadf3503ff63f6381ce97a720e76105ae8181cb185d7d2ded3609bf93f94530d1699bbaa78e6618315714f0fa42b06aa27209818409e3f6e3b9d4e687a98cfe989ef245d84444ed34884937a5ef699480cd59c16e61edf1e34461c66e802aa4f4142564eb91886b91810607f7154c8bbe9e8c7342c76bb7ff98a23e7ecc4539a0818534d67017d727245ec827f3477e091b3292f8a897f64e8fb11c9ef751f71c0a7c081bc81610833f3613c464cabb77cd939b587992c69fdf9e23c33051ffe29ff47a22d02f72572d2c5f4f678f014a28d446b72776aef2d9ddfc2c5baf331f19a12aa0ab9156320f9bb4d4c575b0c5c0092dd4b107239ef1071e69fb171ab2a84d315bcb1203854eec9bd52b854e8e037f6997b46a56b30eed36ee8233f315fa0fdca92961ebc3241a5e1caa3a855c1808fb8bde0cb4ee086dac52f293f0d9cd03d4c927e27b0b1816f80e56a305ad9b6b9e606511762418f60d87750609dc0113f6fae6ab7b4087d0a5a69c16bf0508f3a3dd7e1235c21dfae37f27c76d64b40e70263a4a8f5efadcead89f0fe69f521b5ef077fcc542c65abc8e7c8698a6ae5f32974a24f792eccf126995a71f7a5933e2d4cc39cb24ed8b8da31fb9b288bbff4752fd798377e87a946a357e3be3034195c15a9dcfe77cd66811c65b992577e1de52deb83ed725b9bb65f039ff19d93f83e0a1d0250f5198f3d04821de4f0c7480c7987cfc350723944e582c0cf5313b611878dcc9eb28f9acbff744dea15216e2c906fe2181052351dbf66344b99baae78df33a703e59e02a47d52c85b2c3fd44dce6729c340cf1f1aaea8db29e712f4571beaa4b26f98eae21ff71c4e520d2b1de45440b21134597f0024f0ffbf1da27bcacd43de93436cfcd004ec006e908531200a57ab2d9954fe0edde1fe74fd0268a602a477ec7199e9b439d0f127a7580a527d3bba6c5490c18d9faa80264d5818a56ba67907ef5523da2aae2745e60626e5b9e6b9d9fdd1716f271ea7d469887c8d3978540bde8e39608da3634c6bf569c6d09e4a79afeb0ab92c43ea270b876830ffdf071b0641db96a15ef451fe9a17ed943d348faf85aa63f636cb48cb59d259d55fc1cfe91e6911fe2716d4f9ed86ab3b6aae0e41f199b86b54bcb06345a29e694e03eacc0c53ffeb73dac9f00d0c0f9de2dce199af30e245a6ad37d7eab2a03ede4570050ea5cd5b70a5233eb219d4e00ebba73cf7eb67204d6349bdec2e5d61b97592ae7857db5afab415d873816cc1da612b213dd0c549f3e6e985225ae46b6dd34d6cc6d1b2f6fa74d67f136dba443d4271ed9093288e211f7e3f3fc7562d7840f3a442fa4062c3d155180bf5436467cea7df4dc94a4856892a248274a6e537c431bcb7dbc6d128a771f2e5a7779562373a4e835d75d136091dfa57d284a9a07181945fc647194ac61c048b61c23088e1eb56785b67d4e8df1311c27b28faf57fa453c2fd1d3d87ec80b4655d31f04636e5953d360804ed419c62cf47e5731a7a0bc7e173e39b796cc6313d1c3b42b86bed79085ff49362d7285de328a5b6820c42518e6e54919abf20bd615689fe2f04db4120b1068017b3b4ea378550678291b17478857f3799849fe7782a6cf763f880ecff1e42e9b3d6f316e9863197f3c5a48de24f8666e1f948cd4199a324e61ee7fc87fcb7459cf1d8f5b8708e0b68657f940f77f3171a28a652ef1dd97dbf5b9eab5c429a1de8677155f400a348e7d249f93a69483b96f4aa52e4415a7509ca9c94e907dff94443eb8d57acb4aed02460a9a1df05e8497f2625daf755a30cc46c7365296e3850e1c6ff7d65f9c809bfcaa4071575f63abca57d9d9ef2c0f275f55fcc3bc8930405dfdb6ee064d28678fd694b99fb0b0b721921db988210cf992704b4414b48e77d78d3f6ec42bf7c24b53c6e23944bdc49e53ba0d243643859ac3afa370e9a09449f7a0c91431aaaa66e99e209024b8509a93bbb7314f05674f211890c868fa7972b64c4b898cc90206634a52a47badd3afc81cb4345b4663db19536f43a12c43fe6540b1a457613480017c7715ed3e97093876cf8c29b0b61837f0e756c07d7f07cdc32c1f316fcc022addec54af3f2f7099cbce276fa9a87ce8364ee39cc7666884aea3b8640ad0393c53857f96daa55ae94221368b484c3764101c15e3e7af5b891fcbe8f3db717255b7f414dd9e2cb39b97fe47758b99616af150317d7baa1a7946ad13a13678df017fcde0341e9ee0760b416694a57281c6107550edaf2b91e6050a60f787465db67029e26de00a6274dbb3ebf4c5802c33166ee4d0c4c34aaf64335931effc7e43566e02c8d215397b16337c495f4058f36e5db89ce8de6e6a4fcb3b92562291abd758c419f922b730322ae0569326ad63896bd4454ed1a867ef8f751612404559e1e73e0ef54dbaa82e75d27b77a9f22538125a9e94eae75c2f61760fa3e87c676ffd86263e113025d0ddc06278710369b38138613283d9cb19cf341824925f17a79aec7de6ea06e25d7382d3a939bb8cb2cd683d9b49614f0ead43303a1c9823bc6e7b5595fe208f05ba8075712ec4e6f29f8ccc0f4025765faf3b0b37599632ec3430eaa5ae09103a583850c8976a012cb0bbe58b370bb45c37fedbb50cd938fa46b4b966629abf2f9e5e54ef9947263297d9224f078c2458dc83746232ef830f235b2b5576d148590b02290645aad37d54e12dceeaf3594771824a12fa880a1025075f507c594fdc00b9ad14dab32a7077174b3b75194e968a000a18a44f96ce4b0d449c6a9c3c9e2ddbe983202f1d928336e44a8ead1f09bc6b0d07c5160fa6e20e8ed43d8cba3ed655476240bee96dd8d8cbc6d7efa06281befabea80a04ad10c4c2eca48fd0fae1a21ce27b3adbbeb4ca05ab8a6f4581486e8b8efb1d397f297d3f47d8427dc30faa12de209f2923e5cfe37a79f1b721abd6c3b8f3cf085930bd667c5ba378455b950f83ab7b2bb91ef364bae569457b5b563020124d04a89b6cfe3740097f67b564ba29a86141cf154b0e9c26823e952d7ec8d0c243224817b43e5d0d0a94d5273018321f2c1e59a5e138bd6fcc63204c5945f9f566c89c231f90d3c9b2c07f972cee791ec1ff4b1b44e22c1b71c4198f4d711003603d0792fb4b3350a469723f80a66ce85d504c3f215a8dc7c6a706ea653655643a9ebaa3a695dc53609adde897dc7e875dda8f157ed2f61822227d4ade809d483a70781aa3647d9868fd586269161aff99d87000a55e52b7d5510c3b161e4795fb85894e18510b13da8ef44d8192a40fe88ac6acdc0d71e7ba540e8b620f7657e8d060dd2e9bb5c2881d6bc5bcb9c70543b6d266c65087d05b2acbf28c7a1071f79c2db5dc89059ad9f7f62ee1ea89767afdd2094f781de437ae24c1c8fd87832e6db66ad255422dafb25dc62e445416efee94fe4784179fb4649c9abacc82d106a305d792a69a1c187dfbd142bbe3b231f70ac7383b09f40aed61ced1e137dd5481177d375a74deb95e4dd35a36f89185c81c58986fab8993bd55148d0d4dbf87366cc9b4c6cf7e404ce54c92a35a4623465d16e517ad23f2b5dbe4e4e7f0782f3416c7d3411653574a08889d54eaf54a194783530948c4a42464168bdd28f2eb59135a88a3ffdf82df30eb76816d9419a3867c8a4d81af79ee5e814fe655e7f4769c42f7574e581fa259179bcf7f55cecd7922cc4c4d9e3b97fd8c3eb86e8f596751baba525c70cadf812dbe773acc9dda5214646137dfbdf5535e1fa7070495333b233cbae60a54b90e67c08421bede506fe11cb8769872dca1ac09dbcf83c19d63870b8b406c694bb67a60d3fcfaa2e0f73e79032c81f4ffc664410ee08e251496db7f687934f862816d69a5c3abd3966bf1b08f5e1428a00f32a6a9a8beaa6007c7abc6f3448dec3ce9b364599d288e7ea3205ce06dd06f74515f5b65db617fb1e3cddfef3a902e80aaa63bc9ae2260d607aa62c155f500680f4019548d8c2cdce153a54ef5175fc2d42f98181190fd086cb33847d411fbd0bf4bf6f13d560c679dfda39f4af3caa8029d14c6fe400dd802df8aeefcd333c5368e71f918dfe5703be4fbb857a1ada4b1251de0c16d75eae75fba773c63c914ec0499ca85d89e7b9f938dd64756f7d102ddb468c60e605336f40f28974b6eb5086b0f6e40a4d3ca1951887a8345e66a24422e275b1e50e11bef23e7b7c4d1c49760941a6d62569ca1ea33583a8d67e60efab2f80e5965b542c06c665d7575ed2ed5c22536f2ba06b2e7094d863f022397c7c820ab1643c9ea93a52fd135a12c97ebd6327bd3cb017b1ec225cd3324fc0c1760f88605d52fa21d5caec1fb55ec72b874266bc88b3aceb6b35eb13868ff91bf8dd98374b9acbed1f5bceffdda6b8eef17af87fd6d8d226e5d73dd26798f58d7f5f7b1dc8f7c40729b1a589cde9578d1a43745871227042012e0fc3a62fe043e52488740dd168d9ac1c361538dff58896b2d7cab9968f494fc0631a8c1f4835c24c7f2cb01323152b4713fd03195feb91c847a35189239815335622fb73654c6ac14c4ccc6edd5a2aa89fe9e1c430c4e902fea5e670e62484d34c1383262179004ffc15f6d6c7b37c6aed293d2cd4ef92288d01b85dff4bc6deab44f31741893d062d37033f8fe4bf1a059d91e395549f676e273db7658a82b6df11a855ce43894decd8fe5d9e6abca7fa2b56888e43c21b25c9b1dcaf9f595decc566f56d94a6e5391c1f6168ea3e18a39d7c7c6c0052989b82d8f2c4731dd1278042469a55f84b8dd15fec1dc45cd0dc142c38484a39f452aebcc3df3d6c0b37aa09d02c428c608c9f95a6b8feec9ec33acb76ed71e79ee2152c95f767fd30d5cbae7e1fac072fe81e692a69a91c61bf87678a86b2439d1d59a9feb2a4aea10fa1ed6ae44d31b83261b9cce9d1cbd400fcec4676f5a3f0b0fbc7d5d8e1ac46f9c8078b764f5e27ac2d96731008a122c151863a8f40a7b88a87c3d33afd6c41b8c3f470414d0c83f885fea1766da1c4e552529f59deafa050c4926f1890d8e43b61155bf234e50c3d899fa900545c01220a9a63d1204e769db2c323a4713cc538ce705dd7351443f8a2ed8bb3babcee87971b8428b56e64b44fb43c48e13b4c7f75b4e463b68d1e16f07237c38fe09230778c4f4546582927e596bdc4ffe620cb76aff6fb76d51d26c6275dd2fde5562fe77b0048c453677edce994d2d40c2684d4e5a8abe203f99a102e5c5ea03705faf7538b10712bcbcbc8dcb1294d3b67ee64a8646212b84b72bd31b6f684fdef0137ddeb7e95a1bc34235c67ec40f8555f896f95aec8677e2e4606843f95431d1d13e4aa2cd7193cdf0285dcf0674346cff85897bef7555bda0247c8eac1d0a612983d729d4d472290d85f65d686e0b172e15a44941881a796868d6daf226ad242c3aa7407219a820ced28675019c2cb9af0445066d71416be924f51bbae6d70ee28090e0547ee242cecaa7ce3eff93097d920320d79cfa2f973042a24014564a66a28602d1ff4c0057d8492ff7c9480e192663d1863d199c72476274104ce6afccc5b11c49010fbccb7ccf49e9cadb308d073cdc1460f54903d62a0f7b42aedd9ec22d2921e461ebb8526d2c6a37fafdbfbaadb453fc98ba48950813beb9d6e71b99d0e23af1be7956ae9071daa2a7d2826f2b58285c30ed6ed1c02a57799a787fcbaeb1d87c066ad3f07f2bbd18ef29280aacea3a79375b383c7a16a227aaa51ddc9729a909b9b29de87b39ed805d4bd423c2f56aa2f35e738bcc6e2c189a48afd8281dfb7f3c0ddc2992746da196fe109c9cbef8231908ed936fe3f9a125727aa8a595937886ef1b3b7be967b80a845d78bcf55401c323213d1a07d7564df871304185ad3aab76582d27d3958685533cb25cb99ea5c39042928454d3ab4beb18a87c39c3bf3629d4c2ff0f36765332535aeee8c85f2d72f2e8e2475d5b20ecbc8ede5f79c4e99c4501ab622cae65aa0227d15941a302aa9c8e02cd923ddffc1a3ad131dbd3d38bb13e79d10d68cd17d2b445c50407d54a3575b6a76603935775aa00078f8e6d84071ad41494c01faf06e4537ad6a13ab67d6342520ef345e363c4decb6e7c9c8d54fac0b0cc04417e5ab325f81d72195bc42d59dedc4bf10196b9401c264873ed673f346c2494f8123e7c3917888447460b3d6ebb763624553d332abe685c91150ccde9ff6e944a8039470b0644ea8dfbb906e518e13132f6e25a3aaa2d7e5f99202fd4116976930c00ac99071645d4271f9cec502ce21bc962965bc883762af386fc74c0914bfc486a5050e0ebaef44300d4bda248eeef3d84ebd653c8c04ffbfc38922dab0bb12cd5f5f477652592da5bf449c7d53919c579ad7a1f6d5578a6e5407a0227b6b68650ac311d4db672d53a386f425f4e9ba945f4df829ed3972a83aa4162be171ed7c8ddaeee96d72406a7653ef981e59329712e65a1dbeed7580ca930261e917d222ea25aa2983863b3153df6ccbf81ff97413a4ecb56e37c36b1f297063606e474d8ffd00e44f9a8f49f38b4f1f58979563137f5d69c2ca093eb0b3c386478699be827065c107522081bdf1628eeb168bfc3b1e868753a387c328509cd5daa23513ba3088eed6c5afbdf7d49974792296605ca9cf5d81b83988681a042803e34b59f67892866b31bb67177b47f4461616ebe54669322037ca4e5fb5065d9140cec9d6866fb2020c3504b3ddb3c4838519a04db04010a7fadb10fb105e44d31dd0c7c4bf1d97c56c6405a12b6ed9defd196412a363945b3231fefb35098f55f427a84ee8a4a29c4878a2265013b08da7767b4affc272cb5d53acd94b73bf9f71a3e04b3fa5b45053ce10dca7d2ac95bacfc1f28bac6c90cabc09c4a3929a02cd5e6324566adfeb7c243be43d2730cb5ac0980aca0bb063b2e9ecd55dba2ece2aeb3766b7f9f96ac297c6e763df976c360ccb941479adb029ed0be85c9fa1451200ff426be7ced91b42ae9f9e1432c674a948d485f24effe439a3750b4d7b8326b987cb1e87e7eac0616338e61463bf9deea1d2044572df6b328844c7e27883df56fc2e1f51cc7d28d7b71afa204bde9f3fac9c6f8106af3246866169af722ac65fa6a61d264b9892a29a5843b1de317e301d605a9bd22c08c7a5762a843ee477ef541ce420466043f9c279f8118f9b20962b3b65b6e22f6456df587a9c5a815859f02a38b75ed69d6e3f384e3f9c884f572e45950aea3394225cdbfd52d52add0c43c9d690da9782ea722740002b401f480794b9df7c71643e709cadf0ba75cd3217e4def6a0c9bd164058aec64144c241bb8d60e3c4106d90a99db1e1ab0a5599f062478cc4adaf681cc3c2aa3d5de7fc8988de43852612e167b53f2f96e771be885ccadfe85b3c889ce2fdf9154f4732a78e81e6fe1417da78c5926e8bc24f7cdfc5a861ff04ca67718d138c00eb87d702f3f8426f2fc40473486f51f3bd42959d90d8801858dd21d52ad87fb49d4df55d84885888cc6c2d2d42857a236e9e4c203b1f08ac27df40b07c2264756ae3ea43e964d1bc0259275224af90a41d2320899dfecfd2344f3f7b24871d9a921ebf4e15d1b7ae5cea63a023a6586e0ed75c3946414c86ec63900e2d0c7053d64a6177c859204dfcb648f0691f9eb97c304e98d913a0e6fea0ee5e309c0c3c5d1da4d920c06b50b97662c67bffe2965d90ce9cecd953fd7893deaac50749e9a660422b0947296663f55065a513363302aaafecc7e544d270a08ac3951dc88a1b457b651a9eb25ddaa69eef179fa8640ecb92f618d24e1ce5d973f2e4d5a9f1bf90a08068674fe2797f03cc30feb803dcc21e52bb7f2ab9b8e8dde5df273da9d1ea0a0a71933f4d1494e15165be565f229b1b10e32868620c350b2dc8552f238276ddc24cfe64fc155dc96ca42abcbbee8b5576cccbd30f955044aea14f05f451841d5c2d90659a48136d991a36a246a58eeef4a042d7a3222876262d2f2a5e9631fd982b55d01d2f3c4264015c9714911b3e37cb1541200451197d42d1a5d4dbfc649c4e49f80645332ec66b2a9ab73ae49c570104d60bacbb7e08fa4650702c0e1014fe106371351e65c6baf651eb6f0acc8249dcdfa7d36e2191c0ecf42a52d770269a4b7d2a50a775298f7c239791016ebaaa3b17eef557de5dd76b6124193e8c26fbd3196479bbab20da0177297e8f1ea849c0d01fcef40ef44f0f02421a1ad5c45f74103cd9e892191b92bcc9a04b4dcf239140481494a5f985bf20f3e8c26e09fbdeb4fe87acc3ba205da97783eed85e11dc20b27d80eb126eabc024666dd8771bae60c6ae05ecb18ead475ee1c31722ee11f8aee1b6a6bc8e4e24e7e31efd7cdfe6f5ec5a1a4284f6bad47a7d38c8b641640d75f66bb6d72240baa06eba6618c7647393529eb055fb010b90ac1cc971fcd27419cb7369c702bc65be5267607caa6ce64e5adbb1006830165ed96eca123401d05757766d59f6e21efc67f7f0c399455a4559c98a8d70f457ed13717e816c53c5c8b2557a310a63e21ca5ed442b9f2ac44017c7c6ca4c60c4eba5f8d02b3df6052bf16ca325ba1a9bcf0e697491adcd2e83c7d5d0669d36bd829bcd877ce43fdf08775eb411924e34c1d6881904d058b9a579b96a6ae9c313257c42b4950cfa53e617855252be4ea5e20c7bcb144999692e3632848baf90cfbc94a85d6ff543ecc6eb45fdab8b6562c780dfeb54a2d46ef220fccdc97b0ffef5e84fc29da6c80757f6bcecbde91c28edc5de8dd5f6f5eefb0d2d1847815930442a69d3eb6fb348824fb7c543007b32dcb21d9df82e570491ce32b168cb697cb230174d9638bb79f2fb5d61a5f45c5f776cf1bde9f6fca11068825b70860e5e6003c744d373b6a388a6d75a5c92c4a55c09789bb78828965a5d5c3fe893e4959af156f473fe04a44baa0bfe0be6dcf4965cb4a564c2b62a932629b3f4bcf00ab7d6df2ffb091515c496801e5478114cb570d3a284ff28d8e20f3df0c6aa4dc113e2eae7671d166595b660c7279c9142ab576c35d45efc32820329eae9be2564b05f57af95d8c7a2f768455ceb9f0347db3c2c2d2b54adaebd9222c7d2756026887d79cb22eb257069282e44c22bdcaa865c2f1cf65c42ce59821ce491bfd7acb776ab0a715821b35113223689daa23e828244a27002e7bde45f89c5dd29f37cfb435a0b9bf7a0fa14ae51c0709fa760bec019c8ec576fd25bf5d30f27e00efb7c592c72de9ad5eb55d5c80bc1ffa1eb13988b8d6d923e8ed84de7577dc78f5b56ad0022670405311cf4f2189923fb7ff726d7f7d13de86350420d1395a3acbb91bdeca13f469bb46854c3075adaa30fefcbc440ea013a1ab934513a36cf12cc9ab72b29eb0a237b8f97c9f8e5dbeb9eb13d2c7a5263e396711e2090c983b6991bc229312d1a966629765f35dd325301642a74dba45043f06a2a5f5f03fcc35c55efae893a0bc1f78c46df32c3de580765770dd9cfe83dfb2b14ed90e57d392befba712aefeb5aa2802293c179c2f8493ad80c1585a08a51461405865f25f08323ba86cc13d76e118c0ae9b7e82d34b1dd26f243ff29dacd10ccdf206179f4e43c07ad140acf845f1b8179c5bbaea9bcd6f734d8857000e4eb4e075d8f21161081bc98f093e829abcb95a53b158f06f680b2b43e5800c55f13497b4772a28b021e4fa394765e659f3fef9dc92c02a33d621051c89cdc810005d203782f45e30cbf5790a4428fe4016d315d4627c52aa658cefa9ebbb5ecc841c4018655ee171ba933318e467e23b5680b31995dd9a2b35a895b3edf4804a62ca5ea571712030341233ee544431b3af601efb9db8c1c971dcb322e828197abe3089258cb557eee12e234ffa7599e6d76b7d69aa03eec072fce7ae26b66b5caecac526b4451c806972d0ea536c5ae8897630cee0d0f5b8a7837cafb21e7c2d40df1de05322824d0fd4ce3a6b2237dacbd447e3abb80663ae1aac71c94b7a2a76919fd949c082c20e62760c97581df91f9677c3c0840031ab023ff671e4e9b07b625afcdab631be41a43ebe4bb632fa6954b23a23f585b6cb3e1eb00d8771a2f05e1d8fd7db084fefd3748a2a7551e696357e4382fa2c6a65c02c00556ae0fa9fe30e411990ad97bcc0a812338c7b460390248517c3e6e4eb46a17a524c6c6d13ea164471305bb94a6a3607817f73c5f44599c6817bb75a55465fdb27bf9d2bb3473470f396084366e3503fed903789c832319e025accbd3aa996295c422a5cd624b79cef24b6a5fa743b9b08dea36311e091edd5c665c4f2579800b520ed24ed18e2aeb22b2157b0a27f61c10e6e5cc977ed52709e4e0bd949c4ca3e56e0440104986b3ffcb7960cc73d8f5fd1b9e87370e731437108ab63ae5d34f35b863d713f8499a8263824f47769639e128d03d9076e7d5e0ef8ba9abf663e69b4a686e0a8dc9831956cf458652536e92d1b9d7d18b404574808262517b5fe79c9a71fd0034d452c2c3dfddbe07bc84a9c5ddbd4b64ec2a8f4eb65572d4eab726822437252eae41f7b0f25ca70c6045b2020d008cc79a8289e3173aeae00ddf89a862be90f247c874c12527b962dc0b39228b804017894fd0cf75472ed2bcbceb796060df58c16fc5446e6e5571890dd3ec0f7936b5166435895c33cfff447a29f6090e8efff8ad9a656443e5b89e526bb54c5e046f4c9d4962605f5c743bd1ae825067b8070dbbe021284aa4092d16a80043aa73eaad5cb4530104390680996b0fb078712e60be93e42070c5138668d83d6ab189c040bcc5796e4e6704a0b5e67d83338244f2ccce2f5af254e7787197f2ddaf558a5a826cd280fadf61f1a81cab32f9019d3b0aecf3c93c562c8b94caa58a2934dae9ba14c5cc50e5ddc4c8e5110970fa6ddbd8311b1bb39807362f27ddf9ad8e1a7127e785d7a2ede72471a57c67090f49b5580bc3260b640cd534f83141dd3b84c9517283355d72dba85d482e66ca6fe404d68f0f40b192b6e2199f94d0f327580669243067845d5274e925c25ab4bb9bfe8e57a21ebd81d76ceb58e57d5bd2963a6b488b9d39a79d794e09f98c4a562ae4ca6e5c69cf38cf307045f756a67c968f1f34cb02e79c552f6f057922359f3f272936b8bf6cb2ff2a0d3f7c07e9b9365598b6a822d66105c59a79b622651df11141e561f4863a2c206a6f248a606bf3a2220f392cb71627a724af1290a532ff9a5c3e67b985620034adb2bb409db18def6fbda1f048ffac163c0e43626b64eb6a57d47f8d2e186549f952bfb6a82e82d77cd7a3f627ef51b9ee208705e0347e82fda92ed2d66b000722d68d0e8628614c6bfbed5638f981c2bdac32efae02a211dc265bb2010fee5c82b7e06476e59e350f6180552d997ac857bd43d051a352e56ab1d2cedd2a7021985770f1d8470b099c4cc571b090320b928a1d58dbae2bad14b7912a0993cccdc8ccd3cb5d05e178568b92273a2974d5003d20dd9c4094963881e36cb53692fdda9fc407e8fd2719adae44b8c984063b61787021984f11210f45415fab7791570af4555a80aaca6190e8fe28a2393d72cb90d54fa8cc60bc0b1fd334e8665b6a0fd2912eef2664459618fbc68b6a49fd543b9a699129388fb855e03b9290f8685bc71d9bb379c4e701492ccfb7a904cdeba2f7883e902bfbe3092b0f5ff1824084910a9cf31bd0384d0d42e7113baa30b5de916a30fc7c9aa68a9aee30a78201c3b9cf6ed99522c6b770ee0427b4bc659e358ad90b68e0f17d4366430bdfb757fcf367f340af7993f9a8f229fe4819bb6b5a1448cc5e9470eb482ed8ed51b1978a926ea7d5e8a5abda585592372bedc1ddb6170e1b2fb4722989291692ab1fe8873e7659decf5e31616bbebd9c445481a2df95cbe6f50ec72e2816799000b2db41fdf13dcaaf259bcd4872dd2e6a8074b317858dcbec0f9d361175bbc12666910f7c229546b785ff5944a7832d5e9e956a4bfece83e508d70a9f4198e4b9557523465c5fccc3966f7e119765b164e3bbf149a8c35aa1679b67d7e86faeee2d85764302da0bedf6883196a98dac075ee4703c4a4d33a1be6333e4529f757c31f7eb5de55155cfb82477e98e7434d18c18c96b6e432ba823ab42b3547a5d2709a7c2ffad4eb4bec2753ad3517c936ed0d3accfec8867f112f792b96d1e90d91c5a0c59c14cdc282fab77580e940c3c761535d8c0e476f9ca87d8e5ba51f1899a9dae2a7510547d4d9d5ca24c93b2c09fdf7851c6ee223f409089765fec820141cedc8ba120e4fd215048863ba5e37e61e1212900ea6f3eea422f2f6259c7a5780c9d425d55ecfdcd6f465f5719324b3102754470031f85cee17c67d76e962017a176323e8940d5a76c01b5b57be055be1ea7ebc9faf77b98b0d49d3390101bf0ef1e1b1a522172802a0eac305adf3370e98c120ed5d2bbba9a3cb7e12846430aa840e3c234c0cb478ce867d96e01ff43340b3ca3f531054e563b9a1aa005b59ada8d657cd3f6f4f86ba536b6626de9739a2e1133dc0506e019381735e9af24ac99f6e9e9ea62121851bbf1aba4b84e3286b2f63835a1c2c2bb2a64c8aef1af2fbb0969ec4fc1c51e5be6e6486b98135070cc75ec6da8d34080cf4bfb1d81b117748c7a839a9b26976a3d21e1ed115576ab711f7731904ca076b2032efb1910f7a6d62528f91f0c21165f29007bb3255ca9a4bb78e0417bc77d4a5bfea531166bb59c5cc0f7e53d4e71e731e756cad42857fe84a99fb878282ab85f606aa75e2bbde56d4ee43d3463af3d885e5d06d4c68b04131c5475ce4723ee32c434d62039f2870c0ee67f98bea718b9a74f2ae27dcb956daa6176d5e3a10b781cf3da2fc30a236e8355884b440a18f0b883d3989db49f0a74879539815d7f8ccf60ff4fed85125fe8cc9fa5fb158fbf0811cdc3104615be32d951a739c7ca724332aa53cf2b7043691febc79bd5b31e0b7f770c406eadbdbfdccd274fc89b136765b71c91357b2d10e06ebd689144635d00b30013ff586fe5afb469696cb7496bf4efec409c6e55738558d7949bcd1de57eb8da4e422e3d6199a6c147a590f48564ce69e8cd7a1b216577a80af0f10a18f3e1cfaf1a927dc5727b5d76d81b91d78628926f3603b4c06fcf21ef8e9a53b0360912f9d9717fe9336a99528e7e1a0caf63964b772ed6c539bd7495ef457c343c59c57338626ee11dab185aef2ae9920955233da7189c6e49c80626a313906d2508790a22d69ac0a7c7656782abec005113b0f39a741e14ee0c0efbe347504af3304f7bc2a25458fe6807f886247c56ab9d5ddca0254a520d199083c24770fecb304b22293f188619adabe23db0f6684b96937b375ae27f8c93e9dc736e63f820585b3edd3d60a31517c02cc788c67cb07ffd9649c92ac9dc852ba3e335b7fc34ac0fd673018142617feec442191a92fb22e692f00863503d0987784327f42f7c50dea165dd8dc89d1b69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
