<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5928f86b2ce34d061314be06a31cddd54ef3ae6e3fe70772c634e9a12463c7bb18ed7e120de621388b3ea229c2da9b947f455963dc46934ce8249e4a70c53accef0bbee69f97a3df783a774002501da0020b5a8fb42f887e313fef496ea235acad3f11a6b6cc72cc3ae7153655e5448459428c8c52b8ab0ece56714061f7b9552a5c964be9f69ba0cda95e90fa604750fffb64ccdb766fe593bd97bea8e505766f4b88fec8fcb52e79d7863907534b27ebbf5116d038239314820669ef59c1f688d47806e57202cea97f86f9b830d5925d4e01c4726bc3dd05b3e6baddc96676531492f10f29da6325533c4e1c1734bdd1411f7b81ab28de7f724258aff76a442461d43bcdd44f1255a34ed1a420249213a7198db820e30d13aacac429c48504f08d9d1f0c4c1e075a1c62eb3ecc97fb0167df3963338fdb2134e4274d80019e190379be4ead84a3a41dc48dd03d341205ca97fa902db9f8f177aa9715ba6c97bfcf1e247990ad1bd5db46969c9ee0fa41320a5308c66920973b6d1f6cba8d9b913c0f55184a6f1369e957c8ec5e761bf16852a78d65705e5bf6477d9f828d13663bdebdaa46ca623c6afc4f7441e1ef88a14466fe6b29b9a5f376ad72af4420fb83eaa9759528912918b62a8621b6d091a08132c9327f0c3c74085870aebbb0a19e6ce60d790538103e29f5a0a88a52ba9e45b154f18ea8c8b85fd860869178f0cdfdfcd63366c520cb7679726bd81e6aec8b04a5bc3f3ea94625ce8919e89899492ce13b6cef0e89e4a2a844b0d3234b0f7c713f6c06df8da935cd39dcb3d87bd5d2eca2d5f095d0e3c23315e17ed9de1f1bc2581f0d768b5588a2e712c2c6674639f91510a723d67e976494e0860de9b82c766407562a688e95151aa537fe49922a27599464e1de51afa3e5ab39937eb156acc3796a84d5697e433826c7d837c9488f7f340308db713a8090528a2454d5f32dbbefc821dbdbecebeb02c687896eecb62c66ee3c58db6bdbc5851db1a29a9775ae22101a41fe28e35f71d65e4453546a8400774e5888885a3a24f7b2bb8ee7b82f80c2d889600b8924cc98fc730103a6e33c13128942cf681f54a4cbbcb2fcf238047491577df7babe991f5091fe7852d169862c6a89ee7278b465a766c424b5c11d8e2f24cd7e7ea41296406078754983c0980269ba732c03717818a89bac06e57f1854f74da6067d4e34df97a5cac1ad24f2a1851156c5596180787135845275ccd1cc4a5e9c20126f1f687b1edfb8e7247dc1585c566ce23ef660c7bcd7b6a6685c7d1ba56e5312ef1daa1ca25830d8069fe9749ca52265a7ebb8f7b8850d78bfa25415fc887684053edef71c0ace245f22eba6ec0b51071442fd9fc722f6ace0807dc7f46bf766ac64f6aef477ff4b9640b8ab37d07847c216ca4315663352044c5d1f20589fc955ad0a4bb31d58393d5b887b55ab98739d5259986e0fb860185ae5e3bfeecc1d0606b631a105caf749e047235199080df02f50ad90d173e0fd4846ce190c971d0407aa5ca8b02a9621e8a31a765e1576c5735564d5952e65986d1771dab02a9f789e7fc96cbaacd124ab4003f422d03eedfd85848a171b19bbe1327f01fd19f5a58fafb30fb16d894a0a37d485906fd4de8c7369366f18becc3a17adf26d1d98e0f0a9d12d52ab650e0cbdba58717882194b9c24712032c377e4358e98fd7b7cc3d8309f295995b05c87b6c0e443eda595fd859d0f3aa86bca9b71cdc8e42e761342b920627ef0ff3377c6004ae264def7c5dbeca5ef243366d342b6d68a8954f97c2e55f30495b63071e03f8b08d3f612bfa39fe8f80ddf7a74e617164987d5d1cbd2f77a3483f8f1dd0fa4fa8ac1c5452bb0651dbeba10150ca31ce3ae5264eb88227a913d1ccf69860365ccf7154c094c1a0565c7e2dfe75fd25f95cfec96b8bcb17b1f5e2a8ea2df852b938d38ce2e4122859918ce9b914effd37c1180db3988e68466c16ac61657003b98c8c00067432b74c96791182b6a8f280c9919f8b1e35dd509463f7031f19a37f21f46948c5e4d2604560946fe4f8d45da858225a201f8f62cd3fee9e712fec904f6855cbf603dd74a47ac3882a15264f9d76c29d6e38665aeeb5a5242ec8557ecb465823abdabcb2af5f878f11bbda6dc6e88435fa4b66e9204cd036d7d3e086708124790b2b253cf7866f315b90847c88951801ef7d1ce9c70f0b932d25196197b048d90182f933199eed219adee2a2be70e670772ecfa31f6c831fed90db4e22c61f074455d8a25bcba0b6eb4adbf3cfb4fbd51902185186fef19015710fa63c32e50e005349d2aeaf452fac790b4a0ecacd91a096d5421b128b87542d4b6cd46ca3cb8b432e6f6f1063d241e2ff740f3f14ab178a361d32d595f2f473faa120f49b8acd14277318872d90abd5ea69ef5ecde67b37068d0a6745e86c0d61da23cee670bce27e0497184435a1cc231391eb8391a53bf90714438deafc86d8b937cf677bcc455c991774d3509b37bbf484adb1fe9332c8865c2adcba3e1b03049de62f364fe2dde875bd7477cef7a50ffb8fff116c6c7a94e5edb9037f7f86be8e54bb230ba995cac23f7fa9ad7587db4bdce6cde7918b4abaafa883998c62aa4517220e40e2ee73ff0fd00999c990d53abda5a8e47f1e3315f49bd4a83fdd5d051e3409a6b2478857b85eb852e82b4d4d481b8fa3be0a9c9f1cb9fdf58530ea35062a76cc3a43c90022ad04d20fd4174ec9240285c7bf054f4455f66f5f7e150680304f80570311dd838aabe241b57fc3c9c8b98cada3af217bf508ab9bae7d82b44000c7dadf1ed0b266a54e1ec68413edfaae5622903dac2c8bceb862955524a31d610180eff7ccb64b159e3ad08fce99529ec1d34cc6747287cd497f7e63bef59d2dd624c709e957d9923ac0cbb9dc07219fce4c5543503a2e5a4348e5f8894156bf24d02fadfd8c854d638f28891748db384ab78d863f5fdb3b090a603605ad9a501d8e53f221ac38342784322b9edc8cabba47bc9cb9269f7072373569e656e78331b957b1875b384f5502573819c4f15dc824872a2e5a1ada834babd99fce4359bcdf775e7f17429a31c757ee76285794b7fc997629e0726a2ef028dc1378475c385a69a396e140ce7fec0a9cc5bc87ed5292ee8555f5abf6072147ed6b9f229bd0b03e914fcfc43ad31339b46709be9cc771ea111ec87c4e21655c875238a47876e1ee1be3fece8a10ab6655ddba375988f8ed5765afd85261101970abf4f54e3ccc1ff1b5ad23544d90bfee00e419dc9bfdfb26cfd0d99f0917aed405a45f254e8fb26b912c86caa5ba798928e6b0c7f4e91e43a3d88467e06f1f941aa497db5334310aff2e09bf1f333ae7cdde4e86e8ca4fff154c5fd83bebfbdcfc76904f2420f48c4209a2448cce561090e2c9d18ed39d03dbbcd7969ad9d92bdc8f256fe57c1a280e8068f90a5d3d6fe691954aaad8644f6ba02b8768b3482f7ca469c6b506f25a7b43db3b033edb98ff5b128c76ca1617996fb4f255bf706a10c01557fbd818868fc40d2d06e3e429a1d03b673dd5f408445ca4f80eb2b85cb4e75193df366e4cee0b52877df21390853a878277a2fe054a70500feedab8a7a627fd42d391bc9d9b08fa44c8939fbc0f96299b978eb4df5a3c2aceec42b17a0ac76272eea84e065ae693e3700cdf56c37863b9d2554dc16fe966e53ff0bdf78d64c914dd9d84f80130576b7f53412b18fa958b0404aab0a93b4ff3d63156ff18075e38cf51104860b20ca5292bfe57aecbcf3c0e6b6e76fb944cb68691748df2b993614e2912a127f7a1f590067aebc883968d7d2404081cd85e48cf1102dc75fb2d00d3e8af089b50442b52634b4f850de3bc6f1dfbc2b0cfa9912da482e41dac38b6c827d2c8377a194671c2743af1bdd230dfaa2f5593f1605d787b2dd366b832af3d43224253387bd381c6383aa8c0271b47e25bc3ba5509e91f4c7feadaf479e2ad46f443c72ca6e312d6b53d4bc7a699eaeff8439045d3bfdd08a0e8888586a48913f6d6537205d7fa2bd7d706c16b5b2afdf2f17bd90304144662e6da528b3be45cbad990f122a0b9f215ce260ac5ecbda21735713d81b5d67ee5c252404737ac18e48144d1d48837131447419cceda00beb4edb552ff88536702d20e17ee29ef919a722d2c132242b3f3591ccc8f1cd0b887f79ed1164c641409ca31d070441a9fc02afa8522db90480c4e8845958217e7cce0c5ce1bf1d8f71b43f4f86491a40c3ba047824c7c4bb39f026b77fe69e22910523c3bbed55d12c13d13c30714cc21a60a6b9a2876b517e7b3da2719806a42675a5c91f0caeede46b7b5f3915f6b2e2a2c50600c63f05ba4222e3247f3eb3deb338767a3ea9f9ab39911c400b0980fb3d79e2c5597732b53d1fdee8ff5ccd024168399f980823ba844ae6d18b329dd963202de2e0974d8cf7ca8873dc885c5e1dee8168134f9bb0ddc9361b2be4845df8273b3d5c3e1ea3925d7b6f369bd7599018c1ecc41a2251afa961a1862b0b63d4851c955fcdaf76fba3cba830d9a73198874277121a13a8f142c3dea648ef56e107aef1b487e3661e069a03716519904f3792b91c43c3bdd5eb0c377350068b48fe7dace0cdfce2fde703094017cc1cb0cf8c31da243211352174466c730f96c6573a75e983b01b429909b37f16ba585816f377a5c2d01c92f74c5746a483e87765b73dce9297f38f4ce4fc30b80f6f787dd2630fd64fa841bb57f809a1b53414da94786e311a881836aca311fc8e83af358c3e8af6480013ac64f141dfd09acf01d049412bcacf0a0588f9b558e04f13d855efe67da6db654f58f23a28ed15d94296ec85f41d3952151501e1c21a2d4ab5ed15156cf4fe24b01f0e563f3b722fb0ccf99d991d59e9d338d7f1e070f9c4ea1a28546c6dddf588ad8841f06134cd209d65839a5ced5984a1c0caef27cd1417122c9d46697589cfec0f4b6bea56060885a28367dbbc278affcdf32792a478d1eaa2205ba4d50731d1d9f0d38cd541da4c75dd9c24adf10a70da6f73ecb1f81b45c2dcead375a80cd059a64531e727dbeaf3596a1a3fe48cd6d7918c77bf707440dbc2fda58470880919caa315d6cc35dbcdc327fe04770a6eff57f43de95ea480d9f2029f8867a125d6d1395e7e33dc71c728c3ed8f7c78a03a504c300b5ff693d231c82d34e04541e5cd322afefdf45445fa0c85f5b67325cf483c1fa4354c6d9595abf724410d1c48a73646660e5f780f114d10d65b6c479b9938d4bb631ec3065bafa556b8d6f375add3a9c4dbb632db311109412f1d6239a456f5c10cce7f23aada13819476db1dc9de62c147752aac9874fa88c381e7ad91cbac2fcad45a911efe6d31d9f0e0741cf5f8aa0ae0570fc1edc0ad4143af7bea15fc879c3d1f66e3bb52e2617f17e49f5000d74b719d27f4a6871a5b506f52ce451a0eb53391fb9ce30c8dd019c7a7e3401481bb632af7891e833d460d4fc0371e1e9385660b6f3b7ec30dbf0cd53d2c5824e01efb6ed54b7c3fef0fa529958de6d41558c9d36530104374033933cb56a83dd21e1d641ab59dd7b5895ffe18c7e5ee8406a130841d2493d0786775b1361d012894627fc3abc307952db4ecccc86b59bf750feb38517fbfce593fe5a353afba0ba35c8f6e65858e65200eeb5d4f4995e045d951971b7c676fc5d091cc1ff54fbc830009411b1e3d899a63d3e7500a448f7feec45b2fc4efeb7354aa80f17962e3a92030ad11e4f06a6166947b57f5d32f82896a16a3392775ba0ac33ed54952f05ac0d2a64a69e3d5cec3673385edc1ee0afcfb4d3d7b35ea4d98f27e81927e271bf4b04fb9526eec1056ee99cc808b51896cb0cc636b0c15387fa0debdae00771440c49b960d8ca9c84c044181cb2828f066c3ccf32bc7806cff578bd2203f139c934e56159f454fcf699e5036551936e76275574ac24418b31c355925ce763318a47f997e63b206b09a830c11e14486d5e9db4bb6a8a5d54a1077708346059635636e20810acda33b8050ad339b5790844d93bf5afeafdc4a5ed639cb213ba769085d6306f47bacb7f418f4aa63bcf0389ea11ed00431e44c6ab59a5b350930a47ac37801fcb0ba068097a89a00b2bb26f62312fc428e72a8233472c35845fdb5436943ffc13326c215a9b9b5b9ec08e01c2b3ca63e796dc7eb2aed043ecda48d2d1c0d5b2c1b6e760e9858c048d9803468b0142ac0b6ab8d717a44b4562cd94ecfe9f6dfc9a214d4c0f897c01df629d130ab05723e33228d0b7a16741a802bf07be232f4816f8d68ea2ee493b65509bb3712d1a4769187542e08434306664ba4d332ac0682014abf0e2708ec83f2bb7bda40f12dd7bfc4ffd610c0c26bef9c6aff3799f80260504fc3b26f6cc0fb7ddffe4c9969ea295195b94138fd8d43686a538a71968f46298e9331fb3bfd72640ac940c12786bbd31dadd0cc7472f53c5e2668cc053d66b288061ac7583d490456cfbdf5205b5f11a79014cc9a7665175556f7d755ed54be30bac0dc8f92310c1aead603dbcf1750b6ff683a8e6df0832cdc39e82688baec65fe7ddcbd12ef3e6c9d1b35800a43e5c595383390455aa3c0f9a3a8c141ae424368d7970e26037ffde1d88b1b4dc2e336890547d7f835ae91172d89f21bd16f5cef981fbb3cad4b8a899e5ec751581001f6d4cf74b702ace64fb1d9c7fed3ef41b4c5d0cd27b431498bef5c3d7c4d8c9c7fba18fa1f5ee344552d4c5fdcb7ba2ec5fe273e0973a4ad1c74da2a8e0aa81a2c298c1e3879653cf47026837f43e6d5dc1f2f2909aaac38f97840a7e0d3cb9e6de0f0d2ed347374445a807b42cf93b68748b97b19ea4b11dae49560a0d3df1bde3d110d07f23c68ad36a9f5dc9f0fe4275b154a504d85ae59bf17a260847d9b2521d92fe00861e0bc5f9ae2f87ab541d24013e79e775b13975d744d4374043ceabb91b30aa2bc5f9bbf36224eb98dcec568100684b010c375295c8d53ecaeb42493f434b2997b25cd8d749530aadecff03b72a1c0224801f27a22ebce72a95a25c80ef4ebbd42df76fe7887ff43c81bc211ad77893d34f5bb6f0cadbdd05a077392a117aed0712b2b7a81c36655cc9968043938646e52645ca88c2053df0ee371b535715acff2257b27d0b4cdb120acda4a5c94a7ad351bc8c2ea05c95bbf881e4853e194b9ef65144152ba82560a548fefda9567fa6baa8d996353ba8c35adf86c5bb8bd72cca559112fa20b73f26ecc2b2199c545046d2b4d50d918aa2af9ccb53bf181f8ee551b2a425dfe0f38c764a2d1b4332dd52b8cf5b8059ef3e0f114702448952a6c37d859aa6034dfda401c00b11d7f63e747dddd6b6ffd15a179e62eae8529e5548351a77fa27f20121583572ded9a781a2d9a898a8f12610d4b5facc65de861c0a079512a4aac44d7afc1335bbd4f9c73bdf80a91580422e9da89c9774fd2c49eb1af52a7aa56e863011c3678fe8c094596f37e6270c851037bf2c7120581b3fbeab4dccfd0450dad1f6ec2e7b8d6b7430a2423b5887738bd9297e5935df55a0eabe3d329cd03864834dd26ecf1a92f62f296e7272c82859fa16197ef2abbd4c29bee4c18701af6077b50098cdf516ceaedfc41b606ea9810450c40940e9a27de48cec65284433db6d2f0820eadf88e1ce734056d1419f586b27d2510ba7546796896b0ed2514ae7665a1382e2e4fe7f5626437b0d614411615f3ff252ef0ca012db80ae12a7f991726c58362a3686197f80cd2b0d3af6389ed4938149354eeff7958bd459748970f5ae3a16e5461709bb1b797bf8a79d85cb1bf93f65a1b45d39e9ced79288dbf6ba035dd9415d46407f5c57102747ba557532a19b4c3b3e8ccc4ac4d91fc9715b26d14db762daea574367546edf77583b2980715669c9c38051a38abb863b37894441b89f37507ce650bac6aba15c9eb95117d3ec9c3300e7ae8bb2294b0f5ca55b0bff7f16a95db2532607a7b3abe091cfe2e1f5f24d24a1aa51616f681a30f7c4273b953e9ed234c24d06f3c752f02368c2415ae02655db3e3e145ca10eb67b0663adc231a78f620c04473cd930eb4bc5fd90bbda8e807eb28a38369bb1f4e4ee8a0f7285c0fb21cbb982923df502c9dacf29140f79c172b6739a80f05ac324e78dacb1b683b564b754adc1a6e45fb6e9f0170cfac0c5e671583af586bb6a8b4b433de0c15abc2c532505dcb09b501858689fd403995eb5c080c1862907ff7f6954d96783f05c889b2380d06afba3dda5ed27f1528e675d1792cd9d18671d3c7a5c6b1c8279b21c4f6e5195d9c6eb7a2637b7edc6865fb27c3cfde37892ff1d6d91f8fcb2c5a8e716e830c624923d97c60596b0c48224307d926ceeb43c9fc41e2972433b571f1c69d3bd4baa3042195ac5f2b6a9c3cfd63f69152ad9921586d98a97f13e5a4d806a425bbccb71e402f4b83d742e27cf7f5ae176799722b2c554734028a33316c8eb4f1af38335026a00920d0b66be60702c35033a82a679e8cc32b4d656d1b58e2bdc018acb0d20df8f67b24866be0cf9d7b95abbac8730f1e74bc79f7cbd9205d0a01f3f1c518bf18d72d1ba0e0a12e8787640d30291d04db1c70bcd4d6da5630306ebb98739dd6ce5ffb5c1cdb73cb7af4168721ddb4bb6a8578c53eba9b0f45261b7201b5c2daba4993667976e2f29714d75dc62b73f789f8aee168c7687bf42890dccb99148ff769d9bab59a6334f3753024b632fdaf909d84e7595ec88165db1943625200d869d187e3f0ec451844918b995d6c796836af0abf15ae72f992a438874040b6216ea53989fa1040ce6cc1c1183d426074ad440ea4de79ba885fbf0e9a8d270b38c2874a08afbf1f73edece01438488968cd69ebca3a366d26e843e4bf757d5368545288d5d1cb259190da48098fb3e110f35e220b0b76d6ad84792ea7788e332c663381c3b827e04b922030195c32b170ad7d86cc23b54739e04dc5d2a844da06974fc78a89ddb481ee6293a9de339f8c7ff90eebc8e22bdaf5708b0966d6fc4f7ca0536940cfd81110aa7366449828fa622ce059033a014bf6ac37539678ac362938f2c52783cbb96e2f77655e64e44d66ff8a083ee7cc5edeaf5971d6857885f848d3645510f6d17afc6d64bf539076164ca18b4a9ca476375ae46a8876caa717d34ccc38b137619e28de0448c4a507b4a65c0a8e4cf944702e97d7003a7d0e3c8de644ae664d3104a9d6b97abd8eb17f297361025828a702b03b11db98fcd9fa4eee57d7ab1b9f6fd566a62b0070922d0f7bec32d6483a624b60dfd1e7750bc51db40002dfc83cbc5eaa9d4b1e1dfbac4496ce8349ef0d7525908ee81ff678955ad889ade202f0e4cee8cd3331d3bcfa29eb00a802896dfd4fac1f1af7be768fead4a70e937ac68725ae1697508d274e688028a97a8bcce2e2dcef1f1ba9322a7a1749f02d11040e107ba1ad6fdee067ab0d06c36294b1e54cc62e62f8b6091ea8d4cab5f279339a7bf286b8ad2f1fccf5884b280b4462ffc341d10e807beb1216849dcf672675a6806db4ac0e6b5e15484c5729e855e771811e14ef91538224d9cb641c9e229881e71fd6788281210b54d884a23644a85282d2ec7fa91953c7188d5ba1c63d814855c690ca62f36c220942102cc7ebcfefc5be8c17bf82153ee46d0f358deea4c462d6bc504b5ad2caf82e5535153ded53a4d6d777da11d5fae5c31f25a0ac3518070f09324a65ed715b3a30b023246e06413c0916f6e69df2c865281ca544345e6fc7335e62d1e4026bd3a149b6d4d619bb68c792185f15f9edd485f3abcd9bda9e7666b42ccdda08358c7011fbf2da56fa3b4039bc5b1cb0989cc8ecfa514a87759724067bba4b68ba160633d39df63e8ba881db3470712eaaf0725532cb328ad3f022593d222ec75d4d0ef27adfd8fd6c1193fe5267c5001497c7e665ab3e8bf2657da634dc64637cf3a1c716d5dc700b1f5025ea43497b50434b50173eaadaf8743d0e17547ae5d331ee29a97a22e0f6672e0d0d22f72e648d0bd0bb5eb2aa2649e181505842e2a7988358593c25c6cd9e8e4fe4ca64d9a6aa7b4fc42b31af3aad4ec59daef8180d3082f173c70212aa013741e647d5fde149c1ac75e2a52970570cccf01bab3fd407402ca349dbb053e1b7fccff250979c74b54f1308e09f7d8959425fa82e06883a4214f08f62786ea56f0e60956d469ec32d6ea4861b450c2e8bfa4ffbaee3c28e61778a6cad8672045de5e4e4dabfd55a47884cbd317075e8c4ad5b007928bcd8cba238d73dcfe9279eef7a6a668e04ddaedd4dcfa5b58a4e39518fa0997acb419e39c82114eaa39aa4f728062353a2885c3f4b084058809c910b5e769933bbe0499e680d42e4f74c9a556428e3a113a936289f2cded5b928dbf5eddd54b1676a1eeae947c5eca41c28acc229585e269f286c405afc2adde73b676ff879bc46ef7c84e0d0b9c7d02e71aab3db7d4cad8eb511176163d005bffe91943c0c690011e974745570e537b1950481dbd124dba36298cb53be48aa65d529a3ad7e600e6ab64dded704fa8d096ff392b7cf932ede2b57e67d47a1ebcc78185ae92ed27b6bff75a7ed1f6ddd5e4173262a7085473fd66a7f9c456ab8cee35f928f7240ae5b7ca4411b33f8fc6775e2f465fe9d54fb25bf5b68ab24d541ac3af53af82ce1f86c28368d2891c8fa7a4cf453cba1415a250f2b295cfafcabcce74091215b0e95fe2c28bd2b61b32c823f7c4c3052234f7c190c17df6392dbca9285a8cbbd3d35dd31e3a473c99fe2fff7249d24e4b985fbcac867a48cd1080fbbe7c524b2dfa6ad40365e14a0f12bdce94fa5c2f371a68cd836a300f557d18620822864102c4d490028734a195706d815c506ea92720827cbd8fc4a457d5e500e96a93f0a75ebc5aac2963658a744d9dd27fce738cebf8827b96f29842b53326933bb0ad35b611ca941988629b5bc42b504a226a54aa8d257480e610c28e1b9c866094e1af6c4cca0a57a577697d07e3516dcab6ac86ebb1189ade38c21180f16ade5029d2661270cae9d438557020c127e8c175be4f6a58837bf152cd2e57f9a110c1619005cf785734bd3c0f96e9994016bc6ad79314687bf0d5bd669b94f3150dc96c77f8a76a474b20248005b418bb915952e863d86a9ff338301d9f9597f6c52ac088ff7d4d9aa14d8e586734da1889500dc07c8ab15fb75bed7b21a26a0138fa1b646c1eb5bccb6f11e5761770beffdc9252f2a8c4ac119ba825e7b3b4acab23bce7de8c84f0ea48dd9066c4a9e1681ebe4608296b4bd7239b49e704ce01c9db6807ef5f24a6b27d46d5281740d123a4b2d3d5e3f1abe8420cd06d6ef51d5d7560bc160a2916c2ed4970d64d2e02e4ddf774520044a95c35aff610ace1fdc72a7245b2f01d6dfbbbe0a25ce6c1176ec65114bf299fea5ae24b74ea8994b2fde71e7f8c82d8309b65661b3ffda6a341b924d674fc617af830ba1a559dd953653aa22afc5a6b43027fc4cbec480a98218ff4318eb617f818b41f4959c15c60ff58013ca9d4c87129f6d2b31b93d14ed65b8a427ead150f6247ad7d2769eba2c46111e0b23c92be0c2549f02f27f02e0396d5ce1ef4e6c70b1d2f6c348480d5ba014a41b317a686801ec3ebefa061ead3ae87cb3661d6f2700a8616cbadae6de1be8fbe041fa314c0612b6f9fd5d31b57350dabdbb85fe99acb177e8ff9da14718aa5a5b82883974de1b5f19c0c1aef153217e6f1a7bc5e2c0e4d5333cd9a74137bd88d6d69779efafc7de29d8ae07e97947478ec315d976fbe05fa0935250d36749ca7473632ad5f24826bb402b2e4219e86de682cb1f8ec804fc732e992a6ff1a016e1ee611ff757411f96b2dab5016fae2f6d8bc05f9c50d69412150a76aced228b14abdcbe17f81ca69761a674561fa032610990f3e083b635791eea966295054788d8d2d9d60667eebd62989a9b35f21706e27cf5e106f7de8f717d3bc792d34c6d402d4c7025e4ec2bfe26985acf3b37c880f0a8a927f2ebb9d08be8d55e4f51f3838371871ecd15110a0423344945e10f8db255d198417711043a4611dabf85963d59e497cd46179163b97e5b0e7f6991c484671c48468391bc6d0b8829f1cfa24d714ce1a739e4e198202df6348718f91492d0bacc2d095595c4fce40ee7da87693e78ce7d207d76110ceab9da8fc826f30ee8ec425b7cffb5306823a93e089bba5fcc3cfa35b3825239093ac07038be2f2ab24c7c10da564b934114875db4f1409f6511bb1a5224491cc8ffe3c6732881e88bdb633ea5e9159992b671e3ae35d72c629c9c9a0f48c4dbf5f87c9688de32f5676efec4266a75477247248f88ea78e64ad2d2dd271c78a2606e7b5aa53d4b91ce1bceac24c6dda275fe3a73cc0f4c649e0edbfcda7890874d6972126755db9d10dd2d9507a14089bcbf3ca7f766dba0a84cbfbde0c939721e71ad062581321b219732691aca38490ca50ad9923317c6a7991178555008b641548ac73ac750c130ba185b0ef3ac0a73847e0a4719b2294a49ed5c10d034b88bb6ed3bc1cdcdcbcc949e618ef14abee48708dce324fc2cccbec9b4db517faa497d9d6d6a2ec11ac2d318460db71796be51c3bacf706794df276b79c0d269305f9d4a134b2f56d59d7eb053104880724392b96e8999b2829ba3b86787c36865e20452aae6303a2caf1581e31a9a01a05ca8beb0d068e77f100094d40832a2141d0d0476bd3c21cf6fa5a62000f7657a24de11e9cc7ba1d86b0f74a9d8bd116a51d22f9537fd5e1f82d3f47d8715bf5f31618bf606a0d8cd3ab876b3d2e446520b675dd520af8d12a640a13502b79af33ca25e0fbb68147f2a3c372eb2ed0a6296d76e69e5fc8bbd847e8cf89e724206d21509e4f7ed95fd8eca268a4ac8f0258f4fe58eba6fd56e3784b132ab69cdb9d43a7ad144b83af3452a671fa12684b2a1329370212fd9b3ce4de1f3ed1eacf10e2ec4f018d47132a738906addaeb43508572f17356cdf9e04cb5b74c0de07ef41e327b8766ffaa87ab3df5f90101fe426b69e3ed84a9d7c699e54d090bbe05b3a8b27f26e26dcda72a7a2d6e9a7b1e41050d7afe4b2e47de9c7b4d11433344bcfee9b50276f9b5e30db60cc8aed8002eccbce533a01ab7f81cbcb2ed9f45335fbbdc137e450c24abbb87259169f491dd1b2723d99ee551ad02a7ff09e533a4239fb61879bb16ea9a8fe84c8642c72b597f15f32917971d948f7154fdcc59349d3e903e2317266571f5380200d2a34b1f0e5377c3b5f2371089f5b40e1ac23e7d21ec0cd4309633f734564d1e9a33613956a518928f34df6e13b2ce83370d79b9395d722bab7f41a81ea700eb45327a4d205ddaf0741bb69e379f3bb4a55f8d325d615c194016bd7c62e7fd7039b7c96967a8ba2b0fe3c7f05037f60c7f40cd8b22e9d3fb329fd393ba4b34e245a97e7299feef4c7be604913e07e992623144688ed85ae4db9c5a5e80d819d607a8b93072868ca73068b5374df7856a6ecb4be1b73c76b95ed9bc1e5a35a102c3a3137336e1074d3ee52e9be51e056d9c1cdaf72be1c7045a495639d50a8b0ff4ebed7cf1ca7a8899aeefe501a888fe41767e380ca6dd7526d5c4788244086acf43354713a54b0ee8f0ab93ce89814ff5ff32c504021a86a5376218ef6a5a31d171dd22f077646a1cb26741f9750519372e9daec640a94558b90674cefc05adf4993ca261cbe34d94caa52a1421df7205947f50961dc503974e74d145b4dda4ee55705082b3b4d1d78de3d8965a42232814bcd594329ceb7398af0e8beea9336615c316f02f0f35202a1e4ca6fe3082773ef1566d63dbe4ba49c6184a16dd005e2a9558867a01ebc0a6c28389fcf953b651aeb4c1c7aa30da63358f01b771854a504ff7df101f89031aed1d1f47a4bf8f79dae06e98dcfb07e4f25334173f98cd0df79969f9f59009e703572d44cf282178e7fcb40f682a3e0a251d221a390af4487fc16b838e5ead6c9a09e807f903a43699c8032fa196dc5294d00f7dcc372b93d49a7bc8aafc0a4cc647b8328ac87c303ad952933365e178b8770505ff3446804c788c66580a4214c1efd8cb19523e96e48abf3ee0fa23d0d11b1f55ca3c960d7d28c168553e399c112d9c69c37439f7b3a9b8374d17a324e3b23ed353bcfd40141459bece34537cfb502852ffc1de2392f52522bc7cd7f2685ee6c6e274bd0bb1e8b806308e5984305262dac9b726db3c2bd9ca0d6adb7d95ccdd18deda8247d294e3b7b7c3891b50b14cdd6fb1822e047cc8cbac05c38dcd3fff082e7a6ff02d3b3a564702e2ad446adaa03359a66a3502c9bb542e30fbe48cd2c216f89839c436f79aa979715771afc458f7bdce448ce2bb9d29e5cff6985b1627fa386787d61cfe7feef1bf22067db90a500725dc4268675e6a41b41c03ef321672823d8f255dc0994a855b2990a9cb845509ffe8e00f9f8041d29cb96dc50dc26c1eac1c7c3264ecd10b088f2a7d56cbb727b656a4b745ce0380581b86584193d8704ae040afd6f1928e3753b69eb7ad6ba1ebd058356638a693924796a9bf1e625880547e2f75aff98989198371969ec2889d70657b6bed9eb97a6088f595505269f8e0a861d3d2d9462ba7665355fa9e9eba164f89e5e5e03d0740de4553d060dd5864677a72c69c12c5f84a46960d4f3bae5c9937f35b17ae9242245af15d066302497c7a0e5d23f32d35dbb991c4445f755d29d77034e9280c15966be8b3ed136d8a85dc0978751b4ac90fd65a4bdc71bab732cddfb05558439fea0cb42cde8cefc68b895337a7bffe529f050f3a279287a3933ec1fa1ead24437f65f3df1b22aeb72cd305b9363c9e0fad8a986e8efea1fa3e9d1145a52b460ea22551e3114320ec026b8e734a2d5b295523aa0cdd2d33610476444ad04dcc116f93a746941663b25a5d77306201dee5900b6faf9a3113efb6629766917e0ab04c21f0e0b82009f1c5419da229239249e89ba6e8856fd1924e156f2fcbf63783c1640322fb947a17ba7232807759b6d7fd95b6272210a572ee073a9378d9c30ff3e68c151fde6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
