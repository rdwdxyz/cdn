<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46d913e3af2d91259fdeb253ead60ee865349af2d9a7bc9ec984a76a0f341ad22087014a515d6836b6c8fbb3175611d38fe0a621486d556a77cc3628bb0dfe7183c0d1615a55762805fe820b2b0945bdbec7389966eab9ae2c5d75592e5bb209e7ab8f587662c5b04a24ce954a0af22d437250a71f626420ed9268720c106a0e474d381b48bf23b6d5acd94fe500b04e056cbdcf887847bd5ae0d6aea4a27939b44b834b76f3814e1b07cf0ed56a2640d78e1e2a12809eb5bab0e63527afa238e8ecb61a0ef87a9a9d71a5a1c17e3dbb676a19521903b93376d91310fd3702c276b335b3c79b310de79724882dfe0cfa9ed79f9e5c4a5aea4ac34c8832c061e71556422cb36c57bf88c496c1026d109d3a2473da8ba9053634bb14c84996f31b0afbeca8704ccddadfcd97fd436602dc6444b41baf0866877dddabda79fd5df7bb19a7223b031ddce189c8f8f682a89f830e7f66073cf774fd94eda3f07bf1b670c5f31777870aa00d7edfc480859590eab9b59eb225f23b264f23cdc5128b4675cde34218ced6e18f6fd3acf6fc3e9669a880546254b817281c3a1739e9118b973c596542a9dc215c5dc09dc6afdcff67c7cea878eaac227ea64462f7e5957699b6fde8546896cc8c83c1bc1eb7ab11beaa4b656f1880d82880acd0bc6f9ec8a88e47dd424a2e7fde32164d525badb7c00015f6d87b3cd2ad115bc1b4d42a44ca612707ed036a36807889a256ec747b4ae04c2991651601e970381a06352f4d3941b469d07ed6c72b98ac0b6f5f138aece74d0ed5c1409542cfeea3f6838ed61e3c57ff953c0124513fd18aa717b1ef5a96a82f922f7020823f5c0c9bc50fc113e214b0bbae31216d1b75dfbb8a1ffa48deb5931eda07c0e4a70eb861cd47e4c2649546c5c41f478743ef9d83e9b5d84324171ee039a431213453076fb198062adc38137c2534a3718b69266e1fa0901dd59747bc589f9c7f1d2cb475d4ddc7e11366e9761497818a95420cca08769f817fc5f5162abe91cd992b4f6777a08974aa296f6ed592501b0f97fc7af2d0f7600411859003c635658baac468636dc1c0220cfd2c6fbfa1f998d1fa67ea2ed0052b889b03988a05046a9cb954ee3dfc26722b9970656dd99ec6dbb97b074c8b413199bbaa35b4de5eda1c54a554cfe0f400db80188e3ea8b74d9bb6ec908f435333cc3c138d2a83f857bf8fe334b422fa8942c4ce58a3b0924f3df3f12c0e009905f0c7342b63e74cc9c2d753d550365960776b64ce55880b3376af921c8b40e8915fc57c454ab8451a62e5dbc0cb1ea9e9cac6f8ee5ef1bdfb80ed732213f87df89794a0ece99586414afcf4a84f3c9fd5d9a16c84b20135747c98532589d174694e821a13978c43598c8907f1eaf0c82ca2db3e29922d897d64facd2aa19033ad6e767e8bdc33b0da6c6c4f46cae92e9d8d026e4ded0427d94de5d423a40b6f994f19ad0abbb8c78c1bfc3954355082734ca963b60fe5748ad7bee83d841e9dbbaf53abcd110872ea727a78e562e58a6b0c845a3eda06ae811235dd8eb5f0940be149a5812674309550976b9a828419775068b8b94fbe3c9a3ac42c3b8dfe220b5325d7abf89bb981d35d9c21ec0c0c92ba868f2d1cf9771fbb899a1173cba1ed5c46c7b6fbedc104de108bb3b7fb90d03908b900cae21c7287e57c3781dee35e0c0200e7e9c6f78c864f25329c3ec2f906d26f888689c9ea9f7256b986abbed3389d8dad4de48df4e0670be580b838632dfd9df274bd87d62c82b234194dd2cef1166e5dd4dc5694c79eed59ac7871ad1141be169e0620bb4836e15a759c5bb58cb10c6f8795ec1af99ca4b78a93ed11517e4cdca697f93ab57c5c8144f7930acabbfed7ae296ae03cbfa049b2a680e51d58ef6fbe3a931ea64b9c150e0e82630ccd7caa5f6b7be34b9601152df1471fe958ebaef71996a0b74c7e25763f902396f5b29a09ebc2fc178e206ab01b530d56f78c36d33c59ddfd482b63f88d1f692bd0c7cfb317def94c2f4a19f07df6fac9ac5974b37c153ac501871e649c5215eb1037c30b51fc38ee07813f6fbf3adf58da6524a2c16ee51b5b8ee428ba99094991227c8c117135fceb1d8e41157be5884a8261213dc0a4230e03ac06a01a01eb66baa7d07b803fa60b6c2a63ee0a97908642759dbe01c1c86f7361fa5d798cf222521c55f45ca85161cd08cfa55bb603e6218d26d203ca3f772c8c00cdbb06489a712b08b68ca0f9bdd7c3a2bb7f472df933da4754735e64614b308f48d947c2a2a3e9bd05719865d197cac386d965379da31946236f18fc3ad6db710ffcc6bcd36c4ff6ce118f5c3e1a7ca62885e0b3924ef544fc4a577836c0feccf40652e0c8383735fd55f1562698e0b45271361efce34d6600d9a0bf369953c6ad3afc57f2387fba3a0d5ec1a0c7147fa0ff244c7eec9e9c7b6114a1cb948fcdbc7caedc7eb28ead730944583717795cc717503c9dd621af4feb57accf48dc5e2509a9467f57100d7f8e14e84e073cdd838681debf969d12c8aca753a9c016ef4956916a78dc48cbd17a2f9dd489a5ad6d4456a47d5eacf21026445701a44e05bd05c6d3c4301c01e89619f80d293d8ba04839c3503e63b550fb16218c1fb8278969a8fcb7a0b70b42e1e5f9dbcc09aa63ef2def0994dafb75f5a5402eaf86debd4b1e219f9b0f81b7bd881d001a78c3459ea9a857875eec0ea82715d9a3528cf4ab07c837cfa1eb178d11a751c120ef12e0038ce4869277e0865acfb65f247cfddb44277d9134ce11653b97c5a390b676b1d3a91ad8087e105d5c9bebd31644b00da4e1125bcc4a108107f34da506588e9c74f304a6da1e7caa3c7d3dfb0794319b28e1d61b97313be2c751a68e99098153351917a948b46843f478d5c30b9eb332a12667de5acd44025ad6ec24339b0582511d7ec1663617fad5c071e9392620ff9f9eda346954017a6ad0f8ac934534731f0107a6579ee9d029f51378384271faca63def7477689b50458fc456640be07ed98e68b2630c4f0dc667814100dc0736ae427cea53c4df64f9eb553b3bc4982f6acf3cd397a1aec6e1aa47fff95ee555268761d1a949c0999b780c197c33837927e4b9e4f78b5e635237adb50bfabef7a4e3720ea7474aaea5f890c8c2a39a6ac1222d442fe46e516fe7a1bbd96eee5813d8f3eeb7b61e3359fb5882a970e50dd7eda6ee4761431549db34955185fa338b17e382d5c623ed72b6b2b9402da4b6454f9945c0c42b99e6b030020eeca7af78020ce5ca11bb9aa81fd377bede3d215bdf92e544840aaf64d5b0dcba97e11c5235d6270e3d0fefc86ba265d47cdce96d1a754dc4e58d3c2cf57fd40c844ef83f5164ae9434b96ace2ae65b1038fd8cabfb27627ddde487b5e0e06dde18cbbf539ed849f3b0edfc31a1562b599f6e3184e4ca50c137765fc5d1fecc7c480198fa2434d51abcd9c81a0b2a9f69a13a81cde4011712ea78bda2d078e3e4d73b3856132bb68e78f5c4dcb3b460ca15d843f0c1fcfdcde981457dad5d4600fb27e16e733958c6c8b658c531a028b4f4a62bd9d454799f5a3b4f5b14f162f8b943a0ec45abd3bdbd79ac87147355254dadeef9dcf0c5fa5a7d8820d49ed499e94d89c12a680f4db82ba6220ce8759f0f2a2d3fd9d7fe02b1efe780a6a7e0d99b8b92dd8f53173254a5320165c63b8999dde87639d535edafac5ef5c1626fdfec028c5a200c3fbd7d5f56eb193e08ab9ac8b49598e6bdcc561f7d07162c7d88f9f33755a9957a2ec0d3512fd183de0295dff66093f51f13fd83fab640d329391172e5b26faed8ccea774a1659fc0c53c1d51917af192145aa00bb51805054d394af97a2d35ee4a14275130b7cc41e21830adabd91f6cf7ec2a29609ba998de83f83c04448c8048a1e829dcf03f06b1e2fde615e330309211d40392d99e88a43f3cc420183e39c652d83c8b238fb7f1f09e7a70592176b8400d1873768b33eca93ec245f7e819e9fb0d48bda320a2a4e978f953a06fe1b92a69d93aa08df17bde462e8b15ac536b50b1f5c8ab788cf42337a3cd4155c336d65ac95b53fa18b900802cd5b675032ad925650b5cfc4d96b04d7051c2b420ba682c67afde2392def459527a5c8b1f9e77c25b3f84dba8fd4c5b581cafad1e37b6d538789df5820ecaace4f750c2450444216d3a3165ed87e5bdf939e988e9c60995fa7569eba97a9764fa220b890b04134face205c104e1c14f5dbf8fac0070711e8de47b35e0bb93ba083431cf961915b2de31be50d558accbaceedea48a8eb139d98cf30534e50e89f5d966dd4e30e4c118085cedca1b4e9f72a7ea0820d39b7868991398128f8aac3ff6c8767187f122e7a1479568b77e70935a4f2771510e847c508352d22a15a02afe34fd8af6f7166fb4da3a374ccf416580cf4c2d5fa041c8c7720052acd11b57985d0d90b520de62f6a8e6d10ff43c7a32a353ad463916e5c5cb4a2aca19f24a67d7b87752e2cd089e0608b81a43473c8e4b4b2bb48a82549978346737eb249d13b05bb463551c00e39a1b867349473b1bdb1a43a0f247ad9a0a9e8e1c7235b68ddc791c6d52cba325d71cb27fbb110cc19c8ac123a69fc628eab028beb8466542d673cdc19b787b9bbf44b43eb5e90fa43b6cf3352706d58d5aae5281a70df08406bc9a804352eda569501f666e7cd9ccc8c45756f2b6c4770ecec921bff70ae270a0c53db32fc633ec29dd1b5aaed5d61ad7aaec48c376b127063daddb72a5a47d5b2a48ab08ed44232481ab95035bfab1b964d2f27bceb8c90df9fdc690abae7d1f0f42fa159c09fd6e62f5ee2114b151ed186cdeced5cdf2d7eb8315a97ffb48e85f677f63e9bf3abcbac732baec1e4eec90b0fa6eaacc4d6e4d0d44d149c10f7168324852b30ea265e73f031e8a87ae7b436eda62dd6462c3ef15ad90d647a63120de18450ab445c16fdbbd2fd9965a1f3f9317ff2ef693c73be51fb4082848e4d8c8b0f1b87a85be12a20bef6270e5e5ab4ff7c68fe62ddf67a252816f4dd0d7f3603b9bea1972806fdf1c1614fd2bbfbad1583eb371473f9e6091ac1ca3dd0ab3759a05144aae6d107020aa102c13f0beb53f73f2fd53a507d0d277306ccec6d78fbaf080ab1c23d4f661ca37141420e1e99b415a7e2465a888a7373b1b37691825afdb0b043b4c8f4520d9c5b64cfcf7d1b0d36b62c1e3d6e6ac80fbde757ee1696cd71a3e1c04ac72edf008ea28836ce39d528f6a794d72e24cffeec58fc97b7dfd41191038e24d03f3cda341c83a0593723af2399dd9c379be9ef4efc9c04fbecaae0de1c36014f3f37cc00297f5ab4e1c2fffd1b67d62078936a6dd2823d216e5d9e3aa9879b0b9a4a770efa282202c61ce5e73ce31c5b8a7f2a8b40d44af017cf04dbf2aff5ac9fe2470cea6b17f9219f530bbc55204b0593b3afb3175776695632d73b2135a6e18f225a2483b1e8194f3feac1b8274ee5f9efb80a59400766cb816d33822e680c3e2c05c435cc954a319ed6c524fe76301f808b6e22c073483887b857c4946b3b5b427c25d70a63f0017cad84f48bda0da4ce0cddc7c2d1b00684f242efc7d994dab0442008428e42b84bfb4eac78b6a1943f5e97ad6dd77cbb55943988f09fca0d3c40964949a307183f2a3e45e85f4e9a03889a0d2d626a86267ca0082fb78bd2a0845614192a638640f8957057bbddd8e8ecaf0c8edeb74128fdec457d5f4d9464aac5ee55b3b7e0454fa213e50a51e07d731cf407f26143b8d76c40c8da10764d05bce5f8e0bebe4821f72d72898db008a7309081f15633416f11cebf63d4a093ea63c3d1c59ef5ff53ee0240a23272901e8052309f87da52a2ef0cadd5ca7f0c184466198af399557865672e04daa31649ca41c99ae1391232b83bea26f14f7037d8db42cafb1a3e035e300d0f0aaf80b2b231fae94cbbf7ba56e1534ff80d7b6e1c8e91b8dbfc8abe26f3c6dff591d2ca5119aa95acd7f2ec23c982e54916070d98988ca5b5617455af8aa0ae0deddeb5763f44ca1ba903e864cc4d415fc7f74ef67ecf7732f3a988ec08779af2f65dca5fe288d04e75c4a7138f289f81de2ae05be295da32e1e886e38a1fff94dc20ba387e6fde9a0ad5ba361ba8d338eb069cd5de50fd0afd76e7e338cc63310297578a4e3f0abfab5c50bf61c4fc9e1ae8a87600ab87d23de07b1b1c408fcfab62e15b515e8cec87fb8194f43beb34839e3ab09592547494b7a821087b1e4632ac05ac7412dfe42dc41d799eb8926c071b0d4a4fc2af1ad39312482bbc6fc658f05fa7818f37abd169813e224e4b1c2a170d33f4b81670651ea21828d5516f6e9d8de4ea3a6d58fd65ed447286dc2502e18ff33f5ed2dce116641adfbbe580437afa2b5cdabb89ab0464153f4ccdd53d91a96e6f481559339feaa20fc25c2efcf87911bce02bbc468605cd93f11dafd182145ff08170b19c4ff72d4c65f3c226908d6173b1cf87c1b462d7257ea91115506520c0d13f980a113b78ce6d73e634d4ff339c117407165006d58da98055808be5a2163cc1d6a538c8289cc067467130682ac9ec54aed04e470fab5401d3214edf0283d1abdfd4fd1ef57a0411919469f2c54cad172ab9a80b1a92b666a4c5cec0f42ec43619dca4d848e63a76a069121a3e41d62668d4e7e98f25eda5f89c105b8808340ed140c2fe5bf85a85731ad28612df572a0f9c4bd9a132c42c2efa1722bad7e3556b3e0bb6c537f411c4ce30063b020121f1d3c04b30a2f5a2b4241d809da2a13b142ad0d600d09af6ec874805a13d698401c04c57a6697129eb677d170cf325b67bed89ad7ad1e140462c422ad87ebab9fa3bd39d3afbe7b55f57f63d882a8c725389991086ec3cef1202b0bdda7e3dbfaaacab4e50067c1370f8819ba005ac6ca09de71e93c989ab08c910abd0f64174227f263a112d30e91b5d8d0bf681cd6bf463c31c2c19bfcee52929b5c53ddb777fae81c669eb4e701fc3dd17aacc3d49af7863fcb542cb1a7a3ab78242102674a1382457412603f6a83c14043dc057b2e634e440ff8beff719215ae11bce289befe61a76f9297c709965c1d9ba76dcfddfd082bd471d377cc40ab930dd32c2761f62de8f4403015801424c4c73d2b26d738a00d911e65053587c6a32e449a296c354959deb71d65e7f64b9f75c93137baa799e5c45d71d10162c69a0a8183f3d8c4e23128761a81944f83de1dd29a1b0526ba1ccec8956ff5d159a716bffdff4fffd368b9ce10792f80481c2f87b588d26845549ce6d114e5a7bc82067271c0e7c72040dc99c36f47c66f444e3d64164879a0d014fcf95f5503b64924f0f47d6cceb6ba20d276408d45f89f16d5ab9c3961dea50d8a4ec9faf01dc68eb63894b8634bfbf5bdd234b2f8bee07ff0a413e3caea5229a766c023c1f8e7a91c3c3d55407d9d06f3929048817849a1569c713b6df3b578b4cccc8a4dcf4af01a74ae5ef3f80f27cc43e1c3141394eb2f74f7b03483133b08ffaf934211a0981fa2d0d6ab9987dc293e3f04fbd11d4b495409531fa3e14039c8e75acd606cc2c97b7379c8e8d45682acc0792fa8016ab54a1a216641fbc9eff3778cadaadc6448a819d261544d6e6261305e691a708ac4435f842997eaaf7d843039dd419cbec73beaa03d2f46af5da69f2865686eead89e87d528de8b751f25523452f80a313af6ab170c424e979867954e518b54cfefee1222a2aa9f9890a7d7b6d46d217858f22eeb4208ece01ffa50e57960f1fe516c8a3323c1fbfc9d94b7a90579118c118889f6486d3be5164b68f42521c1af616c37e41360774847a590937a9d1f23f4a0d85c05f11308e1ef5bde0689759dc34586eb36c1bbc532ba1cfda1881bd0e40a1dc6d3e1906ce0c90caf8bd0deddaca4674ef52fe8276783d27899b30e44a541ee5e27c6f41b19ffb47f64de56f3ad2ad967a05b67ca23706166f8b3658fb0d544b36123e50934c58f23210093525c11951758d0b5d9d078ab19188f586ef0ae7043ca479826dc10231ec9b608c5e2eab10c0be27cedf89f6899945991b4de360a99ce708521f5fcdde088b2c905756448bac02773614e369e9cc90c30d5d3f87d448df97e3b0786845f14240c217121f220ff39fd57ec8f721fc18be0fcbf1dfa70d775ab79770cd0d2b9df83ac60a696808508343eb7965be6bb34cfe1bc491b4f141152a74d8ba769fc2a0b7cb00c9566bd4d62d4f1647cc3e057041028a1f483d542af237575c6c96366fafdc8f77cc5d7b78bb699a600918d0f74d280aa683b0b2f61cbf1edd03a311d42ad74118737fab1c8ba917df3fb8e00dc367f768bd1d806400575f15456956222a76cdf26889c93116ee1cf5fc2c9890d2b41f85de0c5819a45574ec444c0405bf74a2ba294674f3027bf391320b2f1dbca44bff2aaeab65b1dcbdfe58e36496d85fdecbc640ed09704e5c928ba94af4f340d4ae491d32154a7c0ba9a3a0de35dbe42e91c7fceb083f283c65ba4f71e3674a8637c4855f8dbb21857571c6d98920b749387ce04a32f27c5f931735865b939d1c3fcbb537f8e7e663845d72a431b6d2f59b0d1a835561753dbf25768753ea51484f0a8256167b3651152c8b5469e22d2d78520a6e4f26429c1b7e58a1d3649efcc814233a74d006851d17f27a221628023f6fa0dbdca03daaa59901184b327ea481a474f6ff5985445a8e44d777f847ce47d1febc82fc27f3406b7b24c6669283050e969a39e043b90fdf91c113b71fd8771238b4ce0bff27d23a448b2ce9336b1481aa553ea215eb4ed8faef73aa3c26de385d1a6ecbfee6a4ade27d8ab67c4114f584a44576ac1fa70c056a6e5eb4c7b47dda56ec6f6af33ca11922ac20a20821bb61a0335d861d6f271a2e89bf339c35488997081fabbeabb1e8ce56f7b4d48e48e051f1df8cd6fe838bece307c54a52318395b0c2e6d0fafd236e030d2dee7b72adc00659dda50dcad9f179aefaba779063e1966c8879a35013063e6539ed2a9a8b7e90fea9ae88999e59afb389387fd9d890a2fcba819f9034ae065ebf1d966024ceba0652cb7b65781b0c3000815be5e493ad35c07029940c8e93196db2ee092fd767d1fed6991086f3b017744fe8fac31df9f395f82987a502dccaab2455c4149383b8551794be4fb2de5bc8504e473df25d2f3292c69b77f5d2c2a6b7485a76a0c0de98665966178665bb8b23fdaab8b0f8e28ef0009074cbd2ab15a8316d6c183f7aa15820bdeff271136964bccb5398b3371dad3c63a70d5f0ca909d092f00d9edfee189b6b5e1ed388b2371342fd77779aad94f13cb0d51efe0f308e26509168374b0031574f686e42357b973b0295c4cc63672be8aaee376db3ea6cc0d27a2112831c49b6e72bae1714933e5b2b1a84ab476c01bd740bc30280bf1e2e989e989b524134b462ed0f9496726d4b5cf021f58f9bef86ab18da8b625e5b7101f0c919df651825c535d98269b5fefb67faf6df6a8dd64eca333e2ad53ba055d19b427964f542447668c9e622e46fc61ed6cfc0d89fa4a3d384f4283bddd01452611b3252908e2410e0c22bdef34e2ec60472da75d24339357e21c34b86acff32d85b56c5f4d69be14a6f767be07de6fc0668f4bee33cd6d1f304dba5f3cc8b8b5b6af9c70479ecfacb75297c48535e7cb61e140fbee5eb156e8ffa7b6224533e797a31cade4b24f8d5bceb83f9b7da0adb96a78a418c5d624be39768dde7db76161c767224522b6725b055ec3dacca561258379e86a5b7f6017a86bb29f821c1585903675faaa1581b36b8165e791d61a4dd2bbc943985dc8e92aef4d467fbcb1a6991e1a7a40e7f301c44797793a941c4703ebabfaa05553c9d46495cb2fa46b3485136199b6c3d60e476e5d590773c8998d45c3525a478143db44d19546a4fdbd19a1725b0a6857b94dc250c1ef32c8fa8f79db44563694f46320a213c985fa1a08c88665344af8ac683ac649d95122e781ee80edbd6df61a0b8e6e153afd1e5d2c5758a8bbde5b16a2cabeb86d8665036c9a42b5a3bccf6c144c5d06e044e2e44433fc53e8e48655f33a449c57feea80404a3c839f6dab255c5cb147422dd10e6527b338900a9567cc68c98286b9ef2f03c786b68d33b837d13559d4545613ddbaa0fe8e73522239ac7175e418bae6d398b8e05e3154b281ee6a68f5e7081d76481ea14bc099c3fc12374bd5706ac9d28e2f37abd378b9df65bf39c49a8924e805acb43ad6e78ff7c4e21fece57b27488526b99ed00171295f5687927c6d1cfa3aa9ce628ed3cd8b3b2dc91b15d695f8dfc969e182ecb8d906a3cf14fbdfc4cb9ba1b6572cbcd9a75eb65609c4eed37afb87111bf9ec8405c50cf87ed5603fa2124a1d52cf184071aeb5aace05c32c501265c856af1b70a4899519f3a7a82311b021f45035fadeff6d188b869e3d8c9f8e2d937a6b3de489e3c29357c04c94963b2f0f5d5f89126d7c664d0c5596895e92c1b97d1256b708759c123ade38453a00f55c8b30757dc08db26008796f52472eac8823befbea5cd3ef3543b461cfcdc599c5e392aab20b2aa651ed20dc282e4aad1ba18fc22b022dfb5d7c4df16c5dec099e31986d88a380a6e491f5eb0903b5fec980144a7bbabb7c0643a00d85075a0a464e03997e352a3445d1394d2f9c8e30dc59228cc6c3e640f8e378d84f9e36331a8a0d08cfc2baf125de8127e4450963aed4a62420921624652696405ceafbce167f97b27acafdab382d9917219bef61c4f638facafd9c8072666a92363cdd0adb9f2dd147e529974cfcf3ca2d6b53641fc702458d478dfbd52c4f50f25cd084be2dd374bf8c8bd3e9a70d10723a638a9032e143c6bac86902e8e2e5c8d7c9411ce42cdd444cedb01dd690e6a73a520aefcb133c101a2a37492e8b0762456a74ef268575a7bd98189e45661717fd9a3118ef2b9f4eecb5cc243d9dc80a4ac613d0b7085ba4693b19531a26d53e9dc05c39343b16126f75447697015f50c279f7099574820f4b6e66940ae46b210dbc22f35972189a2f9f5347ed78e3bbb86f65e8f3c4b3f77ef8da862083dc6a5f3dea22e27b6fdd5d141d809f92da7467a5d86a9358676168dae3c6253a89db411a6ea31e06f69c77dfdb00f5084850e367d91e8dcbce2323c6aa60ebdcd9199ffd50266e030f0f0b5a5e26edcee8a94188100d627c12e8b678ceebbd83e7cf2a877a0dd94e97b32b9ae466bd119c9ab5dc3159a6be14ba74050ad12cb608a6b9324a12dc80a0be143101b7a4c06ee799b039c2b0a38c93c9ef550a5fa88ee8c2fd672c2c22d9b792fc457b85238207618213a324704a5e3a5b81c7983889fdc5d91f2508a1d714083ab6fa617107d70a110c570c26dbcee55e978d702aa7a31fb422526d66c6d62bd23200c35f99a9a39601e9be6f8668bc2d88875b7056a4742647ce800a95cbeca48e15a7b8644af0ede9ced2b23fcf4dfd5e0320f0c58e37632ad6a20050badafecc1108a542d756c459f84baa836c1d381514c14eafe76d359dc3ad6f03c2f8a292c9431d40767b6157b9f57fc2295cadb4da57c84974abb083ede3a5e12c9b8781833c8bdf25a3a345bf10e51fdd39c9265ededae47144fbb4e20de46b7ca4a25e988c2db7c8f050711424df0f254119d3267d1fc061ac0f53add09d974ef799d9e33f1f8e660a8c9837ea40aca8ae5b7f12923cc6dc6cba36ebda1a62ff0866a1abcdee27de16ee1ea30ff3030e3a390b5501ba425ccbc8d21cb68ce2f6788027761f0bc0846a70a8a110538db4a88212448c4f8ad4fe3a40757dcbf205f37c95e326f1131bcd6be5c03745ce249c8fab1295875284d4a8e3174f39f63f7a4f5a3dae770cd435f1f8c824f158f469d7506c21a2f67d6fed72241ce63cf3d1ac8bf6553866dae4ed65e95ac42d9b08e8ccdcd54d620bb43f224f9a985b9747e55d1a824338cb5fe922f720e7db0fd273efe119d12a04c75a7ecc6205d599c9ca36b1bedac72c5da98258d20f4b8a0777ca9e9fece4f53f17c06c494cc52f4bae6bd1a919fcc21c147e47397cb8d2cf8d14dd6760c13b0e9a45257233ed5f28c6c7e095aae7e41ec71ad7e84a388c77a2c7c8c7763f9b5e1021945b3e1e8ad2a0d05dd61c6112ba305009c6898cbedb3f29fc8fb771f799ce7e5e932dd0ea7f1ddb7b963a129bbc5e66db5594edecccec960f55a34b7588403ed708189d1f2c13fc9a2b17f92c479ce2857f0aadb42642de87ae76c9cfb1a6f526be1985dc1f4f58ca4222430bd733e64bfe9591571d9d70db6ac809c04e7c10bf7c387f9c22e85e8c78b7e465b093833d5b10c10115565a745e9297aa7b91925761708babf2aa8d956ecb201bf76bbb469205391a52e8cee8970d30841057cf755c78859a19c76e9f9c49ecf9651ec60d43814867277483be4ad93c69e9b51a5e3aeb98cb29e9e5ee2cdfb8a7c105c2d5f99f0098f7e57c3ec4d291537741dcd4dbc815f52c381f618cc0f28389429f156bf747186ab6c6a35f508babeaa0172c8323c37fdc75cbd1e76e1c4eddec3a0dca3d55d63c24eb084eebfcf63f7fab43df03deaf2fbc1ccc2c054fa7a9e5ecb84dddcb1e706c6d3fa1c9a55b919b1ae426f6f6b48972298bc6141a66e913cc1bf98eeb9b7fef1c6fb3aaf556a17ddcb34adefeabcbec7303129bf21075f456ff094ab2381ed357644ac0d1afa576c720a8722127fce940306410c2c6027c9fa1c8fae478eb2faf0a9402a7b240175b6a485f2a542741ccb11f9ac473b323571cf365a072c7aa252f24e3fe9a888a1b9c18db6c4a9dcf8ac9b6714b8fe12a95244767a483f8c5b4f23d0aa81634cc7ddf836db298f14c178d379f883d78ee049f0d5d4fe90148f63d5f1f0ddf456fd4b37388672c18b56983f2a903e40b73cf4ff1d56fe68c3de2c67ff46c16d46516b552f7b235b4a58c848d20733c6d865e9fb84e08c52178cc1c6acd8238e60ad200d418fbb7b05623770595ef569a3c60885fd35309e8966aa8c35f79b94627a07062c1c75ff6e793b18c54b3b0aa04a6c7631029522a31dc33ce0c0a7c8998c05666a4ebe6c98a01f5a8887d30b9cd2cee7e0c59245d96ee90a0d047462bfebeddbbe1aa6cddcb393378c25b5c2959706cfd4fa946dcb0d6554c1776bd154a9516f4a8837c2b967ba8f1dd72ff1e4d4cc0aff7a1a92f3e269490ef5443c53a908b5efa3450c21e7d0b1942c25e4930d0703dae726e14514b7f96a5687ce7f9be5d678ad8bb618ed98bcc438e993278d176973c8e82e1ce7609f33e2706becad62650f4da84500362f1b4ffcafd16341c1d214ea91854d3a1ed4f263c8cf09b6fa8e3388640a8bfb9deca07db3110957377f1b574a877027df08830c9e2b676030bd13af66375545f0b1a6ab870c94bd326f55eeb977dfba678d0113efb1108a6d66f05a95d99b33f4d4c6062b036f1c6c41ef6ae5071c9cea81bc6cbc54c7d2e97b036280068f1986594d93d7f84985e791346e3a88900c38e8c043266111a46eab54a422a9e03876a792a06ed7c7f4d292ce08b91ceadb556c3cb79a48a0c593777d54c378072e0d1197c7066e2b57283f9f0bede31e82293166e877bee21822b3281ce1838a7657ecaed700349f47a4cf1498c1afd290540c96de4de48ecd390a0aab1fb55051d9b0d2db2e140cc6e780ff99abcae8d82cf09ccdd5f5097b8b7d2845698991498f8ad32bb0466998a83da3e698b947a0f9d37c821f85a92fe9c6818d9f2f88965a846bbd28e4466c21ca7aeda389667d9c2a94406a09854954217de7c0df8ed5d32301d64e52b3b3b341288a5ddb3bd58b168b209c6fcc54a8766bf1a3be5afd068460883e7f7771d9ea3864a5f94c095dec81a11a422aee8e4c6518ec1104bade6b1673319c2d275c44772eb9c2e835c29ae75e75652c9d6c898769a7c0bca5805aa6f0de26bfe92957f224def952adfa0a977cbae5af6cdc1517f2174cd4f187cf60b0a11dc2f817c6817574afe9f059da1cff25dd0c2e78b2ae9f905a52efc7a0affaf0a05871b0ff577e1beb27677060222d4e64a505b6c5520182aef7ab33c6d743891fc94a6982249ae18ebb94ea0aa0b6bb521c1a553ba86f2d57db4e473e241a6a86605c1c0d61b4f5c4b7177162d1b923a523e3102d135e972e4ee0a89cc7d855622557e12bbea0b2762c45f25292a20a697c9e34b0bc0b3fcbc0e2b466d960561d5214a01a67c39ba5c69cbcd9060173ce92a7e53f7e93a06af005ef27e32c01dff746436572ad50b9eea34fba7d8401967b23ad2c3c52fa262e13df2066fef973eff89191eb29d68dc5661bdc1e6298697ae97b97bcea408a9669bf1545923b6670453cf49e630dda5b43881195857c03a4bf5b80bb6c25fd7971554bf9a6b2c7e409535e58e53bbe408cb8b87a79579a2509ce026a809abcab7dd6186dffd60f57d49e60c4c1c5185e3323a8c403190b14ad4fbce2794a23530426d0e820e5aa7f60d73a777735c2e3ad6b4ee145d9604558116306a7f214dad8190193b642e8ed6caf079be5b8dd810a3723bd8798f1fcdb39a2c1ced3cfd31de21289c506a23cd305e95c2587df81426bb4a6fa0d3f2ef97ee8d443adc08c562f5269579118fb324b0f68686bc93921561bfc3b0489db3104fbeaca36e5a95b46f24f36cbc27529e5e06c7c64ff9489ddd21388b13af27674e7e98b13f93be2cd7e5141e6f9f09816013a0324745aaffb9d463eb982da4071f3483a5f4eb711350d36155de1e3697fd586526ae672314e1f214edb2986a2b63532c004b1c9555d211f3bb9085cf39960757df7dabef5f833f4c2bd765e43166fe51abd8aa1110380b2d38e1a6b67e478961ef984ff08652870b4e94fac0b4c34d68db133b8b80f5be0e0c46745599997c9399a56599942a23e0bfcf8ead9e4bc0779c970d0dbcb57bcbcd0dde0442432e1b6c63425bfb184cf79c48d294a89b8256b05219e9a1d46bcf9f470d130925b62e0af57db5f60dc1a78d57d6341a7782d3e413dbe3c891ca5f155d1aa74333a53bb0bf33c7244b2c42a0db235eaf7a325f4c75957cf689c00837c57d751f4112a9e7e76995d34d72726526b8bfc721498fd5be32d60ce4af1ab8897ca288b8be531c5a88f757ba983b0efaec2059386a296418043e030cb6ae065ec748978116c54404b652ad28de0302bfc31d2840c5774009ea684b78ae40c4bc7fa0ee1348ad9715a4d6cf29cff05d6422637449786909358b7aca987b3fa4a607d09ef3b3b1d39689316544ee29fc24b4e79d84b7ba913e142de3e38809bee9013c8230c620aab0b7b0a89e96fe6376477e9e193182c6ace6fe0065522f3fa796a6ec3b6b55722eb414515948de292ad877dc9df14d6ba7747963c9d02de1533d98db1d63a9612d3bd13c432d1f25568b49f70aff73e712f1c55c68d0c589096fdedf6e15f2ed06d588683e89f0d501743eb5e33c4beab46656f5d7b53e283af1ce290470d4e804991cac19f96416a51b497291c6f5379e97e3951a39821497cf6d33d8a13f8754399135b65ec25ba734ccab74f2364a9cc97e60df923aa3defbc8c993a77857ff02122279019380bbf23f5bc771d3b5ca38a6226e3484d1eaa19c233a13fe9797c4161c1f166ba5b5672141419035b19aa2b8f6a656a60c98b62d71bc899164047cc89477e12a7a96fb4a60e7605c247afbd2a565c8f23afc678170ea54cc7ca9770b33f8564b6aea85be2de45971a83a9d9e24a7f4827dc9c66a639a18ebc986297ab82aa54516206c22c3c1694bf93499a33986ac88aea597cd9bbf9c8b7fd2da3211b5851550227bc645b7d679f255438c3cf6b7f984568318b5006c2df52d2abd9f4cd20b621173ce38a45228e2efa96bb51cd88ea7d1df0ba31c53b1c9a3ab4eb7fd992930148d971609ed0e9558cb87eefcf70586ee6ea78a64eede81c93caaa4c3d7d0e7f47b905f9e605e7b84d3cb4709fc0f555b80dba93cb07a8a98ae0ee5e54e74fcddcf50eaef2dbda0ebed71dc5a8c474b7d18f990a33de12bbb4505a56cf1c65c9c05c1f441573ae06183a68bdcff36e15d0f467c52b7e51a9ad9336cd11dd045eecd2a1b0f28fde7fec2d7861b74b23b529f1ffea127f9670cdc4146c2cab28808d2ae47394c0c8432bd5b2def32f43be9541bc782ad9687d3c23ba17eb6d7f4a5a450306fb46c0eb228f31f13a5dad4dcb238d04ba62ebb603670a92ffea122c2eba4bd2c1e438b3257e67377ddb02c39366c08477cd68ecfe646da8733bc02b194dae207af3aaa1f30c73bef50489b2f8dac7a358baf5ea08db4daabf6a20b359ea5880c00fcc1e2762a141d7ba866f27644c115e679f00a888ec88258c0c008e0b2c4dfba4c2324ad572c7c531dd14aaf4dd206c1550ecb25b9c959571526e94a1444ef090eb04a075022b3dc25b376afffc0969d0f881ee887c5c7bb862c8064a87ee4728659dbed2109e3100d080792eb3f47d4996eceba80f66fd50104f7dbae42ced239eec48b205c617f0a666b4f3e0aefba59b710fd6744a21029f92cccd0c89583277bd4dc552460ba3c099f14c707f326f6df7f4af87da6359ffbc3d10e3ccfa21e002b7e64eb8e5ef4349b07df50628a2850b9e5b1627dd985b16f6f086eb464f17a8101d1d65460a24424a5f239559a09e9f5bbaa10c7b6d9d9dad14e6cd9dbd90fdc27f3af61c92a37e834639f9bc0453b93ce470921c0b33faf709c5f9f56a0e69140da26705c2924f4540a58cd6b481f426388317b01efa35fff05e39ba489c651ea9341d615a86fff953adb8bb22d87c218c85514813c527453ebb40f29e9cfd5371fc47bfea820b8c3f2f8a9a8697e42c27db3e71dc214ee0a3b2bc1afbeaaee054d3a662621300eb4b9461eb622971275611fe5adcdebd9d181a171a53a76bbf6cd7afab2904c58fc71314f867f28b91aee36104e31c185682f5c9045862a671ee0ab28b85bf477322d6ee48fa63bf5140415032b6777ca08e31718c47cd903c34c6137e1b64e32be5cca5c71c12b0ab633314c75fd31fe6bea7312c27233583bdcaa7d81ec4615f439963e118857aaeb76060c968274c8c1245066293fc0d8b966d28f43812c2266945b1ea6166ffd0fc0d7f2e3e98a9f1b99ae207bfe794f89ee1738f45ec30d25e57262e1dc3c52c3a40456adefa2dd94abf70aca7b2221d4154f98696dc91d2a2ba99a02e89a5d41aeab4fb643f037b1837009862df68b3fa9be5380812f00768870da8384a6beeb32bf0691e7d8ddab796a5c229120050fd08b8951df77d88b1b8b5a314bb8331080e547413d045c966774a205d40df0ab24e27b9c9bcb0b5c397ef7a297ac602e4b35da2bde8856242b380ef7783574ca1aab97c90896e204082c9530811363b4da950a5c29246e346bff4c0eb16143ead71c9df5bd672317927c00c134e1b3c6ad6c503ae8b7f800761d8065b9e9c844ae92a3b0f14c1948502e804c1d19ebe6870594d8d132b3f1022b2dfb69417d3bb167e821498725e343becaaf9a5790b69ef6713a68a0e12093ec2589ad9fc4a18c08fb2da319ce093c067c56983ef1285107ef8c768bf049ef19aa41d0fcef107ee68f0b81adc251fa4baee785af94c2556ca0a4487bbb23a86aa240ee8ac241ae134f6315eabd499ffc064b39f99cffc2a7165d1d1351933bec80d378de2935eda61a9b9123836621475d19c1124d2e862318af667592a96a4ee20caba9af99ee9cd346174c89222045b694aed4494a1559db6861a10e8a86a999a7e62c6865e936f7b5337ea549b03de2b4f70ab723b5567094ce46fef796f151ab06cee0b8ee231fac0163f8b9d156e52ae75c7d2935c189278e09e89863fee99ac7128c8b6c87aa0b43f93e88a93adfda0f897998fff5ef1ef78e02e15f45f36cee556343312d1ba77aaf7b9d8930dddb708d3120a8a22fedb521016741b540a45e850917e5f8cf9b8c42caf77a1a1e5df17b6b4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
