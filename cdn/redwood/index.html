<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a543f767ddbd44aeac7ec8a12ed349d5119e6f370008b61d793b774a942552ed43b301e071a62cf31216423e8c112c0ca1b6305ff1a6883567d4c6992a3e94dbc08cdba5afd34683a36770aa52733351720fb96da56d1ee712f6cde35be44a48511900d7935320b0fe3e8a204d09ab034612f24132e642020671e7887796169d1eedaa277aed4492c62eea70a696401cf9e61bf54d0475bc2dafc4581c63ed9fab30c4c0dfae4c81f3aaa17eed3ae62979445c63d25437377c3522cc6ee7fb7d2ca72d5c6e47f9b105b2ecc062b88cd977bc819c227aeb47721fa2483a96712e42fb31ea8d7c10b403df59d0668f8765b31a7a3016e2b5644eb51b108207286b586dea6bcd1b344eb857a1340173c0bd44e8ee252d8bd6d6c4e40a9733d7c556182208cb95feec96eeb0e83de3c2764d4b4e47c0dd853f2691ced131ddf4d8e872da118f920fb0994fba7898192c7e458fe858e92d003c9c2cd24820a9cc07e0c4bf0c4e00cd6b05d900373d07926c7470a6110030886e9a6c219cf49b24390b5941728c89cc1c1b1d39117a41bd0fac1236cf45eee4201743670b33b883b2db068b278103c82103488683cd4c141d2ec306980e15e97c32246fdbc8d57b6412166fa6236fc3cbb43ad3e440c0d4dff571ef21b1909d737c649229d771cb6b0a0a40b24b47e9dc94732ee021bbeb6829e61aa023c70f5391b0131882fe0d782ae4dcd280b40c0c9862a1154b92ddb4933ac6e3f961a06e4a8527dffe4846069fb3d644d11be0b34b2ffd15afcda121b9800cd7a54a4ba797ad6b31252af4f9351437f1f3ab8bc373871f28a5da224caa118b63f5e2df7b756f5c78cfea93a5bf52d26319d56edc7fdd444318df70b2bf0d1743c67aab3042e869bd0c175bc9760c0e9ad745c431a63e8d157842a13344594603194c03e6b265ae345e82353c5e8349da55125454fdf60c62167e1252e5757bfd34d5f58f78a0a8bbfa0632864302fb1bd8fd5b1b90a30f582c79f6737e6f1b8a1e05a5c29e16dda3e0de82b9c1b2776d052283f0add4bb7dde293b66308b28f125c1f3dc01fdf5a07139a52ed1afb7659d657031734101c56ac18628645d252433f7e5e5c824b9952fab5ad80ccfd2d8eef30316fd5d43be02bb84885608da8917e110e6987cb932affa6caa31419c7c6627de226efe6811110493ee76fce05ab1ef97bef410452a7a099ade185bb750a095928f576254e0b151354eedb16c2d83f1871a457c254e83f48238f4268f7926bafcef1140e5408e25ec4ca28aeda3b050dc465c048fb004f3549c73c41b9230d4b4a437d68610a15fb2df9edd8e6b5768f67314e8a6bbdb220e621808a625afa1be66e7d2387af2de7213d5c4071b6ab94824a234a4e8cffbd56116647bf7764b61cd1b4ac7d3ab27dd2bb855a376667a3ac71bdac47b3d6766a8f14694f6a6bfec8148d4e9aa197480fee1f09552282ca3cf6b74d647410bd3eacd0320ca511a0bb94dc3a8efaabb666b7fd5b9d0c760aaa719a58b53ffabd0455154d8992ca112634267f95fb6e0a344eadd7ac26ef265c062225e4aaddcdc9cbd36edb47245f2ab34de1738342b420595a5abdb52aacdb25d6479da69cb59b163aaadf3a9def6ebd4073e349e2840dceb5f50428e5a577d6e52f13e4db607438cf36988c2a053b58fd28e6ef5d5b940ab43af0a3febb131f7abb3748ad755607acea2af9e57500f3053bb3492dfb2941530954490f78d933cfc5b3ef064a7e0bc15c6ec732e96a1cb8523ed3fb0fcee6cc7905a39037f28d0d2509c1d374dab8a1c459982dd085b20f85ac60448c46c75cf81e35f5121fe1fccd5d3c45410efe37689df8177f80403ca9ff00317fdc4faed78be58caef1cd898ab2bd27f077ee6506f73a973f6ba3cd7656509ff78051fe95b8f607afa68d5d772dd85022b57727907b84b80332be5d1d3534c60a65550db40e2b7a60e4eb5e46134d2979423f04ba3457ac298e814330929d103ab33006d944d295be24c74909251e56a2872cac0492910793b9ad22f99229ca03117690026c53e5b4e3ac8142f51b3b91e8699f1a616c415a605b3d0194e913ef289366275cf933d4af490295b7e7f8f61b44a7ced31061816a14084771cfc199d2b9f5477a51d1e1882db7fde620b4dff5b74ee4297394b26c935787bba70baa5e9f657966300844ade8e4d201411b205201f9d77d4adb608bd6a74829ae3e024d2f0aa39b0b89786f17093e11099f8ba463cf2c62d4247d598876b30abb7813e2b10bf57d400e22a57c85222d529a59ecd9ce8e4c89e454987f7f24e0fb4b97ff64dffe79a9641564c3bcb96c88bf3715eb1563865e121d39538bb998c36412b92a1f7cc2453bcef71fa5d0fd45f12988fa648397be34871f67e73b9b462586e98569514733c583d44aecb2ad51011c509aa505fb891129d31dff38c3c759529530f569b13023d6c33e9f86c2b79ec424fd782de5ab96e010613d5e7906fe5344982c7c713513a0ce6f0fcbacd8b120973847b8914481d24853406a8da37c2fd7cf3831fe055611e517ab8fad6630f4adfe9a7e21d6848f1389bc2a5970f4df1d4318ac4e67d4329fd4d463e8a61eca75ffd860bffa769767f976d0bf1e93102e031362af7baa4e11b32ec2d0de1936d276230897068f659bc03137eb0e7ed7bf0c2f0073a746d2132093c6d10fb874e1b9fc1fcd202246a447740fbd71df80cd64f75c723d90bde7c814ae01f4df3cff036c427348b23b3860bd1afa26e7a23c69a1440b8dff85c873f9457e0092ba37049411fcb681acb197f9066f8853c6d615b6857f8407b6c0c26fe591c3fababf5439da18245d9b112409189e392419deba0f223824891533c558c5449beb6c43f26ef21725990bd46a97270c5de6dfc3718c6e43407bc1781d11f0448bbd81117ebd5bead165c083b4d50be9955115a8e143d734403f8513580abfacdeb4d963a5ba96ce301a1cd41d814938c9de7808f78b966f8698b24d28f4a417acfa2934cdd53160a56cafcc212d5a49cee97f78c2e1235c26e3c26f0c2ae48e5e54e057f5530a7c4ec0b4728c115596f2746663ad5048559aa4ed12daf895a57b7ce65ab387c754784a9c4f2bcf4c9a4085bba0e07c90f87f7b8d5c0cadbfc081c0117ed0abe36679fb2fe4ffdd35b2a5f3c1bb1962c9f563322faa72a18978712920e37f0cfc403ea5bc5d353493a623761dda896c6ea3c4ab46816cc81525c6e8a134d6121ae0c9e68d380cbc3617acde94e2e2060f3e5eebca2fc46802b997ba70685d64f3587132aefe25618bdb1e76ebac3ecaa971e0a786e37a2b77c087c982cef1cddac9491543ee09307617f965382b67ddd10c1e423b8e075ee049d9e6bf8e60a017d4a579e71bb4fb622c6635685f008f79860bfccd0d06f9a9a9914af6c081c91efbbe1c5f3e8aec756acc94d06799e5a48ef8d9f555810b58de7f248705eb6abc6770bc516669c4fadd418b89bbbdcf903a7d2563bbe5b9532b77d7c987e3514c7f4ffa652c0a2e79e5521c4c2814d41458a2db91f18ffb1b87c895e818a855c8fc315d67999a5236a715955e97fd9194f75209d83c638357614802cd8a4b6db4c44a6e1774eac00c86692e5f2075783b0ba7b54d3c89187a6669c8856867898ee03f6680cb6b4d831eac87fb6b19eb713a4236e247f6a244fbe798865cf2719206692d855053820a0e3730707be358161ca18d7f1f58e1d7cf76466b5a1ec8fb4a6986953091dab7807b6682faf8340df4db2319feae083284212cfa52fe09b9cd90541a05c00ffa927516df4cab9ecb482868271565946a2e59af0645f187f7996c0a59ef9b401b878f95dbce2130c95c528502a3c89af2c89ec560dd6766ecb3b1b257d4627f4487f0121236e3ce807ac1fb2c5dfc112b9cbd57ef15561da5c640a1b267835139bfc34a2aeb5ccfd15455f05e85855c1c0f53e1bc1e9255dad907f69d956d253d7e156199c3df76da2e4ca8fc9a869f9035629c888022c9e1661b04de0309bc720c08d26024f1c635d62da63b3d26a87cedd2d85fa9a2873ede90f761ecbf9a1d8b94d78bf0b76d77b77f31ed211774f011a048bafcd35eb0392a3423ee27c504b672e20bc1bfa51e05b884f572a8db0400f502dc7ad7fc4e75c53626f1acd51bddda0164e738115b7840fe38162f60ff1ad4e60619c0ecacd53335eb6d01a3e96fc22cc1be15a6141fb223af95a709c738cac11135e9d7f1f804779e03f39a75cb27e87689f9622f4ec9c32f28a9ecbb1ab0303e7d1b7621d973a3b2936e10bfde122b85cc27fb6b0f8b90009fb30fb04a1dd226310c1ceb0a760440c41ced5dba96f07e93cdcfeaef502fe50bc57aa941bf032ee0451bd081e2b04717c34f3a03f79dbdcd205ce51107b14a0d971e016340dc6a12f18c4155d91fe731991703dee8ab65c4ad1a835837e9494d9c7f0eabd44e4387110baf5afcb415566e0f1e1b8ade27153fe1d09e74f3350dd1c0a2b1a92250f1a7a457266e25b24da4a0da5ca001746e34457081337aa7c053a374ae502c38b8eafd0b0fc3cd1fd2b95aae342448d68b24484185306b8558f4f1ef31c523ed3d0e6f7495ee634aa07c6fee6e0f0d01ac09d8f7c8a3ecd4dd7799a0d33fe749c534f27a0acd60fdc4196cb33ab55692ec2771e7ebd391bca55e548245be90eddb78b819d488f042f480a52f14e5355281e5de5258c678677c8b019871f3583efa455853715d64c0ee2189f70e1cbc575c632e6444763564c9090c3c114bf8fbdfd406a28704f0b3c8eeebcff1ac28379df1e121e65c1a99f9061500a9fd00d426b53c9f9617a9b785d8338add8e14752e397054770f82be8571495925364a1dc672f41c6d300531d3956879dc57f8f97c39efded2b3ec083c5d1e22f8745b93285c73bad03636d2dee49f427675817f9b5fd175e9920f6f51498ebef7660529e4f2d2b79d5c31a928519b83eacd141d5a3aff923ffbb98bca3b636989b3e7f58e314cd1fb3d65e3635260a84c5c01a757548c4b10943bbeefc47c3c13e77875c7ec8376160bdae47c384f9ab40b4e85d8a9862b61e224d2fa656d87b38a5c49d862ae253303c1b4358712f2bdd17c6268beecca6d4c84c42b27839fd83b825e9a8164f5888751dbe6f9f8fbec6209c4dfcb8c3a91ac4ddca7168d15011d80434986d70b8a8c81c3408687220e3b70f4a531bb25432a18da92b419bf151173926eee179c81694194b654a3e4cd2fcb84d4364bcbbad837466dea5c9e03435103fe2f56f0b2f51aa1f901f013100d53e454d4c6a88f6b33ea16fe079b9922b6838db54c09ec12707f1f907dd4b3c6241a53b98922abd2d7da581a0213dc28cbc50ce67ae76364a96338a40e70221ce47dc11e542b8424af4fea0f81c7809ab3e514bd5d5e3eace417e839005ec9b7b19c30662be697b3d64d4bef85a1503dea3e55ae3d592697ecddc7d9e3508b57726d736b01e23fdd705af081f81b9954280714e9e14913eb4a119fe35031cb349e2b67df6399033e8374c697ac3eba1518719d0dffd94451b8f799ffe0ddb8328b9b751e04a7350be5c38d7c4e46b30190b48a883c0cc1182f95782fe4d2f35e629a195f6e45bbaea7c24b77be17c8551fe012d9932854978b8ab57d652d932aaa7064cfb5c6caf99608545af1fdbca902b2d33ee865468cfafcaf24fbb6eb166fbc71f38d38bb88efe5dfabce19fc4cad4cd4fd4f9da7b8be6891735f8ce251bb82f4b5654ef31cd0a19a018f62d79d9de8179d1599d553c15b798d17f233a0fc3ae433cd2b069d18e263fbb07fc23f92a1a414a8740f72d54765154d07c6454708734acb60449b64c674a793051b5af765e5f3269562838689f2fc58a8444a0447c7f584edba361da7d55b82709cbd23089d0da45270bc4709e3e0ad0b126e03ad435429cc7d0750c04dab3b41f5fd29eb2c6b72027386eb598899362d9610fc48e49e82bce54c8fc786fff4ab0b919ba2abf0dce7b21ae6e46686dc66b25d5ae4fc871fc83d30f387b81682426610a50c8955fedee21655c130ca18a091a1d3b96be15ca99f0a293c0c968b02c074d6ff5af342429aefc2a4eb7df9896661e96e2beba85809acdeb37d77c1230b60663fdd9220f73359e9c7f7e99d40ff8c1231aaaf1072b6d76609ac764cec25c03d78c5fe62e7c45bb1144730ff6990f18163ff535d761cf762be75b95b21aad1a32867214e0885282178d1f9f5023aac847de06c9bfaa50bddc935159a20275cc086142a8721fbd4a5815132b36393d6fe710ac48c172fa8ed15289e73cc81af84fc8e94fcd4c60841e75d3ea85c2e32fd68090b7200d5b3e4d2382a797ff99374bae34672de1c11ba8a4fdba5938bd8d59ff7af99f13eeab2ba41602987e56d7ed38686d68f69d8b97d30eb2e3c0b096bba4d868725fa551080d56e5d347e713dfc9c5cb9775bbb766c520b29492bdd0872384154a4bc149b4061dab314c02eab2d25c38e9b1102dd0748822fcae4ab5d6f3d93e88c93136da6dfe95c1de2f57fb9f8021c08ec129501f26e91dde97f3fbf1c55ae4340a0234dc577b494b1a8db24e7af6a9f2665084ed3ea153a93f5b10845879b48cad379bcd0468c5ea986081d837836510321736f20daae970727ece9b97524418bd241562555159703a0db146ce6a489bbcd2f218bbc8de97ffd18bd62ab5ff1843bbc0e0a322a32ce8552626b5a04df17f9bdb2953294bb32fbb0311a171c8e9bc37ef71cf251cc46b59bd1da1daa08f45f6b5f6dd8a5781ae4a0e8499743d0690d2af751cb41bec13b57cea7006bfe960c33d08a957ab29ecfa2a59c160a7ecd0d8e58b0db7a9603493ddcc407918f114fa725f36f5d23c9e85f109926393ca59a6a0ac9ce35782d4fbf26dc2bdbed80edccea5d280a0dc3f4ea4908436aba5a9af2ddb471feb7c5d6f2016533ac8024d0fc370ebb92e03ae5e779996a8e48a11699a274c17c87e50b78ec304f8706874b23b67beab102e21ea62123015657f78f15a606409cb062184505323ad560135733d53f196741e9af34bcb2015a260bfdb963715b4ccbb5d7e62639b971e3cff8f3285a1b14927c57278a5c1fd512c6238b4e37c1327e6d94140a24b1210aff2b6883c896a94ce17c23302040c22a695cc89bb2fb72c0963e9749e833a152e134363d37f7237d550a148138e6801b1138db57084ade0df90e82356731e7e807f3e81eec4c484e8e4176d67cb5015b8a211f5457f28773ce20ce1fe80a24e38bbeff4f86020edbfa5c40644396dcc6972a46f5d56668f707af0ab9084740c33f22f50215e30689041b77765d61b874918ef0fafe448f128af237863e64742944859c81ce0feadbd02d1bb9cc908e9770342334d43a1d5a11e9970ea5f358cfeb360f1965834b4d8639c3474741ce54aed6df110871c71eb1618ec3625eff8ac9c303c9f29b0e09e4df43b075231acf2a128fdde67355b7ee99f4c80f24cdbcc0f436e405747f014cf8f42eec03e2553103b44ce613bfec40dc0ba75e3e77d2c7278afb4ac0e9ad23bb9dfc41b73584723a2bfc79ded5974a44e73fb91007b50a328fe8d4affd0d46dcef8679537709f73a57ada4354119b8628cce1f00acf8a7852fc3c214c6728b3f9e4dd264837f5448aed5898f546b5b705143a32788956277047a998a301c4cc0423c0556546f430545143254650556cf32b89ab1e4ce85a40e91a1046426afc6fd9a57fe2ca3665781aa0542b40141723933805872c377449de412971a8bf2b56909fe37e929ca2414ca0ad1ac902b463b03d11472b3b7edbabeb816aa2d33a606eae30f301935ae853a8db4d26fdefececa169e58fe5bf0998e72cf8176f756f48629403b1c3a11015d81a28442cb7e7b51e3bdf700376a3d8cf5d2a6dfe68b57a00417edaf16b732c9fa7ee161b2db95a034e0484914c7b4f6997f938042d493f844c56306a00abda3620185f07f16448ce6c9a17262a347fcfb87143edd72f72d2c0e29eabfdf7ed644b886a4c6ef46072b63a1f6a0f4efbb47688b5b6589ae5179b992da71654151c9602439401907c15ba50990fa926bbc805b0f5059afb4a3e427ab0a21a844829596015232ffb5dbd1df209cba60073e61985569ab87834ff6af754ceccc05723b45055a06c25878664ccaaf4e06f7a0d2dcb39d11baaeec12dd65c28dcc0c6824213f3b8bc72646c9e43a997894260c49db66a2b964a2d432aa7ad0c120cb02819b18841d612fb0df15e24fe1107fe90c29c84fd091a517c7b765669da0204f75647edb32bc86fff3b117dfde8d391221a966e30e2d714bdae2e12a66fce58e92d43451b5e39c1837b16f370ff39186378ec2e82c9297ed733441711b1a82d0dd61634394b8810dcce412c15c1b45afe0cbacb09c1b3e7c153a22500a56fcb911af910d15d0cb15ce91282e445fa4f97153cb82802c2f4017b457a6938fe9b3b9fe3078d05ad33e3093f9c7ab87218e6ef58d83b1ddb84e674ab143d4fd9e31e8df804a02a7b1f05e42acee83743c6dc248bdda1a0188f912b003dc2d904566b08d5eafb65d2e8a46a4211ffbfdbb3449b9881886a590d4c540b4b87e81ec3bbb47ed1de248aec9002045f977ade28e5b830691de65630f8014b45c51b49463148231191e6845bf4b90a559fccd681fd567366bf4b21c46a13b387472405e2139ea61386abb146adacacf46b08560fa2e1ede37c8fa94ae776d5d992057f99bfff6b0b4f7c71dd8ecbabd0fca0309f88209e10aae20cca6a176608e2995bed09b0ae20c7ddb78f265e6a9f9c2343afbd8c94ba5124d948fd1d94f5b1ba90485c607b162209a3305a8017a0a1dd9607e0407e66d0269a2824cf7be9fa46f73fea9141e1e19168d85b18ed2df193a1870ede6e52ed980f6fa64561e532a72972c68f1c028887ead7b0f03837062120b353caa23333c1c87811a6e60192d8ebe1e1509dd3432bef9c0ecf9eab14e4cbab525bf4be7d3b49a1c9316a23a72568821c7027c10496a3bd159cfd5c38d1e593688ae66565411f383996c95e778b2bbb378d8a169b12d549045201cb39a39437c3fe1522b2fb5b172d894fd72ce9d9512b7660fac2db0004da61c168e6336d17c93d953bbd54224c254ddef2d84ab328abce357505ffbb485fb716f72798a5607caaccca255def4cb91728e76f3c33f756de85a037fa0a876357ae42f7fca0b8296de3d4b6b111e72e205e4d57b427011ce9623789fe21e376a80d48e4c687a40b26890f6aaa299803f45279498606a1928e463e6af4a23e729b71874c6762aa0c57c858f79e4380ce197d5c983a2f5b34865ed65d6e44f5d17edb4ad5404e736568303135c758e7aadd9f5e33cf8006b7ce46cfdbfae1146fd2e2ea1260576bf0ea47b15c1762e0debf5de60d84caadb8a5632cea0dd69bd3c2d9bd70436011a22a482aa50d1d99b0099a38cd735abe2376eb4a2d83055b793e20eacc0e1e00567695a80f42dcbb1bdad1b635f91e9cc884eea328793ab79c200b83d6e08de12640ea5359c048345102a01c635c332565fb5cff6829ec3e0b376f6a044a0a2f3530449db82536a91bd0718a5a519fbd59abc752d35e4410b36493957a43c1fc6e691b50718cc4d96c3308fda10b7ce10ea1c83cf19491482e4815f73348f0cba9df07fdd4b38fa3c729cd4755a15f639a0ea3e6131e58e71a7254c3d0d1e40978be7899fbb04f9ce375d09c3e1647da4c66975cfae6a575f57e3f7040d32c74724a948485b506a8ae0df7f26c841714e212850ed329216bc1a4fa6e6b87e9cc8a762cf551b33e25c14f7f77d6bc5034455ab2081acef9bad23a2dfb7c5ba91a64481ec03c1ed5edd12be10617cba7c0359420bd6a6e2398ea5fe7fc75a6c4dce51a289619a336901c34ff34a240e3498d633559f2832907d7356edb4d4cee95c2d2fa08d67940dd123152bb79048e702737010e7e506fc8fd9c59bc764f38cdcd129f604ab5760a26a31b969b40596df37c84c11afeee0c7969cf06879affe6a8dd5fbf4ad4b666c9862a58338f09ed4ad20a2591f8f8ddc362c7c2ad26c172977a7b8089c01562f99390e021fc697b8224a968a9ec0e8762fb92cb7d692f15941f6917cf312d9e49917b0b6255dedf061fc4bbc7c73061c4119e1846c0c3a49559738aa2604893cbdc6986c432a9119266cc3325a1c061e1870c6dabc441dc217e18241e1cdbedbeafed532975fa42001d0ea73b784172c317509e5fc07c03237f12e292dd447ab29b4964f88d6ba0abfeb73e9b86ed0b06595b81af24b8504f15cece47d2c9fd56550a272731a827d66eba5ee559d502f0493da379a88c1009ee12101036025f1f8ff4ea8479887f070264457a04de618beedadab86884556bbd41f3483a53e5554df6111240e648080633084c2859f2b0a9325fc9df736790d76f6d7e26e0854d97d8726786634096e23ea9c3f0d36bb8055f95ddc9b4dae93449ad9504f89e018bb0b3ca427a1af4a103b1b19085d16e4bb5c33a3e2049a710f76d37391dd42715a4294c123e845d183e709a025651e3dbeacf7b4df9377547dfb605643d4f847eb6b4c71a041b464df2c5ffb0606bfc90a9dfdac31c71879eafaf6d2cbae145c14ee63bd055286d361e1afc18bca1bdff81cbc67f4aa1efde6c02589ca3f5ef6efea952d94ab1c7d5ac1ee29c150efe9cd21d70a3d4f97032259b7706a0e37ca419bb17e1aa423d363d053a7b5815b295bdd9f9c1c4e4b63cbb53100e7992c361df6b7cd0efff3cbb18598b3a15ce8d85e5a455fe1d534caceb2d33a901196d1b4651cd97793316d7fb3b98019bf31ca21ac3f84c84b55e99617c730b11348879f7b296272ee3cdefcbd57eb490b46459b4c9a182de0a4688a6de3ae099a7d5b570894d66675b4716bc74f96fc5e4e9b247fd72db394915d0ea8ab1781c705e5acbf3bfaaf1042c6e71b01e0e79969b936fb9664a0cf8882078c5b0e7de30b2d64dbd80f021e7cf48532dc6a44f7465654ec16fa0e42392cd5784cdedd811e8e26ebca2af0f8e7f451c85823cd4610d7ed0f4c932e627539b7ce086a4de979c7c3220e892081eda7a5a1d6e365b3aa61bf2cceda0caf3e73e489eb875cb6fc94c6b256981dfabc82a7f2c6fbfe574a7638c6b8d3f87cd28b2e6ffe41da0a2399dce3a7002d9779667e2afc144361ce9590a4e1b8edf16bf23517fd414268b5e817ff74a646421824feaddbc84d5f5451864ef22ac135e0792146ff0e15ce62fd3ec03090118ec502d3d4789b5d2e422a2d42cd4f8fd9bc18be07c496dabd6fb6a011d43c18feb98f714a807f84fcfcb288a9e1dac1ab6c32f47db46807f0e2f3ca51be3c5c7e54b2e904a09d215b096ebf6cc46851e5b26ca1c132ac8fcfa7de438508e3f2d15c2a15d0e438c2d2aeb40fef67c9b239d215af8b43d7934090eec6f81c072fae29939bab5ed870bf21ff45d248efdb4a3a75acdb64d8efb6c29f8c766cbe695aabb9d619faea3d4fccdda57d8dfb30143ee5cb227933a9cad9650ef2e994a05e6ffe56a59f94c5d4e04590f2f5621493217515b7099c028f8b891bfd5ea33a184b5bc21377b038cb52625d5bb212479019cb23f28c1338625ebadf6874cc15a58999fdc0f01c526fda6a7e143aaf466a39c32c492d9d3a51ddad4e42f96ab42498a989b9cd258fb40eaa4f31524239efbf1ce760649c625df022bb7dd82e1ac5c302f462676419fd9665ef9055a86fca10f117df6c922d51b1bec88516a91b9930d231dba92c0a0458df9f3d514a2a99e1c98cd96afc60f7badd39d9906f2679021dce4248f6d0c14bd25054a8540f6f69dc403e2bf1762a7a86eb63858d47398a757f8c473e277d0fe37e01ad834f3cf4ae0058ab17e683196688b6ce044cae5290ccf1efcef7d1fb5ece944512194b82ff3178868a2c12d662cd13168a45e40ffaf9812e12b93497e752316e63f50f959bef37ce0b14857c557d5f061a79768bb9f30e0ca7cbfb407309462abe648019da5ee3ee00c67858663779bdabb8c0352490461e495e510211465be7ff32d5268f7feddf771630ff179c618fa1241605807a98a5285489faaa05c6672f2f2975d71b4e9cf404187c9ff38b0f07affea46dcab4f8fb806f32b0b5acbde4872939189cc391b3f9ad5272b201ed39ccaa39cc9b1ab9ef238c618f3b3f2b183c0cbcddc8f980e5d18ab981824292aa170506df781dfbcb5fea469a5459addd31ab53671d4a5a31673f5d9a5a171908ca2a0f3399951a1c18c55f88de0f48d16b34747ee1dfdc0d0971f969442e59f002d53ce2a635dc20b55c6d5dd5ef244deab72790ed9a8319cd7c7b6eae5fa7db6f2169c65a5a5eeb3d898b0124a2a5ff27dcd25d40b8fc2e326c37cac6440f6f7b322e54d4e73c0df47ac323a5a9e2d331cdf08100e67bd76d2cce211be9ebbbffd8f11d131d6a72665839aa73d79f3d9f3ead9256aaa45a4f909b9c8e426796b3b1e07a1f096efdcab1f4016eb541b7b615a4e8c5878032564f471dc12bb63e8716134b521f4c01d0899df1de03628066f8e1c942c8fac33b599673eb6ef6b5cf59d7ca6cac8d71cdb2a63105e1516e38c851d058d04027e4d21b93188867129a2612262f7ed936e0ebb8867756006776fe5c64542527aad4bbd9a6cc3dd12fb158f316add96262f5a962fade42a2516f49da227b3733d06ce3077badf144e0e06425a7aaa49de11f1358e24bd81e3a69cc0bc0e7a0790937561a86e441d40e2981c7e62e1a4199a2b6ce6c14ba826d5292f93d87e4de9c283a5e67d3c0c7fe16dc1a8107e74b83ee87cab190c5dbe99fd7cff9970ef78688e2464698c3b959bde79c54deabfc9a242dd2877a3f5feaf58527d875ed01518d4d9cd36aa97a55fa6941ccebeed6126f49acf06ba6da3472b6495993cc18c2d3a61919609bd191e9a68c51e98aaa55d6c201ab8f64541ad49e7d10a26752a27517c10755c04d288f029040dcf6cbca9359c3fa8f3fbf6dee997d372d75faa4549c059fb0811c240de5bf1d8c33c9b8764b5e839787638a7593b740ed3325aa30ac54fc77f1c9e0dd358f3ab0d4de7bac0f840c8d28fee7efda735e3dd8e3539cc141bcb8e63cacf149e23eea8e004b88f7c5fd2aaae1cdaec878fb4f921aa811cdd47f19e6cf55ec7614f7239457e90edb08ef74c33bcb71ce668bb44e775b7b0d70a9d0f7b98a8dcb16986aae1ca42f16e58793ac300547af813c1c9df3284a8e6ccf918fb1ea55d06ba897d8780b02f49306e3dcf9f457955ef75ae8c2d529220d318e0714bb526644d16ce02cbc5905d8f9f3c8f428bf52b08a9ae2880c152ff29eecfff03ca0c767af123b418a67039591a8cfb9b5c8ed3f88e3afbd87475125555a7b711c5dac5d11bf00943dd738252d85c571e622a9e2193527eb1dbabf849658d3c35b7a9cd2997a16f1123ffa3803067535277df101e9ef5ad0f4a218dc889791da6d18ef8f0a22573cfbfc9c7a5909ebb66e88b13bae841e12da98b82d657213f020ecc609acf93d519c6c9b9e066ec1e945643bf3e144b5cc03b6a8a30f06f45c375cc851552e6128831b616f923497eb30dbdb4903dd5f45f016ec2f9f88bf5d5ea56f49f43a84063828d8134a5a3ed8f62b51e111852352d0b300bad8bd720527e50d1a9a35518c4e47c7a3a762d7f1069ecbe762c319e9d5073f82c8ec4c40d6e801e7a5fad9e596771ef5e0ab03d117a0254339ffd274590921e323c4c4e860df64c68276c2deb5de89a3ff75ff8b3cd32d9ea0eb5fe970249ce8a4e35ef08cd1ae308e0bcd6e077feb50ad25dc98f958e696e4079d2136b844cf17683b00d3b9f3b1bf431b00d744834c5c538545653d137ed680fc185d31fa8ca849a7384f9c1adbdb636250a644eaca110d9ed691dd993570347d856a22e0597b9bd6707d957509efcf2335f5b8b82a45749f9d8775782b21302e6d911953d70273087f4eabd92bf33d21f92123097fd734c75131ecfc3d8f031d51e6528da60007a0942680291adf7d8f0694df367292114c415427f0604b5d253232fca0e2e45c649fc180a7ec92a7cd3adb696eebc68b4bcf34db449e9cf8952e37655a786cc828396713cd70aa5a233766f48cd35b3c8f67dbefa9b4f40aeade10531a9a19cc8ac0ddd92ddcd62b05d046beacb94e25297e912b4f907d88d501e15fdb230797f746bd3bb02269ded0d541b2dac3a4d32893e1a6c60421ddbe2aa51252175ba25ae5c563ff356823f52912c278f26d0705ef2b9f851c6e720c595c3d9b196228d758341f7c0a1594ee48521b4a3607a402686d92779d6dc90429fc6201d01f188a2ededb48d136ee53fad9c40ffcf485a02f27c373518a4491c22f5d6324ba8f41ec970bf9b690f712775b1b975daff694e482296e37344f36152928c80411e046610af05c7a0bda80eabe7f80a0f44a0a033a451bdf44c99127b0eb1871944960fe3aa2bdb936ba12afcb9106f2ee0802a0d9e2ee3bab094dc45ff483936fde36afc476e0a03cca480b3d1e500719d9f1b72528b125a28c3a9708e04091813eed94143bde103fa54e3fb4d907e867802f5f0db52452e5ac40b90fb438f5c5f00b806a07655ae7f07925cbae72af1dc4f0eb57b19b0314a537de721be453208c030a7c170f49ed2c746cd6a726a5b9d5f155b06e5c8ffafba0344e2ecab21cfa61b02f92f24f75555c32f812ef212f4e244626886688967aebdc8174071a2dbe478e52eb3530d6e55167345a6b10d87e629104b24abac8564211dd4f0e6172c24a073af49706db82f5c23bb2f89bd632e2ceda543161dcb400acfd5c047f3a423cb8e9fa00d10a412bbe2fd99e8c1146a65ee4c409030fd5ecc56c3949c5e055b0efb3aedffc67ad8cd7124feb6504307ef536cee5d19603874c60674520833258c8b8dbe415c1668fe6b6c2770e86549a9e85012666d9d9af207c6432c14f194229504ca3e9ac2cc9f51079f1422da85599acb0f527948fba42214312f69a87b567dd9e26d8693daa49039b632cb959163b6da0c0ad83572b634da6b46ea98fad399f727ec2fd866a0c639c191e23451c2c1296472e51506604a84f54de7a644d49b58f816b9e1cb9b5200a21bad476a9450ff9fa7ddb9aadc72257b391beda2bcd88640154e1209aad4b842e047bb17cd763a8733de84e65096f91ff14dd3fc17b366fa003b28d9e8c82e12d86fd4282b247cdaad015ff96ec818af38cfdec932b5155177b8c2fac47395354678bb32a16ad3c2d433c9f061ca0f7cd442a81fd43fe0c54f4a926b2ad32caf844baebf3e902605f353789767ab9d9881251ec88d03e704ec6c3fe45be5dd67a9a5ae9594864cf7d8abc077fb91715aa5ff5520ba88bc3f9276caaedd9337c45203bb87f7fec351f02bf771b460caf6fe52c09d019ceb425912146e45e2898237a45418eeea0fde1894145f742df9c22122b14e45d5839ef8b8e2618bb98f69d72dee2e82a3c09cbdafe299573f0c6e8b48616c6617c4e23246a05e9e9fd0bc86d6aed8403352f1281bbb37b51badefb8c457a53c612190924eb80b3ef6c7431d891bb00f408544c867699e40e55dea15ea2bbf42abb4422f0f329aa9406e6eb37c75f2e365454920655eb5b03912c14b6e888b4f17597af6f553c0b8d15559106739c42e34a8c19e31a2c94838f608cc4c2a9f94d43ac397a22d9e42da4c983b47171caeb34668e8f58488a73d32cf7ed0ea949458884da146682017869892876b2375f93adc52dcf40e379f958f0a682ac9910f4f8a4854232e0fd17909ecec165ab57b4e155d12c30ba49ca1bb6195241996fffb3ea3497891b372ad0bad54c8c6b4289c145ff03cfdc938eb80a6984bf0c306159a53f92b4502b3386024208b33fbb3944cbc81a7b962b51e57825918369cbb1256b09224fde88a2e8a30fb5ef23ccfc5a669e552dde4ecaf9535c337b0f99f44fa2274b56636a63b70ff951f3228ca1faf27affb6d4dc2574b8fd398e7a3f052243f858f0e6bc0054ca30d22951ae8cfe5556da34adc149bac5c5b57d05bd92250a2ecdfefe9b4550e0fb5eca58995eb6533f16e3ca895366990f43658ed886f6b0b7c6f05d908fcc6f143b9926ee64170fd24378982d71e331af53346ebc56a23305d15fb165537673741f2ead9628ec20d5536fd84642f4ab07fbe2d930194629a744af65ea95af094592553cdbe663a2b4dffe9566a2f1fb52122993af6b38d20dfc1a1f545b47577bcda4e943bd57b2d036136e9ea2d7d7c429b863c73d0990843c7d387e36b551c59ef5b13640661a27b2847623d67a11689279045252f5ecc3b51292e34367d6091ca71a335eb21d801f9c05245517b89e1a532b9eca23346ec88b568c208f6fca27abf013b3871a1f96710a8d0f0a2de6fd9df14079fa5c72473d3153a6fba901a4cae606444025ebdcbff16277756c90f843d3436484f6ba8e817604479e41fd7726a62f2d4d9f7fb626cc1019c43c68c65ee5a297f3bf605987cc2bcd3cebea5aa99c86d065a66c02bf260a258958e87d3d903a7a9e145a59929f6d55e76f796d60549018bc7d6622d99663953a87e555357cb02ceb91255e0e1c92c200aa78bd616395e0bfe15db1023329dcd58e8a73745db29f33ba9859ce9c49682acfdc0e031a5277eab7e0b8cc16cedcfd1276573e085cc038a3a6eadd47b2a2c3fef8912754deaaf05c6b7cb4c7e9f76d43a35d845f59a85c0c85302173c87ff61b3b0930234bac1c73802f2c9d4a04208abdb6d7d223002ba8341fd03e5404ab696f1e4cf27f0d6b2aa890cd1811433cf3db3accaab7ed263eaa5b747a407947969d88679eed6e9d9e1ff11ce00a40cc8256bc69941d1a113d319b882f7f63b6a82965223fe58583375ce5058abe876e045a40c74df697b6f35bdb3d97c9a91603ed0692122bd6480ddd655beab604c7973127c81ac6b59427a98d3796c06dc4cd4f0c015b7d4ce0f9c4b1f45a3a3b3ff094ac15f2d1374a6a6bc70bc195a8b833ce033509daa35d4fbaf666c26626a80fd9dda2ee0790725597a613358ca33e51bb2b87f8aa7546547c6317403b05c347419105345aebbb557757a8a04835ba9205b5d5597c6310b3659a25162fdbd4bffc9b093b9316ec49739c734a2c755ca00db15cf10eadb44692c7a78838dd28d887f32798bc576cdbd224bc5d9029df0b8ab6fff007ec41bc6cf4c76e0147ee0bb0fe93f6ceb11243d14c7956f1ce0b87448532b8f6cc595631ff1f630c219bdb8bbcaa2dce92d2f9dfb2d2825fe36bde0d8b0b4e6f381c139e94d23ed9d7676668e7a20b173c6f31f89acb3c39b2e4603b709412c0e78b4ad1e67df6812f197a00ad5062820e8ad1575a308fb270e7fb07ee75d19e33529d40ffd12fda80989052ce763923e7ea9c26a314699dafe47fe44f1f83de13c23818fc24db9e082dfa9033272837d4e2f906f5d36454ed656ab19278b5a34b154d2048b72063ea5b2ad69addd26b0c44bc2f21af0756f6a0a8042898fac96a17bed2a5072e9968cfd1959d8164a3001e6bbcdd5465c208cfac2a5adb72cca786599809bce7f9cb1d12c568305ee934563811e3123379b8a94e029b20de99b579e24c9247d2ce914317b485ff1b6df23364159fad798a32e428ae1f2fe4434ca61a31bc562dbcdceab41e462535b3254dc856c2ec591d349f9c63e97c321244d85b20015f5bbbff34eb980068bf06c0d4d5e8ef5ba684e46ca2e00c7b981de277f0d3fe5341b0c5e3341496a104e87e9045b3f49cb8876488a337329f695d8bfb549307b215d789ed897b791f52dd4e8ebc1ffa351aefdf202d082c942a6a350cf1297b481d56432c01557508404ffd0f2b70621368ee6060242f345e3d8c1b7aebf24646cac9874590ff799c486601e1ef58d63e6c1e859f822d5731789108824105c8edac1083a02a389197ac4e99a672e6265abf53ac5ba594ba9e3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
