<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"441ca8980a8816125702bebd37680761f3e5064c814996cc57b876a1a9ca75a54c2bd13fbcc4960e1770f7dae43cdc3dfd639134b569364720685620024c0eb492863883d9312ace6baec42a92f688a59bf4b5c006a1cf8c6a0e714a31a5b1adc208badb4431cecaff9619c4311bd6977926dc546e1ebcedc198af29356ea6fe1183e28fe413a65dc78742649b34c1fbcceaaa0829656ce93c73f8cb9c281d7b730a19bfaef336c0555c8e38208df17709b3521ec2fc54ee6a6cf7e76e39b9d8ed8407c2deb2ad2a8abd7ee2a96cec2f98f5ac2e5ac162848acf796469a397de163565ea288d66c47662055b41f4a9c254fb352ca73b9efa3b0958f99c43b25603825ae6740638f56569ffa0e7407c17c893961d57396caba0c1ebc6a0f2d8a72303690bede16cdf744d248a277b360cdae48e8bdd41430babe835ff997f9de4cafa0410a10176336a2746ae4abb56da5a5cb2a755ea751957e1c925f289d63aa04373769b8bb049cdffe8abb41353461b777e5ce685bba2eea033be2d36ee0a6e3730ad326048cfd255f223914a0563e149f2cd981f161b1c3dadbbdbbf1a8bd94f6c2a6c9d83cadb6c4de423b0abf6f2e6fa3f2321e0ed774af0dc2a3fca8c184fea250b8d63d0cab039c0add3005ecf4a468a38f1ea14a2339c08eda2e900dd8e17b529c1d3520c7674481016422d62bb79807948f2e21a897da0bb09f52c1ad890c83949da9a597b218737ad06dd896cc190c551f0665f183958e1d4002156dd935569aba5da4b6f121e9c409bc55fc562e447b0bf6ada1895d8207ff5ac76efbad0c8ae0f18171224c11f4d9f903c6f3bbe0ac342b42f1191e4bbf1a3453962c86530c8805a32d1c65769cd9c23fae94597f898abb25e5d08197a2fecb9fff7330dee237b77ceddeb1221fa4ed9dff7ac4e7b97b034224fe9eb55bb18b3e55e937b2503517771068a4da11c11a0bb4c1577bb13082bd95700d3b02b3fb4740b70e51b0476491e947d3841ec5dcb374995c633c85e52825d8437e20171772d1d4b7a6ba489c717c6656b0d49a14d9860f651bab4fe3915f7548f181ad6312a79b07b23294d474dac6d85d151cd1bdd62cf79a3f02e0fcef78e2ad472ef0d5f993456577b0a2c12ec2e34c9e409703a95cb1b47a89a60bf4ac2406909409b91d5ecafb9180f8bf048e280c1d9324556331b1a8fb38135a9a1dee3f40d1a3a57aaa3686ea1777cacd6798577f04ce4d25583842bd61480aa5559348dda133a7073f83cac9aecc133a87aeae4a392ca034eec09b3af49bd7a720fe323c86bd51718595669691e140e8c5f6b77131307dc9e4a27cf033b1fc77d7fd2ab967a21a8c0b7b90913eed96b2b5415df3c49a8f9e44b2c788bfa3de1a7de5d6062f19561a17b05ea7f2bc93bd38cd1d294da8c75beae2e95c8b71f1834e3659f887d561c9e06aa2fcc0d79fee3abf8312e05e3c82f4e19530716981073daa5bcb705fa7b216899808af0bcf1e85e0670ae91465233d8d15259d24aca53f603ef87232fac2171bda719259145864056365dd72e8e3a041c35c281f3ed67bd2b2202b5f89dffcf237cf9570318e7fae1f3ae257e6de7df98aa81260d465ea280d378766f2b91bdc29d1dc0ef2ba449858f8522fc562704aba88c096ec6e175aba3a3559e670f95a1e07b03100a8beaa54e0ab73d59ca3e3be7280a925f5b3ed0ded4e297b5187a31d859be3985e5546df50bb90aa21bd3a6089fa4174c3a8d958f95903c30db56c1378d84da79034aa917984907a7a6781e912579a409466912deb8f302939c91357f544f2e63f8814498e12053f697101b4dfb245bf547e83b13c4ea34881b5d03e17460d3f98a020c396691c170bcd8ca5d12bba7a325a55b6b74dad7c41861caece71eea0879998891d10181290c782d1bd6f36412f76e5ad92d7d955a8c92191ade6bf35ee9b3b1bda7ce42c7942ce77b472eb36995f9932f046bee09f865c610cb6465f971599e5ee9213c3b826a96358cf77aaa3889fbb9ee30ce931c4e6aae59cb7bde2d5b8360a5207122b7c5898721f7699c58c3e8a06697202b30040f9e18ecd6a874d4847a52b23c26d5aa9847f63ff5e0e411fb2c7dc508e49c43b7d44686c322002eefa796ae4006668f1416fd41dd58aea6d3d5bff637ad2b549613c9b52559654b92ed9f6be8a82029a5b6eeefdf885357e6dba0e0ba2684baf5f42d3287a7f2cf67845803a1bf6de72c063fc4842882f39e05bea79081b1186f7e86d98cfcd662ca14a8513fa0fd04afc5d37da20fb4ec4910022e87e94c1cec57bb39b3c9f5f54b0a5b713f7b1fbb20725178bf1f1a9c1b6ff0aee516db03ed60217741da06efe9854a53424f9b2d9711c282f2b5616444c568abcc2d3a26e86b8c778d7cf492dd8d9b765880f5ed1a9a5b29b4e99f5a626028e80f14dc435624c4d4fed4c3ca05ed5a57b094ac9d2ed1ce21f74c85ad435746c3bd96289fea67f6b090341a826e42b3de93f53cf4e395b7d7eb93021ffed107f24134096fb4fe4feaf6a43b3dc7822b52dbd5fa366a9aee11516bf6345a29537b5435c8c73a2a4780e90db8e0fd33f14da5a62541aa2595f5e8499f6e56f7c0ce12e9a077d5c5cb57a1ffc92cba302a064f0961acf9dfee10621055def80670198d84f06c7701b02dec7bc97da69f84954f4b46cc3252424ed604500ad07a8c39f8b60806dd213824dc7411335547b9a0bc8ee0b178d15891b3bf66abea841fe713af9bdff829ff44efa01890cbd63ee57d9b685de0f948cae37abc75fcef578b205dc50d50b690fca1a765bbb0524a6b052d2c827652d81f630bc8c6b4ebcdf8342e01a5e492592d8275f926da663e4e70ee219f1c1458232ea6436729b666a2a6a7578459642cbb8265b54b4ffe670ee3f922c884d6631a3f15ecc99f880fc98ff9d6794b87d7833d5e8e3a4bd8a419d9099f50e3fe608e6159550529f31541884b0b388d142ba781ea9d818a80f50ae26aa9c02bb3bc8358a42e48ab5e618cbc11c905920784a2581ed17feb8b85cff81c30177b27e7ee075ecb4600336aaa9cdf381026f623db77f6539503dcd0448c06679022727a2a3c8ba758d868ddbb49bd24bf01c36065325aff0aa4839557e75c06d7fb202de4bc8cbde15da5346a22e2f8004f4d6ae9220407120202e2d568e04315ef8cc8d73afee5eb9bab57ac485395fccb4a0f4bc4ed6ca799be5bde4a9c76af88b6e5893c9788f1ff8d540c1454d1b0da27af64117966b317c38f58bb0d978c3ad0d8c38beed873af6537db754ca747362363b8b62ab730082e249f572ac41a9180674c313a930aedbdaa6d8a7fa69fb9fec18ab2cfce35c62c6b1c8e17daa1c5fa421027f583925b2676adc1b093137631c35370e3d335d7289ee8c08f5aa1e7dea172cebb8072d2797f7b0c1a4061159421e7951c5e8ec90306da09f686f28bf57d1209d75503e238640b3a2b162fdf1cbdfb655cbceae3e9ccda88c313c2d8fcf5ddad27edc602ea6425b1a8af5365009bcf9eb06c48579f148f010c58bc7e3323d12faf3f3563d6599a7dc469877f31df970bc3ba75487f649eea383e407118a4e9d5f650155c1f53e5c2d3d3d3ba2c901459a7a87565ac115786b30bec07d38c71b7f7157efa631c7eedebcdbe07d798411c99bde639e10d183691182db54b4b42b6a69f0a41fbffcd4bef37ace714c3ab2aed5c52109e33930a253ed87d364bfdc6c200904a1bb81b2bf32cc259d628c5a3fe9755878306bd2d8a1a72eaf9f7692748b52dcc8346f0c505022bcb669fdb0b4e08b98814098477d69941cb43ade52809513edce8ed64e6c67313f98cc0a199e956fd33ed191b820cd18e91cded0db4df125ce46d85f89a216f445e8e0857b4fb5fcd6c4e85a527d3f41f21dc283992d378b7d02f9d279fbb75d92b6df14406a726f06e28b90b41ab85b377eb22883da72a733419ad3f4485f303f6482a88f37b1388615a760f147c25fa21de52beac7d59be6f0f95717d85c74d8eb9264401d97b99fefacaabaa781ef17b7b6a665b1b72922730c6eeb0ec09634e15e35157124cb39ea1229f84a56bccdc466e4265fc3ee6b948933bb52fed843ca9030233734780c9301728dfccd5d0764caa31b495f226dc1e7a536e7e1c5761ce541b2c4ef502c7f04c0349ca98e4b40d85565547bb87d86d5695a69257b464e1ca39ed0f62ed340c40bb782df1d7f1778d909b93554335c0c99f317f46898f360d96ed526737cee423f027c6f585aa5aa739d38730f0dfe9b51f2d725d354b032e26cc716eb4349877a1ac2eac0c3fad5f70f07234433c5993bb017295b82dc9085d8d840964b55a36448572da1b09655511d936663427e67a0d6dd06f76f2f92f3d960559cdd7e56cbbff0ea26ecb24026fc7e1a6eae1c4e97957babe479b2eb261a7cd7baa40bf738508b3ce46d6e4aa6e044ca52e06884508eccce807837dbaae8a775653ed1c939d25c9be6d06717f453a9690bcdc559b09546db3dd1291ee7ec480824e441af3db7d54918d3952518749b264901399f1d0bf9c51a5aaeb40c2253c8fa2655748c7fbe2ff8c1673e45af50c8f67e303588580f4526e4d650332736805fcdfd0c855f547de6fbc00eab88fbf1579a215d68a242393ec21b8ee0d3bca709f7fc2a7a514a88e356bd11701855ebc36600b3bec6b694c66d0b699186d0e0e3b870dcdb4ae26cd9dd7309a99e79a495df215d8035180fbc0093b44ce4e40a2dd0dda17256690d65f6315267fef81445b4a0d3a18bebdedef7d5de7f13f3de0545a938e5d6949f969644bb20be0b7838c33324619da75adbb9c4a9c00c0a66cf85c5252028ef3ef65a893e3e1a5c2dd91dc3b27c5fafaf8ea9fce636887fb568047c0281e5dfc94576d3a623262c7f9038b3113b1d97941205aba488a90549e5d5dc9f9effe58c4a2eeda874802c9eaa670d2236139c281c57200dbf28ff3618ab01d419a7f3469d8ded7c56ec1fe6f21938eb7cd404bf0b1613edb60f082bca2dc0368df5b8cc4d6d8c1a417f882ed58eba06c857c57b67b7eca7ef5fd17c867712f4a649543c051e97d268085387eb71e7635a3e7c00df2f49cf1570f4392bc5fb6ea15f0544b0ab80928998b1077f17eb8e3e0bacd92ab97b8a1e214be0a454afe9a7787eb59268beb7e5efae7ea222229cbb80a589b5ec401c108391ded9030beeb8d9474ab79b959128391aac77a01165680f7c1944d21c994ca1c5e9a53134bfaf58dab75562e7ed1d496337a437bef63be53fcadc3e68a2e5f1c3377812b54080ac850d5261cf098159db14e42c0b5a52926c24af06d55287588c25beeb4f430b7f1df5adb624b60654da8df669695893d7c0671f7987f65ead1a412d7e82a75720b76876968a596ffd78deb086b01e6adbd29664643cc9b5762f728f803ec46efad43d226d904b86cdb9cef96201b4f86dd2989818c02413d87e793b7614f73f86efb1a5823054745051a5678fb0c684858e46c43fdf7fe2bc6464503b5ae162c643d52e1f1cd8b060a2cfa4a66d7c3906bd9b2de2482a168fc48c7b119a0b8efd1d8a5c3910d5db9ba11b691f7c29f17787479233b5fb943f7b5f4bcf2b7e13cfc18c66375b7747ade206fceef202e98cc0bbf3fb435e6a74db16f1532ad3dd79902147d1e4db95a7bd323826d99871a11b19018802eaea8198e9946c315e28a71e323f17092b7af35c2a29d699062b15e3b466692bb8ddb4a8152bcb761ad539f4c78b40100f6183bdf9f8dfea41e6c549f98e6ebfa8c6946cb9f494361fc4547a04f4f5676e0953c4ae857c3c9c45852793b291835db07fd876b9c913be1c18df44325abd5deee412f734f9b477d529aa30875ce953da047f3b471627beb0a73b8ed672010c12313efa40608895cabe538aed0f023f7dcad724e6fc017ccef78cab2278dddb465d103538ee0cd7b1d2e83ebcecd23aefd056fbb3f45830aea2e43615672bb68795da4fc697f04782463121023721784446890081eb7f29ca0a26bae58537231a417ee8c16c0ec2c067cc8e94e3fa75d5c17713f27ebb4f4db7b980a6e6837720b033368b0a6306eef102267fad05ba7d0180e9860773e2503b54ad77dbdd822f2e6b3b1a6f862a00b8cff430ff11b3ff88d60fce1f9af113d9ac9a2ba7c0598fce1e1adf3cd7b193cb423e388228f3e4dcefd689f77fd75a4460c52faedff84a66b7cc3b47076f7a81307e6bca418456009d5525ab243376ed0dedc827fb5043b6c40266d3893b77346b84a4465f472e728f95974f93110bc05d83ecd803be050836ff7df92d030a6c327b5ca25b4ac752373bc90e05794ef5f94ccf3aadb5bc98768fd7483e72b808a16aa0a59b0ee1f7af783745eb2e0525c003b78e3c60bb6caca6176dbb4c467d9cd51cc81c7058bd943c6e06a4cd36fbb261fb9c5cee5754f00f0506bcb5329a594c614214325ab25e1439160c7d0760e65418413cd08946e1248d51a0b9849108549be08edb7113f807a3cb6dbeea76ee0443f809ea943ff4340c40344f5ba13804da4e84ec95b8a68ae4e76998d62f736348cfa55951bec3d93475fb0910bee94f56c6445e40fc2d453845f87f40d61ea89f81bec27addb3f29c9bfcedb6842a63f0195d591aa2dde23f9816beba4a10cf42b96e9444bd63b436100bfa781e44fa43ab70367149ceb6eb8ec470db6349cfe53c90190c5534c8bd45381b609128b7ee6b9fc520c73a1182b6d40668b1aa7d2edbcb9fb3ad0d95b3c50077bc6157a0d5e46533d13c6f7c2e1b0bfdb4e67cdc0c6e57c3b8af0f71c65a6ad7e4c7557994ead9c921cf1986b6265f75f982966c9ef98781c491e106865da44996b8c06ba936e0a008fb46cbd56fec177aafdee0fa262fd8a359f09c739d35483cd502bce42e982cb0deefecc947504f50e48cfb6c4d98a30b1c4bb432b3bb82f2be5e6e40962cb1545aaed4c9e0facdbf4ca5de148b7c3d40efe868785b0500b942bee0a691e4f429f507e4d32619e13abfc040de4448f9c1788734f29bd98f93bbfba08d7391b07146e5223e44d78083bdf275bbe53eabd1bf808e9052ac37d7fd599222a7f62aec76473521f1681a63c08d51f451807f3f46f1841da60a4e23a7596c3a4ab1c2ec5a556f2f0ecde9dc79f9573e326b5bc25a00c4aa3afd6ae48ef5220266c09f01e70bd8299dfceca705058065b43508ebf5013971c9a2ebec61f340e5340842458ef0785ed4cba02958410e7a711f7facfa85a557102ed3172e44e0b477552c14a5427253202b7d7b0ad60af459992f7e6c3a4e5ff5e8d46e030cfc747a6ad21c43bbbff25da1e958f3dac14751949d9a08e1eccd2378fc1c462c37b08e0f201fd1bfa61a7a290e203a736861ccf798a22781aed361d373bd4e256192af56011280abdea04db2ecca0a76ea93f9e15984e3bc48586f11bd5361e2947d54b08f58fd0b97c0af2d3e528317dc0de8012334fdd08933dffc35c6bebb1e56cc2854d90d71897633a75eac49efb771baa62a78a0bf6a17c8bb208261533dfa4bbec98c0174967a643562be1328f199f505825c1452d00fa26e6c7f4861fbe0203c23a0a3dfec47ce1302c3f77a3484fa51693e91b9223e7df9fdd6e55a3df84032fd3618b01c63f8e87b01c5ec38b694ec999dc6e16064f556e1ca7d841687eb0a52f781fae80169692ea5869126ba0599d8b06e23fa0804df14a281533ce6dd013a334e12f1c72615264da0d1fbf3f396e766e1a828724a179acfbbafca809b89459478340810a8c7558f093357564bd2600cd8be23e8eea3548816d0a2155a226826881c59863f54474db7171da949e3922562f7b936195890ae70ec1433f718fbedd9301f998b92ada91ecfa9cf231cd7b27c8d1cba95f252b31ebab36b8802be5b3646dc9643245e454208cb10b7084397ecd37ca05eae37c8e4c94b91a6b41e71f8454fc159c521d6410c62ad7e9a1c36833023f5b7c713863c2153c24a764fc08de9382e3439d861cb1b0400dd3799e12887ab87c32fd5829804f218a1de1469eaafb1fedcf57eb0d226b1917f6d2137a0f7055d879bea152a87b0bb7c02fa2351189a36e2ace8550b9f9d7ded9bb16f3f0aea9549ba5da87e5fb42d4f77422f64256ff445b108c31263f4599d93b3c06afd88c629b630af45ac9bc3499c274ca3e2b2dc18123b0d9c65c2fd0796a29d457073f41ccfffdc3cdf119e18f8eb6d6f962a832eab57c28e62bdc64a3f1ff64579737721c11ca87252ff6be7562242a82a5018754294142ae87b3bffaa3701efdcadf64ce5e94e0a7b127de4ff27ad7d1642594d2d969e089afefdc78ed7b69d2b7c2dd53cdd8b8194e608ad0f496829d3a87d3269627311bbe1456fba0ae9259debe16208454a332da946a1408bf6b677d321af213825123f8b6c7e22e47fdbe8eacd9b1d9c7c8f9e9ab207267f096745d353f9837336c5a4554e0d281047e8bedbd8edd02835e2a505836ee76a88a56edda25bcaa836157bd148f599456e877da41705690dcd7ac7d30d5973abf3669e4aff2aa6275ea9db409bfacf35f78864eaa5322d8cfe4b67b8e2c654013213fbfb0e495172eabf653335903c1c082c8b989974e91d80e80dae858363fe8df691b581c8a805f6551817cfa26ab21c760c25fc40ba88b05d0a731dd54ac1fa610fac6b2c5727869a5807e515d00d0a75d3ae9e5be4dec3d028559aad2fc4286e37535cb87054103720378fcebce4f304235de7e60ded2c6c4334976b0bf93e3d8be7ddcf54c4e0f212cf7df6665fb98b5c10828107d55d163cc9332858634311a635b1ef7c7fe1becdc409ee4cd0f64e6e78f3fa90dd5f3701d7022c6843b4e0ccfb515f6df1b1e0df60e7068f042159c9f812abdafa881ba90c08777666110ab7949d606a0f7b6e0905597c8f638c846e19831b122877235f3c57b89e22a07f9f1104ff9fb3ce4abafdd3068d655cf0566130efeb343300f5950eb2607fcc059e61a7215b7b2ddba6737d344f1b9ac92b0b80ec8b2697211be4246f9b18a8ce1f5f306c1f3f577c3e6584335f9c2e7824d8fbaa11ad905920f1274e77bfc60b6d335f46c684aee690a23ee6d7524c14a8fdc1dd027c9f018f2eb54374e205f7f2d414b0dbaeddeb2433d7c4374fca353bb68e11fb1426bc25d487a05c662b4b59a1fd1f9b1c23cb3ffbeea85876cebc8f6107aced438a5a39fc1f8f9321a1dccfc24853a91da32e105566cd5e3b074518c1d03f9782e8f2632d2529c4084014114e9e53ee74ee369cecf6011e210d61522332b1fbc1d4157b21e55ea6b572730b268f0d550b20ffd5c813fd780f1192f1e51fe9878be2e00c7ef7c0cde181f0c83b5ea3254dc30b5bfbba08c1c4aaa3fa227afa7b90c369f7008a299be5ce6ac1b5afda15bd4fe887089abc79e806eee40778421e9a2545333459b14e21f9af63699768f0c72edb31ea8e40e5d64259f608a4e1f8bce11da50f4a398ef9d2e0e28a2c0c12063c2f1d64d739296b9d4ab3eb939ecb74df50b5a7552b80ac6be98e834aa5919637b254677e7d1a801a0203014dac0facf5d67e3a30f94c330f387a4b46e583fa4e3a5c7ec8ad2d548d89ba3817f65a6d40ebb8ad9d003b00b6f1ebda7978bc399b5e76e060ef0add94803f1a099614189fb811a90aff5963a65c6b6b79b585cb1f20323678dd6108966baf26988be9882b32ee6c373582011002430915eb56d7da67176d682760e605095bf910aee5a796ad4fce5146acc332e5dccf1b1e785314798291006850fe38e3750ce083d6a53c94b8cddc69e4487422183d0573ab925d1fa7771d99ff9e1bb5bf9f70269d147ebd12598b9d88e85e117532638dd9bb8dad75325fea7aba8e4f2c6fb7bac1c753075b39283cd4a7babfef13fd636812f1c319afaf94448a121278fc3a4d4b922d74d3e44e4e85705ef0ceb0b0fab71ffbe46920cafa31cbe91210ccc6585265f233251bea0050647f4eb7ece8900d84c0dacc5bd020972d6a6bfb29ea7c639ecc226621034d47338fadaeeca5acb882174e94ae57062014cdb45dbfbdd51ad8b1acce5420015bb24b04aeeccc2a09f4965b20d985eebdf395b3c583ce7b1a1140accb9b1d43bf16eed65552ad863419660537ae173196c34902d38d76c2b4b433bfc0115c074eca21be02525b5e283722c04d31bac0021d3518c6d5e6de44361662db7227540bd64fdf3a97d713235a2c475264f91a8fb59e767ce303115631fdc4a7ce5dc1fa3e1ac1772bdf4f223ddb21485ff828bb76d05b9eeb082a14e8bac8f9e0ce65b919905759c62e4e78732f4a0142e0519700fa7aefead5c3a59fdfd16275c2254f74f6a4c6a882d804f829059c2d6ff6b1c484759cdbb68e7271ab7ef6fe7e0f0fc226b831f312a0983b30c4785b9741e18b5ccf77fe81d5d3f1bebe063b1b9d3339f41c9ead4c7d5fadf76779507faf2f712b17af7d433ac3e795c7f9813974cc408d4a5314362182aeba6c499f817e0058319ccd1eba76f5aac1e92c02890b992f50bc3c51681ee18aedcc3f5c34d84ec91f3fa694936625ca57d2284218ba75cce6da215df3bffa12065002e2fc1e8086dd9b7c2c4518831464232d5c3b6057fcd471f7891a2c171b6a7f8a0b4d4a7561cf8c9948a68cc828464de4d89a16972c6428ca596467653699d4056c4943af9dfb231e8b04fb069fc1f198c0ab9d95855ce4aba69d18f90db3bea7e9612d2d92c292f72227f6d6158bfda3bb22f0ee1585679f586abc0a7890581a7781f4c55fabd9be5128647f441e5d4abbe4e592c80bac94afb41e188712ce2e8c8abea04b9c347a9974c5a4fd63f91d07ced7d1d093749da19a5b183a2fcfbf02b53777b91243d451fe5a665eb26778c2d3c91c1a5710f03782d941c08015ab2b31803e8882c3973fd3f470c95e285504df1423bdb6ba38289c3304e2f5f29dc6e9525f5d40da2641c62e31a4e075534d1ac0134139f70dc269c5cc590a899d56c93e447ab66d05b773f6345a6f6286807d86d52f62160131eae8476597a10da04a9a1de944a6022c41f9096bc0b73cffdb1edc9eff349cd459f48bb5461c84fb527af63fd6f724e9235e02ede3064da9afefe0cff496eff7c75e78d3a3ac2c25a17a36f4cd2d0eaca73f4f49433554e2e87934168063c1e08689debbfd34623c2c585ca5c539dd43733e8c4f9cada45363f3cc8453039d6ab0d89f8b9a367989c50427661ae280517a5c365ca9c54f9429d87727d2208d2565e8ef2311e5cdaeb6f75666d1f64a2d9cbff7188883608ef40efe46dcbb675595f04de8cb8384c4369eef991da41548664580b138d9170df3c570fa992a7b01efda0068a99f55da590a6fccd3e28c1bca3ce78def9cc88d9c20280f6ab80d4604d2c405f3c8d64cc0b1a9f6454a16e85e7ab133c2486fdb5fffd979076eeaad409badd98bd581d7aa4ee65e592252b13bbde1dbe01f6837b9af97a9cd9e79628fdb512072377cfc71a51db50528123576e453d504c730b30b0be8a7be242ff731a7166760faf335cd6fde2b744781954d1169c49a572353ebaf3caeb21f00715327c70042951dce3f9db485df25f66ea1bb39a742604dee4a6e4f6b21f576be6ff3593b362494822f9bcd18554acfee9902cfa6f1a47b45fb05de8f848430a5a544a056e8b285de0a4450937104f7655f26f38a169889e7b2da57a87175832a9fc92c330104f5a4b749450fc7f58f11bb8a05be94b3a9e5c1d366579a6b9ae7333deac816f6cd215138253194f54da3556b591881ee45d07cfbd6fedbedad65fde59a8806645e849c5a99034050d79db67541580237fe0fdac88d7c8fed5ff25bd9ca3890f2cb246784392abe8ef57a08c3edb6be9873f220834957d1598f64b584752107cf6750a7c25d0e74f88b2c60fc623320fe599d41f3fcf365c0e6d4fd3b8459a23d4c51d2c570af22afd4fb0fe2e3277806a1b894054fafefe851c7587e584cdfb20050019b3c703950d69b5e8dd49b6bc49e394190e3d81013c0d71e270a9645e60d52790257b6e61c88e9450904dbc8b126148386c06b216036b15aadf1674cbb3f356a0db7494525b30fe77e99c134136de67e52d6e1791b73b0178378d27d58620a6db88639cf80fe0972dfe4180433f06191512eed9c8f893bcad7a1f4f0d57cd4c0e2bae4633b79f0b7056de99b701edbe679ac33c92780ce8b462bfd5b0ade48db543609b2a09cec383a4dde8d5efa48f05833dd0c1dd1e51ec44ca938899e4e83f75399c6d123594441ab22e8bba76230a389ff47c6160ded5f404f6595a2e16e3a5570a485eb6cc521f09d2be018746c43ca86605b01cac0641ede7f30d3bcebda418e67497d197a5ea19658a07a6a3298c43b8ecaa75017176e7cdad9c9ee46358610c7a5f25909f130cf60846eebb1286b6d8f8a5b4e9a00427359ca292feff95efc379770d2d0d7620f6387b318b83eec40a0e5ff3e76ef61a234acf1a0b48ade487bf2bbf66b9d75d3c33aff87d27cd8df0c85f84bcc08014d5438670e8bb557b8bedd8ee94e9e53af58fbe1746a6fc07efa22f883f04957ce3292fca7d34dc659489f921de5cfee9e9d66ad7191498c22c3866891719184c8ae5a672eb051c8c55cbf2bb4b331d83ab1474cb4524dc9702c1468219daa690d867c50cc1bbcfd6f33a66a0577fdb3ebbcb6c4295b069495c1457ad99006526391cbd871c5d206ed39d24ac5f73e96b5897edd34c1f7ecaac92e831fe46d1a583b457123f83b74a41a4f3b56f1441a024d0e207f69824c4990290531514d9aedaaa13c1497b4c193f45a530a1a33be276b9e985e9b3a61882e49f2e193eb7e1d039e376b080ef6de05de2a31016c5aac7ebbf7af8708d7597929957a2949590918e9cff3ae528180157a8cea62849919097fa980684841275dc523399fd1a6832b1112304a4194823e9eeaf6b7dcec85c68c06a72c3c04e9ffd239a6ecc11bdaa6edcbc1201ffc79197ab511775fe640d0cd36bf177e17567badd0595ca57dc40aff70102d52d869320992afdbc0d0f6a5d289f42f09de001b46460a18a4b52c045dd81242bd7edb9f2d259cce245a8d7485aa339c3fb092bdd20259ab9de910ede3c646f1f3c93e4da5f75ac651f5e42f39f4a810f6b35713494123265a69415bc72bb2285452b6ae09799113647cd5e4824a0a3e86877481a6688bd92371f13e9322dede2483641804e17537ef2c0f841ab2c6aad2c69822f951837b808fcb8c84f57264f23ac5286cd4574a762a74d849eb1575f7b245abd31c7b2351c84b75a53d971097bd5587f7547244f2c132eb38985f87a870b941b3a46bd0f74246c93ce17377364a5a434532c41eb8ea327b847deb07839250fc710c91f60046fd5fab88c16aef10fef3cbe100974d0dc18b4cfa167ff2a01803bf2a831ed728d3140c9c5a08338c915e06f6e7ad5fd8b6b39233b845011bce798d3c767bf17772b411c4f0828a576182c9b700a82989c7de152d08d2750383a11349f4931a5cca3f5f77515dd1f506a307b825e891cc816bac19ba6701f3b8bc358d5bfd5e0f4935e3735c21a70ea84e5d1a9386f1dbb22231f6170371fa0f743ae338503ef4b7a0e6233c1b04456c14f5e9e842920e356524089089dc3febb0d824906a7c1a373c5b38af69dc7fe1765e10e880ecd9db4ab006d02c84adcc29b71ed2b0f1f67b28a5a7d4583ce4dde60e230486d7dce9f62215178c31d447b0f8ad117583e09ef932b7bb413dbdfd920eebdc5851afdc26ac53b4c58767a53e912d10511d3b0f4504f503688c9f1f939459eaac90b07581abc5b382eab5c646911e30751ef0469a63c127f05115fde9b55a26f21c4e55383bfab94eefe798b4e026177dbc7da4ca9b5d0806631067ecef0a233b236ad1528ed6ca13e176119ef8eaaf51b81da26a3616c88b9db530579bbd2c6f1af244ac72fe531ff62fa3b0529dab2891da14db3702344733a36125c04c6e75406437893d9169a652a18ea7f0fbb1a9dd5021b61f23980cc88cd6ce133e2d5c070759b7e283b1098749477d8e79224d7ac1a9ce4f644f1bd9c839ba62d5340ec167c324e09c7710d360d06e42e6d093bb274baee54f9ed0d18d36a20badfaddc345ec6f4631703016bbf62ccc84941b69d03d27fcd2528dcef3c8bd825ab7eb0cd6986836ab6cff55b86b553ab25d05cc91ca3b25dcb4529216ade10c0a6ac360c71d9241de3ef069857bf4f5cf44c989e0ce4d2f4c2147db4b0b00244599823bed59f6f6d64958d8d4b66cac20e89d59f0e1f996fa1013650a3a6ec318ba961795ea8975994fc6642c08e6e33afb7e4c14f959eed340bf43c58b319493a747fc977c2d0391962f8bca344f7362a5fd79cfbfc7cacd103079f01f9b6222bfad005be218bbe3a811d955916789dba7df1bba0d0e503ba90f4aa5034de4c170efefeaede679e81eab2ce9b22e5a2d91cfea631758a7d640ba6a6aa2cffb5ef7e56201614a264a9fcda2136eb3635ab5f50021513c984c475ad944345a18f42b68b7e98907bdb5ceb21e0fff80a27178d50cf7a6dabad6dfa86b16d6ec23fde705bdfd6a7ad181ffa3fe8f21e736984940ad70fc694a63e803f0853fe2c6bda643704751b7fa7c94eaa0ebf1842c5ff938b9e72dfc60491b1f0eb0d945e3f521a4a4cb659fec4f56b390aabcf6a15e2ef886c5a228dab9bc42594e0a3606e1c8424c82d22afe61843784e971cf1ab3b5099515874d5be2150b8d6a3518bca3dc24c0f841b1c6cb461a423d61ff4af66d20026ba89e5e23063fb0d5a03651b81fcefc5165b14412fed3c05e6cf345026e9ae72d02bcecb4b1aa79cd341cdde07ad9c51dadda37382e7056f1f4a50cdb20712b31929edc929ea230e2de28c29eb2ffb154b2f5f45dd073d3a288de3956dfb90ce8dc100dbc133ac4d4e42a93bec3173f33536554722cb35113766890d61a8e8ebf25e115f461aa02793403c004d64559892532b0d6648f6eab814c1a00341a72222ce5a282696241daa25650587f9965498bf53eab1092366dd1bbfcd53c2d5747748033b34de278afcf075dc5eba8895cef90e6af3c037c5176aaba22a15e02707ec295410840b1a3eb42d991baf31fff056989128590bd618da9091fce5dfeea687455d82cd57b7a8dd1dc31375720d18fe34149bd43e36adfe061206d4da16d0789fe7248ee8ccba9163182b24cda44d5be5d3fe6c8a49a2a82d028fa331db400c0ac1209774e5cc843c82d9efb8b1a1c1069457da4f95e7c3baa0be9276db8802b2d4f1ad79b9a59a06dcce61f93c800db7e07730787af97aee6fd54c905ec4100240f219f20627748c48d12828eaad310aa0c48a066842b102cf48ec4a8c4e90809f34241d9a7788d0df41d60d718975830dfba32982e28d98c42fb2838c1a409d952fe9ebd3aeb1eba890b3efb39d680f4afec2f5faeba4be7696b011ddb99e1be4c816969e489080e6b994c5194134cf497d62b7db4bd1592dcff052271d9bf94d169ccb15db6630f30c1860b482b119c8a231ddafe09e20e8edc7a8e07b4524340e92aa90f8a167c5f6ab68992a01c86a91ce78b0a35000f333cf5291f41014c4a29907eee8dfd9a8bfccc8cfb211f307257d6623299083ba134d1f4035675266ae40880f9d37ef7ce1ad1a3179ba4b45407a2b2432d918f7caf465e27cfc9efdecf50ca4ae8cf490151666f438ba400d41fd5caaa691bbc78e3362f8cd5e11d97f26384296b2bc3b002fca07626a44f2dd4d70a084aadb5ca4464fa9dd187679c7d2d7e297d026916f99524419e06d6c242f8f627609210ac9f770bcc596c7d3d52732b32e647c09ca02bd7e8058f3b0d7fe59679b1fc32c195f0fee1085b5393cd0f314bcecd8826f2a8cf0193d3caa90340c7456889032e52577f98586c82f7060b92d016f7448865c52ebcf34e7b6926d64c581113a57e2251f1fce6c694e8fe6f5e5a5e7356b943f66a27ba3ed0f2e7aa339cb3f2261ff3384ff44b00b217c99ae5613a5cc7aa010153e9fb8d712a0e7237192039eb3b00fdaa709984b3f25f715b466594ee0f4b903a055f2d3d4eb383dff0f2347cfbc620043a6a80ac6f77918bd9fe5803fa7bd2a873644ac107280cea8b9c6c0372a54e3100f341980fe68eda0f793c1d5fb9ca97cd970685f5c2ce44d862b28d09825d98ed8ce9cbceaf9b0c9b5852b3c933255e9ec8069cb5b9bb9e60e905ffd1fe4ddf3928673fb8ee07b1b882a5eab4d1ecab381be231a13c1f0d159107c79b109dad574ed58074833641b709646f112db1c42194f1a262789a72b5c533c1728b248038f70494edd7e9c1514081db8fbe1d7f529b8cdcb330536117a42192850d84cefb3ff5add47cef5bd8897d9ba44b39f09d18b54716fdcb372dd3bc372fd8f9a0ce449a42c401e923a2a41a6646a8093f9ef601bbf675dee53887ee3600d694a0d43916b9749c65df33a606ace05b52c0e9d64c88dca8d62a5ed0dddb3c2b6b413a5fce0c4c63355a2dc0b2a75af2e72bac16d3a5f7d217cd7a720aa0c6f46dbbaf82f163649f866310b5bab469fa309435c48a748f45b4c297fbe7be0f8ee9b7a64ee99b4e799b2d8749e566f222dc454c43fbd620563f158c4375870d706d9bd7467b04e5837965006c886430176065f4cebc9c9e4f8fd19928e80a64748966e711dc2ad50ab5930d1377116a3fcb828812f30b5b57ddaa3bdc53a6a0ea1ec556cccc0dd250b207e92b81519dc852b1aa7bc27210ee633ba8bb3f5b3e2722d72b380f1203dc4e9b6a9a9e7e41dddf6fb30e9d7b6bacee90042c8a51a64d779e3abced4c5b164ecc68a52ddfdb3c340f7ae55205ad76d8bf4ac6bab9e2330a77d651a3fb189b64c29ef498d30b3d3618de0f0ed96934ec630b06986bdf28aeff18e3dc38b554e4ca349547455fb07e253c90e06ef9db9e5c8387f197b43370e4486e398b883fcd975c9750bbc894e63940c23f8c44ed67236ed9451ecaa890cd6dadb6f2f22b43d8008e83131b2b4f2f51419a2353048064071073ab0c96a98c0540535300acf60af0cc4a9eb4db695c1598b5ebcb61ef340f71abe561416c0a05304652a71be1faec90610b63818f7cf311d043d0683544c035447fae22f76ee3c51fcbccc372e2af0c8ed3e92cc2c7ed7b5781939150320193249a348fb2d280594a2534815a3885ffe83b510a8f0953c7da343ef0bb6e9d5315e79ce3cc52939a49e10adcc028d9d61031349891e4aa22cef56c1546619e200ce2f0d6522f1077aceea92789914851a5e071149236c52494d40d2654e7744ee7f27be0efb14efead14e2c7894ee9ab84bea257296aa2fd43f12bebf53937497ed84ff21e3c1b4fffad320f09c282aa9f604999bf679ba64676188a3a435c2e1c710e71e3f74c37bb5e10c776cc726139394c7a557190f42e3f2e007207099caf7b3f097171ced918f02e23336df226e0aec887886d3eefafbcc539dbfb898cfc25a6e3a8b7dfbb544897ffdcf85484372b6d87ee4876aa35efc61f818608da44e1665dc93887b29cece7c1198e7ea9b4d62c3bdef5c9921db9cfd8247f5a46ca9283fd476fa87f09641915bbddb84c6e9a0c9e118c2a45ad615dd27381779027df5928f67006717266b9de37a03fb88b4026ec4f98e65c86077fd4654d52c2185df6d12fd05fac283c60066fc6cce80d62262fea327b4eeda8a24711b83cb75508df6ff74cc0ce98e150a34c047d369544493655199d66ffe0ec5b54d95e4d654526766c7313a196d5a760422fa7c8ed01b5fb062d68772fd53671325b1a1e028dd204feeb5e11485ab5fe2d007aad4545841b28bab2892f09db5e6b545fc1698164cc74f2de63de0b8e7966062a8c0e710995ccb5a70510c9d039f6a85322f04fdd9ac5f40fd82341887599c2450aed94cc8a4c8b781e0acc9ec847deb06138adf597f75de37ce95210c878ae92121d0bb5cf7fd912dd9e977","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
