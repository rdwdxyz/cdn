<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e088af36b6390d834e65f15b65fe0714db7453ad5e6c0a08d728ba5a1e8444e17820cf966394954cc98ef853b1deabe921be953e2e67cfc81c6ddbf35d1f2e73d5b6775d526d603c1e10175e8efb1ba3dbcc2bbde55f524107fa84c839a989cfa7306d511c28690c1cbcf1a2dbab2aa2cccdc5956be46572c106892919e3940198bba6ad85a4b57da96bbab8604a4506963ec29a5517ac3e3ad8e6ab5b797f35871e559346841bcf5268d1c3514643e8c8ec5f452911e2829ffba25b5e51ab74d3a5dd4f5d1efb905c5857e6d4b7922a7e595c43b0dca527c0907876e0bd7c460c7099fa6ad4dc87f7a573fdacda1b27d1c1c30e768ae55fb632b6cd74337c5221b45c36a94013cbde31c64eb90106598de0d4fb58604dd838117679b38421c0a54517fde1a19921931fc1fcf0cf64ade79fd2f7f711cb045997c1e51506f5facde95bc4ad8137a4c4430a8e7cec0b3e51c0da3ee44bdfe43123c40d0d9829ff502e5dc1713e0a341f9de3e73c1143cad8a62a8cc16f3b57e01488af421fcf982c971e4f55487eea828087820e11f495fa33c4d5219c0af7c5bc6d17b5c0b75fbe798ee71f320aaf090cac88a50157e703784d2eab478ef69eaf3baf74c3e20731a384c6d03192b73158627ddd5e1c39cd3e5b877b39680f0c466b71c471350f3e955166e4183476cf76abb42c2c75bee3f76bb7a33067b5e6f6d0749d8a5b6faeda9f576c13dcec3ae5086bff50b72c297c076133a00f4d6efbb794252eba3fe07a6a640f565b129edb24dd914995a36d43e5dd8dacccf8c255810cef016fc60cf38e6a640bb5ec3ac5c1265ae8aab6c0ba2e14d0ded45a3c567819fbca6d14e2969b1a24bea16479af017c792f35790c414c9c5291c05568c58191d9395509629fc5f9f681f6041d03912360b242a216da94fcf290fdd444659269d1b729eba1c78eff210bb3e696a73681b9022e20c4322f4b09965df8068d62b1ca29db2997322dd2850238c2f5ade59aae02c8784e54151a65bf3d5ec892d0571dce8da1d67f57836ac52c044a6103ae930bfb50627d30ea9874eaa485f31011d64b867da5251cefe502c0fe65cecc520213b56191a3d91c880f7ad4cb4f32f20e28eb46967e564d8260de94fcad8d323bc6b5a92347a63ef5fd0183b0fb9e98e6c4209f19a2d4f003f9fe68904aa6f2eaba84d04de1cf5998eff436c8c7306d12e50e8c9d272b96008e78b04fbe978215efd7cba1d068e59c65534cfbbbd0d9d0c1c230ca4c11edbc3da0b9fe8b0f5d1f87a96670210bcba011cde738eb2615670f48fb9f004e596511bf745bde0dfaedf189fe280b91166a8c8c5533e57572d1a79611a8b7c6454aee36e56e219bdf8f37f7f126565e0f4d0c028dd0a7b0d4875754f39812f96dd72d28cd14cd34158c8d63b58e13287ca0c7d661233bf9c5c85d4e578e5921efb9570e06164dccf3d6ab213af009522abcc24d11bc60500656d48c01a99c131ed7d55659f035e90a590859c69a64f6d80849c978eb0dec0c2b0dade78e8133851bb992f3b23d5b3b7e6eea74c55bd97cef382af6ca053967767f0f21c3011758bdcadf6adf8148b3fac3eabb66998a810b4ad961b19db5af15f7e8d2e859465a8b213f3533d3abed87a124a812aaf58419927c3e5a31c42a2dc9f7c1fa797347351900d168638be60746c91496ed78b3b80a71268f15451957905ddef883e27cd7506f73f9fcba1443e718b9fc2c0a080466669addda5a7b9b541814e7aa5fabfc2a9e8838c1a6f7a56194c407d235cc1c7a7cb71552b205679c3503c054aace94c7db5994cff5b8939560f91cbb1e1f0e1ae9f35b733929e24bb3f2bcbd98105afbc0154dedf11c3108eac88256627f4ad20a28b2fff149f9d2f75b939fe578167920dde498c7432076d79a75e11489395e8213a00e6813609fcfc55d9d5d5183c851214c9632c61cd4e1e39769bdb79e19fbb3d4819c1e1cd398e1c6c4fa46d8bf1447b59d67bc7ab1b89d09fecd255fe05d08d908d853c755304dd85457bb8ffa7ef2d004463b64edf0450166806142ca02e7b5bf59da4d7fe5875f33a2fa6c9a5cb44aec1cd8357cc6c18a12f6971ff61953d88a203bc98f2393bf0878d3ad0a3e9efdf7105bc08f8ff523c817c9da4e0fc056c8ebffdf9e28b7c9c38371ae27b6ca39e58831cb04d0b0630e07246b82133955618ca3ce8c50edd490b4a3f971ce794c60305f7b9073695d705f5dbf83973ad57ee6fb91134fc805383e513e86bd2d21e8cbd8b8106efcda5b1d87d4263c8eb141be55dac094ae7b0fde105bec83e7d49e74868ab494613fe928fa2ff665c0e9caff788591ad8076627e6e96917f1d610dff5eb6330f1ec022f6b83a2348a8f724d31d714cab719ecde82723a9335904d0d65050c56a1be787d394804ffc11857904f8c7ddf05f29f05376f3b54be331fc9176d15a91f495dfb6b3f5a484d82442a10630c0deb2d0ad8a0807da322548c5ae2c5eca603663a17c5c0954fa27b7018809c065ba6fbed4a31e81bcd0ab8d359d30abc263124368346e624299b4a785865ab2aa940d3cdbba21d4999844edb79320f12165be027b347521326e504a3c0f40d4844b37d6f4f10b9cec07b6d2cda0c2f6f1f2e00e70edbda49eaf293c7eb87e13e5b28bdfd6f795ef0cf8a6baec16c59c483e25361f586905e237d2372155e5aee9e4086d664a18f3c763cad6aae0a087b02f9f50e5d140722958d2ef06f396dc2d1781a7756d43ab163eaf2b7e638df0d9398fb2bbe7dd325d181d5ccd5fddc1c25587b90d38bae4ef2c870c5cb0549ceb2f1670157217c98d6c2d1570df82cb04e66ea2da6cec4bb76c87f6094cce1f1d1fe4949bc4f843292f606bf01c5102086c5768ae980f3bf7e4f9261a9fd0af9dae99b0002e0bbecd82632175fa50569a638f5a111e3e010d8f2236f63d9e5d91f7a3499629c98db3238e6c18cfed377f21a753e9577aef7141353275d5116d4b430ec9506c02dd9803a1933b645630215e36ee13454098f67bda64649a59c3996cffeaee9f027e05282c2b2e16234317a54dd82c9db4e938c52e1dfdd68560f07668cf8d9b6f2ac7bfae954d8296da1f4a12a30ae072d9a67f47ab92fbd98952b01d72375c609f95b7f59dab53e8604f8a95b849a3e939a4bba1a50250d0f6d9ed427beb509216ad6a99f1b6ee86c706898a3cf66209273a3a6f7bc1d4fce73d6ac27cd5c430c84746430a67fc7cabbccb83c85eaf91ab07b9653243b59340fa6d14611ba1815b5bbee21131d71c5ba378be25c716d7df0663ea4fbc48bfbffe60c5824382d77543024d046ab6361122c0357343eb202af145b887a1066b3ec937f26af9d36086dcc9ef0bce3ac989eb20a03c592911c88b331eaf092f2bc323cebc23be0db8ebd0712eb6cfd78f888080ac88f14f2add7cf21b126d0b1968c267fb2b9f87a5184bd62f03c11f5e30b3fb24dcf5c3e4db5910dc9eb7e1ca5fe201806c7ddb98e32ce5f388033799a88f42bb083f22b0989a7a0043adddefdd1941752df490c62f0a297f138a6ca9360eddc2607fe3567652fc48d23b3a4b20e3caf8e078ffa34b36702495fbae1e7970f8c0daf43323709d56158df15f2e1e934326c85e47b656c81711c69d8aa0df60c5aec78912b9fc6be6208e4beaca4003c16a6c7558138b00e79dbc0ffebad70a38bc4e6af0d86f7979a9aaa014345a5c0b76b1ea0d5883f82e4a6ea130bfcbec39f818335246faa9a47678e75a43addae8778b65b01120257a1cfbcc890928b55431262637dfc9d583f41f2983bf0cb94d21e66c15ef0da78891cc7eafd0d8d97dda6d062eb5dda0aafcbcb21e7e2ca41044b30c58143a46f503839d47c3538a65deecc50ec3867947f3484b5716b369b7ed0e326b264f5088149248137975c3bb27cbadec7136951e0d02482759434839a8d2142a8473e489391c59894583c1507084168b49267db16975cf03e7702de7e11b88ba1cd1de9ad1ad08fc99f7bad5e1e59ba98405987783cf0f7df8ec53a9ef6e8410891ec32ac038e12126345bf2edff143c2bdc4b24c0d17301e5dee234a89a1db8a109a75628663e26bc2b9510579efb5ed451ba2b2fca3d053a3468998d8f388484d3b4e7264b36996af965e95d4ff6362d6af31b1318c5e37a57d2f7faba50110d934091b2f09d4ca837da0debca77b2750b584091054a750822f10df4cd8690d5dcc01845c6998109ee05787f60954edacc01f94d482f7d75b2ea2a4062196a80f199d7f11d39860a926b83c9149356ed28936810812c45a1129d48611fe5130fd98fc7f22918c2db589552fc2576b6383a1c578c632013a763a6820673dec1fc65276669f113653ebdf0f3a404bbdaa28356c8891c8e8d89f7ac4a7a7601231ad5321a4c128d4e31c76065deaf74cc7028f6391b3a99320789c84d65a5ad5c405c1a95544055a562c0b133cf7a3af12e3164f0a38cd8ecbc7fa1252a7090fba8896505dec3e18150f42d17ab319df246504ca697a59e3844556b8d8bf24679de7d9785b0c5f95e210a63a1a51247fa770c308276891fbad777bc3eb20b809271e8c94baab950596bebdcb65c73cf73dcbc950be51e5207e4ae77ce3c575de1c692fcefe71c4444d985a3ed1d14176a657bbbe16d3d9c9884c23e27dbee07f1521dcd78da7d3fb4d770aee7cf805834fe94d5edd68786cf5c109b4acb936e4263deeb89ddef6b0eaa1d05d7fafe09d66bdaaaecb60f981a7095ca95d645896492adf7edcc779f7c2897d2e3ac88ec37560710b79b1de33aaaa2c23a8eddc2e977050a51a681b4916ca969498c16e2427959f7de741c3b47cf769f0e3006ea4d26900d95d242b77a4f9dc3bf6a608787d789b07b325d51be0797a6fa9ff22a832da5fa05d19a3d838c4ebe292afb53bf12936f412d421dac6f3c0d4ca8a4fb45876a9f0bf8c948c210cd92c92de2ec8b41ed9e6622d1e6c572392789d457b2358450f338a1a55c71ceb541a71afc7169563e0608b45d82a2e556089392e7b4da61b839f3f5068afdc3f209595e2fce8b2d05753bbff1dbfda7d7dddb9f743cdb6eeae9bcaea6ced0ef6ad9346c9096a02f0355a93fe4a7f940174a496e13445bf8ad7ff360ef9479a21c105f920ec0ae583ef9527aa2501db27646ba645cafb6630a789f28e5eecb307a76bfbb2fb0d2fd8bcdca81dfeaf8a6cfbba261dfc3aa3b947bcebb2e3f702ea841211d76601480684ff5d59ea00498c568f0e572fbc03c24042290f97a74d2a6a9ac0e44a638e5e87a2315bcdbf52aeeb34119bb2acd2dca3e5d3039b71053e313ac652ebbf9186d4f48358ff57ad59a7decf6ebf69fb2befe904db9d7b3165e8057679bb379afb27ddaad44c34e3eac119d346b926d7dc669092774cfcf94b81e019097b9b03ffca37121ab45239e96212eac91d06b8df3798d94aee015a639eb3198bd679a467334eb287fbd6a2720b270763c0c98eb7dd78451225f3f62fb83f910f1aa1f86cd10775b6e6e586d446af6c2be14b7f8dcd63833bdb25da10e731da2b23c3775474175eab836e4a4b8aed4d3720b6618e444c90a69260497845cef316aaaaee6ab4fea6d1b430d0f50939343cd213bac4cd753c1b9c19c8bea4c9d23d1aaa912cbe12e55842c50b7cbc3099187b2bac63952ff357c2bf1184b1ef32e92a856ee74087cbe3ef9e66173dbaff2f8f77adae64f67b7c18999e7989320f65aa2f079fa9cd2d551a7a5302d463378d9936272bb969c92fcc576e6e283fdf507503c53ef4d25431b16b7b982c94c324c0fdd5f77f9e31204f00a5e081bd85ec18b6ed07b6bcea183680ccc16ed64e2273afdeaf56a04c2eb446a84738232bfbcfb1f02a4a428055fe155e5b0234a6533b0efb6afea8b3a9117c0ae66e8b892e283fd347b0a77f7e7d301e1106b2b2eef7587ba5d4a3dac0c708d89051d1cd5001e70cb5c127df4f3f19b162ad5462db0b9d9ceacd25086069f0bec0cf8ef54fa542d6cee1a21b930519cf3a7a6a980820f5702ce7ccca0f70aa892605c4fff6a45e7214ad8b61b321284f89a2fddd8f09fdcdb08e3bc31fc2a371097c792056d64dad1e97fdf93fdd537679565bbd856846ef5fe9fe9897bea76e0e0ac4d9e9b3f17bfd69a7a94623c842c4c68322f6b24543662575609ac0f28edd4e61a0d99d7610ac7264d3dfd839b2566062ecd3f729ab0255e1f192255eda6a8e65616e5ec9ec13e198618aed5311eea95af60282513b64afa5a210aa7ac5a5568db2254f1f398011e91f2d07154653d1278917939c6cc47390d199b7427a540d9389486e269b8f7d3643fa12923022757600ab67840cd2a3488eed64e3bd946668a27886c6c9f834dbc2acadab20cf1ac40ad70f0c03a3f78386ae525d8b8b4e119a79c2e6d6a701a1fa0871abca3f16bb2774b69d56f5e1641693e55c47cd6013ee1a707aaeb2373f1cc9c14f4ad0368b6809db5cf6583240d2cb7afdb4b2b367049aec4cd06d6ec6852011a6be5cbbba6529e28a9feca0f48aeaa5a5a599d8a3b3b255e1fe187d05fdac435e47027d2c175a7bd2d2385188666e27394d020c61ecc9e60217185bd514b60eac4c22b31216758cf38407ef3ff2349b723ad52057903db687c74dd70ce1db282d6dc6c636d111488936af8a7c3dab50b9515edb4d9f4623188a577e070ce5c99c7f5e67ee49c66db6b4fe248d0827e79ede14a66c28e2c69feb84ae0f213dd2323b0100c8a87230e937bde1c51768fe284c1995e181669557d1e9a073e54287e417297443ade86d8a723fd40e4995ea55652a501ef64a82dc8dc29ca0fcd2c4d5768431bbf8696857985b14e6b02d4573037a90503c101f4b5f00c6766f87ed42740b8c06a78b7c7c8853ecc67111c6de4e2cf42c8ead6b0b2fc95d63705b3f09c0bf1a6ec89af94606bef65f96b8a439156d6281341783efd8a6296205c2ff25beb434c8da800e97363b3f301f01d184d249c88dd6498973bba181c32f412564c4c93ca4d544ada0c9973f3db4dde950bd70a3a9d3f837c640a24b6b91c8d9206bd97a6106573e5c02dbe68298d11572804a677e1279c42d7696693850aea451f3151338a56d71f5c947a91f00b19ac99a8b4fa56b754035dcf8085c729ae8f2be5a9d890b51731b65aacca2af2fb4807768bab4b509abca8d74e49895dfc007209c2c2c23923e44331d1ffdee74e3c8f010356b86a68e2fcad6928ae487f5cc11852eef7ff024a422ee655d7cb67cb88916242ebd9d6959dd68aef8f0e95f5cf5f0a85507dcc135df8540382491957f42bbfa73f848bd4ac566d914281d06021213d12bece34fb8f8640a739c98f7b017cc2b020970097f43e2882968fd6f3db7208361a71704c0c4631ab2e018ffc01baf1d84076a9af28d5c6cab630f7ad2ffb44b5eeb1fe694223a5e661adfdad7ce6d153cee15fd141b2391e5b029731975245be3c1723a7eb07d5fd948232c15236af2dc2c9a261c12e9e88b0847b07e4c9aafd00eae4a7b7a896a4874926a2d4a98534e5da70d73af43e2d7f70553a92833a18b4e96db55d5c3ce2e0381a1db00091f5704760898f8678b00744273076c3e276e801e3b25ba781d833e719815003737a995feed0e103c5d2d31df554c9bcb832f5d13cf1cc4d85478a7ff7d35d613f09ebafcd42e9fc8000dabbe4e2ce53ec20c20585b5574e7dde80079949bb57dfd04b2281f4f85df81f580afb0b5f06e897a30042c95f2948892032559d4592aa5bb579aa343bcd1aa3e9345f2d29ba92bf9121b3dfab59bb948b68137821d0a062a7ba0b911442e58581551eaa44236ac18f18b309698aa9ee23c07249c1b95cf755e16b3cc374684198632e7f7fad19d64664250fdfce6e3a34f65ea39681097347ac603c6c242a114cdb7e8841a9e2c3409d925af56849e04dce30817fdc042c1c189fc9068a2508ebdcc669730f33a2f380e417097e5e443209ec7249ffa3aefe573aeffb2395826044218be0ec80e6aec3c4e009890a506aacaf52581379f04adde32be9a0caa1d92ecf64735618422c5b6a8e9aa4c06bd8e8059c65647a35cb57802b60f99fa5057141a8b81a7d7b0d8e26088c7cdf75a095af9140cecff67613cc09fe1ea80bec6316b3b9b006aff9078bd250a6f603397c140a168244b51843047a46d7890f64be64027d01a20d78af09c74fcec494f54d68637284d2201a560890a6011bf4e68bd38a6a7e6928e5c8ca8ce1661c5356346e6108ae74053ef7c62c893276cee1b46c7a14ab0dc164b9af41e094d1f476fd4fdb87398d7184dfaa93c9b748bb8ce53228f946983d4563a8690cc2b36d91513a4d23a618b0e230e29a2bdc85455ef6eb619816086445384d6421896e6327c57ec5d0fc6328ed7f483bf070393b023141735aa0ffc31932a86dae1e83c682bb9778fbec5c57b61b70f3612445d0fbbebd83e96d70c34c44e420ebdf1f79d0be7fc44516361837be06999684f74134e43eb5a49b04e1c7f8a5a56021f99d75762e959771266d2ac3f8dba06cdf677a28a2afee3b0128eda5eda88875c365ffdd5277c2c4fc5a2c64295eca00576dd5f6ec7ef9f65d487686e19329a1030e94cd7e0632701a0f784091b1310e0fffb3b2b847e75b634c3205b4c0bdf2f92cd55f666faf4a34f7e5b74857e18be22ebdfbd1e391decb352e1348255fb2d4cbbffe019691096805f42cd696398d3cd1d22100eed854a48d03cff98f0db0d9acf49e660dde40b0b3ec33e56104d20afe016c1c15250e2474b96276f81b0b4ed1b743802c7f6e1167e53172f4ae90a63ad134ee9514f6a66ff5a49078301ab896c523a025e5376e789dfcd9f9e619e6626f30247192e187889f3a655006832d01e97d85b0ef9252e91ec02a2cbd689287b17a46c954f36652e8f600432be0cf7f60d0b4ae11bf55dbcf1f886c5a101bb9a7bf7195c45a7530182c44588971a956342fe5390419a40a49118b079054b526460bb70f87bd5113375175514033c085f5bf15122e02ba662f140cd4f9c133ca750bed745ba85fe02ae94c8cf6bf64c0d2e5316ee2662677ea29d79e7f1f88bc934b300ba4909c337e047001a638fb29c6dc46094fc21a8e55113ee02b668d1e3a5b7576e5a6ff66eda7b47a7eb08d483ff275988d6961fd2b3b8f8e9f6fd4df7316bc334fee9d7a993c2a98694d88a2f01a834c12c91c9b2380f2d6aecda7bbc8a55cda9a988031d5b0ce3baf14b55d7db85ef8b884828500f221785468b6519e8141b008e634a7e528337367349c8a97c06bc404ce49660a786ad188e9d7a5aaabe95098aa866cf6c4b515b4f3581a9fa73590a654250eee37d770540e495a738489d9f07606b022433082d755b5cc98b603129a71954c2f4ef646a2ab61c66a9e33b1cb3c96e6c4dd8798745961762132b388b80445f766b1fc6acf870f7ee72cb8133a7ba09f05512cef52eb93b699755804f551d60c029d03e3a87d06833ae3f05fa4bc7ed42c24757ec30a2cec22aa507983726dda26d6f9ec51177b5161a9db0cce3c1e18c0e115a54ae1b3e666280bf3797809e314f1e4abbf48e7bd88ca4a8542be1bf09f322bb5722544351da0ed74c2785a695a7f4e3c38aef007ced054dcec900df8f33834dea6e7eae6e6ab2dbb7d900748d4eb45ad781059102bf0ed02d5024139e4acb748f851a1202a5cb631b7cf4d6af8710e892a65c552de78a3d63d0cfef7205f657a87cb2a7f1bda6ffc225be2083d5625bc83b1e30c3602a491b922a623aa342db48a00cb330195709fcdc2a283494cf5a3a8e4d457fd0af2322e6ab7deab177e99bf8bd0f3d4452059090cd53b5c3c365ba6d113a5ba73532cb1020a3c34b66db707b44c9682e74708abe585f55592573f5a95bb863aad4f5c4bf4381c0e99afabb91d7df7cf656919a0153978a1971edc2431c2fea640edc9a7f7023d70c13ae312aa3790eaca2bdd0101409104fee03e22e92e43f4a33bd1d265de39c3275997d0cf6a885ca0ffe1fcec32af4983b0eda00771bbc59ed3f0d598d2fe08c8045d95271e787fba5787167f1efd92203687fdfbe4319a739a99ddf38ca19a9a6c4e8da0614d298ba282b9241af4d0939ca3e8a2ed5c60a70d5d7b2ba8085a844130acd6c683c8bb21db218ad00f5f5d1f775a09be103badbdf8d8126482aee23efebf9eb326e3fa1c5a3f2524fbb0befce9d82f08569a7a5545e1d66e69c32eb625574c992468def3d67e6d25ab48a2ad3d3fa8598c72e0145e32d61c38164172e193ebfa87ba4f721ecd2dd29179a11b2e66f564affa3c176225dc0acbdfb94ed9b0633f80a298ebb10f7697f355e57734e596e01cdcd2fad0c0dfb81593462e00dd61380294d5b3be6cdc5a7efd06f98e96aad068048b7a84fde4a7b5f4a8b4d321d9dabdf2d04a3b6babc53a17673b016f5d6c044bb70b71b11945605820096b05ea683e6f1cfab4e4f872cb84485a6d61ef99ed29a2d42b759b438d44280977b066c6effdd6e17874e11633db912f8c8d969e545b00ebe615eb2071f9cca4298fa4656365f8f979a9eb2e318b07884e297e477148917bf652f1dd9ebbd0f9d1b27c58221df398431a4b440fb22f06bbae51acca4dec5a9c3b885e06fb03fc4cee848691425fc4cde4eb17210b4597cf1c7b703302319e1cc3e23b51ea820ab49c4c229dab713b1864c8847b3c9e656a0137f07aa1eadc1a7c0052d29ae17d5a43ced9d464948e055d991748307efcedb632867494d17cc1bb68b59983f799372db3dc273fd5530e5a3c50908bae16f2ed27c7e2a719ba633484783e5a4b72f8453dc961eab6a15a024a54501c14ab7b4c53abd82c0101f7259b10bfbdba7480e655038cb8aa230ca525e79a2156a8d08a2d27ac211c111b9fdcf73b997d5cb4933dd3acf8bd0d0e85e79d936277060681a55d3f78126938c183cc8eef25e9561bc82a31b00163dca11581ab70b5101073d1b14632f2ac6ae8fa1e89b044fdd24b9e0c678465bb0a0ea1355d7e34b45b726648fdbd59f8406c52efd9bf92321cb33d9e6f141ab006449b76368a1e5439576a44a7ab268d7fa4356fab251732687832b27ea439e317defb660d87db0fb29fff83cf88da108115cc5878ecff7bce877d60a74201d43490608ca20119ac2cb0a4a09695aadd76c0ec9ce7fac56ea802f873a9e04a72461da7ab8e4dfc959d54fc674b75a913297a68f78306570eba04c60af74b9ac922c9626c6ab88bbe64947db83ea6c1ff246fb922381efbedf825ea6b40d07dc6d5a9df3906b029ccc5b4c51ada05638c89b4a5ffa6183e9191bd8e1b347a2cb83f2c17597ccf6baedde86e3c278feb52959c128830dab0d2887e99035178326f31d0e1d3f107414fa1b14ddb9946d3069479ec5b74ebc7c77fda4bfcbca6021f3bcb7bb62c3e92398dd3652491b2cba816ab60ad71fa5c28611363579b5a87890b504440d09e045120de9da0c0f5bb05b3a48d3565e8ce58afa53bce48c7f6a3268cb04664bee8a29e6ec8d530ffd9ad6ba2c19033a56bafbe19c0bcf837676a7bde9397540ad30a0cd36ec0302130125b1d452271d1c76a0a2e511a21786ac8b3ef29b3ede9415df3b2e4361d992f67afc3d12606cbf7443e20775cc282abb8c8b55bf70266fe04e451beca0d64c273f65f86b4f68109bd412547dbad9a7f1b5dd26a14bd08e0efabec790425b90896167c14b8a63c9c9f7a6aeeb7a4c15e5de0833562650d177b48d37d57782371aa39e181da3c4962f2381649081bcb9c3f57d33b60161196f39d328a64df93666d11d180b531fc576538ed218b94e7b78a3ba60d5415bdc783241922ce2b16d19bda83f31f2f5e8a067dc7288401f01fe88ef0a7ad0850cde5ad91515cf3433427048a3dd6c22c047c61f93ef413a9f982874c18ab72450bc1e2f31f04be228ce44ed0d7a547859fca70efec2a8f5f11d8678a877146a2dc97fc7392409f7dbdb93b7532e478ca5cb6f9aa4ddd1b11cba50ef763ca3c069bdc9e7c7f0b154304a3ccd1ac4b6cbe72627f31baf400e170de0af3fde642036697d20370b67bd8d2b94f942ce7535b0f40f3db0f1b6bf248550b77a97f199f8584ad1bf46b0cc07adf54096d032e1eed439fbcb040c4ea501bfc6e05e384705f90cd52e31d34df6edbe93989e3f64872f3e694baace3757007809096731eb59fbb55604e049a0ec548bb510fc53832032f649d9dfbee3d9e39897b88b6bc84b2cce2196503ed25e9a4bf3b509ea1e8e0bc1e56a595a20dac3e72a2d58c6a5dfc6c2715002055736a7eef061edc16f8d02eeef9a9e252f63fae33b426abafc02d6e33f12a0bc51917f09d4b4f3da0380cb35591b9321433a275bb6f309f4ca1bbde520811e517f53f4fa1c17f035941107e5820fb21b8cf162aa37b8a689b078ed3578c9e839b9d465d81a7451195d091af3d01da14f1638b028955affea3edf1a51cf64cc01f782e88ee99a58738ad48d83b3a325a78c2e3e318f44cdc013660cc71ac2f8bead8ed57604fc5232ab3e017a18428179d0b9a60c9fb780eb4ef7bba9e9ec08c53b9dc5d1e3ca857969ca778273439feb79be5232d210f3dbe6dd0dc75d1d371afbeab8ed72697efcd111e0212fe694887f7a94632186fdbf228a2032b0f780ca4374034f54032b40982c4eda7cd692f9a66847e5763338ca4565c859005a27670bba9a7ff9ea13bf0018850c717030f71cba0ed0ad28c3423d64f82c4a9268abecc44e6298da5a15619edad87092c14cc253fbde6a5666fba062b5121c0e0b8a30bc89f867a16639f6e1f38262667d0ba98adfa5492b435de5ad0bae43025082a1be5e9824fd3d1e7f353835d09dec5ffd65134f15bc121f965e1b0dd2da70835b41ccf336fb061494b306ec512ab8cf6f1e4c9d05d379c3cfc0aca5e937e8457d6b729b701ffbe55f15f804b90468cf0e487f0d35435a2cbfb17ad90ea3ee93965cf057791fd098faa3813e40ddee6a08caee9d318030c5a63aa43e7aa6ecc6a44be2f5bfd76151f498d684794f7819a5a5ab46acdf65194324ca80bd64cae869fc57f739fa31084754f734f8e65dec1867f1b608cf9746a302835d75afd21fea56983c5d5166ecbc20a8a7f8824dba006af144624443808e2bb41bfdae0bd8b24c8ca171a4dfedfa7ed34e232a28bbacf5046a37b9ccb277aeebbb97803e026eebb26fd21c229bb0f17bed3f1191ec5fa885b6036bb9707af722e6c6d7bdcf86672343066b66bc150231c5aa3699793d97b02a4aec5fb3037b7e060aa9c4672be41fc605f4c1285236c1e294ea683bfb9491a1a45eee87f7eb06b80b38558813cf14fa35cec49b52b7db27cdf8164a9f456d562cf950c07ba4c741e90524070d7a39870f476f850cb85084443f60aaeb9deccbb8cd690ddeb6b0df9ace930f2653eefdcdd9f729dd09bd4b66c755a2c39e0fcf9bc9f2779e735fc4d73186e0befc903f38a4c24c9ffa1f98248e0c076d87f59b32246abb8da7a23320cb5809c3c6234248f590501510109ef4b7328c000a5e94e13bbd48b2a316acf3eb81d9a40f191621def99ea6e567300e03a7d1d8684561fa60e0e277e0300defc629611ea31c7ffffbfc413d6e57ce13ac809cba216912ad5416dc0e09792a93a16d342fd19e55ceccfd09d859d3a5ac5e6d2b883aa21fa7c0a303cea20fd438c28027d611758c6833d4959a1108e56913e303ed1773c9975c78b6efd122a99b975ffb974ab700d755e89632322f253474e235fa0f225cad1916d5b6bc319b19bdf424b5075a131d83d0081d29e34b8608edf1db349740c333fdc659b329c9d1d42c1c19237b2eaf93bda4b474e670c39981ced581c4a340a9ceeb20072089fceef0fe01b46f9052345775312575401050b2e7bb6e034520d31a0e36cfac26174a8a269d1a823fdf6db58b49b00c79a6cf297633015f04fc8a0f88c68d818a63fa2679104f4366bc4ed5c83bcdc0cc8b4328c988e791c17153d396b0b327beabf87a65d53b165de14982b9294bd69b17a836977a422083899456adca20083ec909d5f6b83e013dc226ee1c76851d15f5ff473bb270b0b8250656838524e137590fa4f4d1bcbe0e5349e4cbecdf6b7011516f8f19ee6c0912d9122c258c2734c7034b4b883a0ee501877a4d1ac9d9b63357ce72f0b6c05bd2013169a9e4bd8f976c1219387a05ef9f75834ebbc204b1abc75a377721f0ca83fbaf27c10ee7c88011f30b3d23ad7369e810e65728903229dfa0f18f9494253673489d27f75641c8d52b59663244e7a8f2ee42a30df434e74c3bdd6f87dd11992933a680ad548471df97abd7b35780f029b9618df170f2d86b30c73bbe564110e931e154244b3f8de7364f2e27a4da0ecdda8e3e2898bac624c189ffc1fcf344a1eca4e59f22b755c68f9b98bd6d41be869bddc9d7c9f03e26f1a3e7c9ef34d2b3b272a1ee11ad54f29d91658fdbb17f76d3310af3daa083537ca2a0c28cfc533cb5b99b79e5b66ff2f523e537237c6ab7e49f3e52abbf28e0fb421a4243c8f1e72770719685563b7f4f65b621a4eae76111e4b67045b3dbd43431545e732e9127ef5734c842432d8d0a2694eded0f2e240c214623afe4d515399eb391f310a7a1caa4cd3378d072f38d0001fc184da389e3554817964b190014296a5bd154162eebc9a5b0481867185ac9ce02e0b20d9de16b4ee7858bc77ad1bcf103886da2536c7d0d3f6cce3c0f529fd00acb05f6da6958e5db728c961a7910a819203a5114c79df0d159822c21d6211628143d5819027fa7fc322330f69165bf68b65064e3a0ff22efc812ed23cada54470ae18db55b978c6f8c410d8c81c11c0175b28df34bcb35caa537a29c78473a658833fddb187f3186233303a1293023df8ddc06179a1c9f9ec5ddc3eb851fef6660550cb0e394f3867856a794da8d967e28d2ff9d3067d9ca9527519b16236b245c298dd6c38ea13f75c53d174b3087d7ec6d01ef8323a54df997db79f832390196de9b14704eb3ae78afa982d4f3d4c45aa527fbb818eada4014f3a72c7bc3ed917ae969f1c102ea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
