<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"197053cdaf983fe4e422176fa52fc5e3de79dc5094be2025c9dcd8dec3c1f3d4be50deac1c4502e41c452c9c009e94e89846628ff182355e3f2dd5d7cbb72db061489daad56ba6cb2283be61c5b9eb6142ec452ef71403e5f61e7c737cc19d68c4311e97987d8514df6c6857097a334e1baee86c004bd0bf25f25cdb62d1e9d5d404b5b0f3a0d5038f5458f464b319b9df771415e10ca6be7e3bada83813467103e75ad7ddcecfc7fd7c4a27a181baff5444d5b42f0819f1091a76f9e92611f4f2d0774e147b4c2d961c1b5d1e50a34e01587f1463ae210dd803ec5ac41b0bd11d2c41262b04984dab38ec0eeff7ef4ebd353bb7f7862f602ce0d3ade5e44eed4b05a5e779455a57eb6cc09d7d8f0e98bd8ba0250421efa1a3706a38908a43be28d5c2c43e46a87c2bdfe016d3dea48e287e98af6fa443452fa15ec835781efd958339a9750c3414c65e38f6d82ee460166db28e0b70bc559587201b9981e1df7ada9a9f9c3101bc0485d60dc759a660f866b5a5e79fc877f5e616c00cfe83a5fa33a3e2330807aac76acfa89a9ccb3988f2e6047ae5b28863d4065e1ec7cc3600792fa242341e041afff4b26d0fc802ec8188949bc16a9236d5a9c2d0acefcab1edb68a640b2a1fce51489d36d5a738308803d3a0b48aeb43ae76a13b133c0b98b4edfc91e938bdd89ccd26906010b0e4c2d6ed409c78e687f38edcaf67363dc344cc133edce6dd54d43143d9164803999f80ada574e6238d2233d3b2e3aef4e4eed581a37cdd6c81a075f5e55a7fcc5826c962ff7e1ae30ba0b495a5c6acd6750f1ee269ea9ada385f1a9a14dbbb7aa0d1562130add7cb50bb7718d93b0e23e800eff09ae10aacb1483ddd21215f0de9c73c45811722abddfc710fc668bd76812b239a6a5f80fb5fbe5dc2ba214d70875c0a1235e76450f0544c9bd8f48fb025df1d43f28d9d606eef8f3fa45b4175b5150d0d2901c1146e480b3c49572038b4ed95fafb63f8e2ed15cd15ed54f93fe21aa114aeedd59d1926bf0de165393bb6fb71cb18f2aa5b1c6cb9c606073a4df0ac7fe8f2c1d87c597f3a61c541a84430eb59368ddf03a87642edc21bf8e41720d087cfef392a3a888b5a7f25a4f4d9e72635d7ba654f509dc9f764c3df3e41f7683dda36b9ed25e09ef90239e3c5590c399d3638b70ed1d818889dcf949b5bad26c160f7fdf5262e370af240043c89338205a1048bcee013eb3c3cd9bd3297839566f4cecb3074d79c595c02cb8fe5812b751e5cd80ca4009f2eb925210b7cca35390a2bc154af8e97e9f3c278b8cd19b0363c4e68d44a02e5b05a23793f86b5e110c589f479e51e841432e8ad92c9faf0721d803130c14357470531f8130e548d675ff98570c111aac5c600961e4492bc155d81d07abd8cf0e57cc7838cd3b43bb00cb1b50b6d56ed98185ff4ab96d853cad3d7f81e98d118e2be308ffb1400ec80d31215bfa85f1e209cc5a6ec41dab72b52308bf330a238dcf955ad509f75e5327f251b7bd6d60b896d0f20e6f2a6c2944d652d6149a47700ec03790e4e21718f462abd43adc9d3722af03de0feb3f55dc9283ae42690b3ea903c2193dd812ae9c578275af85921471a2409567919417135560ed45024a95e78d856ab16984fdfe1ee5856b65c3d6e6f91c97af3de3f5a378bb0ad8c68df665f8f03e10fb3e8663355389293c34afe0ea9ef4114eb617fea94f7e56b651e54adf364c6bad063b45af4c11274ea11cc9f47b8b2c84136543bdd0d3bf29cab36118d66c5068b7e37c131c55e63ce0301b9893fb34a8a7592b53ef906dfa35a72619a268c5a00517662d9fe33daf489df88e95b28f3d95fdfb789fa4693ddea93f784c781d985199878fdad4ac387ad021f55b113227ab9237e9707f8f5ed8f5fbff5c1ee9478d6a31076a7b6256b725fc133b770c9d5ff138f80305d13346670b8aa7eda6f0a57b33f4e4134f66992f42119b30e859ecf1f675411bbdd69f35832c88f234e1bafd9144d3bdb57153eb3f0f9e835749b1c60185994a0d1505e949da0f737ecd6720509b795713f07b80384a3c9f6d916530b6bde5ed2b01f5e8b533c7f98826c16b16dccef3ea640918a58eb11df80dd4bfc6162bf5246196c34779e821d46a23b079f18464266b4e222c607acb72548ed73867eab153ac6f20a21cad59bddf5b60d1e0c515741de96d5fb7b1308e7ae96ac7753c9558883a4fd3f1d0f8d5ba10b9799d6cc5d28255c2688a25911e4337963da9f879c64f3f62c5cf448b2f10e448ac133f7ec3893f69355b3f3ea4c48e2b11b6fd2f82a84383e115823cf631c94c4e22c6710b92f01259114fce5ea35c13d7bae750fb31f51f85ab63aecf89065b201dafd24bb93d4ceb179074bcf4b10d8a82c5c881901acb24337b36a6f44ecb9e9617f266860f052d8173fc763b4108e1c164fac3ad11716cea745df612527ebaf6dbfd0b64ab72b04e1144a13fcd837f85b86d7f28d6ed65b070a54fe7cd8b5144c66a9890ec5b7a532be3f676d5bd77cc4ca3c590e9fc85483a06709d5a36b92d900b02e0ccf946737b1b55c1e43e1c9ce443d5a9cc3dd8caa181c030ad3edfec32040ab65b232106668f1e260ff721244a50800475c13d14d1d1367182b7c3408ab39b52d4e97272d4e125f7a52a83f983fd97ba16668a41f1a2d5b4036a00973dbebd9aab64561ecdc549aa126625549ff71617a6000b2ebbf6d7fb35039a577b7b902f17ae9b73f1eb2238710fd2fbdbcdbd397ad344d55377ad0fa560a93e4aeecae8a321267a325a5da262e2e974918618355b18c5a39cee8541f8a82c48e6eb5b4407a3c61fd2b97a8d4c36fdb2728697b9e82068a3c8f81cf916e5620ef610f9beff80982d8ef980413b2ff1ca70cc564f827d3008d38367627c04de26c8fdb928a72f83bc6c7963867c5c1413d3b40f629480f52f82fff907f60ad457edc378bc0dfc8a3fa5a076ec4a5264b39ee1f8f4390a12e9a86d1087631ad7352482d30bad5f9f6dd17e1d501c0a4241823f8196fdbb228102a3a647ee086b22aa512df114f6f1267e44e949bf5cd524924e7ad9d41b7cbc29a2a3b4d0d48bd18b511a19bc608ab938edecba7d280cb1f9d2718418e2133a8f85978a4645414bf6ec3fda177fcb859f0e8878015d526571b167496209e1575d7845487c93b68e7d36ace2ffea751d7c4fb8148f7d89657f4935e0d524ee2234e592c45674eea9f699683c0ad4fd3a8bd18b39fc014df6733d57e3013c3797f5dfc9dc07ceed2469f3def8f3c560a8f382faf4e04312fdc94217cbfe181845f66dda60270504741bd34b8ed84938aa89bf0efb7ad3404dfc65f633a586cfc56f717a7824cb0f9f5516adbbb31e649b1fc73a3a3c62d6122f8caa53109f0cfed86b30a28c4402a139c07ed6a93fec9ee27b98baf92dcabf986edeea3e4273d98ea6bd1fa3a6267a33355580be184afb622f7a921b90aadc049f16474136625ffade7b4463d110e4a2d122feae87af6f507ff67b303d88cd1f8627f70a412f0c7b3fef31b22303447f0ad64033cb29df9f58dc9162ffa68a57f73b8b1e36d3b21afc322a3197f32062274ea9179de8962a42665d1d408b82ac053f7699d66d6080e428fda263c29d440446c9336403a551071ffe373dd063183c0250c820e1d884d29efcd044e4b4625438ac99c90e8c6c7165ce33cf5ed73cbcce347d58d17db643c7125595dbbb02b353bf642abb7bed07bd416625b979f5338447378b6ba1b708ec5c17bd3e56cec6e59f94406fb229dd9d839f45dda7806e606f8ef3a68cea3ddff2f418dff6b40df399603bcaf301a8df46def932b5f30fd817396d367c70c89e81a289c4e67d6b652bb99be0b136998a1b09e104a15c635f58845745aea16f635b5ae7ca651abe34c6d48917b433110995a09f7261d81484299b1d3053c2be6391633f1f69b3a382ce17ff445b6db7cd208c8b99210166605e72d2117174ccb4955b8fff126d737c8267543aaf630e5113bf9143e521695373870b75708bfcbec6708f37e37ad62ab964951e3a5805349c9d179c822780123840f2a9dd491156258ab230c036fd617bac0cd5ba2dc7033ef94e8b163a6ff58dc3645627d63994f710352cba8988a3994ba3ec17489e186302cecd11f9679213907343d7d45615bdac514cdc651ef7db233555a3eb3fe9ca18a5792d8bf0b5513d075bac0f679c48e4d4274af3dfc2cef21bc18ae57af96c3dd6494b17fd0f38265884a3f53adc88c8a6b0401781cc0214f3554eeba0042ebf9429865fc06bee5df8509f0bb20b39644daf78eb529b3fb1d570786f2684b0abba1fdc376bb5687b7f7a05f1809c6364a13d42c26b4487347fa7c48ed773b1dfa1d1d13d9f094611d3e64a22d8abae81f0ba4882feef42dc4b459c110099488f332ff5bd7089cff7e020652ea3306f890ca4c6a01ad32de44344770ad9df68c081a21951da8251339cada292a5e83531fc64f6184c14bef99434e77d3b65b055afbe866c0e7e8e793253e4e9a6ce4232f3d0c7601de0e826549a5e9b8458b5ea50f8cb83da127340e42f54461422ad342a89b9eac1e1f624e1da096d158409a868c2173e82d1652a04a19ea48bf1200e75d6dc1abdba055bd2660222dc6fe0589c8dd3cce7dc9b617494b631f9b6825e3f0d4bc2c8f603559f975eb76466e085653b1dc03e8f8ccd5aa1b880603c99c2fe1fe8d027c587c1a9b670a727934c66e92e9414edd767cfc129897cae59128db6a6caaee4e3014636f39e5fb3cf512b1541433b8e0e3ecf78558cda3ea560e2451b7f56758345d4b2c38044db5c8527fdaaaddaf30c0a9bc53bec5a4d9e72773468c29d45144884d88c757b22d6aa59e2c31551e76875569157eadbdb154d260f1a1a0b1f682649c4cd7d351173d97da458566bff2e5dfc0771a5fc3e123cdd9b763e46475c68b6f96a8a3bbc0c0641bfe16ac1beef9cabf2cb055c1a6c7bedcc4cbf3b082d3fd8dd2de4955220a6fc8469c8c8fc6a549b7a20bed2ad280e7183661184e1861134f09201f85f7816d3d62cc123a6bee94b2db2728fc82de104ce32ed1050643fbefc26e05afa4412aed523aa54248deb2f3cd0b2419b948536aecbb92afdacbfc765a4bf48635ea3ad576765ff009c26e37ef433cad888d01bb309cce9858cc5faedf9f0b52f48153d1cf2faab83dda21a88fb388c8197ef64a1096511a1fe68b3790ce46b704b0c25fc543070b8d5a3396bf994adac7dc948ac1444e18a67195c32b755d66a716b6f810594a85f5bc341782e18131d66244fe696f5c17df9725250de735fa59334ca61663684df47910f23306ac9361bbff0540a34a78c6f551d9a863aa880b98776b7cd9fa082ad19859cdd2777cc078c666b5a0389549e9705d8d662da8bdee4a8470390120404f955a6c829f94d6d65fc973b63b03d0f483c1eb4019c37dc8bde38ebf8b4f076a73cd53ebd2aa2cbd10d86a9697056c8ae599810f566c2ac2a4e32be720248e42bc3736f4ba0bacd548d1b974d5e1e5523f931fca00a616238e79a02a81db2a4b8c3ba6feebb362aa0afe1b398fd11dd0878a14051293f6998769ba511169f2529d9c767c26373d2474a1b8c4e5dcb84f412668a3401ebb60869d2ef08b0dd0c4c879d776fe395da02286ca831e8a0ca4f5a279a0f7ec59e49b2579fd8571ef13f33a92ca19c567864ea66eb2d46e5e1b036573da0702962aa650b86a9f3edd3f2d5adeb463c5dce6a4f845716e7457c5a97e55842284877e7fb44597834ec3ec5acaac6ced950eaedf81cf9d42d5d6661d07a89ab46181227789df0dbe40f9ba08fb61d3a4ff768b904d55a7367684f10c241ad591fd9d234c2b6081e83d42a184e6abb874aab018341ab53c18a0ce706d11b2cd7e636d3b742b563c28f1d13fd4e0b314c6ffd91bd35418c8109625bfbb2e84ecac0ea0ea824ca3aefc875ab515549ae37859798daf7918b2e3f2e38dc67f00988900c9cc846ae50ef46540ee8c8ab695db13bb86721fa7b34dd8a05cc8c59cbc05eff4f69faa01b4283aef9c6ccce47de4e1ef6a6da8226430ecc938f8978927efa044e940a6a47245fe5542de131a289e34a9cd0c68b8f31af2ee9ac12ae1702c73e6ee0ed085fb29765a26d364c2b992321adeca1239cb9adfa1abc7f8be765a587eb469e2b60adbed6c1298fedebae2f366bbabb7f8cc8bcfa3eb4c251158f8e8f0bbc9d7c7c398d4ecb692939440a75406c2880e9fed482612a45eff2f26616f7da0ef5ec05dd45c4e9da0cbc8ab0fe248f0cfdae55dfddd2915c301ea02d9944a72e14be9116de85680b4d5b4d34eb5dd62239c3956fc6946bc8628ee1d82c2759670b4972d3cc43f3ec106e1a701df33c89cf427b071508ba93256cf6ef4d1d0f3752939b414f3a6cfe6f6ceca4924107a02db83a4bcf662240b0e0d250819ccc9082e683390dcae12ad95863e31f3da28cb40f2fb614614c33fff0e329b984dd78c15d059e8e7efb4fcc0456a64d0ff3b30802ad2edfcb20d552f236faafee0d3c9ab365bcf772c352346c9919ec6c58b3703b6366538023582a7b3e2c591d5116328dc13830851a59977b43be3d5ad9d5171bd6bed2727173f758715bc52d3d6b74ff779061d1004cad6aea0ed4468bcd35820d844bd951d699469253c533176e4b7e46d7580f35e265ac94e6850e1d8b6421eb69203a87b9c925c75fb7b97e4585389b0bec38eca4280e9e0a3ce8c47c18c0d718ebb90448bbcf5965c874b09868529680e459de7dd5c8335e70db345a7832ef06988d05587452f0cf5ac29b7f6a98d01fef90931d2c865231569263f072d99c40f666d07e7aa81f412270a48d3f28b8b2c6dece5178d9f702134a9b7566538e7e538fdef9bd60a3e99fa5509a62a2115c1503b819098a2633d5b8db340ffd06e17144f07b67aa26806f4ed279f11ea6b43a36b28d392f52df3d665e9036b1d3d3dc028d3d5e68a229cf53d32c020b49545c6c9d951ea27116e4176b198c9c4128213d16009a7d585f92cf22638235f7164092a8c862126e4fe6a39dda2d01566525f1822364df077dd296d10b9fdacf033e51955a6cd4e3d43b44c2357c81b986f9b0ad27d9182f3c60b1dead9946acafc7a6a0f8a67c44c47b547783492b0948cb4e543cfbb8ae2205747680a982faef05af9b6312df525655499b73ba9a92342da2d949170b4d43294ba0e3fc932392f1062f887a056d75fe90563eabb3dd0a27e89440e9d061cbc7fb7e1ff0e337aa01c5cbf02b2765000d116443f7e55fd4112fb13b27e418a41bb1103c550a3396d67f56640f069210b76b1dd7127ca723d4d800f1c03d25f1c53d07082d1a45d0ae14bb10589647779a5ee931b398ef19813069cb85cdd4068e4bc3342fda61f0f510bbc447548138f2af7970098cfec136d370f794e17675ef48ab6ec8b793e88018eea22152a6fdee3549ebbc36b1a0923c70755cafff6d37c663933c2742e89a2684c6ca2c502ea2ed0e7ff31cf6807b15dd43c73c2d9d08596b3d4e8abeea8733d0e9c0c91547fad69741ff0144184d66213c0a63ef2324ba86e49a7f544105812830dfdca331b125614b89ee7a80d74442635db15e2c5ca09b9ff40baed1d98eea591610c13a0f19be018548c2a94ccfcd90fd85a933e787cc8377fede1b938c13f53c0e2d23255084d87a4991ccd2ed787edfdf697c06fbaad69f745c7b70485816e34f49ea111e9a1b2fa4de00ece82078e639611c77433fd8b06e3d3cc3af719e1a88fe6156a67cedb5e882ca49ed4add72790118102bfc7ed91d7385c4cb87d59f7334c3a0a9bf4a438a27640ceb8b51054d3b1656ddd8b3d046a67ed32c25549efb06a264bf990dd0b07cc66802d5953d1c9251b963661eb5476b7c22b6bce43645726ff158c270092a53ee13005169c9c055810b9f92f51b7ab2748f0e2d1f4d4b6724dcdab673d4b47dc5f54d41490faa311852ce21f6b464fe3ea8cee3aebe39b96827f6f7679a9f59313634d0100422fb0189b42a82cb255eeb3080719d79bcb98ecbd16c684991c6bee05cf42d5528e68b82e4ee7949f355ade14ea03991bddf1d27575cf53cf2b5108520486e4304914d6efc8ae7dd965ac58ab1301fd460997148d12c88d00fcf4f6d06474fa4da816fa4b88fb3133c5717ac22dbacca96ef72704df2a5b01d8583ef94ed09cb2b2546a577daf23ce5cd33a90877055bd98208885ca3709b9b3ddbe659386ec53a8ab585b999a896dee41a953a5876b6b7969ca76943359c43b5f75ff48d04fb42271c4f2854b49074a208c1d1dc1eb7ae303950d908b14435c5fb35d1db1169b0bc8acdead567ae490b4472424aad1c75f3cf77224b0dd1f6f1757c8b655fd00352d9827fbc9bc60b0df327aee10432aabd11ffd9c85675a08e926644cbe532165ba0fcfda4c10300ce1cffdc69a37fa9df4418d1a64cf06b4163c038ab73066d7d828927ea63b451a4bc3fe3d75173296fc07051a0424b05f2f0a9b9092d91f1f15289ce16f061e803b61f53eed37b6fcbff4f8ec614ae6bfbc2996a80628a25ba9f638a12cf0ea7188f8853f3173d231b2e2aee22049700851e58cd3b353b15fb3147c5702e3e54e7b6a350b03e4b7cf05d525a8349b5d023ccedc4f62966bb0cddf4d99608c2e36534317dc18b8402eef951efc0a45973ee4e2b6a4f54de5db8feaf45c2d1c04848f4a0e800bb1ff9a845c4d7f8785903a19e2c858bdb137175931465db27b47ec0530b7d1dfe26228b8b140f5b45b08cfcc1447000a81b24a7fa307484363a26446036132e1f413e7cec7411205f7ccba1068cec4cb0e097ab7f4ac9c2568c21a21097a87fbdb658563cdcea2fc33b9a433f705322fe57c87ce4763d49733a10e4da08fe02d76b61549a92ebba2d508bdea2d4782ed2d161ac48cefaa16722001f1bc481a88e24d1d75d4c63ab51573c8ea7e814e9b09b5e3a623261d09a00a030763ebb2ff81e54ecefa4f9adeb4d75e46fc6a1c2e8d4d89675da0870b94701a9c37259d53b38a143cca07b6a55ca68774ca87e71ebcdcb1d7bfc017d658f6a038f8272b2bbbcb63190a6a4e6b2eb577c5f7b6e78cd87679aa471761cf7db05a875c56448940c3316e4fa0feb6d41940cb50dad38220c4f2fa3dcb721fde3c69c81dfc8ba2a09dfd17fd31477de25f01e2815cbaa7107a8b9bbb3fb91a86f5a5e271738d5fd6ecffeccf3bf39cebec932a09da3ff5cf10dedb6ee0b710ddb8b31d8ca91b4fbdeaed0aaf9d0061d6d995acef59037d6c08053f137f47630330bba5d7221925c9dddb374cd64d6fb347bfa41addf1364ba123f08e7423864f0508495b02ea6f12ac4f277b48b17d5dcab381aaa25a559b9ff6e12cf80a25a78214712535bafbdb6150816b2c9c71691274f576cfaec11f2f5b262033bf0837646431654bd60fe8fb65eaf5ae411300ec1dfb1bb42d7f7954b59edb23f7e6e10c505cfe1f135b92fd74eea4d9e82e16e5f719128da447d04741ca3e3196e6482bf86e8f54746c605738c89f8dd93bcf1d85e8fcba6751e96907a526d2b378e3a73d86734e36b20ff16cacdc42528b0934dc1276abead200d682d249b7396597ec3dac55dc5ec416909f08a92628b995b49c18538b7717c8374c780c523f87058c4fd63fb305951bfe393c06bdf4c2186e4b3626a3130039027b79139c9e8589fe0090e4c9f60ab277c38c47f4ec985021a17a491878b6cfaab1eaa874e7f890535dfd843fdb52997299204f7b1ea9e57609ebe24e6c1bee7d5fd174e6e1a0b2f675e48afe691180c918bc6d2d7fead890e04126fbcea998ae32a60eb21f32578e3c4ca9ba5b3c9625b1c943cac813eea8c2f80aadef51515fff68ab3809a4ce9f32372d57255a289fd25b1c46d133f9e2244aca930a88eb23c20d4b761b3698eab2743bace60ffea52cd63f2096dc06601e45250b958a134fad3493da87ae64cdfd23217e541c509f3161973d77cb6ad29dbeda3c28d507d711706dced0ab93e8389ba490b7298a88d8265b01097627d01cbf68380ecebece541ef9f9d848f3dd06a77ac0dc822696b269cef8dd4fde4e3ff76ab5e54af6acba6db0cf4866881e469d50d730f497fe3a319ee891d0408b9686f3685225080485c615f123422e3bdd756bd8d95a90d37b68693dd83952510c8408da73b5d4399178fb776ed9afcd1973dd865afecde2925046171692453a356177a1b7519db4ae4fcf13afdebb99482b333e0a16c53df087949b9745f8c8bf3da0793a9a2748f8e46cc66247882cc9a9a8ef1ab2aa7a886ba577a677a4dd637b5ddfb62457511f3be11b709aee978e605c1ea69229f06462b626b4cf59cf7ee6526b3bc52acc24cfc5321245a1fc61d97404656bb9005a7b62752499dae8c23333b9f06cdcea6de7e68024d1ce341422062f5af1310759476e4e078d2cabf01e392f3f9675350c1482be25cfa09ae95fa109e3d94197ce8d6dd3aeb0687a4444889bd8b3e13332095d768d949de7c0b521e6fa4766531c4234009f8bb214a49b04134ae5a9b8060f4c6309172a3298e87066136bcdc12ee7f3b22885617e091d5c1195aa93870d586bfce0ff4f814df0c61380cc7b54c486ebff864e935302ce374b041110e35225def486fa69af005a336e19f05c763ee081d24f26f67a81539f875664703cfceed48450487f56092b22745545c122415759792d6bb63177ba03ed81f558a04d17463b9b6ab819113a41346e344426c863ab38496ae98978ab170b961b0157171e7273e69ad9462dcc1f6af86518c69c314614378713ebddb4d0e25a3e95423f5895007ced4a534c4e2491872b426376b79a2468517c5d99a410cea863569fa7911481c17d12931ef5f0d37dd7395d7a4d1c649d38a2825fa42db01ca1d813de918868b656cc514f90bcdaf9127dace5ca8ef11e92f951febad914b83a2b29ea6e5ee4b7d4e6ee18d951e7abfdbb839b0802f8f634a3e02280f4a8b1b95c5c7806306a9088ec5e845f099a6cde1c390dad0485c3a8ea4d91bf129dbaf6f41526d9b806f31db01dd0606f71294737d3e9953fdcfd9bb633975facbf9a1c24a15c03c5394b4a14d5a313aa313124dd1c8e9115bf9d76ad7d12ac89b442607ba9272528e5ce2bcf1c1024000768bae3769f41cd258b2bf8acf04b6f775ad24183c3c93464aa8d9d24c2af3871653ea84cd6f6133115c29fa28742f24adbac412807d3239c307532ae2dd74e77b88df34b1ae4f202eacd4b86c965f4a3c74c1f20f5beb18834300d155d70b4b8f5449b8fde825092edd20b872cb87b6dfb0a8cb23549aab8db3894d5e1d301195b77ddda46c6bc92bc4fcf8598625eea2eed6305b523e6eab16be9b2b0d86b2f0ee567207c2e2f832dbed61666ed3e039814084e89254f4b8ae5f8e3c33fbf5c8842880762b0f201336a3ac424de5d52b2d64fe73afd71de3afee5a51ec183025dc8f637356df5a074f0cb62c3b7c3d2dc53cad51dd334447db7dd5c4aa1a07b3ade7042a7b654d6d66fd92a9cf22b305647a53d161f4f75a012adb124c29ac61daacd52bd81c32de93e293b3cd2108cdca3ee2ca9d7f1807c403deba43dbedb3e5b707d6962a1bdaa4a04cbd876fb56f8677446c0cf1891e37727ce82c6359c7c03136824f6e3a697a89e550dfd80c3e5d437357c53c95def75b667b6160e8aa0f6e19ec8ad9e7b2344fffac77fd1fba615d9e2890cf003550e6d7bdb75aba672adb8dfd4b62c6ec8d3ba3ff517d5b550d40e30218d97d54eb9e1d1070d6fdeed104268e041f493d040985f84e983e130382336c60bbb8d83f05594b5d9f59e27ed34f74968e698e0b0cf30a19fe35bc01f6b99fad5ddb3def931a3703eb3635bceba51e93295aea39d0c843554e50fb74510093db2deb2f8b82744239ed5e2079321023039f0e17cbe8d202df513dcef978353e1c5d7d27f77c6dab0e5b8390cd8fe380ac6db1b20a3f1c30386b97e2db00ebbf3941cfa1539601382ba580111ab2810a9f4ff0752012f0ee498094fd5ef7cfd7cfd65fc30405a6f90dd8afbb8cfb2af7c8194f1c608f32a373ed298dbdfd487797997f744ff0b952b6218f1c65610dc11ff8a812320b1e1262cd9741d274b829a1095e7bd1240df13af9ad4220455fe7a651dd39f347177116291d32ae3ae9cb89a696416e0311f87d7359bd5a0896a47bc5116837ad8b8757558efe024c018df418ee2d22f151fe7e5bcf915e51c772a8466d82049822afc3c7aff0016bd6618c6aed8837611f7facaea0601c40a4af39a5a1565655e98c941de936d22df72f106033ef33b8c6dd6e53a0997bfd897a3c5ccd8ac6bb7e20f66259dd9213f77a72dc494bd0916ef4eb6b5a250447e9559700ae0611ddbae7762fefe30b65448f7b6ebe1b7c76cb248d869b4f3ce0a7704a60a4c09fc672363923d06f68b12b7c3195809b674490e87bf1ec1891f3cc31f8bcf137d61accd33b9769eb98e4b963ab4c440cd4e7068841bb6992d383812c52809c1c8a20343071df5b115f4b4c91c73578691fb6a619908a8ccc60d81f21246c6c0c951c2df81f400982649bcf9abec318b1616a77f8fa69a142ad0b1c2b7f4ebd230952c688cea0432297148753dbfbdfd65e7b0ae872b89a8cd6044c73fafc202d2a6030f805bbc06fcd0f72d234ebd0e8fa1d8f856ab417f5b621e28f681557093a89b974cddf2f495c1331b77d156104ddfa430c8ae2e569cf18499a5c7cf3c3771c585ab3dce130026d45f682280f65e5394170f168fb5bea4d5a72998e4bbeb1f1cacd7d251b09e3f31dd67a78d380573a06cb1937a555c9f876ec75eff3c774864b26cc5d21399ab90cba495ec1ba895f3e487038df3add3eb4a7e60bc1a99492f738bc92b71a87a9d44c801182cebfce55c556e8b84680011a39339023882ed4adc6684919dd41857480e80f656d7afd745d439fc28bf8eee0a4ffd93f5ee6dab836fa1d44b9cdc1851c35da3d7660e3f7c6709c4d7fab86cadc1550e424aa6958dff0ef7d8e0625456b364f50218a49b3214c6e316559a7900f1f11817fc513f20ba6224ea48c8df9a61cac87e1a0c870ee3a683f213bb541833825ede956a948da75c841ffd49d75be922adbaec6ebbfe8175dbb8b4cb9b43a4d61b00a4ed9c4205aef0ebae5f5815096918cc9a79ba9228b6145b81650f37a7a59f9cb2c626dfa2639df13855371cb00cd12933a2653d0496246611ee96b71a69641de5bf37807566335027bf0cb615c908d4ba85ab7757dbd86507ac1691acaea53c8208d04daa539a65313dc1f31347392778926436a869103f56b588ff14fbc477c2b22e4878c16f9ced181ff2819d98f92f6f115316920f5d007970474dcd3227c7b022828ec01868da85e4f7c28fdff79ab0840e8bffca699e9d9d046eb72cefbe1646c79984fa825d7b95c400808362e478f604efa534846dcfa9fe49b308c365b13b5155c49d0495565dc66b5f51040a52de592e77e1413c490d48f3608b35d15203f81b29003b5545b07a1fde7d0a255c1a6b4978abdb167f25105ff5f21c38782351f2e83e7edbacda131176867e9849d242c0fb1886dadc85cd0d35ec07ff03f14f9475b9f1ab0c9beb401871e21d9d182e88807b8641b7b64695fe3ef60bfcd013713a7be8c8a178a69bb87520885fae00f01e50964ebe977252464b93779b37f99b75a6a07cc1919a213af626c2fbabba9f8515f31766fe274fd3d5eb523af39c46a5130931a5fcff2cc0d8732c71ce34e9610cb4058f4fd8f5485bda18090886a4b3cc1043cae89d5d866a73f0b6c88b211f2285c1f3825b6580979dd6d2b164192241bd62589e4073c335dd6288cc937d85ccda5e837133e4f5245d0532702ec17022e309acbda2658a31a85dd4fdc8fdb45c1ed6e767946389ac890f822baa01b37e29c63aab5c22ffd582c61892a50960ee4916901877e684597c1bd269bacb67a628eed1732d6bdad9fcb635c668a60b701516a8478772f8b290694ad1a5f88e9083bbfd31d721d507fcd1a1316d2c9c908cba6379cae47fbb1508ea216c5150721b735b46cf4f0cf29fdb833330df75843deac0a1fa06efc210fec2806e716d4b0fa0a5db0f49d4ac9f3b5440e2bddab7dbcbefc122e5771d6c39ec690a856384257408ec4361f8c3a9c6dc9a486e8d6b9c60053d82025f42b7c949ee5c4be1da2cff5eebf19e8dbca030eab49facc324cf4043c3d02fc673b8f7fa405130f541a82bc8d20ae2f8f894e2614eecd78b42c8100b12dedb14c88d79268c5875ed865133f265a2c4ac8b1d0a8c0dfbeb000c3f8f9938508faf00971e06eaf568fabae15a244bed54cf50b046d9a8ab6ec0c3e4a5a8f5ed066b7b67589d9e2bc8e910efd0d5f34ab771843d53806386951e31b16c9e80844add1aa3d56269fe9811cc25981365fb395903842b2f46661729a1b6f70d59addef3c889bd998f2aaaf98b3a3659821a38561987e23a71138efd54f9a132491ec30c44f34041f490d2e6955551bb1cb20269687630a69ddd65ef6cf439cbd74eebae17c36c601a5247170009ae502e70fa5f9a2bc733332a7289545dcd03b63948b87df66a513e741b26665f70646c1e5b7a6d3fa92f8091db9c4f690494a1458e15b491bae3565125858b56ac8c107c155e592cd4a7d9d6ed89416255f154771b0d82f641ee6ca8f599d4b1eea6f1a754e33cf250add22abc7ca39ea4a9e8176d7a68d8e2e49629f3b991c36e82031a94cedd0b196738535a644162b3a938f69578fd4598d7bf49fdb61f09e41f881ad2990c778144b4df515b348c81b969134f25c60bd2b0b21cc2b4f71c9ba85c94897aace80fcee1550d9cb54d78bf2ba21134fa14a88f5d63f6aa5a7055e36c7ea30a20a26df9fe9ee8e007328fa1d13a8831e7f21eb1304001eebddbc3fd3861c62dfa2af015041b7f0d2f4f60e71498ddd9aee78cbc7bd823f9bb21e0af62e021d67c921b17b13bfc76350370844333667d9c8591c7956d23f5f6012613155e6b2227bdba97cabce62519378e90337fec32b1b0eceb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
