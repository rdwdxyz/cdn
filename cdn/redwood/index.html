<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27badf3d38a40c98bc3fc0e67058ebaacd196338fe6f7e431d54046082f7ba7c5bda76d8de060f2b3f57e882c36f84158cd56f9065f9857d608752f63481468b411e457fa228e1a7b399f2aef7ce6c45d72a95a1f91ee7fd39ddbaa13afa083ffa303d520a844adcaee5f0d6b7aed6f7d9d9eb9d3b05b0c00f92f639a4990d72feee787ddad8c169d9a5da763b99324d140d6a7b9cd0f1817168b10488760b666fea9675d1bc7bb185c0f0097df8e661f6fb87e2b21879a56c9496890c15d0303d14e9d1f18df11fe431ca0fed1eb345a990e47cafc03a08a90e5d828ffcd1a6cdcc5c47ae6cbbb9afa7011f2d0cb98aea74f089eed9679d3b9a64e9bd54f346f3d606aceae9b57c010ede8d1379804e245052172ce705d8955a2dc0f659cee1e688d8a85b4c603f484a34d87a2f59dbeea1624a2f177ea2624e00d6ea1f4119c0dbb3cad115dcb01cac804bf63a23d8e2b89a066caf5dc12263a2ad5a007807908ca4a3d81e4dea8d35543d75e98b95cae6635a0d14743611945d40cc49812d699ef5f1c5617373797569c4a8c828c404b07444a842ebf1e26c03d9205f706e462783794373bf293906d0b90da36b7d6f98b105b1b107de131b67e76095810a5bd94c3fb2429424cdbd6d2ec131c4d6f62e9ce75a8ce8d71869d53593e75b46b69b90afcb382052a4ecc6deffe62e8d1bb6a5623d43af53de646d8498ca0429c4c955251b8438773f6e392445812ba6a7c2d3e73e518056348fce1fa110fc9dc514bba20ab01837c853a8c005551e51d134c87629d520f4172dc02369a35617babcd8dbadadcfca56f029a216a84658685574c7a679df65de2f75c043ba7854396ecc6295e7467adb42077c6a248f1cad2cfa231d24b670f1c7603b224623c2066d6522f9bef44f504f0af141db429e375a5d8cd7ac62e36a471e459d26bf3b4d3257bc9fad96cf361a3a697b948a6e2d33f285c277ab84610ad0bb114131c8d08a953e26f3891d6912f1ffa86aca73b478b5b903cc4e430f610a509c608b7bfa53666c66bcfe47d4957378cec266031e18478f9281116590a34737dde8b1336a4051ecc0d03b37e89a3308d35079af3ba2a8d23b1079b4395411d89b1e006875ce74f580231df9ab35c31c33b09d6916300247e76ca50a5eb71cbe9cd02f8007125b436dff06d03cc884512297c376b984ad882ec0761fdf803f5ac58fa5d215f9538a3daef7177a13aa018c02b9a87a8523c9d0f6f457d46df678ceb7fcba09bc899d5b4b0018c3196f2b535c6c3e618347f7c987eb1e3fba0e6ae63e040821a3a78cbb8646c14fce5954ee355f11f5d185425730e2e42313b8bac691799c16c13b18de740a8b3eb12e54e222d148b7c10e000e68e85f8275845d58863d22c6074795d2992f01167e9f01a52d179320c96a14af314ebba8047e7006d3d650ddd83c43c0fdd3d7f34dbe1b274c2d59cdfd5e645f2f0b545615d8942c7fd84ffdfc1f3a85445ae45391d968e3c547020b4d59adcf758965e0afda86817cae39924d713d3d07c29d2a75aa6dc80ebd9c3ec230cd9396b219ddbf4b24d629324c89aff9550ccc3329b51dc3c0c8a362cac51a90fdfbd1e65715a43493eca60722ce26780b88fc028ea802166198d2836df9aab7caacd672deefd1e70e65b79da28f36d0cfb1c5fd2e31cc33891cb2297fb1fe7df1d2c924f599ed90c5dae3efd9fc54197f638a57aec8a0ba9e1ac9c16aab89417e8a6a9a319ba8b1261b392f8fd15957477d16f04b0fe084645c7d91ff49a0aa0f7bd8eaa426c0334ea806d26da633fa96aaa22920ed8073641c0e2be886788a0255a22f2dc4a60e36523b00f0158c977f1bf4effbd58c213ae5b149c1e8952ad9809312b19936d5aff3026505c10c649f6d313b64881832e08be723dc5a6be15d8f27aea98f92e8aab0f92188ab6c7ae10e9df004b0626f4d6e3e8cc45fbc5fb9d40e5ae924c54d8d0efcc84630bbc087bbaba069db5fe8b88c265fe83064f7b53a766bdea92805cb44a9d175c44b8e45a6f706190e43fcdca615d3c0ba6fcb79dbbc66a7c7782908fe94bf2575fc6f355b548e3e0f54aeab1988540258519e84ca3c82250c27512b77a4cc41340786e585202203ee762e91ed72429421172da7f063b5df1ee9328c618d494ff90427ee7547d43bdbd55bf2c7514943ee41ede4cbea12d2af9b3cb5050f4843d43ef97504e5a48a13f81e868357af988d8143b3523fcf7c6b1f471e08990728b09524088b2d1155be07a8efb63d588ff65c18964af4cf9a63249866cdd58f54878c25def8e92f4f2b956a91f5af35bbbf55c9aa62137f90901c6d8debbeca6723b35c2422b5d182cad832f426c29de029f2f9729a9b222a8a57beb2fb83b6bcdcaeb1651c1a66b8c4b5084559e365c1940e5a9bf92fdcb5551de1bc4b71f31e59ff06703ec4d4d5595560a8dc858ca9f27a373a0ee5c360a5461b655d16c87fae2a4070024aa93e37b33758364ee1b578bc79f47be6568164e768ecccfa6c3b495c5afd3ed61673adbbe289817a3cb9a7476a286655ae43df33818332356737b7e8ab32a44e8efb6ddab85394619d01e3a8f67066fcd54adda27f837587b86d1fe59eeca8bbc8c28981d3c7ce36371e1c6be4e12e27f16357e57078f44558fe87ac65c251d922839159c66b88ee8accfbf756bf73e703cf3aa4022d7a4bb93dc0931e570d7799bb002e5d3e08e4018eb0a95ba1455b8376df75226b9b22f6cf8f25666753ad05c59d945c9ce080f80cdcbc388544b4254720f4a7dbedb7cad8c6bf85f781dcb9d0fec5dbde7edf83dde5dce1b14b4e8a2ee7688230c8743d07a88452132b6d1f8fc5e52ba883a3b8bb15b776221a1ea58497b693b561990163489c02d789e6959cc327a461861e2a98457bf6a8ef6d28092973b35313a736b67277aa0ea12beae0e1e9ad7df763221d7268f4dc4545687c97b2e81980730c3bda13768787ebe7b1e3a0dad084e121e989695bf5ee07ef55c5afb6c792a9c4d8d77c3477b11338f77b5d0104600aeb1e6da6e060694ffd14ab12277d09504bcbbabfbea9edc149e80544810774d5c433500b0879ef458e3221fad239ecdf3acac989ae3fefd1ec082775a90fdba5a8491e589cdfb76a3e2bd8bbb812fd702f013358c77c01c7e20ebad51af0a89a5b98607e7c4d0abf58aa9c6491dc7b9c818d3d5f15e469816169cd742ed47d5e284af9b08b32e9a80f7a883aa961677e4adc75b9c512276df5d7a3729dc7528aa8bccfd13c3e5cdc5b5b956631d3a274746b6f0201ea5d03c561b6f27cec5428bca7839b5f90ba53a2ecfd5f8a4cc1b33961d4d7abd721ae3e87ee6a4905d822b6179098ec457840328afe85fba1a6725263c15d7d874ff62ebad2e8b4f78f25efaba07b258e3f499a0093733bfded02b48c7a221fb1b4760bbe59243e920a15c2b1459a1db0f2a79b739fe01a7ecd8816a00c2cbc744daa9ed09320fb077cddb4f664ab093c26de60ee82bd08066b08da63eb38e991ef476400f8fd676d007656a4e42abeebcafa61461db50eac14613a11ed2d08d06c2e3bcf4f32c9bd8d77592fba1c0836924e55c837a26f27f9ae1807252c9a441a323a30ea0ab656e742ce48adb130df1dcde481604d5e321bac6663e68f3bd75d2c0e1ea5272518245018b9e019059f9e12d1e73ef9968de4bc344233b0be65adfcc14e1601b6c229ace461d9cbc824b35b2a1fc92bac93a0de0bda3e20210d5c4a1d4181c63599e461b77d8b8d0a2f8bc301a0b6dea840fe9a84c644494a0b382aca71aad21e445af05b06bf587f6efe6e69a9f8fd950fb8f46d4b3f42c468f0801458fe730bc4386cfb6d5cfc6682fd614a293b3d3068234a966a0a6950709bb7bc513ab34b83a30d506a52d067a4c7f1fc5260dcbd862173b8170a66dbf5e8a6a6961b662b3a2e65cab451d12b53687527ada71d77d3d9c9e185e4463f5c516d68b33762075ccf4227d6530df6ca82bdc64df6d806c5ca46da58669e0d931c6d944681427c5c85b571f7cb140fe428d557e7fa22ceafc9f7c64770db6fba2bf06aaff85431899a7f22b47f5839dba5b2bb8f1c8d242ee94c522e6876ba5b6835172ac0eb9d6e91e0108e7651494cfaaf4919ce050ea1779c263be11cbfa5ea98f53daa40673d839e16a44b710985c7184c0d005817a24b8ff0f2f04865a9bf483643cd8d7ac1f1e3ccb42897b527a431755a04aac66170fc99acb9af75e1978fbfcc945512cafdaef9e5cddd7b870d0b89cb8a0fa995d549de32dbcca9f6fc831bf55631c699d6c912c67fe2d12872f69f3856011bf4756adbd92ae08fd59db7260659583eaee373ae9a1e2d69d32e26c026ed53b844afe445ead04c052b156a82311e1289334ec9aebd29d4cc034a0082937b52b055d0273b84a9d9b89ef2ae60b5e221bf0884c71a0144afd4441fe218ac7b6b434d5db8d32185c55c3a62c7364f9c3eec90874a8846c41ea8921975d82cf16b3d0ddfe69c0eca734a047c09c53f3304c5325518a94fcf9dbea56f53efac6bd8e4ae111a36b50f70d41a9af7da600e23311003d5e2d65e25d2ab54452fa7e7f2b31d67b3adb422c543efdd4d3f78cf8a12ec82b4f0814aace3639a73c124cfcac81340b8cee09fe46b6998d2a8a41797dfbc6472aaaa55cd1f024bf304caf5a7584b35cd0d5eb33e7a59cce138f59fc8995ec2a9234328fe0707853a796f63d7f9381f37f48c6a1834d799862d3670b44f886ef4606e793526880799b95a77d93a14aa42b678c084ac0885380bf07fe1688c30cf28dc866352931dcd91fa69b044b9fbbbc4d52889be4504a13069c284ee4c72cdf09241caf6c3b62bfdb6307f959a1e91f03f5835905ecdeb70d994af0caa53569dfa409ec3eeee256b51f01f667e09d83b4a75dd6dc1dd4d74c002c4a2292562a73ac5a27e52cabac203eada15950c3783a9364aa77f50aa17f1f62b127c4bd33d5eb3d7768eb43b05bd7de107f8eb826abfb4f26f421e9a06995edec38c23c7ca83e1468f5a4d09c94202765be743ac52cd715e7c54e1913527fc17453f26698bcf8ad2497fadd7a8cf016234ae0b9a596856f0948cb30af210b4deb30719f9812fafcf0cb31699697b50a5f6b821e956172989e98dd65010545469cafa6b021466564bc81423ab28d73ac2b071202de08b867beb3acbe472bac7eb3deba51ee0036ce78a19da20d368143d0c303b85a19aebffb10b7157f319b1b479dc1dffa6f21345fd39954701ee0ab28deba9917e53c0767d0dedff63e8fc9fe6eedada9c4a95a3c285f166f32dfc423ce64afea4c7b79d5065162f5b3c9c426af603ba95e2ff20a7949a4fb345934ade1bafea2bf13f32f37a966cbb5810136ec745c154f52c8bec4bb8e533ce6695e4ed9a6b405b5109cef81ad8b9d5b40bf365354c4082b9d55726f88e03a43673ab4b3380991e89b258895dd90d5e366996896c66ef4ad2fdc11321d209149668f1759a391d0357fa35a646d295c668a6bbca47b0ce5031c4510d4c32ef40defbd5d217e5f4d768ca2a971c2aa8073a25454b9c2cadf8a1ac7732bf7ff023e2276869770f7797a4f5263317cac285bad045786cf65117006b84b99df2196535e00a465ec3fdd233cdf53cd52aa9cce581e8f09ca0ee874218fb1bb793b44ff20fe59a4d6802cb7ef89b9fc9237142cfb1ee1186cc7926f0acf7a0c92f32583c824f1bad60edb04b0b53436ebe52d752deade21fdc2572eb926b8a22a168eaace2595d9799a598321d418e09841e4e95be38c4861fb64b9bd9430e3318ef349d72f24ffac87d87c15cbf30623d3e2bfa499270ebe249afb503ea9a0724d4171199c302524586fb80294f473e49ddf9f9baa998e8a7f90619f338ff4247720a8917bf63da104aa28808aeb429381f5f5aba0a8ba672e12bd423cb893af03632605fc3f336f09757a2ac524401e711a9574b7a97c5df25f073cee38c942d317a1278476361a6303dea5018c19cef85841775194808b4e9a4cc2ec87a704b395ea5f1d4cb3ea613979a85ec368189cc93f165433f97734457d2289577230a4dbfb92b69a4c7231c076e9a7dfef8df1b656747e7949a9878f313042da0fd428ae25919d1479b0a4bef93e4fb79b3216776d9da3689e5700734b6740e0648365c96538c543b7e2ee321b635717018e2ede1c2020f52371fadebf8894d2187c6d2b9c8b40bf48ac39453fc36ce41e7718da9b54bbdf8da3f38966d9aa3fb714a74f672cfdfb19328d7bdc8627df14a2ff6e93e29604feac50459782980232673cf2be0b02f6fcaa50011c5127b305e7575ce2ad9efa6cecf0c65ece196117be13ae3d8fdeeb5d46630fc8f48e3f9b7bc9f81ae8d882afb60e2d65ca43e45bdc213a7c04f27406601c27d42c61d2c0624db8c6c677e02bc7d884d36f3a2245be547998d2e1881fd1ec9b5612389355d853a6e4de05fa63f9f5cce67df2e15eacc679ba953719485d57d28195af51529ce40be541a5e33cd8117f7fdc4bc69c203af8dea00d81f779db26fd49556e6f0af37ac35f866e62c2ae2d0ee968241a49bfaa0aba95e69ec5f5c077ae833ea3fc15fb3b875629237720468559499ab71b45e23870515660a082fcc3824d70599cb59c27ff71ff80f6dd4e4af4afeaa76d40f346916c8b7bb9dee9e796520819c6806b2970f7c767f7821e8979581760c74da8df2682a6d8eaee058bbd69c83bfeed7ef1fa6cd05711e5d3126dcf40b4dca439843644b7baf0bf5391fdda56b52da6b1a8aef15db75d65162d20d9bd7182709e3a5342b6cc62eac5d7fdc01a539d19322478306af55174dd74d27acf4c3a883f06efe3cad756c519aaa6d644500303059a79a3ff4eef200a77af9f100a38cd6e9d135f10e74da78e3b6a05dab835da8a6629dcc5038ea32341f762583056ea315c1d79170c7398a3b398bbf5bb816975eedd26765ca94977afc0d5bca822e7e6e64996b496e65b6d56d7957387de60e817de58effd9069fc4857245df3f12711d6a541b0316342cae818e89e4d6e8e5cc2ef379bbabc240a323f9ad279daa05e467ed1c85ddb64bcb0f99c5fdc6038ca836694380a304fc4751fe2c70582082f3848545f7cb9747648e9411bcc86a32539d7527b60aa96fb7f482915a359c0a57fce5df07d970457fff984eaa6f595ae8a2d01d67a02a22ec7a7289845c8ec69c5087487b6a917f4132f4e55f6353ce855316efcd79ab07629fc4c29c473e526d67d1e3e7a70691ab401d20d580e6d0e7f6affb9b3426728f03badc615a52261ceabd943236ebd23c7f43015a8dad0333c7c00be1a8726a0988e01ae3e8e3703d7866a16100b6e74bab162b976dc0b62239cfa3be1a7e79831783ed3a5fc4a182ab9efd4765942bbf6d9c26a8d75cd92c0a8674db58c234aec7936abc8b901c14e9d0c4f4bd3d9e42a14931d4555c58103af705c56f0736adaa6bce4f5f984fa98322c646fcca5e308bbda56f5acb2110013797907181c114234b58be9ee9e29e494640ed6222288336c288fd7a15ad0f723c5ffad0dde3154031b9c84caebf8721979035157e2f4aa016a50206af2599a4f1f95f0de686e9ef00b5e90b86505df7d94caf6f42aad2b3a42044c98fd96b8184319e9116b6709d86bb48c5952a72c56f27e3dd6eac3fe91bfb171884257c3e522974b9ef575712a74580164ea0654feea536e0c033a15b92ce646f8e960937af0a2361be89011fbb455de840c2b4a6df134879183fa40ed0f56dd243d340c5312aa54fc294597063b10d5fba46c117cbf9102673e4b7463511f1211c4c67c6ac86c9e186e474b1c12e61ec964dd67c31f2e0acbdbb598e8abfebef578ecfb6a9635a5ebea6a4263283f556b1ea77b2b28b712e48033406d6c6963e3a8c7ab08bba028bd92ab7aa078ee0c794daaba22ce9c3820dbde182d629e5f750a758f9442936d48000a0410aacc812459abdef42833a7521d08cfe4e6b0b671a8ef571b4f012e92b1a429fa2308de51d5d8143bb02134b301fd25247cfe6d5837d92fb7c547ff94cd9fe953e8bf3c633cd0eee58bdd042d18b8d04521b4fb13e106fe5002c020ae0c0db239311e4b431ff2af3ea6d3d6a3d38fb83222fb58154e57961744f6937e01ffab142fcc9dd46a801874df5e0433302d34aab83377890624d235c70a2e341aef1e27380babf65158e3ddaba28347e15c8204eea7513e5ed6409c8b20f98beabd5b70509fe2703acd09b11e5d578866b201af50f87dbd62b9e4d330314bb4c3bf26eb9e23ed6e0ac757a16a64492c99a0532f84cf3366c83ae680b0ab25e3f440b08b97efb2cadf869010bab086fd471eb86fec7ef4d08722bfb365451b6f2e656f938896112189758707cfa94bbea643cc555e35ba9ff338d9039f0fa6284bf7d452f25b49a3214dd82016d5523986d2eaa2d6e75a0b9b34fedbdf0af7041f3b7017299e658fda868eb5837158de77c5850c8aa5d43d89d5a9ddf64f01e96daea60af7f680242e075f310fd75fe9ceca1be68dd75978650a4fb908f0a9d85cede060b8eafb7f5f6c3b1b8fc41de28fe21db5bd2fbe6d6330ef40c7551ac234d3f9d8a7c16bea754ea0739d6461be8abbe912aabb919295faa80207818368056a9b33c74fbcef3a1b6255374fc2390548dacf1ef2d6d6a25794ca8405ca2cfa2a20d73759c0a173ade9ab10655e659ecfc180a0113588069b58737936cb01639f844fafa0422d9aef38781cf2ca002286f12e489e909fffca447dbc4273a1b9dd45464d97bc4e5d3c03bc03149509c66c01321f76a1602db6db66625be9343481cfdff4e44897fae85cd2de04a7cc0ef30b446a8ce78b99553979b7fb83ac8cf817271eabadad1442b9c9d8c1852aece70218b35010eeba2ca835acae3cbdb89a542139668216e68d67e6c2e56d35cbd1301867d9eaf64494b69794984b41dadca2ca9126b9d2432dc47548c4d3e9f879043383e4e08a089eab628fba09e9e58fc3ac8d4f16479877e7eaddb81a5ae9f6bb71d78c071db8ab506f2e95c4d9df09bc1dd5f4e8f5941162307be39a48da3e360031b2b3e7149fced662216a6f36af83be48b8fe61f444ab6798e85aa21aecdfb6b93b422fdb2f28a518b0b9932db991bb36c390b7465d79d7514abeb08a37d82682714f58e5836e3b289f255c682c4ab121de06e2529e5ed45006e6fd0cbcd8351f8fca48b53d632a962c010622e9a2d6e1829d6642cc3d351b0b44edd3e7b69f015803c9729ab6ad92c014b1173429827d711b80e6d0741a9b393cc5832acdc399a3deffac1931fd5e54c03ef6d6e0f45d098b5c9eb5b028b7da0409199e3ed619185c438c91c57481de6bec7c3d376e58e50b1bfac0015837fdf6b012ad54e7ce8993ee43fca868cab5c08f2490a942660e5c6b74125952bcdff823f96e2b08ab361d7a9cbd50caf7f453d8485923f8ef06ab9f583d8a7becb43bb35ee9380318655d5c43fc9ba1aa6292f3c61fd1c6701091b78a8b65a20b37d5a9743f704eb20e4dab943131e098b30081e55fda33593b46118af6a621b97a5d929b850e12a25c574f8b453e98b58fcb8f0b18bccd6a9498d12737a1a4010d5e92205927f8d5c3084472ef2dff1fad2c582cdf9aa2ad7700f1f221576471f6dcb969d1165fa8613622e5585b8af1a8887614e5504df1a780ac8f939812ddbaddeeda7658ecfd68f9eb9259e026357f7f5ca9ea88351963114555f18cd89b1a015f1cb8b2af7ce2e7b913c32ca908bcff1f313e3ff46720ad570ae680f6db8025284dfc75c5382b48e853f648d5244b20e01fb471f8737296d1e2fedfedfcae41eedd0debe58edaa385b41b82441238a44e3e2e03d465a461e694729826dafbe95004e106568ac3a2bd97a3ff58d4cf18acaafab0c15593b8265675dedcb48aeb2e680e069ab2ab08b954fb8f85d16b4f2f08a79e606772d202c8e498150f99a34b000bc6f600a2074f81bdeca8f73a539daa375b83a1b206f20323274661daa25c4f47824042eae6ed2e6e94a3b45957a9b0efb8aad573895c254c46ec9d8bfb991530de5859078ed270c6be7e41942e81944a673277676e1d65e46003de1781b0825dd9cd97ee2e5afbdcf5061f54a4dee80a29cc4e4b5439be4dd91b5371673dd59f67f46d84eb9f8de761a814e0be63c0c3fef4a120d67554e7eac86b59bc2086a5ea734393b32f1440de583ebf3a1c24e1d3cefd22911847d055ba16eab8bfc56c6fc093bfe7f3cbd7e92d6feb0307a40aae700876d7a6e975019ed548524a3d15a663611351e63d99e38471cef26dff90ac9cf610be886ba3c7e18c18e2618b72aa8b70d752fdd4700a8f32ce33ff883fa9c897430a25da2c582ab4664d8f2ecc461b37fc71ec403a002d844d24b48a7426ff3fd73655ed65f552e652793e4a0eddcd5715d95c25f576abf014c082fb1c45ca8c80f34c3d6d2fafd47fb30ead07ac7e66e4f0efdbd1ef3c1a0af30e80c09c4315c775581fbf521530cc42d177eb0156a2a6080a692c8fa069fab064cad84c768a25281d2bbe5cea259ceef56aa4de46410997c617a57191b3afaa56114e0a1c5014331ee7987e4aaeb8622a235d5deabccc14b134ce4439bf4096d39d72434a917bbf8e5076c852299aeb61d8a5d4432eb1bbdbcaaf976694672e250862d36f1ff32e73c09d92f5816a2c9db869c02c81b882f6324a3415ba21c549950df1c6c09a24d07914d046b58ffaa6b5f641ca0c7ce344f8834ae5c66d98462711dc5108d6bcfe075a57a7caa0a55cfbdc6b98c3fa8d544608bbb9caa9bdd33623801c106988bb692cf5ca2858cc60b5b3e5facdbe35f7492f94263285d4463ef669e3783bc359c8ca2403bb47807c27113c245ad9c39c3968ea5522c860f395a93f1c92b898a2074369fe2543c24fa1a5cf4aec567b3918b1b0dc95a239df0a5809130a9713fb2c48976fb46e7195cff7f4875db08a1f9360cc4ecb3c06ffea052ba831b23a3153925766cd58c78fe3f4cddaeddc6d9d73cbd0e20533efa13c014a37f64c4e3c323e1a12f90f7b34ee404765642aadb969c106b8af0b92e85bd9a8ea8a21fb107159122882a9a410b3d56bcdaea8e3445c4b8e835370a1cffbc2c0ae35c4dca41b7173d0c940c6e98c4a7a1e9f3d8612cdc7f880b73c7b874b1a6476a7699bcfc1ce2abae586f5fb04b4cf2d94323ff9d16669dc6ee2ac874e2b6034ad9af91c5fb5d540eb964e62427d33219dee84d3a3b1d8c923e844ce7d0526426c6e355f77e4b7762b87e9e5f56edf51f9e0f22b79f8c8f5d83dee8dbc05df69a8de048510212521da6a40d3aa3e982af553c4b3b1e953f35868f45f12afb3d594a0eb67df041de18370b1eb1f9cd1125e54519ef67dece261ba8ad141d9f390f752a9d3883cdf410551adf7c493fa13f27e5ea88ab89381b3b5ec10800646974ba4fff8c70cf8134ce63cef05397fdbf3bd853acfb859133bd3bd697c92b3fa514d47e55390b2ecd43bb4779d6ba041e4321629b2f3ce05e2f01a7b6ed41ec40f06e50c71a52fd5f0378b14f89ec976e5c8718831712bf141d5ce971883191aefc3cbccdaecba555340997ebc02bdb9fefc9ee93bf2522f5828f44eadaa7f5ba0d4ea1ea4afca2b99df4853ece72dfc160f992c6c3f8aa193f2824750d09784b13205d443f2faafd02f18a77de0316b98daaa94aaac9207f085b663a261773688a5cbaabfcfbbaf573907735ce1ed95ef1308acf10f6e51da5bf8b36afab9f177a2635e57166dcb67269929832eb91b94938cf2b16209d28becc254d7050f55ddc70e85dad3e2682b9873b2b1d69b9b49a3a3a452df660424167d4be684bd65f1c49eafa35c062af39f472f48dd240aa1094fe17da962784cd4bc77c7d1caba8de9d81e4e559dfe5fcfa5a4f8e492946b2a97e1d1dbcfb2702a5f2fe98933dcf2691f3c72e3698519dabdfa04229c0601ae6435c895b6fdd1930e459fc260f06a827aabc70f98dd3fa26d470fceb323dda6daf6f7086c868c531a38ecae6db4eb99f11b4329aa806bc8730bde4cc0a9ad0817eeab1e93f30578a58058305a0c08f4b815b7dbb23eea03f6d0a4b88ed8556366fcb298be347e314ed01acc45106c51fc0dbf0a93b6668105c05598d8cf3644020beaf914704719f6db634a916bb67bb80b269d64df67b8e90230776462f63974128699f7bb68bed7bd57bc44ddbd6c995d0b72b98027de3796160b202ab04ba9fd40b2fe868b8805b8470d861afe271267355defbdd6eab67065c14be61bff13af0a960cf2e98daa3d6107b02f7038914606431beb1e8e1c893f7e91e20c516c3a7736cf4897311997b8679878a76f8ccd99a2e61f88222c8af26e98934388ccbf9503beb031381270c669572c22cd79491d78c570fc4d2909fcd8d9c8a35ae8dcf6ff13cb2d53cda22a2c1b1b1d1be24d4572b8921a98bd412e636e6af8876b4fe78dc802984ac0cfef8f0a489dfb0aecbfda7bc187324882642bfec22cac69f367bb2d25ac649eadda5977bd05ae6ce32f3f40e5226ec039a3f2b96650e513182fb7686b1a59a5bdee14217a355ca68050afbb7f963c769ace552f6b5b246ad93beed9a717544fe2cf4f191ebb698445d3e558a05dc47f0cfbb68d43b3cfa3b19d275b235ef9350facc767b042d35b56df090ee030b6bc9db0faf55b4ed44122763808607c1cf35b68e84e26f0cc15c18d607aa39ff49c284f83e710d8d2698c90865e38829bdd1c2722a107c15c53353e547ab18254f54a3a6c4574641219ce63912d5afee1e3eded26208858bd4cd7db3340a179ef45c363bcb31f2cb2ce56732825b9608ad3929b6cdf1e3045d95f174ab025a92e764383a3c738b6cd7bff893352942691fb4ffde681b0662d80d9c66a7ee6fe2c2a852993f318686d33e76cea687e5da483b74adbe62643cabffd401ad69b8d679fc059dadeb59e13f55c5493d723bbb13c01cb420d40f1a6cacb9b68b9f320369244fea87e9c439ea24995be0bc27964608e56035ea6ee2ca7fc0eb361ccba78abe3e362a2228ee762a3b8414804f66cb075dc24fab74731f64c01b78d270ac1d0630cb13c595c83a30fd0b094a9ba8523f38e7abf3cccd3abba87300a9e73b4a391373b40d29e62b9cd3fbc0fd1b9b6298c81f44b6b2b337d9a5dbdc4e50895add9af3aa6d69c0cc291cfcef3a62ddeb4945b1c4d6c27030685f2988dda5938de35d43d05204c16b3cc6689bf5a0ae117f12f1f26c4131e0f4162b7fa6786dd1d81a09f82e0432410d1bc3b6bc83585ef6aebb0c5a912360c8df4b06852f762f22edfb8d72a494a5df11a1b73daf2c9fb0651c2e9ef586ab8e2795244a7125199d512740a6da53ce675cf45c440a4a36d9c0f6038bca81c5f6e23a65ac80fbdb9bc079eadb05c7f6aea1562a01bf1108818b166a6441b836fb846ea969cfe09d40eaa5256eeb5117b0330d1d47cbb1bcaeba8c96b3e1c1a7d45d608c44cb5001024f879052ec1c06707b8ac6a366de689dda9aaa0cabdf0278892f92e5ce10ef2197c88489c1689b853f10fdfc89edcf6c94b823d41cb46c86ae664d9c85d6f2f637cbe0c55171c52fba35ad2eddd0046a668a6241520f8489beab9a3fe1fd739acb800d0c873f35577c1e4abace5ab09f8294dc4d84d94ed49ac9eb2c4e1f6868d31a653a1bf5db9bf2b1792af75b6cd4910cbfe8abebd0a0cd3b7c101b14467dff249839a7c6d1e366cdecce11a5a62b885e795fd77b2989bdb526cb7f991d269d3c549b5bfaaa4bff4eb4d0f1d5b5395ee087aa63b2d6e260798a248447bf191d798bb94d7c37ce2b663c93e387f9481a9952a20f23b3eb3a05d30fe636f03681412d0138b72da869906b1ec77fbcf79b5caf7423ea82f201318cd66001807fa03edb0fc69e3888a4cb7ed461f0b1759015f05667025245d46ba8f9f6b917e1493a7f64afe7e3514895d8945ed98d1b5320dc3de1b45d402b522fd3201892642d1a79e7d7e1b136a4ba92c79098a774a1f130c7ea72b460c6d0e35ab0ee1bebf1503b78af79147fe5fe8a652cc3839e9c4d277364d92d9233c3f997bbc29e43369bfccf11e8305d97b426317ad43cc316ed347c11bde4273390d3b01aaeecc69fab6bb683cc56cceb295072fb92571698a037b2293b8655b9e381a347990e43eb5f229cc158480f160eefe6c786d3d1779b60b2273dac5540ea8dbe9a1bc87fe40328dd42977ba179752e2173ab111bde31e659ce0cb3a0a03e3289f5245383842e0e8b5a2f4bc896f3232e2fa355d331f58a37fd141838d56b9f0fb6089ba724869eff3c10153335a7af8e4fc27f02e35bfb2e576b19052deb481e0e465df8752e690bed1a5e21b9b184c570197261d86e2006d0814f9e566d36be07f7005c5b00138ba70e494bb6c4d51aa16bc2680530eca170e8df1f84020f39411e829bc76d4873ce318caf7d3386974ce03c0a16c9870d0a2914b02850efadf978cdadea739fdef635fa489ceb756a125c23f0827b6bc0f5b3fd7cfb39fa10f6c7a8fdb69dd246bc7827d8bdfca0a7b3eac1d937ff1872ee3c23c8e38ee140e7ef88230f2251aa6d18391cd2584cad697ce18ac0c69afdfe7e07c429d59a336a6e98ad1a50f0d6d8ac5025dfe4708de632bd8751b8a57edc36b637ce39d1622b5d1df6f0320142d79abaab3d78b60fb4cdf045c340d6acb14aef75e1f931785ce72f6f4c5d403a3a1cc15a6ee1a9fa6323a0e5c4e3ee6d3e1e8001df0a168bd39ee3ca1b8a4e3fceea5681734e6c3845e34923f2742fe83f5f825f17ac7f9adb5bac1b6e25bac6c2269ba343f8da7b5ea4a69bc8990e90f7d50c02d6567ede147a7dfe658d697a7152495bd6635ab6b2162ee1419044dc1371a6b1c75b6a039d362690f7a357d6d0102f206420385e2cc2f2b0a6b7061e42a640a20b8017ebde2ff9bb79a4cf7313cb84f19469f435c0544f48e9cb8c9a1dcb96506c6123755485d2a23c9836ebf815f144ea1f98bc178f753253e6df62a142bf3ee9b38274cbbc7fe41b47c2b55916b25e6c9ce8329a11cf9d71a6ab814bf79d3325b2ea4db3e707ddac60d6db37a6abc012d2dcab5ba0b586ffebc408e14463fa26b6be88f001a7be74eac6f2b30985534d626ef90f1e34853f6270d2200916d22fc7cb9913a713ff220c22ebc90be7efed9c2324e57bf59f2d44b872b5c0a9814df081d1e95ee6b94e01e56c2e89035156d15df36c2dba0e3330f7a12407d17871a2b1d3ab20b520528a1c174f638dcd5ef5fc383b2307e9f838d53e22b0261caed4f129eea66147c52adde20e3210c62ed8740b220d6d5bf797e7acc5316a3c2aaf72bc85830eb4b7b8d769334b90b33534b7da0857e206f9dba8098db84393a5883836144081e39b32d9c732432c23bba23812eeccd7f4a920d2f3c4469f994c2b2e262041faafbe35744ad76bc8a14257ca73482448803bb3c482fb02b08acf11f3440b5d7db50b409cc3cdb73bbe481a9472082a4438cb368ead3561aec87ae5c137652b0f37e9d6acedc7f5ea5d2ac00c3033409a820a7dabf95eb56e226952ad95128cd947ecdfa55e456c60e37808d92b25c9eca28da9f3653c9afb3d8ebd0d2fd8ab3d9499fa508d0332d8bc2784ffcd3a8459477a474a28eae534a6944249d44e77c5cd60e91d4ce8685fb0d8d5545bd2f791224bfc994860fe5df74bf8efe30df8545639fba42b66f21dd483231c6c241e3be5bcef6f9a5e27bcdbbe2abd036b749d6ec16d9f96d24f7ae00858595a27c768fac839de749bb158ea97985bea701b6d5ba3e42b00b0832e451b66ce31b0dbea38653a0bbec305d2e3d0561eb7dc94d15606f44687fa9e3d91207e3d6194d16f005b4f1bfde8966940dfa9ce149e841fce8580baf2fe49f734df5a36c4a15060d303aedb356f16cb5078c62a773acb7dc9b28fec93fe90d05951c813fa05158f6fe6e79fad6118898091bf6cdbf39308e470c0eb681da6493880a5cd0eac1522b01e3741aa5512ef9b051e6b9888f31db9da7332da00daa588559cd1b512a5fe997eb3becdaeeb8394874d5c641fb1304322e0bc61df50c798fba66e6c181d61d033938685322047167cdc79ebf98cb526a7066f547185d04be191bc7c43ad073a7127683811564694f474eb316e74271c2801399dbc3285804868ba380f695a0421b2c8363332ccda38c4564fb8b9047dcccda41509b29786c883c1c9c7cc58b7f2c84e42f0fe5c1f91c636e847b3957de3233a38088e1de30db78e1a85c06f6457b54f33226fcc1f8585744c063bffb0c980e5e32c3454448c22f45e0a9326208decbe93569afdf2fb9842088ac134db4321dd0e641408b5d9e599188a48fb858ff2233b13685701c4e0ef0fb546d9b0dc88fb36bd88a030afa0fa579b5b15bb1282fb146683cc84a376357a915eced5b88c978472339479278b7e620cde1564bc89ce2bdab722555f2116039d46e55e3e7f2db50d08f13199e6b8ad465c65e1bf64b12cf0eb33f2251c68617c80b252e0e6141ff4d723357fcbc96b4661226c0f79c1d6f88e287744c660565a7a25d1edfc9cbf25471f77e4b172c8ac4aec00b663e8850d2733f415ed737b643eb6f29cc77a08b6bbc04516ba8b83de856dfe1937912795b5b7282eb354eb9ddb016ca11de312d5f5c03942b5d141922aa564f7baacde818261aa57387ec11f6f219bfd448b2060b53dfea65d1f92abbaddb0981a88539c806069693253055afce35d6bf3377f77550dec59ce03a6d532309af05d16535c4a846dfa6a28ce98ec0b829ecbabe5d0fe95e03eea80944aabc03dcbfc7afbeba29fddff5b2ed72c358411be40c2172f3dd0fdc26a4b5076d46be6ef575d0aa44715723d6046f19edbe9555880eba4d29f073186d0b745244dae5a0938df494c5e35389334b9352d8e1a33f706f2b0a80e1baa0d0adbdcc436843055f06530ad3dd0bfc7c5bdd0fe9ed896e775c085ec47d65bfaabf64487ff18f3e475d884ff7509c269d4ee3f0833fdba59194a32540103f06b550b6276f77cd91e5ac9827c39d46b310b10ac7726ab6e2693c1562fe91004091571876347deca764af53d1ef186fb801f752118253c5b44267a16139cc038839051b59f99cbaa943fee35ca7d6766c0f48d35895ae197277fd5905c4fc1ed3c980e2039115071808cb65c1fa1d787d0d3733c994fd0c760629a9051c8be301a54c068c847e26c60cc4e0e8afeae53c52e7e086779b05e2ef5104f9956285a98417ff863b2d013dfa0e8a759d3623a6a58aaa842bc3a30e97139d8fbde4a3c70cbdc20f0467f588312fbd3980cfc09959ab787347f91cfc37549de369b1471457bf18d5a0639240f6510a99f8d883703993ed47a0c37e89e34b37fd0a7b0c8279d7ede3004f58e3ee717aa44ff42947968d16df4d2a15602d2e771c85d9f88178f17a7bde2e6cad55f77d18c52609707604bff8a78937e63438dddff881b17ec730eeb4eb8cbe03dce73e72b7d3a00a7ce636e3922acfb2dbcfd67d285567f0e3c57bb73d43c909072771f909baaa9e198857ef88b85f546cb11c77c0f305a05bed9aba2ae52f1a14808dd4db1c1a6b02fad9e8cda201c66f9d239df479d5be91295a6c94186c9ddeab518e63c29234729bd72dca6d290e1f6f1ceee13933c33464bb4fe7bfb03d431e6755c4ce3993485d362a9dc63abd7f13e5c6330179b79de0746ed823563b44e85f0dd599293b7e32644f15a31c74f27b95d21a57078e8d952ae1f15a0ea2c1b46858313041b159408b88f918cb42e8a64e2cbad9040a313a3ef563d01180b891a66c413169e1451864e5c9dd12eab74cfd25c05e36a2339e60ee6dc9f07cb03e62f9d5e7e16f81aa0fe73f2dcad6e6b752cac88ddac5ddd6260762db3e84eee79808299e188cca760221bedd4381393d83962d405bf210fbc25d41bca4dd9e5ed30da1ff54d9ced7dcb76fea90861f9bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
