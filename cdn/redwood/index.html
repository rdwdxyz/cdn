<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d3dde20065903644e57c67c1fe7fc2e8437be0699127f3eac6b56a7d46f5b8373851f30aa41da1dfaff650457e04e475e1bac619d6331af4cd5791302d374d433351c68a8c5f60de913e816d420246c2933fe48fb76fa2e3d6e1e5f125fc68ddd789a223d9ba44e8aaca0017c8efdd08446384bbb29f73aa1096229e9fc6609c1008428e37d56b1ff7fa816e19126505e60137b8978778d06b6700f815f9868250da5904ff04b1b18ea5ef3b5a2f4fc1f83e74c8c9df3c998a7d1d134bd0747533c31dbafa6adfb566854b4b54342913e68646dd16d2c03689cd6daa2fdad460be71a3af672a236400f5413ab8cbebd620bf9e90877df9990fc6bbfaac81c5fc1ec5ae5aba728cb89a1a269cd6591f98405776cc861eb94fb80037e5913adb6d640fcbb9482a3a1450e888983ebdf15f458520780978d4540fde389ef107790798a3b25cd02ee46259a8da8f7e728fbccb3c032105dceb07c26c1250a0df8ad939474f43835c5781f628fb52e3c9d1460c7d33239ebc8a10c050baaa12362119b6907e455d389af4cef1f5eab5eff5cb9b0b8aabc96e999f302b464147ae52540992598ba97bf3bdeac88d81bfdef1b39bf1fa659c27425158e87e425662ce0761ad956c11c9bace8b72d696a0f4ab006c492c44555e1b69ace2b480675e3925ad5a1a7419d27de0e2084f529f9552837c08cb202b4cce330dced4126c876eedefd8c4079b8abb2e33d184aff5b43087ad5f9e8fd67ffde34b5458d2a995e437a420107f963b68f6b4b63c09ddaee1640e500ecfdcc4e5002dcc7162aa7c731c56e80df080d62c2191db583551675eb0559cf04701c53b76c51288900dbe4ea02f40bf4d2ec01550f9777daa3c354a31516c4132a850c8ef47e32684d30815cb16b0eeccbfb8474752ebf0d28f59e15afe880c825acc47427e3f9075ec200e1d23f47dc79e40e72daf91731bc92c67e6d659487e2010c7e76b21ebcdcc3e9ea4770c633c39d8d95d5d381c4fafde1cbc18f8e049fd6fbc611d8b61543ecff2fc703651fbb00aea3bc3c9d302ec7020ff02b0bdb6fe8c5d3dfb3cd6f47968da8600c01f493719caa13c058508f96c293aab8d5be6f02e1528d378dfb001dc757736945b80b3c2f531d4adac01ae40dc5eab62597c7290b4e681b6d0ec3ea9b73a49fa510e8ec8d3a23ed0a124bdd21a53d664caa8d6a6d0d1cbc342162c5376076c2f244c75e29e10d1a295ed7ddd17f9f6912651aac7cf12f7a3a9545ebebf263e226b0186bb4061b10b09fe6f2242554882837f92b2832ad23e6f2cf1307cb6203c6d7bb5b0d55ef02f32da01b8c047a76dba29a977de4d0642467bcfe5ddf0f5af906d053498e2492da71a3f8e6dc1aeccfa192861649e1742da7a010630369d8ec4773876a0770149996c62d27be384bb0a801339ffd7ba0274c5484a77dc0f7ba62c256f6b5b32eabf42b9a9dcc962d6959b6921af02daaf805d11c690127539b48f7d3b4e316b4a5479035c3b3f79bdac9f0612d5f3122876e9d0d839041f1da4460ead2213020020f1014550a95e73dbc79997a80bfd02395f2534b2c3b928a163b65c1715b78c64ed8ac56c19841b11c7a60ca377f178967480fb62132c5bd1d3d0c6ca8a0188052adf92eca891959e527ca2448e932fa9a9b541a0ada608d5648597f6586e627eefd39d2ed00e39a4345bedb0845c90ccb06fff104a2ec36740f1150df555b4b6dbd90944fabab2ea53d8bc80fa42f19974795b4ef5f852a8d043d006bac6058cbece89e8aa2ee656c80f85c3f574fa8b8e84f24013f7cd2588f3a66c46a4e971ec354cd722a9b4774f9543af4dc5c3f87d81b4a715be087af7a399187968245a23d2870556b1763013bbdd064912ded7d5a8ad95383b6f54dc8815d3d1bf4e101f6d9939b603869742794b6aac94970da4e7010b12f7fdfa054f578ea371e741e9f91f0f1f9b87888b4aef97924aa8d2835a0d82decf2ad325664de38cd5c1206250d450a636781651d1cb788e02449946aa32223436a862efeee045e6be404849e025d6281a81e9c4f6ba7a7d6160957b4b9fdeb8459a8da4769c2596cdc81e6acd8d2d7db2d64010310915e8276dc3c9e1f12669e3b6a2cbb546096d45a43996a71a43dff02b51d50f63ad87bfc904085d3d651c0b7d34c0f846c8002a28284a7d564545360fd5be19c8c6b2481900511e568448b9693938987ab60c36659561f47b8fac975dba912c27a2cc6d4c67cae4f4a70672efe4537f83856d0c41fc35dc53927ebbff4567099fb6fc5fe823c91088605aea3b546918f42c26a55644e1f3614e70978902bcf2cea1512e43c996b570fc7d4e52c5eef216fef14eec2d4e1c17bf99ae0b72c418a250cfe3dbe59ad047cc0ef712da6e1a5a9e8d93b45351f2d45a6295fa262138e116b165341a2e2695a333e7d9f06cc23df76bcfb529c34c324c93c49447c696194198bcd297a6f55f8896bcf3c632b798788a7c05167252fcb821ae8d42b501f4cedf809943326c8c8a6efb1c71e75d34e393060eb20f529fe0d0d04c92dae4ed42528ff264b3fba69f4884ae01ba10eb4d95c024677fea993269110922c1783bd705e94d1962b7c38196d1c7cf8d7753bfb8a36ac9341acfda7ffd7fa15cee721f2a434280ddb326fc98d3191a3b841e2b1f53143c1294b4e0016510e15c84bd2d6f8da94a937277d6981ddb9d7ad6277d171038215157d2616601b2bf01af1eacf04ad851625294460f0042ee11a4c287bd969a3869ed180bbe588b79d2b14e1a4132f6f4ff64a93d7fdf819bde2302662fb1caeda8e671332c0062d7884660dd76ac61da8093cba3314b3f576a054fce9a92091c823d68d4cd016a00e6cfc2aba924b4ba1ec3f81c4b8b94ce761d0a8ef12bb83e76d7562343da5baa1025c34dc470e2d17f5e8c0ead1177d766f7004595145d9e77c32511402ba6e67916c0f7fbc6d8f1cbe1ce39f4323aeb41a7ed1b05707ceb4ed8ac6f86d22f357f6212671f185c8e496fd4c9313c6774a2497b26fc67482aa6539ef81da29ce9e38f976e040bf861f2895b50011212cc1931ed2a6f55e8afddecadd96c39ef9cfea42d6dfa071290ffc4425848b2e753309ddffb5a8b83e86bedd10677fdbd80e470f693d0c0cab79c2c2bec6ced6007f84665a80862854afb5c5997f030b6ecb1aadb6aa10374a4f991bb025d618311529ee41fbd88f1c365a97c8ba5778706ed477ea93646900aab32547c9e29cc3bb1034c6eca453e05683fe6a363d55b317047334b7d0d16e08746c907df182f9db4bb29ad38761835e09e0b425efdb7882208d4672903efc4bce2a9c8cc1ce8a4d0df98a21ef0928ffa45864c756cc32a0a479754dd1c5eb213937b826f3e985812be3bdeca74cf0dc1c9fd18cdda27fb1cb9edec7fc548c54b700af4984a9344484dcb56d16ea28682d2f49b074765845ebee966f3c3ee553fa32100d46d6a24410f70bf1c1ad0e8e5d9c115f877b1839da5505515eb37835067bdcb4510d086f58f26e45f51e676f2768885b1d61b06bd976fd1ff81c352ad1eac8b055d9fe1c738b4539d63a85d27db17e58359a47040dbfc6b6c3d11d718d22019853222d2428ee8a56c39dc6cbaedf336ec0d8655b79fde82cd8478d566e3c4b21181c201a7761842dd1b2ae4728f194905aea0fd70a1151ef448f40ae4aa9ee8818678b0f8c84d78045a9dd4ce5a2779e65d4615c147970173dc10b105568354d5be21cfe4d7d8974c1fd39fc05f5ad225320db27bdc09974ee5e75a6b78033bc065494dc2321f85bc7a9c4de9f1847777d3868dfd9f060cbaff5fd2f72fd1a0694da593777afaa9c78067379f25dbf353efe2147504964ef45c45005c2c1d88443bf55dc697f70f6a73c9a02efdbe67137f6c44b2610dc947be9c5fd7a001058957900e0534320abf42569a81ec4eb608ca1f7fb2903c7c23c9ea1bb5c9d727d8d34d5b1b28b33f3e57967795e57ba8ee1a1bc1acde4955357c5a2aa63469991452a87518d8efb5866b5ebe59356d4e1e219355b3e85bd719d23afde5f7ab0a5c55edbb36da8af1d636d3a15677f3e1362ee1b0ede6bf21638a8a13201241b92cff9ad3e110a2bae1c4c68637a16ebee76c961f1419f703415348661d53ca40f0de02fb6c2b0eb773380d7eeeed71dfbe81d716295888a21f4e94d60f79d60cf07647df2c1a1f28a42ab21e1dc494715f1ecb8ee3303478954ceb3e029279453664430d7109f4bd87063ad2d42efaba2b63ebc9aed90f7fca6a6b398051bb5d0563bbe144aca733d49bdf0395a8e455ac52813d8c944b91ede24c7acec36031c398fee6a0309d3a69f3e978974f24a1b01a4c80016a6d558f90aecfb87d5a636b1b99ec12034001defb7dcbe10b28a9841e21435fd9292cdddd7ec03ac41b1704ba68be43a91545d1d2c6b4e1b5b425f069f6aa4ec2e19fd86728f95b44d60d4b7b05e49816809fc5faf8d9cb0846ecb577de5bd01ffc4daaef1a9dac4d79c2eb23370a8bf1c5e39ab4fa8fe24d04439452f2b9da4be7387b3f04470ed117fe1aee2e902305ed97d6c19ee2b788120fb9f2bb7b05a6fc9fe4237f22997928920e78e9024efc2232bdf6be4145774da87928614310725b3779982458f4513b9c64d2468b18a81b9e8d97adc666ef16bdd8ee02d5f28d3aa153a1c429ef004e9541aa74676a542761bf8ce3698c1c3b2b5b6a9b19656131ddbf48f2e66d03be2431ef6d37a16ca595b3834edb507aff08c39c04ffe353b553f64d9101607b347c3509f28e65919b16f78ca3eb285ea965216aad7944933e09b8f7125a34919a1899e8ff9a6a72e796af7484c2a9d0514eef70abcf28cc0f8d4c293f0c5bf55129b6d555c13a20fa7fca5ad2805787476368b281afa9277eab820b86b4e3e6ed57d672721875e3011fb6c53c48c7fe1ec5363c536e13017c37a156dbece098f48f44bc6aa55d0424190ef0efcc8975ed3a7b042678224300664de0f672958f34bbab5d0367b56c032ed251a00d174157b981e56a582b1f0b1387d0b533fbb7ee323d1c8b25cd30b81d64b210339ac8e52c8d19603852a36023ab0262ceea968f6f3cd90a38b71aa3760980789e338793ffe4af699267ac77c8e1880cabe9aa7d2713d4caf1372e6de6d64f1642db3de4cca975d477cbd859e708600fd1f79872fcf2bc1779534ede5527381c208fbe1a5857e1a39bce0e9275d7d381487f858e64436d63f8800d5158b7f949bc060505a845a68ae0ca4eccba340f7808322d6cae76ecdfb37e741c20b1be257f0a8db548d5bfda7d46564db2542520fd8cb2145a1aee469b3d07c0960ce0d050af96fccc887931e5fdd883a30cfdf06d2f8824f7bd648ec0f5471aa87a327a59ff21b8ced856a0e45cdd8b8acd35b3c31f2bf9597f05627de167489a1d5c7dd30ccd1070f590bfa28f4d488c4b1a9edcdfc5e2f0ccc4774275ba0cccb8278e4eac6d1fdba923e12e2cfba26f8f47382c9b9bc0b97abe974a785c37e01519e61de1bab52ddb93de91ddd17c08f4e89baf9437145f7d00768e6028bb28685559d64864bc5141b59b21867b52e11fffe6e36b20d2d0f253fba871a7a1de81cc8ce0457be74d9baa4e1f636260e1fbc5b3ec88519bbf8b058f16c7ca4b9627447738da8fad222a20ea2384b218d6dbf79b0dd99cc2cd4dd2abe3691bb3da03673e6a741120ede82440a6663d5c270fe0140a5eca5cbe490d5efab9ea641d4d9b5a979e5829e56013ad77f774c132498d8edcdf7eccde5165544f9e7f9a0b3d7cabd24f22d2341e9645db786dbee1bc231d72dd2122494d081a553ed3145425ab8a28811148d3c5cec58eadb0e615cb48587c20bf354177e21486d93d9f1917fa85092276cc1538bcc676080d758c36fadddf9b30f4e1491a4efa6dc71947f90e2e72f0b283ac4a9cb3d0ea194e92ff054e4932df66aab453d78d872ceabbcd4e5b59865efce231543bcab3638d7013c35e9175dd265e77b710bc4807e66482e4116c8d53d7229582a2185b3db9de93d56db6453a75082faabcc90fc81c8bfb0ca62bc24db2d77043c82d02f62fb7a36065972f6d8f9b25a711bc860cda9e035e359c7feeef074d2ce90ed1f5bed5a607b980d3ee91a88d91481b46e30280d595873617f20fde0427429fdb9028578cfb829e74d6b444219a8cd06cc91b9e3d6480712d46e7d0becd7756b5fd646bca793077b9cc3cf2a016c5598ca1301fe6d6940f00fb85d9a00ee7b0adabb0e832d6d146cab8bc1b0f4228a04f55820ca7b8f89b904cef5fdb2f878c578b78a4cfed228a8b050ff3ca65e45ae5f0e50ee7889aa130d5054f13db52d3836a66da66b1d5bb76e5bc92c402121d858192d7d6fb07bf978b7b325ecd7d87d5d933782435631ece5c3a1c711797872c25c4db00eab51834eb4b8644d1d0b092cc67decd42fdca41a63448781b7fbc6e1f5f5cf3d51a77b56e33c8d619285dbf4fd1a8d41b7619ecb547a9506a24a2c2055942af5710cde2eedd7cd4bd4e1581eb4e6bd9e969c37efe182f983db6649f4f6cefee1d5861c0eed9f6ab363e8f059839f487ef8ca13a9f9c3adde725b0fed73f438a5f9b10651c58f86260c51e2a17814582593d8b062d84ee06175eff467db092ae19d2667021891f9baed9f26f6765d26ba22709fe59c6423e71b44925c20a633bbe3f0b341785cbc333e4cf9bc42c42f77c4c44fac642564f5bb3d324455f1db8880e8a9d817b664d817e8ccf318cf3207312c2b4167d46cea70156d9532d95b160d9f17de8fa67f442b0b21454a6b301aa8f96022a899c372bce366e9e8963af5cf9c672282a9283fc76fb7b4a2774d50c3aba3d42f65584bdcf2322541ca457c636286d87ad5139a29ebf36d0db4d0886d5bf236b2d09c6750d58c0d42b71da66f460c2fd53e6a66252098b6b6af70df6582236d759d78b54f6fe056885de823b21aab1f098f79c56330a290dd23b36c877e45b1293cdd6c39cac3161d665a4819af365f26ed8db8c5860ed15d07179b0cb9abde0d8ae2baf75c37fa6d68fe42540157d540c858119b663c006d56d4665f28ad6b8e384d307e476810d5278998d57ef01435fa1e7abb50da3bbb17e3fc1336282e4f15301c67d8689ddff45b7ca0e5171eb8f245b7663051f57f23adea3d7266f81b34f39de0aecd14bb57a653dc9f39f0a7fe813f36a9b24ba35757c4eebfb6e51cbab23312f93d89951bee51208005e2a5b0fc976b37034787def87a864168e4aa6aa91b21d2a36e2d2c32bf0de2231c995f45246bef589d416b69bd9f34868b41c8b0f9a46591cbf7e101e2d7b2008106a9c43f7cd6246e4b5288de9a8465a98183b825346a233da9f536af762c798caf76b0e489e4a8f8e7f02ce6d8a6ec70fb5bc986315c0bd2c9caf183691d3aa763328bec2edb306c8de80856534edc13658fd3e3387fb957d5ffa85e1ea6c1e046a2ab694b9464dc44084d20896f2b472543863f1fe9847fd12dd7d84f3d9ba063e8547c34dc8ea2fdb797f5b3bb5dc83eec3d573f5df32c163d9dc12d162301bfacabef29b843f523e6c01755a33c03b77f177837d3380717a0464619d253fd57b3ce3b1a8b4dd9eceb3ea11481e6e8a60d5c5e44e32c179f4eb0824d1c21bcd57b3fc07a80b8a902c86dc899dd95995097942a46676bacfd1cb07fab6bbe597ba27c0d40583183827330d5ffb3b6b366dabb00b55b541a333f7fb1459b12757b67c7be918cedd14e6867e039380c7b463fd11fa6e3a6068191686747af84744f5efb0cff67620b226d93ad4cf4e662c6713c9e682b8af3c0a2337e5eac97f15df5ad57915bb925fe9ad4d37426ade9d0054e1811fd5ceca01e9fcad774af6328fa270e968fd424d479531b44946ec04c0fee09befe04bc378df5735c4a76b5f99b27ac51820af58855e00718fcbc1944e0dc6d8b021c5be7de4cc0d4f4c05c976e1d5f6c3f79c3540133c48c3b02f47332f5d435b98c69439cd6e808b78a658d34680afc5d45a43e27dff5732d139463d2119f2682275b7abb55e335d67c43035e14df90582a75e95ac8f1f2d8f76f89fbda7230856b497382538ef6884a7e0c03490ba94e8b128d382753153159074a42fc29044e1b5f468f7c7b00bace0d6f8850dbac0fde5c44d19b0b5d2abb8317c5c532e23b13fe6ea2f5fd453f0fe9e099e5f403138742fbad24046c083c10199a0109a9b9925f1bf2135a2a57a7bad7ca0c2bdc072808cbe6292f55a4460f98d40ff08fbc65b1c967e304213357ef4582671a0fcf7000bf8d4dde35eef354abbf500a6dfd846281afd1f9c01c25250c0388353384dbb882f8283c5509f4423dfc219449c7f60663f68a34e7bebbd94f9bb6d565303032d7100cbad415b93ae23d727c8dc26c13ffa6d8b8c443e65b71047cc2f90b99cd293f39d0d1269efbed4a3ce6a95d2ac041c21ea00a318552d48ea10614cf7140e3d68b91fa2a50cf869a8f61c7cbbb7d704a07d565cfc325b8b583bc8220a4a4a9cb3794be42fc90b2600fde7ceb0b16175c8b6d7d87c9db3c1e3312777516788981b2f9a8cef86884b40ea4a0fd0c6772a13f7a06ed90852ce3267961cbd8a47744e625977d676c7e6117b8bdda7ed0255e59151da64b60c4f3a60c6cd779533d8e158a8372d57293fcad3802437f4c4e6e91656cf0d35aa40ab0e03c19b3d79f80e4cb9f61f135353a5f2f68831a508fd7fd54df589dafa12cceb909b19052d9a2fb8254f210445a954d49960f87f66e4a4ffd99e2ee855a6587e6e8624c7956f4316a264dab39c957aa6f06cb501401bc8a622ff839766ec422d2e0b9d9cccedad88ac7ef3435c9f475b3533db0ca5410ec26bcda14a32b69ae24582b5285aae5b6ca7ef7d25ad61f1a11fd99b546b962480da5c116ace568da8d36c1d5a48710f864b996d801cde47a5d54c713b20d40548e34305c8c1f01d2c8dd53aa788072e6e51c9d8909b8c52c553234ac9f72d37688ab81e641b22b8d80d5baec2e939d29bc2d67d6ae0942c79441fda83249c7b2b17b52460f3c400166b78695eb2deb4ec53543ce49ae92113001180839b0f023592e8cd87db236f5345a5bc94dd112173a9d3912cb5a5e5dc72beac309dd77aad36fd60531bd79a16bba79ae393856f4ec6662067923700c2161ff52102a9bdaa3058aab566e99fb0eee2a2ef8da77d91ac982fbc6ae078511ff31fd3cfb874db07efac494bf9934492b6f00aec208064ed3dff433c5e0f8c1c373cb4a26e744e4dad87db1e4b7306117688eded35e10a3586fc30f436e7f8f9e49956eccf2da2f28329ae0f2a02db35fb96457a91135f9dd66dc941f1756771ccf137c1c762457ba26ff1c6f7d4591f6783a188d83e9ea257f38bde45deec28148fd9af9376dbf2552041cbeffd72169ad3e997804543db314f608731423dc4a4fb72e8c619a9dbd439090b8dd9a70f0ddcc2f7e2a8457415ddf2e9794ea23b7f41068d805df25644577b08f51c17d8177828ef6dacc74606d317281458cf05f9e1b330327e5c4bb0cb4bb84abc69eed0e4ff9d127717d48cc30f650b24cae4498cadb9b564ded0d3f94c2898176af863d7a8045f49fcd2835c0b42ba19e8228f63b9384838116364a8a7ef6a68af0f7789be1a0a4aac326e21cf353dae01ff0086a0dbf4654e343452841f56302d2c1e8c56d647d203d03a0a668d3a3a29e8d7013d18ca9955bd9b5fb5e63c81432effd6d1922edcfba42b39f3237096a9b4965aa4341a71759859868b17ee46d2e2f24467eaedef5949334dbb0cc9faa389b271dbe8221278f575c2e052bb3607bb110dcac482d965eb2baead5bcbda0e4afe5ee022e04023cb6e086095f3d299745401cd1532a1adc590f93f737578de889e2a09601e0f211130a626bf2360afe50314b88c44ffea14450561d8ba9d9da64fd49816aaa9a168ad3cb43d1d391174cfdf33232e7c2c388bf096d2287e93a023013e2bfa9d7dec830cb78d35a67c0fe3352cb42c15ebe9285c24fb876b0ffd6e31dad404558b6e71493fa64905b1859bd4194f03635159a1f46e3c2c2311302f147a82f61e6f1209b39d7b4434b2c536f566128464a788bb2aeb5b58dca197ae12762dc194322ffd7aec2f35699fb2c69a5e9ab6ca8ef1ddbc58e85b522a36ccdf4c35fcf03e9050d7110436c14278db2f5771fae7b7cd9f3d358b61082a75724707ee879378feb4bf4033bba26288c87b67e2872c5e4821a2f319821363e0213439568d8cd41a5bd05206ddaf17f9cfd2d33ea7443f930bd5d04865088e2c72904eba57ac38ca6aa5cb8605284c7ad985bd5a46b6444280ef979ae25311a56b4dc42ff06a998c3e6c6dce2713893c6bdaccd42b5d9d67115ae42b57d01015cc05d306a3c0a0ef75f3d096259c6dcb267cb5088c11b041e314cd30e638b67ccf1e805721c9347a8d36c939651068dd885ed88225208c4e2628149d073292712acd2a7d18e1205afb07dfa5c1271965c6034616c7d0e0e5a4dbabf88486cec636f7240218b30ade506233fae45b8fac1781af1bd315431c7f42101c4d7411b958b3879ba62eb393f72713ce7f55a74d53ff05f15e66d311d37102e3a198c9c0479ec175eb8f1f2eb8e035955be4fe71c6d4e5b033caecde694ceddf881450ad694f084d3d53ce5438708f990e824b336f7fb16604ccee72bd44b721131e50d73c1523f59fe7d5ca6f0888cc9a1cd9930bce1b69f59d8b255a12880a8057364154af4dd766bbb85dac21aa81b9d5003a4e5d1ba8855158a1f7fde2fcb27ede4e38035d0f8539d60afc1e9a5d322b979bd81304b234d67a8e2f99c3e74cfed1ecbbb93afd691fd56dfb3dce7afb5b769ca03d2262862fbaeea463d80624d8941222f5c9977f8fd4e3450cc6f8f398d8a4fd6d6c33b6d0810a64acc6da5868d8d3151de3cd6ca6dcb8aec116c67e29ab3d13ad5b1673988b4ad7b3a09c240641cec2bf7991a422599bdeef922e7a8af43023ec35c93ce21aa13bfd35bff622ea8b80ecdef3491c6047c786859e18be61cd3b25672244581640c2e5978db582f08eb8e69c1e0b757969aaeeaa201501277a9b5135ea37396a1f229cbca69839f1bae42f3aadd9ace23f60cd9cbc25b3c15e7c78bad614d9cc811b6b7160bf2af39c04383ccb42cb7b8867453dbac4c68c29297e38cee11579723c70b02de48aaf17350493b3d237d358e4ad04cb852bac12556fba6ba01d1ab50f10d9305ff43be7587f4bca6bd0e80e04e19640f9fbba9152bd64ff041965271a3c66d6f988c37f30bb184adea790bdc8c8a3b84bc33c2c5178d7d13eca0d4690f4581ba81da5e404eae785cecd3027e5655b41786e3022854aee7e997463d91b8b18cd2630c8701f9b32204607467abcd4c5fb870f72799ac6c87e7f0a4a544a54eecb76133964e5d34e042fa38e0b5e32653cd9ddadea0075263a3745b56ad277a980412bba1ee484798095e28a5f943738e537f81a736e671870d41746268ef3f778e6240ac5b7d6a60afff215e637c8d1715c17f000e5ef0ff7427cc950544ea9034ff86cce916a09420eecb18de44d72cd92b06b31ee9c09e10e8dfcf72aa5a788f657eb2ec614675dce0b87b798ab3c2359d611277dd56d15d05a826d1368d282b2cb78a878fcb6c19efe8ea02716c2eb427e72faabb024d23dda3b4cea6f9b8d9ce3506cf0dab9bbedadb88fdfacf8900a4b1821388ce8daf4046cff6e051424f99710f49274644c802cc8915d6d3b57c2b197775b1decec240eae7d3c2326411ade6e80f7147244f2ae9b75704eec32a9e2a4d50534bf3e2d63e9d004e0fda6b4d8f8eaf0af44c09c1a76fa19f931984d5795fa02519f2e59deab43f7e4f1022d7612fe23eaf97ddf9cc2b0c7693c4d5258d66b21767fd2c41ff32a7401f96d950b9d7288f14be2ab799993594f982543aec9971ab43631b15ce67089f612d258f6a87fe1e268093dada4afe6e335d8f4718a0547ff1726b0266b20456b2b6e9431e531907fccd08b31cfefff1564110b76aeb51aa316ef5a941f9cd298b57bd1dffdbfcc62680e293b8feeab94aea7395389fada3bffbfaaf7fc31f326fcd25a12d283ccdf399f8abe150fe6ea49ce68e8cfdf46deaf531c666b392cb41331eea8cb88292e181f870784fce5fe51f7c5af18279129d1968775e03552bbb99b65ec2ecb4ef1515e0bb1c3907b8ced8885badd5e8e992c2b10117a861ce2c082cd54147c0af7c15ef2bd1263642b3ec6676f796ed29efabc4cb360d2c43dcb93119588e6df265c53631a8cb55bbfa34410340689dc2402374a9cbe166597edd105096c4bfa952c4700c7e1e6291733e1fe7edbe7ff8580aa0a34935948bf82d4a7e2366502cb078c0966e5551aed508103887e65bc24f13c32062afefe6e549f0750dac32ff93fcc6f4a7095d66ae4347ba282d2f375338d60b9bb7cb4b1fa859841f7c8de9537ebff0539c0e38b20a12a5f55c0769cf11169ba985bae8051966e1d0a60648cd21e4b6b8b535b5a43254210cf25ac95e6abdd2d67e19b05c378b19d9f942358997d67fa91f0429a1d7c383b524b2a3780128b8ca789d714292d247d8c06def1b1586d136305fda3c5858a942d672b78867735332488bec49c9b9591f08dc3b9cd430337d703cbaf1354f208bc654b8261257e67feba5d186164481567594384592477fff40e37301d86aa27ae1c057ab9add908e47992125f85e927688fb04ce3b309de25994f6717c6b6ef07dc19dbcf779a794a5efe354d15b8dd8369dbe37ae1377c0909a708c1647565d7211a423c939b0ab4f04eefbc105554952422f0744eeed87df6f8746fe6454bdc022fb1071df0fe8e9e7e9085e3583e69c88369013c5148b20ba0677240f6843e34ba7404614b42c49da1fd8a5f6d0eeb58ac0fa195da0e15fadd32e598cc594028d6c1da22861653c0d24a2c39b2f14af4a86fad09e64f57a37b923bd25233edc4a5aec6d3565df8c05c346ce3d4d0c49097a060bdb4c4680393067e63b0d6cf29b419a0d9cbb91e2d50c9e055f9eb5cdb4ac64e84a28afa0811834b1d0fedc99d2f0f49b50f511ff1522748ec7228e9c8e9674bb95feb62465de6d928f95912b101200ff2f8d4a9ddb8a887064ac7a86ad549e8fe2fc05be7e52ae1c8587780d1a8aa38e79a40d893990619e08ac32dcc743f74d7aa99889bd449d1a751acb1927ca6b8008486df6dcc31bbbe2d2ec6c8e24037514accd6c10b70a0703b529b0e37f87bdcfe016d848e96ae2a37722b0c249c8805d6a79126d013b37e21bce05693da68359e4ef73ca1a5bdae3b94d6e15e51365b34504f01e6328389ea5fc8807c3aed241df1f149e25a8ab8ab3687b24ad8cece1cb84ac49c4c2e13e3c8eb24156e904aad5616cee1855d710c50d306dd0c6c7922ce6277284e9ca9bf13c2078d8cca0122282ea4079e74c66c018556fb716f076c6451f1772c66723e1c2d2a69bf162bea8a1fc962750d254b86846b11fe3810a6985f43db98536d1ae83bed31d4eee5bd75f7b4af86f161028472db54ae66d50d4b6ba200b4666595708b85b261599388caa517c9c277b227d5d090b0f567c71da4f625d97fd8898bf67800248b3954452e03721327dc0a9aa30fb3d0fbda426f7e4d04d0b9c47d3eea3a00579decb249384895e66d75f9f1dd252130a1b5fd4e058d8f5b844529feadeaa92a34f77cd8926bb0d6bd7d513cec63971fa92b91e69952ef0c7d1a8287d1a1bf50d4c228172ef1e5221cb871bdc2711f668df24e18004eef642498e74f505bd271f5a6b30d93d34a60133ec9f96cc103fbd9b56d6bcb1577b4b0c2c4b15be626fa27f1c43629b7010245a77acd080a7d38b281b0723e53cc955bfc53367dd95e8bd9c77973aa539cea860758e8cd0ff9a452c5de34ac3838d0a1f7316691a817b51cff8179b03938f1ab3ef9caa562847c96fb3e92cfe9ac6472b6fa5a184ee3bc12e5b0a02f934667f2a0f6fb28893023f0a60b6f2ba26e79aaa8946330343c7eac3e693893e6063ab6fc7b2570b503e2d01368132df452aa5690918dd0ce31d5b630b85355fb151b986ac1e47a887da844751c3a8db06da445c4c6643ab71c7a33083b5cc50ae630821e3d9f99180ace390b5cc83af46844db3f9bf4fdde68f4ff69e043cefe5419564d922559d0c5e7fcbd5cf97d75e1de06cfc6748c736f7a49a54fac1304e4b876155302eca0d32f7140f577a122dc43cea821f0af37f19d5ea89fc5c486b563c45a6dd6ed08b1cd7a0a87db09194db13621fd8c8287e0a9ddc6359ea8a8107a1901f30b61c48f7ce332479f03d53def767ff52489914e9fc7eab29c2aa1691853a27a39231f9087eb3651308faf40a721a8f8c14d3caa354b67a1e2b65330ef66505ecfb87599eb28622169e652d90f23ece32052b33626079c6ba46bf6ff0348ec0ee2eeb16a93da7e31b174942a44ac05eb4fb1b3ad3c6437ed035d07a5740d081ae2b91fb04986245ad4f86f3f7140e9cf30a259ca947a08f4e008893f640a0d094ca4ba55fc6585eafc4aaa16720248cbf7f1b1e22c3ced9f5c42c6d4025c1a2e543e65cada786cf43ff3743899272d67c3675057fd33c7b2e74d21d38fbeb7585b2c28c65479a66a391cca9fb9b08b380a8a559ccd1c999b78ef5e3f9a2bbe6eb6d9f6c325b1e0590d5b448ac71c1d61285624f644542f9f3f100364ce854b60a2dee70aa9b5af75448506618b238b83af634682ffc86d20bf571b99791930364b86917daea52363897fa5a04890fc735e4824fb84634aa81d8aba63b3024b1d7a2e3491c01a1d4fb5c891aba937352c24d5d0ebde69b6df594d4a8ab8233c3678b4044a7764450be4c9c0c4b3dee5c585335ddf8979cf664b18153906de595040411a7f46576ed2360a215303f669a2cc899df10feb5510b56fb123a204b0eb51d573f745821b941d148c0b8193d74dc951f230e3de9f9160a44836bd30b8b07c7b359a0f9dad6d2a2377e8eb1a1d9f751b3dc234678e9931b3d47adb436ca1dad4b9906a06815b6070746d199613d2326f9fad5b23467e8c1eede9419cabed9bca5f1cdacef6211dcf13a152dc92c49a32e8502e6eb54dc1e4bae782323188cf2dddfb87d9e6636ae1831586096e2fd27e20a81662a5545b6b10841f27096cf6d39d0552a5a0e06a549992032e5cde0c1cfc2688cd21dca51d3fecfa9315b2957aeeb9bbcb7c5fb7bf46bb49ce5a93c039bfb79e0f55d1bb07105cdff24f96ca1faaf5c9bac75edc9b9cc5102e059242355e7be909b8861696aa93a968aede03fe61f3ec0296865ccd6bab79a50a0893367ae73ef554aa0ef34ead62d6e73bf39f695f0a76108f3fb83c018a984027cb30fb677c51dbed71a399ba112bbb3708153294658acdcf6674a9958ca8fd03dbef0a4717fefe72b57ec6d1596536e845dfd0ff98ff553d9c5c23bed3061d129ace500f09ab80f54010af84e7ef95bdad9f880d67183ab53b3d22ea292f86598cd3264853b1ec8e510f7a824f378080f50130ed4fb68d4818c41a3aa3a5e64c4a0d3e41bc42f64326352a9e63b103c589482055414d311bc76a47fdf30b3b860c1a54326bfd45470efa95ad306df23bc13c8b3e38c7f89ce0dd7847dda5ada7f8316cb4dbb42586142d05754d581fb4c9a0eb89fb6025c2e5f55959a825fc872cac095b88f9f06f5630ef9d4bb546a0b40ae27cc8d7995220bde6db397a6e60cfa07f0d5c051911ac8cdae813f4b122cc28581f851e7b2489ca7926ec82f677ac645dab0b17c67bf349ee19a03146d7982e1b56de6ff13ab922dfd2c1ad1b6cf2994a6134a4d91557929e318398f01cc39f818cfa7c14b2952cf81535e98b07011547ad4017ad5b40475989d0984c851af918aebd2a304f9b99438860e455635eb66684e2dc65d0af98b06e3d91eebae605409c0e80c51e9b2f87baf1c5d88c2b7843d180594f4fbf7f44e108949f5314c16d5b71009c0478c0c5953888147db75830f2d79ca2aea6e9adc78a48088bf22736859538ba2567b643592a0b8cd2e13b31f583e9023a805af6a35fae881d97ae5b18f48bc30ff1f1bb0b0975628da4c99ac7fb26b7fab2bc8b380d9e78780bf0b461b13f6de378b70ab0e2724442b12623c04ad028abc1c4e0800261b1f8388c9a68e4fead15326e7d25b2e11248fbc321fada3c824b1ec874b2c7187a8095b0df145665cf23517e117168d1f1299f9df4817544fbc3b03432c9c5dc312d6cde0e5442b0a2d8cee4feb6037484dac9237786cf2adc3a3df3477e8dd8de058aaac8cb65dd282d1c353443a7737d64d4739815848d0eb8668a0e8911abea19c84eec3d017d780129b5fd66319de82e331925612b284c95eca0c99f3e5edcd8fb00c5c1a68045cb26bd621fc19479990676d5e42fb4a28cde0f48453f017ba10097cd82bd680a37f3a570be88c045dda0d0a2b18a0b991681195cd63c969bcd14e3bb204c30263724ccfe8134ac90bcd7f453e7a3d05038651699a7e5ff7bc750d10408781df00b7e9215321ecd3cc103dcaef8dc57702a76e5fac96edbc3fdb8a2df3aabef3accb5ae1c4f36c244ef58dc3b1ea4d19c42c8be257938f33166030fbc3722dd08abb6030169867ff4dee33ead032e0ef174e03145f5c6ae9e60efa21ef23d7408aa3b16cba3f9b34c793becee3f193e988e54f98cb22b15fce13e0433de4dd9e764b32940774b7021f6f108a5d28df21bbfe4d7c7182716def2afa7cb455a1b84230e4cb5a9c5fa254ca41bd6074ddf3eac3771d9d202ca8e2ace1f66d74250d99f59b502833e42dc8310d88468eaa77eebfdfb35389869a2d02a7ceaa10131c5041dc62869c161cc1401946b3a09d629729c6606e100ae5485454a9b40d8a0d49eae59eebc4e505e6a4caf55b73bda0504c8a9c69837b506dfcac6393f39ae1db35744f2799f26e0674588b9bb4bd8ff7970fd4f7525145c2a1183f2164d0b3984b2e3253f63316ae4b57f8c0d0112564605aade1bcb3877acd1417d121afeae33e13b585e5df9c9caa54e9cb88d2ed6850f1454f57639d918a18cd8725519286edb899a30da433d7155aae21e8107cf036359cf31e5356a6a33055516bf130ce2076b81be911ca901fb9da5ec5752730d40c981d136256c596ef7f9602d8f607c631d9b876a399ac9769f54c089ffff0a4df4d43d731fbfed53d6a7d407be040067618f85632a37dc14ed676ff952035ea4b42b68b8ce7685abb2a7e03f0bdbaee9cd28b78e15368b3ba47d831671e1a3658be28cae912b836cb064612babfa11dd687ddca7cc63a3bee9476cdb254ee6306644077c23792cbdada5ebbd52291eea00900510f8e7bfa372c6d93ca4a44c659273492136eea13c22c50527f4fbf46db4e101c8854bcd7758afaa3e7700f59e15f4185762e51327b8921fedc1c944b4cc080e82f02f046ed0f3aaddd6da7e343752bed8556bea4c7c6dd033ab30e1486b77515273fc556c329135a0630aa03fb18f637853de0a0ee7ae2f917024afdf60323d7129a41da1307b623017058b5eb3e278fddd39f70d5f84ffe0323d29a1c75a6a0daae523366a6d19622d7c9b72b53fef3d082a1fad67fed5a24b053f92672f86d97cd33ee2949db4ab1edf3706330c83b40d65fdc277ad0b0fc0c456e9efb0cbeeadd41c30ba7c1e48af6b121a088161be988c1b1c6eabdd1c091bd3642f4224dbece905fe7f35c89e95a1da84f65fbf76ded2e3f27680070bfd13407fd0f32683ec765bbd436980c8f6085c5f46de7478801851031c86191fff17c0456d023794e69a80a8f76282c279fb4311d2348a0eaff94001b2a46da43c562a0f6bce1c4264737dbe147775ccd1c143f96e39e970a0527216fd93f6fa2eb2703c42e9e8d38a8163a2fe142b1e05c884bbc43a4c88a50dc68be252b1185fea69c38fbed898b8db3290c6f6c0248c31a92b68206c6b074a183e4f18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
