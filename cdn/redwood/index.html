<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"200aa1c0489c97968ee737e47888b18e26eadcf462211ff3decd4bd2592870ff8af10707aecfef66f95f9f7741d44a849fafa2924d0e7fe057fcaf2a4978b7268104c28463b75e4b9136875a95fb89e69e36ea2d3842f6572d0a7fd56b5af5446fccda71706dbf0ce8912e28a8f9da8828ad9f990efd3c0a7aa4679929b0f85833c3b6384f21d68d83b64422e127137710b256704e9f810265a6ab933ef728ebd250177f2ae31817f59382b95654e01004d3944459252319eca7ac155f39565eda3103fe3e1048d047e7684efa9dcea10ce0f36c9ffd5c4ca71c99833d5ee16f901f328d2248fc859bb840cb131b95cf752e2bc49d8f469e5f62013312a6e64505b269418ed4041e6630ca7e5f849df1460d8046cdfc5105b49de39880c27da197738ef33980f3a95d8efa04ff54fe7d6acdd5365691a962da5404dba744ef47647399aa91fc4ec17f83f9f5164bbe460a49929469914a62b77db0d0ba5384c95fd308e4cdd887933174bd3fc3219c41a9d52bcff4c02b3ec1ced6181a62cf9fc5685a8c3429600a382df14d6a37d751df855acdd2f6209d673feb79ab311560d8b97469a86dc450ea8a2008e932f664ce3def40840c6d115a13578ff94f010bfe91e9d0b5d4c9f77e716df8246374634782fb450d2c0c4012f45921630bb04b52c09e91174ebe9c2c1b00060cca7bb43ea7a404649a439fc3b0124a7c4740a81fa4aae8f0b0a5dc6a9d4a2af03b0624e971ef7865d86537a142981d56e4f9b9fc6c2a6120d2a8dace200079563de559ab6c0028ca758db7a830eb3ffec0af3ad9626424693f8ef1783ef2e64ae196a6b0a3cc9628495c01a33c2161120575f74d631f203419ca25995ae93b9aa1b724cfc68fa9c02fac6df7d85fa01c02dab81fdb35c5b9ce97016843c47d50d5ac3e528f0fb18275d665d5f02e045ea6a10a87f113ad9dcf121dae838d6f0917ffad037649e7ea8f471f7b32bf49e8d29d246ec86ed2f69d514049b63dc118de1b14648b6a2817f8aba767e6fd4ead980f1cb8e231c369c006095f5b6bc615a23826d64c6d5e631cc38e0c4f873e3458910238a218276808b934a904d3aaa4993f3a6fe2dee517d7c2909d297f73bd2fc0458e500e4349f3bc2ea4a95b27a518cfed0600d757312eb6736686c701fdd44dd8563ab3f48121d22f49a8451d33df5b7f5a27385f22c4a0eec48ea03c9ddc0168b50b37be4a5186bb4ee0fc8095e9354efafedef72bfc32acc62c1512577e18a34eb93c009de775955ee495ce455b653402f361e7a4b2cadc5e45a89ded12ad8935f26d8d709220f675a2c9d01115574012a85e27e3ee9222fe188e49978336bba8b1b3917c9bf085487d56b6979ee2bc4c228750b67080b36a4cca5cc26bf3193495ac68900c35e1cdcfa63ad6bb2a531ddce518eafd202369425b3cb384d5eb75867efc989c4399cf9744ac801a968fc942c030bc2607d93e6c313dd917ff6c0c109a2100449e90adabb047cbbfa85897ece89d1194dff40b482ed2f224e4e4d360eb913f415eec1a6df2ad348551321189b75cdfed0d8728c4e15cb3aec70665f32f9a754fc430e65e1bc1163eb396c3f2d0be1d527bcd8efdd62e725bb67786d0e89994e86b4f686c3ee278762b95682ad0c604ac281769901b1bd0bc529d81f297f0c0e2ed19f18a26cea75d1697678ef6bfe5ae7c68f3bc171d3930afc3a941d0030b460e0235e6ae59bd1348fd4d46670cc5f9959d91ef7c4d08e6c4ed793dac61e995b8aeea3caebf2d7b7102249c03b9f1e87a38395fd6c24d110e7ce68e1a0d4786857e774c72fcf80b9961e877dce67ad35834345bda992ad390fb74f92f8c5988cd028086b3bf9f84c20fc36f15cf418d15922f6397065c1e3e4b3cc3ceb233fafacd4e3f970564a1fc911f9d2d74942bba4f1afa26a33aaa537411ff08d2a1dca9e7a44c3d9fe1bee1f4cec9c0acff8a334a5045ec1b19041933f476eadc8555080c756637089a4435c164d17c330615a043a4fbdaa6a97759b5f8ed57ae79264e4a52e83316555f78fc532dfd18c671ed689c6d562daf2b20ae2075469f97a717f328f59379086a5a46de48806be104e05c2f1549de3824479e2c50507bdf5dd8e5c07c679489dfb2e64ed9e62d9a0cc8009b2a338c8f7b658329db552e3d2e653cc33b2421b6a924a51620a2416c69742579101d6108b3e1d947f8c1c9a010e05f2e0164e66947d6ad15eff96882da067d868eb61a516b624fd18a43fd4ac0ced8f1bf1426b45c5f51cf73731b9bb00135dbe2755eac82d09d6f993866d89367dffabd244fa26d68c7df2f496be5c772ab0114cfb8b810231873e1c7b62704cdf1b46197bf50f54bd65e5194c63b114705520777100fcbcbacd2fd3a29b4f6a4aa08b87d6ec8815231a361d3f65959171e366b25a6134f328202b903c981a7c45809ff674c1bca740c4fac7f9e3d36e7b4d7691a62df208bb287ceaee5cf5da773ab782665a59de179830219233d39af0a528e96d7781f5b46d52d21d81666fe71b94c83e6fe1a1843f0487181e5191504154ce7412c97b8a97eddf80bb50f7aa664c414ee05132e2b1570735159d837a90a3865be9e33420e14f811b89207a3c781ef20b0fac57969cf5fc66b6a4fd5881a5f5bbf65ee321c013de0ec1727fe16f20e5ed9ae7161eec7545afdd4e44939b30dbdffaf2380957e832e5f9b99a0865e042af1931c551230a5bcd4533c1efb6bd513643040a4c3e9fd240ac419606d01f165f4d1479fdea0483acaa230884a30497742907de9edea5d0d8a74aee350f5b28f08a1bc8875fb2f5d03e789a7ac4653dce85bee9870d0021e54926de5b932407f6c6b7ea8428f37ff7da8275077b6815ce55479ff88cf6cf58476220ccc910d0da9f6fe3d6d0ed4539543eafa8c9a164ad7cd9df242d67229056610b794ddd8033553bde0fbe9f279e8f9ebd5802ec184b125341ae0715d0ceb27acc05945a5a4cfcf24d5c34373784a4afafba7a93fb66da2575fc0de866d1492114a5c7874b7835ff51163ea75ad7a54db7da29c3019e34a51ac618e1e9e5b4c83118119952aad91f71727f3a70496d6f4dce8a2cada6b97b4dfc970e460c936d970260e83936ede84704a222480eb4c7307833be73f0f5e62dfa470e1e97b591232dc598c92fc49d8a2de4084c6be2c4bbd4389150f882d0dbcc5d38a3a2348d5df4bd2c22e907f57b89262101b180524a9242c7b5e2d87f78478d917a896c02bc20a36e52131c939110e8795f7ee726fb02d9e0ae17f2d46c562bf028065e2ec3200ae9773561f2855410fdf02a16f4c3ad1fb2e1874c0b31e73427025ba848725da944a788ff17946f0c22c06b9c9549484944c3ff80b92a7545c32ce2955458b920004db56f2270780dc0181720b18f529a09f725b102ce407e3d574075c4ea6a61e4411399aeaabc28d15af47ee83408912df92f04b9cd51b80cf76acf08ba2204417d4fcff5a8eb6ce28937fdc79c31aac38799fdeb63e8b2536a47ced595af68dac4e6578c30589676d83e89e5b471942270548b47556d52ade0b5b1f20b4e5d75d2e45fd690e5a13f67102c848884390c6c54d107d9dfd9868df8f8d924a891fe6824775d33ce845dcd89662e72e5a46714e8bd0c4db3cbe6154f5e5bc82bfd8caadf663e9e9bdc25264ed83b58e8c2774bfc1f3df57439d25b1ad6a88b544fb8b03c732363ec9b31bec6c9fbb874e81fcd748c44bf798ebdb52c0a7085b30081e6420da6fb472ef4203fbec676749dbd69e3256898a7edd38ab5912e4a9c7925e8b11497e9ccfa6285bc260b856b2074ba8189a9d21d63cf9a984bd817371259c15c22149f0a4d60a5e4b90fbc9cd392e8e1298c245c35f72e6edd66718e69762e406d271e25dbddb3d32b64fb053208f5eb3a90224ba61fa42058cba96c31dfeca624dc229bc6ef4ab296d0ba16ee7f91625df7d7b9a0abfdb05e34cc17ac776b4252dac1503d25d85c8a8c44efba8a24d997d299f0da8d4d69909eb2c033e18dc1348ded9241f3ff1deac8d0d75d0297ab3c08c904cf4f1b3c3182e6410820bf4986b62563f3a98cb003212308f4ffa3166e8048e833ec2c1b0b9380c94eccd98582cfdb38a791efa9c9c338ee3a63a4115d7ea781d106bb2981a727ae4dc302718e4238c48531cd897157a64fa35a426d9dac420e5429e20cb15c605212b4e5139a5c709fb43131dd62d8b784225d82318165c24fa6920cf3ed939f9e56931e8519bc8894fd0b15534837cf90e761c611d337357236a8c828652bbfafbefaee46dde463f1198278d7b7bb6b16ff49b8fd7f0ffb4d0481d2680d8c4c33b2f889e14830eaac7014db74d26bcc60635732c92440c7fb17b99a13f17f11db9211c92a7020e42ef47ae4523a03dd9caff509d5dc7b52140934890c8c043817ac71f171cf9c375ebdfc7efff8915a99290899f48427e5121a8ab40f3aa1dd0883c27a963accefc28a48bf5b05dbd75fd8f0de9e1dfe36508777d1576f2e9ca6db114c5dbf319eaa8487682cfa94183a1e5539456e3450d0192e780dc9d92269e8ecd04daa9ce62ffa954ac617f2f1c31ef4463e061a28b70bfbf647940bd4bea98e0202aaa1916749e09f1ed2e5b0f7605eca33cac5cf1d13b237acd3777ee9710a1348b5754f122f91ec14e2c44e32a43e0418445651b65661df0afa33c97abd67f829896377d76ca17517394087fc6758415da773d619b5f62a4474715d27f65560022656c092d71268dcb6dd2d4bfaa2b1cdaa8f19ac06cb208896255751421bf97eeb8da8e0edf7d9749a9251747f752ee27c9c4fbb7fdc57c8e8c49e30fee2e728f6aba54a4ee2ef2431b781e65f9d4f06757cc52fda56ac221699d8c0bcbefa418fcc85ab087755738ee9b7d897b6fd055d8fdfdac3ae7a4c2cf652c5b33f57e50953602417542dbfd7d22843e2e31da6cc4ece2395facb33380562d0c22941540f6425fbafd729b563ff76bbc14d0a883398fc145de826d76a3e2a560cc2a86c749cc7dcfae7ef8a55219e6bd8585de6c01868eabedad68acb85f733c725f79687295557a01a1f168fa8d72079fbffdeb5cbf19dcf702d8f200c3f69d6b49530a21410f44ed2de4b49a2fc29394695d6f6256da4ab491e55fe738c020a8384b250bd50c11ee6fdd588a7763cc89df5ca5430d035ce82043f50af09c72e4e1306bc1f7a6de130dd219290dd8de0269e9050ea9fafb7402db1a14dec9a1b2753fccf49c2b116b62b3c9343911dbb6d8809dbf32f7d78ce38d58a93f090436fcab757dbbc3509e77831f89f4e4900585d013aab54f0791fbfea7f6cdcdf4402f55857cf7572d7f41617399c3e4dcc19144c3ed689b44b8af8bfd25f0a1d9172377b5093fccc8793490f4e9a462317b90fc0bce54f800714fdd213c4ed76b56b101c4ba565cf1f92c222f57efb794e9ea31a0773ff84e5e456907d9d7019658de5e5808c74e0ddfa06251638bfcdadfb08e597d97710d7c153a56d20ac765302a9cd77969bf8e7e419beb220b8ac34d91a41f808f4363ec40397684b7c9e66a18725bc39b10303d7f3ecb5bb002f7f365ea8103e29f8eb9225a27b46d9d24194b591855d9c385567e55cb36904d82cccdb3bb1f809eaf1cb9fc865c3491731b1a64b18a6173c7c8e867b1792b1040c34a6f6ad0e4900c301bacfa022040fecb7b8ffd7e0e6bb1fc5f9a797199c3d09a2b92fe8e16cdac9b4fb49a7e1e5a4f876aaa6679d4a9fda2447f06e30a1e4bd057b5a5ef6ab5519b44abe7974030f9238e4804f745784a628a84dbb5ad7b77046d2022b0956677925e193f6df9ef038413652cfb16e4b673c368180e657aeed02d1701ca0535b80336d13b8fd89cfefa7714aa1d54e48d233634ba66debc4b36146d399dfa70bdd216d78ac8ffdd69d51856b61f8be769d4335bc036c7e0ffc6ab4cd6aa7c6d9ef793590a02dfeb3bc79fac3f4b879fab7aa502a53edee868441cf92bb0798b97e2a78262e479e19461b9a7bce8ca3cba9f150b662e11e31b8f730d548c2cf072302e6c412fd069219cef89eae265d9018c2d3871a53f7a32fe78857372eb7a1b16f403db7545cb3a06e4d6b4ed30b2ac70556fc2d10dc88a7a1334a896272e0aaa60e140f062045fc6ef117efe7658582073ab6ff57a2a90a6d991a7f9da6522785ca2a664f3740b87efffe4d6fb5bd2687b6f3a9cab03b5372b45a31baf57ce73969bff3c9868ece416f4ac02dc0a3211724a92d8dddcc80b2dc08ca888fa30948ee616850da0092d66036edcd5d834833eac57e9fe9df684645a65712c3759b57f0cb17c4eb5b381fd2465ed3190bd17e5eea400639746345654d43c5b384e6ffa576136bdae9ec428ec4828add01bd8ac283eb9f44b5bc74f3f02b064998c9aca8329fae850f3a46e745b2121a9fe430b019af2ee99a89d64b5fc9b14a69a419f6f94b78506b3cf80bca1425b934e4088be82875e07c3a32a33273d546ded606102b4e12af980d6928e20f19c6a58f324375394b8ccce0859bcc1a2bfe4bebdb83ebe6ccde00530375b736d9e10aa84354a5d82cca9566725c7fc4e3fbdec29f2c9e1ae327fad55b892478d63c49855c6092eae10bf4a1080290f58ffc1d4a88f5f76fb70c1fed68b6e0ca3f930fa59b3085741c2fe6387232080b7a243a9388851156fdabc341a1e815dfada79d3bb1a245e2d148f2e5ec004dfb8a99fdd93afac44776c0037785839cde928367d2ce69e5ff8ccc4e03ecc559ea7ecbf96171083a1bac908ac2319f765bed604e5fdb082da63a7485d420f1b3c7dcd6e2f4207fad7eb9348571a8069ea6e80cc7d2ca5e408c046b1593db3e7be9aa96d647e9ff080c6178c32a3df075425b2573492fdabf0d143ea90a38c732b2e6b625d921d64a85572a0fa5d210e05969504f15925b11f307dca7833c132191febcceb8be4d91d5b44d52ffda26b4fad570c6f9d5a06a106930105f7c75e79bf497c2f7c1be869957c6f733e0b3eda76b5b29a1244c8b25873d2644cfaa57e8be5373daa3aa0e92c20a31d0652b25b923b445329093a7aad40244037ec186966158d930c32884109c27cded9c0947060827ee0329d5e8bf07fc44db8ce2deb70f9951462fe0b5545156a4812ea334e07cbf31919707b8fe466fd23f4e0e123ea7cf9bfb125c27181db66c20200e20924bbda04c0b7357c754a23d9fe19815efff89fe7570d768f4941a3868935cc5981db1ba26f11286bc827a50fd04ba20314bd3299e1d18d5b2d1029c047c00ecbd8a85ecc0d13f957e2a0968b8b6fca2149e6cff4f280be7ff7449c134707476ef7649363a0678c704a5af75fac9c112bad0d10de2a0226f6af2c0aef68e95baa371c209c1930e5a4753c4fe98a17a0abfd20a747ec01cff09642dd3d6d7620a722cc81648c311e685a53e197e7ed41087b32f425ab24fe45adbec6225817a87c2dc227e4107c880471a631fd63394cb2b1b5cf5fe0835a6c1530da15028ac0f132adbc0b7201ffa51adb7231deb0c8c1ae8b5757ea2f89def338b4c7ae76488efb34741f5e1953e25550411d2b1cd393d11c2555311d9c45ac82217958bd138632defe48968a1e72fc78257aa32bb92a35669d9a2316260c737db927685370f33fd75681416eb7f254162d120d807a880310c285a2fea02442b1ae12fd4f7f9dc140442c0197bcfd7bbb843133042e974d77e34358c0f775ed9cfae21e24a40c3829278d6084abc6a58e5334e649378b4bdb1b169422af91ed7fd39d2133d21c856c3e40be0b0ea47301ca95cc3738631e8cf270d96eef733f487c0c7164aa029b8958eed0adc9f33b3a2583acc8027e742e70f1e4a0f1c1aea92ed3950c56a3f6c395bfda3a11decddf7128fb72832a0913cea1b0530085189138bdce04ba3e52e8d73283ee83a47853cd4ab4a00d120de23d5cd00b6351183a90a14dc0dfb469740a9db5a09998c91d3f4dcd4617400e16f32df241ab7a8a0cc6e77ec8a3d245488d48f65ec7e9be0a27871563302ee89618da61ff5fb688488bcbc199e1cdc23b674a36d9501add675f4e69cfdc181ba87385b2b0c0d08af9041b8aeca443f1169fb50c469eb6ebe5033ae49ca21c3419a198c88ceecb9c9db8e8ae8c6e1443c38e120f88e3bbabd6b4e65ab9e65cbf491f2300948a3682712f448d837907d292672946364070ac892a196054909414e6ed7a1abf9c62fda3ca7c7c6492f9d5e1539b9ef81b533e7119cf957cece4b7fb0eb424bcf1e9bdfdae9c245874c9403bc1fed42470c79fb51264181250de6f9c16df8cb0b73cae1cec3d0d630210af928668bd1f8748c682a368e51889310a44ba272322883b3c71e51548ea243f00aded5eabf1612d0f3e7d23cd2b6dde45cb93f6a1ece92fbd9b96ec91b5a77729e065ab8543857def467f476e74fe624e78fdfdb853a81fd2a2c3b7e4e0e75f0e97d72cc179dc98eb3d070dbf5e345461022a3bc16cc5150ca5a7b9a67682bc1545305780cdf51ad091e4e6604f16378d4a6b8af1b95dc88a944adc552def1d7c6e2e3b7437e4792eab4b23f14fd7078f7beba19f0b77256f24b12471203bbd7e4f26110c510339045e983f5d9b105702e19a5aaef9d88e0584549bac13ce457abd689440b148ecb1dace7ae69b2b2f2d0bfb983a32b815eea88238855ec5747f8eeae6a3beec36289950670499760e01e7c648883e845a53bfb0002f3db02103cc7dc2c0b6ef4ccb6ab3ffd00a0b81531ccc38c9d9a1e4b7684bf16e978f2c6ccc56a41e2f101e3c9717523aea937070e238b54a962cfa137b48e16840f5caed1438564afad285b81801a8d9bea339c38695e332be0c6bd9ba85b81b65eca742fa9a50828473534ebbd630073a0cc76bc2f579527ac8238b1c2d165200abf38c6bbedd81535403e3fcd60906aeb807845a0150b1493f7317c9b0ea2f7bee3d3a4afdf36b3486a86a18f49272d300d0e9dfb06a5ef3e41b4cf5cefb9c5a215ac83b0d15f2276ba95497facd063508727c2c503a216d98fc6cc886b505299cb592caf2f22fd5746925714fad97944aaae8e57a2ef47be41beae1cf6c3937471c1a72f25f3ca450eab457126d433002df1459d36c0cadf39f0c4a5ca7a6f90f8fb88b8e677b5c72bf251208f7c17a38479daa6267743201dd7c2ead14f98a0a2f6c968feacbaab1355abc4b9d52545a34976342b62c81d5aa5474a660743b49586d8086c9512b06f2d4f19c840728375ba8c531cebb5fed5d2e8d61d1b5e9c66346577aa2808f909f4890a7e29543a07e49627dd406c904b5562c8f5449fd6976dd52390be71f65308694625bb30074a366de95a9403507c3e55987f628fb10452c646364dfb502c7f0d54fcb423901549af28999c190687ee3157d483a2e5607274f80e25270a86418f0a6eba213bf0262ccac4236fdbec774e5cd624801d2f59e06ed6a0c64989d8152948d2d95e0724d1a302b4d1b545cc765364f0b02dad2a59bd9f9cf1fed792675158cad0a28c86f567e5f00224e8dacf260f7158939ff16a45a70e5ce8a8aa688f841a706a1f4056ad74651dd1cc6db3b1156f25888d27a12572087ebb20c8cf1dc43786634596bf449f2d50952c7ea5c3cac995b2bbf8d19fa500aaf758d3304f5b704069aa035c1e9423736d1f08afde5f469f8e627e6dc49022d70969a29cc343206890e5100f42f1da54864167d642a2651549f663a19c7b5b1db934feb6eeaed89cbc157066c954dcfaab19990fb3a4d0e7ff0e637f62f91002c2db9a9ea1e4c69616cf821ea45995e9e1e16cd954808134dcc93a02b366c1159c9e9000a45f6867107e4ed8fbc17c13cbd077bbfb1e258d1439cbf0ba7b358a79f166b57bca09f0b806d0ec4fa4fed65129f5f4317ffec0b8f3bfe680ef23fc097bc99aa7c0604402a4b18b7cd005f11691ef3bf551554d5ce4d1150c79e023177af6f7e601f5e0e79c1d73253bab08f4b3878d9f3481f211e8f9472dfd8ba06f274b9e52a52340b715cef11774ea8aff7342dcdde2c5ba088f0ba6e9cef7f57adac58e336a6e617a5a68a37068f717fa254fdff1c1a13ae0ae55117d06e068150590ba1504e00c0895b90b3d9f1137face403ad7a917bd8cfe3b0dccdf1d88df18e0896b7010258690ef56a1d20d0b9574c32b8c6079c64cb70fbfeafca619c81c4c69d2274a4fe163549fe8e7badbec45cb80913c34a54de1f3887c0cc6cd4699b295b40c96ca480db97aade31bf1c0fa969aba4fe82dcf50a1d2bc81e91995679108725dfacbbb757b3bf1008cc853085e9a4ff848184a9437ce38b1fce3e40d76dcd2f7694050a37e6a7ae7cec0e6fbc136c83b3f1c7061475746f2e9f44be831bb0d6dff8a2ce64a4c92e75268621ccda16bb29b8fb8780a1f438e139a27ffcfade3594af50f23ef72f37f1dce2337a591898bedba773f14431144b3c75c9accdfa9e368d3279e5ecf7f110e6fe6cef084a006152b9b819f25307008c212fcd519e91edb36a5a56355c766d2962a94bfd1ffefaa21fd5cf058ef165d468e49830857b746eb75925f2e9e2538a1653dc5a54d61f60bea5139292634d76d08aac2697f07ff32d6d3be03ce765b7b1d56ca32971d00307e1a2bd62c35129404f87826e1e278095e62dc46f635426bfc3599cf4395e534e4fe7ca5ac8287345f5321a9a0f3aa904f62f163ac0dc9a53e0fb45229414e5b098f2abe674bae3a02f51a2d732570a692426d0279415f0b9613fc7c30feb91f5d0a44d228907e606f44630717bcadeaece282e1aaad3fb65003ba1ed48908803f8c56da8c4f07563527c4d3c84bb331b6f785598153c5b827120c4bcf28604a6b02ca6ca8c2fd34d70ee863bab93a7fa3c0afdd8470a6de446ef9e27e176a0cce0fd1f849fefee282507f8bcd60090c29bd6ae70b4c5fce65c343c85395d01f1c78bf1ecede76907ad08a567136c0796653f2f9c1db51211c981eacf9c3235d1d89c646f95a3d3c4dad51b10a9ed3c9b2f00bb7d102daf999f8f1d5bdc3239ac6932798a1dd03c8d668318b9e7522eeba12ea282c9e3d86570b3227898b8198854dc0e128ebb5fbb2664b99761ff80517fbb33b6444de38b97308c045d1b31264cbd029fa8644f2b690946137ae25599efdb2a1423c197b333e18310b8372f1fd584882ad771776311bb0746bdf1017ecf1c6c82611d29e9a6f91030460ea3e7ba42b34f753aefefb934ef8a70a3af0556d3df479fca1f18cc435b70ab4652a16ef078c3e8c396ade71e9b42db9b87f500be15d463128f4741d7a5c2b61850c1bb6cd0237f48df7e2fc30c45ab94a677e3b22c5eeb3821333c7d6e768a390abdb893164a8737a3939f3b5d870231ca579110853575ccb7359bbe0abad2a7c92fc329463a2ce21aafcb66d27dac6817efffb744de2e3b1c481af3a74f3ac6a99e82b5059642b863ba7d81e07f8c2d1a545a66c1ec98e831d0b136142180a2cac565eea5232292409db451a022f2c9caacf03615493a3290cc50903a347acb6697b5486258fbd075d16f991db46543d5360cead110a08a1649d9d32009bc08bfa3ac0e9b42643258b9d6d3397e459e31e3921aaf2b9896ba420726a1af2b1f529d23c57322f8e0f535b68c9d32e8d65c93623254a8b1ba4b03ce54c349e24097151e5636f8aba4f61ba09ae25f5c510c3f67eceedad48c4583f7a7fe321aeaba29304685e7751ce9325f1ea65a690fcad022a5da468a5317bf60e3d81b2b1b4a41b2c91198458927fecb91de0c47fa3d63d639ee27240b8846223a44f56499d121b72b2faaa45f93e782018cad7364e93cf65b1c7a5e6e189eeba1d4db394bb22422fbea65398a54fbe47c9c1f4aaf0ab2918c3c5220d9f0331f465e99da456fa9ebdee25f758fe7ef32d4553497f3e96c9a948ab8201954132eff426b1870a59e4c7fc5e32efdecda1f255904f44d0d601b86d2a0abb79567e2f4e69b3195c5c5b07795e447063e3037393eca920c01166a0b28bd55d03c0f49c8a1b02d0c36e265c6c72c5a4762dd5d3cc3d3fd8d3b61647e429014231179db44d2a2460a9b00817e3ec9e584eca0a400dc0d42e216cf1c500ebd84f095c3e582dd87923ea6a923710ea4b0ea3422090dd14591a37746d923231d60cc2f94cd84728836343cc1089c35d37614a3326d69544e2d35a6873417e4b67071e8222d829951732b407a423fefca8c6f30e5e4e2a62ec74188a3fcb47832d525d83847bcff6535a4546a2813b3a67e44766a11808521370649581ddb189dc098a0b47315f8849b92d2f3b12a6f945b48980fa12e35ddd8b768439c7b37fee199944cbb699a2a69ee402361e7655cfbdedfcc39df8b3a837d23b9833d402308d79a89770860ef34c4ce007c9ad2b78a344a6d168bd9321d20ccab4e43a7dbf5efeb65cdec184e20154558d1e7a802405c1093c1602beaf1b6617cf53fe8a94fcfcd5bd3bdf88bfcb302094a710338a29056cca051796cfc1ae038f88444cf3eb2bc386320aecebce9d1bd4e9509d9f9fb885aa0b8b91dfa160efd249411ff7688dc22036c79bf44fdfb58133b38fa3cc730c4b79dfa8ff95cd13eaedc7598150f54d378668f24226f2694ad446267f4418cad1c853549b490d0e26b94651caa540b94e9fc0620d93818ca7f3103e28557173af70f4721f17b15b6ba5b0e0bff3cd6a6bc1f262fa9063097b84e9d47fce509682195c0ce09d34381d4e77e8d58a3f3317fe103d83826703e1f0482181df387461d2b6779e6817f167389e9650dbbb4c1a067ff27466a5172dd72bd66303fe4bedc0fd8adb5a1a8f8a84b73d34d430013e2c5930df3019d78140578aac09d3d9b45f6b1f39fb2a6cb3fa541661d03c2671c99c757803a83e2921aaa394eb9e3f302db21fe28aac59dac872129ab3bb0a784d9e2c400442fdad62f2d665113c555df5c94edce842bb9c75111e52c08c8f7a0e402995e2a895e6d503f298e28b58f38c9574a9144bf48014a4f8bf74e2a95dc01e0fc1fdcfcd696d6f48f1ac23b8c26e9b6c2ed0cc4a1f48e0ad8d8edb2dce0c13b9c3e6c48456e05b5f2c8e3f84bc1ca4a8ce507b9eed6d26975351e7732000a92388ad8ba8bb2cd96b2cc1d826399aefdd4f06d05b3cb172c133742fd86b89f37d435e81abbae007cba0e7e27372bcb66c0365dc9817ca117458883cf03eef20bdb556f9c71c195b04b7ad04c79d929fd8db904c4786f698ea922b9b43660d8841bfe769aa6d794badcd2a266ce95bc2d6c7d1ee3a3278b80410cb1972f028cd42ab81d39ffd3ddeb427b1c9ef58ec4c4c04887d970b6436f1a13bf70a889cd758a600cb0a1a910ddd398065fdd3d5a5ebd7875f3691cc35e8aaeadccf11cf260f0566eb873c804bdb295d5a07fc7371a23505c0f73a815a3db18fec40ddcc1274c56fbfb635893572c76673999b0e57290a9de4896c539c204f170d6eb1ef7ef8dd50d97dc7b3125ae561c1dda676b030b44e53d5ed21d73b2c79de80c8d1cc079b24f230eb6cf695ae4a4f791afa8cd17feb7a34a8d164a7b2d2781d5caae1d78e8492e2e09a936d8cbbbddea9a616655933ba038263ef9ca434bf23a8523149e02407c5213ae4b9bcf3cd4730f1b93653506ddaf996acd61742609587088096560157943d93d2bd26404bbd1a11ee0fddff544ca1dbc72451eade270a4cc957852904271a3e4cb7a1b0eb56f6dbfd72daa46ee676d4bba02fc26c43d5fe089bede26e5b9f957eb580e61cd850f0acf7115b298fdf3384b996c9c01fcea85f4f5f99ae4177e3e1ffdf50dc27df970862282060730be03c66e130cb871c253ab020b1853e064a8eb11b6f2be3c73c064d8aa5111b28bed2424f64d6913dab64bfa346ef34aa6655bb3b0a5783490d2687d4610290a21df08c031296497b51b9447895d6b6d81de2bc744a3d76bf519611ac5d266eb172ee171d11c3ccb53ec97f35fe7dbdd50f86db3f8a5ae7cc4b1a1b2ec2c9856d926233bbb11294d1439682c4fff41de71e72ff17cd8803767f2d2ac814b8828f1386adbce7034e82a165fa560056f4e8188c95dfb17b5d842c30265e1bd97fb43b59f232837e1cb5600327fea7c934fc04f8182d47cb3cf085272e4a89c5d76109332e765f175f6353acc57d868f9a084ac3bf803a4e3f3d0cfdabe7340b2badaeda9d48d72edb90245acfca6fad3df17331942283a9dd470544b811a79bfb0293414c1b71c846e7a16da4ad83745c14b60dbbf074f53fedba8bd566bbbd06a3a82ba62a434decc56502c22789b4209cdc2abfdf21a9e29811b4a84191bd5991bd91149e8ba5b36a8dfa550d1d8793232f73ae44db901bf5e7b3607f9c73a0a8c173dc8768fa3a4215f32a18532b53abb0bb7169d8d370ba23f9cd92034cda860e873c92e225b76a10531693d3a8fe30f75adb5116d9ea2d6dec4bc4575709264c656fa8e9dd12854f69a91bee656a640f95532d41776d06e504033fec66a998140af0da246bacf024a39d02f9c49c449363296aa1d0668f6250ea791606f0e50ec3ce40674d4d051fb576e216bf12bbc513e16a6ee77a93a659c2825de0b33bedec0de57a58211f97d86bc6c58f7368a73dad6b9503442e5f7e15eed94501d419412790f8499efc4a587a54cc07bd7e77d5fe87898855adda7ad1f5ca56095273c3ff38bfe1d74c231377da4dc0a9295e58ff6b78e80c1ec74ebd45f6bd772d7f1af8d4866f3a1399104fd5f2bd5e7472ddb53797308ae484210836343bdd7314192a215465ccd1535ccd1d1d4b60c5659fc39ef2205dd38290dd7d2acdf128b39317fe0cb4772a7da542d98c6522deec5060ed4db021c6b7570be99b821630a6c4a103c3a0b92c80062eeac430798ee41d81f1303f87751621922cd6be95b12e298124a033ba16c26e4f76785b65891dd4aba3c23c0d24b81f65776201ddfc8934c806d875f6640f9432b59b8f0d5b85b5a81575ee3e6a5a9c9f55dc94e3e4fc8d050a0d3aa526a54e78b4b4ff73ab223993181e1fab7d62f3421ee1793b1efdf64a00da48e4025b8d1788234cec38079e1bcdd3f1acb12fb51d2a278a622ed2d6bcaad75b6f458a7e2147f725936d16226d0a1873a212095a027376915c87fcdd46944dc2e4d686f6bc8b3e547da9dea25f7cbc1e77ebdd5dc935eb12dded6141265ee4c05d29d4fa3804aea853695fcdcc79d95c7a1b3b241b18f42d4ed95b60e0a357e6e3fbeb928f257283c482475da322029f2693f0ac3c968e9136d7d4269372f761252b684c4ba325e6e3b7bfcbc28448eb51533a75eb189f0c7411825f62adacc32f83d020dd9a49b6f753d0833ed41fe81507edf06248516d2dcdddc8163b5bd7b99a71e29974438d5c6bcc15e0a102bc2fa33cb11809e0b72213db631a80252b303b7ede7e8469e702f77fe6da98a1fcbbcf2c6e220baaf5f8dedd3e3693a2116420c3246acb355b83cbbfb9e05fe7f5e7814d6efad6580f966573be6ef1106df0e1af7b1c17f2508eb075ce1b2b4741a9b4d8e029a550df300c4feea22828c3f5c4b9f2ce5aa0b119ea946ea0753812c3daef16443e1ceb3a776a625350a533a71a9026e2cd74476f942fd1e3fbe8d886e7200a1ce491296b28f685e67fc59e1ece7748167f7985d35c8d889b5fee584bb4d004a60cc07b6ae4bfa1adef22af0afd2202df6d62d37fef734d8f9ecb4187ed75a9228217eba1d039de9897f822402e84991eccccba3e656bed33d98610c8e4ab5628b607120b138d37ccfe77e51633affafe3d3c1e69835a694526e923ea75e19e32d9b13c274e0c6d5be746190311c021611d972b1e61c8f453794f75c87cc22c8b933a8ee474c37db9e017cd12315e48cca3d18c5224e3a8684770f1e36f05a883858497b20f83023927e85ce2d60f82330199f0e7212ce4141e2051f020d68d8410db225f0ff7659d48a02f0408535fd3711707d805ada33ef2ccf54533e39a22faac080a16578e26c8d4c7b570143e4211f231de02a05823e7851baa8fed526b76ca8aac98634dcde67d2ac7fc3109aa147387a7e45583ac4a70dfe49a36ffc808787934ab7ab86f0964d9353d0e633fde52c0270b56e3c13a2f151476910d6b93573e888bbbcd3cecbea0a104bc8c5713bb337a8a9f1d68e863d5b46f72237988413b112ab131810a73bffae300db2dab7159ae9d2aca4537030b07609150d4cdd93a4ffcae0386c706b0a10d122ad3c94ae7a15cf158475c4e8925ef813e6fa7fb524b5130778598296927f02bab71677286b94deafd392e61e7514a68bf396bd98c6f1f058ac54b603526383ee5f4a4c7d41d9ad40c9bea918b421c26035eef61e312deaf869300848ce77d3980fc0074753481a4922600b3db8199e1fd648338c892c05bfe34ceccd98a1da083ec347e3b48993b56ff3d0bc0bcdbd2fb7fe6a70baef849cbc13113aabbc5d913cdd2731393c77598a0fc7df929e5a02178e3485a9a48c5ed8d6b93a40d69e2334750e5cab3851bddceab9a47db4713bf2b03b78100ab98f5c94565144082cd12bf5f2279e598aa84b0e9e61c7332f61ccc831d325de76b6081517576bb613b9f9bd3084c121cf5632532257ad655c708722da80e6ddeb2020c475d83c9d968c80017a030baaa4f0bd415af415bcbada20dfaf133fbae3f2145cc4c09666ca867b6fc1ca6cf6be3b525a3f8d63d95911d2bbd25c7e7caf30e1ab6421335cff0c5cc2fd083a2952ded1eedc0a36debee348bd44d841a79532479edc406c1d4808c937b0a2d59c0be8329c070a6636b3bb67136ea58ff48868876dc5ba17ebe1350419d2dbd61fc55e2a4068cbcee6e653568d56fecb8383e9c518581e913fb1ed503bfe9393712ad8feb9b7478c93c63b19aec57fb86bec13c0f249e65fe998969f3f7ddacbbf90055b1181ef58b055b47f9431d530ae1699f4d1c665bd8c6f3dc9793f99642de34ca7682de73142d66e047e8efcd2b2708fe99d34604cd07f44f60bca055edc7c82c40d27d3ea654f610c61637771ffca08d0d2c3389c8d8fb6072def112803d6357571795f46d0ebd4ffd7b9dcf4de02509bb4ca11ffbc446ea1a59c6248002a27d4276e81077944d90b7a9cc8abf0d3d1b31bc6a8355b4a850fe62d7fb7846f8c1fbc94d8fc044191580db7ba53fe4795f9d35db2058454892877e155f2f52cee555770f3ab55c0e512e4d238b5aecd834a5083e2d7bf193fea3a7e209a772dee54273a5da7c2c92113eb0efd2d685bd1556f9da577e8284e9b93c2650db2e182aebcfda3d83eda8f6bb374ad9aeb4c2a70d4155964c8540b85c20c82f46a190748e1e9392124d138a7b8dcd43831dc1cbb30be8173f509d9c787ec1bc6ea17b6be13b9f8712900aefa0f92db400bbba9552d316647b1a6637760120381270f1cf316be8f9bdee71e450b501399dd85ad65d1aa2d4caecc5ba45c888c5fe3a13cc045331412a968d1ea8a703c3058c01cbcef16ce49e35894f1057d762469a61e16b20b7513bca6a942a40f3fb8325d37d29398587784a0d16a3ad599726bec1a42b1628c7ea51fbb07865c79af94981de33ff404a16acceccded4ed7e0b9adc630f7130373fecb6196136149f7fd0fb084beee7d1a6dd5f9dfa2f0d3834319ad28f8b796c8bc2932cbf82716e1911cb53b336c7d8696717cd9197776041e8adadbb1e58bb05d6b9cfd695263350fdc5f00adb61134c3130fa2e7d90a23280a151476cef33f81709859c77423e58c217641eeb8d71348770f6b6a50ff6f8e79bde4717a551dcc5a04e43c7ca090095f72fc04ddf2a03772800b805f997240da604220421bd379e86372cc6f06163454bb599c38f6b76c689222b919ed9c6ef60f480c8215ad9fae3ca5304bd767f95d1ef5f9baf7d13384dcb8c9e9108a73b4437602bb7b951eafc9043dd93e7b9e1fb09e0ccad306ae2508f656cd775e2ba44dd089b25575535f7b28ef7bc0fbf73721ce6ff908","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
