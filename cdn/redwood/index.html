<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecb3d3056323dcd38f8e49bfad1a9201f5640e74d50608537ad4e4954172dfcf2bd0c877309741040e2d44360214f300437a8ca6cff698dfaf550fe90c19bf1a9ad092b07ecf89b9622662ff9459d5bb9df75b6d847c548c9bd0ce737eef2712f5a59ab3b62a28e3501d43c6bccf12cd1a351678fd4b3d4d5d4854906773cd0b6db4b89002d6448ecdcfe496a13d614415e32b9b38f8fef416d6a9228a1f44a3361adc5f095ef9f95239c8f77fef4aa78f40bda31b8a8b3887346ecd1e6a66c7f9862886f8400c8ca8d89cc919fbbb76da5a0da83551c6cab6099d77c3b274cb21372821acfd290b3b5bac34cbd8e45f2a206c399901623846a8c740fbf02d44508875f90c038370fba1db59fdec64747c581e40b2e453a8e07c4c82a852e2bb2da45f488ced1ebda8029cc0793a9c75fbea20d0e28352f048c3f60c50288ecfcb591882bbd247201e3d8b1a7f86e9697faff6ced0d21aab27952ae9a5857db700c609ab6a75540e3d6965faadd0155b3420b66a7cdb5003ff4a38c9e2b3088fedb878acce67799dd2b64307fbea53447bfa08b5083be581cd7119f98d8eb84b9f2f4a2f7b4200de2d625219b8dfc03d243f725f1ac698ee233c768d3ac46bec88378e0bad62edbfbeb852656cfa80af11ac23b538f659d9e5da7d743c3203cff01330850755367eb5c626b6313279fb22bee8c193b98eda8a3ae3206ce2f4b4b48183f3b4d549d9057ecb2e4a5386446515884161a435fda12cf818f1149d09fa73836879d68d1c569bbd209433fa0542594a239ae96122adb93e801bea69345c5b5002fc880ba31418149c8e7d89815d49369eb4725f4d081739015f41f1137512ad69327a7b09860829d0baa6f6f1b1816d3550e56b67f7f95c3e7b10cb83632dc74e93c69083fe6102b7b4ef92e2098a3ad2c8865151271086c72b113738d0a0978ab9dfdf68cc23704abc5c7c53c99be2f6c9a74d58eed17333e37fa7f57439b8d5f62b009b8ef511545592bb40b9629ac178b6356ee6a83df18742bd94babf3a1314bb35eabfa3557a25b85b121d7957d782ceca4bc88f69109881b56c690077ad9777891be6edcc32cd748b51e20676fe9b9219085b9c7938ef250bdc0604e930c50cae3a8cd36f105143fdc4f04019c37b6629761918974e25fa904ae1eda26a8a6e1c4ced571a843e585cf3cf0ba9354205eb930b12df7dc30dca3aed5a9383994c209ec32cad0a096b09008a24072c341c6091ba1b77ec289732281ea7c6d7d7f3c50918988302b08073111d3d7fb100f8f680912007eca24e669811ba4bb318a71965571f0fffbda1d7aefe886c5bdecfc412bbdc165ed7900b11427d29011d5440b38f930c0dcb1c1f39d870f6a0c8b4003ca4fb809890109bc55b1ca19588dff5c9b74a0755037c08d243f153e78470787eb9c5977175dd9d5763a9d2fbf8d64e9b48b2e693ce1b2388beaf4d4e2ae384822d4e48c83f5999330493e6a636dd3331a12161fee9322157d22bc57bf0af6e6d2319581a252cfdacd214f4a1f05c5d8b0ac05b0aed60c8d0d834f8b6c74f6a38a746dee8eb6123da9184672885c209b3b833dd70482cffb699dd002cff6d99e79b4536de8fd2e4cabb0da216b4f397bae46557172c4f198f1a4d2ff20c626e9c1ca018b5e557f710de5aec248b9513c916576468b1979a518b964bb0e8e3408e4ac2811c86865a5302aa94c36e167572d3e96ccba77464bb8ff547036632670ccf0a0239eda4262046b8c1c90e45cab4d89b4abf85fc9189e677810c6d80013a42af2ada702f3f59ff0ee288987640bb10aab10f79b4a2f92c2389a6eadbd8eccf0b3be09bc367a8b61ef5ce276bb6efd9a3540a4de3d94b6d2a422d84ae1cc90353c7a69d5cf74fbe5eeab97a580b39ce3828d9ba7fefc1a9c8b1e5b0ccac87dd3b70967a8112fc93b4bb0358aba7ed957af1dfa04e4346746dbe69a1985ff148bb7aa039d7e8cf09bc162e24e1e1371d1e096b9f9083770c006136cd872ede1f4c2f474151f84ed6fabb97e402ced69551b53dabede97da64d7b30829c27eb568ee7775240b39de11104854337215e988e024312466be1ab6a5af9274d813d053f0dad0bb275891b641fcfc1dd61401ca7f029cc4a4dbe4d61d0ae623a228c335c234b016a2b14278b1b8f54df4be3f139af15394250e136756faf063557478436988744cb3f6215ce821888165320cb9f8bf6e42cad537a3f0f32b64eb94a621fd1409d811e73a2b3dc8fc9428a344d8d2416c28e8c390e67fc157b90ddbafd3a084e78c986b332068ce43973d6a6f06a1b45f8739144c35d34fd401c551ac36b95ea438cb716468b8880cd0db6d4dd6899c1f0df54b3e551bc94a264a02758d6525dd028e524fbc495ad8b97b109e9a38e3ceae669c4fc28f5e34804d7d51ad22a9c37cf73c532a78eb8a8cb25b03175d04bc28fbff5679311036a28e9683a8d69dbacd2037c24735b97a6c7135e53c5949b1f590ccb736dcd0ebcf7ab76a06d09937ffbf9aea7bfd00aebaea9fb623ec40984789085f3152e6b68421a53b90d16258aafad2bc36065e1b0500706569799a269332e9cdb34398e2bbfeb7e2fb4c9d3de92ad420122f7dd542a121cf39273c7cbb3f752e172c434cd28a89e0b93c0b6dac95d580563b717f288262ebd05ff3a98705d3ea46df711ee10e7c861427d362568e26f630c974ff26a983b7918331de5971c3907aa0984f6f3b1736699f970ee9a9894c7c637da3592da6b06b84e6e79ac3b5e9e599b68e93fda7b376852d6f183ceb0d2edcdce10a5dfc66dd3d079596067fcb73946fdecd6cf8fb7af1e2418d84894975be2822593f3155ed3de359370c94850ec16105bd51f0ef268b21cb676dd2b36d779d98b62d72e882975b603d5254c99a4935d64a422c1e69e96be8fb60be1a8a6b1fa04923dfddf07b1209a1abf0d89616e65c0f01b48b333faa4b94af43aee7fd467ee8b7f488a88b2a0d449ab8e43d1e4522d0a3d3141d1e2429d1fdc7bb35803d711acf734b316a923131af0fb607039473e8f490e5c1a0a0154ed38312a69ed0c0334b7cd4dbdd331cf6b9054bce272db112a28ebaa57b79b3eeb95d9c59c0ab7fd94cddc6034e25d67e6dcbb57a63e1749cd581e97ce9c342adcbc167be6f3fa8faf8fb7574c2663c7aad27e3d8c0a48549ab7550a0701b77fcf4e5ae8c3aabbced440c9550720049d3977d274468f177febd74d62b7098c1807c1ebc10966a312fc194dbea826eb7d6060a34a562b3d8a43ca6282a394dda0aa36867672a119f41f8ac906bb0f73ae9c2839839c3c77a634253741509779047b15b6c024659cb641506c477b9bd42f1ac265d67ecb12962b9c51b4c44a943b022848abc40c56aec8cb71a2ce3375ac3c1a2560e9538b7c9736830749a98c1c2b5af8723107b4e32ceb9908853a2e5105c0e966cd7be0b1e1e06c35f9afe6e286a026997232a196a5bba725298e8578279989bb6ad3e739d8ab06cb8e5efb55d473c11de1d386c122eb639ca57b4c5ec14b8c2ee4c7c3100fad3e5bb01eca9437408fb9e1e88091bfa09c5a5f2e79d99039bd89a35757931c09897e75ce0f796ad85fc80e6bedaf1cb7f795e32bece1a0e800961efb790cd5bc9e6ab92af6d6ce8e1123afc25f9611e04cf84b43036da7a48e94764911b52ad0cc603baff13d5642e2115a6430d3d0ef36fcc38d0e515a19b3994ecae359d265c954bc9cf3e1f1dccb49bb1e18ce5fb58d585e3225f02dadf6bf219e00113f415db83cb5853da6cba767d1d47aeff140361d09816db386fbb308e369eef197134b444af39e3c79564572fcbc310fb92f9c8cd371f454646231098f4722b41d3df6e5a081cd378084a4808bd75d2819e7a9d5e22599bdc22afec1940184e4f00bca8c5d002444bff6ace067d3c49c534e72c2a3c5af83ad93022566d0fdadd39a5ebaa7330a3ff9deaf299105de005a43a7f93721020231c35a4dcc92f02ecccf4390fb64a99dacde660d064be145c3b187fa551f2193fccc935b9ba08516564d1e57702e8dea560f0dbaabf83c4416522abdd39f448a35afd51ed34c4e7b7b6d579c1b2bad6feda7d0424725934ef6ffcb978752a2e3d920bd71bd0dfd2e7e571f7e7587175bbef25025887d500d80cdec1d80647e325e7ddebbfcc33b384de75c422f17a3355d6a9c634912a2065f944a5d173e907b0a94be946b3335f1e3ff0a9dea25b68c28c894138fa021e8043b7c225a0f98b1af023bb3307b7dda803e5e1fa5bd89574998624e7cf39ce1c05ca2a3c4e4a76f16fab0d2687e9f5c30237346c70bf4a2b7b3192a7fda0cb16f974cd0b311d2e74a49574a1c2fe5f39c7f4cce1bd65d54024380e5dd86561820fee12341360cdc89786da5616796f5bc8cb9ddb392ead298fd429df931e15c17c26bf9704c53de18459fc8c7b293fb9208dcdeb6a3a42c07c3b92bc80d929eb4e9fb363232bccf0a112f976b5f088783a658fd368c0ebbf426db8921efbede7af619d8b54d7cd5f8c1c184a5fdb91452bf69ee7b0803ca76d717eb0acdc927a0e4b81941e1747af71b51375a7bab713444d2e022b2bb0553150d362008fa7ad299548f56c87ce2a9ff8ccd2ebf0dc368812936f88edc4f4ad22b93d1a1116553aee120fed98dde5e129f690ce89889f4c4f5f0ea441fdbf96bb92cfacf4c5c8a7d8e963bdadb9ecf13aa97e53cc5a63cd2013255a1c45778b812e32b98727335e227afd432418a150dd1c2903afc8bd26a453b65e973111d9fbe0b4ef5efee1049fe9cc93efa43206a1fbbde25d6ce7850a619b6c406f7db44405d593701f7f99197144cd38e07fb0d6c17339966d1cdb94560299b9bf37b2440ad0f2e03713c5d8800e96633dd208d3153de2937d6e94118d13238b6bb399bd175f70b017249ee52ef3a26429912b04a3f8520a8beeb72fc76e16a6306084693bec6214e506aef243f9b2681d92d9a01c26129f6bcb9bce49e911a1f154d1a98110faa62153dd8e06164ed461eaac0bc05a1e3b836d9e75e5d26a1a34f3ec71e774806d9a8f927842bc9b4baae359639e1a38f30207fda53a6b559f39d22781bb2d846f91cb4cc3b735c75f8cce53a1f6b0ba61a0c397454f25b51c2ae8f4cb61e1d0bc269da1e85f3c0653b0fe98ecad82643f5c11e02c53906a5e0180b5bfd3d599d202940943168fb0e4a6d19ab53890d81e1c64061b208fd8a779afe2118d247085ec0206256de5707d4c877dce0bbf38932154b1b849d527e6347e07b23d014d8e3a236ab6be83d4a473ca9f2bd2fc932b732e098f7910690dc26e933a78f6433b363a3b1dc7480b7ce572e6d1a0e6781eaaa5ecdb2ee2c1c8dd88b4e3cd760cdcbee6ffc9b4bba75efbf19fad3e3a774cdc5ef436b87923b595b7b2db7ab0165c39dddf16dfb84a7328028aa5e2aa04dec2de32b603e0719d1d855812cb4d916c3857989ff946a59738b6ac1c55e519d00b7a0395b7cd79dec3b67fc1dc4702e20edefb7754a92cb31dfe3b20473cb57ad23719282439fe6a5d65bac898541270e86ab6e0e78e1e263666f3da6b892d262bc9bf149351d3291078b34886e00fc9284cb10eb13cb7820925bea1bca4268c77e94917db5fad780e77b6469bbb6c606de11b187baf728f9980ea8efa885dae833121c4b35c53d2824c33f54a765be2cd4d048d40b80ba5da41aa0dbe87dd6ac6e3afa89ae5ff6878d640d407906de052b8b034938886622a4c5c95e063b5708a4b645efa0eeafad7a813707b3e0650e67a13b2cd70e13f4dae7518c9e37bc880ffd2982e120f4b72f152a27d9ebffce9912272b6ccc889adb5c943caadfffce3373fb404ac229f82d3e03b819c888211077fcf0b9e08bf6d30e2c0be298bc8684f82981e4c25ed54b15cb14585a24cc4b5805940e01e307d2e89ff0ccecbf58c3d7ea0e9fe5c61e6df86b15d45335dfce92527b4bc9fafa04b8c897ade040d5f8c6003640e2cd3adbb983b5dfbba91020f22260cdf5e20cca428063b9a85268ea89af656a4d8817c2735120608680f2c54ee0eaf0035fdb32b3732a5b0d82dafb8f98b20703097785706370b4fc7205ab2f4c434d008aff25996035db293fd6791de52469243653a4ba81dc26b3ed26fda0b2d6f85bba28c74440d5f1bff1b5ddd5fbf1fb2e369b33c0cbcdd162cb53819a062fb54b7d1d40cc773629c71a7e47222bf713014c598552d8e2136c73e6013fda8680e3ca17dc7d98f50f9b30f2f87609047b38d5269534bb68dbc3486db28eb505c7169ee7b08541f6af4cee614699ceda368b3b25da8c625cc7437d206c1206448472460e6e958cabecdf29b245831db6dd3f7cb8911070b848d29160b4f9bffe776c2a957b6e797e1a5f84b67651fe694eaf48953f08ae5dc7a81933c0940cbcb7d80c24d95b7bb1164766cdf194ba80ab7f29095938b3a0b2fd6829e841510a07c9feaafb961ca6673bf2525fd31c3c74029c9f92f551c9cbfd59b18f3a6b146c4a087f6a2010cb7dfcb05e1322d1e894bcf78aecb5bdcf69f3df0ca69ebbb2e9186aa376ff9c37b3add8854555a2587b5c491b29e98e2d7d8a7c58c2dbeba4ce6d5efc58d9f84eac667e6694ce01de982cd7a944b9fca51e94c17a9162c6d5adca1f5e1ea05381af02af0d230ecd7f23c21795c23ad0fc8027bd860bcab2583a0cacb4ec7d6680c1032cec02dcb3deebf972616641a127eaa0d1ea9fbc572cc50c0d09fda882c4cd5782073b144362f921d8421aeff761a3c9ee9a14a13d45df2c224fdf2fb221b28d9eb35a5de6c7dbfe7cb1376597b1f7c35e89d163f2e363fe9b625a0f66d04048a950f44f8ebdddf026f2504942137a40ac3ddc23e99c7ef750f554800e8b486ed92793435b85626062e55cda1e2cfc86a8c616f363b3a37b54538d5ec9e65e7ffc8a3c39e82dab117a88a4b1f753f9dd43dd7e301b9b18697d46f34290af1fcfc4f293109b4ca2f63a0c096227090820853f4adca5beac0c1d833e08d0bcc9cd2664361aaa2244c24d96af565f3f7c8a874d3e8754b0ebf8d53b9701846db14f269f14fa875ca8b7dcc033360f61dec39392ba385685912951c253eda1ce9c56edfba0057c4dfc34ee804dc6a057e09a2bdc66ca4be52faa3a647ffc468133cac389b603006e7f4354eb218ab40b8e6e904765a6f72c00ad3794cb9ea3ee8bc39bb3b29e1d7ccda6e1274e04c30e84adad00def2e00222fe0f11a58925bb81ace5a81c8e558364899d0c993e53f6f478d9afa29f9f46fe651df61e02b286bf4333d5cc52a709b8cc359bdf6b38873c2cad644d013d83c3f9aaa732b274fcf4fe5f01f7bdba835dbd784b59b053c17cd801e516c6dc64ef727c2cfb141d47dca115d84c4851e2d0091821d97adf64b06d22c790929167f9c79885b7380b3e80a6bf8356eb6dfc99a0caebe081e1f8e891aa30c11e3eac5f5dae180feaa655a8be1f0ebeb970cb7d7092abcdda3e34353857f41ab3fcd00806b7d4c023d99f32a13a32f9044494873596a208725ab3aa89743cff21e3930ee507eaaf5ad60a4d3e7261b1041d81bbb133263821ea229aebc1b822a8522026a31022aceb2cdb03f5f4d591e1fda6361bb3ea66354d85185a413ce874f07c97cffdb394025bd65a785967cd3af1653183022ec2c3ac9655e2b03f863a48e3423685c71ed541de5cb1613d1bc67c5787872fa5cf37e8e400840a2258a1246d5579612b241f3391f9a2fe09a0cd253dd39794689431b2f38a963aaeb3f473f591e7d933ff16a0a2469d1e0a0670b37b291873f2e9450df36cdcf15b0336795b6be2e92563786f480757365264d06f2aa908df47eb7123bbcf733b9f6dfbd8ba847b55a2fff134cfb602dcf5018c2c6cea60a7b7dfb8e02f097898167f634cefbb5d83b5322d28f6b066e600011ffa590db6a8f2fd908f571a22c8ffd96f83a5f84039fa8dc863656c929ecc5ca1ea358d5c2afb0bf0ea6eece2f25d76eb29d53c56c8dc4093d3e5acc725231bfd36977ac2e621baee74c37350394bc24853b47a58a8e173fa9dbacfaec1d68c0887cb85a5335865ade757b0a568200e1679c0ddf972ace869f211be16b56a6473aa3ca2edd21ad8eb8670d990b9e82de4d1e915b1cbcaa48083431ac91e83d8c5061747299f73c39582d2f66bab0f0b9105a42fc949016397e58f39d03a49b31f395d68726d8a9e5c3b73b3b8b0f68ce610b7f87aa60a8763429534576007d0517b9e485a4f4dd5810ef5ce2f2958ee4223c2a06389fa02146798fc7e32481bdde617f24b4d991e0237b79d80ef3a5617e17b4f16897fe11ae57c74ec247ac6324f8fe51a04900d8b32704ce66caf412eaf7b10f1c88d8647c89b6210676de3a94c4f2f8c31a89b118676cfae54808e417db24ef0a32f6eb38f49c42d2eae14076b4400fe05783e795f02534c91f7aa3296b9cb9771b0e21e5201351a950614203893d1ede6f5e6b65893a8d6c00218ba0c8e36ae7ebd801d0eb4938f3b78d0c168d873662d7eb259a88ffa0e30877f1b028bb23b7815aad66201224c510ed97a82535aaccbfd8a68aa3766fb8270e243a64af4716958bc8a9867273d732527c3d0b1b61f8ad8ee2c70f239145535aa24309cc19bfaafcc1e9f9c269d3292df7a7016926e2955c091a1c997549da12405f287dd3b87fb2708364ad16e1c75a02bcf98565ee24b2997cbb42b8cfdc6aed6459822ed171b6c88d20086f08df483e0ba50ca56786e828ef4992f9ac30d052058d84bdb9320d4aee9114eac5b0b745423c1691953d9e926fe3f060bb6db574efc733d92d31d08a380b6cc78cb52aff98d16a771f55d1da60a1ac7a0bacc88dcfd45aabfa2ba33332e11ef540ee53c1d493b964efcebed1c152c0acbfb285e95b9928a640858d78c8aa96bc93dfdd451329f5cea769fc06472b164b9b59816d0ce76713b6ae1444454eb806d377e36d13e0e103ac76875aa6f513a45430856b064b331ef80654486a7f9279487723a65fb09a27f4c61b38bc78da61603f00f8033a4e112df240931c404c959d1ba59d451239be839e8fd01e9acc964c61edb4b53b8768d9b07ed6db72527bcf31f6a6e1dffdce9f153d01c0499365d738b2128013ac2723ca247fac7ea3e9b0a605bfd4d457bba1c787616d2ee167ba003e556c151d0c7932ec50d03243c2532690e44544b9005c94be15278f348b7b7b285869896872fb388a8c16d102b7a42b2b2e915dae8a6f827ef4a4fd611f75fe1bf7cc2ede7abed1b310ab5009775cf5233fb79a633dcb185fad613b6e4ece38988d4a53d9080b01ccd232161f2a14f87c228401f0084f5b8c8629c33356817a7231ef82670d2d8cee01ba0d4a7b5d7c703f35f6063ccc2ace492b2ad9cfbdebafcb76762b4012d6effb890f062a0841ff6d476c6029b77e89d5e7c2d4e9fd12762e513fecfd68e64d8bcbdf786c5d870f1908eeb9e7a2529f95f952805e0bd92bcdc8d85e133b3ac0a16fc6764396bf9a0f12f889aba4692b184fb0c60994c1d2a9fbe77b5f2ae26b973642013b128d1a94624b36821e734ea9b1c210ca42fd821293183cc847b04f3e3354c5b9146c61675791ac4127a25f907d0867e98c574a6467eb246cb871feb9478d4c43b02397f28f629c8fccb52bac33b2daf58e7fc89312c39bf6e8a6e3eb81f0d3ac28c53c5a0e66ebd6af396e64a6b66e428f74259f12edbc1c7254b0bb09119d6f8be912a170e2a8463f1bca4e4d74181b1a5cdd39d3fbf6ddcc7e31438489b3ab13b84452fd5065e6c69bbddffff1d53529c66fa2cbb0d60c4e4af1b8f2d32fae4ee415890f691d9647693af59f1a02afb78471a02853ce8e65214dbe76a83dacd8062aaf9b38ecf2925465ea384fe4d9d364bbe3c09aa759d566613dacd84665c75829da7c7b7c128adc2b95cd706d49a3a0af707b6767f599002c1fdc4dc143d66163907c09ceb3231328b601ac54913b605e1cdb25e31d9c40410f179720f5b1e7b30a452744fbbef7dd84794bd0c1fdacc8203741267bd4c43b78bf5e9d33f26e7f1fb4d26f3b9ca4506f0211783700060729ee51f0809c26f9e25ba18cfff166a6352fbdb79bb17b90a31d7266cbeccd6d3cdcaeef09e5afea147e30150f2abe8d9b9cbbdc14a661df4bede027b08abea84d508b71c62d461e035e6814e248a887ed31ab78716fb0a79072f9857fc213fd942ab7cbdbf57015361a63296074c819da59d940d9ac24540fac881871e3037e29553acd6d7a1a048081a3d06b3b81d90eb357b82b0596af79890ebed8238ffbe1c06b260d2488ef11a3eed06fdaa619e7180da5ca0408e0cd4ecd04135e0e0179bb75ea69e9e4d69881265357600af50077146d09c1d8694ee29e2caa0ac74692eb2e2477751309ccf28b03377300c448c3eb3b2aa6a02b4ab492551fa87da9db10daf3bff5a3e2ffe2e8ab4dc43bb410a3bc54cd4d6ef2d456eef5a54ba0163acc05d79c86653a213b3997fc475a51325d224e3d640f549529b00920d49e7e5e8b5c7533f227bfb855a0644a5ee7602e07ca97e8c52843e4b83f4fa98f683a84fa7113bf0ee1740ea4d61ece269aac74750eb76d0379e6126ca21843133be79394cc0fd0cf8538c71bf87983d0c3a0f05abd9c168b645abf1f6a541ed921da8154bc3e8229eaaf8842542b59f5d25a7e901236a3da0ab244be7a147faa9506bf1e7a8128210cf049cbc845a5c26f08684b1b2534373780a02fdf6802a09cba1979eca560c51e26da69961ed0d09e7f33fc01ceb8200f3d7f82582998ba5e9cb44be27d8b07fda3b606aaddb3d4af55049932b1ab4994d627a2aa17b6d69bfaa5102f9a0b46db65b03295099db15eda662447cd2b6be2c22afad86fe2a67788a358371c15a3ee48691aa69f743852b47dacd0f544c2fb03f4fd565a22a46d6633a9d4a6265c9f8bda4507b0f7fe6fbb20f688d573f646bf5d8a8ceeb942bfde405c5746891cdc3d5cd163b411fdf9c09192c6efbeaf97c86694c35343b1bcbba66fa26defdd0ebb15c6c875e1c648b1c66e1d884e6dda5a85f6fd89b393d52589be435b9cc4726d7675c37e53bad2df30c0694e17595de92bc6e77bdfc99bf68f008dec6ffbf94729acf58da5d28d8e31e31c97495186d1cbb775fbb1a79fe7aa94bfb9837fdd6db2c0006c7acb01e76b00333db794cac8d7e0d035de06ac50c62430ca20138a57ff9e7506b7ae3372c47d8a415df63d4c4803a43a128a56b5ae4e6fecae3cba7075c42e5f7d55a01a47a06a4bca930c3dbcf58f22bdf1f09220063a70687bf3740fe7a3eefcf73a8aa2b3fb3e2ec4811596edd7745112a29a9e125c16f911a6b39efce55b7a2a3d76e38258b1cdf4796196a46137df3d6b4363b00791a557082dca90f1e3040539948bbdcae2601745ed84806d67d2c1e6e46b31eff62ac1b62f30e1e86e608a29d748a2913eafcd92e814d38c2fa5848c6b3f53ce91783bccaa4b1b668a4bf9463335de0792802fc9a9c12fdf46a27fd2e4f6e4b59cade9858690349d704fe0e6dba977877203c4ea950adfc1ea5c8b7ec8e6a489c4102b77e0913ff89a306a19e373fc55329783ec4b56bf35629130e001b97788d8abb9f0cca763e29f3b71db7c83f908fded9d110b343bbbe15b7c35cdfbd66a2aeef8a21b666d1fe51e2cdaab0c7e509364e7b3e994afffffab73e12bf05fa8a7bb0109bb25a498313e8b48bf2eed8ebbba5378771a8f2b07f637587bc11235c07baa388602dd6683f37706022b9fd80186799733c2aa59931f8b6b400a4d20bfb861768cf4921cb6df93c236ffbc1fc1cd7a1c5b8ed0bdd99eab0d130683657938a563efd5ad356b46523f49a6730940237ce551c016b0ce87ad8b27f0be225751f6fec93fc3134c670cb72be24c15a57d9f2e3b482112bbab643e167f7d71893f6c9e86fe14d7a3790559184d925968eb41d4948485a0eba8b2be5638f0d336740d1b43a93aafa02ae4856e4f93da335f48b321c1ae1b5e0b6b0fc0705abb3af0be5ae094d2b5b22ec4dea6c328762cc67131dbe092ba0261b98e3c75f639b0c15ba52d0489564574a33c065d234148e5c6a3d4fd36508442cc27d24289c7ef41d9f0cec2cbd973865105a979cbb728aaf70979c31c5930f08421834b94340ffec155a1bd99b5d035f0cafec07750583d403908cc5901e83043b2dc758c593667d5f9c45881caf778c4ce87ce757761ea13c8a1f0c9b7c777031fd177e09e1745eff45b2cf1ebc120b4eff28e92c8e8ecdb358b12d3fd929f8faaaa21e12255e506dc27b2de039e5986abde2552e3f4bfefdc9d41ca093cf3d3a7092ab5698225e78f0a21aef81f5b876a7142930e19daaeb60421ed3cb324e71162aa6c82dec897df322e854bc389053a89bf2f8b8d73b2729fcc38fee2635ffa6ac1d737b46c6d53ebc9782d9ad7e78bc90d169fbe2c53cefe8831bbf5b97b2514e6ed695de17f75c598bcba4a27343a3ea2d11b9c50497455e112eaf5e47c24afdf1e9ab15a03624526e54af8fc35f7204e735bfdb5aba9e9bb632927938ab61c44eb0a3ec184f26ced9a39f590d17bdd92353eec9c5c728362975b57a8643c53308ed562f8e3eb0ff5844088d81dd92ce73a0658e49268816dd066b271c35350d23f34b0a403fcc269a9582c0ccd94fe48e293569ad9bbd7298d72e20eec9ecc099fb34409ced8494ac5d9d1c960cf35d81bc2cd8a665567cedc9c167b7a3789624dfb04b016489e86af4a8d14165421b35aa76cc2b85c817eac0fb6c849cf696842259cd0afa03e7b43ab84a344c03daf0c9723a56165bcc46ec1394167e53609b52a9686ff99d7b8e2f82bd0a47d77fea4c01cae20a2152000f5f1d9e5fb996997344b1f26226975e49284824239e8823555f9b28d57724c4446c91a6032188a095f8f5c586c80ba93b0eed1644b170391eb496ef81f395be8e0c95eca2842de3efe7462a3cbd8556fda909b464393b9a5fda26fbd498e74486eab4741608f3925fbe6a58fc0bccb63e758daac9b2b1a19c264a2e4be69a19ba0b1366a7d8ece11b74985c6837525ef4cbdf1b44aa29756edf76ebc87572a35195aa9027970371e9ba5b14c2971f4bd763ee1f76a1fc57f08265e3e66567c8a90c6996e4c2d0cb08ed9cf4d37fa09d329d96a38ddf557dfe55ebc1c33d619d53c96ff87b5fbf149bb3b3ee77014370f9c977856591746ed0e4b9c58ce5891caf8ff0ba6259730f52b6bb4e2eda3eb81a18b975ffdaae980daedc9eda5e0dff0750b3d292573a5a737a18de9b6729cb3255bf8e6ecbec6417084e24c4fa10f19414e731f65cb2e7f54203fa821d36f17647f3628f2da3220908b0003ab27fed38e51e6203d699f7fcebca156180f4d7c4d0824a902c01c404bdeacc0b6b51424577f0d9effa0ee3ca545befce4e655af9869d15f8578f102033a7f3d4b9046cd75c38f82b5fe7041d3dfc91d75ea468749f76a1384713f0d76d4ea798b3732f4e115276f7f0cb72ff19f84629030116ed93da58d4fb135a905547ca64db7358c0b9d8944e43233d08e7382578775df9cfed018e2c2f482fc808083a82a0f12663e4bfb8ed028a6e0ee3681fffafda24ed9667f68438b99c07cc7be14fba3b704d22e9b4bde8eff04e6ed21bb200f12108239bb44f2031c7e9a2028385a0c756d6d528c843d60494b88b0db509a02783b776e5fb0185011a4bfd88c87f33968293fbab47fa24a67052a307d1bddc5887705e38177575f0edbd8bff007ed94f7f8c2f7541fdd258c20a3d504551a55c26d79c8034b73a7e14b8377b162b8c1f1b7b7582dbfbdf8804bf29e1f4e2f5d893b7d3b8c28f817d36c4292d35c44a585815950d82d436caa279be01a259fc0e2ebf950518e9224774c9df7e7d4fc7231b3b4629eca2ceff901e77b201f0ca8797ad19fe96772de55675e3bb6cb435840f7b1796937d10da0391e7d6834bb2c65c0102f3ed8f371d2fe3d44481d445a9fd0f3e2b1cc860a3f75211a23a9f2450a6c0c7aec263ee170074c70b1785d66a0e345c71596fb222e479f7994e6c2886727ad2b0ccc701059794f66c7d44ccce3652e1d0e727cf1b40724c909523a06abbd633a7b8d49f67b1219a49552170f3693fd45e7ac936d37b9dd90470e08b4cfd3c7e486a281a14faa1212ea435f70590b7d10193930d221110115e0050ab76839ccfa2e495e2bceb1c7eaace7d91d3ff8beb37dfec007ed0827d8ab7b037161f3a93f8eb1f7ac9b5f8ff9f01589c85551a517ab89034f2a4d7a8130bd7f347fcd20f56692ba783e3f479a2b17ada6a7239b6a7b046ee00ec73adb23b2ddc801688545b7b0e43f8b4195ac2bec380adee7551fdbd5947890a063a9d298a887776b9d65f280b5e54999a884c3e5cf2238af6c335f315aa6caa78340478e15b404e88181d72e16b1cd23c7ac9be48242221039d9634e6c04ca997e5e3bfa1d17f96fbd9f71966dca8e183414bbbfd66435e82f7f3b1ac7e85c1bd527a46751e5e7428db8b357452e71815287774b8422ea32025c24b1ec2b873e2ef31eb261f3ac828267ba031eb4d969ac65daf1b290bca29f2f34027dfd6711c1181947b56ebd01f4c9b3bed5c4346eaddeda09b3837dd87e51517d4ae1034b6e4c4b9110e535b29160ebcfc628b048f5ba3f5ccec674b0265411c04a17b336887ac265cd8c73f2cebfbd79cbbdf9b8b0915300b16cc1a7ded6cac3a40da1498441a80f25ebcc6718a804ccdc43b7d9f4526281f572879216aae8124e50ecd8a7c2dccea9da5798d32d3aac0ef7c1d59a603122da506c4090a9d00ae22230078f03700d612f4f63f443ff7eb44f4e60f5db29d63ea6dc9e0ebafb4f763a3766adbc6d3030016cd7b08ea62d435532df6d1e041ef4c69197d9c335ec9ec4e623ae698e0bfa85af908c200d2cc3a3ae8055b3f5ecf60767ff1a9c6dec2cb8f2bdc1354945bbb3c0767b14ac3eb55cf14245faf652a6bcb4879a587af9d234eb8ab43cec46f4d9fbbee6a88c98fd9fbc92a0441e2854b550eb6d5bbc90a1849db48300cfbf4e09e2d9ffd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
