<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa7c1842b5f3717ded883d10f7c95ed82183779d2d526407b4e323e48af29d24e1d5123a4cea9a9d382d8daf032e56fc45471f3d79762a6c5cf1343b0e2fd1f8526a74aadd508219466019a7f68df1a68fcfae11abba24237c0eaa7ef0babea2ac90934e43cb3a467cccf58f710491e23a77e117eb9b4c66ce5af7e3a7633044c476cbe078a800f2ad87ea6839c4523ed07590f26dc77b35784ab8b623c1bce3c56ecf3a92f158a31e36432ea625bec005a5f4456c561108aa756fc9526268c5a4ec6d724fc2bc67283932d646d427e247e5758d61136a14ba7af406e2745f64d02078e92ac5a812a8822046c154d909dcbf02b9d07a288643dd551d4d8068dbd873f0b76409a3e858d945136be60e9461cdef81f04fd8406c1fc6df3193a775fc0ff364fc9496eb92223aa1dc9ecd2c3a1d93046f1597a320b246edb4928f79656cfc2edf31d34178f55fe9ed2a8a06c099a22fa2475bc097fffa437b807632514ca3072d8c3e46605c8ea9377e4d07ff5069958af87335a314a54c71079c7c6f5a3e2007dd266749696ca8de8463fdb5dd72bd3eb56167250799209c7fac0902ea3e36ed9decb0fc7dcb2db62217c7e910902dbc16eed75d62122f45c4ddae1a08004c634a42e048a86fd79f4d13c829092f78ad0582c753f3de8fc079be5d4a41a1c1ad7d732c9907a026fd45a6b3c723ca81d86dea2f37d69278c299cc548b51880b2a84f49a63ce49fc26cff49de6804135b1374cab535faebbfeefcf407eefe730575afa96f6c725f5ed9edcad914d3bd231191fc5552ca3389ffa63703879d7edb50c5f2faa2a5a28a2d5521dd5d52752009febb0381d11014a3f04ccfaf6f397234b62a7794175be63c1c71eef2a2f879b1469ab145bdd2b6514eb994bb5550e3fb48eaa9c694defe28f95253bc6b4f815f22c8c89ca1fc6876c62591cc48463983999eb9513054b5fbb0b46ccf8dba6e761ab2d5e3a8aa714229b1c16a03d8bc32fef045294f51b8478f8a2220068a2b0e8ba214e2ec39702b32cc323724f9a984fba22e2a6f9051574c9deee366b2fc60fa381f72f636c45f35d1e1ba8d1a5538e8e29d95f178dcafed6afdee362d40553606188f28d25a2740a2420934f80c7405afb9091dbb4208ceb718569963337ab05542ac9a3207020e58d86c251a37a46c76ad5f876eadb39e32dc6b030dc9bb4033d32fd6cbab526b2a4cd8346a0e2aa0b5da115855fa6cde46b174b93a7586de210b0fee64ce0380af6c0eb4cd490639b5241925b5bb75911a1c76b43d11a2c12a2399dd5a992d01e112fc07c18e50f7eb2a0e4c12b20870ae43211dec07c7bd9514672e0ea3e5d176440725267274144a61d92da3336ba990070ae2adc92cb1cef74be2be74b39bff04b03f07f3103ebf39015ef484541831d93dd1feac92522a666360afbd491c2408a7bb96b0d99707999e75cae85ddb563a488756f016083fb87a8749cc0a3b347e29529bcd376c8f522d3664d1c07517f7ef49447c86a9ee98a8342836f0ff3413fd0d6ff05eaef1b024a24fe03da35316c82809335400c8c50a22278a04a80309a0d8012a5e623eda1604fde9489b0a82be269ed63b5cba3f4849b3d6841a483cb1d241681766ec7b302b74f8191744cd78a25dc3d83fd707d98d72f593f3b861f8b4a9ba1829d88fd1aef1643d0440cf2e9accdcd8d58d5bb5323d4d7f72f49eb8f3caddf280c5f39c094386cb4b434b53cd46113517598030f7a76d0a5126bd77382377ab08adfdb6933a2cc4821b24810716264a24f2069019fba1d4ab9cfc8007b373657ea446888a940e30aee76d05225c56dcfeaf543fc1cff9edc01662839825534e89b45a5792a5bb7e0abdff38aec95c4ed66f2b4d6cf3cdd1f3efa8c2d1b35aea3ae86102aa4bece154b7f0105e3aa6ac2ddb2f8660dd1d3eb118f491670354122f111b362d2b25745e38b6532e676ec2a4e93a2a2be1891abeebaa45791307376ad0f5a785abf28271987dbe6e6afd0fcb07b309f23e54f7045babb96a1ec91daa2aafdb6d4cdfe4bce292c9c81265ebf87bb3386e1fd0f83427fb491b3f465b44669336e5fc3b0bd4650a8eada6d8b2a4267103e67a8b5156ba466ad53f10e25276e66ae9b04cba664c0e7c404f250fae4512b46177a35908958bd8fb70c14f9f7bf13c0407c50bc68c9b689e20e5dff66552e96099aadfa2228968cfff6bd946f4a6e86f264b080dd10b8cff88c87c99b1e8fe5348d6b4d685b290518668fb8219150561c80cb49808ba122269ede7629425420971877b589fdc4f9e8dcff7c91adb661fc3c087f8b41c19122823bc96b30dc5335e964fb10eed7341cb7a01e1ef7dcdc8d8bc26b8943fc9c33884ccf4ea2b169328883d8e46e6f621908a6d7de51d70411197a2f3644cff0ccf1317fc90f4be83c03511afac1e5e6475d06e64b199cefce6a41b667b93e28d090f921e834ebb8fcc50390fe1dd34689cbcd708bd92164aca6264edc81f60787e32b62ffbbe9499958e90e42f2c468ed0c6485444e82cc07d854527f65948a8f45ab973ae7b39671f49df43e92f90a077b904559751b3260ab86cc8b4f88f0f32cf07ed145a868955d6e14ddea201307dd8b0125a34de9da0000221be00cc52462de1d5c4822c95f6009f1fdff57e88c740d6c3fe81466e34108993bccf47b8857aa14214204a3b94bcd950aff6e77c89eb62225a1f92974cbc5e6396eaaeb8c5b4c83194cbcf86f4b25967c980d08cbe6d461cb044ed09bd9acaa1398adb3cf184a8a9f15650da2648f83d6ef794d3a0449c3414b913019341be1aece705ccddd0bcb30b16ba46ffcd164201f5995e2b703b8be7c428a13c64c42ecd3b5926a21b23726f5cc96775857fe5d8ae4777e285aec8eae7829b59a097a2e348b59e6b273db7144357ada238de78a1689b6192d9372221f0ee6e9c632e4dfefd862140d30a37fa72b21b1fc4fc2b397abc69f5421a7e21656041f2c62fe9cecb30e4f79eeb20c79b7be9f2110aec0940808274ae8c1e798b1562f8e8b1f18c744e72a99d03d03b26bfec9fa1f3bfe627f95a4381895a8e212a4987115c31b55a5a1ca4015525207a22f363ed59efe2f6aef2104bb38306b10ac52dc11cd16fd7f59fa1f72e416dcc6248ac7f1f0cccd20df5729fa000570d8c4c8900023a6c73c8482ae16ad51063b60d5f4f889b34c9652f75feb3d8ea58a342f9a310b0894c42c7c13e282df82c54170741dabfe3b420aad110f4bb5a5e57950a44b5cb46152a9c269a3d59a4904cfffd7b413f7310880fe49530823753c107a81de97a4ddb839bf79a8039856bb8043ba71a5fe39c057a004036a9c82dcc0e43b6810f7021311ca3fe2e027ca58c801df06752563ea323e65f5c29c468f13db852ba250b4ede5473070f18085b015a7fe5c16497d8a512edb7ffc84898d398ff9e03b0bf8974c669699814cc33cb5af185e14d7a38bfd37de0ef0156629fcb0c7e4955754ef516f111cab95623dcde485c5314a9a39735179a05d13698bb99ca678dbd7f6523d2c0100c3f988e383003a33067cb6fd4c40442050364eea4d727632282734498406f95a78421b947a6b3a7b957fb9045fe58350f343d490dbb00d93f7f0144f48608fa79c9a29d2a1fa0b072766ef4ca9fc2fadba29be4bd7f3d402fdd3e5a11b88437baa30da35a2bdc750a3051bd42914d7a9730a8606649b8a9e2b247eeed3863091f97a3ddfd17b276173f70e2fe272222ed2f055528eaf630924dc5ed4a661ff745d3345e6d23d936b5e4b2aff8b4e7bdcfe17de9acfc605fe3873378ee3df9feefc5bc7c0136bf296965287c79986b3291417cb6b0a89bfdc56b7f40189957b9a74f6ae01a864d0b52227763f919eaa7f16e583d334b4288f5b61c62999c7554f64b2b987255953d4a77b6514fb53eabc99c22add9bbd9048aa08027bb15f064872dbaffc820a8ebbd1247856a14e0ae4fbe09c9828bcf3bd925dc79dc3df87127ada7db9b03f4c605d50e60fd2dec03bd433d033220ca3f6bbb407fd38b12b9dfa1b7521a0d6c787f45842b4be8273a8d588cf81d23d2f45774931441c284f101d07b4f24c0b5b27efbd9e34046b896365f65c94bc644ed29e2f69f55f3f09500f03eb7862062deddf56cfc8740470235d397c26096bd7d6ace1dee377bf75eeb0b75c1640fdb1f1f9bac1665a187a9ca2df04b49a3d89048acf1b62f091b57356b37ceb467b1ed940b545eaa46a7b9afeba21c8abaaa8efd00ee33f4f786e320169757a79fb133350e0ef0bdce32a83e350af84b0f931d5717b7e0618d90d33d8fce6b2185d16875fd54b9f8ed89ae63763c7cfff1e2c2f1d6ce6f26ed30392c26c3270bea843b82f1cf2438923b46ba741d6296ce93d682d202502bc9698716cce2c1edcbc82ddf8395afb46b8c1f494ade091bbe56eb1d52d1aec129a2466b468bd192c85f6f1790a4b643a9bbf0eb5ac681902645aa142cce287366bcbfdb8afb413e958c085ba88de6b9d44b9cd171f83bc6307b5028fba5dac143896cf4e577a9b82177c105216aebe9486a195e2324568eb48ff3eceee2a7c83596739320c68a9518e7e647bd62bc41a5f2a454a2009b821c3f1906b22ad58015b30a88623fe0bc90975eea5ec1990298dae6595be481300a383c57964c0b0ee002e68d562787a9e663ab6249eb2aaa4e11167fb00a7b999ee448b8d3ef334796dba326dea2c0a505daab51aed8a0305a25466b1665cb89a863456aa828a334b99fb99e273a166b4d902bf4be718aa750d44ba2abfbde12dd7c723dc1ff77034357bba902a350388d09a18849dd2fef3e03604ce30a9c13e0ed72a01744fff8fea6525666720eda6b15ba340cd7a7327174fe18dec86eeb06f1e0de25d4fc0269c185216943edaceeb2a4b55437bd305b523abcda5bc327844ac39ffacf52a7069982ddd5e98c64517698b977c9d11dafd2d9ac3c9103c222d516b2e167521a57c640ce142b5eff4d706c21325f57b51ef456c95f94b5dceb35b66dff771bd7f2c6ef761fd324d58c4d1f85b88c083a6dd204e245047f97b5209398f3330c84c79ab757505a48e81ed269916efae8eb6dd6495af1b5402af57f691aaa811f74ffafcbf22ca18827a8d19eb7c3d43c0a47abf93fe352aeb34b50545f93d2d68ee6538daae8aeb7c41f0d1d5e797c9bcb7f78470164d2a20449a0d96baf114835883374e97eb12a6b25541d8f68172e02d1323c283e4881524f52eada5c4b77e85e83420165d6656e31d514e7017253ac62907165abfc9f20ef01cb954da53e3f78bb71677af91829b759c77ee9eb79a61d80029da1b4e44a0d9702207792165a2d0bc018df067536c030f2b2db2b3eb517c9c13b13793efd1c1d889daeab4286a5dab615c0f93d34fe18241a5226d7cf56b279ab50e349b9c95cbda8f2c8b951b90b99cc3537614d1b00bb94480af08523884d1eda3493352f922b215e274eb60d757d36fb5d88badc9f73dc6268860e075c505508b50d115cf90cc86c34a60cf75628f586c520f09ba0c9b605644376ecfc82f2cffd1d83632a80ea9a7a351d654b3f71c0d885a2339a27eb690b01ba064368108988e2c57338880d8b451e1ea0d849cf1720351b2696a563975dfc095212c6fa7b56c60cba41d72186e5640cde2658d2084928297123828fdd1bc70a170abe0d8f228474367ee18fc3bcb51af6646cb3c93eb386272c307a37146315ffdb0d1dda99fa3bb46904fb8550fe38347a7f7a49fc8ef0a46542392476419b09497e2194186b6b70407876a5eddc17093184f69ebe178cef56c245acc7a2f28157d803faa7fd046ed3d97c4282084fe4499cc8fbb4ae437671af631f04fdbe735e6637b011e1db36f4fea1a744d2a7084fe636ce6795be0e4a82c9cc4944ffe4e39fbbd9dfa73604827714ede46a81f01af046a6cb3b35654498cb89447d4490baa22a2be37c58b241af555ffeb9c80668c70332c8978112d6d54d6e6b4daef914d7a764996076b5dd9a81fb4aaf585356196234c92a769ddd1789c11280d20befa5ed09cc8c28b2b00972a3cbaca0dd664ed9e659c7e61cb69a666d038ca16e3379d9a07a45741edeb7b3c98e7fec7945968024942c96dfce62d23eef5246c7379d41a4ee412199aa63a63e2d645431486d122324ce48c3748d9e62830a5c81667d0faf63401b9b7900d291919ab1ba1fbbb1182b9b07c4281a90189ddfc0e3a37ef0e8868c94174bb49cde083d53f72f7a17ecfadccaeda05f274c02e2df86b7d16382d5004678dd00a88ea5c7819f8cf1a28f5a28188ac4b4c6b1913d95e3a489df11795004180ca69d8d8b28f050ce356d81fc262d25bd2170567c1e3dbc1ed0988dd22dd4680164be0528b3af832f98d71302cd7f3dfa3044bffdd9ed759b221596ddc1abae5c79d5e68b5cce88955452c5d541fa99afdff69ed772ffbbd9da84bbb5be508b1dc692d56d7c5295f036a60bc47b6d0fbbda9d2b4520b1e02eef9a9ba2aa8fcebb1cdc74d60646f093ddc8706b21efe6891d464329e6a4512faf23150c156b18910c0033f78ab721887c1de6e68f76f9f68b5026db32ed28bf27ea1de49284319c7ddd282336230b9101fc79bbd21ef46ddc8eabf1836a72a59609c6a16a7002c476fdee4889eb0fdab27cf85cc0fcf135d1c4b5a2a531603ee0fb7d82cca487b75f949bfe327e6731a134b846a47c2ca75ad24789a74c90b2e8698790287412fb3e0ee0cff88ec449f88cd3e10f0ad721a2d9aaecf5eef0570968eed91ce01f4b3b7dc3478353e23008590beff8ace125187a161c8c622b2a0ca9ce29bc1be8a308a953afc02a3c6dc4fb7d1e32b334ddffc38193bb8ca3ef78aaf7e7272591a4f7a5e293fbb7bf1ee6e5901fa148653bc4be93482d731dba97165e02ab3edeaf501ed42e690184e7b0e6dd07a84e2bfe4b483f348dafeb03cd28e3ef39e8fcc0ad745f664feb801e0dba607555bb7a548a96d6e996f4c69f8e02e380699356d890f68e147f4f7983129ae3d539e43885983a45ece278a1e75474257af94cd25a30f21b7ac36bbc7b5b6227fb2c2aca552fbd95203ecc96b04346bd6186903f64787baf845e2c4f78d3c0af7d537daab3b0fdafc5f9f97fa2656e081309f0c4a0a3e5fac037976dab80c9d2b8be90efe5262175a4a3d2cb0ac2c2055d6f355d2ff7336350833d321ae04f8490f3f19acfba272ca5ae38d1dc3d8bdf17c8a0ce5a3cf06b923ce671a79bfde8c6cab79d53ad004ca510850cec2439dc2600ba296b89ff990c482586ef75e4602332beff2be94bc9336bfb5c94a4a6d5cbd4108b6eece6176944a213d9871fc02368ecfe47485b547df0dcf76857f16a342fccc815292ab4e685abb44efaf4e0e138e49cb3857e132175468e164236742b3c0cc62d17ca1800392c374ce43f207a3aaf1bc1801b277028c3ad8c82579087e466f6d9d90d33c6cffa3168ac1617e060599d90f46f890f0f481bf8cd0bc66cba229d23e5e53f3d666f2c49c83f57b3fd7fac4b069f88bf3e99de7223e8ae9bd5133f8310736468ddb109a7bde24ec1a8667e4a0f26de3ea71d36577246b0e7af13da899474cfaa9fe5e4c2c92ff53dd09b13397c52bdd2d5774be1b0cb2076111f180c6e1ff764512cbc986f24884b96818609c5d9456d0a70ea7a67c66878bff0a04dc955b29a5ae301ace6b6af8711b150b7ad0117c5ae8cb8010317ea96d776ad7bb0dce7f5b55871e44819b6819ab78d8b2bdab560e20bbe783428297cd520f0e982b712eeac0be18b5e319e1d362d0b1da87a8f157bf94deb099b8c94f2918cfb694c84fcededf8a7bf764b996df2fd85e6be2fe470443683e2feab3f6c77db6b21c28a9202e6255c0d92688f92e225e2e60fccb8cca46484340f365bc94eb45512f6af996425e0753e566c32c9f9e1cc61f48d41a5c8293770f6a0d102b48ae71924e78a2db16b85d7cfc5f088b7ca3d4a9b66b4822e076e497a25c559157965a085a5938b8328ce2e7e3584cd7a4fefeaa2e6b0b14e3006570d55c18da2404199e80fe2eb6e121edc012e6a82ec530cf70eb44b0c06fee1d2b683358447464944dcc69c09e30bc3a023920462b608693a9cbcaae3a5ba7cdbf31298253633471d4e0bd5a65a5c9420e31825789c708c7cd9d10cef2b32de4ca2c1f9f5cd69477e56327a9d698fea032890afdd5848ab5566c6d1656cf3668e7175f7aa8aa0c4ca1b803918c78c24b1bfad1d5506c9788680b78f7f15d74a8a5b790614ee25d502b8147a8882627f512d008382dbcf71ba6de9d32235419fbeb94a02eb10c305816d34a348e10908cfec922446d1afcf804ad692d5cc9738768bd33d1d717f289daa98f3988c51b4f04aef4cd64dd5c878be8b001e3a813aeff1f6ede48873915fdba42906736cfe186d5b26fcc33710734e0c6ed7caa53eaafd716166e1622139a244a6d8612490e893e1f15ea7afbe3f291ada30fbb6d1748d7b0ef56b6beffc2a9f461b976acc18f7b9a47583e8d764cb1cddf79f9ad19222cc7ba2521947c1602f7d841d71dcb2c5dd4070e5c6fce198a5c800c31abc97292fecc1d7e487eb055c414039578b56f54a06102c6860f24147d41de8916eff06eebef3175de577d94f8e6bde0c1e95bd17c8f0ab04c1eff9f11394e9c93ce9cbdcb864d749707818363b29954a9b37e422fc7c2feb61cecd340389850b30e23ed19863f52c22f569298ead8fae81ff5e29a143c8236aa57eca9979900e7f2002ddbd65c45294fbb81c5251d287741a9f5dd4df0672f46c59cb86dc1b40f957e760cebba9ae2cebdb75c8552cac943e71246eb9a4d703bec635656b0c5e7caf5d499205fa532d9fc03f109f939206a53b7538292d742a61eb9a5dcb5f7f16137cca6715752fa3b25c079b389e78e78758a1a49e61f60ab735b20e377939b342953d3322b880523a9966a3018c4c1e880233402683879b24a94811cd5d63462ff0c2a6d9bb3d77bee6ece5b7c0eaece807855e9613e60a46e7f3989d1c40fcd00b79241655a7cfc1be4e4b476a2f62113ba5ac76bb7499d28f463ca6bebefd4bbe538d560513e00254bc82af51d61c26c01ed6922c5dc6d3d9814b205db6239295e90c14bb45dbe2eb66459f507494602ce5a8778daa23d79263ff96a35da13de1313af32ca9e7cdd173329cdc8e41e7381d5a040a655ebc2acfb4a249f129f2c7b21ac361ac91548ceadf02e6b29be3bc5d35ed47dabbd1755f197ab8a6f55b6044cb520b631c181baed057197f7e98da0a37d9e8ff55be5413cfa9f06ffd8c3f4854077ffb4fb088e70fb7e7e985397af2069c94a866206e7c6d21011880fe68d1d58bc4153b4a6b4646a6af193d9cd374192636a6e7d59c3649a1db4c4a1aa1743b6178e9279df089f15c5a67789d9017c8a9dd2ce671c564d04e54d6e6d409982566da47bd49070ee53e54f75c099159d57d8f8baec6bc9188c5bedd6661d15a1e438e09222e4041631da3a9b40a8afd9e9767e62076052b94f5909a286c9afeb330d22789a2b36ab000cab99b80c462d4437da732655df3d0bf6410142f922cba33d72d2c84096383390ce88ab3e8a85141e337614224189248b14e1444d3d37401251ac4cad6dc39273cae67f44c760131e7d992973bcf2a1f63da16e25b1f8d19220819e938fb9fe01f7f676f636f00dbc7ead81cb2983a59862990103d6c1f408921f60e1dedf8e2a08ae6a0066557b4dbe0f648beacd466a9c9fc0995b61ca942dfdd0bf4f9a4a0a3c90cc9e92932110b4dcbaf7385cc4ce2a4a8e4f0e2844f993be7b6d2fe1bf3f51a288f6f822427e1fd4e3825dd80b94f16ed3751bc8ebc24c694bd9e8f3ec3b2c0ea3d62ecf14bd1dc708d95c6183ae133b757fbd88819d88fac7569aca9ae4d4a87250eba7b730dbb0449ca234302c3180e884ec1ca182bc9f839458ea536390988456b056c7703c27248535e02a85d63df6ab3d4cbc92c67de359c711cf76553a106e1a0e436824686dc698dc30612bcc4e137942601ea212bf73b0918378d36f167a045bd3335e4d82b88ef7f25447b60b14a74d9077629f68bcbdec734ef4f70ab98d03f0084723f6d4faf46ed197a78bce6ac5bbc6d07958b744ca381fb7c90be1ffd6981b7b375c715e88c148bd8d4e314362cd9af0173c7e3d857da08c7dec2ce021f5769ef555eac03c6500c11f318b6774569d7aae46c6937ad7f70edb0baaadbb9b171cadec2f8245c18e837809696a039794195f416ec1186be3ee6ed6737188f5a74889aa441cef132a5e719db92b9bf0c73507de9ebd0f8224b86fb496a69170cbcf3cc3afad7fa07b21fcb0b7588a9a7ed152a052e8be905526ceff540b7df95f6b5010528e993b3613fad91d2956e25e727b995b327fd5de1bdf4eac363b09397057dff4ae17953602d1a2c96142e9b94770b254380be36670a319d86973f0c2aecc450136cf136d146fa21646b8d8426ade63ca4a31606e5698eb369b81795b7a127a3b3f4d430844bae7a2545fb77bf81dd2d0171310e842dc5a890c72fda04f77bd8a6c2523ea15ad3ebd98962c2c42ab3a98c281b60f85fcf868766bff95e470c87dbd92c2c560d250a80df4815f5fbbd9beaf6a4635ecfefff9e795fa0fd76b87d14f3a45642dc48a31bec531f9639df3e104be9b093a985fe249dc4503fa487d861ab7904c152a042a17db437090d35efbb08f1bcac6923a13e99d1491a98f16d439a32d5033d9a1747a19fd68dea6c1a3a23da304ca20e7c278fee831412d2ee7ebdd5495d0006e2f8f4ebfb4a4108d3d3cbcda8fcd582882b8045207abed7337f3a3c024337a077b25889630a2a705b887b1259924a824b3b95c1883900b1c2491d76a890999244ab91198c8133ba70782f6e24147ea7a9a8b79ca952855c9fab2c2eaaf51abb90ae475772c0cbe3cc6e26926a1a7a051629599354e660142d5c1e7b02892ffe0cd6f5b1bae1b9fc1d35dded1fee11529405a061b3a6d978f0de1ca5929a629d2797fb4d51d259bebcae61b7fa419ad5cc74d0cd26c32d921942ce125a9fc56546fed8e5822eb5fad83fc16b1dda3f7175e1fb0d0d8885fc3e60b46a2a697bf1936d03565014d4f634c9eccb00bfc8e39dd43afba2837a1e26a4f25c9218d458e08e0f06e1e34621bd1de959731812510680f687fcae27afd13dc4c0498edf7fe757bb3bcb4d79c0bdd1d75ca69b296331d155e9f92365464f26b1ab0174d0379bf390c6ab2bbaaedfe0eb32a61904177bb5d5e85aab8334f68a50e33b98e3929704695d2be3befb6e5cfc3f202633002ea20f654f6a122debf20a5b0e7791f35d0c769a2abd8759bf596568754be7ec9b8a50fda0aba31e6904d15b29d8913b720c1bd4f4f21e2090a188f4967c0ed19ceb820a0f1c753b1f5685b546a537cf613420a3690de42ac99c81612c113aa373d1fa10936d27ffb394b520d8fda441b9f63010c6e27662d227adfa1b9a0a5c6eea171cd2e98dfe05e8dc6ce1308959d03b0a37c223fc42b4267cd9241766146f316d0a1190dd007ebebdadeaac57082e7b3499afee7244c9072e309a3e92bc047bd2c7684ab03b1beb64cc10b19eca59fb9649b93d2827592ba8b8fc889f621004b7ba764961b3526dba353717bd03663cfb59041a730f9bcc60d4f2c5fc1f198bebdff847b1893c0a988c9f7612de34c3fdeaf34ad2f674cd37751643c70f43ca6aac6362d74828499edb6a261160f70069de4a0af04cd3df6881cd6b5c18eae8089152ab592d85206b00f8c647bd48ea2f51af0a84dfd1fb0bc89df1de4920833f961fcef58f6d50718670a7adad0f7940c5860a21d176a756a14e6bf8573aefeb3860799a9bf73305229598be2e615d1072813aa25974a37396ea57a12a74f4a6850c9504ed00429ff2705e0518dd6c6dd8239cb6b790f1c36a3de4ade7508b1b6bb682ce1eccdc5fc0202989b26462af894bf454fe13b8f14fcaa0a852d0b595f6790e1f48c97edda5f9398b52f1130e425b41ce935860016aa664da4c976c76c382d88ab6f1a054004ad0e52f96678ef748a53535fdf09efcb1924530ccd26bde641f477a892f50b3cbe843db2749762a46eaac39c1c2202dd16281999b87e637ede3b08aaf3d52d82aace93b611ad7869375b7f89955a074ab0e867c570ce116f61d23e4cfd71d78989a97af4559b329d8f7ffa1705992490dd33c432fa6b1a387c5a71366d56937324206d583bd94d09e08ae6012d5006317ca0d76896fdcf11ad91d052d02d7c6b3ae7e6ebfff54e1c30adebb05b6f41330dd1ef82d6867ef6c1c2e432c0d24ea5d548a7e3a05d7f9971767045a513f8e769a7be966538666eee34e4664aabcd379bc7f61225484559467d81cb29685188ff0bbc03953dfe0c7365e3916005f6c6287a520a09398df653dd36825551b3ac9287e22bfdac96ad3f2ee332e614f725605ec323e7541212c5f486cb13c122a249e6095a9aa66cf34a8461806899ef63f003bdacb46cfbac052b86dee94eafa65b82169261018c36e806eb4a50128e2f4d65f22be6546bb7658ad403107818fa2a0c145c7249c069a9ee66332b676e16cf64145878601157622d63151acf3468a968373c98ef27006206435af2fd63bda0c8e0f30f4c7b403f678dcc54d985979b62854c4f52e7b68b726bc28d1826fd34c3d5ea307b81ac2e93744c00870813b186104d4cf6c76a4f6dd872238c6ace229868f146b1ef0adcaa8297feaf59f32f30ea8bf7253e3331b6ea4fc51e4254518712f73dc58f6fe2cb1efd81610a9cff369b7e755161e171aedd467aa437877184b2bbc2a3bce4e09d4feb602ed7615808a44e06874f6be9ef177186df1d6492c00f7b1f85e7615a90e64f84cbb854218e08fc3e5f2c9712e437a7e68af9f4e2e35582f176a304e81dcf4ef7a16ff655963815271aa51a31b5acef8e2f4d5fa559727bd60796ef36f306b9468fc5c6acdc24985e16cbf643a41f325db5e3f98db0f594ea004afd4c4b103283e27a748a44f8a56de2c15bcb14910bc3d5c618c2d0c7d8f3e6242eb3fc90f4cf3622ee20c47b279c6abab3028bf066012d892f1acab4330408b5b1c982a7bd0665b591b690d6b0627781a4eb654cac87ae3185e34763e9fbc433758554fc9995ee3d7b9851cfb74c318cfb48dc1f5b7470ff413f587f4268fd4a099e7990cedefac10dbcb74f8ee2ceae2207ddbf7ffb19c0b0db1292d7baa25cf2c198f0a4d0d04e803b9eabc5160fe9b831b0e46152bb29ca1e3808818a58ed10bcc70a36eedb32214dfb2be86beead0df44a01da2bfc94a84667ad77974fe67d5c48a970b487c9a82d010f819db59f18359e20726f0da62b6ac04c66e3c54e7f77dce2755b8125b15841d60de478e3c7e7d5617b10448ade02ebdb22f399150b675220912c6834129c5b6e9c85499be67caa8bf9e29ec7673de386b51f4d0895e98cb3cdea2180d0b32b230577d69efc80a9c1eddc879a960c64aa79d43b2eb641e500b0b06efdb8b10f195d34e28058cb9cc8d243bfa44505a4611e633ba67653aa9a369061334ca2b4f9209b971ed28503e3a5f6b17da4d664c7ca84076bdadb13d499afb2c1e7dba225df80456596a183b3ce3182898bb12daddf8b60501f8b0af6ee8a0d5f182ea8ce9461878fe6e0f25f97e1f90cb53c13c6efb8701388f026113ca3f0c0ee6346c5c5b69c7ffff0d52925e75a167d4deb38b23ac1bd8a280f658fe417bc6c7d0544a4c8093c7c54a2d118fdeac802837491e7c9d0c2e705fd56eaa0477e5455d3cf1939fde5d48fb517afd132ca07e136181fe3600cb6b52bac21e62e303b68c4328235ea52825a7ebe9d5e50efee41aaed790a5b6c82d074a37fa277417405c0f61bf6f95ee96dc1016a5b0d573e19343938444c140bbcec73e744f7fd8baafe3d7b5484361e9d906c65b3b4e950cda51bb354b462c99db7c4fd1f9d60d087b795deb3c3b839c7bd034f857550e4e05f17a12a8197af0f122e9609cb532bedf22e95d5a585f170d1f68c88aa831730848295eae48421d7c5aa867d1f62adfd1181e90990ca585e24c469275163160ce3653b988de419411cf2226df4aa302b24d3fc279ec230d278d6bdc5f308e10cc66461479031bd1f1509c0e56007aba8a38f5272bb211df90c070deabf7e454f491b045bc234664a41cef0f8ad60a7512e1c87193217dc6be58ae3c1f274d9ecb19ddcb5039b05e7d0349173db91a5cd1daee40b870ba48edfc79ce47188096c0b5bbda6c1e85e60a44f26b47e9cac5bc527ab33d45787cea189f2a04370b130a55fda1feaf572f283f13f921e8795049d3ae0a2f3f3071394cfddb8ea4802c0b05cb47d327520460208d58417dd47431086672717d7a6d4fd5177d5a141d3a3fd1daee0c2a02906b6ba247e0f0d368c975429d71213e4d70f874c1f6be98a990b8cc0a9d499c05c66e8ebb9a6ebde8e8140f3235a2cf2e6d1999c2b28e21d5a4dd3c9b1704589ba4197b23eda2f82e2c6626e4852042d83700114395452e3ab91040f532650aaaa245cc049fd7f2df62e3cc2dabad8695aa61dad7a4403cc705135f9ba37ed84caa7444f63bb1fb7994598db71f770efc99bdea6b4333bd65bf0e89376284e4bc3299cad6891f719cd5ecd21c4dbc131f096b57a8b28fed352432708c1c57f6b9e18b7055858322a8ddacb365055614284763d0330a723f1f8c96789db62b3e219f36bb9d247fd10321c95b3281f34edad1faa41faa82164a5f01c61c0db5ce095af1db2c4b15b5afa5c129575ed56844f690aeb1d512b8684893551042a14d1cdf93c15abc3d7934ff559cecaa6a821700c23eb3c488a4d092f5e3e7532683727c5d4d8950764aa2763150008ddafa5ead35d9d2bdf43eb5002673aa119cb7c6fffb26caf6a1e34b02636700bd970daca4001a84556e357066af475d4aba3821a0da060a1b603b799d62b60427bb9a03a30738d100d1664049c2a27bdb4fe7eec03edd4c33e727018930fbbe5ee3f08db85becd33c249cb2b4c5b0966cf7ab6d41cbf4631c5915db20934951a59f1884fabe9b7e29eb24d81dffe284999bd57322dc952794d7f65732d53f2521bd4ec65f69c6bcc1464427bfb5d3eae50b4d105fc0c61e5b87a62980391e85c03f5d638b3c23993746cce35d2514ae46086813622cfe42d567c1bd00cedda3514f53f8170a591d800480ab414be88b71ac7521ba65e806922505ad07cf4589650f39d372ee18ab989cab588d02eb10bd8359a377a57acb1a579d70b1187ba102ceb66fd4fa9aaa8873cf331a6c567de9d670f251534b48a466a8d7cfd2af6d8eb134f1abd82bf1fefaae36a74e3186aee08676cb29c20b544d69195b597cc0224c4b8f20ceacf7787a1818747465355bf35d539845f3186a442f94a25986a64a452fa271b401068bb15d86c192a0de554e42c232f8d438e1a0c46172892cd509d9151b4d527402194dd9ef9ff6bfafec281bfbd73172cdbdd956b161303300d87c76f22a2a719be04c381df89f18a82d6b660906aad01676db0f955c5f8f58aea7988c342fa7faf432f5f9d27d13528b48343cc47179fc75f6b8a567ff80ef7ddf043351635856dfde25a6b6bcf26d560c273507c8c87042eb816d0643e5e0a7ada7e3229fcda226343642c74adf3a0798b0fa3cfac200317005bd605e04ff2c40a01464e382a0cf07d2d06cd4ef0d99059717c6cb1d4344844dd0be7a7ce05b246b47c52776b34ff5dbfde164f2344e65b9409f20159be2f0790ee37010d1c238ef4b107271f394c24c98066af20249de84ab75dea8b0ae88cae2ee544a4715d8c67d845212298e8f3d1814e1745964f8d44179e2183d3819c4583eb2dabf432c819cce6948655b79a47de8d19ba984dbef6cb3d8c26c54c4a0292f4c84e75a8037993d90de76025f325dacefe727419372861a913dddf6a40a1496c03a5861aa0ba286505ad4930210286a7fb5a6fa61f964854ccf258be414ca494fb7e51ed629dc917d506c8de8f261d42eb1c0072a7a32aab9ffa2d8983741b6131230416ea57dd4857c3e037a9204a09850f8747a679017c4bab93b3f572ac5230bb64387a37369908fdf1fb194054776a8deb0ec751d8e783a775645c763455ca4df7b668369397b2e0a4797014176fe3449088640af8266555091405abbec0e621839a431b86bab4facec5f845cff2a8c41dc476eed5d4e99dd53e37a9f2d56e2e099536b09a4dc76d35221018d20531bcb406f6ad91c4df3f2151b6c81af97761e98bdbd276750e459d16db0638fe703cee217ac203c61d4890c62af408c649c5ce1fbe7f926490690d4e8734b27479f25fc5ef63b277a4b6aa9cc942739c087148f1a27798e6f270af545309ec19a2be8e69d84598d15937c78886759182ad66f764848277c380259e757c3de8dd6ebb3fee1ccd656ef960ba553635117166695153e18ca5d6d30de62362ad3eacf41d7d431121e483697169849c178ddda99ced1047479baeab4f12defb99e81e01c942c966f3d1374a4e6efaeba61d91627a6e335433eff36611692c3dcd2945d3825cde0870e8b0b61ccc738f0e37d871e37747ed1f9cc529d651711c06fe756babc5a1b710d00bbabfaf5b102a130675d1afe3a80b0319fd4e6c89b2775aaa8e10c4f26355181f2097d9ccf187082f0f7959284cf18118bdfc141142d1c113a0dab33571d00594f4fd78a992d28e702aeea5222b8c57dea824b06818c2c1489b05ee2e52115a856bb0ad450d1c9f495611051cdf12329528476dec632988fca891e6be483fec0ee82f834f3a1b9778965f4fac1df2dce6263317803d5a407587aacb570dc06d93bf86449940318622ccb356820bda2d14129d6ba6fbfdd8d098a2f02961c25644197281d9246039562371d4473aa513d0edefa9937fc7af29c65422c1de28d4af2886a92de95ffeeab39de5acff2b56a7c9cf675f46629111babecf79f2c6970bede009eb69e95f37accc19f34e1e5609b02471966dc72183dcbaa92dea5a89117af8f7b58c349ef08e350c14dbca5ea73a75e7978294dcb99f6f901e9d683143820130312b1932ab374aef3ea2e7ae3a3c168c1c5d058b03c234a5c5f9897d19222e821143b84c4324a4f46fffdd56dca04afe825f1d6b377cd7c591c5b0aa2842c1678a92d4b9f0a212945aed1284b701e27926e7d8781ee671a1f43a0a35d1aa14d1cfea5227cad24d5a8f36793c6efcae883e2bc6d67d3bffb0934addfb21bdd24df5a7705942e89f73961d91e5f3e73819c40052fedd6750077f4f852b1342743fa18215bbbf0c45d843fb7e0e6f1c71dc135770c903d34232784b82a48d72ee058153e34b93505f4f9da9fed7ded135217f948f402eb802b3d96f5c5ae96efa5e44dc29532a6020b30ee2d849d5b134f387ca593f9301d261c1b0815cda4147947580c0431bbd29091c7093419613711c0d84abdb22ab303ec4ed1787053bc02873163513976d76f51874481e8ccf1aa50e423ee1567c1df2653cbda521ce59392cf1e52df104fb71a326b0edd425efbe6e39ea759bc5e7d7e8a020170d0675f6cc665cce8952edc808949e100a9d99409e8092e23a901f6acbb508ba842af979d990bc58b1099c2b7f1478b198dd056b87ca02a40fda3777be0a76d39ee8e14fd38560b7258574933bea95c3dd918c974ae8e95115bc33175c28fbdacbd5101b5ac4340d4c7eb7e8abe9c28f5cedeec8080411ac4e170fadf02fdd1b952be13ac81cba8272b9d62983c8cbf400fc315bb5ed1bb7df94e09bc21b600e43c4cc07a4b1c7cd52b8900469c478aa7f2656d753695154ce6e6bc87e20960d04e69283f112aafc9b7a9f1577fbb069b5bdd29fd08e3389b0f3ed2056dff2e8d38a8ac4bc9d81094f0fc704d5748cd79500e063db2107b7efe4655d63ba6be96822994b044cbb13960576e51654de39c6ba33555d1c2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
