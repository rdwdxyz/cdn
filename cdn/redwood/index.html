<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67a2060cbd5b875a0d5b486074e2dcaa4fe79b2a113c416a0a0c70f84b7522bf93d3849f23fbdc92cc4102c63093ee16b39c562e8a093a96705fbbae29852d6cc3c101c0e7be02ab85477566f9db8220a82ec5dd011fdb267c80bd6d7a6e34ee7c619d344656165055c6c78e9c7029abb885574516da221a84054751995be4c754dff4ab3461c0d8ea1223ecddff3a9ca7a471501cef531bf58aa0a7838f05ca0c743893adccef65b8f932f2a69bda38d8c8eedd5032b02ba9b5f3d169dbee24eafe3474dd1546cb8e675f6ba0cb396ed2d596f266f6e63cd6e8cf9ad6610974cf6b2c2c8c9c86c574c2ab1566ffed063ae4b394ed6dc02d14d7220478a72fa7a627eb12dd3c2f936eefc374234ab1c8fa492d3c076b6198ad4861525aa6cffbcb32f343aabbcf2952e08922fb81bd663023861cd578783527ff2b0d18aec9ff6591d32bb3150ac9e56c53f4f7aabd01882652405d90f876f8c95e47754f5ccf3a1fd1be3e40803f257c0f443dbf5c4fc9a735b6e63809ce579c17ebea58c79232bb34395ec0f34b25e094b772baf6a0bc805beaeb63a165afa1b91175bc2ee39cb61c9aae9ab73ed4f8a7b17066b285e8853e883af22e48c4a848d7170527a49ba761470ddcba55c7998f74765ff1e55731053836b76f5a2fe7fba7b1535f594e6066d3bf53ea2c6b64f684d36c1b8c04f168f0c9f84d7f9908a4f02fc9c8b987fedeb89d36c419bd529169a1ace47e0131e3aa5897abeb251fff314633f969a40b5487d69837d4ce8be3f8dbf42f7a0a209b5ce50306f396c67bd1dc25c3dfa00210c34aac573f77dae854ef3601f5104db9b395e72e66d3b1208451059190ee0a6634f1c5650a4c9731b9ba0f8e2da027bf1bfa2b96a6ff587afb385e1502ecfd439c65030c245d6c079bcbe3ab8b3df83adb957e785959b156400b26aafcfd8835458bef08296ef2525046a60c648bf1a1b7fa59d58d00d790f4e023567763c38c5b6dc36542f87b432b3375ab0bba59c31b86c230d8a74a5ec460bcd01ef0d6c0e7d208ef89ad3bbb84cb31a2aebc095c9939db42c4da9215bdf2ef3e70e3c02f14bb86fa7653808ceefed6b8d91921c7dac7802c597f538a516954a081a2445b770e5c63da8201d845b95e7058c3bc7332f5e1e3600e6bf05ba5b7013972df513165b33487308de3edab21335a6376dd26337114e98de4173f8acab75a2b6d54e8dcd91b89652ec33dc9232116749df6f46ec570cd107ce3f11ffd13447ad078f03f2ae6bedf2d5f7aef4810a6ab5b7ae7e73d1558d42ab4e8809ab248cf2eb9ab7589126fb8e46ea60290db0a99eebe7a1e05ab853a70c3169304631997532639ff78321f5db317d61619c172e8412bd439958d35dc7fedffcf3f7d2c72bd6037531d3200ddcb2691e343739003755176ecfa3c58efac814e7fcf9f3d262d3cec6b22fd16e90621ce43a879eb6c66b9fdf7de185db364ecf0fcb656dd437760a63c399cd89031dc7aa4ccf04a5ae33285d3da7ad03fc2cdb37290a35da7c6c2e3b50df226cadd8b171eaf0681e497f9750e14518e58ee8e3b3a1edf87ea0e9b2cad542b03f886c164353a87adf9a21bb662c31ab46e38c3d74faeb2c63801d41d165f7e0b11ea24e8a53be436ef5f266da4ef4492573399d98e13f7780b0c71483d15161944a6b39cf7790fa32aa8626a9f035f898595a0fe3287216e830f3a58b6dfb42340c47b34ddcafab8b3ef28ce708959dac1cbe93d556ef82b6973144523551ba51f26f5dec33cd8f3a99d2d75e4d1d8c4174307f01b78bbdbc4b2563f88876f9e0426ad4647d10d6b48b8fbca7aaeb7d49342fda2e6a3746180f69c5b16eb25ad1cf810505940c3e0a19383e29a400d83ee98ce63c7c254cabea3ac9d58089ca37a829c41655cdd7be5b5b39b0541fc0fd112fe95dbbd88c7e7575ec29a5e5769e97a0ae3adfb48fcb0321bbd06a83127a84702d4cfd1455a24637d0d36a52db942f732f4cca9b1e13fcdd75012bc8e899e0e4e1770b8927d3d6dfd8ad32542524218802b98de0cc46e17e25559fe29a06c9357c0006aa7bac98113b28acfa09a28c1c41daf673cfcae1840c190ddd8f63a63a8d898d135bf85d4a6d866d084920c042758e3d3ed05d64c74a994588bdd54062223f50dd32975d1ef3a74bf13f57814d7430d0eed9c61eb1eef5074c3ddd172de27041cd1780395ca90e4a200dd2a48a9929258652ac0f81c05e2cb1d03c89e535163d92759f73aca1dfbbdc225c7a6dbcbc7c82ea531b59d8a03662ab715e441dff314130f350173d010f0b2fcfd19f081c4bf83854c5cea560c6d337a95e9bcbc9a9406a8b62e475bf718591289ed99d8ecb7d6066335ae5e0e2c08349c25bf78e532f9d11993329ec1166d0331d9c7aea7ebe2ebd60a0c0d51fb96bdec56b4f2d991e605241f30332af72cd6daaef076c5f1afd396bd87e2ab918d418d59abbe8152645004baa991adb225cf7d1a4509bc08574b1e4adafefd216f12c139fac1f18a085860970bf2944b95ba8fb80ac60c0735b4eae703468b8507a2aa4baf5a4d15d0fc05614718fe862a454055c3b2f2cb86ea2aea0c51eea2ab9f66889ca63cc1c90f9c80f75751ac01dc507e6ebbb42e56492ffb1a36d185ebf8211518f877b092235a67672a9fa75d8dcb0fb4d4382f16d66a300cd0ff425906b356a3394f10f474f682d888e0e1c04c76874164a0ef6d7c3bba0c6cd57f44338bece22c9d8186f8cc4798e42bfcb786c28bc0300b36b1d7b14f2e7706cbdbb6d5e9dd9d9a9a5749cf0f3b73c23cceb6d9cb6f1e30494e9cbd183f6eb7f42119fb8fa0ce3b487b5d0970ffffae128a52cda3406bded2bbbcdcf13c9d890af1c11726e12556e75c778d907f20e00e4276c48c3223bd635ef4d1f5fa0ccdc517f777807f590931c9dbde581bce996b375e03905e30e636afd44688373ac9d7cfba380b2a119419b6c2ecc549f7343979e12af517d38c263dcd9e0621ddf7728f6dad649a92e78986d6dbeaa7c30d7c9cac9cccd22d827ae39c49249bfadba6e315dc9402121ccc7a0e0712d8f63c1d16eea5b5e7f7568338d47e39297fbc0842953eaebc1672c492376c32061b9caacee5bae4dc1c8d523761b4647f126ebd114f887263f0aba40c9408f1c288a4e8d4e41e31af751393ee0aea6a0a3310f8951c01bef57db1829c59781ce510dfb6287de7b6392e1ea9a28489d7c1a9a330a01f54a12781df832b6ee65466414cad37e4c772230d2eb4d9f8b21c59c426d366a22357bac30100c654944827d9743e760625274e4cc61b70fdd3c4fbf2ba69e5d5cca19c1efd860a13287be6340a2df8752972c20df69d8fd13cd453bfddad8a2a721590e2719b594eb5e68fc67286105cbed6814f68c6c34d15c96445c2f0c47c43964af2432bd362ce62e1167240c4f95fcdd2f5910d1f442662d2bbd5e5353360f2706035d981bda1794f1613628208657490c31f65e5ae7b6ac31f759e5a7d6efe286fbf3f39c56a2497dbcc244e47b462b1fe3540928303f382bfde476a9ce5e888dfb841856effd682a733b60074d40f3b14d228dd3e395bda49bd2cfc3825b5751b9b9d78f662d6bf94cdaa5a9c723b6d115a294824f25ab31b7cdd6e2fb7ec00bd035b91587ed4f70cc8f171bc9410fb49920d3e5d8f4b77a1d75efb0518903111e4cbdb85bfe7a3f0785366c24c1da24687a03e3572821679959deec350f1fc8e3dfc6ff3a4c6db22bd9ad45a34315761cfeb12ef8e45457e8d74d0cf1c23edd52147b88e158b4c5973251eee9b8b724a3c8a8cd08629adbf0fbff24c64c66d0b47e6e9692d51260a351fea1891910398ef8581c46abc4e62c29fb9c6bda01e4a7198d6ee002306af4ece6aadaee503e88e5354f508fb69389086fe95a28e29bdc30d43159b2c8c943f6c4cd84d7b2d70d151fd81fbad9edd6d3290bbfc8ea0ae04beb175f49ef8c4f186d218a3a1cbfa3ff0e489ea96f43b3455e59add4128a3e3acc6850b014a771b7f5f36d52ff80a1195d56bc4e8bcf86363bf89f998f1265408f25f9a505680eaeeba90121664183210a387612677514cac7223f192511d984933bd6e0d8e872b4a35cf74cc28ab64546b754266d736c6c4b3fe88d5e8c26808e13b018cea201c9d8fc2f327bd3a6a0aa7a0cd4f35209a66e53932b89675d52bd2ff9773cbf13ba76f8a40dfcb639b0cd86f1c19f3463376ab17774fd1b52318d8190d249e501d5ac50bac7765a498fa3b81d1add256837444dfec6737e7ca4f65ada0590be8a4aca12114e420f59c05445aa871c63169034df51530da11f05c32f3f1f7a36bf20cea62086ebddad4c60fb2ff0fe67f6812c4066c7c169f6e4e7ad682d8c5380e56d83ffe1767e87abca7876864806b2ff1f760a8895c3346fc4a967c2b2d04a20607e82053d34ac1e4d6ac752d04923670f5fafa5562f3fbbc69b25050c31de92d8dd5cba48eddcf47057966a7dbc5cc5e5237fd3b746b4152d9ff756d56bdb7c6baba3740ea7ca64fe427efd7a7769d072e393a1c40562eb2cf13291b1b7303f345c0e3c593ebc6bbd6a6464525b40e8352788efd80619070a564a93be12056b820edab48b4019e5ec90308d33d1b64e48649034671e13f30c53baa911e484511b76477429092d1676e58f307177bdc91d7e2e04a3a5bcaa3c58e0d71ddbc5dea436de81bf80ce878e63b80f594b7c0eb968c00e9c620407a670325b40572d201c85749a09b39a546ed1a25f36eea45647c2fb7c23543b289512e6bd35dd64a96f1697c2eb3ff51a49e41ebc44685f4cfaba2644604be75e798e914b28d29652ca8fcfb030613b09b35c3e7c2e137ed16d4f31ec267ded715e684b0a26766a1f831a39d90902b409cb08843c7530e89f077a8be7ba04f7103b7fcba09704b15480e9b3e5dc9fa5f48b9a8b9603363ba8c7394ed5fbd35bd5faaca62fcaf3139d6ad9f066a50dca043e16d910029846bd80a43e455fb279fc540d4476abf403c24ed7134640ae4bed261d2ffe94221fb2cb6d757c90524609470518cb47cc0c825977a3e2d278943b2651813e362fcac4854fde6b814a3ab36bd8373c075276f301c193bf80105235670e4666a15bb05ad064e8b6c7df683625c9a74d26b1cc91186d718668f22a9cd7d00dad503fbb989a1fc3021bd86e15c86bdc7838ce59d3a54ceb44a960618a0e51849f0c1f9eb7c8f8f61e219a90d599c868ef5fb869d9785cebb44f2bd85725dcdeb6eeba7e8943755468a7192212c92a3b73d06af2b9bae6d980541150e3324a2e3c46a67d83d3f4cd592d95fbdafde1c136fcedaed03e31b07c7b73195360baa32b49c42b9b69b5b599d73f22b639517d609d0c7f375f0eb07a61623cc3e659e0a6edfff5c04752d2f2c95a82161bdb1773093a385c2f8f80224f571559d12ad6391f9d5c6d7165b949285bd328704be5376d3a96b6010e64b275cc0100bd5c1b450a10ddcaf79fdbc6926d64f223115168811dc35a62f172eb500240494ed1c0bcf6f7fd5f4c39b6d7da056469763b7e7dccd5b27aa9264c999934027f5044e58814ef15474954e95600de80e5edc50a00ecb7f6248d3736cb50415649530874bedb858dedc310aa244807f973f1683b54d91daed04cf1bdcbd774452e6b238d85bc98e6abffe04c96f36567c4489ca6813c9377ff014d6a12bd3ab8e3ccb8d0168838fbfa8ff0163d7e69289132238c3cde8b564b932b25c8f3e31c2a9a917e25b85fba39379f4053a2b2e8cae06a15ba89a67066c1865bbd16b4c31a6b72885c1c818a87584e9b5aec7179332fdefc2851c2d61faae59ef0ce06149654c3a8617501e05796fa475fc1e6a671ddd379b3a16bcf81f3b7da6b440a72345f59cfae5e979c7c3179198695d886e760cbc64239cfd98aa639f4153d4872a79629a49e96b418696f5b69ace869dd798d521ba93d874d90eaa3bb0bf9876bbe22d21fc2d6e81f702321e804d037b1103d6f143437837fee0caf90d2ea0d783d18814c0035851708947e6099fdf1f2b212be636be8bfe5b04a4dbba3e6842681acd195a6897b6965ff55c4c5d2e840acfd6385ceef9e1b71b76047046ee928e6dc6c03d23fe32f262c386c31bc51c50904aa18edb46dbafecb6ca962eb2b4ab6e4fc8b75695f65f2b06abbdd261307ea08c8c7ea5b45cc192e3e56d69cd9f59592a02c0f3d8566c6b714e8f2297613516f0d6cd887e60d22a2602bdacc74502b0132d5bc5c9e3d98ec9bd30f80b3da51994332cc79acd4795185171dbe7e39d21ffd781f1f01cde4b9bd73a6e2a1c60681595849e9dbdeda960a02be98c625b06c5987ec2117b21fa9851d4f1713e707789cf6136676b6b7df2ea12b3283ef5858adadb16aedb21908c0086651024c12ff67a6012be64590d99fe2c1df1db07c26907130603a5582194e94f4ba25e28aa19754617ac29da6a4e64e50c8779283ebc1e1eb66bd2bd3f00224087aafd33e0977cb629fa2fde620fa27ae38ef95835e0ba38951542f3fd0fead511b968de8387536476b9abc7e08b67c74ce196438faf3fe3841c9d1107bbfa7c9dddca97e144a4b1dfe292dabcbd5cf2fff94b4a85bb67dae64f5b324ead48a35322621f7f41590ecfca87e1edd9a1acda838fdbf5a6fcf65c2d2a5c90c7735b8f8bcd67859708da9747bc06d42b27cde26d39466e1529b16efb2f0b8c8269666d24a5fb418ff3345644a2891bce7fc6678e8bcfa1174ac1821fafaf0b852410dac8ff33fd00577463276a4bca1552582c40a6240c5a7c6722cda8dc9770faf9dc7e76e7b1791ea39ba4646fc13c5fa2edb26540d30dbbbae3246041ef0c95f3a79bdd60eca932ba81e8e7ae4c0847f4866acd35fa072529f1fe3a303fad59498c540a4ba61229857e44f76c9010fc978dee99308dd4972f94e41bf171d6df07826f0c9a6ed4b6596c27d9a4215ffe72322e18e08030701b932670a92615256bfce5f0466607306d8c5269a65a1efd5f4c3758bf297769317b3ca5cc6131a1878704d9d432a212e7c69301057d3a5b361e0ebc2c2b4240b19c8bac12e27592a6d6135d0829b9cf2219e8d52eac2d7369f7981d08ebc3c3d05d579064042ca9e79dd19252a8021e77f98623b632103103f396ce2faeb286fe943a1d3725a190474628fdb6a28c5fef5059d0a05c2d19b7da0b595be3635d1f2655ac9651ab144ec488674e1316c7631a2c735a4032e4a76db313fbc5c52bd9b5f2fb964cb463e72e50df49c34f4aa70dfe0ca95b947de68caadc9ce32f9b672384cecc2b46fe7ece373179571fa7b83b451a2b1842e57035a05814a6f896abf702c269fa90c17d404614bf26e89f6296371269f6acc67f9bd587c1d43c401c0c8968f275602c75182d7d8134a2d8e513e22fa1ac31328381a3f5eeee30a999ec230f80b14c272f4179602c3c657e6c6100f2fb02f49708c26b533d22428629c374f27ecf802e671db15f85d472b4970f511fa916798079a7f330fc3175419072ae204222370c729ffb394440c9d953c5774e5b030abc3ec3ae0bd738525e3dd67e0466da2537978a45213260ef935db821d4763a45bbc6786b6db8333986ec58b328a0afbd3dbf6da3a2e2ea3366376933d47401394ba3bf5117850050efc26a84f09b4afa3e43191f758b1a82c0d26f3ecdc09cf7352246c4fc24cef221feb59cb9b67d35a99a75c3e35ee35ff08a715c1265100ab80b5ee74c906c9400da4f2ce30e0b2f80e4b4f0f4e4ba835bc12cf95ff7bdcdf2a21bf6863544c5ab7025fa12b3673b03ef911bb868975c27f509ffa0c7c9ba69fe8e66c54e2d672e29314a610878438bf4b93cb5584af791c879e96e142f9910ede8ded78076bd34c189855a68725a9a4ae1df81e701951229ae5e7ef098af7d7bd0bb64de283fa5e08daf550fc73e4d1c964e854fd07825784db6938b1577507b32bfeb062b8e4d4d46e37e3341f27d9e39a19e7e1cdee2d1105bd44e35a28a3133d13cb566c5e7e13fd8760a309a21b73dd49f0cc3e0698c0fb2af98197bad445cd2beff687abd2aa27a789e6c244dac03617c4b48e001d757b5c2f097e651fae1f328b277f4058c9142a578e64fc07473bdd422ee555fe0e876da4bf418228154d754ec8d61e52545a7aa52dc5fa5d49cb515e472ab68e11d1754f25fbeddfb2366dd943d2d74017d0d82c3464c99469344d8dafebe929ca63c829b8625c7e6a88e3c05e24769bed986ab5894b31800f44b13b7d252c6cc3ffdbb61a9d6bd8db95c30c4bdbd27c1c176f2085478e5d66e1a9959519b25887084d8ab76825e776d6a817e59bcb37565458a0bda877fcc59c0d99591a234b0342d53436b3bacb24dadb1694352d855fe7236aab403d12c3412d23ce18792127f44755050165b4aad138a92c7123398c2d62ec98a8f41e6cbd9eef691ef825724fdb3d3394e2c3864c6f16679f325052a1432b09b0cc647d78b140ff7234f0a20be4161217e0e2917835f2a73513f39f48551365458f85849e1dc392dccbac170d808c123faa0d5573799212375a47607b94ce3ff25207f2c310d6bb20e0bde890413b16c8a793ad4751cefa53d7fc495770e635d0745b97d5073caf8f515129699d0b9fcffad4564b761d0c390592a75c854507c71d830a4509b76c2c2ac35d5773936a97d53e7458cb0afed19e14fd3b4845ef5eac357ecd130faa283c638abf089b93c7a9447601d39808f65b09dbaaa3081c5082841335fe34ec53d8fea4a5a9fde0fc4ca3977fcf133759c630b5d2bf60ff82c6af66662d9e7539fe2f5f8a3bd3353e091b971b13f6a77728bfddf1b402d5fd590cda54950955e2e62c2e722bf7436a8408f4e1858c4c6964683387d43a27d3892cdfe13ebdd93419e8f8e05e2efafa450cf344ade4db886da759b61adf51a18e2139220cf239ec9026341f9745e1a5d9c1d9641cf98010a2e5b57dc9ac130169e3a6a0a34e845d40c2fcdd3984a81f0ea2785cf70be6a12642166424e1b3646a6848264201e68ea35d6db08ee5fdf60d14e8daa10781a7a718f2f3d911903f3926d6128e2bf53d75f1ee302563384b706280caf3336d3ccbd91fb8bd8a63347d99dd910a7b26f2b3ae51bff14d3719d8e44a8a9b41838da67c5be7494d77d5f6cfead7a66d6e6b64854fa2f2dafbb516a9113fdc6a624fce5ea6ccfff890146488d1e359fdd4f1634b574266335e67187db37e457bc2e84da4262baaa175b67c5ac5ce1d5ac117eae6aeeedacda9cb261708a41ead186f2cfdb0006ddecf43c295d2239f2e7af5ffba784c4b43ed4648051a5575c1d0aed7a5e73f129d5c96750d720b1f40a9774cd6be9264e39fa9654d876c8764c63a73869b5b308f25e506bad32fe5e426a37b169438d7963c155132f2e868f0187213daa313f463900d602697b965fcbe5791da0ee2fe18434133da02343ac3130d88ecbc8801e0eaadeb658bc454816cefce8c6f6fa31f158563b7476ca50953b66ac6722d6e3b92106caee22c1e80ac8c2a5453a0c6c7d143b1a798fcbda9755a95833e1bdc4b9497ae1bd955cbf22bce51e1d70bc8a868eeca94e04378655016e0bb2dc84f27c35211e5da43c88465d4f904ac4c1b4cea9e9e6cf24058d280d6d0061077bedafe2b8ff13aca42512cffb40498541f19b8a4cad188a4c705adb2acf91c72b020a767a251dbf1337493312d53e4c902d7eebd3f405c0246ed70e190dcac684a6393cabd0084d6f20665c29860e44ae724028b2ed8d59ca3fbcb1020fc0942c759abb2b166170c0e3d8b26ccf5c97fc65a4170180c29e56194b45ea96d0e7268272403b6a5f966793c11ebe734e80d119b1658abe3ceab31c0375d0b87e6789c69ea61a2d895ae15a4e50c8dda83ce8645699b1ffb4b907c2af33ceb7a560d8bb965e295e5ce6fe3d50c60ff1b18d1b7a7d77d6610e24f8936274f5acdb81319a519b096acf9781e5961d9f33cb8fe4510ebe69199e0be7619518d12ac6ef8fd20d982959bfc4bfd71af70a2e7a2acd44d1db9d03225bca45a5f2e279b52d36802bed9eba016cea82025b5813583f3531b7bef05b3fa36824a9b680f14f82841ea9bb082c806f3cd77bd2ba24765f5a888243e94957cc4b3c4678b9bbd34e6808b88d46fee06f7630d05da430733ac954d30816b88a54ab178f3168b4eb51e719cf2bf13b3c86766bc9f5b3c909ac8239502a5a6e95798cb417e5385a4da45bc697290809d2d5c83966d9402a58ed64e85f8b02b32a0c47027017a00e7928563b933b2516764cc8be344b94bf35496af018cf297d005ba2cfe20c5d5ce8ace518456d9bbccd7d53f03d884ef153187807e293b8e85785c71361de171274aa7f5f4b0e100f4c869f0ac9e50a6c6f113f0def1f659011e3edd2b3b91e72711d2169c6e747e5fbec3feb4c17e6c9aaea57dbe0c050058d4128d7c726269ed2c07fbd5feb3a4559dc76907a5cd4f0ab694ff2393e95d896c9dbd3ef09b392d51fed4b411e36c4c6322f18913af5cbef2e7e0d23e7578d6c3def9e9d52bb9f0a58d7eb804883c8983bfe915a6fe56e4ce55c6d747f9bbfa083da334056b2a475c9f3c2dc7eefb5e9929a510d438fd07704bd77c8ed878aef722028304b31096a4fcaae2e57778b0a707b389039229502dc595d3c5c45120c57e0e02bbd93b7124ffde6b7f758015394e32c22963b5fe7939947666c3c037acd0096e61b0bffafddbff1ae940f59017302a6cb7e2e4cdcf08a11404cf5fdc302c555c8a9b66b50a83d815da9c9986f1cbaf9c4c8eae5d99affdeab17764f3d9ca8c76895b185eb6ca7126e12d8f566a5975e3bb500ff2f94fa62081f2a50ec07ca7b0543a745e93592d015c0030b77275ab9b7e40b8706f646a55d7adfe13324b723ced3b15ee5b63fbaebd88afcec794f33855f3469a02426eba8d39c251a983b5c0983fb782fa045677d83fd7a43a934a6722f55ba36718cd14a79c082f2089b342c04da28ab78696bd31f20583c7f18026534349aa5c608dfa96106f2b17825b60f84dfed91532f91f85dce9037a1e799b3af0909774b08f138101130527126f9100238c024138440587ce251e9a8993134d315f0fe303ff9b8d0a00cac9e0c212309f50819945100a7c4b68dc98f91ed46bdcee4abb3a881109c9d83f45e17e107a4c9c6d55c82f05acf6c38ea38ab648b885ebb1dc1db39b2c6b3a674d323d17c7a266632a897207cbf876968e4f91e2e79a2f63a10f3d849880f419a4998c4632baef5da223c480a690d1932ea16777deeb965771d74c7bf931e2aa2ec81267c685b754bb260ef21397414cf8f0f6ccceb9d61cdb80f438da3e34239de98d580e827aef707e414bae142f053c007351cd9269ed837c3ecf3b51eb3a8c2ae5280b8fdce5ce9d887fb8db64ce8910b7eda71c02fe536dc9b96bdf97ad93f67ac03edd300f854ba3de5c591badcc6f8359316a7f4465650033b99614340a42616c997e469e0046b0f2e44bd1e880937fc07693293ffc39083571e8024c0b23d2ef0678926bfc8e89cbac09b5324a36ef66af23442acf758b62a965a39c4aec48dcea8be68eaa41cb22a487a9f330023c58a96418f679ca8462871ba60ec6eba7ef49ef0f729a62a58609ed7eb0e91ef7b957e2c7e9c5bd51ee83236ef939c0cbf15c973b61a7afbae21c47fc19e74f74d88cada49c965645441f0864868043697adc2f8c0cc6ffde6654c5bdd35abf9080a60cd4138a5278f8af066ad3c39f6fec9e0fce75e41f6dfdf642a13e2b3cdf92fce844dbb7b6d62558f90b94c824af244a641f216a568726ad584d71647c384ecea564baac53a94ac0ed653716220b06068583d6741f8f4021357818fdacb300f3f5492ed6c64454f8943c3362352aaedb008f0e8de3e018cfb939e7fb35b0c5bd143766e085abef91090ffb242a018d5f13462eb30d684917781c5bee380083c8a83dde74e09904e155a015680da0c3d21cecc604e3d7bba8734cb4a0af0d8537378dbab758f58653d1e6738c84bc6ae10605755285e248f1546b343186b27af446bfab119d209925e1b9ab4b33dc6ee812603d532b446c66621e842b6f02274a4dc510f5976f5e1e7f91aa63b168aaea05c835f5626597f8f9039085caa0cfe20f1caeee78d494676f1d414fbe56a154012b53d96898481a37b7029cc931c8dff77b16b2e5d72d4e375fc5d7d9905777dde68ffaafe5017b9034542faa0408e52e180c60b5b5d16297983a035d8d2502f3e57449b8d47747a85ae521dd78ba118486dc97749558b959164eb52734b7457a24d531993806ca79ddb50905b4e9c330c531aadf1a38378fc7ca7f0ed755b52023db2b3ebcb50dab86dfe57ecd5717d6a7773a9fe68f252b3c3d51adc3014aab3bb2653d95b75ef01cfb72a6281c1ce7c956b1fad1b94001244e3db3cc48227bfd64ce586bd0be4590e9859f23586024d565a0848ed202480380b28e89a53e4043434ee9a7abd85a9e22d102dd08e3639e745ed85d263f20dc5b09f9da98cb247ffc3b7435bd1e1dbf7f773d99dde4295cb2f22b36d077e58890613d45858d4b43139130d8a3e303e7a666c0d5834fc1dfccaf657aec05cd344c47cf63a6d1b65f62c26bc023d48a9152fbc6158bb0767a28f441a0fd5d3e072b6702f610cc8c9586bcb28dcf5d998b82671c16f095fb75c7d0966549b4251be7269399d0f96a8556109bedb4123213ef3de53c8855dcc7d666d7f33e54d6bddd41947dca930b6bc6392dae6d5c5d3159c98e0bd9dadc9675dbdfe553944b0088fb4dc222e91758e0fac570d523b60fdca4f7e8cad29ccc25019d5649f3219313bdc2f86a731c46292c65cf0bde898660fe84a67f37592cc60e669cc9ea1a96ed676a002f98c7abcd30abefdf3f3ecc95b004aa7e929c9c0726a2adff74707ab14260a92f3cd7f7ba8a270fdac61efdf31434887a98ef8db431435a936d86491845d124ce6c77a011d121fbfd9b3d62dec31f58b7274f6dd313568c7210e4261b433b55bb7e1681da66917f49c72356dc62c4d6d7aca0145ef059ddca33deb2dd39d1240d65073cce902dca37dbe4c8ad4a38ece66d34d7039f22f2f02d283a3c0ef039ff0d97c3778c8fa8edd604d87deab3b141040e52c756a89bc2d53817c854e5f1eca2dfb507735342faac8728e4116cf400ebf8bb7c2cc7f189ee0815a0418a54e318774b3c36f48ce0b4a135d6e074017a04702c797bc174b5d97af2849a5480f6817c10c05ea34985107b42cdbe49787c6a97b37f473825a0f70aa47d2dc95af9587e6b1f6494d8d7034be9541fe9809cc9d2af71bcc4e4aecd589d4e94925692ba7aeb3401d03085955fe59350fe287d4d5e2fcb8826778eeb24ac551636a2ba66bbd5311ee679cf8862390255e97d98d746f723d03501c9469f7ce092cd6d5ffea6f285bd7a2dc2b67a4c289dac4000fcdecd0834d88dcef3b0690682b743a26c76ded9e683483d0326594ef85555cf0ef03856fdb3a14b8ad9d09fde63024a73c3d87616f45118187479ee517a723c7b7f297a5ca6a7681e780c4031e0a5d5a721273b3c2e15c75ffecce060d081023616d057da6a4d6215e8bf387c32d5c023ac435d61a32edeecf45a23018b2137db71f79f02cb08fed2f68dd2abc31bfb7a36b86e4c42235bd59ea86635eca2e007f61689cf7f6eae855a5f45c753eb64d568c42790f6a8af3ae99810218d4b24653cf2394d95c05b097dc06f741cfbced4060a71b43a8bf7c9c4fa137a97f7db89c224e7ef7348aa2158018e664c6b09433e61dc7a289568d6b484c10c5313bfe8f25b61521c679927275cb47adb5c4f05f6db52ae2038d3ded312fa02e3a6d7d33e76d076366cbac0aa0f935095e8b19c94f3ea0b0869f9371d7b60d12471a400cbe40a8e951155d98aabc1d4cbf8d54c4a0ffd54bb3aef90b96d74edfd9cb22fea00a5cff3e603cfca5d87b33c3548dace999982f5230bdbf590d2416ea85f3e8f7d4f3c2573863775f73f7766ba25c5998c6978683ade3c1f4b32e2648b3936bcc553d68f3ef934543426da4fa82f0139c1480a99d37ac6f9b411fc017e676a3e756b7cda75f7b0c487ca31acae9780ac4b574add220a6760c1930b74f8890c9e92c9071e21729a21cb27d9bb989b800f7cf58aa7347c74da5e32c348d94c8d1347a586c45a5a2a0cc55548da72a8e9d92f3a57d7865aaba10734cb54d15edcba8ce08adecd9101e97030b4924eefac297ae69ab2711f1a36fcb462f530ec7e3dfabbc8e8451244230512fa040173a748d08653f8445eb6c5af4cbedf460b30b5c558866196e0221c392d0d7e6ff828c018a66ad3e7ed4f2bc99e123655836eea3792c95530d3e5c7e9c68f172d7488e01e6862ac1f4e2c9054448a211a6dd35b7c4b8553172f69cb734d0ba981209e8111105cdc078fd5fda285b91c197c14aa1685220970cf33e78593fadf7ce23fcca5116c579b3453b2599ea0b5e38ad169fa19e8fd64bfd57de03a5ed84275062153960c0f4ee814b85ae693fe5e29bc68bf7cbcbc32dc87944014307d31888fe73f68300df87a861f5390018366db542dbba7236c63b901481f1ff70ac676eec801f23379fd085c21426dab334417bb2f84fd6b6903cd3c34a206975503df6e6199941fa58be353c875d85692fd6256deb2e7b25f11be1c464d6afc33344f7cc3311c12975d81107a1ac03540dc1686409deed6cc75e4681df64a73b2561b1d7a10339d2f1179d3f709d2be68e80731b24c84a399a0784a2d124112bee85f175cf3250de6a6eb2814925e7b3be916d43340630b1f2ed6cc88b0df4fe3351ffeb473552e051e9edb853154d32fcf2d52873128273a690dcd5b1047613d6ac011623b786948411bcd47819f3065e5fb3b2b5c0eee29cb3b3d37688f6c525f6eda29be54f3895ea16fa367eaa8dd5d8474d53297c5ffdf57ad987f1e2fa245ac63071decefee7cc8b21cf2860b08951da7a1641953c2dfb40115a6afb7e061b0ac4c7ee7ab25172d2e51bf56ac8c826858fca1e879d172b34eb146b0c30a3b3e929481335739dd4364c5456adf73e3abc3e87e7a457612a4bf7beab1bccb6d7d7229751d97aff97c2b1ea376a1e2d039f820c6ebcd67148a7f75333927f1fe60419f940f92bffee1a2ad0b0303ee2db394e32102e1d928a823ba7351a449de9f9e7acc7299a0f98815d3a2f08765f293042721c97f6831fc045da1883a712bfed20e8204aaf0ecd40ebc7298897f2a5b15a7bfdc0dfd0e4b620cf78e6b0d44f7c6bd17b55d4b57ca223e504fcfaef08b06d13cda5d75597a67a64d4d03f3086fe80bcde6b65ed86b3cf0272daca9e4abcba1b3c166fed54cba8c6feaa4bcf2677c4f8ca4edb9cd07aa886eaa1d6d8018b12b6d2b4cd24f5875c187756854a650eb2056b42cb0e47fc9ffe2452b78c64b9c519feaa631c7aa6e233f8c49f9da94e239f7ffdc0b4a14509d02f616bc20544a789d067450d3229210d87de097c6c25c69ef8006c3c1ac4fe67d73fe9d6d7e91b919a11652f1026d35c6ede3e26af49014bed3cfbbdc7ede425eb75f4b9a8947cd94a9113c579925bd228d91d4f38f67f4588345dcc36b965e3b79284b7c84ac0387ee632c922505e2a8a1c5fc8afe857969b86b3aa7a17a0fd674f4b3023c064c9e38ae69a040e4409a9a50890c93638b03867eaddf93d2c0fcacf38b75730254b448ca21f0256bec47833362505a78065eb22f003a3135042e5c21cd4a3c41c390d662c8e3864fe9277551955e55b43745a11334fa0543add4350a6c8592bced73bd1f3d2aaf844b1cbdfe6b41eb8b9f62dde42fec54475cff355d3b6ee95bb7949944511baf18b4977cad13173906f481869646cbc46fc874ed749f85f292d81d62a73aa0170609f1fe48771d5e05824f8231bd5959081fc13a4f1a90d31e51d5b9dd25b30a6562a2856988719ec12f8af24325f8fc47b8d37cbd3928789ff891bf232bbfa31ce29620a54c0cbd19d2d58002bdcb2224c26300fc685680bb26d7b636e06eed916e129bc932120b0db57b5f75f265f63366fad0844211a6194e9196f05c61ac274515ab8a44d9edba0ee07b863f7a03321bdf267a5d6c5b361ebd97e3ee30c02e290a7f56ead578cd1024189844ad356018f4733d8f26c3b1bb59d15402c1992e54b8ac115aaa5e04fe87c71dc7a125162d9a4f7226de5c6ad68e645fd8ce4e9fda65c9fcd6ab5efef73c07eeff82b3596d4c8dd41795c6cc271562020353cd39f1932178f2317a313e75007ac58d6565473f2e0d111388e993f482418750239d0492d9406d196429590128a134db2a2b0b3ee91ba928e237011cd8d157995705d9d5e5c16602f134340a17d393d114319f26046c1ffb0912fa7e2fe8abc776fd7c96f6119becb7d7a035f710ceb62b435ac8b3a778d4d3ede6727457074ed4bb91527f7fc2524e39dbabce2183c2da0fd27d03eb542832683bd93c65c299492ea7db6833b2d396dd9161249b41e22e05ffde6b754b7dac50f559c0cf563581db7754860f73313f28c639072052000957f55739a746f84a2e672c5ca4da8b1d266e362e44078962c64f4978a2435195410e50f2875ec143e1fa98a80c75e197462dc21a4f4710a5d46eb84b336d9bc90c8cdbc7424bb3222abce53f222788a588937a5392d38471ca8d10972b2ea2cb73597552a7d092ae54ae133838d574e3cae86289200a21fef491ef9587b816a1846f1d2c7c86a1c53847e1e62dc6af1d0fc92e0aefc2a55dbca24b3f4e18c1fdd2d1d52d827ebebb2b2af5d6d22478c3e5fb584084ee207cf4a8096aed6090c9c7d4e598c0395c923648abee91d3676d0d2ce82aa3a9ed91f0a1087b133d841c7c7f7718f2627d63e9aad0e01dd587d01a5eef7ed1e38d228c25ad8d25cea20a9d2b762d50c33ef02fd0e9d723ac04133964d0acb9f3d787492334070ef166b329d93af95e2416116321f2cf9266dbc679e4774efab7c5987478df673ed9deff5bd3dc311fcc0111ade3bb8016c8cd34897e817d85b48ec5cf9233a9562c9ad18b3120af1d173b327ca13b88beeb6681df361f1d23810388afb7b49697202b63a78ab32989181326dbf8800ff29ff631cc6f47de1aeb995c721074c147ce74c9695c7553be80bcfa507b11b040de29833f6400ccf3bf674b2811f8c0b394175229df5c3599bb94b9635f05b35dd2c38e6a37f5c9262292aee7a473935d8f2032f8b154fc669eceb5951773673f8daa21a747526a6d82f48a111bf22a7b16318fcd91e1a312b12911211a51bebe80e6ef1cb7ae864c02d1fab24179ccde808416149377e158c09d8dd459163d16e806b4ddf8e4b18314b936073bc450f7c2d96478642f81022d3389c72887996ed11029773fb66793fdc661a30857fb9554999684e19408e1713e17bbf4ffaffad922b4712f1f9918f15437be421fab147ed4f1c1bd6899be8affcd4481f29c31866977fb72a207735fcdbd2b5314a25404d124223381baee8b30e7d8c0c2866aeb5ac3a2b0befd54712e77fd758a6cda6851bdd4d72abb05769c17c0080f4e738e98d45bbdc57adb04565d070543f96b0a0401b73993bc75c6b0c8f8038390e2f5c6eb91f78d8279138ca596ce44b65db7645d6dc18b44566368f6d7fed97a1ad64af40f84ea00288bf043b0a582889cbda55e2bd63e3fd527af76e6ae5d54b4049b8eb9702a39f786926ee4a56f872870e0892e79d9abebc00f71d24e983995500c22834e99e2c67838adaa913ced02913bf6ee7fb2ae4d01270e687d4b4dcad625e9648d178029abd4aea6174937b6e0959afd63f361992691a5f3e38b568be14629366b2eea3b1ed4a3c10d2404353173cb1c336682d6db03e53f9e56f806979f9001cd6ac462dc8ed386626f7d0a3e2cd96666e222415f270614046e1c92a5f857958fafb11226a8f662db9dcdbae192e4bb8c640d089a1a0becebe94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
