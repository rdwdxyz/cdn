<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f729b404786248456627c9eb719cb8ab6c31642051c62dbcba0fed8b72eac3dce68ed26f5709f6b0059f7ef180d9e7eb9d428acdffd312f907a65a6f1176b785cc0e87f95b6e006011c36e2bf1a4fc0593cd129a79092b96dbf0085aed4fe575cacaecf95a3840dcadb019660512a35df42a8354fe4f6166fc3502e429b9b53302a80f32e3e45f1aa4c68699e9a3ebaf4004e45ad54c656dbbba04ba4fb67dab78afae260c6fb42b2e725102e358bf23b1825e3eaf3dc2406c45c650478665a6e212a15035ce8686b4fd65d3a7a2fe893558ce5c3009305ad3709f833b2e52f7b270bb71c240c5d2eaa81e5a2d944debe74a4b0eb882bdc23dde003996e33883d18d1eab4f8799d736d0fd2a12655963cbca10e491909ff02855aed3fc325a7aed3709afaccd54553d09333348b7f703110a15fe0652e664bff9511d4866766e8ba887bd2d946243951da255b8cf4ec9ff89d6e8abab8f2fec31f590f492fb8096c0d93415a6b86befda84cb27ea8a02a8647693e7873a3a76ec3107428834400827c2886b6508f4fff324793b8c1ce9bd4f72850d09dd6a2183246cafc3f20da1b63ece73e3d3be7b9d3d643b886440a2554d8ea35edbb59904a9b420b8493822decb43ea9dfcdea8b9488dfa802648b0e4820421a6c10fcc637321d01da2aca7040525e7dde8ef7b4eda52e631bd8f211d73bc8eee5a1edf4cfabe2abb535db4936337b529ae3eaa152d12695af8d5f6a66db14eb08a54e32b348a93e533f10c3140ba468cf718b59abb6153027b2bac8dd013b4143800654916c3b51366c6f1c3773eb3238e067368eda0ec2de90b582983e9e6523a614f20fa5af9d46b04ddcf307e918a9b651900d1125f2759b7a576148554f606427c5ef41d96d969e16b9ab0efee19205464460cd0cb55523e146fe0f7a5f3856120c78c5385ef331714c8e7b3beefe81c53f2a41645df63450b7a6767027fd0094848fab21c61a49539e66d20707507468554cdf4c565c0aace16004c79420a6e7f8efe7d228e3e3e3c8fa9a6241d877537b3d891f08505137dcd93d6b2262530952b96bb3736d60d1a46e611e1a346238375c74201c9dd464985fbc16708775a30ee771b76632c35757ed4882f5c0efcba79b7908e5b73dd0d24008d318d4ab4fd1e8341868f421433434d37919e752fdf994b34160d7477fb19ed43b55f9711ba7f489419105077a8182f6db81611a0df0dcffd85c524604c7639dd092a5f9d6b97e513dbb24bfe0975b6c47d3c817aeb26cb5fa7e6b082da8772b48624acb66004401d6db0d97a2930c144fad7f1e4b026782408a835c926148a227f67bf42547ea6bc4f16d3ea1776097c9f53357a7c2c63a54ed9fa9b1a807bbe4823482d358d51a4ded81073a7340e65530476d909e1cc5aff9e02f4e56ab51596b2c388cf673b1eb1e8acf5b14c466e9ba7d00f9b427d91c8667c1a16adf08215c7c23185cb1d614e854a529ea3239bd38c771ee95146913269cdd4ba3a73b942ecf10facd5d0a92353a0d8b1c215274f8012a4bad973f7cab7585b5e25a8ce55447bec03fa7c2f530130251f0ad9ee29d70e591ccb9820ce1deda1ce371c89f2b9ffa4ab1e41e9e5523ed00ebfad161b40613721479f9eca4b05efdfc0cb3e499e55ab963b29632a1a06dd96742ab0245984eeda1f7722fc8352a0469468f2e2c98ee3968a6c1e1edfaf591313a8e721f3dcd1fb9918ee3a0e74e5678438637a2b08a7467966043b3187a8bd06ea4f0c01caa626751b6381395ce81136b43301e88c168f86f880f2ae4db312b506ebddb0923c62e99ba80751fc46e4e02291764f1a7242528a9d5353bb83bcf84234bd22f617378b18d7b9f676b02eff3ba3e5ae8265d4432585172e321fdf7c7cedc395d5ef0066e465b7cc0912f356099abab91c20d9af93243f39967d7cf7cb0566899785f1b00bf8217e2b832a4b837ec42f25b575de6cabf8322bd2b0ccc888e61ca620d5052ed5a1fc4decc1df0879a966835325bab3511411f0f9bb3b6eedfe45b249874b18e720968e8072e568ef1bfaedd96028d4d83a3fc7460074189c1fe1eb37bcf5e98f488cf9a8182bd738931e47aed8b42283bf8d0361281e498f325c0fce19688098c4fb06763c4badd6e826115a43d244450ce39cefae5f5ad3db6752a8dbd494e66305eb3abdefa423ae2c7406b9d8353dcda6118df12ffd9aa7921142cf316e33aca43929e884dce3fead08fc5e56e0959ca96b75fa6ed92b8166ea523f9db2208e3071bae521447aa31f3737bb172acbcdefbc1e35449f4ea826b8f4ec6c8cd0cc85b721a190c465cccdff105c3d04528926422f98cf62fc647c8429b6c88f442c528753ae1a7717cf7d0764a5ca7512b4d38baffbfcb392f9f4c65008716a2e4e1051e2f13c51753c89571eb6f427caf82cb2691c8529d9ccb5fe1e0104262b895ed5b9f438feeab6e4c33080526bb7a8f7c52309cff5a60c0edc1aaa04c8ec5db8c6a22edc4062e6aa09a5e77ffeafdf279ddeb619765c5245fa071dc89af3733b4ce81b4af26dfe67df8a922a9ef8092c3bf7aea28992c108c9d3b73969f85bfcb106a31a676c52a14665411e13a15911de4c64b2fbcd1d2fd84864a827acad9d29287eccdf2fd9ba2f432b599e200ea9dfaa31da5809c625c7b75ca1ec61115941ac3e4955dea0423159c2c714dda93afb343688d86355354cb38d5ec7e084db0af80a2cc16890c3cab08e2f8864813ab368f833088609ee8d8b134b62910061cc0a06b8fc75a3b3b3db17be6af8f91b9c3a8178eafce0c9df5f926faffae1328865c0bfc1c5813f4c148fd3ff4cb931ff099bfe02f7baa9c9116d7673938d39a6bba32f6335774d7b0cd95111385b64936dac72b723ee047e2c5cf2fdfe837752ac88618341db526047f41bf2f79d70a302c3162475cda10ec6f313c88d7b8f969f88113ba776d8b198b061862c5ba03a14f59ffb125c54a1109a451b4c25086ed9db2faf14c022ee0b1e37511d00898fe73386a7535bf2dfa64e74ba9d7ec50dd77aabdaa6de3e1192590239dbc38d5601f4a733647b6796840db8fd5cb9c3c397806d2003d4936060e24a925133f01cd5c72f6f8f15f9d19d327b17636b34785e631da2e4e2fa3c7c792fbc2ce7f8207b1ce392ec7d870f153c70971e0528568bd69d6cb49f1d94abcd82e05848726c7a323256832b45ec17c3e8750366b12792a42f07ee85b1273faa0b03ae3d6ee7d1cbd814ce45b688963e45155f4dc65971b4005c91445e43133efc1281a979a2779401e60f69c50bb8f71a7c3694d5b72517e389ef9efb3fe348fa5914e33f6321fe0ec9b75a881b8c91f0f5d9cf56284cef783a19c29b56b8a9e1c135557fca348a026022e64f5553a110612400de90551cf775a3b063d7af27d270ac08928a5102bfca8ec7b6a89d92af9ee8ba753c113db0eab2b31060fa21f59f8467443659bbcfb414d90df90744ec27efbacb9fc6e8e8b81ef38a72794730a812408a272fa2433f1e933927a18184a1a0c6f5f96126a4af929e26353cd758a50adff3073d236d5c38dffa2765adda5bf84f0c7874f4d71f0bc26e030e20ccc757b8d3c608f912f5005fb6d0d0e6734eaa5d0d1de08a9f51771a064c1930c9b4d551c90747af7b9caff51601c40c6dd3a792c0a60885844a5283ac18f84826c23b1654db6bf622285337d7d93952e3bd164aca41b2099ae1cd5dada016018691d72d45a44dce6068e3d6d746956fa36540b76f5c2681782144b13d7bee2658b5a4421a2323421535dec34045e5b6beaf2ac30947e28a87224b465e1d1fd4cfd9ad86abc2ce86e285f3dff4f0d9767658e022399ae86820df760d15fd5001a2c9335b73fb0a03f23979226adfb8458ec7810083bfaa3b7b06462789bf3480207f5a5a940818f92458c2fb5b45070c1eab619823224ed8db9541252405ea28e0b38b16f2ece3d6f2499d091ea561f42cc6a6b6bdd80f0973c9029272882ac681f27917beede0fe473dabbe3f59b93f5b74038607b9a6cac914103ad41b4f606ebb43264934b9879ae0afde260def090a8bef1d20cf48620f625b165399eac220156bf792523f7a1094171635f3da1f44ecee5e1607b78d4e9f5aaa6939f94285392d8bb4a47a600b1155b377a02575127b46db79a1ca33e27f994b8ff4b11008d40fb33eb03dbb97794e33847549e7f9457a14e03bd8a8918724ada879849496bf01a43075c6894a14b7f6ea8592eb21d756e7e2f83d257846f20ba55325e212547473c2616714fda20ef332c638d7f38f537c196f4e0d86e5fc74fd2e5be10ed2633d75723a63b2d4a9b24f4125d8f2b8a80dc2659d0f5bb23ec899c695c2363597f1ed098e218247fbd8c8f1f15492760c59be1953a6990111cc88d58ee47af632c0727fdb8e593d5e93318c253d7d5ae8ed9a01cb0d2e3478d37a41faf609b7bb32f656f10d3dbc223b1d4c3cdd57f5871d5463f43cdb553c7b5f8405a70452351597292e854a82bf692e7e444e31c6231808aba63931580db2f74146f7244b5958babb2d278286ecf3272cb26e905d8a588f9b6a4dbcae7525d438bad51a879d50895808f86b3c980877392d2806c91800f52df0f7c0ac0c29362ad9480b81943b8061c40cb931b70fa74ebf1a0203027484e67835e10d160e78577752a3661e5b7b8a4dac1599db265e0511dcc69426d0070f627f6d3ad4c0321cd611484880d261446f112b424952276313e522f17b72ec76c64fb719bba937f46f9c742632dca2f659f64d117fbeb0cdf0a010957b74ba6b1cdc561b7bde139f93bae313b883cf90a7407b4ef8c2044b1e50de5d277f3a9285804397631240e2b5eb295b0d24551b9ce7164d0350bb42bf2d08f9a4943bc354df9661f8a0daf082fffccce7d542dda6b5e047fad7f516ad40736f5ca23e57b9bb64a772c50f452807ffc8fbf12993f8c189a86ed1bca67d1f4a46db249f28abb144f701405b824b891ac5bdc7d1b7d100e7a89151609513125b8ea401b9f0b4fda3ace1171e15f16e8c35804de79c7c7e2282f03cb23db33350d83cfadc282028e697365af7a3918e4f1730f5898f7ffd1ae2ea03ab132d6f8af81e5f5ba15dd2490494530330d520f02c0ec8621366f01a53311309315e8e8da5822ec3e4d18162457cf3758ec8d7571cc8c17f64883f2ad3c8738a309a526d67903b664c519982b8cd50d126b84d0bfce2aac40d63a18849a045ce112088d6858c3598f47d1779a198713530d58abfaeb666823089dd5b8f32e099e6b064d5fa8bb8b1b358f623140713c5bc5af6c0f82a997ff006e1959f65cacab3cb52a2572625a2fac69117017f90ee0b72427ad1fe45291e946795a4dab1766e783585e88b5dccb95fcfad01c654a4ac47eab9a6d66af97b45324e66050b045522fee962767a7d5c973dadb6d05eb1701f798dd33238137f8a76fed0a872c9897099e884c7b94ce6da52a73c3196f74f8f8074a0975139f3d3554997b8e97bed26437b4a4445f4785a63f2c3fe6fa7528ef28bee45915c45d5bf05a626f30fcf7c969e720805e5484f341f75ba00eae165bbedf44d3083ff1fa440f1c895fa22097de9064743f0a566055b8afc692960f4c410dd65c6dfe1e4f8500088902abbfd9da37f4b95c6d108f6457a17a2b67df387ba2602f21a394471f5b4ea2a486bea668a8fae57c1ca5dd6cf3a57af1c737b2c82eebb1fe4f93b82637ed0a2555c7a3d5d81ca75c23f583fb559eed526b043f4ba6434b078983d6f58e39b66925c9901e2de4591a9571db139add28ff15d2cd89a1660b8335fab9c0d8beef322c8f8306c6b14428a2e1255a10301302ec491308f220e3c67a9f7021934fa875a4778257c889227906daf9760e69f38556c55de915e04cd2839d2a870a7b26074fbabae68f8bd988f1e3d525141db1850d7effcc7577aff33cea531eedfcb32651d9e846126ecf15a34e210259b05140e9af4ed4450af2cb2b6b715c7517ec6071e3b9ecc4c5abb0b92c1334358164cd09c17f8915efb82ec312a571e26f4891bc4709fd07da96bf9527be99422bdd2e531c16d538a8ee8eb49dc6bb70586b3cc833aceacc184e38e9ea32543e34f40b7cc4449bec5d9f6e20bedd6513b56adb4d592fecff0e7b6f11d39b0ab10a992cdac0c8e5beedb02522c25d12329f15901bfaa45f91ecfbcbc3833e60819014aa5709e16cbe9660da9ef774eefff325f6516f32325f83059ee59f4b9affbd63b2b873660889a3a7c900bd30d838162a6d17c48439add336d5e225e2286e86f0a06321c18b399f9a88693b592002f048497a34ddd6b92918d8e172e0d7d510866f49d673979ed1a4d37efc0a3f104ee24f2d61fddd67ee8a40ba3c19d36150decc154562adf5b0fdd47d44d8a564614594d872dbd8b3be41e72adaa88c03979434af057de0816dc69a0eaf52ae90296870e3bf1dc358e4dbb941e43dda23b78e628ab739cb90458fced0456083e67a9db3f4f8341633a4a8246ceb2e94df6f4bff4d3e509c65fb85d22d8b0c9f489496e6d71e1d1b9121e4ab8e75e245ea6a0e4c17dfcb7ab8fbc2ef9fb72ddda4a9f0afdc59848d0640b0e990c3059cdcf9376d9b7ce56b5bb1aa13d6bb56ceb64f027281bb859231b89ae2af9eebcc6f4c10e58292c9f0181902e83868a42ed698d2beb5557d43f1557d678217753cf732efeefa4ad5bcf343a840dc804c0ac73d64c38da1e0c3ea1f9638b8f65131eb45b7ef6d16b25bb3111dd877924473354d28cc8c6510cc52d2bee73b421913678c45b43461d191690bd55cbe2a76d3195eea0d2a4941040be5b1d898279fb216da710108f7e2de0fece7e23572459f74fa40806e52e5cd2679a489ac0a8b6e76a981582f7eff3f84f191d0d9a5486b5c54c855155dc9c7d0784c14381b8caabb4f72aa599f48e03dcfe6efca59ca48a80f6654a45915660799386bfc2a147c3b6a57f9b418b76b121b48f452cd3ef50f59856a9fb8d1216904b49760f6c3dc70136836e5d1751089ffb22235892befa97666a224866164dd8e286e1bc85f1dfeeee0a0d489d2b142bef7b108501c33147daec6f6e49d6f965cca288af2acd36ebd06b1e800f528abac1ca68bc7160e8716c5c9000ccc4c1f2d23aaebe0db643c410a148927e809a069e05b6e34e43bac85ef51484a117db03df1390abf0d265b58eac828e387025d4702c85b36f5e3e877c92bce3ee2254add6de36660b24de4c0caf1243068c7efee9808add4981343b8d5f18072b6d540bba39ddb5ebbf4bbac870789ccbd998ae65417646e17411f73a17d5c37f0583a0945dcc649634b35338d854aaf78a66add21695011aeebf28fe60434e507ca5e8c164087368d2233cc4b7ddb2fc74f0f6b8506618ba8c20a019157db577683f50ed7f8b4ec9189ffd9e1fba20a4c778a5e6d818b5b7d1d8249978fe05ec4da6885399905525e7916db937e409306bd9522c3109a815d094943ca9dacc4fd8d5e3f79ef6455bc4f333cb4d3bc59ec1aa305abd8276f5ae763e85a95cdaf1873652666ef2d0af426bbe3823f8bd2b7524b4989f904d8f701160f690439bcba53946713f110633ae7221192a6b05564b8fef3678478e659ba26d2f1a527351fa78e29b8bfb821c92027453161c24fd127f5e1ddd1a4467574a72b4c0e511aa9402a398c2d05ee6fc145fa94a20b0a08df7ceb56afcd58af6547fefc1d4591d87e67505e261bcb30be4bd56a0d6b531e6a242e4c37299fa186913781ccdcbf8297e1b55a7556d6c14310f3565011c6969f7c4265dafab935d3abeeaf25359edf095212cd605c32beb09b002ec9be6eb65de65dc904b401cd49ce875a36e75cfcae57c58061c8a78d9d251bb52687dacfa246df8f56bf4473e461cab34370b16a67158ee758320d6c901f207e58e8222dcd9060300a53efb1abb12bb5fdd838b1afb17dc38af442bae4d3b3a31246233acf2713451f58c404768477f964beb8ec6ceeefeb0605329c7fe2e84fafda86fe3e099322b635c34186de156bb9f7a14a5fb7e617b5a0fe6d37477711d085ae0aa6c2f4be6a8786e7879efe4ac034d96e634b24b00b5e75f8d4059fdd4f3cb7c543b9a5db2203112e5e55ae257bfaec863563851e4c7c243fa2344dd010f382c654618eb7f00ae456413211c9ee238cd47f648695ba78ca9675af0c7b1952ca7b0a6733e3185ae42082e5da13bfd186bd99a3d5d54225cae74009688398312b22a4b283d1ec0705c3005ef359eeb908823bea84fe9d96c2b41dc956236352f210b89036936f08235a4d1078669295c1a035ea5d913af75c0eb8684c4ffe1aff136d58626f1a425487c372e8fafc1f3abdb6bbd0c2776a808274b99d72f03f8e9afb6d4f396a37b5ae611d478b1ac97f29419240c26171ca181f4858e37aa1f50e2d72bc8589e55f00e918c83882659421cb598d899c7d03aabb3479ca38f02ac56b9ca88fe7b406a24e12ea85d9f9db7b5687d388fe7f01dc63d0ee6beab57f2c948f830f66614d868e2fdbd5e70c34f36148d0355f3b5f955fee627284ff1f652088ff5035539ebd19c6fccce7b7bd25c988e3e081cf9a6c182cb54b2b03b17cd14f87846cb6423796679b3228a7a828255f83844c43f1e8922a78c0919513be9ffd6f41eb2321ea27a5a7f1ec7787ecdb5196b503f0fbfd14ae215cdc0ca053178ffb855e7f9105416e693eb8922b3931c7fdb00549fbfd3cc840cdc010db4b1c2703cf03208aa785306fb8a1c3f26410aee629532af753f902e94830e9a57eef2b3675f49796cbc3c123fc9818ab6c7cfc71496729d292466098514d5753389c7190c9940689677e373d26bc5b5bea70b13681cafa2d014f4a7dbe624da7365fd17321f0b5588130d5f0998b42d457b5e80fd5e91a7a5d4d4cbb414b4bbbe86b34a1bb41dab3209935b4d634c7180b7b96ce9a231cf1e5a027e701f7b6ddd0644e6a61b97eabdc0bd98943e0f424641a13efaf0a4f20e2602f14cd2c3a1bce338928af40e7e0f22012dba69282f9ac7981db4503e68302cfd8f24e09788b2f746f626dd0413839912722d4c51e9e4bf8017c42957c0fae75774b1b8db23eb0a68b397d91714af3befe7ca7ef160dab73dcf57abe35031f02a9caf4b6081b4f4751dace65e94ce3c2f1de5ddcea725fb1515062b3875aa1634f42b3c8da8b3a90d8b07ed05005b1e7373cef66524e66f57213caea95419a966ee926cffa0eb2ef2a97a54156c49f870cc9123264e609fbc83b6c5737fc40decab1c371f826bae565d1f559a7149aa81eedbd397d4fbb8be0680f9d8d3b1192b2132e5de9e67dfb5bd20f575f6ebea564ed97e6c7ca3ed114f6fabb4e2bc9a8668b564857f7f273956cabc9990c6c59736c450449f20ec50ed4f346a57477173b207f68e93c10496e3457d7a3cf3847b288592f146b25b14c8217605df9c21e01261c43515670ab30585128edbf67b465f74d60f3f29a585d3810be2e15fb17b50f9198a020b6356170c1bf22986bde5008d2fcd846ae2f52a0e5ab2519d409462899df0301700fda248754052c6b731b7d3a91e00d964b46352c6a07143afb6a5c0fc91b0054e654f90dd775139f20b91d777d51a5e6ab895b5edfe5ada1f7fb1506b52d3ce88fa3e9bcce124491f737655d7fea9a6098063775d07e006851bfa8a3f617f3f8da8719f0ef2ab71191a2a6250b0838402d2d01c183e7cdae9be502ff9a742eaa243769cca08bd35187b4758f0642f05eb15b57e1f37245f558e54f72d5f0a31838bfe28adff3ce87b12aaf179d2fa66a1eab2532777ff54e8d2d82b4dc7501deec4a37a744cf4d348cbb1173e72897e5a4a949353026760f2a18c42b809ae1302bd325a9223954f94d06370919d9e71714c7b1e1b43bc34d2f07560b462741c555327ee4ac936d09a76dbca064f7513c29e37a4ea4d8c8979e887aac9f3da7cd617f673ecb275218f8d7756180c825138b38d26b6bda3ff688b16d7f04708cc94616dd2cfbd6676d6b617166bbd1ccc1a8bd74482aefd5fc06e8999377a82d1ba518b88316d8345f0d2defd90a7b722c4872a618fe95bdf2aeab07e4e9568d06d2574bfaf09eb779e20367577d11c7ee473300d6e71e59a40be911d2af1df9e94c03c03cf1839c8fcd4d971cdc1c9e18dde5d8fd7d868521f65e3c9f6d1e3660db7c4af575038f1e1b4b3866193578cd771a11c58c39c4982e84dfac50ee842b09dcd1b671108dd9a5b251a109352676ba2b5c588d803d7dd0b630c3c6c33f1c84068bcd078638323a687570ac4ee273457f5d78c942f6aaac618f34ba0c6e42a939463dd6e7a4d1ec7425f96033af6271546b535c0c7cbfed73e5d89e95060f3ff8289e848077a271a850503c3d7c92ee89586fdf9bdaa408be2ac5bab9025865269b792410dd2de3955b89c64acacdc8fd1c48349169c960bf481b6641a14c9c86a9fa9c05423154419205577f74476da3af99c0630a7ba459762d0bba19f70163ae1eb412a9e7437d18acb06d040ee77b3f25ba1f497bcc278fcf5c8f23c767e60a89eb228c0b4052140db899a1888e9d84a01cd00510a97fa1dd42a482ccecffa74b08df801c6d5e726549ef56558a9035d6a11ca8e3d6a6ce96b5bd758246c264f208ca4aa2f147ae3b8c4c373a6c9517f9b21948a72bf0cf3b958edc9c58de7ceb3f07ab64e2ef3e38f546550bacade1bd917276aa74bdf9a15939e31877a87c2f9569dc062f54ca148eed1ae22a13aa8dccdf975a60fd09f153f93f295f46530b9ae28fc3f1c54e1ce4102600b9822810971d344347ac02ca733fb37a370bc135205c112611aca0bf92f32a32ba35b7707f4fe49244903951bb9fc39ab2320ee4183b3b66977e08e1cb0c09e1a45744aea6bfb81ac49f00d34587ef105298d666ed6d7c32e39fe442389dd50cba5fbf5e8e812b22f971ce3270575378bd93b1c66e13ead190771a81773b8cbc7118e9bf2b3759a63835eac5317d90ad8ac2a5d8e136ad7ec7c95c0ddd9c90d2a2f210dd4bfebd4c6b4ae6d4973a734520460903abec6edcea8b5f16b333491f048a592f46dd047048cb502f49dfca535927d41a3fe1a4940f2b103cbe2cd3b2fd5ffaf3483e4a7e139b9265bae73b3640023eb062d2bedd08a48f64d941429ee419d5a8d369fb05a146b3e673b19a0698d9119a8c5daa8b24585bb18a2b57e1265aa313117dd00dcb2dc1072b7817fac5d33b12a5770ee3f5f31430bb1c225a3e083706ce0c52d0aa9bf27918743b5cde7eda5bd4ea9c22b0b977d578fc085a80d6ed4d3b1dd3f938b256f31ec53dcc4f13731b9c80b0a752d70e1b1eca9fb7570243091df27110adc57aa7453949a4c46679ecfb0caf70dc959221cb943ebb44a734b21ff7545187e0ddec809793bed918b93c3ccdcd162f0bd1111172ef244e0df2f509c59d33e78c81a596e57e230bbbe8cb6052e424ec96a7a00203fc32ae39d703c0178d51562658fead9bb98021ca0b0332ad8c629e5b4b61ae85584daa461b0591f5b9440e43223c3f734afdb2eac8f0f503205e71cbfd28a0478b0c35f82d1d2332d4e118094203b56c1cc10d5f70a676a775c81b60a5b458aa71dd59c71c65aec1f7e5680450948a4356a2ebdf24637c69a1fca1b41876e3febf9b6a5d57ec491e4209ac767778ac938a36d77acbf5223503c277948695d24e542fe5d04c5f130306bf315535545b863663d6d106602521996345dfd112b79e5f4a354b0619441b1fb371129228365efcbf015aa0a46ada91ddef860e355184fb4721267ee41670b703b3087deea7e4c36e3aa49e8e580fc4cd6b8789480b7b1ce0ffadd6137ce0bc6bdd63ece0c32e690fc5f039bb0c0419a2ca286ae4a402efaef4716b1da05ef5b8d7a75a0e7c1427ca42aa051636fc20ddcb684ee50fa30eb6982c500e134b4b502911cb5410a5e7893a7e151003bc3a0ea47aa7e5317d96297573f9c59da7a00a9ccda0c7da8cc113a288bb03a99d57ce2c9d2548b1376e9ef5b09459004a682190a561f8163c627216e8cb0268278db88f0c8d8cdd9b73784b63002f32644c1616ee25fdd7cf6192d35b777f70638dae0d3ca363364b384e06c41325f0ed1487df9332242c86bb8d5bca85f46d9d1b1637e90e7bdd0154fd77b0159eaa091d1260696804e30221cddc87b951fe99f3a0780e364c5af40174541be73ffa95960771dd11cd458d0bfadcaab5c90d1b11cf515dfae79f262472d1d057c0420e345afa5a80d5cbce9db15809f42f6101aacbde71180936c9fa37715d7040a322f6c97358b00a64826c5b6fb4f6847cae4f8e47ab73d2b32e644ae1a1cbe25452bfb02510c0b52c7ffa96fd25887bebeb43f2bb006e4cba5c6fea42d79b521e922b7ab02378b44a005ff557fb400800b399326ac50da453a15eceefed7c3db018d18f238f5e277ac5c8c722adeae1394f5d79b49437eebc732bb67fe885b281e8f5c1e17b3de66a7a77a0d1a722af9b3ad3f986619f98f478306bc1943f5a02215d50c614817cf008329b0118f3ce5d2033a96e2a76e6e0e25ec1a91149576bc7e14fd5f4f5a25d25578fe201f1f91eaef7f30b0326515f73b3646d10105409e0464a23e84b9f1340a9feaebd6d25ebbecc679b21955715fb08c97719afce9004a2998b3aa55acd6dcddea7ec7a045efbd615707bd1dcd13adced2725b6af0b7a890114fe15841bcd63e181a587e8384a411fc62b5654f4fc4153b4cbb855659980fa5eeefc62ecfa2dbd5066a0d69574a48e7722996d8c824ca9c66157123b8e92dc43666b925421697e60f58b6a7e667186846c6be665e536c17da0d78f412a1b035afd23dbad5ae7a6be1b14f814d60583fdcf5d95dece86d4a6a7b2a2ed2b12b4553db806092c00759e2bb034bae0cd5239b18df3decd58eaa9864d901ae4a36473e36bbc1e5f8e735cbb7414a9dda17df7e950eb6d2d48bfbfb500ddd3bc70bb172151f0ebf370945a40b3525c1208efcebe2482cfee68989836f97194dcdee289fdb500cc4333076d7486002807e28e9e69b58db681fffee9f630b294bcdd9b1dee950177d1c5cf61adbc046b931569cbbdc849fa22b3d38f4e0ebf24f3fc0b096004167d5c734e20edabb55caf1957e2a5c5722fd5005d6e755ed0ac1506248e26c8b39e07cd93b29377e7eb2dd97990b56979c15fe0982cf898e12502f6701cfdae011d48d11d215c9d3eec13f215c15de872cb38e2e7bae37080a21fb53650344285091ef952f43c3d9a11fef440c8af009fcbcfceddcd034c17877454941f459aeed81cc01fea3a27456b7c1500075354761069642cbe7e499c437cdebbf161ade5cc2767afadfc418274c467d64180d546a9692d03b8b0a9f44ac0bf3a73cceae48b19fa9d005d73f50227c8ad4ac72795459aa9f38918bbf9bc74390e2958cb4ebe568dcb5e5b80f04ef702fbf449845be2fe05a4270811706e386bdcd6b6a60b68e2bfe8678978d514fb44ca7e79c02b82d15dae807b24806a496e0ad5f5a823888114318623e280494f3ef99244151ad41a9f34749d40ca7093957e831b2487c45506c2d9298125439d8c7aeed5dc0e43f9052516f52c0c7ad8275d250ba4cc10e5acbf22441d833cfbf31e6262ab37c3b895b40781537ebbccee7b62b3322b0a0167634362256f105d97f0fca92f0a9f9aeda974d44ab775e26fa4d7120942e3ef010461e155a4b86995542582517a7ba43155b9f80b8fd9da1b53e8f8a8ec4f887989946c934904f782699f81f8a40ca5f647b776e4fa353c7c09e1459f17390fa924fc33ab08a7a6f6eccfe477b3c726e4bfd5aca3a4826ae5ec9cd84c271f3ea55b1eaeded48af0861a302d3d5bc320579b310eda58b754d6cf4fc3e273c2052143110abb9777e5679a0acd95186f71d0139681b7c5ddc3daff7d135507816cac03f1e6d776978f5fdd0d1d5cb2594b2d21b4ab4ee22d1a39954147dac92fb7d42d805b5f91e8abf80f98e1bd7381131d1e01032894076ea337388ded9b31cc6ecec798c5bb9f326ba66943707e687b1c2bad8be984846006c7a435ae1923b7172159f12654007b8133c56bd148e0a60de49d1295ca314b742aa646a449b9dfa8e5bd81c33d7c972567b7c4ddc0f2aca260c589f9e4de29661e1ceedd675b5248ff85592a48885f51252141f05b766d414d763884f8d72eae1f8346753d0dfcaeb1dcfd0d9b73df019aa8ddc9d28054ac35081c9ec98e34efeb4d5b58143665c3548f38b66e878921b86706a6426bc80b690cbd7b797796f938a6ce01f870407e4840ff3eee735898a67ac8e576e8f7adcdc59c1b9a09f5b9980e92b5413ab972896793bf37274a34b615bf44d700c1fcfe7ef082bc8f4feeeb8b61a355015f7d6bf2706b565f3361bb0e6db89cc14dfcf8fdc02b272b6cbadbc9fa2b266f850e4c1ced2f26374dbb3e497cb5c86fb1c66014f3f92b159a506d74b25698eea2be10f80145f6ca9f40e121e7b2c0435ba059194c0130a4e672bfd949cb33bc55ddf7de90d2946f74840802d91590b67dde85b2e9efd201248c6a4d316a8db5bf5ab48f4588221fa7a6830ad740dcc08525e35abfadaa6639d13212d30196746352b3cb2809900b2417c323be5d02fd49fc84559786e2c4e27206fa245ddd1b235f63ea3f212f112cac9f6a5488a3746a40d6cc0922237b3b8228b1b67d7b2e68d6c0f9e34f63671759d9c7e145b48c42e42da9912352b29f4e29d8d3fb816ceee91e56e8e20a077d02303b30421a0b7b0bf423cf9bfb51f179b379db32f31511a27de94bf490bfca7d680635b82037c9db9b4d07aaa84600de3462104c2e4293454fbba0d409889fb5630e6c3fd4012cd67655f8f5c697096b5cf8cd51c6ae6f9465308745905d6315eae57e686bdee171afaa4e3790d02d7748f03e684dc130f22fca301440d3b27d9b2c94a3e24d70b41a61a906bedb6e65abe3b75e2199bbd0524ab5e451aa3e599e38ae7fe8f696d9f53c059c8313462076e11203a06abd22bc8126a5b02b3b237eaac5cbb2535713547a9e2369b1cef01b65372eeaee4d547162588585fb6a94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
