<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d54c1a6c229004766329b4ca7285c0a7edfb85e95bd641d73ff453be102a6485f5edf419ef965f66cadb25b4d086210218412551c5ee6d2687f3b2386c9f608365dcb6c623290af8bd0e7c01ab20bc4991645c9f9df59a30e5cae1a5cc669dac2672cc9da4215f9286d6cbc1fb0d84f2d20a9c5214c6259a85c3590aeafb85c15c8dabb0f945be82f74d6c7b416608bab811c190fc66d17b08844f6b8abb92b7c41551d22c1617f932010ee9121244aa282e63c69938be82101c50bdfb97ff6e8a81701a25e41d5358c4ef7c5918ff951d0d4f07b25c51cb9209f14a8f0b73f62f95b5f91a960ea056827985059dd1375ac0190fa6a132699af3cfd53264411be9a59176581820da92f60f9e5daec827cc16bb108fe3d012b80aea9e89a083b9848657e1ba4c9df34c472a4bb403e9de2b01f0618841c619ec4c10c9f64527ee201627d8ae5b2f4086254ae2bbf4db743d83f0b80fa583171d21c4cdee01c1cda83bc7f71fac2f9abd2ebaeda3b66c2503dd18a62c209b7b3630f4a3f5f3775e50be76ae977efd4afabccb9d40f7a6ab8d9b7707d46450616f5cd7ab79c5e784a097d89828e0e7900e3380513407488b2662c61601ddc35ff1bdc6cfd1810e377543eff2032e2ba13eb21f8efc57f23d85b08513bad78ff6dfd953d205102619a3bae17dde5bdae1436c34d9440dcbe009d59c7d16920893ec875e1dcffc039ebfbbae4c4095753f045db9d7aecd70e781c91029fe2f7042582fc911a5303a1ee2d907df1792ebc45355f63936b539335caf1ea5a1d8e19cbc56cf3b22bba6408064a197d5b070f1820e0ec4b9ea9bca7b1ad178a0ad385eedaf2d1114323d4b0ace3386f284cda54ee76b2fbbbd9be4d9c9d51cf2c96911868fb6c640358e1e7825cfc7ed2dc83ae5d200902d4cac0ac1d48792c041eb2e99b285352c769f416155cea306936ba4999f7b47c14bd2e3a3b472dd9bbfc4477ab4d07d70b1933b6c6ed12545dc636e4b1baa7f2ddc44588714a1ff4dc46bae51dce0c7f0b0e2b0747ba8ae318ce6778ef0dca20070790faf9b02357724c655b0607400882385494e61407c84e376c9699110f23041f480635b7bc8576c64a2f22b07826e896148995c8ca36ea3672ea36d747703e1db712a6c943f4701bb802a252c5db4d271826422354c292920b69da6eb43e7df8f1204854e3206d7a5315949ea27c2a18087271f0b21b1f7f5c7fc492f521172d1bfd578023499b0eb4a48a6dc53110ad61c27b9b344c0b07ef5f72a4120d4587ac77f98d3b16267049687458c6e051e4830b8decad73a3dab16ef5179cb1cf4d107587669e6c4e08095869f05562bd8db0d45d4b09ace37868211ffd9920529cd74688ed564684c3067a8c10e1a25292bfab4d54895b0cdbccd1a89a340f6c194bf42da6be494a12fc3e2268a83686ad5ab8a6f7fcbf886bc439e0205efce79c4ab68910f70ed00ba0c903d77c417c297762eccc11a7adc4f0048cf198f0770781bda30f3ba1e3ac3ecd064ed3bd3febaecc01dde2f1da54fbcde41c5de3b871331a8368e328d9954f6393b8db0c33014b05ce41d52e483e21d460fad4e50851be85e8275cb389001599e28812100c3263f553a82a12de8e7a0f41dc96c5bd76bb20aeb3f271405e900bf682870c9c267385b9df6fbdaaba97aaa6a6f946682faff01616e059ab765065d262b383279c5b4cb31072a6f4bed08e70a93f2cf6a543b5fc9859ee60ff03ce05443a244114e749f30d5a90d0434284d09508efa0c9e8f7c68b6e3a3b6ab429512e1c6496b1ba840865cf73b0fc40d2cd3f63c3c546ee697319bdb6ee77edda8a46aa0c52c683e0a5e19567737cfaada9fa9629ceaea20215d8023685c04ffe4487b7cd478c841c5563cbb7398b35abae9d47e2a36ca50723314b07fc8f9ee05879c273c50b2581c20a4312f87bd201e02ba0a62b004600a6e30a6a3449afc455a92338d8bc7d9d8234c80cf814e78676fadea37684a571342f92994dbefb90c39c3d047ec6a0e2e7476cbce65d717687fefaa9f75cbc884cc9db37fd9b9bad737143c3af4081b65c1c832a9d103006ffa33c9849f05c75dd5e1f7ea65cfd90fb9126102af90ec032d14effac901a678259c873876f7c086a013cdd345c8c594c9785da81648885565d4b077facfa577b36490207cd788006b6f93903adb1312503bc47a151849a9cb17c342378b5d4650d8edcb45ff135c184c08fd6e313e83ccbfff6830fad5b726ae9aca089957dd6ea8f42f19ead22e9e11eb0f76f538feada0b347d277c9c9f925094177dbd29605584d75559e4d83074a5f26a6ba282489f0c0140cd879d4eaa49e9ea8c12c6b5617cf49cba4233177d065f3cef4aada704cb4dc61876a950e54e633351c5bd20786207aec35ed655b3010874234cd84dc7f46159d6056b480b1ff15ba5ac107f14f90156586bcbfdd52ad0341f8f2c133cd2a983c79d747e935e101498f78ce06807a32a87e9789111fac751186968dc685bacd8c9c50d12b34448530f2b78869315f602849d527ff96e1b3311be940a8a6560e922b1cf39d87c2905e18b8007ee4e9395c23fa69c7d300f71742732b081cb903cbb50c8c53357ef80a5d838615822c27a51293bbe81e1fd8796df5517dac10d9f2c3ce2f1a3a271603715cd4b468e55f22316f8de215c1bac7d994a39373e5a5ab01efa508bf8ba87eb0b52f28d4fe1f34fa32ff14b7a292cb17f264417a24479cbd4e525a9ddafe7731b30fb3b24511d1f184f00b9b838033b563ce2dd2fdb27d1fda04244c2ba280c5dda2dbe8e98ba8054d907c48b0b02efc09f9b225b942367678cefebc8dc7e6dd6789df71172ca0e5af9f7a4e523b36be48022f7051e976c529bf99583852f303135298b7b1d0ab131784040d844652103e62ad9a3f5f2f54581fbcf1e84c7ea4505b0a6ad437ffd76d08ff8856cfd0f23101a80f999f67e41f0356a185681998c13fe7bc057e07bec6be2d0ce619eb7326e73f180534bf3e15327b49329d94de3acf8e2f17177a9165c209dec4f6dbfd1cf44cc8e4d671d1521e65cbf89eea784ca6e0bf739a7e6ecadb7bdcb28252146eb35b625a5a7096329250d2eafb15dfcb8c5842a6f100d283b459d62855f8a5d9fa1a9b3ad25707ced2d791d89bd2665197bbe54011fd6e52c8394c0802a585eabd9b3e6d3cae2ac626fa09170732451dcdb042a9a68e7112b20384ed3d1c39e5d69768ef650e4f5b8f7212f25d2f6c9b75c4166e42e52755837457d27406be8e0b4570d1d83181093dbe269ed498f24b1ac8491f6d9c8d974a9baa9bea92ba1a41048b5be36e137d690b9d0b8f36d1360072e2a107aa29f57a1c082b6e1f98cced7402e5c8181a04233e6af4eec3519c812f5b273a89eba7457769b42dc013b5412ea595a027bcb8e2aaf6f7f7461dcedb0b7cc8ab482135d03170680d70f6620509a56c8c00651a415e53a2d55f3a75aabaeb1aee91022995702d0678a3d3ac582b9905e9fdb9be30f4ac1113aa5041364e2f9aa5d0009e8ac55d98837dd8cff0198fe34f0dcbf3a6d64fff4a03713be606486a697367e54bae502a42730ef1ae83d6aa5856725944abeb35a3a172640a24785ed945df8d111188d9f1c58e7292a49210444dfa1868a9eaa07d0551397016cb76d85df15a4e33c2697929454df7ca39fdffe67ecd719e8423d2f364968e673f64b88c110ac8c4520eee4fe986bc8c8950e4163708326756b9ffb1fbff84a2bb0cd5f84057389a89943ae572db164cf6a5a92ff71088c2bef184b6e302d1c21862873dc5581d305078caea06b14e3a80f71239a0f17f79028111db9e02d2d5d4d403ec654565bd8b77f2dcb95b6e39ff052a5307d224929f200fd76f208ad69de28aef845479fe8111c2d7194c187adf0890ce14a8e0459b160f83a5e6ac7f3c11fb02c02a14a6fe5544007faa318e5487b6efa8b4b610eedcef07568b27cbbae901980defeb8174eff022d20194f6cecb515346444b2db94a0807af8af6ad273f986c550ea99cc3c48038fba9b424d2602ef1857bceb21da11b6df5c7449fa771edcc27351c17e0102d108825dda7970e65bca0afe2611ea1b180f31cebca23c043a70927f5cc27d2851ea82986e77540fb4e7e8ca85a60c610cfaa57066e0cffe3e432d6b25765173feb62e43b348d1587133b8025882a4a65d74b7881d934139ae91c3d09fa2529cf790acfebe22d54afb6edbe64c0c03a5f34ce703b536225748488d0441454823ca9ccb35af9f5f60727c0e4c2d48bad8935c7e4f96723c3aeb26ab6337ebcdd54d426ae9a365260f4f8a01b28cc4cb7f014b8887cb71b1583aecb3169a708a1ced8c79477f2ddbcd3d1dfd6e439b03f08addb467495ac31d7cd952f32dded96313a5ea390b31dc8678b6bbc0a7e78d464f984c11f7f850749bb4cad76df10ce1ef73060ac716e7fc3003acf354a8e573fcab17fd95b7245d78e18dc3be27992d6a20731f9edb73972b2d35e8826b87b2c0ca37c30df61939d295caf5e2c212dd3f0a5a4caa529ea2d812961ad5bd787e5296e73c0dd5564b6a9061f527fca9636748d07226e4af875256daabdc1dee6e2e9451d51e475ede6b9eef6a9c95f3d63cc927a01645ee3cfc5567de4b75dc9ab367a70a27344c3d5744da10ce7c0dfa616acbf4f0255df1174ebc744454c35702974d0f1c6ff35f3be2156fa5ad3c865e4e2f245a2147af44762f24fb592bbf92c34236d21844523cb9e14cb93dde459855b3707b0d96c58eab56fb5140728685a159932d9311d2d31ffa674e59e46ad5c54c54ffc9b445501e232f36db18380fb864433f0d5dc58f3b8ef94fc54979e24759f2aa82c6a0d0ad08c07af35a0442a3114cd0e76388d71c40798c9906b3558ee21a2ed882bd5a19267840d82e7a984b15ed4988095a5941ff9ef867b90c836ba49b7356b68a8bc10882122d2e19dc0f864f77877ae3b5c5c911b670d94e4ae4ec17ba0ba60d1d2b06860dd1d41f18f8df4cba34737db6f948576f7842c7d1565abeeff7d2705a254defe56d4fec5593aef53d77a4f8d342406f479c83a4744a9c3fef8dc2698a579ce98201299c7e97dccf64f1b3a9890ecfb68e36888af1e03fa3d112a706b5ab0deca20f1ac7bf7945422b042ceb4e846f37b63fd84e513c655edb238518efc46b58facdf06704d21960d43cee69acb48a45c00a6ad10780580e031b53bea0f9ca34d66803f6ac9487682e491fe572c96a03c642bac19757a50c8569f260a220150eefa8c92fa5048da957be4ad417f8d6218503e17ea859a755bc1cf645cc16c3118e11e1c37f101e4f16c069659c25c5cc8d17363168b3d2c9c69156a2ff4436ee556922dceb1ff9b8fab958ca6e9b5e82d6f86ab3b2ae4d1c36fe3efd1de804345d8c75eb2483f0e97d61e286c2fb012294fb3eca5c42d65927faa7d157676da8739f09c46cde1ea944391a0b429a621063ff615ee85f64a41424ba7941cf0b3c6151e040cf706b410fba292ae94cd200897955654befb539148db75a58d164bfef6bb2e27f3ad63ad9979028329ed8d2dbcf9e902e2074103415b1ca1393eecdcf70007b1a9b5c3cc7ff1d97a74e8fccdebe5c048a84e7ad16297f6db3bd6c091d9717c3b843ee101b13062f8d1398b2178b3643392d025438c5dd22984deb8273b9a7a1e95365f5c9b894d13cdc8ec2fdf51c405fded887a8cb917ed61e59aeecaefa6410a6a4f065766336dccadd5142cd9cbb91ba1f911476eb626ae29abd41b12458d8aaf1758b35caa0aaba9dea66cf395fcba3792be952969c6aad48c0b8088ed144329c232e380d00ae1f35afbc6fd64dd36ef252275a52fef75df15e7b936a8e7e90a091cb2a01e857ff0ec5cebeacb41670f208d7c3a8de97c8fffb0ce97032100644c768b9bedde94800f20073cfed4ce0a790107992bc65f8908236cc5dfa7d1c90eb96c7b0f2377c385a5b88a830fab934305684aef19a2af69d61c03a3653e61f2e2396154ce475917d5603ec5cae2d6fd4ce08c5e505a390e16c0551b87e1ae95fb94b1db83fb7089dbd7f36e3a5680fde5b254f3662ac0f43571f0c384d8f229bfb4932a1a90e4a851b89efc0c3bdf5237b77ec738c1a10ff4bfef51ed179eb668c51e7c2c60994ab81ca643cccc53e4daa71ab0c2110db0949cfb607f5fbec3b48e644bf9a53fdd2b0c6b6c15d2e6012408f33c8147dcaa05cf76539df5d228c1df01983335de377195d61647b236c902b6a04188686045f38758fd017ff0ce47e03786ff087a215a92db80fd0cd6e1b6f8bccd1d161d5f7107b7ddd6df3377cd914f33b51de26c7d865b1c6e00eb4f98355503d39646bad49088410807a988661ba1c793c968df254440030fe28b43d0f05c6f9e1debcec866ead6540463aee58bd3007f7c591798b82989629e8be0a0ea25caa5e0d23d59d739f31199c802ebbecec9d522ee86a0592e3ef0e68e132de94ae42b43f3ff9260e986d1ef9fa194c73fe4d0a4727b3f352d05e13fa1228de375deb41e18f62794617256df22f80da914f88760ac9c82fe76692a6839e28d311646d5daf199a0349ebd6aece06a801ec4df39b5c09a3f239d78ff854a179ddf6dbb2b26ca4933ccaa1319666ad2cd1a48b7b81608eb839d288b044c4554be8ff8db2aa45e19544fcc435b62512a0a63558268ddc792c5dd0104e4ef72f99949f134f18c130cec1c70dc2e373d4ed97f2d33a327186a1ef1b63bd0468a0c3698b63f601293d50e2dd0569bb145be4b702749c58658b7f6b7904553042b1acda59222a7ebd3c75221768035ad001bbab8eb7b6dd7e65b5276ac1e3b7f353c5374c90503e45cc5057e5fa5d1662e126fae66089da0cfba114fc40fb30a906f1abc04f206c740a2e566d540493cbd6db460bb5637f5e3cfd91753afe308e84e646b8a2097cd44f6d01cd9c452e5d4765c0c3a29344814d15c09de478dea9b1c2f1348f869594927382db650a19cc5c4acfbab66617ff11b0a8c4b07d0a4518e0563e6feb4aac3e622ef1333851003f007d9a898f2506798e89d4770ed0eb7c0cafc0e67c9035578b3a13bec9f12089027998b7c86b4c3436770384be5feaf7b881191e8c18cac9ac0a1c6876f40ab99723a655d9e4e5cfcedc2f14479fb3465450e0fae2cd14c7daa6a3b22c3cc263c29d185414a45cd007effc71d4c32783ff42eb5186a5d1a8b65e40ed226a8843ba2027e53f8bf6cf002245c66094f9313371a81bb9f96bb05d0ef57dc6fb979b28d5bf317b28c7d46293a86eb65396155e55c4fab53ab0c8501b3af527fe48fc1c62adfc3d7915c631e1e8560fc8406842a339125a824095bb3dc596e6a90606b416766b3a8492b699cf4e7c8b48ced25c2de5b8ff0eac67a5f2ce6137bb20df922e37226674fda39ea1c637117c79fa60eaf5df2eb542c1f0d34537afacd5058221956b3b8cd43367c3e1568eb68025a82baa39fc2f5bbff99e28c292a7087a985b0c79c27f08f344fdab3990909d44500bce2bfb4e3f87f8ffee2f6919ec6731ec4a0b4b9f92aac36281413ef9f91b9e4b7c4697b3b5cd271d7ffe530dc7ce5e75bf1c11ef612da6db2cfa3a1452ec45eced008b6187f90a651b5b0ee7c0ef3a4478249c3822a47e04b972f767675556d1363b746bb9dfb87ae7e8888e62e3d10f0ffba02f5bb4aaf728330a2a6c045682d73086f67b905f13babf4763b5f09c2b107ed213535b0b9e64b72f52725668e11d0e6b0063ecb6393ef09814c0bb9b3c343d01620bfe0de022188e962b92ef075bd45143b9ae1c4dbf6eec8f1a3a2a11c83e4d01d6a134ed43732abd23d3756449992f6fac01fc5b210c675e554c7e75709fb0c66210e996339f4c5a7ca5527f89066b5a5385e0b38cf8f3b6be03c5219b53329774027fd04ca4296b4ba81d3b35fb1377964ac0a9ca36c8803599935cdd177315c33ea82ba714ab3862c1641dd0b6ab70155b09c1899fc904c1ad7cce46d97ed4f49a93b009acae762b9f2d153713a340b4e0adf7c666cba08f077e48ea6f89f032e7bdff6c203c5e92f6bf6989fc591ec75b976c93ce2a1958831c2a2b561d9301e23105c66e1b6d61d72f185380c5caf200cefde5c2a6d5313e6189da240496609dee57a67573e5d72d792733aed08107ab2e6c41ad4beec850e25ce2bbf367b4d9a993c0f814970550556539e9c6d13f495638dbf883fa0dc3ddac612c177b9bacaf84b614ff9dc29c7c4e6a532a58310cd66211f8415f801eb9c66e5e920651e6bb66bf18cf6b6f62ace37a367c68bd7587685ff9e7c784b8337cb46203c793d10b410da32bab2aad38df43ccdd9c3c3be79992c2112ba40ebd9bb5138648f5780b15a80b699d05438526983e401fca461f6ba47ded85c8521d2bedf1944ef19315ae7473fafc5ca13ed2929d78e215015b6d7c350fe6f45fe116982fb6f06d6f4147a137f96cc3e541830dd900b0d000339c4b57825b1f809803e0ff3513b28d8c8fa8d68058a29eedab94022db8091ac96806decd7e02058fda4ecedf9f8e5a31ba640c7a31c79fee47eede833d3f6e858b05de323bd0cf6a59232f9ed5039a3fe86ae261b6f688b2507a8d134775a61671f2a6c8cafb60de8d21eebe6bd0ff0873acbf47b4617c1f942aa1b17a91b545198f99a3a42934dfe311777849b77db5410da12bf7e610c52aaddda876e33a10eab5c57b3dd38178b55e8d2d5acd1e939b133acf291a277b26f27ec1343958b941ec18a8788a28bdf7e173b4f69a00e6a6290b8b29be7ed63b094218138997e1e0b5a0db11d6cfd447619d025ac1b7ecc4fb5512386554890863096e4a4b075adfbf4f5f0a5153e4760155ea581a9b2feb00cddeb0b579666b4b9da83937da8b6fbb9aaa3f84abf3a3f64a94ae9376685954a04a3a12b2f2212ccf2e8465444faf0ed40b56256a237d65dabbc17375a1a0f384c37c5b0d8c518333b973b8e77facefd0dfd267062593b118e9ed0a83d09c62b626be3aa5e3c6632fcbd43e09783751096cd87d6e8e891690042fe72873974d3ac41d08bc329e823b19943f28000ee8b1f30d03031e6c94d9254608618e338c0702a693db62e972306fb9020e52324b525aa8d05c1c7482dbc3a3c444f04b170d4b4f44e05d1cadfe8a260eb68f05e38715a0a7147018b101eb017f30e6988566944c749a59a74ee275552e08b80789f865a10b871bb8009ad89f2ab6c53f7187df9b35fdf0243c6b7d29acc996222facd5bd6ce6744421e7f3273b8e185ff1a575f437733f055650269ac64077c42858fcdabeb97898100237dafc872543ee94dcd60d9361a1a92a1d5caa7662c357401da6f98dd4cbc55722680f1e85479ca48521a79032bb78d3b610c20970fc217bbc4d818232c498f866a7b3ede17954b5c465c2979b1714c1c5326479d8c1a58b18683af84ed297b8166edd95491c68c7b5265d8d6c0f4c77245fdb3b70191bdc2cf90b14e1d6faa735b2dfa253a16bbfbd471b34f2cc7f0d2575bdbef580fb1f1d092174b187186c4b7a6fa3bed9fed1c1f6ea60649ea0970afec3ef0e66c109cdc7618d56faa357dd682e229846c82bac2979b64a25e3c98fdd7e406cf86deb11e53a49c41be31d9c2396c23b5776bd65662924dc5e61617cb815e81af41207871e8f9ed788d4476592da64deee76a3ca9ac4ea862ded602578aa4a4f22e0121875e9b67137fc0e1fba6f06c8aa8d0472d6049d9f9d2bb237c81e25c0e5c68e2681e4539fd258d9c347c1fe482393d71636c26961c5d58e02dc377392efecaa7908f3adf5694dfe6d3138ca019c6e809c0b66bbf5b799057c98c96fe8c892e8879b37935abc6163299c4fce7663d1ee6c8db2888a7cc0142ae2d28da54ff4f09bb742129882d2b4b34782968b554d3808f9405a394f25bc1361dd8149b3b7727ff9e464a7f8c34da8aa43effb0ec0e3b9f7105f107d9c05bb5248bd8731cc1d0686d4da7b3e489d14794bce1fe7c801c71167893d6c9a3b936efd6ce423e410b0d3c91f596f79b4b7557686045c6adb6db965f08fcc73b540082fd50997b1bf5d40f345e7cede4da29e4ed948cbbbbc2d63ae7ad25b9607499bb2055335b43a6f1dadb4668803c2cd977fd1905dce8ca6d728da1739e766834b8fbc9dba13d94e9aff71994ed5ca10fe53d48415a5e90f8fc7bcc95b341fc5ed86b4cb8506e687510621d0bd91731151cd09dcc9ae2bbfbbad5782cf9588f9d3c57ae962910137b570f276166526bb17795a5184237b9bf9d856189177562f6515d44df03fcf0ff51030e017e1fc6c19bb920665a8b2f3a9ecd9d061664048035370e624b1ac3ce000f6f8dcefe476bac65e1ef886da224a7c6abbe78ec8d61be37777df4e45413daada463968d23220e07c5459a737b29ff0859f4f70347dd72c2b75193a6397ebbc762755249872fe082866cc321560d016b9b636558cbdcb7c60908644ab21e71f7286784fd26243a6bbc0bce50f106c744a0bc28e4342db15e9f2c791914073d3ef013a7c7239a35828227e7d8dbfc5660b4dab393615c095c58dac32d4c7fd6ac9b5a7b5b280abe26fb68fa426c160d10430e96f42d7a9820e2a027978ab9b4f821615f4d664e9f7b7e5bb601520fea825865f7370ef4e7621bb1a148c972c82bd4b0bd09ee1f9c4c22832da9a2325c60aa29e1532b09863d907c6e5be351722cc60d335ca5aaf6d375554f774ba0ef8335a1c670fb190962514229bc62003fabf43d7da3e2eeb86c966f620e0c0e0702e650b91d9a7f65cfe84895ee0cc181e30073f99360b843dd5e6d196107d61c55c37470a985571ac93178422114594956eb4fad75d887a0f0d278d9165fcd8c1456ad9b9f3e00bc103f893f03a3d5ab1c8bfd56de97034bb2c6c692b21559d24f675f31a89644e7e25f49f275ab15cdb2438894fdd4216c352da7ceb8959b96e7c4a12336988c34b11f2095a8bb4c82cae240a40c08e5c0bd0b47d3541f8b09f879737be9f8c89db395156ec7c10a6912df990933a4de3371997aae27d0bc6468691e4972cfddb6db417fbc4700d625f113e63124b6e9b263a32fa3579e27d78f7f2a6ca2979a421db198ad3fe610f9e0be0a5f14997987c7543165c9e857a6359b6463dffdc3c747bc4b29075358f141296afde056959b1ce9ef361ae172674cceeb25e5c1fb743e7a162dcf30ee60e672e846e59496571c19b1ecc795465390ee4fe6ad126e6b99a8e32cb14788d025db2342ff67416aff56525dde5a450bbe9d2a32e352c54fb15d6f0f34bfa71220241591c3d53b9af34d68c10491d752d7189278d4fdf4d05ec233cc6ddb9965543ade3b20745481ae9f7e8f58e6e00d6a6be0e43106cf4e824aa3ba45fa235a1f2f44e61bf048c21cdb3452398577e02dcf3eed5981f7d0d37a6a103ef029440da8df838bf8ce401ac4d773e9e02eb9bddace49233928fc31496bb61712043eb0f60308535bd7000e26ea9ba8c2cfb261815742fc604cb6753fba13e1e3a5fd0aa5e4e3dee689bde817a1ed454a226c9b29dd454898fe4fd08d4b2b2021f5fae59f0c5647655ab7457189e66fbd12dc000448fd0e9b39bf2ed7297f5bcb06e7676baf473b1bee5e4ca718e1dd8c4b7a098facd0c9188c74ecce880d808e96629738a34241ae0169eaac88c09e7dacb566d16402315a97ddd832d4d980417b40b9dbfdd93af8fbe92d4546d5456b8f9ae413d830f31a61580621e61924a1c04f1a6c836130905ce3dd6dce012fa54f5233c888cb96a8032b9944f77e48728ff6f28a59324441ed38f4c6cf54f463a0e9a2bb95634bdd26136fa35a4e9937c06695d6f4a57fece05cf6f47fe410609ae7bdb387df62d721ae03942dcecd7ae7a2db25e31e149283675b574bf0d8ff35204b490c51be2bd7c0f224c6796782037aeed2d6d3e691d5e95975f4bf1d385042d1b9c5c0bcf0c9a34fba5450894e07ffc1e9e7496aabc273a0da2c997303b4f5c6944bfeedc547f7e6aa6ae871da94ae1f5588d6c1c4255fe437a452aae71945b8fc444f98c597b6f2f709710a989028acc512024a5cd82d110cf7a6d35e7776b8d2323712ecf87ceeb1bd6b96eee83ee8bc3ea075885b28be9102ad78fb133739d0a9b0ae25f891545f8f7672d391e9ab84da23da00867d1fed0a0a0714bf5ae343e38971f6c90ee567b56c9bc7c437e0c2a8919a9d7291aa2ff5f27405298bc09e04d4dd22cb9c2cc27dc6289a35137bc501eaf9086fe07f6fc865455eeea05c8a85766309f91bd128583cfbf4258a6748f9033df299d7cd7652271c141eb7dd3a684fde78dfa5b14d5cd2feeb6de2ef09f6f2ec877265f014e507b97f0dda3b6c7e1f442a37722e227a5174532c65d6ee7e7d693bc681fea2b9a4a16f4282cc18d1f8f9266fdf21ee3e8de6d12712f9b3c10fcbfc6a95c770ad22a11e990c0017a09e3318bc8c1eca870cd19ba42cc84cf6ffd1754efee5426b4be1f8844a029235cb1dc48963e0cd7d15e564ddfd669883edff0a849c3dbb2bda0fc8dab1ad27bb4cb0d7184145f48942e8034cfc5f1dd4143372d3cc33056f8540c7e3abd7a2a95e81d9d99fc61eeb4311474641cb1ee394a0b752d84ae81d84bd03499966faa2dee14e97c4222ee9d59f29dd3b457d83a6b4bb7f9ef6415824367b47607089ed843b26a11deaa1cfddebfed279787ac806b9c2db2b373c559c54dcf1b4c9a5473c79e602e89cbb2b5031334d7b44ff3cc0d3574e258ae9411168a4b374751c54e4aa5beded340b67e7ca8ced66b6b699f9db906f94214125824d685a7e9d5cb154646646e6652f75fcae90f2740ef675c4d5d4a2b8b502cdec5a874a46327017acbdca9b54998e62bf3bbdde32f6a9ac1342876ed216d2dd03cdb9204ab80ecbf3c2735f317006d6d4dd74eb91a46fa98cfc8b7fcaff0fe314e8aba376b8852eeb3955d26d23ce6b625dd58e11772c03a416a7a55ee370a8121fc4d9825cc865ea9742dda401865668126c4856ee59450c48a2caaae243fbc1bfd89735bb97fbc128e0292dc0e0805576d3bc72a22e2f53cadab11b1dfcae1fa8a2fe2c7d12f19f8e366de82cf83d62587f22f3825d6754c76222e4d53c897b72dd5779a2671ed128ca88ee6738876cdbf1166866102719bec7d58357add4090cfb77458d19db46bbcd1c0c153c3fd4f1690400333c54a6bc33d9420f9550bf317df7543fd2cbb703c304f05c89c3217d9b21f243815dfece9fef0d4dcaa4ab9a4ebf5ad78734f8e522eb97b3c054c0047096c9815ab26a2be85f6608a91076882474da5146c2610b030e3e76595f49a97dfbed8caf1a96eba22938f7f95028d545894cef1b465f7c4a134ac514bab52898cb9c6c3069138f71755e3335ba583d0ada6004195cf3aa8267245a27cb5b503f4cef71a9bd772731aa8332da1bd307e34fdb846c814caac4d4d90419ec24e7514aaedd3ce98de0704c1ff0bc31c813af3c0d74d42dd6afa6366ad94776fc7418de7939c603d6be63171317f8d09895eb6ecaae435cd446b07ca9c2cb8f629b9f1723790eb5a91f379f5530b3ac04851424934a5bd35d99bf059e5ac3c6f32a69f4693c4c787fd53a5bd55abb30fdc22ae56e6b1b065ec8182db4c1d4e6754fe83eae1dd0466c1a132fe327551ef03d6b7977a03d3c8fd6d2888bef63b711b83af7505eb43e369148aff0341d76c9d1c69b57f257ffb93cb864565bfab9de65f8569b8e89bb79c8516a630e0a6358c599629b0b04470b5d7133baccfa0f52febd737f5870f7ab679a149f0a3db53c30044910d4cd36cc920c4f7826aee48d6abc881dfc810ba200e455d3ee086a7613b92e5b7f0a6ead76fe4f39884e09ff13e5ad4ff66cc1eb6b114c666bf9fea6d0f331c3b737ad65c49747c4e1b68d625c5a99357ad6d840da7733dcf5c79c9d1c11fee231f5dfeb37fbfe0618bb60dbf15f0e73e1d0460ca2a04ef549f105c4a6649b0fbcdc48d62b0086abd11d9c8a4b78f5b3414dafb7c60abbe2f45b52fd41bf31ad9ce6f9a340b161e39e809494ab176f706c03a17e0912055fd8aebb43a58b241cbe595854c4a4d70653942eb9843b5ed8ccd9e38275a23459ee0ad6d225024ccf1168c5b107ba4a1b9d52679a58a48a9ca47f05565a3e80a88adfef3b47a8d49ecc0498ed40380c0d3ddb04ec6e1e86b4175e3823618fefea63be8908c430debfdd88993bc9eaef41e5ba4197de721248a18254c161980a8ef4ec732e3919d51579f9ab4e48ae93a798466de0089ca765081334d50d89d42672a8e928b71951b5c0cc270568749abd58e78a20aa93beff520437b6af929e4c25f22ba5669cebf47b1293fe20556f3cd7b5537155d9ba2d73bf3541e5d85100b067617a44ebd579b0f2c50181329facea7315a4852a500c59f4126e097b735f010d31c1be0c58fb460853bbd9d1c4e86bdad64ba34ca236040b1f1dc43de6ae3dc8975eb46b8779be59fda6a20744e11baf49f47baa9aae54a9ff5b8395d497e637e1a9f200b8aa3d7b65c79845586a1b98cca448a5b5e823f2e71dc54445692e7ba24689d4382263c6ec63176a3989335e43da051f2ed1448765ba6a52ce4da5fe7014809f59c6a6c2c4906506a6c8810fcfd7f0645fde048c1981f7b74e57525d47831002cdba811261176053e39d84992279a03dfcaa76271efc44e308c7483ee35f2203e97aaf423d043131bddd6918764c3b36045fa87399c93d691c68085842549937f648c48e87d03d2d27648bc4b168485064c9fe0442bdad7b2da0fabdff8c3700edfdc1020ff21b5333fa94334b07ad25d36f99e3b498011ed6f39175ccf0fa861d194fdc844b44d74a765c53a330e9e144fba20c7eb8dc5dc3ea88252a6a272f8b1d6daee26fd8c4b79b82fd82c46371918faf96ef39b7d971217378aae61c46032d2f9eb8de91e61fe0f9cfda4a86d8905fb69d475ee41dde323c325f7dd808231f368bd4a710a88cba743a01e76eee30b4940c7c0da07c2dc5dd1e103a45f0152c9fd15dd07b5334599450703e400b679ea6c28cc9039c4cc8440dff7d1bb03e5cc1018ce9957648b47c62369754a70ffe8e70788101e7b42efe609dbfe28b82b07b5ec77f1d152ded6878dfc54377a624cc1f6df7f22155566691a96e33eaa502e30d083e7f8b4d79724eba66f8d821f5fb6e2b4579e3156f6ae5f1098ff821e004b9540a3276e03e2e24cc84ff68a29f632582f5577df06cedbcd888a9b0baf79e280eb737c0cc2cc7a8868dfe5f4c52124af968d9b74df24dd95208f8a9aa5d8c6e7bb4d076a9f7c9b5ee92b56906526ac1e07fa9170aa6fd0fb28e8c5af17f9d0f164e75dc729bcc033de91f80d66b7999665c267cddd192ca25165f4024d3ad7949d7b2ee6a4c7f028f75db69cdcbafde578cbdd8b709b0662e5e52907d7b7b720acec0e4281ca45e1d509a55c46f4448e99c320130a01a0c5e5f3a81b882ca8acc0de52b57e2661fb9310e78baf0c4db0c191928cc2cc7cb0f0b96094d1de938849b2d60f576cdaebd25fe3a9cdc7ef7ec4958b2986ed3cc61946a9d640dca8aa65528e2e1678e50ff4c373f9cf0b76662b272a730aa037ee97054f7029cf4fa4e477407137edf2d0cbe0386c5b6206a596c4297b64738295508a197fa7817d8c58ec0fe2fa331d018ffd2d2c73c834f5992e5ba70183fe5ef521773c3945698df57aa93d18aef944d97d2c6f9e5a0d470ec4c9126fab7e7075e62a61407fb2d4c1f3cc2ee31486275bf5838bfb7632cd7006f2b19155d2a664e2cd42ad934d45ff8476a4f7696e46681f787b86fa9bfc8461c61283aca045383388702d3630d101e084b8d45344c2e1fd69bcaf2b2a53fef8eee94c99b29230356b73cb08cc56861ec342f8d07de10566bdfa7bfc6f7a195d57a4b1803f05eedbe5b2b036d9134b186c3844f78dfc3cdcc7fa3f9babe723695e9cc3c58dfd79670eb59982a89c78539834fe50783d774ead9e4a6f357597f28b2180128394e8975a9e6de564a6481beb017cdb3a2fa8b3bb126909761cf162b04203c816824314b8b11c5f8cf1a56465a32fdf53c2b414dbe069dcd6dcf7be1500e49eee4d3c8be5e9c856e9ce7ad05f32547fa3864e24dce173cda9a99212dfb38312c397291ed7f657f6683795f607eb897ec99da2bf3ad7a271f88b4c8920e85d94f57cd301fa6fc8fecd61dd8093a39f75cc1ef43294e82e49b4aade6ff3d29c63a2b7baec575ef798ab6b0889753a12ff3f092107e64c3315e1d12c3ec67efd4b3f1bc0fa21a94c0e5704970e1694dd9cc8332aed24604896c99cfb9991a22342774544be9df5a710e3c1f88ef2c9b6e578dd09bef3160f503a71f6f32aff5a912fca646217bc6c99a193c5b5123cde188b897a85ae4fcb8613420dd4a135748058485e5b4406633d39f964d80bf6515b9e5c823fea96f9b7bc142cfa01fc2ed3863b5b2161bf1bfb453dcd6f28c1403a3f5ac3ffef31f3393e6e15284169b2c71b17f3c82aa4680e0b9e344f070fcacf262a10eb3f547b771807ed3c48e20312ea59aac388e52f930e8dddff1cb7173cef4d60ecea2e65df9caa47e1b589430f8d83413733d1fe08e89897b6db3232fbdd954a78c9e7815360ac9136e721160a89512e781bf1bca0024d6765cab93c7ddbf815c38b584ba050efa139510aa2e05319df15feabef7f4eb67e7324dd6b596cc51f22512eb7cd59ee80d41bd26c87d99437b3b4d176b3695ce9c45ff5ed2a08c9958c0a0d9bdb34fe2fa29af757adba8ad9b25d3037e259e38cd561ba60d739715b9696dee0cbba1c382b0d84a558f486420892af076a273315f909839c3ec31d7dfb171974d37279777a521032d768bc90a054452af722a10732b769d81ea32469945fbd36316c9de474ddc09178754d9e1573ffdb2efbbfe14e075e10f600f3f876908047d1c93cbed67da7e7a344ce415be4db859edcc627710b23d2df17778b7c710512c16da51f1e5c82855fbcf5a826ee2ced84bc0386fd01d8159eda409d02e49c46e2f2b96dc77afed725c6ea88971ce0dba3b0d3125c3e9b5e403af61529126b58849358f7804435a6fea907eecfe7db2efe72a3a5e6a20ae0030a027a98ac80fb81e6a83eac96d001f63f90ef585318405caac2a94d29a909deb50c6471955cad4a7484b2752e4e09f4ce101d61b5f2d717b70ad2fb682f959482a270d08018fb278329de61d70c3f2b6be9999e6b33f686537bc364305cc7c0e9a0e25536d4d8609f6a1a69660a781eec0729c07e63db8300f8bd53155aacf75fbe0c33cf0934a455c36d0d5be4324421e21936a55690afc03b6222735e562cf775dce72285d5cbe85aa47dc4f9e1cc90a46ba747a66c94e9f5a9beaf7f316bd334299716b585828a4bbaba71cfb96ad0a64e2754ae8eb20f9d9c889b9941c4ed0f765d3c6eaf006dee7374ed1fcb6210a7a6923877b6fc768209f12dfc0791f09a6cbb0a91ecc11cce5a86662c6f6fe1b974338855aed73d4725e4b561e45b38286c822316467f5940d505ad5b18693a877c5b393b5ad393efaa63ad323aa019c889d487042f08f4fa7a41d92ca65e3bcc71b9b60934bdd82529a6908cf3dc1ae357ea2ede0fdc28acb186de315d292930ae20f0857d0b526537877f7203fbc687eaffe6d246512e94be742c3bc2c270dc14b941eea70493a062762114a76cd55518dcc7fd96724615efb33189b5e2a15326ae918517a0c434ac7c2238fe2c8f6c43f9aadba2a69446fd9834dca96c9785b0583a85ce40e437b7194b8af4d8e5349ceae0cfb8dc424b7fef399ab9d7a04739b3ee55a83eb514c06ac641f6afc6abcbbfe33b4522bcf7865bcd07a8c39dbf2741feff2fcc1d70a38719d7e473969fe38554ad5a1a1aad301a95904ae6f14cb9577198735386af52ba8d442220dff988eea8d313d9543ff6f50bdc675d059b2ecd1ac9b8fec7688662c8256465d88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
