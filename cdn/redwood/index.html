<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"874b0edc81bf748298bc6a28a0b5eceeba2adebbf3b130444d1087672cbbc6016cc789bfcd9d64eca75ee72ded56e2149d5b4b0b74d039c91185969f0ae0510a3d9496ac910af47018ef3b10d3cd7f717cf6a21699ab7b296ddcab6088473992a5e5f9557a920b4b8bf52b9e6a17af2a20c7056fdaa97d1917e52832d10d9b1ef6dea27972c1ab45b58efdf88336b51d852cb17ae2f088a4c71fd43a8204a9b71164b321285fdb884a7560cf6a73b601cfe64482f630383017a6219e01b7fa166bf137efea96c8366609d86abc4b90be41fa299aa21ebed7dbc89a4ed9156d4aadeff8fdb8aedff998779a4728ffbe0c2d5ee0f2f9c4450587ad43df8de53a2e17dd8c1467026faac7dc990356e688299b2cf589f53103effb0ea3cdea704376e19a7179f9cae352abcbf348125a0ec2ff9d623858e24107bea278cdbf3083f82afc4209e2a3ea6158b6fc70994aece9f927cda80b7455c882c40037354ee78682475bd740a2c98ca863a34f1f666b02c2897c4e5f47e6661569374a7111393bda49e7ca11c6fbb07f7acce9899703e93f86f5ac983ee7e6c0457dc0706314f9248407b39adfc59d7485a0f4e61fe13c701aab83e4a90092a73c8dcfaac00bea77763bd149844c6367900768b452dba16ce12945c3ec209cbdb243caadafa4bbcd40b1f5198e2e1d9655b722dcbfa39bd29977c35e5dc308978987987fd13ca11f73824f426e1db9aeeb2de9c56a839c784c2fd6214be1073847080dd86cf4782ca38b41bdec44821bd79c40df953f883fbc96e79b0b9bd1100f646b10ba0dd5ab4a5ca6ef78d50e3f165209d981c0515c52bd8b8fcc22d4805caa9420091ba6d804faaa8a992e91b99d40d2a4eafbdfbfc9ce1a0163cb14bfedf5fc085dd36c1823740de3e85e7921757ee194b136ff68b2a120d9f444b88539ea6fa769194c7c62af0d4f105c9f369fd294b671cfb717fc0037b9bbe3fe69764aceba5c67093151875006acae4300b403959156723ae5130b0758d3a3987039ce4339a375db86726ec43174dca44b8a4aa4df24be8e1415427895ca4087caf2b4874b05a889ada9829c0dde3c2744dc39ac3870820ad6e8a5e495c010411f476d020d3ca5ad0c5e91cef1f61b6834b15724a2defa549a0299aa3533a68e947331941f8dffc67cf73e2d7adec599e1c30be97bf752742027549c5cc051ce68c1e4a70d38a94078385c11fd795476879c5aa3269fc39d8c717cc5ffe7bb90bba09bb3f0252e4a8da2f6649bc258d733e76dcd7d464c891aee61a0d1d58caacf162a8e241b63210e9a9bdb44dee126c0a9545fbfc6a38b22b1a5bccbeb068f489bba4b83801aae2f7e7a4181e336483191095d7962d2e46b1171f51ff302262028664a33388131ec09e097e11e7e52d5348e9cabaebfca2ec79ec9e7b022c2fb8939ee52082e5d27222ba53ceaf4f943d8968a7e99835da566f5db521d967ffb5cba715d0f8db830ce235357d0830b730f78080c66aabcf42f0dd251602fa11e9b0896fa735af46a46e0fc3c45b545cf25fe3987012d6c260ff7d40ddbb3cd9fb06740748d7f90693c759f8a5f4c16835ca4c683129b4c074a5a8caff6855bc1a8ac6073119f47ea181d4bc266f15df0daaf9ec7c6525510b8a1af8c00814aa63b0648392b7d2b275d41c9f083acf76ef13840979118326d0ac1f1d45954bf7beb1b85e722569c3a8301215fcf4f275291299777f29ce013a0bca5b21dd6c1fd4e3635860a1c5faf21cf5fbd0bd7e881aee843b67079c7158a68d75fb068db8394a64d4257ca56a36d3c7472d9fb3bac4e37365545edbd21f87f98e50269606e48995913aa687700a2b0673f511df33de16981c5ca599c13c4d843b5c57add25fb906a236a8d639e5133ca13d7ad99287350c2f668fc59a386ec15494eaf6ff7e71ad35de9d86e54fc01227ab9ac341379dd1b97f07776837f5820d8a87943292f620b89fa0c8f72cfeb74d98872243f0db689d6a2def7b315f0c8a1ef5ceac51d17cbf161caf9c2ff43d72cba735d043df89e9c6b3c1086d3386199ba1a613024c5917fba22606f0abaa9006440e68f42c60509d2cd9f1081657ea94f8a1565762eba300855b3a74a15f39ae310cba9449285e3949f424e20c2c4dcae5e29b67a2457123b9a20e762f2a4e615d2c1e5e29588e7bb842a11122a03b0349e70a71431709183890c5a975ccc6f32f138ffae608ae91dce43e5fd9b545f65fd36a99415d64fa1723b172558fbddc11acde09030e04e398c7d5944ca6fe6c6dc0426b58ef85ce502043c28fb70735e7a62a6f43a213f7653ec23767614d051f1149dcc60a90ee0c6122651a675101d71f3f371e54552420d5b4080817933b17a560f48f3eb552d7df05187f4cdff7dc160c1a7a6d4fd231cadcbffb4afe2494436c217de727e05ce833e77fc1ae31f53dab2084213298077bff085c36d303e6ae87026239c473e0389650ebfe34f192b3e03039bfd83c1b4cfbd1b4692e394c197c881e3c4a72a9c6e147926b4185dabc8689f002456b0dd3c65b6207ca590f3143a784ba2b07992f7767b48fd938cdc1d5a40bc27799817751154c9e463890ddeba39208d8cb30177ac582a2ec84760aa5e50bee4c9139a4f4154fe70919a472246c64642f93cbc5de1a9fb76e509f2fd12805ac243be4e124295103194428b10d2d43bb3006233a90ae2e8b2216cebdd527b40be3904e4c32f2d213c12b48b779fd0fae15f3cb8702fed0789062e8f9431dc5d9727f3e4aaf4f2522db7b9ec68a78db8377c7840e5d6feb875ce6283c99c7a60db44449c9b74f72b8ebb4f50d32ac6fee5d23fd87928fa7ef795286b63412705f1bffff5970ab9af2bfde60a1dd41a0a8bc188312f7fa5f14379a71ff7c573d066bbc12bace3c8ac15da9290a6ff95b8c9ccee7838aa2a95fe0aac3bf326e6f501e07c216a6390193c62c395197694c0230c84d4d0325a6a60b23469baa0d33b4115e022ae6ceb50c0ecb81eabc697c3ee5cfb17015e7bf79c0ce910aeca34dc2f2ee17fa5fb49d4f0093f1bd45963f71f8480d3d9fb1171f02600ec3fc4253d3f87a79d10bf76489585c32f4c4a16128c70939a0d36380cb7c58ca440230fdbb2d8e894cbb1513a68bc5ed2913a62bac36687551feed8e5a9e336215a33312cf94b9f1436383081ed650fe7a9ff9e35e8bf20764cac1bda17cb0de238110976477e97b5dd2fc5ddb476ffd3bd7cd2c815e76ccf7afbaf2d7c7e287ab897bd2fc0bf97ffc7ebedebfe29ff331edf84a24bc9d1b6073da00bc9f021e2065ec11ba30d4c9f239948df524e48fe36fb92f9d15fc577d21cac9bcb5fb902843fed26f71f286ef0486970f64e9817256a731e04a7fe5083570b1e15246401b1965456a8459da0e0a5a75b6442b74d82c782b585b258b340ad67ca0166b63fdb0c3302ca36a5b52e5a91c10cb1be42565bd5a6904199897256913359e17b294524131b21f54618059a91c8d4dc1279a169134029bb8a434fd39d699eb20446c4af02b7e7fb32ca33a7a296b2f51b4ff1dc412de5827dcc82d81e40e19ee69ad9838abcd9da40be80125e4b685c125aed513f554fa7c061fee52ad44581ae0856cf3f72eafeeacf1eaa23515fe738d39279f176a7687ec5ec9eae01cde798e152371d1e665e3de7bf17d3cd9a5eb385be818a53e9535fca860cf0c108a6ab8c43305b20fe0a051d20eb4fd198358e4fa728d2bfb6fa636910a35b2e4902c62a97c6ab937e57ef3acf8f296d983ebb64c5a9577698550f40a7a98dc53588f3880b2f0b892f394f1783008d5b92ac6014fde761df397dd1b8000e040cd0a50006af1a687e5fc76c396bff0d1345590557ec4df5b33f9850529f5ec07ec9c46f25749075e4125e51f0ba8c8ff7866d9d81e912f06d360cf29f230d51ae0e39834aa38c128c1b09644d97f146a7c9f08a2bbcc3da0bdece7b607106d7362d87813a11f514fe095202bf601d154885d5c476a50eca3e9f2598dc32de083d5a4bfe5eae80f2002a31bc1b6986f71e6db4c8385d7ee9d7d6714a7862eeafbc1bef708ecc732bf9e5012693c8e74ffd8e255a0ca07c3d81a8d03fc2751811ba8f755c50cc6f8130b1aa4fca43dc2f5974842cee5e612adc9d906c829b3706e20264823d67ccc07581273a8e416136309fcf84d9fea36661d8b8d31a93b36b24d67e73402cbc84ba461ec80f76b73389e10da567abad04580f55d8356d9479873a7213075091ef3b49e8d6d3b61a3f6bd312645719836ad52907dc7206d46486042c0fb2b2491b1d0810802c1d8df2f1e6a86e14e260620e89558e092c5d7a0cbafc419d49fae2df2d94d662fda872c6585bba0a643e7e652a52bd5db7c79aa62efaeeaefbf2db441442bfb6c813fb3fb7d4f86c71bdf1f07ddeef7c8c0ce4874b23a5f67c85592ca85a4e5e01f7e80f87578b85f8cd536ca2ca0610f17a019ea0f0f06f72e78b41e49c5f692692e5dff3a5c720e491af532702a7349d91ecc9c446c1c273afad093ebbd89fdb62f78a1622c90c0b29f1fe2b815bf16e3800fa88522ddf59bd02cdfea37a0eb7ccbee5474bd8c2f00b768251ef3e288365bca1011b98cf3189945016452a71ed73be6605f6880a5884fa67fd62343cc19990bd3107695e98cfb9d22386e5922aa104b2aa671417fd79be031fbc0a00f2f965bd1a03bcd27ad69c0207a3eabe677608595115049ad5fd4dd0a3857fd10f87bfa9a2039902d2eb58fba0b1d3cc4db63049c6e0cbc17f54f702acb607083148f783132a5761e425b37cd276f99136a1b2ed4469a16a1823fdfa7d44a7f20ab2c25143ebc51d558f696939ffab91c44663d4a4b87f8c899f0e6f894a9f6573267ab953f3f683355ce32ef365027bdb146f9c6336cced2d329de23b806ddc62b7be10bc3890e38ba6c4c278c316f0354f04b6cff1033efe6ef2a9a7e69044eee992dd8d17d5a7dede4a145a7b84ce37fac858c345144028e37951937eddc6d00ff9fbe144cd388decc4c64edef701816614e0e16f23720738217a246c3d1d0bbf6599f0fcaa66b898e86bb8c6ec0d03d88ed7e9e860e5b1e1f4fa1bb4560dcbaba00484b8b3bc9be64846057a9baa45179825274842c0c4e40767aa6aab8236e741ff4febcc421417a4790fa0c62cfb1e4190ae9203889de97fe51955d86f1fa4746f7bafd540e11f3d5cbee3d1741f78f03b92748d6014e4ff52608a0f2fbd9e2b1b08d8284a4180fb780cefb2ab40d83a9078cc9823dde4b8df827cf31de3cc1fb3f4a35b4a757e0c662fce6663d3b939db4831546f581c72b869a3d1862b14be5c79475826ecd43e61a4140da498d51ad86ad5641da489ff20397e46d7a6c34064cf9d81715ac5bfaa06a2264081c4a03fb98d2372ce42f10237a539140d51baff33ba550380abe349758c765031571ffb43db6195b5da602327801d9b099936fe931797408657a3ee37ff702a585fe71500703062bee0ec86de98b20ffd332f6202ff286fc5da16f2e9200d45ed73112d01d694ce9ea211fadb3361f78385b753a1ae7c1e824e7c86d6b988b562a6b5046c1c09ee25286e66f185544ff6729c0675008bc08b9cb340700022a5dcf94109b4b8af2c0abb1c5d26975f65ef5bcda6ee9b69dc14456b29595560870c05a236d2faf9b790195a37f68a2c0e7445f278f859ba4b0cf4f16733f87bfb28bc0d3f976c81fe0ce371f1cf72d0f3ed5a63fc807839ded640e7292d4102d14abdf857d689962f3ab781a7198badb0b415114fe16acd3d572e31dffb3f600cb888f7feef3a833bcf6e874957c8cdc4e1b393ba3e493abf890a949c7fa2fd183dbf269b858d52aea111b3ebc01ad1595d553a4c5e54198119758efa809c69e9ff35bd6ec8fdf452ebd3cc26e4cb60d462c2002d3ace254ff5b70ccabf859ae9f5895cf329ef1a93c182a51595cde82a4361ee607ae137bd5e4dc00a4f37baecc4926d5e99d60419940bd9fc8e18e3fafc8f71517512b69392917d17f67e7021c7a27c5a1c425ec6287063ccebce5d3ffcf47997e59afb4ba912af6efe0bb098fe05e91157918c2e19feac508b62baa5d4734136e4797455ef8a35229098fd577eec4301282c6be7d84cf7ffc28acd2a457ce774a26d11a929c4148661ca2e82478e093245ffb605ead3adfdb3d0d9be940e08c96fc537de462c9aa2491c56d69f1e806951742d7566207192c4a1b9b00a5bbf67f0eb4d7516b8c8aaf8db4605aeda7c2b84013a91369e600ab3e373ce08003fd3b247fdd44d947838866ddd8cedfa6c770859e61b797a963fd90d071083e7b825814ecc701d030713295128ccc13c0d932b69a2a1b497c116da168e58645339e1c74cc8c42aabb4da51794009c1e42299a677d8e4f581f3b1ed44180643653ec0542c99b78663fcebc4cde3a9ce3852e31f3150a0466999f385561d73a32e2b4028307e1a8c48ada9cfa8c2c3c7846549cd4dce352786cfbb5acab094fbef6577a70ed4d0a588a953906a97e359050e32c0954f2a7267d0186a2e6afb320a2efcc5f887c55c95a96d56535c3a69466a6ff3896a94e8a80fe42eb34b3136e70607d5a6c2b433fe1f4a04609872dbd749c7cedf24bbda8a2c015ef9d75bc76203957ec4e46cc887451630dc0dfb49c2db36dd62db77190591a9b7640de11a282f0c1e8e8dceef747683ecbd01f1c1f334b3916b7afd60028a5945c5183ccee00dbaa678ef393805a8536b8c3de83c59466c56dc017529158fe5eddb9798ab43901efcd3d9163aea561235752425d969b6c801577d158dc8943fdec23c77c8e2abe893b1a62f5f034be14445a50304a94747dbef79d5f19fc539d8a7c7a619d83a38d53a0ab04b33227a984c69eb25b1cd78578e8ad731e04b3d65fd6a852f7367e75232e7364618f8708c13d2e5eb6ea8acfa448eeb4fff9627eabb06e75347d62e4b01a9ee5dc8d25a106e30b0e21cfba3a5330c3213028b31889fe11504c88ac2092489a9f7466d35e59dd8a3daf1f08b270dffe78f8e1aab8de11c456e2736b5cdb3bc021071e8192d56c67af9b42e698653cbf1d931d74da0d339c70564741f37b3600bdc5d2d561f33c0e62296822006fc6d8094582cc58b896316b7ca6e72a9c58f92b01db881573709e9754c0117ed2f8cc4c4a1e9a532e10e81c82edc048c0b449cddbab397741e21c0374ea6d91bf50d2d447be979a1e6b9e65e93b6e51d5124b585c177c3cb5feb680bee5874db0f79ca03478eeae21bde089afc391ef2946eeb38345265f4c674799b8f36b22bdcfa94b301322de52ade7982409766d0e90c37c5b68c77da68bd161231fd05a4565111f4f3738ee9698537aa85172fdc4acf6634e40192f2aa0af05241a81ab57358e1f59415dc1134b6a2db84d30fffd2c20df7b4604c23550adeca7b7207b86241e527fbdeb1b916df2848f697e6feba00bbffc5ab08597fca297dfef44abcd677864740402a8e24e8c480fa3e7da6a9b8d6f2ded16f7ab17819f2cb1031c2cee263fcdbee3ca17d20d60c425a9682f2a2c59781b86d53bec14dfbfc7a88c1e516b4e05ad67ba12885356c2e2d940fa863f829f4e1c01a9245596035a3da0d62f3657c32ab2b4d9845c462ba2d3761e6ea16bee4abc20d89ae7b7a9c82497e0b2648cc966587a3ca9c79acf9b67e835471e0d55dc6d888080ba1723a96d3628c57527111702536dfe555b643878b5bdedfb13ff2ccf9f90d23e40bba9b431a8189a7a2907de42c7a365de8f97fd2dd3208c676b7d517d851b9ae968216dd3b2c388b778ff8f4d8ebef0d30bbf0b7a5c70a5c4d863e5bf51c420a3060797b2e9887ad26c7332c7c604987aebd5eb30d1a2e79c2f9b778f44ecb9b9272c48b3702149ccbf09b1bf5888b2ea4fb82b154d2c6c1cac1896b59aca64289210dec42aa7276475f6f1fe194e9c45cd6a83eb50ad65227b4b6807680c2293b95157e2eb477b7baf59041df62065fd97242020cd9bb56448561fdb07abc5ae611138e1ddba8d038fadbc443428a990afb16182103dc665412a36a03c40cc49543c66c849846577c660ef118a60f3e2245659f97d0e72c43c6df2bf9b0735d16686b73fae8203572a0b91fdc3ddd8e8004c96774f160e80eff557f0e4a725e6f332b9e583e94cc759fe060b0d1656fb1baa18700b6a92d158218df058a310ebfe332f75d5adbba16191fafa6b44a4141384dfcc664490377bb411b17e56902fc682e93344b86488f4eaf03d303ed85aa0c774cf8a2e314740bd06e84a26289742b21001b71fff1d77481fd4c3970a5079a0abaad6cc6554e360f1c3417478243a6a771e70b92bfe96deb3b6db24b7b7aac6b208f0e506d6f0aa38e0095c20cd6c6426606ab9a70ffd512645d441c9b0cfd382c3131f7c71542f7a50f94791ea5f4260e9608c7b24dc9230c04d9df1fab6cac35557ef2bf676df88962a812c15d692bd02bf082b1a2b357b0ec1426bf988741b94302bf64aaeba0dc59bb3a4de737851e0b76adf2165b7e241132b90d1ed0488e7f941e9f3e7e83596fce5ed3e10cddd5a26624097e84605de8703dbf03802bfd67862f87c701feae17f4f629590968cb7e42dbdc8926d41c7525424914efa3788e353f3ebfd26bbc88b3e79c9cc865419f471d3a19cc023f096cf3913a52b991e493ffc585af8ef68fc629e97a65e48292e1686d356d63a786add39eee9299d1b4741091986449a06f5df0d3dfc5bf596ef4739ac3a18c31ce0e6acd51f711f9d6cb97f9d07d53b0a00ad61e2ce53b53d97c9074b72dc8aa33d69b47ce75bb75559f7c478b0b1d5df7d470fb37cf57ed727dd7f1c483060bd2783e8f046f4f94eb5f4b72d9190d136f178443a54e2e2433a05a21e600692a76f489b1f75411f8e7f6ab66f103f4508379b3dbd518c9ef0de900f3e4a8b7c70cc4f28ee2b5b6bcd5b03a424e6e2fd30a166b821cc8abdac1d996e3b1556d6a758c9a4682ed79bb615dc5a9d5b03b924ebc346dade4762d54f66be3523168af741d4675c9269314c71063ac4746d1e341e2db3435832cb732c9268e0c4cf5a03f2fb2ea0cfe88653af61e34db33c29a22186a45d87b383005389bce0027bcd4c85666d793450d0a76755ea7be4c985ec2bbe1a782766ace947f89211ea770140d1937c0405007318798e21b9a4792ece30e203c223bfdbdee1d1b90e8253bd9fec84b00047dd4babebd441e8ee20258d4f64b70258aee5c4b2d366c321b472e7ca7d9799791cb378a80c3171800c4614032e7c7e485170a8cfae3ac8402a1f6157e9e4d39438e800d2cc2aeecb06d5ae715f37431b7f957e0b32a8b491276bcf47e7c5ce3731d55d8bff4ff2ff5747549f6b29f11cb4b5f5dcab70693f3c70769d88f06c26012a1a1fe89f981899abeb58c0993ce715af3863220d5048d2e8a1204ecae81840d0a55a64fe5075a5375c127be3b42887bc20bc163f34db3863d78b866badfebc69eb1f712a62e805e9f3431470f148c612312e815b630539348e4cf4be154c83f21280313d93e0ef20f70065e4cf17a3cdfe392270b562fb8d12e30a057fe1060196d979461bf14ef827cec3a2b6a33e979ff54edfb807c157b164328549d131663d5a8a64956f0013d9c26723715b591ff087bb7834285db5801455754dbe2c01e789894130a5ea6cf4b702de7d7ef37ec2257014d668eb5f69cab69df95c2fd1cb5a532cd93ae0c30fcb4f8015c4214d9e45bbbd02960331503e8cd910995650e7b1cffc06ef062b3f8186b8a24d4df670d560fab72f02758266316757c48813670402d8340a4dd77c9fcc0b0358ab9555f53a71114ac94a6f23c19afdbcc78a74a8b061a3cebc4da3874733461ee809c035d66de824cf76d5c747622dbc2d03d2707fbd8148f28d88082daec6b86f570991391993be87994fd74e532c2d682849cc222a67ee301753cf64f4c62d6c87767945b6ab5483a39cab26611deebbb5247bd78162cbdf470308e21134a23b73732a78de76ef182c2df6c48423d5e1f8deeea2bcd45d46b09a8d18ce88db4da238f8ffe89ac4f994f06473f4dac0468c09a57658bdcdb377bc3fa1e5df5e9cda13f5bcde8a743e6a9dc5638278ad36d44fd9cb4565b8344b6dc3c4d5f0ce446b7bca280660f676315f93118c7e19a6e6d3b2fecec25711ed264637724094c74452e0cf4f789ae948935ee048941c955ad92086616b84907b22c720717b9dc0ca19472de828f41fa2ead0289a8623fb79b0d339c737f2a6755c1d2f4acc12ad52948cdb22b0d499c70667643cffb2fdb4644ed3dc66d7125a061a8ac1c0636074326a5f516213e73333f4136c74d3e22752ea7f512722a384bd119bb2ebfd59bf9f9ae733493b9ec2ff8c5f6cd1b79691e5850b5f1811b523c74dd665a2288e542dac771e862ee6c9e3a05f6c922254b32294f440359a40273543428c9a8756f52a8df3898d81dd173eb90554a875f2fcc45cb1946ec6560283534dfe6c530dfc917d30b7bde2f66f258a87d42faeebf54a0a20972af1ca4278c887da7e7dbf19b2aac9d17abffb8635ed1b687c8dc539795a3ec06dd447120f49dbd8bd691c252e5899bd5df37e7c4e3586c2b483dc85252902f684cb36b716199ee69eef2167a639f8bff913d2048ec3fe4e150f18e60f1df1206dbcffb6cd7f6fa40271580884b9a440b0fe67882e4951c2e4fa8240bce4ffa17fbd121922d5edb402c80fa2032ee95fca0ecee8d3a9bdd9a3a658816a0548f6eb6f9ad7a830cd217e4a461b2890e74f52fa08bc2653e95a27df1395726d9d23222c88a8d20c5b11d6c2cf14274a692fe346d4eb4fb8a69ed214e86119ac69f2e1e05056fd5815637499601e269f6fab982af40f6e2c635a788d7e7fd8d61b7acc8e32d60c43bdb55f9d2b99b006a201b2ef05ae509ed6cbeacde513d0203882019e495271920ae3f1d5fa2d3d60098a199e1432033644ee8f6bff13408b7fdb36ede09a68d5452698d79a8b81758696cda5a08cff6ead1ec821e1e3f9e42386b28b770ba28b264e4c0e0b38b371b1750da588eb3554a753053d972762e6633b35d4dee7eb965a5f1a1ebf8a625525090467ed78715e484c993aaf6b54182a82aa94f640f5a646f0f3f995d00f56317dcbb1a0ca6562aeb791a337d88cbb86d1cc7aabf0a1a09b6a3f42e84acee49a480c481ee15947fb933d1a6d069d8aa0e620acd427f68c0497cf19830d3ab43edba21cf23e750eef0fe754ab799d7d0a7247c415df21f65b9fcd6d39c489fbd4ffb6f21d9770fc02b63e67d7b4a6ca76574867c8b1df99a53461dd2242f06605cd3d363594f5402426b64cb02691f5423507950a839e12c8c805faf45cb8a5493243b16241f749f4bfff50fec633e0f2df2ddb7841f45fc3c7f93310f67ef9be091abd24e8cca51443a2b504a4fade33ea59a73959d1516428aab626518eb4780bf7fbddabf2bde3d33cc92e24aca80afd1856a2bf3022a368ab885448a25f314b23d5c0596621f01f8d3caccf8975e16bb977797301d4292924c2b1c18a21c6656be54c45c0848f60eda293d9795500b32e5e81de6d4dd6a564a637e5ea7864aee366819585b18a94f578dfad7539b7f179b6bd10c3eb3d74b727b27822811def908b8913a1159cce9ec7a5fb746e9f92ea66a0aa7a6b52eb018ab5f890625140c91cceb0266717409641b801c63f859959984c308abbe17f1b0acdabc5beb5454c558017cb5b592158c8b3535c163cfc78de495a1b109015f7acf825642eea9914f7717b014667fad383b59e320f22e31898cf5c8bdbcb8661560a9d1a6e65fd5ed1fdf81897184c5e8efa2b1512ddc9189ecb45720311df44148042150323ce8488ff166322774dcd106daa834e3721cd26ccd30b43b7a1214b498390e974e2409360a48ba904d550528512d19e1d200c7d1f14faccde83a0097eeed44212e6e1e8a221e47431c16894274b89656b4005d2a752a64fd9a2897e00981fe51d720aacc4272535c8eebba56defbf841d0a8ff854509fbe9200a5a8b7789802eeabe538936a81be81336b6d911794d0dfd84b0483852ea31aa1815994de47613e81f9c0d417f5fcffcf4b226c0f9d62fb9b08642bb1542ed5f73ac6c84c5707e6641cab88f20a0c069b69462073d991e919d87ad5bce7c9ccc7a50c07cce109d57152e0bf60ad1de01973a4c4f8f58d1a5407a3831774284f844e03bdbc3c16b4c581e9afb6da21d35a352b8ce5ee3e6e154fb8deccb52bc9c6e80de9acb0de577b4bf7905f890d284ec95b87c5589d022e3ebedc49eeec4246dab2d9a1c9a0a237878104a09752e7ecb3a6683424319b1e9e331e511b8d3a1a61a3cbf9983f0fc9f31af631adbdbda448b18c106b879100c46f3a353b7a208c1ca87323f5da97d3ad68b9803a45c00d1520426bdb09e8ea249a7036944beda406616922606128255bae347de1a6e86e7ecb95e8ba992c9f19a35c1bb84a6160979bd6ca10725ba1ea32e7ab94173150f68ea1a8f1c1273f9f398a2437f07065b9339ddb70544ff5eb7e88e7a42454c91ed37dbb7f42c5787be2d89273d69462d37a6605d5cf0e0e33dfe8afb8987a3cf067a3205ad52a2a3062a8d051145065aa9b812900972a2c10abbdc32135453f76dfc3b8ae76f2eab6a9d0a843739a02fb2a8aff586c7617d7a0879fdfe39973d7bd0d7340079515da3f5a3767c6883aa5d237fcf9bb0f87856662520ddc0eb71c8e1676709f91656c385350ab8d43af666b91a356b8d71e6d3c182a1eefd017014a4247e5fcb5f2d19444bc342d286243b3a0bbac38a4c75a1a9dec77d5c40eaf4fe9d970b1b8b34b911d47bae558635d75f99f3407400d31677c48cfc7290676d89a27bb5b90eeff8361c93c2487e849c06dc047de91e099a2a728f993f62e8cc81394a2e09e6fe2a819d723f7c8779d3803fab5525f968b79ce059e27a96560dab5e5b1efd58ea539f4d8d88876b3709bcd153f8fd14f2e5b693747a3831f9d70486037d30c9df5aa45564f8c223c59419b0797effac98ba5478a23312a5648c508b6d78ab272e95c43ee183ecfa7f8615d374dcf4bcb37b33f90a24ce7bc5be6989f44ae1af8c9aee74e666015b839c618044568bbe451420c4c41d6fafaabc860fbc0fd14bbfb199b5e8a5a2135c9c331b1eb0560042e4823c64aae67243167a8717e3b8c44e06ca561693d93af320b3e87ddab3cb222423fbb63ab652ad75c6b5cfa1ea0b564168f8ef8f1bceb6c7e76aa27997cbb357ea0ed86eebf75a057b0cb4caaf05b8079e57c490e9a32e3542daf45f8fa4760387493efbba1fc88bfb8d6abb6407f23cafd75100fafbc2893562caea8adc8e3f1e02bb6d23813444030766df0a6645a43c05ebd5c8e869355ca9296971453b0bf7a747b467dc4546384a595471eacfdd6246fe5b4b86298bfcd89384ddbba2eeec8a94063175b37a7be4171ceddd3d50202ff5e36972b767ad6c3ad6dde92dfefef81960ab41f0c84a70b1410318f5435e118af128e684e824d43b66eb048fd96570fba1b941fc8594f3a9ecf4d3cefc8f74d354074da1c9d9f558d58f128cc9e588678754465dfe33431edac841c6e46e5dc346b941c4b9ec69e6818ac88d6d5c8ab538a966e6c2249be962ecaeddda764b27a0fd06c6215a46c67a30c3342058fd31db475f664d242068baf0de8ee9151fe58c83315ade8002445612cfa92b593bf642bc7a205634a762d1cdf37236e0db304aafefea0116415adb96ec1a19a121d9a39d672449aae5494058e673c70ca3a53e75df7ee4f94f303de824a82be168e2a36cbf8ec3114a6a2eb09b28913e1d994ab6e8c7deca55e12a94add69063ddc78399e676213f0e8a73fd45146f3126134e0cf3a9f8fc4c647c2dcf030c930564256d39721667d474d76b0fe852652547dab5595a2a296123210f0c35df4b94734734eec95d1b98ff9ddb4204ab6da108763f6869568f2c0f01bfa63a5f079c36f5f2363870ab74c314f6b25bb594796442fd4fa0ca95998026f76b02bdb7b5bfba5fe1d49e0147781eefc997bb075b5a1992b41fcfe4db39743345c95065d2c5f64e8613ca0122a5dc470259a62943156c9485b10a9b212b7743a532ce8b2efc6313bebe0c91c725cbeec9f684f48953acc9828cdd1a290777f1e9d58a748126db28c8385a0f315be8c66e022cef760eecb448bca4f54f565dc4610d3384c591428a0e2b5c00e0503c0231344cbcb2129f716bb874332292a22c6481230c9954a5da1af04ae82f3695d56f573103d819e89a1110a9d05d6494a3f53f73aab1c4c87df306abcb2f246df5933e881837366678490288db258a3407ec7f52bd34e73502f5e8dc567f1345ae254e53273301a25914257b6a3f4d208e7088021466f556f18e53c61dbaae25341373d8dcc6c81673cfe1d024678b35230e4b403294d2f7377049e117ba097cdfed8b1b7e7bef0ce7046361e82c3e971ac135669246364b27e8db67e3629070e2ffc7bb7b75e89a2ef9ad30963ad7bc3db4945fcfaee8230282afb435a91a0eeaaae24f8d64ab01cabdaef643d199e02ee15bb714f259d4fbd425a6a3aa77920331d099338514e0766bc0837ea2cb918220d27cd485745c112770dc2afbb388a6b9c8a912cd9125206327f0afca930e9e6b89857a11f6c882af28786f7bf219b3b34f16787200487dd1d8721c6defd2a95c19770faa639e5d11cfe807c92a85ad4cad0f147e99e9224fbea49b523b5e1284708d561eabe99a2d712d25f2f7e6a19db4609bd46259c5b3c8d8c9b01922e411cb6696ffee8b1755a20e6e6cfe7d75918b141707701f21018846621c953a98e7234a3985dd1f1662ed0e4276bc15c8a3309265c2b099596587bb7dbb2ada9f4983169d886dd43421f82df471b339976ad787ed8422a202333a98506825a552bf54d16adc5e401f3a0e126edb60a290a81ba0fea407e87bc4e78d9e51316e8dfa8031d2bfd0ab74759ec0acc1a82f3980b49356d3d3cb9781c5014aac88d46ad4eac4c1598ba119c4dff89e98a8f4588dbaf284e3a476357e2c4ba3ab197650008f3965e18f0b32864f9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
