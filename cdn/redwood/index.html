<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82038b96b5b89ef060526aa9b0af4abc9bddebfb545163b25c6509288a0c723c74a9b47d8a2a428c4793eaa07d0ba4e2fa039547706180615dc737b792412190ead252705085973ad741f1c397d1f4acda5c3c265d5320c5dcefb5a4f718f9006397af3f4b9b7f8f6b64f1baf89c4b9670b93a8b9999c29c2815c7facbf4199f89bf7edab4286fe8e6813538e5d30e2a2f9547d6f2d194e19960d0e412d1269a20812c773c4b45413d6bf7f2d2ee0318ea2433234f17f98a7c70a1ad4e452ec5f11e0249cd0e65955a3826b6a4584e62978bb8d1bdcea2ff57acbe25725bb4110303fe277fe0d6671012c7fcd319829a319355f92bab971378b5fbece9ca7321cddedb15695aaa5dc70c67d37965c11d5d9f2d74050e9276861f5a664ba493714269043a66585d8622e71d951d57514a9d419f5547f586f5d4b3b499263f928fff11e9f9101b0c66b1036edfc8e311081b5156e3c04b3113430b0a3132653335495c2dd033757531d75aa47d5acfbc4c16c1d742ee117521b1eaf40d2ddcf7519c44aeb988536a13930788e45e0674436327e986c90b0ae10ae31a4815b0b54090c591f586c4051211b59dba80b4112ef32c027d523e7c653d6dacbd97cb5c92fa78871132ad196d5b92cba437e48a8fdb32d2b452325de40765d515dab61d512062a830fabaf9a042ccb6db057f39355cdd10b9bdebeaab0f46554c59af4c1be6f0752a66c90ade893b96f454d7cc4c6f4390c84f318e128135eabb60ef637c15300f2e28c13043e530b7a6f26d3ee53a1323bf10cfb0726875fb39d35540ce3dd976fe042c517f64639f36368b28c4bb215f6402f35932291102124b9b7c929b7a6d1ce11dbb2b1bae706744e2dcd3aa5c776af3ad73db82880f813bb507133d54aa8b233cc6262aef829da75af8afd909465e72435be8a063e4e38aefd245b2fa280832a69e9809c2f414e87bb2e5c752bec0098beac32754146c0ac0dab7912fbc185fbd2795e756907450e2eaa9233950f54bf68e8f32303764891bdd00e67425a4b712836facaf203f6c4724a5b922e37f47e87e73036a0e3faeb9fda484102a3059c3f2b8f2a82d715cb2d20eddb63372476a141590ace2707b62da105bf8082ec0b301e800e0297b8069aa7f7c3cf3fe5e895c62943396d49d9d3baafe71129a2dca2479fc8ad4659c4e53c5d7b6e585d3f109891bc98f4758df887a4ab8ac05ee1da1b916c7438d7309200579167637ffc1c1665c504acd8cc5eb0ef4c815a9fd60a2b253e759bba9f7c1eb3efcb5008aa439236ccb7b6e4ddd1117216b1ab759b844f2fe58e59c88379ba94bc65b7b34576fd31810a323dede55d0c267c35cb992827667a5341462c85a2d045993631a942a4575355402360b845af388465d15368cad5423231454bb2f5d57ef7146ad2f08728a1e31491407a536bcff7ee9e0d40aa56d53b45771c705af1c8b42ff44158b4798ecced6254ac97164d7c9bb310d82d17c7a1cc46581ff084d46351cf98c55124ebd4dbeb167a3f41ae6f3b4449cadee0e32d68d2aa674620987b080e18cfca135db1332d0c654746a791c3e415c1a3a1173961a3f08834bd291d5a0e004dbc81b3ba82a74fd08be23162412f8f6cff38899b30753ec440b562a22290cc7092062864af910cbd04310e83d0ae51be460c56f87becd56a374b8e9415487854ae96859a38c8c1695e348244328aaa122321b1cf4f60a73d71aa63d347ab8f5dcde9efc0c0108bd154552fd33ae183e9c1a2607113f56e0a6d51ff497134ac6f04bd6d3e0137b8a7def1b0bfd54b479f7c94a50b85f6d025fbb2fdc483e16b2c27e619d94db1415e21478630b6e7db6e1918bdd299eda56bb27d9c601de04bb74eed12a8950e918f37be4ecf39928d85d60157e29b08c7b773a1f0c9e481406e2a4ce9450ffd5c12151c3e919c70e36df6013e27206a60e49f66e005362c1daefa574f6aea172d8e68d7e9e12b7ae20af08f0a63e62fde0aad51bca7d06c45af2293ce49a9d87d3c1ede777e91177f364ad914067e25e39d3216c2a87ab6686a1d752bb1199018167d23553abf63ab2b3bbcef50778adc81f581a50acede85e37feed13714342c9bc906d77c7c46510317a7649d688330ae6e008b4d533585ced675e2770c68fe99e0dcac2ed41c4f1f31bc0142227adbd8ea616d8a54fe547a14cbbf1aa9ad3eef9b80e8f047d84c50373f0e9dd565f0be0ebda656ce9a007319f2843ca11f67240f6b2ffec60d9d44379213e2447b9e832c014a629fb85f4e60be160422b440236d05c8d88efdce238ef3b65d9576ceafe6af4e96afaf5efc691d01119a016d27d6c8e5134960ae0883fe23058d8578e2f3b91c1a9c71723a3583f19572258e66a775700290e472a8a8780782952f0eeaa4e7d4616d3e7ee9ecabd10b43b94d3b32f6d1d88e1c81efcf55da88568e48151b63fd05ad2bb5bf03f99a406bfc047fe45859cebba0fd7b229ea89682d8372870f29473f447df0cde69511af3fb829a7cf284c491f19cd628de8c4cb4a7e076f776c37943ee254c87872307c81ba57bc2d66985295bcebcdac05e4bcc9b0bbd9b16909ee5d3e1dd6e4fd0374406b1ebd4ddc4403b77a45773e8a1ba2cdc0eb0eb7d918e7e92d999a57223f899f34ec2a4e5cab528575b3f4ec99e1da865d9c212b18ce604ec714c6914c9b025e51094d00c3a49863b6d22d1781a340e13fdba7edbe91ad9095616914d66924a28ad53e958f9448b54ed92b0b6f7bf7a8d5072858f6843863894350d3e684d2b204cd217697898f164f941b74c9f4f1d5aa822ee85a4cba3ec5cf8d89059a559ca66718bd40f6e90e20f7755628681d00d9d305a9cdc2defc269300b9f01735a05823e70c287af5f8f17511dd058366bfac9a4671f799ac8b2a6669c265386ba74011d2196c7b69a931369d6e61d0b361919a1bd14e1d12fb918c9d6d4dab207a7d78c17bd98ef0ff7479d34ef09c23e0154b362227dda01169aff35057a29a0c725fca3157b011931fda40eaaf7d47ae85ce752d5ff1618062a4606e9b55774bcb4940f9f2d40ff49c4c7c23da8ea30888170f19f12c048dca1be83c0311fa62c212d10e8f70b45085e965d094c0aba9c0b08c1c670b92d4ed0a204677534422124a7c16976ccd5ac5b64c23aa1006e8066ff65d362f8e3a179ceb49605855b2dd253c3cad75fed3d95ff7b3474d24303d4f8c05ab0eda0bdcb05b766c438ae36f9527ecd88710bc24b26f9cd590b36ee5375fd8685ff007e735ef897b8c115a2d6f1cb1b59b5ad8509c38ead1564595c5ffdf192754cb68cbd70915bc426c22bb9d1424006bc6c9cd684727604b354d80d6ddb28f4472ac2cb46ff7d65d0aeaa686669c6ae561d50b718a5e38e71238599acf447afed73ecd4ede5d902007107d64c594d15840bb978fbf65e21d6e4eaf9497049ca78e19f066ba1414386bb0b6a043da0f5a31a6474edc0c1065a39c8c1faaaa4554a7887d551e4f5b1b2b7dbba3207cca9fc75e0b931403c783af71a4f55618ca8ce323e52aa3f1b6f5ba962a6c5807c06839100ffcc6ec7def3008e643bd5918100892454b9ff491f1a08d619275fa287755adc8ee68c3737b6b38e36ba2c259c215eeffff4d2eb9d521af539ae21f27a1cb58696a6dfc722925ad8a63a9b13237e02e9102929a8532f8f1a09d93a6650404e027bdc21e04249fc7fd15d890f5ef278bba50d6857afab62699a55ef1684345962e756f77016679c912e7eeadccda15ee9fd330c16093bffea39a211ce8a34b395374c1143355dcf28d1c76180505e98800ac142d2927b41865290898b3ba6b9e0c616cdef6214a1dcbfb0f3fbe9f353af8d45b537fab763b75437c6ec346b968709f90874b8e7ef7b476ebb871490b1625e0472aff559e09c3466dc1019b4c85ff861da7d98f3a4bf8da235ca9f0ac71cd8788349c4ef91ac895f7b7fdd1c7d276add3facc67da68ce6d128daeb5d55a3ee995188a94b769c5b7fe5d85f178a4210f90c3d11e7c6b87d93b8e460c1c98f9166f544dc259a91a76fdea3cb34d5e15b513c7e20783193e59d92d42f6d5758d5e9c8a81481705093963163e43460648e9b8acddfab7f208b6404946591e6cc25b7fa4bab5ccb2025c53f4ad71cd107b26390522cc8656f2b82bb16e5872d1898c2fc82b942cc9c26d7b25842aa16c7594ff92cb69ddc46618f8754d3ccf13e342ba97a780d38169bc0eecc3c1e4390a3b1869c01237c8bb299c6dad3e613899bc19abbe2e1b5e98052fba6ddfa92299f01476c2ce559bdcac85f374f02e2f69a74a02e0dbb98048d64c4ad340107a7fd0de9f3470d88d9529dd4831ea638f8954535c66a69d981c7382903fbc1bf019e4a68d9bc65cb256f8193b6640875b5b27fc3a86fabb89fd39b810abd16c44c34adb51a779946f9932e264e7f3f3632ba9159c0f52f987a663068f91fc46516c07a03011ec7d24c89319dd352ca0cc7644d140695b7ca18951ab24ebf09fe3390fc79481e8d574458194652c968743319c059f5d032797dcb5645d74e4fd1932adde125ceaa1d895cf865fa8059f3ef8ea831d44ae2d384945086b626a146485bffdbe526abf7a27e3f8d5e8d58c20dc95cc0a4e7cbaefac6ba3fed9525a4befa69409053a2fd98fbf72767e98717d34406758898b4b8092213f0754830450543bc9ab5c5ad59dd2c90c8809f27e2b34f7850e648835f86f26e2811873d15f1d980bdf57be389c6a867cfce741708aca633dfe0c7c132822db783d0441c96d14c4478af31f34da84a5a568701e72f445b45705b8e96fcd903879e58dbc8b4b4196b99b3a6ecc38a0a6d39e79037bde58de1d0a5dfb2fcec5c288d880813a8c59d1f11b521d02adc809cc35daf3606f736bef32918fafaeed88b9c4555310c17b8287c95b7da46d9d1e25eeba78557cd5afec12961a8ecd83949a367a8a2a2d750a7c8592f53d3bbc23e91f7100dea00aafcbea9a4d860ad6305bd3822db9c210a0cfc81b9960907bbb4bd88a6816660aaa71940b3f0c9db9300fc1bce7d928ef76c075bf9e89a66eef093440813b44ca56cb079f0437e83dfcc14ed570563858f04f330cdaa0c7a2761f587e664e9948b368ed622dbb003c30395710f01dc80e20e71e224c3877c569d777c3ec39d0c6ddef7a9a11da2f168e437c9974b34cd31315263d2ba3c318da0e0591ae1f885ef966645e2143664014d7ee56ac56c94deba407ef938b54bf91ec4294ec819ab02990c82e9f25c9b11389aaafed6697faf5e382fb89c1904a86cd8f7c7adf9f812b9bbeb828f9e529844ac659c34823f14f97f20b7436e77094b94883348be596f8a0c72ee0ba1b4bde0f0d982c80da1dc56d3253b8c4f1a3f4d0af5a2b2944bd66d73d48d067287bfea746e4bfee5997f77bc7a730c1c6b224ee0155c358d9ce91469f3fe912e03e558d798d85e09a3c12370862822ae83e6b37b981ee728c6432062c20994c12e3730d135188ba88464a1fa933b502c6368125e1b56f3ddd4db6919e4394c85cc08b1797c4ef230fb29f99982d368cace95d9f61037f7a2daebd65153ea23ce5eb96d30a07d301d77d152ff134f447a97ee4bc181377939901a7b343c161cd96200fb332d412c4f2fb7eb7d5347e0fba6a4980bec2cae9a542bf4610d8ef608af53a35c63a5932e2fe1ca7a90b5e5b1c2f0a59962d57231ace54d1c80a88cd924f9be3302dfcc3b6d5dcd897498faed89fc0f4a8ffc4e5fa988dbea4766d0905b678f88ccaab43fcedd54c58efac036947cf51ced6900457e0c1e944b6fd8285b4e681a0989ca719f6c5577319e6f5aae63d0cbc9edbd2636dab789b6920696fb3027ab52b0877a63824264ad4f11a1e408d8780b761e1f73258382848fb467f15be54ffa0c0e6b4e7879e558bcbc19829dd7db119a15e7d8952311f77c7c82bc76f8a957e76ece1b3667985dbaa088b0e8d49ade470e39223cf342afeca587857f2b602abfef363a887d9c56a9af90789ac1782d61515982eeba08c4ddd9b7cc4817cffc26c3a5050f2de160b2410080824c9f02ad3bdf130a7f0701e07751d6ae27d32de888efbc08672d499ec9ee22d0f9622712efd1288fc3b7b7f16e5475bac1a1160d0621cee21215888f1bfcc82be734fe4ca262c5c85d32ec72803bb67449628e65d36138cd94ea7975c148bea40ef5a1686703ef5ec8d853368d3fa5cad597e6f104459bf835c7ecaef7c394350b65384c0014d6f667f466cfb869d453fc8b0f34da6b7aedf6d15c6e3bfdcc521c808d7f4127a68beaa3b0509f87add62119a62864b2adf74bb5872af5c6fe67eab174b2db16304536b199862ee37e60f4062796d5703f5385ced0c5fec557b87a38f3745490e2792b12b03fe1b52ddc45996525a08e505da24645d1ad4628f38ca16f346d21a9a4eb7b7e517ba0ee0061f49a1a2ef925774c928e0418b56598dc5f11f0da896a346db89a97fc250be9f90e6c1b6e0584260eca25a91c3aa51a981def4f58dc8f75ee005d2e40273f75db3315ba19899560575a4b24adec71addb0e7ac604f91e4ef65096684a7138abea1b742f9226c11280acc10a01e2e2cf773dbb9cf39c8949dfbadada1f388273a03a551a4ffae8a5b086c0fd71f177b24b0bad0bced6765d85e3737b0768841f1dbc7b782a7f73353f57eae61c29b49be48f51d79b056d92fc2b9acf30be454028ae52f17e04bcc352c915912d227590d1e039b72bb2c8b6992b09d0698ed2c3776d1c38899ddbc8d1e0d9fdec6763e884bbf212836502c309c6ec8851564c6a08e9db06092140deb3e5077d3dfc9b028484a5764b79475b873d1ceb0919a66428f6aff9747a50d861b2ec88f7709bf0b1fe1b30f3ea0b3e7bcaab76ebc298027ae8ca5b87e601b3d97826cfc87511290db6f08b1e29396973c9734e07b4daf74f6bcdcb5b56acf59dc158e08b9784b64049a5f45bf4ae0e4753e6c1eaa264124e2ec321babb7bb1a548dc2e1e58daaf63193f6fc6424bdc76089819dfdc76eb01405491defc53e7e747a1c201e7734c84f4235e784fbd522be5636273ec40a983257a275a0ec22f85d99bb11bc71309bd31a384161cca2c1e8369726367aa6b0742d8e28e4ff9408e72a466d76bcef26b0c5d23b595b9c56e85dfb34e1fecd13960f5be1f3e50a64105f6afadfb5c331464bf853f0328eb34b4c30d3a24c6f1e98a5a9969517980971fc4d3a75759698d5c67eab552143396af0d58b00b47f953dfbc5122af105deb1c1f8827f91ce0449c99c557db5e0c02f017ed4d9236cbb2765864ca5405fbc5ab62caa3918fba57ac154a4f5b05c5f9e12125c985b99afd9a82bad5edd2ebf8ae99aa8dadda416eb12247325e63685c6489a4c3fa04bead08fe55a81febb19ad522a9d309759b88c9bbfd7db2147c3a8745cfa2b088f57b563946431a235a24d4d3f1237da3f24b3c9b9cf05fa04c4cb3246f36f1ac98a7633714838278ec866fd95499be47492466012b4f1fd2a55eebc2ce4053b7ac9d09b5595a8b64a16c0f61d46ff9959031f3cd535686e9ba7722ba20959e0dc445ad086a021397a459d7eeb3281d1e648203101f5f363d0248bc570f5d27c85c842f8413d0cfbe9cbf950a11cbb2b6a275098edc9b8b1bbebb4dafb1154c44c66a144835f7eef89af738c858d63c4611a362da26e661496bc79ae0308468f74fb15d5f4ca45462cdc0ca59be14941836ff4bbb98673d831a3e854d3a3542566da3ada4c6c68cf141bc01ac4a9a98309254d04c4f876d67e18ae649801795aeb6e0b267ab5cefe50ad8f7a5241f450f15ee7a45c1dd3dc6ab2ed2bc7f29d64ac51eae64b1466c3155e812b6393b7002870e76013d64ab8a529060d34c1351183e8ba28c14b46948df5c0d13fb0251a531b373329a14c6c805d404a71f2e3bcbcf765bf7cce8053e0661d18240578d2ee1bc8777005d44de5e56a920b1b77b2ec37da3e2b447b29f0cddeaa9008609ee9bb483f5955ed5365ac48d6f219daaffad896a59fb28d76671758753042fc8d8615e45b54ea5ceb1426190a4ee4f65b698f4e544cbf919e04ed5bd1ae64d3f409a5db5d70002d586f7e0be275b69c605aaa97a26a53f3bd0e11f8ea6c0e049ee0926623a9b8ae353e247d7c8ea19c88fde3d94eb0031bf7dea9248a7246bcaa299b72434a340b81ca2de9c8b34a48ef630e39a584c313019247dee36f1ad4acc03345d3dd26fafe939be97d2051302d2d1d9e6afed32500375958fa1bae399672f89cec3eea8b693f9139db9341edf11b420c793195534c1e8ade75f08dc8d6bf4cf4f7f448306ecad444ace21511788f8754c67779204c7a748b7b9d56537077ffac611a27495e85254f486ba1df7f0e9b732545cb1a44f724011899b466c728532d959990afa04fc44fe4f6ae2d86f33f31ab82e7efff48887396ebab0b7afce1a0bed59ad3532cb51aa8b67af219c4636089d9ba0e0a267e5fcd1fb3efe300ad44df65728cd8db2aaac597290a8628700892c5c91c740f35cf8df31c47158afcb7feab58726d77b21ea32f1251f87c7de249c921eeea0e5a661b9772df9830db4f284efca9c4047a8de81e950bd4f0c36b0d1102a519a5b385996f503b50049dd227fe97b7308a9093def76a4764d4b7971a6defc08132d0a22b475cfaf662c8b0f38547faa1df570150b7a2b2812e9cfa225fcfa6c7cbbb261f8bb49cbf1ff70c8aa8dde6d6dd1cc221fba57cb59177d9b928ad19d6b875afdfc199911cee4395d6c2e57b77abf373d98798ed244be16c570035dcfda012d4df08d50bac0a69f85caf37dfdda6b5734ed17afb2f1a40b100923a07fff2896f93e22db7c4bea52e22644ef8be03f6784a761328ddd325fad8f26edeafc92125a77fb3634a255e6301f37b11509809ae24d9f8f6c4673ef26d160d386f7491e77c7a93cf531f1e15e0057f5d59ab07fb338f02c96c89a916d79313e43afae735583d2bf23426d38cc50124e6314e1ac039efed633f5f63acf266d0884382e6138af599959d8bcb1d34a4d5556a31750b27987bf942d87d7a5bd71f982af3b1ad74694e85d70d77c5adfcc434163edbfec067bf8b59da6dda09ae2435579c3deff5bd59ea587bdf2d3be4fdffdb23eec40ea6aeda253c84ccaf672ba91a8f3e5ed1b9ccbd97f42f22865b8fe728676429de9821c3584d0b438d234f32a03cc172c4fdc5ee27778744b05692bfb164845c6549174e725bbb4628adc3edb949f17f07157163c5da424fdb1f441e38f60934635a40b264b2e66bac3c555904bdb0a4dcd1488724279205e63f262f9326f582f48c980aa88fc6dbb76c1faa6dfe6fac36d7f2cc5278c5f908ac8385d771d302d5e08ae569319ad384bdbdf842c0960287a5dea927d3792cd1282d2ebf70bd3b349d9f4afb6df33f773725acb43cc097a0c86eec0b9f3d850e1246114d1588fa57a75306108fbe9977d4b810aaad18253e0cebe505481be33d4c242b64bdb58fd545bb8e7d90151e4ea5a736d9140a8a4807b6899cda57e09fe2d8b46dd81d91a4a0a7531472ab53992b9a0b9f26b2caed321ee8cbdb4f6e02a0b05e2cb69d970642dee09eec3d566dd2833f6faee1c4d60899178a3b76a38e5d87a81a0819794f3bf7d095ad5f38be5a5b5e4b931fb86eaafd41112d423b593c8c1e52485ac219e0b5a01388b08f07ea7f481194f1ecd2038a42ec7303bfdcb88e24751833e3208179041bcb49c6bd33840107b837b033f67be0c89e52a8340a2377042e8d10b06e4be020da0bc2109d9a30020b8216c161302e5bb244fbb2904f466863cc985ca7b675b0d913ba89061b32cacc170328030423431ea0080ecf7a1fe209af93b976d87aff21380236672592f3e5d7604dae903176b706635cbf477d7242d23058516606e28d3fbafbf11899223d064e770f3e6f1f85750bfd6dc368abe2e8cbf16599fc29346f07b875058b19182b93d323a35944a8ffa82088a3d033407aaf53e19ce8be296a35224579cacba84402b9947a9c186fce9548acc953a126b7d97864e3b75de6b4724e8b96a434597c5e0a52eceeb85b10875c3787bd540e92a8c787a9ec2969445769cc3398888207d01054e70de634c4c6b0073ae146b72841f19a55148627febb2a30004584cdf6adc0cbdc53ebbfb103bf8e98895d47b007cac3b4c0531dfb0849599fbdd7eae9517e16b88446859b99c63c0d780adb908e617976fe5090bed49e402fea3cf8ca57dd228ce63ac9fbe202ea998bf171328a12053cc0aa36853a209c5cb54bf3f9109b10f83e6ef0d6eb69ab145e5a07d5daa247c4a5d9c800018f5a9089ba6296d1d70950d31e980e71701924a68dd7db4b721b3cc740e086636bbec07dff27019585c95cbc4ca53343a37d9ae0d1e214d5a1d15132702b9f785b8cc8b608f139af1a00a3b1dc8274f5e12a7a63ce0f721b04599b9cdbbc6e16d02668b339a537ecbb44d2e3c14e072a08aa71650067d2d463f0985644d710b588602faa067998baa30386c31fe519719e4e14f21f3574bdc4d12a2fb542668c0b7af4239b685721b0d879e70e7d587e73ecabf15f8e8b7fbd195897f15d1e1eb97a03b42daf60c04c853b972a74f810f2d130adfcb213988fc6c879fa865d91c9547f22bcf4ce1a6738ef1b93cce31b1af07c2808d2499f3bf29954e4c889701c487835950dcd115d94353795eb8cb7466326e75dfbe8572c76d69b8ae2ded024c3a9ca3c9b3f87f076510ce0e0ecf2dce2b0054e68f797064c7d4df538bf9a2b8281b27f082270b7fb9170703e9a587882b45512696c68fc4c1c922c6a4cfd14f18c630f64820eb82f89eeb103b04f71cc62fbed902b26d4cfdb54ad22fc220fa5c0ca872c21e924097f58316f6f2d1a72f4f9a8a0458d87f9474480e1009a831520801f95074931ed1e2f9f3a7c392d98d78a06fb5140fe46511492489e1d8e0df931b63bde040ee20672e1c511f80efccc07dd912d1ca2429c084a21098e6beb44833f7aa879002e74c6aadabadd9e410cd6d98d3910d15ef15d3955094c62081c987544b2e17f37a7654d16f412ac650b0ae86bb6c114b04e7e66550346feb9d4e6bb9b5d36909f99d205cf132f0cbe78f2b7de21e242c31e70efa8189f37356ae709523d5119dd6536d8def0fcd967cb54777113cedcc04fe7410536efd2035189df3beb113d2d08da861bfe073d52a737afafdfd38b7bb0b01086e512d34199b12d61046585eef5d7fa2de3c23c3e82bb1a8e6e86c0c69e243e792fbe147aecca6f812a22e0bbc808a367334b5752150fdd9864ca1e9f8ba05c5367c9b76ec8d0918d43d7457195dc3c40680796ff092fa232220eb5ee1cf892173204429c9f127a2d8a8496afac0514cf7502f270f43c94af4fc09d8490ceaecd7b7a67ab6b57f89f927491395d0b48a4794fe8933aca7901ef31a11cf0094d3b9655a544829cfc6cc2ae3ed0bf806aaa0adb4bcd0841a6bd9b3bd4690c57c7af4b62a8d8fd3c9a2fdb9e6cf0f95fed9483b4be7534f3dc17a1065e51bfec76709d555ecf6089fd4bdf650ef9ab97109718795a27ae9ccaf8046aa00353b9fbc085e13300a0f3e6bc4cace185eb051589b392e9f7b672c05b51ab0a920dc10504871bb75ec54809499b4614b48f4696ba8dd84aecf2505a5661eded2300792e3ef3c0e3ebafef1e23e0dd00e38b99303883db7a5697d89d0f3a9784a715fe407653c578634213fdc5b621e07ab3e722da4d1fac747898135c81f3de1f34e95531fbe45ed9d97c0600bfc55b79ee15b0fa5df668fc1718a3522557ebfd8dda76f1552df05b0e5802be6107d0e675a1b236eb8732171f59c09209f7e8e0d78d5f9e00bfbcd63e8ec7f62abc7ad78bd3da3b7cdb4c2f71698e9898a11179cd450be8590a68fc2d3322d1bc4ec2db5869fd14b0f8eb4cf8f9a7074185a82d980c8596b4b97e6d2c2f014f0efe29f999d4f593fb307c194a5d17fcfd19360526b48d03251fee6cabf9d4588ae7beef7c38bc5665229e3a4b6c764519e3ac179809b4d054bb07510f5b47ea06b6d9cb97de6e62794ae4977897473383d9f58de4cb904dad64edade04bafb4aca90492a5595d102a7661afef81f3b1732f91b46a567c43da31b9b39f616257cccb4623ff72de0ea1b862455a29a75c6c385137fbbdc2f088ec6646a868e85e507b455497dffae874d14192b546cdf2ae838705e0bff62b1006c763dabadbc28b9517ba5632c965ca9b81f0f9a12a777336a5a3142941f1576c755e82e65fdc49d0967a3e3d0bcc1e6612c5de34a020a6b5e3c1668808939c7b7aee4e647c0cf65f0921336a82b8a3e106c6a5a03618beca715dbc532f8ac6390d5dcacd79e832fa4d4afcc30e193350eaeb294fd66b2f75e5c8f35b91571d6d94b40887af7fe3ec3231bd80b3aafe7c9d78ac359ee34cf82c65e0fe0d34d6e4eadf99b00bda06219755357a52b83aedc06d7dbfca4f2b9c576a2e13c093a01448f94133a34ff8482d21bd49b68cd04ed4944712a4c3d6cba42d1995255449e6f770c66f3e78402f420a34b4b2b60eb881d6f825ea9aa6ebb6aab2f51a71574fe058dcbb2229b1f7419b1d5a127cfa8625640244995b296b32c8024d1993b79cd166d07d84c7fb8972f64a715a4f26f4bf5bf3c1922b275e9dc4cb8ac629311ddbc032892e7e5dc155ddd123bf5235ccff86bc0c55c1501e27a1a57c00d6719a642741236a878efad742c2b2253f9ada16f50e95d2cbfc60cc893bc5acc6f3f06460e64200e0aedd415f6d9b5c4a4cae01e2dfbb24f2c8a82abc0220bf577fd396b8bce92325465ca51a6742619d04a6e5ba72bceca6a74c370e2ae55acedf59014662ba317f544f1983c330555bf911b092b8aec4b4661bd9172c4d38163c05de1776995f2dae6bfdee82d267c285dfd2efdb415b43fc078a96ccf49adc62fb36f0ed960f57df3356217da293b662327be33692ea10850fda6fe62a9cc5ac19537730c0879784d453d11bd9da403d92e5924ebeded88a4510e764543fa326a406aabcc66d2bc48ddcd06688fc496e58218bc3eef4a3a34d60ef9d242e405e96b0dbd6469781a8e36a02ca5a9879bd74f221570341810060546bd6e9925b44a26bbe6e42743c335a8a3811550962dcca115a4525b3937ea76a2b6de390e4c3e09b3719ecfa83f04a83056bb05151183d391bf109625d203cf8c4b1ee1cd81ea78c4ee13e0a0d425a4eab5c0b5e9423d462f1cd0ce9253a0355d031d096a674715484c272f737f3a889728d34299ff4f9392a60ba485297ff4dbcfcc246db2cad94d806c898be204c3a33a259227379cc3aeee6d18fdb60f6f0034a43cc775a9bf6fe0d3b98d93469a0f362b612c363411b993d5f067c3f456edea9da346930f2b3d19ff682addc79f0c753d879e3f16b2c53971cd060ecedf9b188c066e7dd8c6e5e85339c78ca8439a5a128809ee18f13056f4c6b4972ceb12174bc50457157d0cc6ba9da707811be9d503acf1ab3bc8e8f7a0c1fe3051e96fabe1f6e7376fd3e60cb08bfb05f53d91038875975d31f5a0b593d9e2f750c36bf3c83785b1f9a2c1b83f6b17506703a0bd11b6905c74e3e502a20120251ac783411c5044a10bd2ee77ca28bd82b4100c9ee39c6edfb28dc57cc9d8a396627cbfdc0fefc7849ec2d6453b8e769e5d4a978f657b5966011b610b114af504fbbbf77d44db853f9eeff8cf3179cb0dacf809f25961f2ecff8f0d2c836407d7a03a0f0ddc5587c9e6e96ae6ed22860bb0b2874c4b953d785fffc5541894123782cc568e1fc93b151957e3b9b937202f91d1acbd1890469fc0eb36e9415b1fb78c04909f18c2eff5a7b01603e10f00f170e9c08c9b6ca942fd3dd33c826a997425f249c0b91b11ab62ef15551926e62473a68dcca41f84256f388a5ced26393215d635786ce185a959299543942c04d840aae73fbacfde5606840ba5c51231721e3e06d4e082489929e00d22ab671313d518d00b19f7f5e8e68cf274bf25768d0333966dfbb877af490c76336230d8f61359a0f73da0d45d3b612bafbb9aef4e563d713a6f21252f6477f495926675c269ea263086379904c1e4099785474c380174abf0b95bc2c2d9da47d150eedb82979dbc3e919370ecbd30ae001e9d079ba9cc1390e9bf9af9fb7bece72590ab3bf0eeb49ae28560ca748da7e96d67439fa31f7e9e4ea3d929ab04ffb2e9acba1b83e5e79cfbfc41e4d54b0339139878c47462f267c84ec4178ad67441510458f7167dcf088a36825e8ae6a07dc1f2833557233c42472d00a8dc0710fe5f876d6b7b46f4fd0535169672a55d3a1eee0c883dce0ca993e9a47af55742bd03ba6fba9dfa06bd67fc9b0e21a6f7d8ac2c55440b1a09808233db441baf58a9dccda12941a760da8c2ee77971dbec8fbd95e97d5ad7b0de8579524df740b75a79f7700a04818805790fd47e311d933291ce35cbb3f6a9412f27a8ccf02a0a4137875761c8dad1bf6b9ed370cd526af3e2c4f8607c514ec93b7555b3518b94e4561da3cbc6fb19aa6c43d0cc1f5b059128818de5dddba569d2ae915139b821624648b22d85fdabafc3b436f5b17bc394a133bb39276b9953be1691e43e05a9fe3193fce481ca63268d08d3e7cee373878947adb104ea1b1d20e4c1ccc7b8c9c565ed25e1d9de9cdb858aa0dfaa8691065a543f8d0a178f0e1a6e8d9052450c32d8a45152869b215967b7e44cdf4105d7fe062967f393095939ed8221587870e3930fd78a23baecd1498f6fcdd8380ef183d6a6100aeef1b34d04003eac5537e4b1706b2e373a35d3786a27958c2b486f6e618f697b42b5bb6b3d0a289d2364813e87cc5069f113cfe545e24d04c71d85368bf10afa4c5eac4f3c84f355a73c59c0326b35cbee41cdf3dea55d7963e78c45a78bbbd2ec12259b77bc648ad1ebbc2d756d2d792e6ab52e630a78fe43c94c33ac8662dfc36edc45b3d74bb5b831fd1bb218267e372eef0a28b829bd97e39945441bef7c6a54be3e54d5c861d8df5980e8f92560e7c65041d652a6c4ea3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
