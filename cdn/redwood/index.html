<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df9464cfd5d8dae765e6082ebc7ddc046ec816f9353cd25117317dd67e2ac15670a8c76175fe017d5e9595ee997ce685d52949d2a9f69beae60fd5bba1a73946ed754127bcef4f89ee7559f4c64fe92ae9f3998d8e86d82ae110931b816351fa6e1fc64aec5770e9cc300b4aa057c277509138e8768057d6ea41f844376b898c102c8492dac927ed835bba7c0be6b54e3188251d943e2626a4dd1608a0f8bc6920f542c6ebd5b48d97ca9715f0e8151a0bd2b3ad2cdd2e6e032cf0b12fd116d9453fab76956657059e6ee7e40e8ab3920f83c18252cb0d5872a7d48495be0f9c25b2b7c68a2954be5a5d5f69cedfa04f9e531bf91f8c07836147ca7d38603e348ed4e0cb671baa8581c54359f91b4dcf8bd9958da8aa9ad4f0191f502dedae41c026c9c94320afb1954232484a7010802df53dcac6ac9c79dc4e431dcf62201b0e6f49b6ebeec1b5d693eab6ba877d1c8b816859c4d7644cf067d846dc03c372aabd3ba19a7ebf56c0540a703125627986c5f17d5940121f89ea7015e881a147c8d5885f8793e994f49cc0925ef86bfa350d99881ba22b4b288e7e8c4d96910040c7c3ccecf3d9f345bf462cedfb167a3c4cf2a24945156b162d7e0aa9c9e57601bf19f6e2fe9f37153255cfe32a9dafad7644e9ac35bdc6f7ae7186cdd675f7632258e40b51462c195adc27388b540076100a404da5dda4ea759a396ac61dbcf620929dd0398119a32a6dbfaf4533c7f3312089fe83974a39d16da5e849360eef42ad422a88f99291bcc12dbb6c84204579311082a9170ab33743985c34cdc56594c6e2100493f6e2d97f58b6d888b7e4aab8f5229373d3a80fdf3445ee4c3351e935f9ce4f512ea7755de0f214da46cf7814d17c8b9da22a808e6df2ef1d4661c4774272d275306eeb3836478b46eeb39a4504e65fd155546b4a234f926731b75c4268c8cf54204e4b37126fe9b38b8ff0996be237f96b1f9ac58abbace9e63b1d60830aa71884f706f829f54f3677e38abfb787aaca848392dc2eed923e1a457bff8b746d0909747a19558fdae4152ad7b1677621ff8c1cc3c03f6fb2c731893401af5c1612666c2eca9743976c8330835615080b73687cc80c2a2072e0008f761399e42ca04c3a33b11401470c37d56131ba0d2d553f1ab2d7e320da55e926bdfde561cfc60ee9e65c739d3c1e987fa452bfdf965b541e1ff189f568c0d3f5e6ccba8ba121468cb7e4345c9a29f8a36ab8b714fc966623368386b0165b4e5c593a1a7474cb07385ac1403bc01d06f22313c21e0096bc81c8b9c0b29582f0227f0097dc5160b4fd8a6f2e8518ccd5701d8d8a808a84630201e997e851ca3400454622c0ce5e117fd71c7c7ac33c40dad30266e9af81a72be108a099ae9445837f8e590cb5eed769d031b0ad3978d7139c2d92a958f0e79b720e00b058ed773a826f081875990fc3b89c15daf41225d95ad3aa5511f3b4f7e548981c0bce1840cbafb27e638c8af4a38ada96b1f8523cec993f7214c3557335842f924f5bc90c4216701a213d163305af05e9341bbcb366ce86daca88b55ea9edb554a24a807694e75cf9b010c7397d029e0138ee6073ded4496017b045b44116455201321fce837dcda54bc0a5d479ec25dba14eec2a80537adb8352bcde86fb8eb5a04cf379bd515ab7cdf025b11a40e2ed1470986aedbdd143eeac453e010a4ae042a3609421c0987f9cc84a6db2c958484e5a620ebbd3aaf55a1eff69f85e391b4d90b10ea8acb26aa3dddb8a4b043a228f5d7bc6dcd99e3407ad1c8db8aaeb94e07c5bb7bc29df48fc6046703e71f069aacc7212ce3572e61d60003b4a97a3055fa804d4576f95c66ea5b0b85fbf9a5578344d50ef957681f66beb03231f0dea88c35dd9549ce9656d4fbff3ee4a2835b362beed74a772b33eb3554cfd907f260da27bbcb247ce10bb2a59441ba02c5959bf96654bb18353c7b67c96d8946d9812bc4896b8675b11ebd3003fd33d365159f5bc74071d0f0aab30ccdc9434f8c528129ceb79ec34269454e832411417fce43273288c3afc8e74bdb0056f40299ebefaeb8af278c6810c0d1c2d47881bd48972be1be000a8a257c25d272d88328e1199bb56de638146e85aacd21207b924bafce32150e40db241ce2ae9effd63a230f2e4d0df2f8f16a63b7094d0839a4cf3e62564e5e01048a3fdf6868b072205d50ce10b918b4d61b88f80d2892c52a790065eed2e459b79110fbb17840447dcc9b43b66872bfbad07ef595d2906d4d7a907d5a6d37f36e93caa39baa15dcc4cf7627d22ab8cbfda568fad6557d33972d851c38bacc46f027b8c4166cef4ea362309d3f1e4ea878e1ddfca245ee9f5ffa31047ad3b63732dea5b03b57375e347bf84d5993eb536540e5d94a80e4a4c8ca9d2386a51a21629fc1b5eda517a27b5586ae8c765eb31fdc6303d0e3300ca80ce6e3a16a3a03669574958c0c057508c426f61b5d74eb7aa761bf15b3a273f03abcc97a9ca30a5d016881c884a1f79334d7661bbb891fc764223ee307c5e26124dfec3c4dc79337ca8344512f63c51f9e35c8c13983917cb7f8cdd04eda166b7e01ecdf6a6331189a0ab971dce1a3ca70f8867ec6096ecc73118f2ff375adf30f385213b690ab45452c85e1340f029f7067b54e0ace79ece1461b095a7fcac8e23cce4e686f3091eb52b562a0b65260731553da15a3242b8c501c067a277e47f671356d103b8e62cf9ddf149aee123b0a97d04d63044cd9311e2500f05372bf7ef90083ff53a1e1988f21dc58bbcd34e720e5f8a2db6d2dd63123f47d7377abce2cc7946e55f1b8cd50cf79a9358482bdf9bcb0c335e4f2d080b6863a5a6b27c019ffb6482865b366ced594e7abe5fd6090153c15f44258dda8187223e55aa9b5823133aeaeb08ba820109734dff8dcf7ea3c6e73c644f1df1143d1fb912466849580b6f29e58e2f47dea6a749bfcd1c21b390f01664046de10806f5aeb2815271682c834e5b64f03c20eeeda5f877d965f33909a56ee911924f63593546c7f01980ebc7a400d1cdcdb237ac54ae9c32200d952d7f7494203dc0f0897f1aa64198afda8e8ea2e5a1710f905d8f04efede35d8668bb67f3e6fa1ceb1187ead3a93d54df0510c73725aa926af487d03cc5a9c6fddc826fe0c3481b7dcbf979d2d0e5612988bd9e80f807d023609df6aa3b03bd0f5efa91ccfd0034f59544f09ea7c701b0eb76b9bb751be503bd9192e3afe5c8c5092a168e8af4493caeb4cdef725743e998df99f0a40abdec1fc816b00643ec6c6a114bde54aaebdacb329075e7592e16ab1ded46efa6fc47ad0da69a41cdcc720c2cb02e0e1551fb9df2e5fad5dd77c8ad69484df366e17e4b41e07eb5bbb8a6b0b0f424f12bb31e7fce2e9cb0ac3b047ceb2638fe75e5e562c237ad4b5d0e2eb398c64a56b7bcc361c5572dd65df567849f0382eaeb86f98e4658a67e9c0d32d4f1d9a456d4b7e4158b9bf9c0882f6ee8d0cad8782ea9ffd48c6132a8ce669221fc9b5d2a542efddeabc47e8f4fe797e3a99473f5e453b894f2727f47e999f19bb294ab147d50753351bdf46de4fe58b7edb9f3ea2cc170c7635def2266aa7744f1e97af434a48e0a9ac1a2e590e92cd3e1939cb5b14933d609659615caeddcd9d47f00f0b2f2d43c78fdbd76de08e234d65a7ceea1e1b3879f86c2f535b6b418edb50c08b9553f35946893238e097b01b452b652267b289753564f529c42bb078d4b1508201790e0244f9dc1c7fda9914b9a384bc2f2c7b15848dbd956abf6371670e776f3824c7757cf3cd05183ab928b50fd3a0446e73e0bfe27ad7b71f2f676fe9de8e8a75f5b980d2d65d0af74034ad73b7feae1c123cd81a6d192cccfa7c0f951f44d97100e56b89ec1d7d994aaa6d1b347a1cdbd8c839e88a6e4b23c1b5668107f458b2df915efbef7ea02350181f0cb35eae2426caaab2f27c2eb2d8e4086b4d8fe17d6d716f12c43eb19f585c2213c404f62522991e33978bb6fe29e8fa24d4b1267e7ba0b69c87ca8a55a545dce40c7a5059036933bd04adf4c167a25cc6bfd81ee79a691cd2e3c234a5892a36f1dc88aa1a4b78b0011f4a188430ea5939b1a8fe1f985c429b2dd7edfb28c279f183fb29b43835e89621d62f3b90f46ada54703912113c917837e2ba336aecd4c507564a57f12cfdbc3e7b77fca7a895de12df822fcb605b00a73e0efd14dc8e07f90b167c08ca68750bb7ca301350865fe66031bc3531116aaa26e78cda2fc24f34eac44ef77ef3cbacbcdd91d443bcbe290513e1ce255af1820bfcbdeeabaa8c155ee108534d06a2c4a946d8f7a710eedae958cfb314e95af251ca69c3501ea50cdf9189947785251f1a75de652803d4bc31f04f1d9b8e9a5e4a67d15158c42aba0ef61ced4a47fe9ac39d2b6821b059914ee210c6b34ec865e1cf81bf109527f7750f06edc8b4e574f331b7b8b014b0d2f3c2751953a1ca99e7a6848de5d8d150fa02d53bd9656d52f2b7d9327409f23ed80c85fa3b173ed67cd7f48da779bf30c6c04641c817bdc408462545ce85b7781b38add9b70abbc8b2dc43da6845dfe3453336ab68090873c2b9b452b6b27158bb4e545ec4d13eef166a5e244365cd803fe93f589502434b72d9ec500cbd3116502964e052cc00eb95a38d04e0505db6f4fc5e28762f818fd0e26665cc5c9f5beedaadf517e1c1ac57522e20ec31d28298697f4f4ce4845a42f1af7d0e106618f630f60f971950735454e06faf1c621972959ac398faaafa2a5742d04d356ed7133129505d9396fe063dbc959518b85f2d2b43fdf246276909d79863a9d12f35ea65bb9c1428ec3adc8b190454315234d7456c84dd5d687c7fc4573acd78be053b3367cf77702872b1c4e6929325d818a8fb4a2cb29342452c21399f2b1ce9eed49932ba73e13807629d7812fbc3f191e03c6146a84892a7751bb75fb2e6d022cc3da418baa142dd2eb75f73f46b26eb0e5eee6072e4514866392b72d4153578a9c44041c26e4473c06b3bf82818f7647ff02ca22f2efe387b00b69c0123242d6febb994caef3f11d51f249a9435b2cb7997e0f91e96b9228a2c04bc70337781fe983bea0802fa3d73529123ff78776bc2d605c71e7553ef2564367599f8cb727462621719ddbe24529899404dcfbf737ac149b5ac34a2d65928a340d5c7f693dc6641715df8655872e403fcbc1c8db14e82463e4562c962f3a61ea06f1eca5718b57a72eb8f4791fcc40105cbaa53612dca579048867f1803ed4314c16ad2e66adb6c6271fae2189c382f18288d13f94653244df5b028c32bda3982d17879d8cdce772348684fc578fbfc3232f92fe546f1f260611df02f5d1897aeacd190042679e45b0a90ef925a576b45fdad108b2efdc7f4cdd04fb6c1a106fb67d3722489e172f5851a5e64db5a874f947b9a42928c677c4346cb125c43b9232c44bf04774465a15eec87d70338b68c8ba525bed4399385a27b81635123a57c42c051387ebe0d5ba30047e339be9d9d69737efbe1f241b5f0d8225ecf1d94270a2b930ca6a5e8be33a9fa454babc3ab31ec0355e3aeb55cce8638ef41745327643bddba9fea17ec1297a1cbfa51401ec4af49f229611d21f863b26514941d6ca838ec614a14b84efdd7e8cd6d436d0e9a171e1f34cc912294b9a8fa0802b6848e180f146421f75a2f3d2f94d34d2f025665149353804feee4e92f5025dd2956e4adce602398ec3d267486a54ab9d43909d11e197b97972bc1670ff67b9c69c5b169b9773e9c7f5b3c4f27c292f46854cfece65ec1e07adfd8391b8db3321fca0341ec9cbdd1e73d210898487a82ebd50ad034e9bdf9fef7c2a0b1320393d019262d400c707630d2817e4ae89841fa73d2d2db2986e68da186f39ecfa9e9f2698dad14fbc953e8536a48ba0d17e82346f72d9daee44aea2d7824e6a1ea7d41cc0536b24a1c150a37ac5284fd39c8d8ad36c30a4f7cf3bf6a0e7acd2e88507be008dc15d50d1a290ed40e7c1e2caf0b1e339a4c3370a5d25440e0ff1cf6fe86fc69f36f8bb1a074b2dc53a414f976d393163a5abec0584356b77c027244252dcfc0398474e67ee3f3f23f9081c747052229ba65b30815508bd209bd467b3c0c5f46e67af5947096c83802d16820ada50801926822ea44a3641e4516e0dd62f100a1761229f96d8e3f22f9579cef354685db059ffb87f405023ff3755aea85c6868ab694f71410aba9db612acfcadd7f99cd570a90d9e38f1c9d4cbdbb1134b23263f8753558b2a78b29026f5817ad084d291a7b59bfca45d90da2bf745cb1356c6da64fd0e6f6f47572efd1be0e585f7639dfab20ca12afe1113ca2d95707a4c933b3aa5cd12ccc2c05963a1c9a5c7469ab8c0a607fa5559876f120d6e1dc232f403851ec68e5ef3be3054bcec101731542ee4cb228e06854cef3ee955793ef79c150fed7e974549068b3efed7a32cdfb3afb345a4452460a719ee7497f3b4b87ead4771354949ffb822556330ff064ea8bf9a323e469340c386df19238f4fe069321c785e5e3c980e1f26c7c9d5fb07656f02952ff9eca11de310bf56c2b46ca62727aa5ae9a3a2c1cf3ca703a6132ff0053c547df56b007c8b55c26304baf590b186fd8342676023d41250a36d18a530fb5552f6442474b19275b071cb887f16f99c2b13b47e810d2d9d60612e655cafdabc1b37490fde20a9412ec7e186ee0615c8761ea3fc05714cf050da1f542b930e0b6432402e200eabe70777fc4e6e4b62879c6bcfcb96d4fec06c18b28af0184893049a9bbfcedb44ca6d211b50fc9cc56d79aac037e821f5c4a02567c95cfcd0dfe2c060ee6bddf14f29bb4ab8f04e4e122ad60b665b6b4b6bf65237fa75260480bd814558a72333a3d5310a78296491c465c5993fa827000277512d8bb073c67126f34c2af165d33e28fe417a622d49d1bfa4ae4e8d8312d12e3663ae13116765d02d5527522e051aa688936282aa5fe413428cf69e421d10c9f560a3fa33bbf9af58805c917b55c7020cca1e0e65bfc4f714b11f35a0c62c2f9ef38ee460d7a2a9aa4a0425254e0bcaf6ed1e987656ee7a48bf8fe4e9b955eae160e0e0d6d86582d7bbd68f63222e937405b3884a61f7ea1e2912945950759d4126ec92ad37445205fdebd24982a88bd65af0998813d184f69bad232ba8912bdf88462cb86c8a051d2d05bb0b9979241ce8ad28edae45d43ebea7ae8af5a95daaa9259a9a41e6f784b22054f2681ba48399e2661c839406c2621c0b1c0ab7295033895fbcafd9d5d50519fcb0861628735ac7923b8ea29f2cb2bd0c9b4fb113981002329f9f16d6bf8d02637189cc78b5fc62c4ccc718f6e99671a422c5f9d86934ef3ce0d2df4cd2d9844d6e72827ff65af59f68c30492f340590f7886540f2347cbe09c54f0909ca6bd5c245a4a2faa1b3eabc88828a6574b542e85037f07c217cca4a8c598a273a72be885af35c8905cdaa6f03ac2bdde54503183494a0443ef1c9047535027b6a63ce05cb069901efedcaa9e9f8a37a8fe4dfca01406698633512f23d3975164e6453d02d87e603a74517a5c047e709b2ff832301c10b8b79dc93957acc2ac76a0025733f95649b2bccdaeccfb70214c7cc3190792dec5bcea3f93446e2c9ad0e4fdf6e0d9e2486b15a0c1edf7b062892a473ef5fb8bc7367219b78a3b7c5ed1f09562980d09dc8ce6671149b22cd53d3a006cdba767a78bf5d5f9801e15caf286b6ebf6ac6014428f2309520d137fe959e50fc976efd7a71b4bf0455402480f013b262ea56e3412136aebaf16197ba315618ecfbb283fd6f9fd43a83e8deee55fa384dba4825519263d450cdb2d2e0cd31c8f169b8f0878d78cdabd6cc93df376e31a2d12197336b74ce8852fa835fdd0083397fc2df9859dd7c8d0a4a2efe41681393d6b8170c5b3035b3e2648fce0c5e06c9bdb9f73d5663808ebefd39e33a9593d98d3a94c5ee667dfc3dd39a7f3cc93f8366178de45eaf3c557e3be5593b8dd1524c587e02915692f5e4e296dddfd305d2118e9f740dca3f7950f353ddca1770087cb9bfff9616da1119ae75ad5fc600972649c2fb36ce88b520952faeb21d15f035e4b402e8460b3c2fa1d50cf9f2a945363bb898ab438966335c78dff168a18048af6babe6857aec124fae25cd363555e5a3a1bda13180616ea8d7a3c38550a7bf791f64df8339179b7a132a95cfd20530c5bf2619d0ea11585fcf3567f88a68e9a758635cee5c3d5896db26975f370426a4f43e8a20cb7c8eebee60b6632516f7581efa6cb2c1c02457ceccf3ba22982e213c5cd117d627897fa8b4b90b4074cc2d1e7bf94b09fef6b49f059768a6aace1438c4431fe0b22f0f521c93bf6010d79443f5029db7e437ea5e8f06e778293fe982a97a148d10c67ce633622172cede81dc16c462d61d247781719f3d7a81b668204f029ffbfd910f1276321caf0849229c03bb7f6554d39f0aebba46cbef66f107a00d2ef7b8f162151d1c81277e6234c61618b3e1cf21f169e9cd0071a355e118284b6026d1357e4d88453379e820d6b3d1b3c05f975faca0aee09f00e559bc2f8de3abd2855337273c8707244660ce7d58efd399e220eb35521b8b692d9b611f7d145e41c2923a391ab82bc9334c51564a90f7a624ba1232bf57dc63684757fd66c53c992032e3f8fb2144cdd13dd6669a5df5ee2a90f0478bbd4739adf91833f5707c96f8346280b4cdf78014d988773e1cf242b8ecbd017f19a92c3f0010c979135ed42543006b0c815bd07dfb677d758da624126392bc0cd2f46aae31093c06630cafa9e873bcdfe5633ebe4137d97cb825178d108cbc36bc3e442467b229612363d17a8a1a19c158973dbd1012c7efbb0d63f00c0bc693f1eb90ec308a8465ef1a881764bd6f836fcaef326a7ae0f0f0c5b62de4a425028c5a7d6548a8ad245e7d8acdb73d7cd3cb7a36b5388050eaf9cc81527ec707d286c1d4b2316fbe4588eaf004481f40a8af0d22e76aeaa9ce51249d93aabe44335f75c0bcbf53c60c015cd9b738549370da42982f98c86a816580a51aba018b743d7a2f2bdbbf0a9f25fd727c4b9979eebea14c2187edbc0dab1c63954afb43cdddac7f32648e279bba991710bc74d9f8e6800c6d6c7b1e86ea026699c3652641e8f72dbafe1ad992f1038b02b8e8fc41c67a391d10dbed8a600ddf5451ded00c0eb23ce281d315349063571650dc3e936d353faaa5e26da3c430a094a0633aecad7ad0be86cd6b27d969cbb65774e334758979eb7cc41a17a6271628117c32a80461aa010bacebee6bbbdd95a9b417c3467082ef49f20aed2bcd45656611f4e0b9b2e8c251672f100c91317a20057083e2b0bf6573fb6255da2df8c4601adf2758566c071feb3c7c1f040b74d2654aee43c81cf2410c36e9b148c707203278b647dd1cf2b41c735597c702c2ca2116e8582998b63d936d947653346a7465337e2eb601c44d56f29d676e9e126229588db0a49938b88fb747d8150beb29b5b1cb4bcce8c6ae8b56f45ba50696ee11c25b8278d77e0c34dd9aea97377a5d7c30d4a724bbce83b535fdb9ae28e3778990b399a923b789fe5ab8bfd8f1964b8eb898e95a2368293fd42f9c294c239dfab92e9ebdc18ec97ff25821a1937b7cc247bc5cbf8dbce7dcf0e4981aeeed69072d15e81f36d03f7249b93b732fcb3c849f352a318e2df986fa3717bedde05f5dc0d6a4ba2fd51deecd53a879156ab15dd07da6ff0e13cd98df336c0a2119c0727980050e8aabba67701d5937874bcce0fc116371a2eab3f2561004db33dd2d0d4183badded451a153f9a9b8e9418bc23220bf201737230d69c8310ce4ac99921ed2678f6a73fe579b6fb360600c0a2e2c56b4b129507977e734f83c31644562013cafd7073ff12f9c52da1fa75f544799fbc8465f87fe762b59eaeb43889f30b7a08459f453821ce34324a17738632f4406534dae99bafcc927483cb0a93991abc53b15b8b27a7020d39f43dced413ec063cb0b022ea28a8581c7261eeb9e4ad5d54f5aa711dc8bf3efb3d49af6221d096d50d6ff2f3bcc367a6eacbb8052119e25bbe58964e1250461175ef05668ae79b36d6312cf793a57e3ed16528e0008703f9784563a0396d11c5a5209b51101c830f51f92232eda21ad2e85435690abcb6d640f4e3de53ec860b408c1fefcbd9ea0f1b5612b531f570f63ef11311239f637c380f55a351db7eeb888eb5afc4d8867054bb1c901fd5893bb7653183722cf6e8c92b5857b0f39292928806acf635d3f7292293e95079cc44a8896beb14e589747951e0a228453b1fa7f75ece32b0a5dc8bf680e57b3afa00e0a120a654f5e8854da0529ed0d3a0542ff02fcf3b94d66f8a41c5a8193a6556d2e9936ff23cfad1bd719fd19b4a1ba2efb7fb7b0412510b963f3a66d658c71c8ba7f3a7d734b41e83b3ac525e10afc84d87be04e9e45bd73f4a8e7d948efbc72b7238c219c304ada50cfc156e2ef177f5de6d8b912075051c286d6c2ad435365b9665253ba271841c9fbb49277cddf67ccb4c026bb7d5871c6d2bc543de56328519eff4404892bbd458088d3ec81a670faa2fe61b88ba2557cbbcd7423ed5c593ca6699dc3d8e3d49dc3d77a7b8e3c8be34b5564d66e99995e024825045a3b0c738d12ed95d777fb353b0748d66f4c507108f0caa493c59f9a98143d6e6760c72b4926a82f26fc35428e98bbd27283a27517cbf5c3d61773268c6bae88a7a8bb4bfecbe6ed172d600af9c1b571ef42fd3ba713f863401bd93c2cfdda80a18390a82f149cb9ea6ce5dda1ecabd1387edd95889ef36096cae66a54796d325234449f0279b1e8390e59763ff62f1dbc240745bfef3b5ea9066e660af7efeca4a47d133b61cc8cf0d26784fad3bf6021a3b6ec23fd20380f5030f5956eff2f9837ad52fa3d49f2e6c6df8840557477dc63df583aac0e54e99d6c0b6d1c29ea25de8a9189c289fab72b812e5f989bf610d1f25312b48162885012dcc55a00fe9748ce73792da032d45a77b0473ff506be5b8de2742e7ed20419e4fd8751d83377272ab3541b9e7aa05b18bbd078fa8fb5212fbeb461067b899a2739c792311123cae4d1da2a1cc6738a4aae2fa934f2a27acc59dddb6d7fc06afdc7304b02c906f6cbfec8ae83cdf48302f6fd3dbb164f14eb39c500eb82733664344a3f0edf419ab977b42d1b386bc5aafe1f03a2923cdd3db3153f2ce074d79e48fd30f7068e8b0f31120c3b791fc16b2d6226211106e421071b262ec9f367079fbde28436e67daf006fc10e5c04381e43db65b8b9cfc473b8f9c4e418350574fe81fb53cb5ec95085ab163d3133c557f36872376415f666ec9f6d2854682f0af0624a4ce1680baa27e08e92ba806daceb365b5c03463797d8fdf97b584167b45026546ef9a68bb24aa777d6404a216de8b753dd5102db5f5ec7fe2bf147ec89592de9ea3ebc2274ec3529d08a8e1caec02d690f52132ef6293c597979be6a53c0309f94a922796dd8ee132020740cc7471272db56ed9290acbe41984b71a5f6f641f560c283f963030ba3b40f8606ea5898d36a8c9cbfbcc0fd2070858eb31957ba1ec35d75e379e9d12312dd24f40eb3c6671c0b84ddbfa00c0d476d4923b640284a79a89ad97b068afa58492e7d0663c4765dcba175abd178339369a48a965c83668af5f01d0c00a5c436adb1ddd2507a91d0f3070f4954d78d0178df46c2c142f942986dfccebee923cb89d1e17f330078d09c515772734514a95fb7d1c020bafdc0796b14d0e5e9217fccf3eb0e7f475be728ef693c3d3dba7e02c55e28870a3c3e80bbea0a9197281ebc6130984d0c02e19786c688de41f83017f6cdb0d26f3c958d113ae4a874ac3241cb9cfd54936647f4a700ac12c683023f90adaba88656c017a8fbed791045bce7ae1bad27214e0ddb38e28ca3a019a4ffb18092269f8985b10bbcf202855c0e58c34bf6a5aa11e6b5be16b90a051360feeafe979f939c95fcd9af96a5b0c3f6d86b9eeeddfc1ea96921f8ef0217387e2b99c3343a261133c54bb75cb9f57800021e73e28cc021026281b69a6914cab6cd20656db99b4f6d2aaabd0660bd4deac4dd25b1a86de0ee1c8515fd9040b10d91ef65fa5c8c97cc89047f9d7a3212c19c09446a560f15e015f2e33ccfb0b08f1da18e3e264ca44b68591b429bcabf899b9aa6b7d8a332a55c01b622a954663cf13b52198ce8fe94eb9841de70dd7ec6248c551519d1be2b08fef363ac866a320d5804d1821f0586d812c3d7379183e67321f708c1113a2d979bb394abd6892091b28c1322b5e1b479f79a4966793f63a4e57206e11587b554b88fd4fb765c7b32358e6d76225d19ea2622d1f5af7fb73e606536a3ccd44e10bda99e3444045a67206b89f70f7ec2e898558a9a9ce0ba8e1530b531d46b5e5d9f08ee83c522881478c2fd1230147d0b7c0a0563a5401a2a9e202b1a3fa48cb530edd704fd39cf5a868c8d3fcb74b02754e2cbcf568191a98a597f72af78bab437039b786bc633848730e1916ee315eb4ef1477a2a5efdb4c51f8fb5d671974984ba352766b51672c09a19db3e6f288b52ac9fff10cdc4cfcd0dc27f4024c706eec64bdf5113bddd3dc956ca0bea3fa7c70be7f60e9ab1aa2a53fd6b64386cf3bedc26039cdd2da75c5c565f1da94bd51695474d3af63949da156b63f9e49fd9b3a127827a561e7cab3e476488ccc2b4d20a7567b6c88ddea205ad498db32c10542cdb089079b31643c8eb3d35ae854413fd8cb24dff7c3ebb057759f9da72cab04351d75fad9a0417e296379dff4e4d0a27e900345c42e6fd5ea0bfba696e9271cec05a1e34b97b3ce5f84ea0e0f02ebc28dcbad880c9f65f6c6d4f2ca13562dbf1fcec652895d9ccbc359468ff5d521b634d77793cc07b50949fe4c7994948a571502239248f99d3125b88ae885bc459b287c4d147f10ceec681a32e4e47fa75d4ec72c79fb95bd88577720f40a02e2d63db4d3589c9bb695bcbe7daa1928ffda5f7be906ef6014bb990020e131b9099ea4d5b574f5cfee68afb4cb86ce4c2a721d0a2e87fda28169c3da1c9b8e6763996fa890df78b108623fdfae3fbeddc4367ce29ba459080bdec113c8aa989f5c238aaf995816e8b81b7a61438e63012c7bfba32044592e84ca5a5c85457892332a2266690a8221852eae0c53963f4ef2b6f2359c5da1157101401fa8f55f7ad4de110e86cd148f6a68e1ac439fd9c36b07a302bfec1a6cf7b56bd78b30eb011cd2493ebe3588db0fcd30f80b6a9b6b54e3a42e445cb84325447a89b06217e763ff0b526d56e4db57f0b4964bd695b693a6014cb3d7f3a99a80ff2b020e3544baba827ac6032e97bbdc5931b0f8517e2db94874f8d59385e9cc7bcbb8625fad67a612eeac608516805d176070681d6d4558d6ba48ed664c94947d4c9c68bde695aabc48138c9e0c5ee0bd167aed0c9c38bb8d420b448a9d8653ac5add34a59d6cd4fdd22abceb2c193cf800420c0faf191b7502289c9759ce8d87b581f79beae769733736c80e00c7e7c966c717c4334cac0633ed18d6da93131ab1f8c251b1843d31529087c77d4945135f73a5ae94af887fcff12eb2783380cc011de7f8bf650145c42c9c8432812ed8d2e953a8aedb422bbb5affbf3b538d97465e61cdee644b9190ab36754624d56fdb016c7414db0a06d3943af3b644a6dfd783f25cb5eed59720d4b0c8dc0b86bf07811a3d6338fc8643ddbb1a444d4afa8108b6a7bbc7a8e5a348543c4aa5e5073ebfc8e7e9a4c1074d77579237510d2d5335a6e9b9136497b40d6812f1955f92e5d39f73c02e942272ae712e017679175bcf6858831664b4b9b43f1fce50cd2628da5051e37e68e86ed2adb21840f0ac4d56a4648838470630018d6fc6db84b59cd43ae517635a1c2016cc9454dec0b7c6ceeffbdcf1ed97c8350afe6c5696951738247e0cf33661b1870084b54a5da420c1f5b73a2040e693705c72c3b904d18aac2318c1ed2c4f5ae0cb19f165e724276a3ca79dd86b47b6dd4132b206903b7a9c497bbc0bd5fef69eb0cbba68421f7ca73d361ec8f2f18be1d5305ecfc5aea4ee3955ba9787260f9d2c92cf4c7c26aff61d2eac92b39104eed1f022bc4846d23811a8edf397ffb4390dc3b6b05d3f5223b6a709990ead40a0eb11e596728f989c7eb5c4ea7e874677dfbd513fa87bbcab9a4c4cfc5b2105a2065dfac22915256be0f94606b486a7d3b5995ec6b8156d532f69f23ab3f6f66d5e33473e4804c7105270582b249242b539b9ea95ca83ac6ec35c8185feb6049b42b3a5a6243c22ac09b2db0bf10529940c847c64366b9102f989208f95905131c429a89901d06427b1666020cc4cc70081593b5907c2ebe89cca9f25ce96ba66761ae4bb46f1f46d2262949c2d0643a797ad0ab5d200c8717658c1ab14d3cc983cc4749934936dfe2f0ada2cf0d0d77c82031f6ef85a5e01db77fae084b3186db87e53d49b52df53525b750a5a813ac7b82f130fbb0d6c378dfc86114498c03e581ddc7b4a5cac1c7b2293a2b0507ebe6da34125f78ec853d480a8a7a9cc03505a81273887fca542e1b5dd34186c3d842d73aa80e491c056ba1eee760a89e3721c47a1c0a00954a7c53b0f3524a1e266bedd8aca06a7146ee12240dce5410429a784013448771c41c8cf29120b4782d05217b06c6e1238cd7259f9e2483ab5dedabd1bc5b9053e3ef63f31561c9e2a56e2138345da9e79c75d862a8480b9376cca83767772b6ab92fb650ef089ac568643308bb4bc350af83de5a9783d1535894d200029137d4819acc70e1bf702cde7c3bc9881f27705265ef0c1b6da348e024317dd4a37e8c88215531b876b9bce1163092f2c0bf04d45945218e74f2a8f9e603b71c2f86ce41ee5e120cd2f017d84ecaf5cd9185b35fd9a800534b004a604e7ed781697afb92f08a90146f4cec65b85c5b6622c3b5e42ea414656db11be3109341863414a023208143822247fd0b7b14be15fb705c7c72e3238160f1925a14dee8d47ec78c9c1a38e5a9f228299658b5f912e3ef58ff39cb4f50d2f3c9e542f35d97316c7346b9e4f6a43f4d987c9d96942870b3ede8bbf7edda2005d08e48c932b178e6957e64bedc57bff643d65ec0afdcabf4cdef5821bd3e62b49d9fe7bcd650d58043b7a9b6251d7538029bc429129a12ce3852245634e82fe4f030d1a199fa79f6c601ca80fab6dcda204747f475d7f71675d02420773a848a38cbd1fa76ca78a5d2a26d25f635f8ed78ccb03c630bc1f2aaef666cbe07ac517b2b6a16065ca9d5180699a2bfa85373bcec13d70b92a905e420f2855f7812e76468ca7967d904f89b251c4338e43f5369ad2ef572507a9f6a4b8ccbd70199ea4e6297c0308d46150b97a81ea150f066c3d0a71b9009b5a253e8148993fb5213d1ee823f1bc70b7baff3e4df488be27b046bae20cfe1312b759bd91958f86089b3f48dc4e358ba2ca1a51786720b113e4a8a569c2c7d4411c628c94c8890b21237eae07fe18e74519ce6f39bbca584207d5f7504c29b84fbf7facdd0fe26e23517e9dfb013ce6f5989e64c4332b33708faf6ad9e4b3c53a8f721478ea2bf10c475757813754a1963b3190e64f358ceee6d0a9085724ee185aaf5199d30175a4a9713c26bf2525e4116c419a26dca4e89a1fb6429427ee8d8f89a653173ab40dee5510b43630db5439690c14565ed2d1002917a7e30c4830fcbaf5f4f90627202d2116ac7e2d34811dcd2945445ae49391ed6833738640e0fa938484aacd5193728257f7c2abfc58a65fb0e5d392e09d8c09a99ff779f8dcf20a36fd123b3338b0c8f76eed399718049feb1c44a2143b1a8b582a8cfeeb661691c1ce815b561e5cbf6eaa66d5fce870b4479edf37bab5f3457d003bb11a877126576fdc2bce2652a83044393c8b2acc994a5efec558e77e38d289972c731245afc3746c930ca60a555b39bedee35c66fc37e9f83ad91b43b9bce22c81eb0a884a37d691221e983b5db677d93a6a1afecf42208200fa698b1e837b46c371cfaae9eb756306ef3cf6a0ec33abb94fc66e72c08280230c07e536605800c72b5cc28390659049dfc6c57a29eba4efd189800a5e4dbacf1e5ca9440981531a4a41afe4316c17ab88ed59e09fa9ca1b28c69d74bfe011c5a02b9eb21801b9d5e74ba1953fc89e09e19eeb6cff1919adfb9acf91afbd7ed05acf3a5dd5ab971a79d16f4d7a092f47d6a9b81c163194b0d27b78e4a5d64424cd72cb48c5ca9418db696f113b73ab516340d528f53e7e8adb9d699738cce2bc347fd832740f68ca8b5debc20f4b472d2b2f75c04806fc828faca6ab19a900d8a0aa747b95bffdcc9b59284c5eda1621f151e00fe573dbbdc580fcb17ffc7e34c65a171737190d5dba09e70330eebbc250bb46e9dd0c1bd5087880c592a7a396f0e25a978655de18468a414b8ad6e946f5b99985bea03f02055d241f83e519754d83a06b33b38f4ad569332a4be33bd910b5f2ae4c8cbc1d3a9cd4f5c63b858d48e9364710f94cb84e0735011a87b8a0ea96a958cce65e39d91bd78c16995a973c58365c75be5aec8ee2d726525b557760d6a7b6510db5f054daf867c1e48c8f3235e5f735936e041ab6a6af59fc08598ea4fd35bfbcaa18e899f2bd32a5e2b5bb6dd910492a843fb25627151dba4cf581b81882466450701f05f6071f9c586297d595f820d8af2a3d547e19b7b392b84cc28d9b5f04fa475cd008326beb70f8b456a33665c02aa1060e832431e9b8d879d67706608d7cd322f8d39f75a9dce055e2d1a929f1f2bd06b59708754ed7574d1f0b8b62a5a7394653fe045feb609010f753b19f77f798c6aed1f0f00984574c91de3d6aac93afaa84d6e2e90ccc5933beca1fa2f8ad5eb5ce710b619bb197857000493e9f0a863c26bdc73ec78274f829e02845bb2a5c145adb85076042a9e70bb763304f8101337b5834a21bc712021e8c395e1f473115c1fd11fc4458a8768b3bb6e12d0361ef97f1ea971b589fff405171f0867058f98c297f8b26b1aa942ef75ce32784e60238037af0a1e0d776113e93fec1fa2d0b163d93b35342e9dc0420570574757a2c65e7fb5aea5a3a51351e8011ce1a66ffd4c903227aa055f1ea24d8d7d91fce9826aae397028c5e6ed4f7ff951b204372d333738970996c3b56270ab2fea01d72ab1d6622e4e86becc104e40c5b801a57952645e8a2c794450ab2d1f518acbbba1309dea96387ca43e5f880d3f9bde3fbba100e067a2a1b8cda72980c22cc7dc875549baabf7c9d9a334f14d0203e03b9c709c16d6fc0ccaec3850fa7bb8e43427beb7587d1519f6fc8b11ad6839e1b0b46473f5080ff9902ef2487598061a2774e7c5b20cf5c378dc7b515c846940cb41578a8030c122fa2bfcc652986f1e2e1e34db3e7aefa3c4f214d81bd1fdedc5406ecaaa0d80c212055797888ce15b8ec3915ad5bdeae2144b335a70891adcfff4cddd894ff4712225d38fefd0b623114806e4b2e7c38da144482fc4a59384b868f3d0673527f5e7f649ec458799fe3a12819b851f382a86e2fe3c5ce8a944ec2c62099fe68de1efbc04d6a78c53dc48419cd2f7e65c4b20055ee9ae72d56f660a82324c2fac06aee697c43c349058f8d517d04effd6ee4576466087ba3374ec30a5d2877c5ebb74106b73212d11e33812c79057b893f15f3c29b8ec12a4f6e751dab6d37f85e30107a384c178be2762f45a13f94e27577e925a602a1a147b9f6edb3845aac92e613b66386a2b4ecbbd5698bb19db8936a5f87065be78176029cf4d285a5790418e1f306e031fc9ccf6ac6dc0542a818b5a2fc5ac079842235e21a2448655559bff50d7d4c51bc6d87b72acb92fad6ece562ee31fcd0b33c301d1a5e1ed64a4eab3f9fce0e05b1f4db0818b2bdc538b4342bb91ccdbe59c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
