<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7af5d5276e53104df4aa2de6f53463e00935f519f7e82b20c6ae762b838fef390abc321f961ec78cd97057f5350cb9e2c6cda665426cc890ff1a163c46e0a48a570edc8a5193bfcd612a9a5de5f36f59c15671a2cfb32a2ca723415feb472397623d68b26b34ea4e940e63ad377829553abd4105dd7ba80efcd8cfcf680f5f977d2b2a653287100aacab99fb01b23d928986dd1227b858acc204318017e53e86336d7e7bc433df816ca0003516f32ac01d975fc7d19b9cd379bbe1e8a8a520ea5e9bea9dd5625dc89b111891768165e5d95ea0a345f39c95c1f64453d1fc915b09c2ea3e836ab83186adad92b76efb045ca094d3986cc60fea8448a0934de9e7115738a2907e9bb984193b74c0f0aac7bd5f76fccabac707c1a91470a07b2dc3a6254d134fbdd843d02c250aa14b54fe5c34b7a6b5a4177319b14f709d6b09b82cc11aca4af379ac7c77022aa32bc427fc7dda30c9678d68aaff07d40fb5e938ea56af2fa713e34df67cdf8711e55e9a05c75776fcff8cf0976fbcb6f938b62e62a964f96221b88344ad6b9ecfa92beba32d1a8b836904b0faa58bc31ab66f0cbf0130ed06c69735941a75f7fffb5ae90c675baba6bec107505c8911c958096069af52b296daf2654aebabcc9d8b3102af8bf116199c709aeed17544020a9266ed5f5e4143f54d2a86e4f3920b80623275e09ddf9a7ee7a08d6e3506814aa91ab3dba41698021004ec34cc98e4d5c417f7a97fb5c76385f811c4a7f00ebd137080057a03bbaa223dbb3c665c7cf6b2b7cd74221ea84bc5a512ccc84c71775aea9a78e4aac5a95a17c9998b8a38dd4646189de3401493b6a049f90d14289946b0bce01ea05d051f86678d0b571b0837c7b655dd1c242aa257d71a9f62660828b76300ceb7bd2db5ba9e94c072ad55d39216c75c44a9bf7db945d4e589b31c29b595f84c909c6e24724b37e816e88225497b0387b9134b827a83c46f28691d7c71d7566f64fecd42696cc26554b1b12f209ed7fe6b0e917b34058b38a110df37fde2bbbc6ea9d0ccba0b76ee6fb0efa96caec443932388128d2d862d87bf555a0917012f82ee85582ddc5e816fd1f97a39e2a6293fedd997d100ea239280f94e4382d9463aff47ee1c9145052815cadb5827cb4b320ccfe5613fa0eb4190c079fba2342ef6146a9e6cbfd5004db82f53380bc5b23ba7b041e7d978005566134f1cbefae8849d363fec3d4d78ed0354355f097d535ac475cfb29f40368e1ef667853f84403e8a53c57a90990e15885b40ef8245ee7a0b4f00b64f7f19beacf9733e1fc3287782dd7c7b19db46d99ba480c0f4cd4f0d56c63f29a423a2d2b757ce1a0e868919473f18be19046a1d3b6a34bc36feda0b3502130cc60875260b2551b8f38d9883bb396635aa754f8948d0aaeebfc29bd0caef3b1d81b74c6039776da9fa88b88e445ee7fb54f629cbc674793f3cb4165841ddf0940de8fcf7b52fc679fa0fd9f55655d777d66e213d401af66b698349b8a68222161bc90807517cbc87562e98382758e484349736dbfe7676fc78a81cd1ab62f7fcbcfd8e7301c832f84ad937d0f2df3c8723a9f3866ea243d5ea0a3b27a4ea0dbead66b6ba6959044d030b5a98999267037c56299f349d166a61fda334366733184c425d56dd0ca7d03642e78bf50d1d4e924c6d97d90772692567c64e9d32e7d0582a1e0e9a7df4b51f6ea6b0462e9f7fc20dd10a798296c7fb592cf78d55bf01eef360f43d71dbbca0e955d9ca71c2382f15d130b14193952eff9a56ee01f50eac6b4c9a38c19dca46849eb721853a36a1358dfdaf217955e03d57a19ba354e66617525b42b93fe965cbe1f2e41cf83c9b938bdfca1617406003c43564d4964f9c2e49f3e7d5d9ae7c07d2c08814ef438c9040a2a957d352aed4b7258e7dd232bb0841dffa2f69385f4a35508b6f6d748313e99a812b99136d98db89e4c9a26a333386ee514d2b9ee91fee08fad60033829ddd85e2a6837cfe293d5f2509d8010d6d753a3748977383083bb3f40dded333d6c402ce09d0a3ce0dad08c362407c46ba2f2a2f683bbdeab6e0c738cd802d08a7b51b26e68b0d5890cf5c4232f39c72a697afaa4cb1126eca3907b017098202855b196b868f0f2624d8e7bb714bcdab3571b6584b9e186a576ab0595ae34b555ff0f02beb1b8b430aada736a62acac1c9fc56b65bb7580f7bb4dcdc2d08180dccdabc5cbb1d84274cd42f02696257a0fd1c2c01cbe9b56e21bf5a740c997e696a1430dbc275afc737bd1869f391b9c9f0bdacf0ac8953106c1d8a5b7a54c237e57e20a0ba874d404019c115e121d92df679d2b93b43ee8418d5e68d1b4a9922f252333c468762b7de757edf4b481b88f5e9e10b858c562c4b7a579d9c035513ec2bf6864e10c6e713c071eba8f2793664e2d6313dd0c48d09fbe178a345160c0eaa63d5aed926c621abb6c3a524c345528e02d48179d945f7b17191ce9a9dd17e003ba827a006f1931944f64454087b021bcbb4b5dcce407ec9a8361106eb1a4618caf4241fe8ccf7c1010ca08dbeec882bf7eaa49a0dcb062fad4351a5dd0d907e3291c7893b24951e6b19d298ca3abbcca3a90684388f7eec62d6f4da1becbc4761bfa2ccca168187914b8feddb5bde1f442cc4deca556ca0108ea7af954f758dd31a1a84d90a9d26dc1b5e742efbe8c1ff6f060665953683a9d2745b03187c4f1443208c45b34890a93cb79b985e77c49e90f46a2e71227a1cf81b98a9d4c998793c73230dbb6e51f980bbb8f7f138bdb01bfe53817f4e271ab07507b1b0e430270a633efc9e92e5e419b24a0e7b3eab13fea2e59db135fc8717f680e1ae4a25a35d9317744ab70873b5bbd0c662f462c03a65a889394ce540fc5999680c516545428cbd5a5f33b3d89998557c93963bce7e71d4f28f3f966468b41c858af14b62acba54626400eb1877796d7aa41b4f2a3be07093047232584a9c94a7bbd80107d2e38b5ba336f542c9944fe70cb20fe12d9680d5e1c352c2ed0c2895035cca27ea8dd169bd7a285e1795b733f5673d5fbce31e082e33d3c90644c2c034170f511805f6d1ca496c57da6955b4c7e924a7570adce95c9bb249d7f2f8d97683c2cd2c60eac5251ea168f0449ec2e86c994bc0f32a5ec2f70cc031d208743a61083740cfd9426a4a73198106cbe2c07d2ddb7894f9382233d675c3de1edc9f3d071162b39d9176eec2f4bf44e8939adf80a12bd90798d9f23bee56cca963d826958d41a404cf5ae6e73ee30788ee1c2e3e4e60426b2c7cb74780f864188f08715341780b2a14e8351980d9f635fe070b749bfe46351659409ecb8c5b93499200e77f94bf6823fca23ddb99f34d686615c9755d77cdbd9995c37d919689b074682522697a4c2e3c799d83c10a890b64339f2cdcd4b06b72b77ee5d5ebe8427f58be5e1e8b3b9a987c3283baa9a8f6613ecdf7856e6bbb0ade184d933eb26e87f59f58be40bc306b587fc753334c483c279921dd40bb14e83c5b4fbb327e20736c1cc6870589637e9e3f1fe02ee426d193cad8873c84347fd64ed9c7c5702f9f16a5a7f3b04ca290bf0145a7b32955af021a1dcbe28fd4bef6a62717f38a6af58e3e722cde2167cc92b56020ece9e5310f0dc36c4bd93cb048ef4c9b4fb5bd3842cd2d1e25c82d61752afbce34672917631c9bbe34aa21b28dd96d3ecbd2c9bd86977c3a6ae56f31aa54eb3cee45ea7d43a013363b0869c6e0bfdbaf218dce30ba8018802f2f82ad2d1fa5eb40bbfa01474ea21c15647592322e2a3a01e52cf9fad63c1da4b79c8231df9eb8b35a6d0eceb862139547775141e62496532a2f2b9edda135a23d950bec8afba334e1c8181d99550073cab7d319a0d5426dd6aa9889762b6638b86906cdf9a0268547e678da2ed1b41358ccfbc891bc99ae5665fdc090e87310d1ac5211a096a06b687d3b892c11533b36e862cb6c8c21521e57e2258ffee4c3ce50b7fd6d0710613bb24c22853c0063770b846dd7bc07e3aaefc976213082c9c1d0bc39ce231744785fc2325b54ab85bd0d891daa7b644d3d7109df0d8174fa154b4a89f270ec9ed772def21ef161d6e363eeef47b3a52fba4e1c76ce0a41dec9e4b912af97568719820dccde97c481597a8a9de901cfd99b577d6b640b8c4cabac8c27bcb40c11ecd9745b63443a249c48cc1e096b6ed364a77a0e29286cee17c3d08c9634c8e69bb7b171bb0f97708b77a7eec6c2dc167126305d4d9a24a9de6e77444ee22fd09303d2886eb8ce1d78839954fe206cdc3c59a5ada0906a8c078875604de0e27c923ccd6171eb47d95e197d4bc222612d4d88cfa3c35bf16e4008056c1580bb478690ba333cb33871c1454856566178dbb3febbcfbafa3e0e29c9cd13352139fbb0576c8105779668b037198848baa9613e3899987c9dddaf5e9745e5ba0306a9b76d108e097b44ab9aa1dfef6d371f8b74e948d05b3e83ad552d583722067788586fe3c060a01363891da44b81483700dfd102da66aba45cb445b785f9ccfb25d5a0889037aeedbeb02627977119b2fa4a65f4c98c2d7fcb51b447a10a2be869193419f055d4521f9111c810bae7cc8da55e0111411068297cd50ef2652d32ea57f5295ca162d6ce507ae886a29e2d36ce54b7b771c2c5744a2e0209164f24fa920bb5962e035432d396c3d71a2f50a0b3cf495ca0f45f2384873c8aafcabef4bc8bff8250f5b9e60279fc3382cab5cd22cba4b5f7d519ad3459586fd617959f32dd078adf99ef2f4d86e04e3613201fe8f70c96c8c6e9c819351cc5a471b6bf674c180ef84c88dac03e2682622cf04ab41d4811386422a90e0e9df5ef1002ed104bbabbafe9bcffab6bd2377ff5b7e809c6662a2828f64d275bef133ce667bad92a1bbd46a51237439e6c068ee8cf38a90eeb3c51fcf65963a8c49d0369fe3761c02609324ef95ff88d327d14c528f69dfb53c181f13880b9b6a9a6e6955c8219999f08c321cdf23e73203c69c9b538e40a668cb5da893d6445c12a31a4ea1663ac2c2ecf540f9a33ed4ee45b12e30431658d37f9b4c47404a3ca7c1a4f48b6a595c6f5a8bc49660089decc31cb20cc235677fdcd9e0ab9511fc36107268bc0649c62efdb374624ffee723fa082b385e61f3b215077f1be9e8fec18bc01deda252f0ca780f668a453f2e5e0b9e33a1f7452064875d4de36dcbb5bbfb44e3ab37fba0a1cacd6714be2bb93b5689d0cbb1bed9a9ce3acd41d0059ab8576f2718c6de416f311fb5c2aa9770feb27d8c76a1201a9b83a541a082bb87c7b888c4ebb986c5b31c7705f07987e7bc7dc58f84b6f9f8ce9e72c7742e18e0222d56be8c4164028fe19366d3cad2499c9d4504d9ce006c1f403734ffa4153964e092f5e23c7a7dbd4432d13b7b98f57ef054c59a1ac81a5ce5bf65520ca2b086fa3f1a60ebe720f1722d54a1588fbcce90c0f7a2d171e2c75ac17fbc56b954bfc324fb6d5d240f20547d7ffd308935fe8acfc1f217b5857a6e2ed212650f82310361fae8c0d60b7dea500fe66c0690135cbfae6d47d0c382f49c3687bc7abc6f1a2fd05a211639de33bcac0735382f5e338a12c013c27e35f3ec8ec7d922542eba800652119eca1a58f7300727df39d3428a39ccfd60e163ae5e81bf7cfa54723c22cd0b4b7db5ea3fbe2632622cb983f58696d2e1ee09e1fc858fc98b8cdbfce65798e293f73b3e58c6a42b66b36a4dce0508e19c828528ce541d13b54164e8dd75c11d47080d81396ab5f9894fc9e5fcdbe6ff4ec7edc16a42c85cfbce66362612b0f24424403c2baff04d6b1413baa707ce92219dfb09e19564ddf9948698c7272b305479e0730748ecfacc4bbc335bfa7e07d3a32f4a6c6c7b3cc31dc3f014698f8df7883edd38e212a62d8c106469dcb03cc6551782b1ad7f6c61e968965464987f7d9094e876f209216212458bc01474b20f03af2ba5675744796ebbe5ce6a715dcc30e561119deff3055da1d886b059b062ed2f6b46a8ea455dcfdc5a05438d41eab9af59f1f663ebc313aa06c5f3b7cf26ccc7b62e8d0c46875e66719802a8560f87bc020b2229e835838745ca4415d01ec347f53f46eaa3a80e1557585f2de1e600c4584c5699919a37d9e369c6c54d1092c12e4f887a17015315b58b5855fed37dd8039106c8c1fab05d19a8d44f1d5adfa5b1c443f0382d31524b4f9269463ed6090b9f9cf6474437e1c76445f272b80ff63036f80523f1a9d4672fa59a0a86e700e2c4a4a71ea38e6fa2e10fae21733799e41306d594d59fb59aa5789f40ca81914f0ec5a6154a73078c34d5ac6038799078c9c16b5dcbca0e4f002a9a3892f9cff8d0afe0523063883c6419326edf4047cb2d4073f130a32de7b2bea9b7d83372eb91b3209ee72be39b0a07103a753d4023967404188e7186fd1cffc7d39bdab8b5451b778d94113ea10f9414f9aa12ab7698b1cb4dff524cda3b549de9bafa75eb158d413f3b863f79e501aa9b32a6b66fc58e35a7cf624834184c22f511a5cb44b80929accec5809eb845b88a6a301e31b77b820668c11113cb1799e1f0a6e2b66cd61172e6de4a37b8fd38f67dde464e955a90c459609d32150731151cd9361841f93431da7d076df463d36d437767f53f8397d18da9831af916a0d92d7192b47d1521b0bf8dffc112ead0afbfc68f178b46242bc6493b48ebe89c3afd59b66dba248ad342e5b150c846ad7c08967156c36de9777ea9467f278eb7b9843f283d69247287a562d5f0f93ed618d2adad187ffee7c71be0085872b9a570884492a3e75deabcd0a876e376fe6394c1f8d31e7d38b3c1ce2cbf686f5fbb2cdd291dac91570702a68ef3fec149ccb8a5b495529a730d939d022f9a4727f1da88691c0753e22e5341bd8b1d96daed81e54919e9195008709e26b380bf3d680e1b30902e989773e3377b8f7bce0595725ab109d5498f695202dc1eaad3c540daab3abeb7e4025a7062cbab88f3c49acaaa3153a6d3b17b7f5b78713620bb7cbc4047954860d3f92748a2886b8ec305936a6b4c65ae33fc34540e542e3d4e834cced7332bbf9de37ababd1e3246acca3771975c790ffb5c85ede683f6991a4ce03ee99e66f42b8e40a3f94098b0fe53add91b51dbe01764506491a417ecb8ecd1502d4671b581b2f0a7263e1fe56381856f9ce557fa4760afbb781b64f6c2349a98dc07cec3570f39b6db90f567d49c3a985d33f294fb1b898697e0c0ae55fbf5770f06d14d55830943ddaee11dc6293851307c14d0c41de68ebbdebc1c23424a521e082d934173abc807f3c76cf7e37edb5c36f4a060d810076dc686b2706255a949b40924a8ea22bd00eb5a731ae30d31f20e4617d68f62ad53afa5af271c1675f4de697cfb718a11a60f673ce703518a51452222d3c885f69e6a4a4eb7eb96393bef35e5dd07f11647c34fddb9dadc221abcebfa9fbbdc03a17963d3e88a06af7c8a3e0bdeda1a63425473b0cf2575f81b96a5ca39c2d80ac92090275c54aba340f84e38e1f395844ae57103b8a06c55c968ce306cd2197db330e430bdbfbde5339a0f07dcb5ee4a21d4ac3c41ed8a305608ed336b482bace3e901e852a8ba1c826e413c90b521f2d62bed403073a75344d48f3b5d3bedd13a1e1db02623f84c144366e6eff9b6a2aeeae434eb9ffafed668a44812fb25325e41c9201029209604b345c127e7a32a0c6daba7d1e2b0daebf515d1aa67390cb58136a46381688b82bc63af9e857c9d5cf853b8d337a902dbab33501edc2964ccde4d3d2d685b2e1b58971cdf94107c529312ebabfce0d08a740d9a0e41c431027afb9bb58377eeace11bc529e091454405e7520a09e75428dec86b21f684649d52a3f7cccae654ae6ded6c2d35299d5ec51fa853fd294f6bd6b23598337cf2ecea010e97f624f28ce1b5307b14854be3c4dd1f05cf64bafc12654c0495c1a82f1d891614dcd817325eb0804f12384b86bcc9b535b63f7a508482e08da37893215a669a9fd0a36dd3182bc49af00c8549074327facf3ea98f46667fb990e67804c3b93413b51390761634473fc101867d87d3dc30be3e4fa5886a389fada2abd30017f86b09eb1357d00af231895387567728c6df3ac2a261431f1f255bcf12fccd6b2742e0fa8d37c9f45da3e950e16ac76a10ff9cd8ab411f6c3c749bff356a121cbc708476191f8a989fec497b93d06f65d0f71926518aad15a1d5da49302fc67e43b7a7875dbb61b5a58d2148cc65ae811d1ce0096e2285c9e0e31583c2d2a9b4888e15a45af4d34d2120b3f903be416100e2f5a49f59c0a31fbbea80439665d191c50ad9cf54208dd25dadc3b8d7fa083b8369100a3d96854bea224d16957f9791dcfd0aa2ec257f1f494314822a947f5865543b21c7651b7318160b0ce88032efcd7475927c6cdd9a485dbf8d2c4a07a641a24b16977f5f48818901c4d159ef9e1365aa8f4461c62201f09d3160abe5987bf81dac2818386b09d4517bed1902ebe81d03005ac7028f72bd89b7af627b17962e8373e4c4ef0716e966db150521db059abc341020f4321ef5a00feee8203582d20ac2b525b2b010dc7ccccae106748e736c3c211c5faeb6476cac56f55b6f45efad6df8bd0e5d9a8d1c91b149e65e2f17ef9dd3f72599fd5c88623642af0868eb9226fe8ca1899903be69e6e7c3b067893574b02f41ec07feea90ab82ad32fe6e8ad170734f7b0cc02b0ee4a7a31014bd10a7bb16d211b16bb123e45e726b090c48efc0251f1439a32ecda9750f43c7f8d93bf2cd30664de6d3a94bda479bb25dd89ca93f25498a19251d14572fdce1b6467d16c151ddc445f639344bf03234640c31e8b63a07c1c81f8f7033701071a506db3a232b1dda1b7682ec1a8aabb1f770ea8cbe7e65ad619561a6d117c30a57c64e20cf5816a4f47a6f3cd98e3c3b984efd2b96bd5c5e86cc14429316698fb794700c9cf8ded7be57ee1f421f5270b4c7a5fe47a448ba7225aa1df9860aeefcac290e1594a8e765278578785f9435c2f925416eb999f2f3e73e57b81213998ad50b894064b42fe7fc443be715a8e88d7eb6a884de3faf3a112a7b617cd04532a34cec0d13ba051a28cc79d4c59153bcdfa89955f20082f0b6d4769fd2526078acb13901dfdd40fb3e2d3a0ad176c1631acebb787605f3bea971c4ddfff97151052fbc163fa95f72242f2ac899fc0c6a96ebd80b7af47edf9c5c6f399827d2e5d927542fb9079cfaf0b4aee696eb96ed443148463294c3c820640a49630aa5b89d076bca21ce9e60053d50a459d40ff61df8335bf0c79a0956ee5288347b22a3563c09d38a108836921db82b4075097d59e9fd080b28b6b7c2a1da7c9c0efb4f10cc714ad3b9a6b018e5f47593bf4a2c92cebd4719c55a48c8d65ff63eb39f55104c5411f8b39ce953cb97f7ba97481107e43eae04f7d8f454fd5100f23fbd6b69379ccb5458ee240095bf49665c34d0364fed28665feaf352026d703a669aa0fbff6fdfea0ab23406f18b3f30349e56405135b02c159a34c66938df921f603fa5ca981cb294ce3a5444f79deba1dd45202a311fcca6ee6990cd07d379e03b027f376052ebc8edb44ccdcb94d961eb23fd3a2940709e641e9037992ee82937ac3f6d1f6c939c3d941e6335b05b516a079d921d682192023a0b10b983abcc58a172a08a4436d388e3b2e22cd02c023a6e9a64cc1fda6b9151f109c1f7af499847a753e68505cf3f6f9775e75df252da0c504431460a8c9e5c757d3dfdca6b927168e7b4e205097595a75ebc9f3b9f2085e6fc97d140227ba142a849344ccef778cdcc0bb425eb24121b1a50635f6a48d30cc269c1343c3088cce6d4c4ef832d6c7073e387bebb2dc64b01ce04592e9ed5239290d65dacb8a489a703abdf1d0a2308a92b62cd1fac7c077721db56c3a791f720fea54f83657c568b90dcf2f3b82b55a4f6c7a55912094848d0458c3f7577b8594e15fb7602042904a84bed933b84609312c1e4508c3778a7a245a3fa3c38d8e859cdec8da1c4507c7220eed2cffeba3c6c8fc9f1a3f99beaf4156f742a0ca1ea4ebf0b980fac8e2e362808a00d44f842d2a1004799911f22bcfd5e197c689a7f93051628370bd3c61f523e97a6602c85e19bb3c73e552a83221450f8df00c71cf6995a95347f12f27c6329aecd058c6f3ccdb8911f63ac4d1d67215e41905869623280d47bb6ea72f05a2865c907aca86734bbab3f04b478ea04c129c9d2d066a4fca01becad996fa8b9d5ea1d5a802ce4c93e71f40e2c510d0601e7168d358f3794bb86b202d1211fa54041e483a6eb8c3582b06d1370219d30972aaefe98804c2244c33ba1835b62c4e8920011545624019b4e601bce0af0e397363f3b9377c81a47df8d7c298838eedb7d7ee6965acbe17da76262d4e2913a7374c6bb7dde59c447d760e23e7023fb90de61530734885e5879bcb373decb660e4dc67d0874904e90101865585b10c412b6ab595fb4b35e0aac3c65e2cf82b30a74bd12bb875a4e081bc59aebb442548108a432ceec40fcbd7f762323db966d95df825f121b7d0abdb3db81dc9697b2982528772e295562e6e443aeb601665654809c8335f07f9f0cc0cec97f658b529bfdca6366cfb3829b28f6ed13c407b1c9d898a3b7f4efdb6ce1e17ae1a5d6c6592bb9c30450e6211e03637463343d6d1e0b71d155848693859065f4553b14ce200bf9765b51be6efabbb4c3ec6d56d1b86a1c817f4c1adb13e0a8042d28335b7780766c48aaf26d5abdf91d8351907098de6c9935f9743cfb7a4e0321ece69b5e1589cfa37fed18580fceb12e523dc4562779e6566cf8e401f3521afb583fa132f83f248ad9e538c8e1ba6fcaab80661864303f90cd3f90bdb2fa8869bbb775c370311ddfa4c492da027c1fc5ddd65c523e6e383e028d53f865d5f42a6e0de947de063e3a5a02e1ca9df11d1cf72e93c6cb5bde33e3d8803f61f2ab8634483da683b9d0a7288bd918215f58562b62fcbfd66329807ac50bf278473e6cad33916b3023e22138ac1526833ed309a25579e686c8f87a6661c09de3a95f08746af43ecf4020e9657278e678048d05a5c3ca2d5bbb7dc029dc032013f6d5de4f126bc7e66130f468be061995362962d85271b151f1f72ee21b349e93b52786ac95c46de0f09fbf5e38ebbf032528c8b01424d4bbb2a844e8177382518d179cec3e5f99c9f1cd3a637a788c4483f0305ae1deeeed1fcbc32cb67152fef1f8ba2c9313be9c34879ef02ef35bf3e11043392bcf44ab0d85edda95ab91a040a51c51d155f585fb67815274263e0c1d650054020aff260611eed9120108c3c24d998d471758e9b22fb7d9af0459af3dd0906fe5df1409024206bc7837092021cf33d86e254860ae10516111f309aa82fd2e612fc6fd476d76f935ac5cd98d3f4b9776df17ca3304f16b85434b972d23d04cca2205fcad00e300167f6e696c6e33165c15369b4d6b37222ccdaa54b586ff167d5c3d0560cf9bdcc73166c5f96bc64bcb882f1c8b7cad0aed4a467ab6af53cf549dd95c32c0355d1ec5c78d9d0a32dfa09de1f8d235a8294f3b7693442089634a5b8dd12f1a390d4b935779a3825b42725265fb911b234980034c4dd5ad6c11d7c0bca7cd8a1601511f67af80066f4d9b15ddc10aa93d8e90d27248faa4f9703032624cffc02060878a3aed05d226af0c6318d7e91f9dadbb41664f602fe7cf9fd43310d99823e6786dd109fede381a61d3881eae2f9639ad255906a30192f3de7a607032a17969f5a3de35fc199d5fc3b4660729fa424f82afdb37c965a47b08e34da353bd9a82138da0cd9ab254963f2a98140a556f35cb599c0c57e077abc08bd935c7b4ef248bde2ffcf1dca5e12769397978369bc0cc3b57a57494a64dca13f63fc07b6c1dc7701221e6ed3c13500c873883ba4ee6f8ed7f056362f0e041d7e71e18992657bed02d4ec34fa581f37576b33b79b6fedc72c1fa5e4c8813bf0957a26c4f605e93824cc9b69a54a1fd4d403d97cddea0158ca7477797eade582c8abac2fa54663e8aecdfcc226ba194459605679d4611b19b0178d4c8fcd018df29b732536f25a70e671da2e576f7c999d73b1f1a86072e9ca1820604b47cd74849b3c236600b6aad5aab1cf85f7a0ef30519a6a6ed2c73428c4347d473927a69f158a9d6f5b965230b646b53d716fd9e0d0fa8f8b7212b3c95edb59170e5ec3412cc77c7eaef39c0161bd39bc476dfde8ce6fab506ef2c17f722bb6e8fc978d19e080b53c8f529eb6dd7c4fa2398183d0151a6290274aaa65fa1c1c4bd71a7610043c10c75db65ff2a776184afdc803049892c5a2bab7134f67ddf4576d3602432adcc894c77fa81f66bc5b95ccaa91cc83ec9222ba12d4fea69eb55ba98c3e2df574e2a63fb5c25e1ac49b7dfad26d087da6f1255078cc03c6e85b2ebfa8a48de4349eb064ffb88dd4e90a7ec1869603a738a1eaa20a4e090220baa5e2f91125735d8fb271931edfe4eca1ab8b7faa44811ae54824cb02974b6fa5eb6cb422c965fa36312dc4b40adb595092bbdfb914783ec309e3dc25e5d6223cc0520ef8953cea6749bf5f29965580dc3f17d6a9d9321b8a2b37c5cf064e3af17ab466d8e6e06594baf6f7619baa7448d8802c8ff5378848f2551e1b5c13bb142e70895c91a6d2a2f6f6966feca3d36bcccbd3a10139be02786a375890e98172ff832ce48526cbf8729f749f4327522f3b9d0a3e210fb10ff3e601ed46a961788348dbdb949082f9020f19750b4b27954b9dd63db194d63fb40d224bcfcfb478afee79d8d221b078c5749b80e7a26f664664d7b12c51774355e00f2ab1625578f7a18b0c69022cf4bd7a472921c0702668ee7d9013dc49399ec666d3a877f8f450cee5da5158c5c5eb3007f74ae3ebae23e8930376e4ae367b5fdb55b5d8639c160d7990ccb3916d4f62339458c00b060059f2c2b84bd416ea89aa1b2407007f0cfdeb3d3ac6a8285b23bacef79a442c980574b7751f7fcb78140883567ba8a5371737515e6daa54da94f2b3f64d723e783a04b6f8038815771ca3c19f0f17426c62212b2fb93a7baf67aab1733f3e812c5ea3b2d369f354a59fd67ac3dd7516e71b4784f583a2aec562b73fd880e7c3cda2e2a20dea3e991bffdcd41505bd5d83ca3e0105c8337499d93c6d72604f2372f664adc40af55cd719009479ef3adbec7a51e00bbe9a7b3d82c51eeb68b13379a8aade78979c8fcb78ef5e1594161bd1a1b84966e8258e287794dd9a455e2d6b92014a02a52e412c75e7f825a22630ce38f61ffff7d7687907235f1893b3ec6528f066fe7266e2f48f95885242193cb6aeed39d209dcdd2b1c92778aaa7a0eaa9da6a6dfc9c8c4503b8432c6bde2de9e3b3b9cff4b04ec4ba97b4a52fef57058176c7581d459fbcfa88d2fe1c3c18b0773b8c72e4b6f3a8586350f55ebc949c41de6d7b8165b3126cb411abae66044550d9d33640f19ecc74dfa7cc8453f2c6e7c1ce6ab14114a5d750aa795453cb95b63a880eb95e9c74da4612f491fc9c8881f2e84cc1fb87435a3e609b19c6b80949f4cb9c19c35d800912b6226988a15ad5025f1c17fbb79acf3617818db6c1177515b26d265d001f84d0c74e156283392b872ff5c68f801a6d76c286a39db5cbb6733324743a1161e07881e12cf13adf256d53c6b8f789b0b67202e5222a5c4f0aac3efd5896b04ada51fa56f4bdcb3247d348b7c7164afd9b981e88dadf199451b95fb1b1cbef185c723c8a72dc4e199489d2b92aff9f0b79d28e7cfa6fadecd2df6b6a2f7b698e856d42ec9245760579ff9b6fdd58ded0b9b721fe11a1a0a698c07938abb4694e0b46bd692a47cd5dacd53c0633cfb02e705d37e07f908e0a175a8e03635c28984e7f20fb2438eaa3ef6a76b4b33e435256f5656e64df257a3023ea10f7d5b679e9a8930e50ad9e65d4f98d84998b35c78bac39ff1d766680b7ee75ce1cfaa7ed0d956656c9374a3eb99548bbd3ad3dd5234e33909bd994e5c59f7d59756ab7e6f7559c98a0427329a1134ccacabd6b3e792c1e85ce6bbe6df7d91932f8d1f2dd50535e65822737cbda9725ca9a0b0fa2e62508d7c5478698f72a7bae5363f81b74e73e38aa216a2054eb05d96523d53615dfab77a95955704ba303e1d246fba19266cfbec060e15622c043d228681acf2afbf2080c9aa05bad9fb509cd24cffcb1907a777cbd7637f20ab091235420697b9005fee0cebe7c8d52ae240d45b9e1ece7b65ecf12f7d1f2e144633d6821028a9c9b226d857d03b37599b4bf39c6ab1b793d5c71e5e33948cf3dd494a631bc280400749c6ed45f0bdc6a8923a33399f2e3e728cdb112dc70ab0fafc4872e57f1ff0f78f66c299b7921d6488e58cdbec459d0351389b8eee94819387ad58b0a96aa8e93bceb98ee3db4c818682f5501ee074b27ba8d6ffd96402b2f437ae3904f8c72bea8de3b4846d92d9331348a2332728acda6b7dc42412724d9107fef40ccb491155e230ca01863fa2cb0f97d121a3b1d2ffd7c85a060437667b6c39fbdaa559995301b3dad79286a6c5bf29c30736bcd8d226a05038f5d4cdf6c8f831b8a3f1ace6e3431af2212d20960dad418eb3097b34422297f73750ebf061194f44781e5dbbed46687829b3ec9b5d9f60033b0232e7d80471c3a73aa2d7e8d5c13e264a1aac18c694c4fa41aac3fba673f7a669c3b7af2484bb3966fc7fdfe8643c9845c4c6fe098b08927e64cb697e65c304e0851328837e8c88714802e482cac1d3b8b232353e5d82939082a4e578821c292a6e0d4f16405c5e792be56d8d974bab44212fdb804d44d84aaedb4817d48ff0adf4a54415903a71e7039fd22089ac2f48cae027cb8dc1db4510bf8e348e095887e8bd68c907919cfb60928dbc5d9dcaabc0782c478e6c9dc137c6e5d6d8eaed59e86f27153efc5efb5edf6442b3e3931adabfbdc0a715deb3edf582554ca294af741195a0d75445e7314133bea4ccfb57b1a3113d37e019debbf922795762ecef2cca59d6fe59274ddbc63dc89dfa623656d4ff1c7c6f3e4151a599f697c88ce184a3e6071007e2d49671fbf164824014a0de488eb10fcde598ae58ba060e9a8f748cbeb24999fcfdeaa68d736389e6fc8282e15e482ecbaeba984bf2f9c6ebd96799ac72f9d36eafa63137941f7d0091220e8cef7a6d6d05f7c2767ed0ed485e51b8cf8e4f5d2768c5a09578cd4295ac5a8ebb1c23cfa295d6825ceb082109ba8414dfb22fe1700776af3d3b71ddf4b4c24ffa18482d415957ccfdae9100ce9ad90781b5164ef814107b3073f263e4f7a77905f3b8e4555f3e8a5a9f4c9ae5fec6dc5e491d609dbd93ce3c0114d936d1f46fe4c6e378f1a297a2caf4efd10aff576952856eedc6c374e38e14b879604c8ba801141343524a14297260635ce314608064155b8250137a1bc1f8261e280fcd02d1b031844965eccfb6486d43e5ea3a94375b5176506d7eb0e3c562227a9cc762daae0a4937b266b0cf448ec28cb8adb3b18f4277664684494e2e0ffd1d5a75a792eb8a035ca6a5e6bfe1e3c3a39afc56c18ceb4b2ff9d3583009afb45a8420384515250aa8d3d8f6f118af2431750786048db141259f7b091459b796f5ac108c0adca1c3b8c4f8370a764d37f6d78b32af97e156bc7abecb7c80bd2c4aa2e038001f70d02933e28ac529c8feab7c7d8a55d66ec52ad75c69de55fe51d02d28a7bdef6f30e513c419ecc42e19421d5f55c511cda8a408b9a6937226eb27f007c3e26e7a9abe9275865e4c5daf6fd3fc7e4e570fbc4c0edef1819437dcb64ceb13ae0e8099743bd0731c4d7be34b609d1764178267048082c93b2180b52f69feb8297350fee7dcbd2f92ce2ea6235823a7deb425cde50dfb5d1869048130c46064c080b35028b62b724722a2be299700104e4962c045f1e150a6cba6bfeaba15ba6735c4e1ec45bb356b3ad5c5bf43198d3cf04369ab9ff97fec4dc69b49530a1e0067f8aa2b0db8b261e86a855c4b5339edfd908db95e75f658fb967d6c97981ae555d3051bbf9eb83da05a447fead0bf500752f21f34e8b4718a87aeb6dcc5d47d2193f34df76a7979a162ac59e30f05eee98c7c67382cd3b195767e489c4197c424f5d6e89b480a2d50ffb9bdf0aed207cf2b52da9285be2d6393afc3d3b37015ba25e8abac750224054cc567340cad489aa2e564553a6a1c265a092d805e2e3a1420365ebb857b2445e03df1fbf263a9bac507b37be6a3834f2609c834d37162575fd9edef4e7d1ae35cd8e13d6af9fc7e2c387a99299fb1b9b1a6f825567691eb017a7d289e7547488126153b445d57e1ea4540b15cc3e0e04eb8714896d274a468c4462b06d8ea72e189000eb87cc057fd1eb64a5b54b38d2d3c314ab625f3764f3c0e511278a8ad6cd54817b2ba9086f2826fb3f85662255d9e4b907462092b7a197127e62fb8e4eaae37e36fb30a8e1e84da859c8d385dc9c5f4a4d9cd0216f8dd106205bd3be7fd45584aef88395deed2b19defa9949034a2a4f12d61311314bd5efbc4aeab7f3d83c00909ee18543b652065acce74740df823982c83771cc0b1699432d03dc210efdcbd0b32a134a05aa6597b7500473994760df9d53c26973fac6682835788d562a22dc7804d70eb6a47addcedb45081cea25920c44e3c56f0068f414fd8a351e8a3b8a11b471384c633f01733cfefbcd28a460c5596707b45f36d66030994adeabda813d55d80c340a315695c4bddde43a9a351a77e0f068ba72f54a6134bfa9aa98e6c0c649d7c92d547dc7cc04e5283650fa52cdd9543cf5c0772827a2e667573c88576c835690fe11c2bbb2b298adc1e8a2a7f1153c60f2f2f163b17c730a60245481511cae3d4c771e16502e4f40c351a89183549092ed9e8314a77cf7ce0785bb715e3662ff4a32addf73727fd26f8189a6842a45a5188fe7018c9daed5bcf4083d48d5357cd9cf2369a1cfb3f464f2167e50aa89fe9845f909960e352347ddea0dce91cf991b0644227f3904d73a3bcd96167bded083a3c5853e1fbe16946d9e5ef971eee9edeb11f4c10befa2f33158efd1de2893d037e8c4eb458348cafda3e7686b9d5f035ec88f5fb37568a6ca33f8e112862fd30957afa36ec3cb570efdf554b51ca04caaa6d6a0a9799541ae366d4269239c9d306c92e681e46df441d8a334a139505713b99f8a289941134d57ebcff1eb3c59137228214b47ab0a011c7940e481fa8e3a521aad1e3dcd00378503a8a0dafa1c6fb2411c67198eb6b9978ae64d53d1954add891141ceb3aa811c8ddb3b28638b631ef49d13c329ee7aec766b632f806fc9724efda7a67be5318c4e9ab83443356945e7a460d9dd5cb3411b93156bf205413203ee6d59dffc0eece29449e9f0d9f5bcff84f02091b62d6f58708f49aa3250f4c2b12342c1756555cba04256722ec278c305e9601a1c692c74ab4324cd558883797e44cc0e384bd005fa6c4460db30a4ed0d88ea2e6fa8bbb7fd7f89f1a6e47f1797d78ba2f1f23c0d8cd7a8b556a8b03cc3eec9ce715c8a33668585884d7c15911321ba2e4cf660775d7979d47d1ad9877cbab11620bf4491c5d52ddb30bcf095985ca5b9720dba5542ceb0d65c5275c76dc75d697e51a7250602f83433b993beac989a74d95e8fb1d41e3b83fb6c6d7a42037b9a8b962b5247e6fdb2c42c057163364210b6c7cfe3751ed4b109ca3a3bc877673973d787fd221de1edc66a0697909b8fb95e047d4171c5a5dace3e8cc2c02880e1e42b20c9c8bf2498ba199f42f5c1cb1d4add6904b226bfa97e431a982636c277c90e52e7624139400c27d3d80f3eb34100ce792cacad3cd133b4e1bdb7ef8244e7cd176b050c632b943f556a814bc343d4502da1975b27a4cd98b4354169e5e423281c3a856e510907d21a2150ce3c7498a7c46285cb83cf9d865d6f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
