<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9bf1505fd00055c0470ac0afa8655e09b7a4d30705b64e9724c19f86dc34e6a0ce95ec6ffe3510441c3ab0ad00e83242c55b13fc5f85624aec5b7127236d3210f82f9bdfb1ef0bb5de36e6fcb8927c8917175e619ab81e60e169a9966662bcfb2c937c8ec0fe019cb20eaa9eb34da61d3a78da19b46bea4e6cdbfa9e895900421b834faeded1060457939278cf05b8763c825dbf50fcddc08c6225ac7cd9b38c635f826365d4883f64f5fe0b7d3eb6e0ba6553de14a14ebf74a7a73219294803e69dc5c8de3ef2bed1de630e5faf7e3135379e99406b4ca57e34f90cb6931187b1a770a1183bb46035dd826e94fd630819ec5d4c3115f619d5892411c5a9195888d994c45dd5e52c02e57ceee1799368fa0b9dd7420410590ed0c54f7c2dd1a0c687d96d6d480df7bcf9d68eb4bc7065dcfaf99fdc9ee7b4ee6563833c9db75f2eba9fb968f80767e06aea2d6025695d67e1cd71d22ca9163618f061319815b3a251a45710ccaffb1e41ec7990607937f26faeddad4bff84edeeefae203296e1b6da801bd6cecdcf3cb9e02932253a90a55fec28957b26446ccb9a757ba93c8fbe631645702c43ea939fc27713f5b81545181fe6bc6a2a5b442377ed0fd2ef3c41f73b1c5f29927e2d03350654064b47f88313eba21128544e4069155bb3f53deee7f804b601d903582794eded57ec32b86683ccf04771f742d7683af70b3c6b7c22ffc9360241f9f42379938105e7d2454dee6de787c5cc7e696278727b4af4f135996baf9c1fd7804af080228ed39cb4674b2f26d2ee17a60daf9a35ff5d76f1570c0369e752fbede203045acc24b8a5a3653f44352c594ceedac120e52a7cbc79caad3985e056eca40d9011585d9f77899755e01d6e64b76fea705d3b0e0aa9f1fb73438bf131971254982fd14d473dd5afc47bc5b0cec5f4520976014caf16b62628674fbdb6280c89c5336310feb21ac29c8d45d643c4c997392d950da7b8a971cfff8a2f4dcc744b02400c7ef981fdcd06ff33640c0a213bbbe4218d65b93ac3b6a72adf8ecd03352182802e714b30d660d912933f3d8148da78d937bd12b6c3ccb679a0cd0b1689630c29090433fb1c7f12bb9ff193f13a04a47fe68888839a05703df7e668f69b35329f8201b47abaa033ca6749ef2427128db3159832980432826307d2defdf3a35704b2801d404373f868f590e3262e0ce707555360db8de8ea08511b6a7e680bc8a270ee5b36398a3c4675b28baa020510ae6040fbc868be848fc179aeb16c02dd74506eb0391d9d43b3113d4f91f5cd9cce232b235761280277890c1a9fe0d19dd084f72a4163b0317a698bea0fe0eaa4be0430ba8fae984548311e1aaf8c3d8313ec6f276119c1b94bb7da45d8765d6398648349e96d58ca5ea6377876290e9818537ec41180ec4344a4d92a255f684386ed55d5dd374abad34ad765ecc663d5d1e9b4de6f3a1b072d80b30d0fc9fcd828ad09dd60b6008b946426814455319ccc29db0ac264151a607595b3b79a5d19f26cfc4d48c6fc1fc0df27bdaef87bdb7ea7273b722f401a765835407dc5e4744d2bfe70bb5b404dd165471d6e67b078d41fb084965c186db13c11cc8c4ad7a6f65ec11351a8bee82e687d927fc1982f7f0b8af9149b651356ae7fca4fbebca58b55197a7b67979c670b6c6513c6b87563beebdc880ff437d9b977287f70acbaf69aca4e223f356f5e75a1731d72466a18fd12d81c089bc8e2a72f3fef03145ba7f36432457b9b3ee0ab9bafa5b918edfbd1dde3d758cf0b3908c6249a9b2269d29aa2af71f65248c604e162f1da56aafc8d50030e1cbd0a07e4a41b76b7cc7dac2f24a94eeca25d43a8d4099f8fa808e55e0e4fa42245413f4f4ac013b0ffde5fe8f2bb8cca69675025e9ffd95d2571935f21ee208b1f56befc9dcbdb451cc50b4e0cac6442fff8119abd400fd5fb386bb742bab7df6ecc752252980dd76e2069f574e7a456cdf81427934d83afd18df69433c6f72be85937b3b6e5d06ff41799da052c0754dc73978f715febb3da99aedf9992146c7f56038f4443217b495540fd41c572d4a914644a7b1130fa7688bff9af28ada2c40ecf0e54a47a7c7aa59c03ed9335b01abf85dc0312563eb984801bd41117389f72c026adf8e50e2dada7d436f0a243c8892f439a8c6602227a68110cb1c571815fdfbb090f4cfbf74c6b72599d210b5ad4f2ae595ebc7c79b60ffb3c5444343c9f08fd9e802f8fbc12fc175e46489b4fa8d3c2352455bcf45466bd0722657121a57ea43c2e618d687c9719e1b421644fd07b5d9acf5e487b40e01548341ad5b9c7bc9657cd444827196efbdcb551e9d4ffbf34211f9f8e64f9b3ee30b531c364a2ebd4f84badab09a5cf0af5a772e38d3f40542d857ee3f023bc68e58bdfcfbf08de65cb2b9a8de161e68cf4e600bd6a71ae97b867631496fdefdaf10119d614625e9722e0d026ca8977cab049b89bad74e0711b11a2d5d3ce6a5e4e30a7d5c3c0f66d50865573e254fe7d44e29f5d02196de7b09420176d997154833cf15b0c82b1f5844784091748e18f41010ff21d040b81a6386eb6f036a35158aba1039fc1626d7056392d36dabe0cc19c9e295c189dc314642e2d654e3d21d936be38e50e2830e831156771346d6541009f12e1a72e8de0fac5bebe38ca8354eaa4625110677bd0527e5bb7cacaf79074939446b501da1cec5b25fbb80621da5d2dc1fe5359cc8b4dab2195b5d9a0ddfeb06944afd16086cac94c989fcaa119bb12c6c92be2c9999d01a151291b382fc15d2dcc8dbea9447aae342b11d4c8750ce5831a791fee7f44493bf2839aeb7334a5d38f3c6eeacb482a3220574d6dfb263bc2fefab697bacecfdccd1938370fd4cb4775b74952fa059bd8e4aa95cddc5d084a8552dcf0edd40af35aefd168d6180c08e4d1ec494d9d68aebc908166d6bca0be677ff55524c01ce8162e2ca6a3c37794de170e0f2f563a342e21e6b1df4845edf45cdaa24b74e8d0dcde2a44a037bf62cadb339c92782672215e4836050172c9964f860ddb0d617dcc4cfd650d158cac265a059b951cdbe56610e14f0ed20d5411dae8758ee698b7bea16456be30614597f53dd83a1c5d463168ccdb1f1efff4a60ad59e73207007e808da4d4185d215ab57eed9033a91b3a5e0337aa0cc256a4fab169e1e00e5daa27bf0910e49e87f81b588b19b9cd72311b7d5a3a81a8d0d8e8fba84ad8f804c8c8eff9b642488b06429fa169e8b8bb55d4ec3ee8c596ad182b24fcf3789c81a49a3bb4926fa2ef26fb1299e31c1a1b3d3ec27a5ed77f5b0c320cb3bbf6c089776718ea84484dc38c12bf0853c1c65c8487d2d84cc14020c32cbef7bee584603bf5b6b26cbfea2fde383b13dec0f0d4bd300d25348e55b36f9f2bd16b74dd5ab935f4d1237fb538edb97646a65cfd8f1e615ac4d8738cee7a597c583af9975c452ce97f6f96e8966b2acfe1a50d52ccb505bcc1178f40767ebb419b61050288261e6dcb4a8e4129f471b04b7cbee3b5511bc22243a3b2609cf4255dc2f6131a035bd307922c5315d0381d5431eb9f020927c06bfae5d3244367042109bab510ee6367ec8b7e3641e0de103b9834a5be8024a69ed566a304f023c5a6a76d81da86b9833954aa5799b6d3c13f3713c0684e60faf5ea77cf41c17fd3b809984b6696632515479be0f1defb571c6bc92f296e22cd0c90c682fa0663ae23577ed61fd34fb97f30fa19e8ca09dd1f0257fdc13be07628fabebc329034f43a1f848cc5b7d3e9a13ed6fe38f69249bb9f8b2ba2430a9089ea1d327287852651e71d287d37f4f455120080bfa2095cdc12132c084f0318db3a7c2c3c785566e86bdd801ef5b2f7b8e25358869fd9da472d926579db1f8a9aedde8c32972dd751f8bfa22f72753a6b522700c2e8cfcfd6ed39308523660247e3fd4ebd0369dd9ac9e8ca492e3e708fe640eaf4b3027bede65886fa747f765f7d389804de1a6deb3ac1be995b01604816f1cb385ba50df60146e4b2ad477dd422aa21a9e9579b40937d5799841a36cb02d8ec220104600c0e9caa378915889b1fd3f881dc1ff96dd43782236eeb94ab491b863931a83ad5e2c1c8fe4953214b31039ba8d45383fd434f1eff79efd41f8d80f317259ef38e1bd3c8acbfadcdf254388c40e2b46cad1875ff52fdb9fc1643736c3e9db1cf7f578b481be10e693e7832bb85eafe7f1972e453f8c58fb5ae979ae16519fee9153faa0328932e52884f65c988a54e90e1218b4e7dbba975189b4fa5d4405607386252ac68c393fb5746c0800708bfff38e5297cb8dbdb6a35ff3bf8db98e530b6ead0f81b9e04c50e98b362d8d6cbcdf1503097a448278b5df57cf5795f588ae91694017ec120e2568d7410659d9b3a1f4f761ab76d2957ca9cc7e8ce3b3cf676f88f259ca5e62a1ba096f72d7670daf91dd60f86368b23f3809ca50a96598cbd97ac39688575d5ee07bc98936cb78feb3b5435d59f92d14f5c0e6a573508d2ecdd5d1a0b0cc5655b205b7937216daf2ae7fdcccee5e1ff1c1838edf3ccf989f5988db22a6a1e2180456efd804065c9e71f3e7237ce38df713cd66f715ab8b420ecbb9876a1a1b42105227e39c2f039590658d3316422c225d71269011e549f7ae3f8de421431cf24a27be01c24e7e971b0c6bfa3e45053a44defdbd10bb836b00ee67e8a1c6c8495ceccde135ed41d3a0bc16f942d412fcb1a4b18c2350479b076dacc1815193590575fb1c057afd32edf3f887a7e485eb8d2b9c4fe2fc51626f7bc98b4f6d609486c203ae05eaebdc4b6dd89d953d3d6440eafcfee0cbddf2c6fabf378b9b2ad76919da1b107d34b3a101c890161dbc2ec3e394f8aabe6320d9fedcb84e41f04203d083f2727095795a038c86ef59d9ebc8564f3b73e4e5aacb6aa59311cd840661723ee78a8f70202988b0288eea98d861c9a764e4d104e4c6d9fd6d0984613b0930f9f25c3cc4bc0a86ab34a72dbb224ff9034ae395598e409d445a2cc24095927e4f9170c08c149fff1f8e79944397ef628ddc99d0de850887bd7509ab9aedf806c6cc235ab1228f21a014d69965c2d5c4f023934eb3b13f0b789c8a4d01bb933d9c66aa8c37f91d51d28829697c28072a86a838e1fcae3db76c383cdab5dfabcee82cf76d6593417072ef91acb9b610bdfbb015108361c7c52408837b878f5c4da6c2b0e36a3fc96c7aa084ac684955638f94149a631d514eb6439c294b3b5fece0bb624b89b8e151dc806727c7d8adf9649c734dca943e975a4f8c33684d574db29f052128867089bc5e5b7a540bc1e91bd43082a866c0e613fca458653ca149a3252f670cdef159159d1477b9363740687fc7c2afd5e2eb55dc8cac9c97a236cb18d7c9d1d9a3b7604e9d6e84dfdb6a9cd46bc060f6aef1f921f2f5e48ecadd728b4117d975f573e44ab93556ae4e47722fe78003e4b3dbe5a3627c0de7347d9f735dabc567ade48ed5c21975a05b89b605850c1d1cabab3f58b5fd000a106fa426d4adaf035a4afaa78d5151e726036d1177553ac46e4cd25b9dbf80a10606a7bc4e4a08c5f67c5be3298475b1c8cb23e7f8eb729b8850e8f5116cc99c626b4a56e085382c6c7c5f264c5cb6b40c71285bc4402869f40f4bd6b05f64c79861ea88850aecef59949253d7d9a1ecce346d272cb5b055e1d6eff0a6bc0ae3d25997bae8f8d02cd44b59f685560ddca41c736a0a59a8442c59fcbb311d4790fdf8f0cf01a1739f37fb0bf24f06bfaee4e00f200365bd0946d8237f3dd1e0ebddc2876975a238b2b10a0756ab7738d88dd27e1f00c81c931229595931fd9f307d724a61aa30fa337027cc77337a85813c90d9c1cac02ea906685e51f9dcbaca9aa01d69b94dd41ffb61403fe52610e616b79d2b09901c77ff2f0de6e3e5c0639dd2c8d1ec45dbba51ea46daf5c6b4a668aeeb7ff3e677750dd8fb6442364de0d611120964c74a74f141268093ee0ee2e38d4c939bc387840229c37e1a0703e67cb6391d24cb6465901e023b9fe73c62f8bc17fbd97ee977893eaa5b731b8abca33da9c2a63f8af11cf63ae73e077b40060dadd748009e7df257d790dbddbdb75a126a0b644626d2a49d27236d6766a813d322f55f7f58f4dd1200cf0ca17f5699e5dcc6f8efb4fda5399fb66733d3a64ecc455121233a484c299b81150e2c9f531cf5b66cdd4a6091a2da6f5244319ded8087fa3b350fd6066f791c0f5bce979fbf21c8598b5caab9b01120f01faa03fda24d2eff95f2a566ea1535a98a93e5d875bd563fc619c256c8cd461b123c7388afef49cbf6d888e2e1d2b6fc84e88bde59abcc6b022b39729508356e11cceeec38b88856b922b90e5affefbe13eee28bcad0ffc33222f57e235ced04e3b9441d5905bd736629092ccc62bcda01aa745c6ce419737354ad160803cfc6f6efb112b8198e5ef86f11fa839c7cf2b91251e2489a5fd90fb8a12a689549f5162413d9f73c00211584b8353ce17803da69f42687576e1fa1ed1b8dab5a03a302325e861b1cba00e588a022658af80b926465e75be2da35405f2cac8c477f3fef5f0778d13891f80d95b12ae6448d2d1e147372ddca2e144c5d87e22fbc2abc2d565c1398abebc9fb5c439636edbf788e5688b03af7138459d0857dfee44b7ec4ac0293d4a719b8a93c57c21216dd08462f1d6b5d5cf8b08edee86d13431e2ab4bf8294ed80727619ad0ce1a1f2945bb1f3753f7ce380fc758c5fd3b8c6747964b3527cbb83417bda3b84f4b12405e0c05d09467c3b9feb635649e84b2299617b93d4048ebeb547276a7329b7e18524731328a717ddf93ba26fb581fb5f71b0a23e24f3a0ede05a0228b42b2e4440d31f2bc58ba04bfc9323362bbb1be0b1ca7d1699910783dc4874c9dd0f22577de37df66d3610758347b4e92359c446fa7089d6d9076df400a61e48e56a57e7603e45105bdde379fcc8c64a92b5a4f11c5713c19c863eac9875e4bac42b78dc0aa2552ec60905b37a024bd46a91a946531da9409edcde78f99331cc732d1394a3cd22e0ba56855102ca623d556e5decf4e57d00b7d2498f10d3986aed823d8802110b701eec1d32aad6f090b9b7aacc11bd19d5b3db94ff43b6e15e4cb9deb7fa3cd18b0cf814aba23d7b657cd04b2d5b9a554344b4d5ac5451ef50877a13a58eb35b086ddbd1cc8bbdd1b3e85488425fb874700749e2dd7655138f8b89494c7fe5e31393f1b485843ea329d178aa4e9114dac264c015fb5c962c3f4146c5fd2ddeeb2e7c9e50f8c32919b3fe54c2adf39765394a6e586c0c7e980f84741a670f8e0298bc200ca117d2141d45c092ee23e56f02eb534f844cf3a4b68d64a0708de54e0098265f5e8b4875cf4529af1c633bb515e229fce295562272eb20ae19846aa2657dbcf25239b9755fa57b6271ce53c98580c71f5081993cb169cfce3ee9fe000d856e018122ac1731d254ff6c3948c511db41a49df23278a50d75570ada5ed6c2d9985d09b6dc3221afc8402d9bc86a6fc0b8b8f089f33652d0382c7a0a6fdb6e12ad8f61563f11de377a7877c261f67811054012ef1a63656154d2c9b35d39a87e21de12f91630543a7ff0ab2d55c7f597c0cb46b24f73e2e5307dd8d294c767cdc896ca21528554729dd7f2366363ae4fc49bbabab44bf681837b174d98bd8dd378ea546e89b502379e5126c8efe822e8932eb5cd1a30625f5a31fea5d77abd96a4698e5e5b8d90616d8dca7539cc38e7b2d5be6d9239303d335c6f9f799e5ab81b4a4921680c880746cdfbc0288cadfb6a776595e95f0f0f24071d6bd5f6ede7792f7e09ea029c0b278723ec6efd7ce46b078df5af5eaa85bde3283b76e1d363aeac8c07c1157ed11f53c33a468da93a5d6b20596b56f050cd363991a6e965c1a3f0e4b62194198cf34d85f937b4e3e9ecc3e3761eb7b5026eb01860519c76d8a8f4d93e8803fb81b154f502fa2a865abc242f1063f52604df4cdf95243785887bdd227f34fe25b082fb4d4ca048d12cb9d2bd4510d4892ca5c5526327b4d5fad777debb8f0473c4291e45cfeabdb06c24801ac50194e4ad97a588ba2ba7ff5a6737f389ee6e5ffc3d3a55f9f9dacc15c00c46d429dde404b8fa492bf36732a9f373813bebd7110c6f822763c83d395d4d60ff7964b327a845bb7dbc2f71c9f1db05f5d0a8009208da5a6460fe4adf8c88081789d02a52a55cf3b0927e7b4d42b8abdeb14f16ecaf5b0548f77c46e95b3130d131f74ef6a26151b35119897d24b08a8d9bde4c8947ad48a8dc6ad1e8dcbba3c71d52c0c6df55cb9f132325854f876b9fbeb5dbcf78335dff7b9576c2b8ebb4d81297f531af52837faf8dc289c96a91c062276a609bdce951416b04898526e3714a64770e79b967f9f2cb8341ed5d7dc929278b127c934936d9d517470e0f996cb95a6cbc5c5e74eb491752748a564d158118cbd5397884df4395c1eeef60bd5d2dbe325751213785dac6c12e9a0e5467e0c89fdf71fc76f03b7cf48e0851f84e5f871eda11802ec7f87b695df53d49c3ddea8dbc74c9a7ea6bd8fa47d9a9bd6e56054e7e2c43455a0faa3700cc661e11a74cd4700aa98438bf46dc33ce998f4cd13775f8599347830cd3866f44f98a93d0309b8bef9b5e11f6f482151bb8ea5307cd847d8b63c841eada11dc2020d274df9b760410b6809ebdd43a71dabc041c12cdb350f8814a6c4b4a640629ed9ff0c00b060b5aeb6c53a184889f9fca8e3ab4d537222b628bfeca7903b2a99625557dd5d9a178ad61c0f9aa446502d4d59a5b153729cadea2c7d7dddc43d87a0aff20aea8e077e595c03ac9cca3644d90ce4a231dec00580f556489e5e593b5fd62a7333e6591bebaf3f5c925241656fcad03d39009f1109d3cac8b7286f7a9494c15d11606a6dd68b8b9b6179a0fd4cff852d38f5347eac63230504d4bffc3180361e23db74e2efdeb6aa928b4ae4f46595e541b47c76e0c4f2d9615870f973a05fd6f2214d2b0d854838d6f9ab2ecbc1cd968dca2d2d610c6527f703ec567f11b66af1677aa82b5f1403df5cb6a28f1b5fe2ec13feaf25608cefb4b11abb9bb6c6357b41523a4becd4d2a7a85f1126c9afad0bd63c4fff9bbd68475d8290663aa3cdf452ff7fee285ae00668f6f614613dda4b9d2d731f2cf409724827f888005874afc750e3f6fd943b826653bb130ce6e60b7409d367a14e21164e0ecce026db38d105e1a54a64e52947ee132cc720ab8a66e4630bcf13a38f0951c37609050f41ee6d3d9d65c3c036df4165f0b8e0c5ea9e4d1b377c41001c98a96f660a4329f92da72fe3830aaaa8838f433d434d123f6cff5080404ba228f3ff3a80e39f741d77db7370bfa76819c0bbd031a9e925ae3b799459b3ee764a50dd17d4a7657ac417d66126fa0ddab2ac34c140efc2b660898a59bd9efc09aa6101f7b2bc9e9b0cfa42d8e5bef9ead640e56b6e6aacbf9951da8bf52c500457d36eb2bb4c79059f0b4626f53c9728f0b0da23d855a96ff8e110eb7c00cf5d68559de33ee5aa69a6eb16661a1dd1ab0fe3f1507f554cc8e6c0e32702825c14251f1c01679a52d9c1663f10991f0d6272ee04884000a12eebc885ff5581670cc1301084f3282f6c2be412dfbfdfc2b92741c038c8313c5a81ad4c2639c6c6ee4284683d9a99b13a2be8fa11001811a79f6b54f3dff0602e2462ec43553d3a6696d72a61abce1c28d8030259c88cc104fe10951aed8adfcd20358ae112ca3a4a4e3c9febdc7e2db6ff9bfe47355532053b8813dc86351a2bb2f282c3347957e927df07384a3aeef07bd38766fe96177efa8956eeee0664d89b969dd00691bbe15ef727898333d9feaa46d61bacc58e44f3b68c0acc08c403ca2f717726a0084a16c3a583d8f7f7129b71926ebad1e560263b74cff581a91dfff24ba9ebb5d2bb902f5307208a72b433350d83b004d97e4d45723dcd44e6dcd014575d6caa91437e0d928136cb48a75c72afe82283fc30a22f20bfab6af0482e136b07517cc021f382ef102b387df1cda78b134d87b28cc22402007aff7db934a33392d4dabad19cea1328846112937241c573dccc1d66b4bd77e166e3659003aa04fd9fc2aacbd11ac60e0b24bae7aa584c35af9829f11724d0d72a60009d99bf3286a5ae6e5e1bcede98b3c78b9c6c838bfeae07b1873ef3aec406d80bbdc2fd94f1ffda5123869a844e0aa5b53d7356e95ec3cd07173f43e22970a808421bc495dd9d03867c103dc775f69f685f5a148cfb5558be031e9d067f79533d3ffff298124e93b1f3dc2d236b2699a87ae72f62361f8e45b731929a6ff2a44912dbe7f54141430160ed7ea28e4a2ebbc9f02702aa51d6af746a2142f6dc5a8d9b9b30d365832859def0d2646e7b5af6c792dd0c6abef9fe5f846d75f2cd98f8e4b6b086159879dcfd5b033bdcf545ddfb1727bc30e11b83c0674ece3fdeccc23bdd1731482de25df9804ae08471bcafb364c2e4603a604e11f82b3bf5e085d4aa02520663f9d766a759910bdd26db2c4bd95fc615ed7d9cc89adbd77184064b425e5e9c5ada1956d5b2297d24c0438aaca35c64a314ca809196fd3e470c43d2bb5c69be84a78591e750f990095276ec9558bb2f1713443bea9c7bf349a9a72babaca3a4eda01244662bf0942f4ade61dcf88d0109516bfacfba822ed87e853497d819ed6941ce5413f98fe11a287334dce9c3af152ab5cf956648de7a1687fc4c43bc6f45cf390a55d5b33ac2e3fb3897385d56d36a63f178b340bebfc8ff2a276544bbf41fa8b25e20a4e2585f9f410c2080cf3b9a39791a70e57d8d324520d07cdbbd353da08ff68ff94207b6b34cf0f798fb68e24a547841509a385dece44741442c1750ce14beae28b872e82e01574cb0af8b89ab9a0298168180446cc794fdf49b1930a8f145ffd978c6ab087659b85616af22fe2f327cd93429fdbd31b452add7980b2c016f36872b23046ed060efbffe7f37a2cd7547f9530322471938e9f25ff8f99051f34993dcdba036d4d935fe2590766ca144768cb3a413eb0fadf8125587b8a459f1641ddb5d69427a376b5625cedb6ee8ebbf6bb939d46deb6aea3851a28cbe12a987a93409037f8125c7655c8b793205f0e3ad5bd66ee109dcbab0486eae138d4ace03ccfb49d6e1c35c69e1b319fe408de84954dc73fb744821df4ec4eeeec18a36778dd2d0b8b4408cfb9d55757a3ce5967e89d8026edea7b5babafbec2e30a412df7b01873dd3a8e98c630f9f00396208b056d7311226e653cb932fe0eb2c9710f40863360cf05d23f7c83acabc60bd2902e0c781bba1aa93a15e8f8fb70f01d74d357fcbd8f0be2f6aa7f3cd69063ce033bc8529a020fada59410e074dc38728b7e5646fd956b3d8d526147027f73d6642521cd0d9da73b6b44a3b108ff4ca25b62954b4561d1e2835fd736e95b8c10deb75f96607d96d5657f8978c49bcfea668e1c89090203b733cbc6203b01e68cccd9ae6c16f9c25afef884e9a44c000d56a444eff92304d95756d3a197aa8e68ebba829fed496b3b7435f1cfb167fdfdebd52dc8dd53d075886d55c1663881118cd9b40eeb1d259bd9ec4104f95cb3330f1339d431c40f6aaf762540fbb8d382cda330cdaaf70b7061bb580ebcf49fe27207557780e95fe0524be484d25d59d66a1848a7d8c95b080ca1f461ae170e1773874c99cc37b2a8c3196f248559d3661d83f6a42a2bc1a2db85bf42a0f8e12512cef80806beecd10cf7323335d70dda7d249e8d062606b3437d290ac0102a67100aacfbefddc2fffd71eafdbe9633fbd505070fc6cd7cf52ec2a29f8ac881fc7d3eae5406552af0a8de366493ed9af44bb42db80bec2e671e651cf78205b2903110267ae7f5ae69f884e7b3b7fbe25a23ba351b21d62c1439d42c6ab923335f61cfe2bd3bb48f718883cb8a4024fa4f2dfce17592a28d154b054a5cdc27458a33858146fdb8fa924d4a73c1b7c09e4ecefcb032d0cee219a200c90b7788090f059f74941af4d7bc2fb6016d663e05b74e27d88d73c30fbd333c4e31d5c3052ad897ac6bd1acbe1d88118f49544e8be9a44ce3cce0990fea50e9248df15433e921ff08a28f99471873339c6b331054fc586a149e41b98f641d7076fd4b088306d86ee33e6fdecfa519e4a1b8c8928752105f5fe2e1744d9368e19c3208988554e9b5f16d7d197287a616c066289eee31417fe6186ca7ae8fadbaa7f63d6a596786d725adc3e2734fad95bf9a4d51d2e26a3b1def605e1de0803fa0dac82ab187f0726d43feb0c2c12846d3bdbfbe5433fa7292dcedeca45f8cc95eb292b923c4de9da11f17a3a35714b265d8dc6580a26ea92cacd226fa4c83690e9e7fca1206606a6f09545ac23d4ef202b5f4c47358b037deeaad9d4fea82793520038c0dded88480606b47c4a6ecb6c8ed2dab51d49abdadd79e70f5c77ec0147286421c2ab167c6896febc3cb7ec56ea6d9ab405fafbf548d54611c77d3455188b78b357ca89de9d9418ecbd5f41c470989db2784a8d94796db407f0a23011ffd7a61c0b3d338f5ab5ad65d539746781b72044b0bb23a306946798accdf1c508e00cda3cdeb2f31cfaef505e5aec4bfffc67f6505a751a528049ab89f3081637cd3ede5e3d629066588e8b47fe387a04055f0dcb6b89c3242091e7f46ffae3289c07350ceb0a4ea7fbc6801a42b3cbcb7cc50753a6ff22a2930a361affbe79e326faae0786cf8c0600a3408ee8c3880b5ca4002571f681aaf9d58ce5693593df51173709e16c7294255365b456d950d6ab998f1ec2745fc0d8e11cdce5d9b57f7f894928b36bf4cd985bcac7c25a826cb0f96c77659e6039f8ab85532470a2927110946a60c4bcce4c6f18cd802694692d500af4e789b6353ab9267b4ebdb5a356eacfebe0bd97268b77ad9ae3592a999539d61619403fe9929924bdfc77180190ad8d23a637d82dbb5af71b5fbb8a945aae342df705ba28cf104aa365c06dac3c6760f62f1b1d5c31370d7ce74306051e2eee7b734dc56a8514fdbb45987898fb646217d478a7560fe111b5af6aa976c43862df8989c090464b6010aa569769c52a8d671284f0fe54e3721a6ae64954746b98eec265640a378f78eb4fff80a074d062b0404900659ccd4c5f1b564cd4aa9967a9b722dee1c5d5cdbdfe942380dc2a0ef2ef9b453ebbd94da6711f4fc680f1834ab193d8cfd7bf84e267bebfe4d36f2d48c27f2156f7818c7d31eae07c5117a2339049b9c99fcac90dad72041eff5a933a3d5647ad693240a161cff1e62fb5414dfc662b087c03013f227f1b2c5f67d5ba26597cbebc8290c1d37d73c077b4001850258590fc60ba0c758b57b0bc9099e1acd1bfc9970a2bdfa163665081e26bd23ca13d6aa70705648a6558e0140ac9abf49726b75852c78fc20907674f0e2b978a80c1d050fe051a58978b157a34d66ea7522db29d36a2553e35f285cc3f43394e7ab73290c5d0a3fc0af9dbde3cb316138ac0a270002e6a2980a26f1a2edb8bae30c5419b55a87d05131864336f7773c14309a32dc7a7e1c9bf8f82a3f33dab380db24dd96fe74a9a0c797a10f74ea6f04949a9c898139af54fe224c10414d57e95e33eff4abcdea8dad88f115421d35338eed70d0f084b1bb4d18dab8ac59af81d1256d1e7c4ba45d957c955021ac52473c95a717e464f81424ae84326ad2275628f62ffcff1db5c4d8cdc21ed008f39d273c7de0bb50e3e11f45b53c44aad2101827a54f970ad3a7d751d110f97e9a553acfa5bc95045a100577c75f3c98c2f11dfa7aa78dee92b91b22980f687aa91a558882aa7b15adcc285cf04f2252919d836fadf2c1c2d1e514e45331aa74e96ce9efb592f41a76ef5422d16411586c0d39046285a7b54a96103c421fa8f4e8ff70c54f42a4bee64d97a1069f4d9c5069176308e21305f86891324402a1ddb2ea48931b89f4421a9146772e9baffa9204a7064171c8f299dc38b0356bf5586898c1340a7a91d655983cb10493c5446d0d742818dcf4efc8d0a10712975d1c306f3d0270dbba4198d7e1dd32b95a673661e4d2f6ddc7046d377bf89bf28ed12d54670f030b233ccab2be50a722bb944791c3327a7c3b06ea8c6516c40849b92501cb71831d9a54e3db33a0881d24e969c553b08fa6e991b8995a432783bb8f76e3b39455d108a5d1a3d8231e645e4a576e2b96c428153679355b26d33ab5822ff884950865050d25ddb7a4602f25ac96ae455c0bdfe0f36b16ac1441bd0cbb107d7d20d0fdb7e8632cd3634084675775742c03f58d7dee7b0729847ab779fc995b0ee4b1e7fdeb72755c661f53384144f5fb329a053aa5dbca4f47bb7bf3da3619d6e6c5fb580eaf2a65e260f7b26bded731e21c0fe9003cd1863a6642b46f3d9e71f4f041c363bbb1873ebe70cf87da22c7548d8547274f9a23357befae0000c0ae0652dbefb4c1b6b4805bf7a8516223bc0cc0f57468c028683676816355f04db2e373f064f43a2f9d723338d9086b1b0145567e0e99e77f9705709e2bf60689759f8b7fbb08766bcf1ddb5efb674b6eeda961b80fa1294b3670453096be20f5709d32e0d6647cc993e94334b9533045545a79c78c55b1e7dfe406c6e2e3e694f111d9da5517859f03db496ce0dff69db07a943760f9efc034dea63dd2217a6c8fabbf767bec6b7e86db745cc2f498c4154949c1f5dca8d90700f1bfcd5246764b94542d447662cb3b6f0a141d5a8b1e766b52b56da5a9be0ee510e2ca5b295dd0282ca07cba3dc61f0d83431605f6f1d4409b08355651a4712ef7aaec07d26d249a68c042439b3834e90b4278b40b9b692c35ba8041b8703cf17486a41de180ec4d8eb25bc218a8b306517f7a3c799b3270780fc36b689df56577e6ba16660c459753ab517a926775d89fcfa8bcd8702819e78588b5ecf5e8cf38d5c73ec9f1ceaaa67a91085823c877c6cd16b4917b218f2331d1f7b8c5d6c8162f7f9a1011db04cabdc0255b9d1bcc11d65a02972cd89f06813f2a0a4a701880e6252dbef0a11daba01a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
