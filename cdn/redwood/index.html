<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ceb54f278de2ada10a9d03203da1991b2d46ca1f192ef4a1ead3590777d0447eb4d7de19373be5748d290be5e87eb414ed3b3a31b3e5a530f8bd79b66d82769748fae4d653b75f24fd065ba1ad99405992a4a0ca92e3cac8c749bd6d0c053ba2ae98cc4e1582ef1a6e41f45283875a6b438e4af3e6108bac9990c9852631f6ce7c8fac3f56a86043d86bdea16346fbeb873856dae3054099881fb90ea7b65239359554d46e21c6968b8fc4fc4ee1bcc745df19023e8cc6a1bdc74f26fa8fd7293f715543ba48b3a078df701242950cc233d9de7f26bd94f0584d0c3d5f1c59520d746b1494eb630ba1a45d62bc03ffd9ae150105ad5b62eb794370e177276ee51a65a07c9ded2ee21af2c683969ccbe0243ebfcf670de24cce0f8e0b78147b46ce5455304fca83a3e2363a6205c7a007164ae3899d8142df0be75e7b97c5869c45efcd8187ecc155813409f2c631eb4a922cfae0604564dbc861cd3d637ed6c540d0697bea991ec7276b37ccb48b339996420403e3096cec9ea537331faa3aaf4e72ff11425f8845cb30b24ca534412f757679a0cd0b31d39f7fc7e15cc93decf1639facae3b38f7cb0eb068799fa5b03a29011ce427277f994f468393bd091199c7aff4620b4ea38c73d976adfb5401af88d964cff4f0a7a36320568eb40a8b912784b7f77f5987edd3ee0dd24c73ade17373a87d80ddefbf9351441ff8d07c2baa6cb9bf5a6f8a0e98fd8e72b8b60b1d771360445fe37e10e4c98f9bffa254d70b4436f4d3da65c00f70d3ef1117a2274339b97576cb9de25be43188c485eb73d2cd423f1002aab4cd03db708c949a52b877a7c3ddc26c5a7f9d33443908edd67b5db1627537f755785202099ca48a91e7a832aff8aa481dbab02b6b9177fe1f6147e7963475a04c387c1958a28d253f2edd2e39f4f84df0bb06a42a2f6bfef2ff1b9936917a8ac0e19b733f7a82601edc732e6641a5e96c5221a5ce56c6068bddc4299f04983fcb4c47d3b7b9951a5b449fd0c25d061663d71af4e6e258be1e4c6f40e531bb40f2737b6db60f39713dda02ce23720f1e822c1f3deef59e070ce7708d41c7374d9743e5d8f523bf8fc7ff0ea8273ab69bc4228686939c9bd87edbc159f47b18a7d45e0ec73eaa194ffa47ad1023d1b80985d7187ffbf952f9d4a8e8c48445c019e125d3bfedcee31d40b3fe55fd320e2da9194ceaae69218788b7b9976ae4cbcba688ac37ba18d710833835028d2497ceac761ade15672d4be91b2e4048493135e3358c473bf5145b9317e73aa770cc88feda1d5143c9691e9f2b308cf3c609b23b5e80b349ad72b942fd043aaaec6a1e438eff162e02ab5dfb34a7ed2ce6f4289af08d085ad0bbf78b97d9d7d977d6b2655c00e60b000dc5b13bba8e887d9432bb41e3363fb171a9f13bec626bba43f03815ee0bbe147a5af5b0b8813c25f40411b11ec670a7bfa9fca20a1522623947eadcb31a43af8b554ff942b4fcb66f88a822e7268897d54113c12edd90cc58385f581700769c73603a2a446029c42d5ed8faf8d11d37ed32ff2eb3c333767999dad6dcda522ee76764d300cc7a7fa09d95e4020970821d16f3c371081a28e8e13950265f1ed7dcc3d61a549b201a2cd07821902b45fc358d1010ab66345a86894ddc3b5746f70816e6d839ff6a48ab8c571eb38b63cafba546c38799f6e23e231868694c786b3814d01706c106eb7cbbe11435dc73328f8f08ab88d1e758a609e5bfa7ee774d66606992979eebbb69bcb85271b34bc1180720958a770db553ea5917df15ed410b01b35b8af2a324e997f845d961f25604bebf67c689873210d5f60fad6b2deb3b5bd98a1c8e878814e9605648869e3a061618855bd0a44e0ab32f262958af6d9debe215ea1b64037c889c15563c6f9c7c87b3c9e02fdade42fa7d15098c681dfe087c45e15f4bfc41f68c4d2408ce3717524a73f7db147635acdd5b46551addab9a440c1f1b42a78dcccc84238a57e8a382b84906c470476ee507646fa6849360cf441797d40b789d49f1dc946061b7656de07cc7abf4c05eca8e120e66d4abdcfd31cc311d017d3448de32e0951cf12a060532e418c4598e57ca2308cf80504dd9761faa329566fa1a5c5efe864b00df20fd7578af84296153fd64f741000fa86051a3edaff6082fc502f642e6597e9e45f388ed55f2990d4e64ea11c86626292c98ca50fe9453c98ccf5f8620fa35612efca40e75aa02076d59d828b594a277ccf1c78b4bd6566e51a8ffab66a42aad0fab9603548cab15dedf51c7f2205245221da1fbcaa51dda1fe9a9c457d5979a4f9eff4a028436f836456b0898301c21266da91a4011da79e024e214f4b79430c9fcf6ef14812d57c05e9da56304bc8fbb3b39c2d15f9a97a8d2495a69bf509ab7e2f0249063afddb1d77473356c5d3a0e93843050b42bde749e2a6d8286580a39a07edc659ba25bf78b037c4bc160f2aaf5084b2df0e8da1d564da49bf91bc2da94b4e8bccdda88618a6a69c3b2f958919a877c9433050f53ec8f41d66bd9b23839b5da5966507dd9de71a41dad74b4b63cd9cadc6d558c439c7fceb6c7e62ab1e19acdfa408b108a706dfcba913a2b51d3faa4aca331d3b1df1582679148f1144aa0c544db593fb42433cb50525fc9a4c47260617ca97b9f8f5ad58ca01788f7d56d860275ecc11187b97d96e6da14a1e960b06eece7d0f0b54d9ec1dbbb00994581486c501dc55c510e74f92ab4eaed2d325084942a1f216375f312da1e9580bca4ecb0668d2f492b3ddcac32665bfdc6deb7e1fb28d2d959bd00dedc4091ffd3c50e33751a8f8b84b596d08d330d8ce6ca94bbb0f387158b99df794f9e2969c116fa70a82a1fac28b23329dd798d4fef919f749b08d367fcb862c8ab301e2f305c4e111e8429b4c3b681d1d3cc69efe8757084370a8c7f47693eff9c57067ddcd96da71f802988f0f54cdf6e68cf813b096a1e6b7c04906b919c76ad04fe1f5f14b39ffcea910ae99d651c392ca666b13a1f1114d17cf5e28404364b496e59607f25fac5d602e1e18fe0ceba00135472751af7a14a7d293389b6acb7b544829aa4504599e6b602c2543e44a16f0d079555515c430baf92a7c73b898095156d200953a4bae100f78082f70c5ad27880872889c171cfeda8b1edcaec50fb1446001ca655155dde685260282ca96e731ad75c43a337eae968b1fa858a9316f067ab0d246d5aec0ba741333833d9887fbc1957dee8dccec3da70261e5008eda7e101f655c426688d60b9c9f8c7e7a20abad5c64481f76648b90676e5f286f87920e55342acca8e8ea42cc486f43453899849218752f844284cc4cd04867c5658a290013f07bdf82e277b16ba85a75bfc8e03d3000b3834c244b1c677a443bade0260d1d04d8c38c408712845cca73124346ceeaf62e5b8c51c2581822e2c3c1a361db17beff8412e6ed6d3e845379bc7f68ce122d22294fe8e1069eac6490170453db567ad98cda39073d6b23a8d73cc7f4a3e2291eec6272ac43cd7d8aa84478a45e62c66a56e73e59ddab39912eeed6851e63809dcec4824f1a8bf24ba6eb128c408391f838f8bcb4f34aac8b14f1379fad23651ea193f9cc80000450953a4675ad532e5e3e95bd3ec83e01408e4f486a33ca3cd47b4a4035ea8a607b27ed1d00c8615dd2cfab6f544194c4db5190645e319e550b65a9eb71f3e2ecaf8025582ed6a353fcad633ea7a4f72bfd7e08d887dbb78acf5867b34877909a3f1b7e4adf44bd260f366114b5c95d597203cf8f96042f7272aa1c0143d4784a38ab7fda4504c8c4b2f4293dd1f5b23dd39f68933a2461a46f100925e6e5e3abc2774808395e36ac305683a8661f4073eb6dee873d2fdafae38c16875404006514237378d62d96396162e1b486185b5099f7fb834d89d02e458bcd23d21021acd2296e24ed4b730693df7d55b5cfdad1fe9be4e157bfd8dd652e9a2a49a5d288129e0c832798e20c5d9715632665b4cde858aa92f7ce62b98a4c2a883e65f7e51aeb9d33d6cc77547fca8969e833a590e4ef99a25d957cf8893633e46e3a1d7c42890bb7f7b606422a4d64def2c4331c73993da018b670a2a58a9b015584a925cba721e96095693e4f596a1761236c680a7ca493f1bc35f9c43e056c1ab1c0831d08c366d905a2f865923789063c05bcdf05051ed70b31238bea8eddb66ce9318af6df13eb098f586e077a087f66d2b686c65dcc5ce6a8f8d8ee45ff6e9fb1aa632d4a59370481014d9847ffa4af2838785f263e0996137d353fb845f04174e06482240d437189d2d07d8d5b12feca7a362e598653fb8d2f4e253549b10d0755917cb043ce24213e1c24fab9ee4b4acf2443e967ba321a9f03e4697c05b639d18ff2acda1ad0b548bfc3aad075c75f3db3f47fa46b5ad8d3be977bf5be1da0fc1b9aea931f3d5e55b5872eb9e924a8e0e30effc2e21b91eb16924200dd2eda7a1ba494fcd042db301bddc26d25b2447eb576ac992c109b51da8cf3033987b755e9c179b19eddf3fd1811485844ce6ec98b1735e4b370a284f64deaa41bd11b514dd98e6f50e12fc89cf6736e3c5aa0c47c55a0ffe183fdea9e630ddf738204c7fd2de292f3a31713a7e5c0f42795f42b799d61b4a77105c696447c2b21e345891a30da1873d4a5f041bc026a882dec85271bd6779ec9e7f9b82e9bb7a5695811a3a4625274b77bc35e5a2b86995330c654ae19fd19e61246a432fed3eb780118566032762b6203c4a8b9dbe24d697f468f3dbdbbc4437e94fb15e6482b080e854ef98d740cb176aaa79668cd54209f7215e365b82e4e7265f887aa95a6320fbbb0f3984d8bb78ed1b0e37a181daab52a472141ab7fa9f1d423734d02e4b8c0aa6c3258bd6188c74664fb29ff823d7abc54ae6b8d1002a8ee509aab6e53e2e5d36d3cfa0da4a68de1b23ae2195806c3daa5dfa9429b439bdcb31598a88da8ef7b844d946329d995a129586f420f840bf48825ce17a57d93795aa5643e011cc323216cb0c134f9d377c095637f1b2efed52e46a08d97154417b7cdea62e804e271f2e1574dc349069a9775455515563b592a52ecbfeb782edef4005d9919ae3438d45b03c5ea5202b7a0f25b4cdfca61da72fd0bd2603abbfc728f19cea8908c41ec1c5f720bf26b6dfbc70bb2b07a995f7ca53b474baab1a4ec730929502a11afd53e2b962c61d9a32cd1cc63a7b233213fce65ec8f612bea22d7aa23f1c1083edbeef1175bef94dcc39e2913dc6f49d377746926e300502ec4c674d459dad337497a6d593f7c25c2ef6ee3dbb4bef782465853236f17e302807a8c3585cacbebfaf727cbf43f01679857042865864ae4c5945a4ba7b6c72ef3acc54abdfad470a58ccc6b28610279d05da0603b72a4c3d2eb19bedef6bfff83dc14b3d6a5a5474a19d59ec890da7582991f801d648f6795cc209c40319a2cb46f98d676445a73eb5d62cc69b2e350c014420299a9ddef597a9ae78237080d6f0dc107fea33f183f9a37d26e374f2ff3b24533dda37d81cd79b904f4d5d7231c7b61d961eaefe8ed3333f4be26f04053b4a40c76b2b4311a8d381c977225657157bfc37b7b84ff8d6e61ac97af15d5c568e09a1f9d558b29775eb0138a39296a269675512af355e81dc4ddc506b69a5a4e4826798e35c1e74f89e1a6d9144d789b2d8dd371ad596f27edd2dd43dbc47419cf404be86d756c417696450edf793aa32e499cee16189060e394b107e18493c58906614351e270473eb9831767e146017a6dd24c495dfa0b86e8243f02cd5b814507393f919f8cf269f401231e9a43883efe379322d5ddac1c2ce7ae6a3675e2283da4933d82a3ae6e7d95bcafeca90340643caec5fa85104bc539338986ef6e9a0af3c53719acdfc3a247ae1f5292cd9f37e8dcf7446d920e8e256ec1ca642d59670fc7be93d65153efe3e546305b1916adbfda6cc78ee5c5ae10a4f4e71cb6276df270c047744967022eb795423cbb311b1a9fba853f823da6c9dc2901f676e7d12500d5e2b78dbe565a48fca4cd657c481503be3cd7812021291243e73c01753f7a126c247cdff4060339131da81b5a80ad2237aa2c0cd2b19b7139b02d83c6408cc3651c91054e45bf7d4f32f927031adda768c6d4c16aa4a254828096f5024f87cca6f87adce6f86291731d75638c9dfd47b7d456e72a363e77a1d2a4a805f6d0e8cb564d2e45af97573f03a53383b8f34b1a27d520c4257ea770f3235ca7bb5234059959630d513f2dcbee7adf62db4dbba916cea728512ea13705a5f75dd84327b896d042374b403d682d7e2b2ea73bbad500e522873f0d99dd8c3a67f0156e8e36c6bdd38605bd2af4e6a1398c230d549ded25345cbde2a776e2e40406f6825a1a163c718d4c59a9a350e1fe8f540ef86fd4a710c79037049a0fbbc8085f3b12a01c7c6820e23797f5744f6cd8f1e8ac85e6e4d00508cddb66858d7e5dc844365094dcf94a9a3316c35b0de1209a2a1174e4d2c7373e65bbdbf67b22f3333df041e15f2dc574580e296fda13ddff70db586b1e4db0af09ba87c06d56fe521c6a629a99c54a28b50499e8cd488c57fb8fda878c6da5b5e8d1e23dfbf025317a3f4da240e4a58e163b29468eb47240ea2265e9e1d71134b7ecce5900ba1a90e077edb5eef207b9d94377fd60476e8f742cfed752a1e279d4d1d717035c24d99ce670c4068396e393661cfdbd26d97495c06b0ce001bca6a36386b64dc77b0243542d0ea05f5d07061db2965a14c62cf2ef56b1abbd3e3302f30777f76bbb874c873af66f9c85f38f6274909d0afd15c91a396433c1c0e005184f8e47e1378c8431744ab19f447238349ab284994f20923e9bba041cc80d841fe50ee8b1807b9314e3f46cd24c8c02f86c39dc4e07a1d79746a0cc54e4e038c1df3d6a4359e35280392af0963d0a8cfc59f200ce3e831384fa1a857449439658b0c5fd3dc29a7c4c4805011945ed2301bae193a785cea6edd3d75f09057ae4654d71928b5aa945da365ef2cd7fb3f9e8ad608095ea401eedf54674b4aff221e9dc87015f6fd31b8aab62c6e38c00d6cbefa223a6a77585e88b1d7c7cc168ef4ae1aeef1339424a5619fa728e52ac5b7b2fa00f1224aa052f6192f08f7bcd5f5fc86cfce4cdc42d376ebcf582f6148921ed14293cce7c1d7243798e79dd4cd5fa899294be6f5ddf0c764f947e78d523a7ab2aca29efae65777cee836fea8189bb085a98a36a7c8186bca09fc3a95d758150eed13426d0815387271e8045af2faedf652d3bb4b2c2872febc201dc16674164499fe2402b668d599dd9ea55c7beb6e534621d092dc866fc5600383eef275b8e16e9fda21fd4434ab23eee3c4ad736f5e26992096c17f752fb228517d0b435376236756edd26c9d9d876c5a1fe5de071a313939c9f93ad5a6f622608d8c3788f5faa876b00e7552b0c378ae996766277f4cda8209b116fc36474d26d3779acfe688d8ee15de0ce4254ee7ba0e1ff06749352f00d1955fa7d30acd14609415b036e7cc8a80c2ca764f91dcca4abc884481ce77212ac6469536d3ddf6f91a7e86522f27eea0ac84785d0231e8a0c1a71bb153d756ae2238497bb249a77d0e80ad81a415c66f717aec7a06d58991334d3c775a5f3803c5f52208fac2c6a52634140c6d5a5300aa5c8b0f6b3f063e4651bd90b0cd7352595b342a42ed15e96ecbe12e8e286b69227fdbd6f11a384f6f7a60e12a3e40632ae522ca089129544cb4bf068cc609ef849493024796e7ad8a496948e28195ab7816332ce1d4c2dde46bcb36a0db0d261674d283ef5c1bba9f147bb74900bf9157ff93f5cdcf02947089e9a0009102a1d15a275ea11887a880df86bee0caa50a6aaf81859be1035720987e80fded85142fd7cb0952d5697913810fb20b61448de1d8b4bbd3377cd5b69ee617d39bad52329dafaa4f57e77a3ecdf9fb6c6f94f12a91b499d7de9fe587633d0efc3e127f53f9dddf901faf43161fe0662be58726218a1c50d52d88fd07b7244096bbe404aeb6e5e16180250f60abf6b6bba89462ea2e603c72b56d2eeb3cc57edfee96cdeb33ac5cda83e0186081074e71be7ef55ee08943d7dc18b025bf86143b15d70a112519727afbd599db8b2788a9edb9eb350927a43e235cfde09df635d2b7cdb477179fa464501b43d62425744480c85b898f293c61477d61fdadc1fb8804a1b5d4167456945830d5282e4c998b04d47c853035d69c722a7f16e7132d5b93b88a6c22c2ee15a3909182675e9ecfb7dc9fe4d8118aa6ce549a0fce5eec736a765a093925b58b3eca9c906d6d7acfcf90270f4e54526bf524be8d001c0bdac51e96ba254695a705cc0145b38ae1e8fe9ca083b7be833035dfe6df373fcdbada5993d99e1b7221ae6465cdb102c8fb4966cd556e79cbd3296ddd6f23fd54a7d3296086c5e3760a8ab20788bc9b3bf7664685ecd4dc1eb486c146dd8d0435ebc9b181c9c19df4100b32903cc3037f4217b4cf64388b0127732d50898d8af3a37185c920148d947c482a566277487841698ab834711d643483f50f5be85ae9710d76f52c4ba561844face86e461bfe0f5b3e9b48897cc3dd2a25125792d1d4d05147499e9550ce7eb439c97f404ffe71283d79fc44d415ef4581d9c3d7134d24fd5c17bc10c4409c6d3e0dfd6ac752d5d2d099c7668fd58eabd40197940875c60169875195a31964d0ece94e328e61f7ded396fca55db3547c4e753a4bee29b369aa02391044f14c00a722dd6a0bafea7e2812f4e9a27cf49825770160fe3e1921b5e75df0b7a360a11ed3f5122ed2ec72417ce34e0173544c695b8ffa4d2a8926e03262fc117daf4ed38a9f2cbca26333a3914aaf3e1615130d8b2aa9f897d37ee989cf35a71966b772977e7347804d9c11a99ff9bb9e983a31488528fcaa38a416b8b04f7dd4aaf0617f29f1739dd125912bcf2594801e7855183f23a19ac4aa88904bb7e4f95f709c1a63f3be1aa3c182dd0b0443dd1b93dae800adb3e1df079c0395939de108bf71d15b8d2484cd7e318c469e208f2950c65361fdd44c77ea698d012773b957ddfa78a3cc9ee2f52f0ed88d1a54cdabe8bfe0d90964ebe83e15e3af4cc5fc3d8b8269b5515633b20a5bc644225ec4446a9cce8e123c5091ad068c539af23bf06b75cbf1ff86b1810ddc623fae4a44c7598d6697620e0c0419e787bf6c7c3336a081405257dee9db993417d1d17281e83981faa2633399a2e67d2ae832521f5daaeeea3fee2f5f2f9c2b05d101a3c4d8db0e556c800d382a0948dbb070d3066aa5ceea05b6188f40c3e985ce96d9bf24ab067a46f723ba437452d812a3c9f3f28c02573657dd116d751782b66b9a690efb829326d7ad5204650b6f140ec4880fcae01f829576dcb0611aa3cbb3d6638720f5d0a1d25b20fed63a15698fce95a4798cf464a70caade49ca56b73a8fdbdf44d4ad4b9c9c378bdd67fae9a2e419b3969a80b8912d1629d1a3d927d2591a332ce3e2c6f9e2c12de591b448bc574a9bcc8bbd48073efa64a8857c3238c5ac538bfc914441126dd3050d71bc2f81b4406c0aa465496a67b826d35659a56dabdbf0df290d1fc8914db8342a56979dab2f7ba3fa13caa1735e68f2d14fdd6bdad0342784e081158834d84eab4477488436861ada5f7d8a41e5c7d0071d5a97b0faf63c37dea1f3267b992085ddedd39f6e3c0e3b271f67a7fae4cd72d969df78e57d58f3148e53b95d4318c109ea6ca1a2a32646223fffcbb66f9e05e2e1d32663d575096d4632994eacbb0cf30a3e29645dc8676f03a85abe9445d1de52a8c51b48661857a3e924f78abc265173083ddb1572c74b30392bd0318a9a952fa5542b48cec024c1b12e62feebfc099a808b5226bc39ce0749444697c0399a26ef801d6858e7e3850b6821805d492696690b7b4c5d45375e713273c5e2b7caaad7ba81ca4c2ff6295b6f174d37ccde00fe7ecf1e5d1da31b3ecaf22f1317f44489f44dc1613b035270adf0eb9fb15535c81e49f07fdd00bb4af8fd1824c902b1369ce7742aa8517aa89b72ea9b4fb397025fd3aba070a4bd9661198f0661f3b78d8e1204a08388730ef06c0b7838b14dfbd5a3bdf87a35cb14a3a76c506ea9d78ca7e06ec261bb834d59ceb75289e726a2aeda947d99c19518da670c846dcd1c26be5210404060a6f2d0842e92cdf897b10867f396e6f60e137d60ac75a956d83c75c7ffa6e7472be133b65b4f372f0da0dde736b570b51128f2c60767a4b33981464b3f9c1992bb0644ae5ab353c111358dae310b3ac80451c02704167158c170e40c7c0289b1bbccbc770f3877e518987021d28912c1733d2e4fde221425975d9684143150208326d982db66a97832054fd8ffd6395740cd3f7d25607ecfb7a821d9518a134c37ed639332fb1855f28f50877a3fd85755d3772da858bcce31720140c199261db278c7ef619b4f1b8cb19c3d5a99c196eb5f28fbe856dc5d7449a1a5fe6aa91b0e77bb85b8dae32aa45942e956e0c24d26e273f579899e2453fcaee40945548c95f6fb199fd4fb0130f5051c34dc18e80d9260e61465c5dde33bb7a4cbb9d6ee0890b13d4a1c187d325c18c07b001d7c5e868c16918d75017bc32b40b244decc0caa1d5548903747a4d5d4b2053747ac62dfb7dedb901743e5e0a2c3b3a59b2e026cde2ba5ff896e5b494b35531401bd6f4957b24f89cdcd378e715d4cffeca4dd29e07a47f09c88bed1ecd6f8dd7f81d25b8f3eb48aeef2a8b9dd0f62081fc1ca97507d180667a940bf63d5b6fe14b2f406e702be16d17c5b1767fff7fc7d97f15fb31c9eb005c34d6d5882cf1da02c2ab5b7be16354aca2ef920711a95bc5aa546b32579fa9f930fddf830dc69021187507a5eadf177d72f2b4ab5f96ca7c611066f27ffe98cd8b8c9cb2435699b6bc42ef9c0fd1db1df908420ca95358c21aafdf2224dbde21acc26030b020fa7d94c65da592740297e35d6b0c71d6ef3d782fc860a934495f7a4cb120efe17e68414ca607c3cea0e5bb135fc58108348078ec9bb354b982cc7f6e814872f2c4978b5f7a1e013336ffddcab97b3e8859dfc8f0c5fb0c036b44be44397328b3838b1c9c0e8549157c28cd25e9bfaf5c80d276b2a99fbf62c3d9891460fdb5827d8d4e33565152449f8e1e57443d3fb85314f81412350a0626f174a5f69bbba74911185993ebca512bddeefbc86afae9a1ca8b0ecbc180bcf9606429e71cdea2f988951f066175ead2ccca04574511b870762bde6710b9e8c5cb8913cb2ce1aa7274f9306b55ab5ed2dd6bdec6c9d8f35d1ef7271be820e2133b68091ea44bfdb34bc9989d9e339eb8991522cafa4679421d3669f5ff3886bcd5a35960638f6ec4e1018bf767dfa5b98c621202c6a401c59d975d7db888aa755ac4fa4fe6e866c5edbd327afa5b68c76890a39ab8f30dc2c4d22b91aefffc4be965285639e622b340d234d58d918e49f3bc6ef0671c1a3495957c9e0bc4d960b9add8474d1826ea43053c18e2fe1ccaa6be75cf2b432cfeaec6b133d4c33a06832b61e01a21d84bfe1d43da40540b0581219f8c193734979a765322e47b2c3a46df9ae3af3fa624ceaea7d33b095f8d6ae75659c17e1f1d3c2f5a9d3340f5c478e928f19584d74b48378f72567413d20d2ad50f2799cf627fa7908796529ae61aa2de056b504511f5488ce0bc66d7309a5e63833d05925d2443f0751bc10decd2eea93ddb20d3105830d09c97acacdfed3cb0350814da27eeb4d2e858ceacc3abb8a49c9d7eba684893229c33659fd68c521e5c9de58d158108c5ba2cd88cc35f0292ef72fd3468fbd3ef1b6e07c6d812d66e710623e27c7561fbc71d4852e6e65369cb49eaf294b30efe10f085257991f4339d337c0bf1f4015b59e762b02c6004110067a75334a30ca2053e136da854d29e118c4f410a5553279c1c5cadd746157682993c1374e2eeccd2b2f24a80ec09ab928e472660b1c76b348c77c8a1956c48e498aa8632164debcb254585fcb930e9858f748933dff1a328c3dd18a1d44269440c02c538a9d7863a5580a7a4fb10051a57a1bc9add24e42676cbcff14efef1e9c4df4dd0c41151dbe85893431259131c37e69a33b9cbed386b375388a18b8ce4558d8c1358ecb08be63b28812d737bb3b4deb93df5070f6ab1e7e39b5e795b4d68338504ff0115188958d8594403e2d7cdc7a4d6b6bd4cb6ff39649e79151f7c59f77a9aefda41a72df4489cedcf52aafdb8dfe3389bca6a8ed5442e052e62b2d7cb2920901fa3f59447b6185d222d435507f4e389836b5c804e27f4255862b82391e8c5e400fcd4cf76a3e64e6e394946a1e022293f549b67b16112aa4b4cb5488191188debb097178500f5531285b61e340da8795be481b7907281799bb856ad3d5567a044a33434325cf5adc3c6aabf03acef6f96d43beaa8d44f7c9209d6c1466e96fe1f443e5567d382e90bc9a86fa06df96f89b4a34efed8bfd4d6f040381ef90641c0deb9a6bb3316c41770b74b829f02c92b432fe4eba1734d82c3c650b90e8c23bff566f15387ece24c27b76b527007f4c1edca2f1d60ea5a8a7dbdcbc98d95b262e680864146900a26332bc799113225e4b52d4ef5dabce164365093a56e25cf00c92cca56ae149448cc0dfdafad7ccc9b6ede7eea24b031ffdf86ae4e87b41eeae2f5e2b1c564c873fdf757676b06f73318572bae782c5cbcc83bddfaa3749fc4da778fef9f8e8855ab578339b5a5b515e7a0abcddf98fb833a3106d894bdb5c437e259f0f3a4d73c5497072ae6c2b3686bbb8d7be8128df580be23317728c4d716564135d8796c06e4dcc33b13679c017c455c6325d7666727f62df9003f27782abf1b6db449cfcc74bbcb0eea5dd87331486c19ff5a686685bd8635a1ba3bbe5a97b7e28750db467a25b9277d319fd7307724bcfa9e434759bcb0e96f48b65ceb1502ba5da4f540477649dabc2f53a9beaa0e2b9295a24b394ced0ac39c0c6734356eb319a80002673ea1f6b5c1a124736db003cef560f0cb419c8892a7714020d51c279ae05d6052646c33ee1dee6d43899fe6c0e8e25b3861c90d0fcdd0ae1a8f56b72d28f29e775b28ecd3ebc3b71085bbf22822c3781de2e787a3073f1ff9a6ba37803757b12645bfdc4bebf1907cb44a226ab6cab8563735f9bfa1466c16e29de2fb98299637b24f498d9d3d8b8fc476485f00b9406c02629e12c3dde41fc40f757c6fc15e87136c2f0256e08adb58996d284e450309b4b43e808f9785800865d6273da4fa6e04a3bb43d97ce469f8efe76f3e67c697b4e06c5f40f342b7f96ab6181ab770081468333e4f2af730a3208948a736a75e842f5fbd03b65e6d6fcc803393982f825236a75f09069046ed686bb4a3607420d3a9f5b78e87a4c60fd46bda2cf058a4c02013f87255ae253b8fe697a53baa33347db190d6b3f5a682278ee617357661992ba6bcbf4b0faabd6fa61afa2507a7f2bbf81bfb37a730a85c5a812f4a8b17461d96adb4aeef8a4fd54a70f3dd609749117316be497507a14491103e8ab1eabd5fe7a8602042ecea9e2d196e60a27f47fec34392e5f267f4e524ea3ee726a18b0803ab289bba147e985c56281ceb2a51837d3f477e05e394235909955bb0c3dcf5c051cd728bbf0cb6033e4f9ef4e710247ddafe25d60842a647aa58658202195f86bbd3b45e5869213122a1a5bcabd7d8083fe81d9498afe11f5ac552ed908e59290188036db0f2fb7ed50e74c009eec674e2196dfe7fdd32f9e7098b8e8379841773a4ce3f221a3c45ab505cdf559c8ce2eaeb5bd62c522fc6d2150ad57b084695e15240800573614400af7b73518733bc23a5419241fde9ebf878d2c898b468ce91c32514c7e9e3a4cf1745658ca71b08140fd11b9a034b6b2be39dde52cf2feeb788bd0da82a858b6ac60c497de1a747d777f6ff9b9a97a97a6df7a37c8c2e9191d0c4700beb6d5246715baaae2d5b9a7a0ee56b2276254ef43823143f6ac532f4b675a7b6fe46198d25fbd69f31a18d96e214525809abf5c061e160a265e1b8e91ed66632c869aba9ed00b1eea9672078f718d7a4ea745d36ae688e2a63a76488ea87a875cb0f7c217e270ec3758d34ee7b5996c02e11751a76c62e2fe87ad77fb6697218a593ddb576b31c6825ded7e9489e17e42be33fa99e1f824c23cd3dc240addd1e925f938d494529e9c26d648195ea9171c3e943700156c036f6227d1d6e4ebafba738041495e935f746f516b7041962abe7e8489ca417673cb7d9155dec1889d7fffcba6696719090616ccdfe8a45869c7621ad4eb1dfad65df2df09168893cea6b527df9f82dca8af8808e55afa274dd839477f3685466d479d1e87075388181e54b95a37aacbf5bc4a1328bba1bf4c0b3c59150b06435f3e2c575ffc184a6f2c7edff0f4ce3f49db95436bd961375248d8a74fc9d264ef80f0ae1ae1789be7cf927ab66811b63d08628032b64d2dfc8c8be8fa7550ef164fed217a9adfd4201c92c9beb3e5ebdc1b40cf7a88f319b1947729b5b5ea4602c77db55caeee65353211771d082a58f9b96f68cc5b51173378d887bb36ec7313a3669723f77ce7c6b116bcb37fe5b19316780a5d67a5e514d554a2e4bd9d5710a3c0f8d97a5942e0cddc1e448f751a9a24a3874696fa8f7f923c4bf27b5591a8e24e7372a12bc9cd24a30ff621b98ed4eb546df85ecefb7702785aa66107f7933560d9e649ecbfef7b46430775b744484c6292b33d513c04f4a8a88973178f4db400a92841d1e7848f2fab87e43f99999445ba761780bcf3b974ef3bb8b7e16c5c0ffea27d82cde3fb16db63e63cfd6694317f3d186e26b864bd7528d37ddfc7c97661b297ca04721043c9f5a7bc644b62fee4cf4ba18721bcf6ffcb778edad18e042b584b31a4b0a9868472c11008d03fb6d419c660d5aa56a87f0d7dfdd057be40ad331e065315e21204ce12c53b9a547645f079b9b922609b16d6814ba0d56d53eefed5092e799cde576fcc199bacc8f0d1e932b71e1bad19ec8a0f09608aa7ac848d8b4a59bc19a417fb64e8ba487cb1ddb2506f2e1d504af16136b507e7bd46abd77372e37207d24ae17b2ddf6465ff81d1bac5a7eaf19cc1b524b78ec68392edc3d1e9daf9a81dd1c34a8ae254c5a2de60e3e03faa658a3c9e81944b91094f6ab96713eb9d27a641bae38198c0f52e1815426ceccdc97cb4dab4d1eacf61233bcf747d8e52ee9b086583b9593655861052c32248ddb1861169a113c8f2e1e3b4a0f39787a98a82f98bed8a16b6f3445362bef0abdab781f89fa0dd591aa8cd5f5da8b72003354b640d10fed8b7928a07ee39bd79d51cc57b0a4dcda20c3ecf1a06e535206c1359860d9de706c90f81c78f59a8cd6ec6205440e52c5aaeecc5f13a92690da0609caeb61c2e9f19bef8f751dc8f089106d441a9ad59963286adcdabe4f754fe98d163268a22b1e26675d50814b8c5595bacf78e02050cfccd379c6da2aa6faad5670e41412350dd74e6679c446eab0c05fee3a47826839a9c5537ed0469ab5346cfe588dbda307cac7f14429f02c1ddc4f043e3d49f0a882f21c1c964cf015ee3ea02c20d10b275de90a5fbf3ed0a00524a4c92ee56d3a21f1183f048158171650cd387f8997433513f7ad6c0e0709b7bbbdbec2509bce0ec7c3020df991714dd2088bf06c8dfacd86831a91edfcdffa2acdb9d2bb4139490827136b8a9b2e26b538daef9223796f5f668fa10261dfaac43c9c17f0bcd5fdddc19d939d6978cbbb5912a17d88dfee8bcb576545f1e5c9116f3c506250b7e816743765a03b44661bf12332d35a59c448e4f9c167cc6526041984d12c2765caa6007fe378ea744657ffb027361f054f8f1418f63985ac0b073b88562dde9dc3cc892d17530343d643356f04598552718cec24ea56bdc2dc21ff5dee66886776b6746138383d47a1ab1392cb72e7181edc912e5c88dfe29faabc37fff0808777805862094fdadf5eebfbad8371cf33f3262fb23817b1f4714aaf72dd8011a76f3e0b9b2bb1733b83747e63099ca1725ae301550f24c4ce03d6cfb796684b437110a1fe28457408f3817908ea870aeb371881ee567a1c16abbaa60f39dd68815e27e6ac77ef1cb6154d36df6f76f9a8dc933cdbc425e74d282a526a6117bdef606eebb9203ce2f56fa9bd55ce4f7dabb0c365767a923e3c00700b1e67de99fe0b5f6f985aa9541636cc6cf2b978ac214c6cd0794989ee51b3116440ecf593e98d9309683dcb2534446c277d733beb33006b170e7a123751c07ec09e2e83796f0b9069c108d9a5b4c40a6d5107a4f9cfe3eb841cc7d7ab59ff1cdfff771089e8e8c7c15ddb8624385a633235d05f516bb507a2da03a86ee426d1ad103b118784e5498a368a9247fe91fd4adc799e6bb5622a560560d218fbad3dd8a6cc5a32a057d1a795b49391ffee353a3e19b0f09a4f7d488f64fc77199068fc1cba5e8143b53b7222ef56d35308864e6e10d4dd4afbd261ebb42968c0698dd79c369d7cc8bf3481216997ed32fca1b323a34cd9d9d58aa1830c38be324fc36d684c8042a11a9997075d0f15a9de8ed76c6125c83deca55dae2a6c8b5794e9f7928d7264baa0afcd00fde23d32332e077eb029ce028569c8851c7cd070fdc1c3580556b2a12908cf161d35fc69a67a3cff7225bc470606545fb7cda67cf43d19428580368aa364305e7241a6bf56d9091525feda66c601c77be091893735cf3f41310580b374a6b0d229ce5198368a59c6a8d62406251e45e53658ef12e5cb63aadb66f6b04536235dfd334cbf2c2cbe4798aefdc62593c7b3f9881f26a6ab34c78c2cf73cee9ce64efa62b9c8c42df10cf8d0658ce61f6cab8ca49320a89b4dda7ba9b3a7394fde91ba49a2b329a03af05d812c9c7902f3ed2e09671d9b28b00c6736c3af54c00a8c387d50676dbfc3a7785ddbb1ad6cc8d642e982c1ca0d81bde039044d85c15fb5f9686ae1e9b1ba41e50069d2153d5ac333187eae661d7772d07f187e1a0a9c38c8740b38d292ebc8e22d68462a69ef1b7aaf2bf41ba38d779aa61f54d93488dd72dfd59fa0e26d9e446dbd73039e9239d42c7614d0d8934750278aea661364967d6308fedbb3c250bd66c1577bbdeb5f1339b7ef3519640c2e0334b9e7471f3f24f6763fc84ce1895532b9d88ce32a4ec1e54269149a25fb46272e591440df94385dfcf3a4775f74eacb6bbde7e2fdb02ce63fa3306a37b7faea7e31b722a37c46072fa4dfa1b366107abcc03a90d437cc73f50ca73791a3722999bf23b517324298190a605dcb3e1db9738c93603faa90e68d42eeefe7bdbc0d4015fb759377c8f9ff48372a6e9055b5d4f21c6b2e46b20080a8789275000f0e9639d08867f2339329c3ab242a8109bb3b24a4ad7028685895cc4b35845a5a1005cb3ef7b7c8515a9dfa4bab0f7497173a30ae746f506f983f477d16da31735fc7f53d553a67cd05ae57695848c7c54b85c76a9aa63c285a6a1b64e0fa25077399b8f4b0aab710b4014925c8298d08860ffd988f3eb283b17a3aa6edf64a49a53b3e0d2686eada13d5414fbe85074b48a4cd8486e6716c3283d029b9fe9594931f3121e00a9798ebb2e98b5ce4bbdaef63edc2eec1b2abe6a7829162b5cef9c8f43d2c7bf4e65664eb0cb8446c5ce44b19ef2485d1671dae73b4504f57d276565173ba451e7f4aa8b8257e861321e6dfbd2f69ccded6e2c28404dd3d61f8b51cb43ed58a4089a0e42fef87a9914ce852e2efb7ab926f687d1a39ee021a09d2afe4725c1b14707ca76b191a1a7b7097033d9d61d7af1098587aaeabb7880816a9308342998d32084d910c9350563b03f21a29c011f1f404857f92b9674036a30ccccff8e9b69674af93c437a6c013ff613418b0a307a7acbbbb4a0103420a695bd3586b529c99467016","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
