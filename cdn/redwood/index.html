<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ec1e8817b0947334466189858f5f02185fc4168af4175cc89072ee78d82eb8bef3f899e6e0dbffb984c423ae50a11e6043420247ff22dad113e379389124d1786d970d3d0c23fc198b13976a3145772cf98b43b8c93b704a019003e5120b9992611743de65fbd61366cf55680b574cd644cc26434054c15127878a6bdf6ac907ca3eb41d3af09441aa3a53ab04140272ae7eca484711b47fdf19886b89488782b7429ee9b9adbf30dc5c6649849e1d6886fc09d0cba2e6567d6df71f2c5dc5208ed9abb64f4386fc40a3cf20370383fe5e1872298fce3b8d7d4f0306ec4f1fb336ea5a57b56dcf0a3234c351ed883ffbcedb50813b49555e2488db54d0fad50a85fdd330d4d90b9a53e8c50da17df3ca374c07d8e6619607cb5de432dc7c2fbe5c70cbc0daa4ff41282a84df2558888870e4355a8eafda0461b7a39f27ed1d9ea399223d632adb6de65e74e6fb1a5fb929e37627505e4eadd5c68fc8ed7d24e142c7ae4205401892e4df3e77e5909d82bf96e563c61bdf2f7be4f0613986fb595a63ef4806d8193525305b623ddae26cfa9bff7d5e8b0974578cb639b35696183eff4562bbd314c385e16c4f6fbf039321948110fb003a8118dd7f594e6e7d5d9b15bee802c3b4e22c4360077fbf943b9f4509286669e3bd2a42248dabeb3910030901a8b35985a97938b0dbdd89afbb9a251f3df51a7e21edcc5edb99dc9cfeca5c450cedb823ef7fae31f74e86a372f2abe00b506a5d8e347aa2876ee3c07de364fc78aff70eb158d4502950136bc89a0ab2672e092f7c951a230f500c0190202c0acab6cdd721a660a09a469256392c1d13864344939b64b08a52ae6831daa98374bd82aa3b965e044887566bd35d64297ba02f4a34fcc1f6487350d860e520b4df16ed182b3b85f64e69a0cad6ac1815955985cafb16cc6ed95fb2c0ead72f741af67337828e9696b99530984cea0b8b871cb48a32410d2afc07c99ef383aff9f3fc2ebe8f96809cef331c208beeafae77c861395c1a25d37426d05b0bfe8be4168106e761684979fc8da8d7017cfc37e885a5d4b2fed73c7d25d2183f2737dcf197250da587ba67c73244e22f18c76b5d89be14fab12647ae2036db7bf8ce8e5ab47c8168cc4f8c05db8acf28b1ceed49938ab358f9f51cdf59d898e13058df0c4dbf04f1dd134ab6d93635b0e034e05d81c287f01aeedf6bb95b82ca911233a92fdfa4fa912cc81bac7afd4c5fd1bb575e3144e3fe2b2598bfaf7ccaff1304256a9e2e9770d1de019b2e8c291fc9bac6792b220e9389560d742618d736ddad948840d8b74380219467f430852ce490be57c3b0463dacf3d7f997706a0d7564e52255fd0d735609208cc7828f92375e0f20a7301ace69c1c3bc09e21b8a5f6c0875ef9eaac82a704bea2155e6b34f26ceaab7f1063589560bd207c528527f82ff8b8f4c317713a60260690923899eda1cd49a6511215e0b26a39d0f24b81519638e8829adfaf066f25b95f448e873a48d542a2649dcc08c67499eb93d2d71327022371c5d93744fa981e1d7da5aba272b646acc0e4edea9c5082cc0159553f8e798c185a5f9c49d23416b0cc54edfff55c4d4407bcbecb27d89891daaff964bb111c2c10acbcecdd33b9d77161ccf9aafdf06e69e2adba86b4363ab8519bf9cb8e955aa366ed44af28c2b4647c0e2fa4b19ee26d8fa8838481ade38f1389d11b08fe74131fd2b26c8f4d8d7579a09b2846cdda75133dc021570d9380cdc3e5cf825d4066c1c5b3740423556312255fd0d5afbaa6d3ea84685fc572f8f8c129fc158ee1d851a67594e3ad50b4761dd5a3bb2debdc076843840dc42b154b8bb8815aa1c60e6ffb45ba475a24d5d90c1d67a29f398dbabbfa2951b8c8dbec1dac38c087196f59bbc04ac4a5cc5c6d437be9dab05421f1942c282aee5a2b635ec5b6bf8e42a68a2b5514fecbc68f75b6cd73f29c578fb7374a18699c6863e2c861a20933fadbfe5a81e75576a97774d8e68be27aba1bc9eadc09aba1778af768b49b4188d3b1b263f872ef97786048c8f0d4538cdb15c558654412f6984447dac6b0b7af52acda3cc36ca623ba761c91fa1743ee1e4f912f0339f6645615d6b0a6139835a79c8bb9c197724f68ad6dfef6d7174230377d67a5c6beceef6ea4a7e050ee1bb549e008e8b2dabec23357eddebdb04d2cdfaea41f918108f30374ce35ca4f287946a941a3462588e14b14734474417d748e21d1ad07847cb91c15786ccb2b517585a823283dc3dfc3cda624baaf60b79f3a4600c2cd42f8eb7023d263b09903b7d2d69aa9799da0693fbc4164bba57b4fb32fb3bced139a3fcddc166223fcc181234a63a780a02c0c82912da6c46235f769287330de69bf8e3d2184b8f35bf1e586fa323c48f0b69d8ed2b08d9fe434c5bf84b60448e6244a5ee91b06112c98e415bc954157a668f76c4c53ae26de73550ab0c8294d950b3797f27f67d21a8040ffaf70a27f329ae7160da50a147a0535a3ab4547482a236d45d752b21838e18d742766dae30f6351bd0dce4ca1d6c29b872c86b790bd51842d658ced7f470cc7197fbefd9f0773f25ae2919676e56b4b573900bc5109794af28c363ee1e50c8219d5ace872cb5107a40a607231056eaaf236dad2a8eeb91d3d2a3e6438fda7ccf5a27587a379be1c5aede14a6933eea80db8152ca9005f237b29cb94d3c08a46ec253a59f712830b0d88e9daaa3507c9750101c571e4d62d82fff2d226df38330980b54c9855b201353bcca48c7d49b74aadf2647b4bd6a6c5c40e180fb7b0fe0d070b1b49889a8f53bfde99d91477b76760542a884e601a811c781c57dc2da3a5ed16fa443f27bf8c8d769bdd6c2d145e0fc59a31595c2c2ccd80ed4b8d57ae313739622a4edbb24e9bd24cf3e57a51cc385d86a653d9f91b942142be2b4f873525dc091cf10121190b78de89868fd1d28363ed67e912de612a0f6c997aaa613ddc816496ca812d271ce995eb9da0d9930261fdb45507bd5bf57f29281d0ead27f6bb2dd729e7ea0cf0cd3b648a08336bf28285addf0adc6446f68599e7d23ece82368f1730d74c79b65bd20ea14eb15c8acb81f8530f4dd652486484bfe9cb6bb88a56cfee540b988005f2eee8bbd58326a13c79423740585cb27b93ec167fc51b646361565a41e0a453df1231f50826f294d425c182756ea21d259356cca3ce9243019ff2d83ef38904f550c2a46e65e5474d33854bf29060259cbc7c5096e23a3f0c2d6248ac93f2a3d4d0f8a3212b4981ef4c041f91a1d6a7489ac90961454ec32d0097e93519e226ec24e159f23005db6862b9b46029c613c426916119fb3ed4ba2cd60ec992bc1495d9a3e50cb3ed5c72565b96cf87e7bc10d48e057e86c0d94421d0ebf346b55ee487ab5f1a845d1ec8051764d67197a0246398f5305e5a728473f94b632f8915773c7859b7567c1a626b55a76515de528a9a467c50abb786e2806cb20a1a96bdd7a8c57dee92751e5043b1442194215d6de01be5aec6ec3bfbcd56b03b6ec28d15b7e0677e8cd9d76a0e65712aaa40007062a3f2a3e8b883c983d210e8ab3420ce6079e7b1c8ab24ef41e3226061ef4b0df06144d81772aee1bdcc1a2cc02abbfb6fc3a156183f7dde5db0aef82ea20bb842e993571fecf81abe78e0b75ee51c876334fb2171e324140472046edf53460df841cf7b1587b95d2617623f6bf91a17d5b38c9d8fa30fc266cd22d66bb761dd921d8c61faaac5df2311d6cfa526a6e5d11b76ee8fc1ca45132df5a08932a015d0f6d5283188083e223b2a6a74c25dc387a22d5f6384e807e21b6a1e61e62f56eb0f65e8cf4a0bb25282b41d919289b663a2af0e81d4d5885e1d9811309e3eb236a5cbe68e7324fbe154746644866fe6bebb80366c5070f2090880c367451d142be7d260148396f3e27cfc09210432e2e28a0dd8ab8d65de6d4566194bfed05c62d66575e195dc75b4a9cafda0a5b024df26b4fc86760f87aa700e0f7fc36c88883a1878d9421590cd96f1e2ae718684559eb9d709b13b88b155c5c04729ea871687e14563530575f71eb9a93b4e1a71fed74d9b859ad3949a8039e2b0baed333812fc9f186ea2143f6a19bd05caca30f7b380839288d4419577ab6a3cbfb45f52c23996539b4c27fdc517bcdbf3cc2633d753e4737fb535321d6ff8709aa2568a9e9c08ad03ce21ffe45fbc4206f189a2c9e0b059c78cf6d9468a4a4c0c3b79d68307467c1869f3c4c894234cdcf68030c1e68ac7c114ed5a14f348533e5754926ab7e2e2bf30229f81f50981043650d0789f7c96a7cdfa123e062850fb2e007930292bb443414f731cccef6e4dbd07678fd0af237695ad985d7c78517b6ffe971c50184e71d1200cfc6fc515b03f51158436853ed048b1b763aafabdac9aad31b89a8d979bed2e9815c71f44672a991498a2d8e8fc0246fb2dc6b2eb8991a90a0a8fcce1bf31c0b07a9202b903cddd66e457c202101260a5f5ab2959fa875bfa1e09efcbc8646afffe642429a0dd13041cc937094e0bb0107cc9aacb97451c3945c54c41fa5f7084800c8950af870eb8981cc1ca8d710224b0474ef4bc851fcda5dd685bf82c1f3acf5670b1df9c9b31a473632ac962d5669a9a98673b4e4c5ba27fc3e41576e1186560f6c8489f3f00f1c794cf12e5a099565472b50520e24d92df32160e407b9a00cae2742538db9f0ebe11b58a47037464e71b72e0c94146fd342fa51ed802eff946e92fb03b434579b773eef38e611d8b027a7eed9616c0917b91a63f5812071b32e72de7313b4218e509db91a19cf178599e7b428eab05c055fc589ede8b1abff4581585a43420ff083af585b67413ba5ce0e123a8255c327c444137328470968450cfb3bcfa436e10fef50dd1fece6321f433e8aca6a70a6d8957ac0a33193d9c15494d09c0549d0374890d68b1b026246b3361f181822dadac36115f824731568938ae0fd7e46831008ca5f5c10f8f7f57ad9856bc0818191be8e818bff5f33e6242995695cb803027518a578fe84ae574c483dafd5f5c9612803eaba4ff98ddcfad6b6723a9b41b0e1b2189fb174c86307ab1746082c98e465b7a450b71f9afe2e6ddccada5afbad64622b422d4d5f1f738173cb17a86002e4e00eed931b6f110fb75f4b7e712cb6a48f5d5a75b03c09ced060bc988964604ba3d8baa72a64c35a8b087d74e9c3e5cbf187b7e776ba94bf9fc097850e9b2123fbf6b5dd054261b2615d54ec23940e4e6a143bd6bf71a1858c33a83efaae2475a1adac5a54d09d7423729b92495b5048e9bc46f9d800ca53195f35996c20a617edff7f1c803f7f625034b668e8a6cb05435bc8a1b5aad69fffeb2cfd450eae09a41d570a5a766046883089dcfbf433ba0c0bec3ef8e6a82fe2767d9c8a46cf5393a14d1a9f877e8befa05e23f430c53ce468101727b22752c65d2b948f39536d92a507e14b9ddbb23c581ffded1abedde32b2409dfb41911928d121277768f66c17198f33cb69b0638b56cafc7ce0f0a52a41ae7d51eada24f9e502696ac749932547f048cec590a568c2077599e4cecf0f1bb39133ceb3bf340242203f91a409967949d59c9745a0eb45b718fe1d34b88545e12d0de8119fe2b64913d1b7db1478c7194ee47119f9ba633c7dfbeae47f1e991bd158e665aec10c479254cefed792529f71287b7b1f4c7dde6fc9dd16263114d0cd2c68a0a8447a3bd1f7bf6b894860e0c4226d4f26347cd6211c27ca1182e2f2a949cba6014e12f8c9b2708e006dc1dc502f080d0fbaa14eb8740eccf6de3a632a8f86a9ca514106184f17049c320633f7f93f0ae1fd68302420c6645a02a7167fb1142742f1de5aaff060d7904ac7adbcdaa5ac040edf9fdc26d61619d01b7f67bd3807d12a56c3b9c45b826c2c5bbc995445bc5c1ebb3ea9076ce69139a5355925953a6be0d5fc9a5af24a505fac2514ce4f70103e9ca87acb002c3b7539058b72f73f980e00198151e3df09dc58aabbe5960eaab52be140cba53cc1c4a73ac2a38fe0b4e05e0d374d371955e201ad774866f5eda65af1751f57c11fdcc6853c92e90fd27b80d559d8ef6eacfa18e97f784814b0f2b85fbdd3be738a64437d99eca30a2c41a4c46bd51abef9f712504319d24ed7fe7ddaf5227cafbd1187f0e1c3fe9f6c1771397d03bd2b694d05170e71b887526fda673c7488cecac82d30e896d4e002dc1bbccb074f6432504b22efadf3f7eaec40d9063c211994284745dd501450facaece9382f4674181fa07aa4e1ed69db7c139facbbe0f9adfff71b65dccb6b767495318e179a648d394cf60ca94f00f6ee6e65367a45a7d82aaf9671a0d31eef5eb92158bfdadab8705dcb341569df01aa16edd4ac0d5598211cc8642d1331bf2bccea501c9a131d7b06accd23f42d69efa9d878b7c6f1b4eacb37c56d95bbfc1bcd943929d6af3c0de2b4c7f15fd2a5cd50b4efa91cd74184ac1391bb925f4f113d3a69d06bf41455239ac304b1c0c106822b9cbe114f262cdf7f1be6314b29dc0d603be58f81ea806ad6828573edb82b34f247c05743938f5848d6a0130b965ba4a626c2f9673fb2c8683fa0c64ba050efd90f4a2735a740b2e554534a1ef2c0ec575cea0ef3b6694e0d36050c70ba123a04d1247abcbb9e5f79a150e1a778295bcfd954e86ad682f87d3b48c3d0da47bce6cb00055cca9b6d789e4e254eeff765178c0f2e7e05697c416c81698abdd0e73a85f2fdc6b9774c881a4a0b99f984066701eb37f6d94a3e4500ba4fb74f65384073475e9f53e59430663c194488c7521ae29d465ee8ecbac38f70b2c64d6e7705eb5b690c8b66c15750f30d682201d6139d9a405bfb071af1e53ccad670aa464f570221856f65ebdd7d8c4528357be52752740c0e0812e68a2302fe6e8f69212f34b03414a459ef570b92f23135b45454fb2c6d2d8c4582984f245ebcfd0f7ba3e9b5d7cd9e9e2d22d732fc69e041882e3f82ff779c16854453beada0cb9d267e96bf8cb0d38a43ed42449a2353298c31016d90ccd67c3361c32b3a9547b56cb7e389bfa9d335e819b593fd044faa88e7e8cde5f846f47c6b60c032b9527c7f85e17883703ec3d1bcf1d5d546cd854515346fbc5d8afb051a655d0aa93634bd0c2731cccff5cf5e2afdfe0af4af69a5a1e0666507961ca8aa0a0603b4c69c5da3f1ad3f385c3f2ccb65cfb1c294969813c7990c347e8d7e86aac68e6f17678e5f4ced20ab08a7f62124105fff865fb160f47172659a70149a2d035be0156ce3e6c8c9a2d311bd879c6673a8970a9d76f90da1f0356f1a089c3f3e9e0e8a40cfbc8084d4018c12df0df73856dd641c22a7ae9035aaae0a477e5cb3e246b892b0027baf733995346ae01d805cc64b140c17b8e8c37a5c63803ddecc97203916261f77b087b9e21e44d6ddc8741217e2ee97f057cdff1312b1cb2e12d6cdd137ee9647e6268c8836e7253be4a91264497e462a460495e15b2380030b7904706ed980d7c6531813b6fd930f39e2362f3327065a5f644a3916093d9f2235b96b81166710be994ea6f1a87b87edaefade588ab241e0ca5d27ab5e47ee7e2ba6fa65379e99176fdc4851bea18c74b7f410707d10149fdd32ea95915398a1361ac7be94a627a69ce497cf19950ad53d4d1d213011928aa4d5cfe8ff62612de506814cc03241f94500f0a650ab9221ebce4230817547240586692993d4286266308c88df56a31c31d593302ba30b42341be8e204887ff271a55f0804d09e82776a92666c11e9b337e3030840ae0686a4302620b126b6796eade391cfad2e7261a27607e7c5a701443cc063e625588d665cf57c6352eaf3765629fb1d3280452ed7cf66d5df1f776f0c90899c66855b42df635a3a21fb3bc2114e960b2f692f63678b942c08707a34a394e57a9b9cab1056e8e4d84204c24e1f77cf8dd23ca8ddd5b23d3fd529defc3e4d721e57106b611e525e297880f3fc1faff0a40e8b4289ef732954890e3f37150a0c4d3ba5a59d585bb04429c2cc43e1f841df14eae6104a96fb2e7bf7b506516d49ae8f2ce8295784c9d42512319fbaec68b7dc5da71b377ce020407a0303003ae52163b8efca528d8b1be8918da62d8fe0106ebfae9708e7a3a59726c6640bd40adb8d1f8b0f304e32180af9c2d879e233d3136206cd41e3037938a37a3b1eb5b0a21e8c6e556d31ae374cb3eb51a8c3dbac2cf368a064ab9a464b8a854c299ed84d091cf5936c534f9723033717559e64e10d1e77ea8c2eab44270941dd7d4d48a13e2e7b308bf428d7b52e8dc9fc088c297114afd8a9826b12552cc69d4824d4a52a1800f377b5b81bf2eb4a860fd28ba70d6010509affb049982c900fc12224acccb8566d4aa67c9552069ffe672a24836fd3efbb78f2e0237ae70e30780cb969902d60596c02099b42d15ce93d507780050476915f07fe5480a5d964e000c0ec23b5f60bb716a58edabc6189260b7acfaa4f1f86ec380d9239a46b0701b78382ca8c8cdcc09f2b4d1ba2282e57707a69cfd232c35860f6484ccd420739f33538e153bbae901bd06193ee558b69c1663b968cafde67a39d67fe433058e3d6737f68b1debbfbb2f8eabfa3051e00f493d5eea10dfdd24a85f534f3637579068286e1a9632c2594ec488163098c1d048f87bfcf25c4a627f14a8dbbe8f2b26fd8801d4b439bd44fc380f6dd64851a7378c86e057b7f86c45015f6cb74d5eda81cbf1b6394f12599d957cd925db1f354aa6cd6b9961cce58f510a699eb795f852c8c999bae79a4d4da917b8823cbd41a32422bdd24c9536f3a875f87803e4e405a25be80e822d14d75cfdf8112db53093471fff737fd30070b0a20fc19db0e3641098f67190ffe696bb3890055dcef86511803bd44e629b692a0d748b30082a89adbc390115e34f1615c5fc4362e32e01e0279cf0d4d4599d409fa362ed08b627a896268fae8d974fedec828a88cf0456e3bd735b9891b833d3a3cacaa41d73de225d4d7633d25083d03e5951fb99ebc8d3213814144bd4ec534d6b69857e245bcbabb243a02782acffd18eb11ba574d2840e2eaa24d47746cbdfb679b9fa46c70e9627fb6c760a86a538e8f50f75eac6339a58ba80572d52f0ae8154679120664ac70aa50b40aa9350a306f7cf8a85daa9209c497b0cfd212b39f40d294ed730f62f5297aca5b1585d995083eec832c1b4fc5e103a99437936666b3734269acdfa5f8b30ad37e09df2a43e6c237aca790e77e8a1f2692cb7500b680debf91c4850369633921418fc11af4722bb0e6e82f77410c490b75ae377cc9fd17a163bde49f14adcef4c823218f4bb6e475d671d41c9ee801c617aa5b57f901d67a0e171a236af36ac006c56406cbaf7a8ea1aaa1d618ea22b570e47c24f99da7593d8be0dbfb65fa7a510f5ec495c4fe22981a8c0fdd571503b335ebd27b8ced70d9eddb653da877cfb152513e32815d5cf42642ae667774661aba0a8460aedb55dbfec9e38cf540706f654fc03703644853af4dbc7cf341bcc22c275432836a50b71cb6fbeb083d084587158fd8045f395b45c4050670e73c8c6900b664bc8320a4c22f14fe9e4d3be7ceccf053dc6baa9b1bb615c1c9d69795e605668fa62d0b9752afb05e52df427203542335827c25f4b3fa543555b61a29d82490a12e664fe8d8152cbe5f381efbfe7c8c6809136f29596111df00ea56344a1fc27487e0a3e04b2a423e700c35ddbefcd947d8a6c596a1709574477083fb754f3f7620c8235add9d9f5bb6d297baabcbb68321578facc8c18452f363d6437b47ba1aed793daf5683c1a0533160f620c902b191c6fa31803e1ed3825320ac277a1545169ef61b1e97557a8dc48396e5e99b6efed635ac6f4ee5552ad1f0cd1a17d21d1e2bad3e2ff2439c22be8fdf658a0bb7e27791b1af3f7b09053c7842e531fd4dfee9d7fb7fab6169bbca46c73beba033b653d949d94bc844777adb0513b02377960379377b5cff71856956d7c6c2274e72c72518b39bc490e04d6874b2deb6d7069ac823d210a667f2656710adc8890934bcc535731c1baf5e7eef1302497bd5362c0edea3207dba03ef4fe947067ebe6aabd0bf6b04df26b19edce9ebaa2f240c0bddea1d3afd479f3ca9c96bcaaee48ca09a277dfa36ea3bb796728436f7d6a416912de0da8a7a3dc728260f7943e18e2f4cad0230177503392b49039371afebef5e6dbdb7f2efb0ec23147667c4186cd4718f500de20b6d0b32d667ed45c8b9bd2010c8898eed50a7c8511202b6e5b90a7a157d50a0ae8f268697e907fb3758d007dd88c58e4babc0cd0d6335c36825eb22cc66cd99ca3c067060e14375610820ed69881526ec2b585130283a33a774f551f56ae5a5025dd64fe8dc6949e0fc8c3766e81bed07ad7afcdbfd7d34dbeca7b0942b404ba737da8e4eb4b562542626d4f6eb7e14a865f8650f0f03bf4423f8b4753039ff677eec6751f81f97b8f03ebb4b3267c75129b5c8b70f82cde952aa2104d7f97b8d88b3dd68c288e0c5f41536ec02fe246c948976848c61a7c148d7d02b14a5b1a29039235ec2dbd0b547929c40eff7b2b8552fb8f18982ca6085fd58a15780a559a51debd107bae2b30d1658c28593e823eff3784cb6d8ffaf95766823add80cb9b608958d7acc57e49040dfe0755115f4792cb0c7eef4db96106088444ed6b368e63209ef6468a4e12f8ff365f08b35d2d514e75121f910e17831e52ab77ee196feefaefc88f43d77592ac1c6b1f660a055c572d4378d171e2f9ebe98631b43c5bff72462fceddda33ee8be1f0a41942cb5e5beaa78dbaacbd0d5e14c6525bfdaf6884df2d2551da6731b033430bc82e2ec0ca6a04ccc98cfc5c844758c9ba71b41203707bea081c4c3aa7269779ebc8cb6253946ba7a613c715eb8438830fb788592c1395b33b303d0915c5601e4313dacf879f0966df2d6d518c98e8233e3ce2880ae6aa0455c88fa1fa4b0a01cb3cb1854d045f7763c81a2b9bb83a26056ebbb18bfa750dca7c715390665a14faa82b4127bd1b79f7d6afda7fc3d555b377e582982ac6855c18205028ace1954b7e0d78513ddf03b1110639d3930d1b13ae904454a08236dd54168edf5be26b24cac74ab5e938cce1d7f08ecc409fd6559125d7af541182003cc30052cff563c663bfd1d1591a2ffb8b84cf08cc3b21d2203054c3fe5e72f23f8719bac9f7b734a5628e83a4bed4bee9b205e0e674985b73b28762ec8b307a528e229d4a354a948ee8f2ef428b17cda68857e74e09215e0f8287058c097e3e17206ebef66bf9244d74846ff95a93a1294dc5ebbc108fad46c8b9123b99f7e3054e7cbfbfa05f9a46e3e9cdddb1b06bbe710c45e281b912c4eefd74559f4fa66bb96ea21b200b512b9256cda4c1cbd6e9ed9033cabfa783ba545db51cad02d2bb11ba0716afaf9b7207c07712098f04de1507b5bc6110b51cf2338f8a8baa31a90ac381d9dffe5012982223b7a8b6219001a14a61c3d0966ba6e47fe1b6d603403d029f2e9d5c22e087bf8ca0748071ee04d6f12fc6d373124de5eccbd66ad3273ee73e16bf24c1e7ab71ef78bcaa5e17cfdc6852966ba15690a44080781eb1f9f2c254fe861d039e31b22003c401c45d14ef1b141eeeea501ad2a890fe7f23d163ae2e0464cc0c8c26b2bdfcf491e469883c7c263aaeaed20db8daabfd101858c61d1d1cc55dce36927765b435afa635d90e455a29772ce0d063430e7c1a6167e0e8e82e04c174155059e5ffa4d1e4ca5bbbafd0b4d5bc668381e4b1249118f6da7800830c82423294579e71af67316228bcc3bc9c06207c3282c03162870dd61fe71dd468273ceb49c134e1cedcb9170bd2cc058770c0fcaaca370e967e8a7e13e649859438aca918307d732cefc0b83ed6f3f29d58f85d2dc9e306918d4def5e76eefdf4e8fde5ee76456127efeb269cff41ff1023b119620e592d2f67ea326c91c7959d361cafcd480d19f61c14d11d4810fb2f484d9e420f8fde7a0a8dadb5ecef9c71c92e9487c93b11e644f6234a1e19662704df8fb0e814963b0d249cf9cc398f42228084eeb5ab1d5a3977c6e8304c50f68f72d2e7aa052005d8e152f7e96003652002e464285dee1949917125d86855650b3377aaf13d590de6290effd6d89b299ba2a864872cd7b26ff0de2e2d34494c8032d8e4eb64f873a3c8cf724b8ab67ca9a0a15f7e9ea35112738106e750c264b84388f9dea3bbb49fe95a5c41b703042dfab49ac50e036a3778aa5baa39e1c4da6751b6d8acefe5e89464d2f90164b3fc7e7bd80532997c7bf2a0de2822aff060872a087caa0aa814fe2f93459f2e8c70def91a7fc7ff7bf3d92cdd54ee012dfec73e243a11b3588cc5cf57530211e6512b971ff8df3b6f154a6d09a62635aa96fe78c0836bf8ad353d7b903b9d3ad5d4ca402907afcd3e7a3373b90cfd7a2c0f1d974bf923f54ec0c85ad9e7b4151647f487d31be1013b7704dbfc73ae27fe0aa5b39adb10591b10d15fc7295b19a8a12dbab1a87de91cfc0daf73b8a09d69b6cad7750beea4e5ca8ee91f6852fa8ad4e5336b18d65633d762437d850442ec55769d189f6c679e971a98dfd6f174e397b5923320a8e246619e1aebace0a36cb6cbbe1477a959be31134de850ddfb586d917b5fbfde00947276a2f91aa2635e97018fc8520fe152e1fb85d9fb2d547f0a7a3e2a615078c079a8db4dc6fe050e0290d6e23030cb0323f8e8ac2a1da2716daff6e5bb3e30d946c47bd5c98c1fc49d4fc716c0eaebfa00b4962e0d41c9751f5f91f4411ac668451846b99d8e756568d87de606da4f595beb25a0c67ca035c6a00136f25e935e68cbd9942e2384c019c562fd7253d01b1637d24c4d572ad392d96aa2eba84a8107562239696ebd3388ecac38a3ddf43bb43bb6883ec331dbed6698fbba8a314e41343ad4f07cca919f74e92720cf8502265477015b4056351a31d5ed6d6dd2912a1398d69e7ae9ad64b1054d4bb82d1132788be2fcda71ef9d21669b498f938d5caa442b6bdb0ead7f02d70d1fd2ef54cc4ed4237784d46a05285fd101dbd09ec02639e6efebc39e2d3fad7cd6e1eab5569b6228138686f24bc6ef080ac63c565f5ef487701df659d953e508558365b8e989b5d6d44aa06f86fb15803e34942acf5ae3c1d0ada2f5d6f956473be58b48e98ceafdb22a543a5d85a4574a943f1f4f0cc72b2b35355c95f3cee1edcf684f4d6a434ef5c506dac0e805b9dc1a162f00ebcfad77d7267e18b7e0801b02bb1381efdc12b37b2b286d98036b7a3eb0b47d365dc64903d1aae1c92c809a2a909fe65f566d18f68db3f805942fc5b6fbf3d7a458ccfc209892979e8eb9c3ef1e562b79680ddd24cb736fdddfcdb1e524bc762e5d5b78eaebdb7f73ac17ffc7d7c4dcee93c91f002bbb52b37f71420f86de9e5612d55e6c360d787c35bae5f043ba9692496b40244552d39a4ea7f1c92a0017e6b17e37324f3eca6faea2bea6e4c9a2448b99aac3dac9033e54835441be93eaf38e1aed86edfbfa634f49d865bf34ec6141da55c0125138f9b4468520119a64dad0cba604baff60bea0e45364356a0c64e3561e7d94e75286bbb26a4107521fdac3512475b445053234b521ed10c8f38df8c6295402a6b3152e75ed9c888994d91ad57c8f2110ece82bc42998b995178aec22ec1e830f8644c76aac97e22d16f4151828ab798e2008394b071fcd9b4bbce5a750526584058aa5aea17ebb8080393bf9cea5d33005501a0f838ac136e2ebaa93aedcbd02ade06586b7f38314ca969a561c4bdd212fd24195c8bc36f5c39bf925abf33f044f17172bcb8034821fc9425d5efd1cb858c35ca44918bc976a94c0d0b93f62fddfda1661736a9b5da235df41c058ee463deb2aaf6f7adb25a7ba41f2b70a6ae702a253757e6dfde233d0ca06cb6cee8747b365d148f29bef4ac0579f2aae607516dd618d66a99647311d22dfdd3699f1f9d22a2cdf1de3ec142f8bc853b8ced16155db07f405f764000864a3fd0130b3512edb12d0cc5e98a3c1e72226a2e8e52004a0570e239345d05b8c7133eabae83734789955373ef82b412f664588d9643c05057db4200864dfc0ee0fa31730fbd59e1ed6e1709beb0f84a0412ab72d5e366d00a69c3537a80721212fa2e0de79aea7b522e2bfa74865bca02949ad2b78186947efd3c9bc0327977e8a081156b903948fa58d346435e7aa95487141355dc002567aa0dd1ad142e109c91fbb35c230b098c126fac131ff79bd03ccfa6b65981ccb378d2a4ac8705de87c2b9650f28e0c9cf2b5ada21467a4b3202371102e41fcc179d46606fc57394f6df22cfeaa2b6bdefbbab57a9058182ff0981a37b294a3e95b6494b323fed3648a97e59b29d47e0adcc525044317713fa36ce59dceb0fde1f488ab51467a01f159433038ff9e54c3e9e759350fb7217c07605abb9688e49ff843bc15df10257edf7b0179cf94f0e63e6b18eaf29a2048dc6e1b95d5355e5ca93a6a24f5a041b611852d1e15bf4640327075b7805b87ddf323e8dab3a8ec957299f28f7a75f8b615d382731790e23f2f4151a422974bed7a919b315666806fc56205cbeb9b4d7bb0aa2367dddb2f50bea976a93f5e8101906fdd7f78d4a847bd314c6fbf66efdf23b79ecf365e1840805312acb1fcc3e532a79a9aba2801351cf226b363edb363150833a39a7f9818d35b1e195b48370bafa5827a9d65b6c0376f56a2255caebccbe6e37c5b708da2c8452ba07f0ef3f3b06037f0e131a444dcc6f404a3cd4cbfd4201276e24dcb9a2582c1118956e695164fe9d10681f84235193e8f8077f89a641f3dc81078e034c8ff62b8192736433293510da9c95a5db637943211ee95031948fb5eb9d3af2a996cbac1f88ca337eb28813c8fed421da4922f26c91a7d9c7f15fc7755bdf99abea4972896c0d78db8fdd09839f88cdfeb49cd13f252e65f15cd38edcd20e725a674bacd5276ce3ffffce039924a6ed0a3e87f627c7d8c4dd47cf7a4b9887b9d73acf81e044f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
