<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d827f439ccfc3e4815eaa7846ecea80ea8036f6befc0348e9d5cf211bfe10ab5b2eb4c8519be7dd1b92c2cbc2d9f5a3c4f99b817d56ca44c899a1de0e9c2cbb303211fb61875a2eb18fe166916980eff0a392ef0588ffcaa364cf9087788e5d6258f21c6c6ac80af2928932c273947147139a4524f71af66440c8c139691628c9b695d68e8661020f21e9389d23f8573ce084325cbbeff494727d9d93635a3ebcfb1b7494bdedec0a2e4a7b1da1220abd76f407bd46ad347fc571ad6003c3d22274261344d39ec3bea49a1f256ef799ffbd3d588b7ef6fc11351f6998a1249010de12ec93d79627929d155c3efc7488b5c2b04e18c91744039ef67a7f60d5a61694aa7cd566a52b84179ea3afa77f887324bad4c3fca412a7c8d9ad8ba8f95431db47b7eda7fc27f19df3fd5afa9b295011e2d1fa4cfd9a988d5bc8f59264eab1396ae4e5ad0cb6b01a5937f82c394b99ea01350d985ccad86c97e6382c09497b2997787754bd1167848227788912e274bac6853011f4512b72963b6ded67e08862b2b7ce98353d986cb26c6631b24c8c38f3b966a0f0f9ce3cf9727c194bab465da2abd428ef04060e080f07b75768f87d87228ef91cb12c157a2fd7450b5172664fa45e766c5e854f9d05562ca5c45a7bf6b98d8681c33a4ed08d59b24df10e1a9d451d46ea101a4f81a3b197474b2e4c06a65a260be93c17691944505b9154a7b589e821ba0d8de1d30f2fb1077c204b7c13600f5952a3cb3f27fe5e87d1669f475109b2e02dfac0690ecc7627fd9fde0b663c88d2d06265a2c76d297f0950f639e0445184d590093080736ed2f608626fb034f573fab22825e87486432d8eef33625a5e13c007d8a576b0f278743be1229bcb9279a3ce74dcb58ffd23710e7b22e0f5ef1632430fd253732515e5fa5ce35e9d1b6a2c0d9244cf6c668b62a9319050e0d9ab392ca5f231af6254a04421fbcaadaa2c8d172f96eb7252b6b8413c1e8781d6a0395d303f4262b9b8c72973e5120572af8b76579ee376296dbff51486fa2aa298fd03b7f28169c577644589ba19af2c52aca2db0cfbf42157031b285f21efb01a5fb9997bc3911a737ab83ccc64e0d21810230838b1289ea899180fbc2af4ed4e4a3e6e2d3cb62f47a8b64b8f71853a6c97309b4d809cdbb6b380b6f2ad986a9e1e7342a36a5044c38d7c4730cebbcae43a3388f882a1959171474fac06257f85a8d397ebffbbdb7f0f98f3e892a89147a6e2fa4de7674711b0056bfcb69ecdff48b96ad19c0ad01826bd00ab1bff748b5b3eb2cbdfc1cfd0aac9c32729e80ead579a1bddcf275a13d6338f83d2ee930d8ea79a2ec58d036095125dfb8f5a4dc33672027c86d0c2db28f158d2fd6853fd4c62b4b291b73b8cc133905085e3351a24e36bd0a3079afedc5efd41826d1bc15895449f29fca0fe605c0b096b695bb611706ff7696da90299db3674790ec1643046e8eac1fe6c7f106acab12a0f49cf509e157c22b0abf7bad073227e5085e33cb58ea5175c9ce63ca7fa6912b71ea7b7e1f54672c8e623fe1f967f7522a22b334415912efef33cb477f57c98b3e6925148c636c8349fb382634309fa20c8370d0764e4a3b00d3953ef053ab8cbc067a3d0d36c978eac9386ff4b3701f5f61fcf28f65e8988d3c573caa2ebd636083bccc1adfeb6648818aa4a2b1f85995c84ae7aa7997f3050cc49668dbe114132613d84429ec77fd53b2a27608b6281f28019aff6cb3eebd746e1ae6339dc4194511af17d8b24952e1583616ca4e3c0b1f8ded6415c9628915dce0915da231fd5252dfb8c5f629bf960ac1fb4ef884bbb6b63560c3151592c5c863cefe818039114303289b7f1470ba54857a9050974bad9a6aec6c79579e6ffd378d8bdf66e60b54a0cad61ed95966deef46b4a828d9966c2d8de555357abc378e4aac6ce35d8e2c077f3def20bb0a125e0f49160f8eee762af18270d6382235f606352cc7d41615a8e4be28b68f641b7b6f8bed930470c6dca20aa3a18ba558c3968c1244b828791ba26302a2736b0bc2334e290b15a2355d0252cd6e1885081ba7adb8741d7acda7e1ae43fad3e9674ae7cf8e58c22406991dc9326a27d71d8a476f0a0adc748277b43d491a9eef148a18ade24dc4eebf9a3780f65f22e80c45f9aac88821ad5e956cb15154f66cf3ef5ae53e60877ff66e8fee72bc610581c671d7f55875cec7ea38ace04fad594f99928ed7341afdcd6c2e419b94201d656779558700c1757c0153cfbe3d6795c16266ca4f7b5065345e05aa3a7c4312a651779aea1b2d6c126b54dbe3a4530e1184c20c4a6b3c190dee21b571067267427f2b17d0938fa327d5583280d8a89bd76786da2ec2dbab383fb1f642a8379998c11aae50f13b5ef91fa599835937988d2326e2ba9fc552231ccb59b7bfcae259bb681e0895ceed46e465a36551c416b61cab9989d8396d73ead01ada5edf8f7f6b170cb9e017007ae798f8cdbfb2b000c8cfa7aa480d374ddfce72ea1db3527cf346aba0553745afc4626caa02bddd8cf7098cca714b43b63342abbfbf797e5007f0252e3dc5ce590202753ec1630b46488fa245be00ac8cf6f9e3d854d1dd72dd3e2cc1285be2d54e093afd81573dbd18eafc5cea2376ab454ee2aa97b1070b5a7084e3450de3f7921d10f9bd40cab1a8c98e47dab7eeea6e783f1c204c3f6b9ee7b11c82372bc72c53522bb694d0780967db2913ccd5731ba33a7c663de81e1e835d190158603e75c7a3a4e1d82c883144848f5fa9b56fd34ce5f345ca62f3d85cd880b459c79c936949cef4bc7e589b3554084ea0c0c532df9a831c1658d0f613606248915c41db82a13a64688ac64b22b0dae6d81af31c8921e916690015c04436c6ef26541e03e185f8e7fa4a2ebd54a0a69774dd28d69ba2e9efc77a04eab0ee114a67ce1da8d647548a69f730c4f611bd54e1f6420b1533bf44ec81dbb5f865b7b2213d6f71dc066ed29e749cc6094bc4098682ef7a4d289b03a9b39d0f33ed3246caf43b7355dfde7b4e5743a35752ef5a7d3934a02142da5a98893c3e356bf7c9c9fa222cb3ed94c5b289b8c36a9f86581550c019842cf335e500a425d84c5a855dbab794a37204e3b035eb15eb6df1a6c3d2f466e5830c3fa45688f2fb2fbf297a989f15df47d0294f041f118c541de37fa72e6861779899c0f13428fadc931b18abf3b8550ab7622a931a44eb723e74b04a2fb7c0ea0bc9ee8c27074e80ef24cbee29eda405dc6ef6d018ae655694a4229befed7808a641dc2d64f4af21f8625600d89b1a8d571d22cdcafc28cb7950726b13ec8faedc4eff7c0962f57d7570047c9ac8276d91d9d78ccdd126f746d1dc77dea04dfe9ddf99f1f01f7a7636e3193357b9ddbdbc06e090f11e84c26072c6dc0c628a61df6d62c108c1c3845e04586b0812b1ab290835f446cab193c80e53fa22e680ef814eb03a1b7f0460059728354b0414a77d7291167928f5799e28d7379a2da576998f5b1561c1559f330ee075490b4f9be66637cf53dd581f5d1641682de808732a22218059d049af9823f844d027e9a53652c8f83efd5fff9ea98c269ba5a125470e43ec229b8d9811054fb923d10bb993e1c6c1977d50bddc1592e487879d8b150dbeda7a262ca806b0842f5255b44d70fcad2954a82e29b28b35982e520e5d482ad5163723023fb720dd6bfddc961bb1d0a4feb73d19d7192ba38e1b610d3b70909316764b6b2aec7f0b06aeaaea85584b3dbd16dcdaa51280599a0f64c32d7f11becb6ce02a77d3da17c19c62075db9d7c292832f99161bb397e0ce7797ac26605f4e47b26a334c6cb52fbd9c7c9c692931c10cfa32cc621ec98053b79fbc582f73ba6015dfd76c9d3ac52a9c7e0c4b3785ef63bc0b4128cb5cfcbe834895537735afc01b031669f57f6425177587157d8ad3127c7c60c36ccac2b5953ac638e9d74c825e19bde2b9f348b604a50bcf216b380f5bc92cfa161c172da59354644dc08b92294ff7a9e420d532877772b654ddfc7bcea6f85bc9c19c4d41f34defef9bb8dc0fa54b94588e2beed7244c2e5227c6c1340a4c13f8468f401f7f735189f17364764cfdd455ba3f033730019a82949a86ea49d5e23f7cf50de5d9fbc2bf6fd77d7469c97ff029174b0b9ec99316403a168fd6ef2d06f32cf39281c8eb522bce3456e7a1c6c3f098ef4a73c3e5243a6a9f4615cb22e5d23c2d664762b2b3f3160bd83bc2465cf47248d5b6d5add7e65131fcaa601e965a41d3c405a050631ac2cde983224d7f16e93b9311c3505f8ecc2db23257de47bf5c716bb41f565f6dd634d7a8eb14a06de29172597ae96ec38ab8d44320126ccfbacbae6843fb4c85054c58155d067fa4447800ae622a77b1ba457d8ef1ec9bfa755c7eaaccf3eb23042a55c49b6e5eee75292dcc634caab346af92a3b02634535635a9a679f720ec71b41cc2e87b56bd9d08aca679179f6cbd28caccff18e944cd74d62a529f718b5b8362536617d13a240886e754735c79d74b11172b228e5321a55d99dbfc0371eb6ffc6a5b07556d0abdb1f257aaa331cae0701461dffc639617d88ed84323e22abdb643fe10e20468f44a86b8c42b8bc2bfdfc564d4ad8acd2fc26b7e81c7e0cea45821c743a95cfbfa39f8fb87f4507b797a25cf9a298a5d791fde1f4b2dfe564e0dcfacd4a6393baeb8ac9e35ffe92fe62e920e5846afdd05fd8a77f2cb6f480b9a2d34da9376464fb8fe25b2622f85078a43c4a7366bcab2688f0d2ff0a36f08640878e0cc516abab807eb2b3e1bf5b7420a9c943969a401476838d39976cdba98823773cb0814e7bdd4823eff01c590b8ba991fe6f3cd8933bbf57054bf9680e346b067104721046692075ebae0f78a0f1f899d8d9816315619e0d93365c3a0d650ed3385810e08fde42ea0250179c85ef1650e443c66214eb7a0f53b7b4aae40e18c7e8bfa674c29e379ea2be5073f59d75be4f3e8b76ee5a1a9f462ddd9a1ff1aa0bfa68786815868882f3061357daf7e65d63485f243c73ab857af85050faa69dfe179432c75ff6a5e470e7eea8e2f4bb4dac73e18e500f6ed23f0c239bc8fe3f3b6e975978378797eb92a5dd1cc49678aee9b7f12cebea3704db2b4d1b40953fa78673aea84090f886d79175e3491ad7acdc9472b1f63ec8d4075af72005edb04c91b6a88b67a77407f674545713b9428790d8b283c8871d09b256e472cf2a81e2413610f5a58a54a8e0a708a3a9f32735de14eb9fbd9d252434407d72bc92bb7f53f1727f1131056fa0ec1c45719d84a5f5372bfb14a7fdc0f4be4488f83725e6d681b26ec1f8fbf0a9cdbad3ad67cb7334aba24d31e46b71c27c0a9f971d185c604525b04a0a87b04ffead9a7032348865234f8926f16ed366a6b6758333326e94571525eb0444be704ea82b2c70c5ae902f5b786d66cd1399b0431a5ff915bbb74c2f8145e3654e6795c08690f1c52e50263df3ea4379017aac33d38d8d6e480f8dfee28606cbfee34ca92d76bdfd051e49c67508154097938739267749a8b15fd43ea523b7b8c22374569eaf69ff92dd3471f8874c39c51dc3d1fe05d0150658698011a6e955b9975c7a6315510c2d1181598b3c1b5ae0ed54459ca8260e37fd9ef72799632aa99f2ea972567c340a77acd7c0df251c2ef247e066bf02439bc369bfee7c0cd8a142c6477608a2a7a59aee9b24021a583c10d408f3c278ca69563b35e74f931554335a582292984108863d34327a871b0bb46b1b5bed53daf429c7fb02a8dfc20386b04eb4e19be608f7cbfb4cb732e40893bf5da6a55389919c4d8e0a83363ec825f9007457e69e900765e4b1bdac144bf50be2b9ffad9f169b87a8c14fed749e2e020cbce62060786eb1c1440eac2b1d90a00f7eb96b275c9d94ef34c3b8fdea8277aaf90ddb39acbba5dcd1c7c455537784841bf41824aaba46d35b95555ca61734c1d01ba33e8bef4a2b21e4159cf04100ef118902753ebe3a820c8eb90a775bc3fb1c707d9a24319c8880a22bb7a0f125a3f6f1b140e065ec8de3d492aba865b832d8677e6e2878e1701cff4710fb57fb386a272bf475c4c5e2ea9eed92b8ac4c66b781ff3ba6349f7c73865618a97b8d277a2d3b05f33289c0a75ca7729c1cf1ea8959196e28f8972e30a1bab82cae6b2b91f1b96440330f53e884d934a9927132be6c65298b16bd1a5b135bda49de91b6d6de5cd937a303d3cd3122328b051c58d89d01352c6520c6b0f2dad0a27bd0321c986821800240913d89d5950c0d1fbb450347d6ff69f962e0ca1adefaa2563083a211d3b76414e8c5e4ccbbd665188c7984d723a7c58d703ab1c944f5d1e2b86a6a71c517156bf38dff86ab7d0900e7951511ebe299f7a534034829c2b303892cc9b1149ffa800e64a49e25ffad5bb6d504afc96ce0f316e8687a0fb5675b1a7f927b6705d09a18385df741c358797ce7dc60b246180b5a1982085012e95750aaac7837fc51aee8748ac68abc0e8dea40d6564051f313365d986249d3015db7e667c734d6f473b8651be0597ddadc500a3fdeeb492c47452e16cc189a3587f78e1b732e6d29f7d70262b603c86772aa1df9648642db8ced8027d9e29905ab3760e4e519201a0c01168046ba0b615410cc246c7b56c345c796129590a703824c6f163b06691f6b14e40547b96491f88fdfff3ea7d6dc15120d1646794b231a80764066fe039f3104ea054a6600b4b3bff01486ee92dfe70ad482a3dccb9699c269926d284367e0c4f2f955a226bc6daffd11c185d2b11c3a80d67c181ce9e603d144ce630eea2abc3d9af2742cdb46916670b899dfc37a6f5289edb3a61c9442843a10126197c0f52c3263acda31da0d5a0b4a1717b6182975179e8614dd3db0403a6cc1a99e9eab6db14029e12ea73c96c625c004ec16412d405b13844c8a30756ebeca3037f8493ca782c035ec4fd1422751e96589fbfb0e193229d6c66c22b8603b266ab18bc1de1cfce068101d7b8c2303267802ad885c29e7978a18a91bd77c1763ddd14091bddf956d3c335dda770eb394b11e6ed51bc064c94ec063b72b703125160e818b9f4a19f70ed1331935f58db4b57d011a48523d49e62da1bc7d7fc03d49b8c673711239e75753d44bb8f9e246855c50f7860a69c614ab37754c58d1050fd108a927d72553b9028f261b3116cd22b4a76e1c83c19ebc8acbdf9fe08f1cc83ece99c8472b1d8454e2b3f066611bd6ab88814ed5e8fba6c4960ab44e7f1808bd41141851077f53b643c8703db73d1f692cec4a7633283cb3f6bf53fc3a463bfe18f6c22581c51fa36da361888ae939a8fa2b45e5dbe3ea11cdba9e54ad92efa1592c812babc1a3f66fa4cee8c5a122c9daa667b0131c995a173af910bdfc85582dca858a9de683f0f5b211a84fdc0010a83e2d4a39900743fb034e773cd9d0bdbe99a245f75b63ff72c81cc0a73e1426d982f0e18b736a0232c28dbdcb1c47859655e5cd947d6f375713c0bc004c95f8d81f207f8fdd755cdfe2834c8373b6c0ca05e7dfc28f84af9d730733d8303c430de857f58b8a52127af6dfde4adc6eb802e5b9a6341f6ca71f84cc606569fe40122ae651e55a658a56e8c1fdd0652c1d20db800d957a7fb118b1ef3778ea941e0a9d01f2603186f739cd9d991f8500eed6525b38e8de4901a7cb49529c720d80e800e545a732c89b62b5c4524fdd47f9656aa9d2e42f6c77f327cb1fa62d9a6dbd32efe40b6bcd893412e582c4a74ad9c5ec88bb22a5358d205daa68792be23499ce5d66ea2d203c87d61c058694905fa70f2a3f1866d7f106e0d224afa1078f15dea7a8914cc6fe0748a524fb898cf54f04b5319166a9c399f55d1b7babe78464b6c7f6be77ee880834e0de5a015a6c89d8fca727a7742f60bdd9227751a268549897f6f054f55d578c40ec99e5e6f8e2a373ffd2fa27d42770da966c222c3ba47eb6cbb2246bccfdc7356e97d56f3a9595c49df0b392c7fe03df53c4fcc51b9a836d3f638f52681ec2a68ebf1557c4d31faf5917b582af063bebfd8473a504cc8654edb71b4f8a99818bdda998cf707666c40d0fccf9c438cbee70a37d5c738562b00dc5dd33f39ce992055a33a29baef0e1de4b7098d2764f2c8420cc4cb09d5607f7c7d40a1c02a567db2ba0eae24b51f58e21a1a82d544da53f207e0d084791143a2bc2e1a7e117cb29a2edd69bbc173c661ea231aa4ce5c4b7c873592dfd546eafe7972714f73dc12c410c953460202266880c92ace7390c8d352eaf7e278d8b3a7ba830fa19a22c48c0d89a343c421dc48dc2c987c95ba9978d30d66c873b75a491a7247b0ac9c6478b3e3abb97df6981c2439284d4569ed233d265a01aee0c63351afc25166e7dc356ed234f14b8dbac900a7680bf03b54f0a7e1076b951434baff1c5891d19fb75190e38df1fa0aa6f2762e9ba837835365a7f4fb50180122102020a5129e8afec4ebf3eca27f8de025a11a53ab656332245b0fa4fb8f3dbd6aa00c03a907275f951cb2c91950c7b9896bbdc2cdc297307eb4e3bea763b6a7ebb573c426726506ffea2b153415a7058af3da810b1edb69f89b77b1ec6db14fcb627842b46b83fc62599c21279a93c1b1f0dcdd21a36db3dde7ded6448bda899612f5aec46d9e9aabfcf46d569c3fc0ac8f69834e0046230ffe74344669530e4a219ca9a55978a4f52f0e176afa988337a7e4f3b6105af5a4abc007851121ac73d881a8653d43a3c2434b4e00652132c4d1c680895956c8f68c8d4fd024288183fac76d2a2b9c45e78a6ae59153c1aeafbfe7712a97bf19d2a86f1990a1a5c7d27f1a3f5522585e4e18b4307222243b819aa246e46494a3a0dc5d5f8d26e9e31005a9cc958fdfb01815f082a0a3f32a8299fbbdb538a1752331ef49295ae30c765a9e66cc988b9236d4c256aeb612361c86f2831229a768b71e134df1547e63b38553cbc6652a0b8354bfc60ab3910f263b56a9c8f830eb16b74d0095bcaa594e2b40c9dd536bfc09e13d9e2c2abd9bdee9806a3ced7b6c6722eb92d4ae1445db8b171d4e81daf52ed35bbe58a20e04373d9c8e578b402c4ed11e1805c7756bccd91b53a902f48d3292304cbf71f02e897411415554de37a78cb78d2923cb706ed3c86b454fd631d8b817433bd5e6322e33d1107d8a509e146f936d88b6b629871fb5a04560e681f6243ce204bc054e39c75c5fe8a5606565c8c9dca6edda54137a5949e6c62901357397e323fa1e0cdd012f73ff5c8e003a0e560531cac0f44a907ecb0e60c1289f6f8fad2540219348594c7be6ff853c5a7c243c1e649b0ad7dcfd3cf5dd461c8318db6a991948a0786fd785c5bd19004fb0c3c502a1c4a1f0b365f31976e050a0cd1ce03d1b36080281191ffc5d8c80a78a4076e125c82a814068256f493f417d34d821cabf9a12be4da620c882bb1770215b50c8fa04171450dd0e9844569d78966363a2eaec321456560cac7dee33f97689815aa5f0862fa092392f8984652575eb7647cebf6c17a8728cddd24823b33a289740239a461b9d848783da87e51067de86e6d4b7d11d7cc5ff687ef1adc75aa6b0ee222911041abbe66030ec4a539c437332948f4a29d67e9e9105e7691be8279dea6f838796c93449569eeb69d8ed17d19e1bd20172542ba765b6c8e5267680a91b1c9bf6b3c72cde5db39b4428e022643d54abf7bf9436975c99a93cdfc809f2fe8a0256a14e0dd8961aff89c7f9d73324f009d4d05ea2d738d18727dbc3ebacd2f0c3bd3970ef899931aa39983e071263c0d9326b89280d05847b647aa293d069de01dcae175f5923c725e8ee48f00f21a518f59a6a293556d9c3cbb969252a9ce316d9892e4ee9640a84d581940c40a85e635cb27c470e448cf13ed1b1887865fbecc98fbaf2e584655ec6353ebccb8c8a902cfde8151953d103c9931b99dfe28d58dbab341d582039cb52d37b8bdca00bde64e20a2564bb8a6d376b4052d44fe2bc69a34505a3d6de0b30a66d52a474e7434b49b7b3f86d7ddf9c0fa026306f9acd29dd458a44f75fcc5c38412be0d0a9390a26241ca6c53ed628ce85909e218cdb48d006e0ffe4d6598e2eae0de54d37c13488a0aac50e5015d4084883b838d8aeff1627410add98152713015b222562f62c5544550c08f9f336feb5e348499f61c715b2be9769c4045fff769e4f3c21267ca4b4106a41f1a8efa448de5bc61d32a97ccad2d81887b435db576b755bfdb01e0371b14baaf8fcca18d80a8696eea1b2d77b29449adf922bf597465770c1836752c26ee29aafb1963eb01c2ddfab2dd964fe21709f94ab1339f107ef4f2b5cff4e312951d51dab11f44c762a5135506eedae54c272e1c9043d6b426985115c2a39d086949aa340b57ffe9f769879b6f6b5b39f0c2257a09e4513676b2b8a24dbd4b1012b848b5fadf1d6c385e1349b86d630470300802c871067f3a1a6636237cfe5ecd42f7d6b34d6c1a37c44f8fcd73d3de7a423dfdf70283259664b9f253764f4bc53468058f1b2d0a26e9336ad67d427f51dff34a96b8ccb574a541a9e14cb1a628acf7289b000aadbe645a1d77a86015bbe51010e3750492b8ace7d1719917dc27ade959c21cd774adde821fae7e12d4b82854d2299a481f2d1d02b3f77ca0cf88ecf2857cdef2315ff2e65d8fa54c07fb25c1762371626be5a232ff6bb8920fb943e1ed0c8420c390613bb8bd064bff87b2dae6ac96c6a9ed1adef72a20f57b8c4c31c0041a2f5b8ac7fa5b0b3d9c3fed0f45dda61e629fa2017bbc9e041745ae71300200352a50164491752762bce6fe2c474104bb0f140557e514571d6744b2d1dbc419d4123bf31bf9e2edba33597798205940a64da9be0cf52484d9962b62b782eecbda2f22f623cb7dec53394b15b40821bf8311e8f9aa837586d04e9368e5cd7b9fd428f14ba34174b851dbb2d6498e14fc11d8250a9e8c2056012cd5e285dfc6ea617e5ff8ee2c01c5cba21f15f120d879efcfdcb6beabe40fc8be06136440c06ee23ec5d0c1e178aa0a7497ecc7a27c06bca1dd4748b0d0c65aefc42a3ecc2c41d7aa143897c8bfca9c47711cf19a4a0f623be65a99c0f8663f8dcc1f2753abacf8ecb1cb52db0a95e0bed2a123eb48a0e8b180d8eb35a5b48666e6c32d510077f23221a73420a0229a08984fba8c6e991d5f61c0b08fb05013377d1532dd96cb51256882582d0fc53f9d5eec2c01e3a4b46a2539f75694fefafb711c6570638afec68f9a0a548d9171ffc0e36710da52d186a0d0b61207833229e2843c33c75ae64f896ecf95513eaf0afe6d2669aa0af2b63f7ab110bf99d717942903e8cb20a30faefd59c5bdc4dddfe12a053f92f7d5f907418de5f239eb435b08dd82701f87cad43633cd3e8c55db18ca73d334fba1cbe30bdb78c7cbb5ce29377ac57dc3545c6d9be12877f3b7812b1226f6df6536553aee03e21c322d73c541c926111b53dcc776e4bc5bb1567096162238fcb8e2c2b62b512e7655b0caf12143d038b2f932844c2a700cb6709e189fa37b69f6b8af698eabdaf407e8ddb368ecb844e5dcd05d66e76b73c0bfbe46149fe5baf6a85d45554fb1319abe08ec9a58314daf674d01f0184e5fb8e7d3a752d9f5f6ac617168fc9e79593173e35fed3858455d4bf7966c9067c1c117907baa6c9276800fc7b6b120f28b3cf401735c06792584fc0d5224c9006a3102762ed2909d47bf3aee0ac01c950e240e91d2ae80f785c0c6ca3ecad77ee599c096aeab740013904343022559b5422fb835d5345c34e288bb78ee6bbb5d2c6e3c27215267c743ca1494ab2c6b6c5179e0009fd920b29fe4096ad7c06f402f50dab1490d65c7c46cab0cb9372a5a906d6346c98faca5cc451ffa3e5be2abac32b4ac94fd6b41612a744d56e4d05331c87b6df8e55f07caad3b1ca414a70fca57ad0b665db8b99d14058c0affc56f4cf762617d7f798710881632e9842cdc745028a96c191b65226d85167262093fc94fdc5a0f56e41e1ed5ef42f1d0c656de7094c5be857b6cc704d04da2598c878bcba2295f60b0adda6d21d9e84a188cb6b10f819edd6b80954a17c3dfc2d77e97f3017926f606e3e7343b7c63a5db72d0e7797e0cf6203bcdbb56f534e86f35941ffeeeccc7103523bde4620f699630059fece9efb97a48d448f95c68a1d98edc2d8e48db34996e9faa65e0bfabdef88977422368a68bc14f42dc73c4e1b3c8a5c5e1494ffc278001af55c2d16f03cd0525e1e348067c2e58e05e01e23a3428b837f29401b61121fe888e3dd4b5ec0a57938df23237436588d1b782610dc504ccedf45dfde6806336ebacd74f089ac588844d4908b716fd3703c44be44b7810b33a4d2d04101aad756d8ce28325c538987fd8449c2f2f407c3d422866bb655232c7e38bc9d9383564ae70b1668632203c032b52461886f1ce473f626fc3a5ea43c9eb49d0ffb070c045b4cb6c9a9006980ec6e10cf01e07d61dec93bdd9e5724bcc729a718df08dc71c7e4f59f8da3c624065e90fd846561184d03e939f6dedecebfdc9300ff621b3507a342b8ee5be10fe57c4074abb994f30d039303de112ffd85f4abbfab9c10c9570ba780cadbe336c83b7fa4f1451cfc7372caeeebcc110632586245e660e19110e9a7c61559d8a0305351acc566ce53c7f868a9b150aef3bb7eb92eb2e38d741fa5c56152e9f431a4bbc7b6ae117272e9aa5c8014cb7d3578f8d241fdd6341eb8f73e5b14db19df888de0a7912db1900d3b9f36ce6a38281c535e5bcaa30991e2715abcc06cf56fa4add14b4024152a4e8220be75d4c62212e4cb7d39e11caf90f4e7fc065519e973253c81f030e6bd8f2855f64dc7d6cd70920b07ef83882bfa167cc04d6791991cd0cfdb3307a4a4a3f0a1bb9d1742d15b1e4a3fd7a330ca5d00161d4857e0a4b3a0b52ffbf3827e8c14f139cfc42195ef5d158a79b1a26e35bbb327f3625f08cb56f5c5c650af6954bd329ea680909f780650b81f77d2502f43027792dedcad5253f3e436b9d435ff9fab02f8d7b768aae1400d7dee109922435aab78e6f44be36c96ba31b486cee84536d51499536da047fa9be1562e135a9e2412b760bb97eed432e5d48bbf3ccbce2797e273e0f81cc61402f559ebf9e27768e98e6045bb76c7cd13b51e99ef512e6fcccdff3e5c306ff9d3bec7072760efc2e94b878bd90a71dec2eab4507c4b122b2f728d1e605ed4f81e7ce83e0b46dd141d62e5fc02306a513f6b63844fa8e09eebbfccf607b413105a20ffd042540b2e0d2c47a7b8316ecb452e4c0689108e40fa1460a71cfbb91a44b847091e344006577e68dfc949944f7effc60d6419de9a054f0285d4760fabbf527dc99a6780e71d803b58916a7743d7caa8e18ff9f8ad28dbeac0a23ff9359adf72101e7f595a5867a1cbe98ae64f09d0f8aef2d8087fb6e5534e98a1816230f923c71d5a52f2fe90e3a7a87b1181f39814ac6412de109d726bee4de91e830dd18efae9b955c79ece0efe73b3f82f417870b7730eaadaad126e059f2be6a50b10dc7eee8dcb3bc2c822dd9bf538a5eaac45da7974bccb4066d77fb63d8dbbe6cdbef9a4fd5c72d8e558162a51846ad03795e65dabfa25bf760a8588c36880259c0f13cf24bcf0d4e2e77256a749737946e6a15d7cc6f521c7e0ea7ba155b4cc023602fc7b0b48d3f2c690d486ef90818164d1df649d018a4914e516abbb8158a9a5b2a954d72c0d0c2f2944cf8c45d652a9e44ff2de5f08b127b6d78bffaf105e591203dfaf8b852df335fc659b57d5c87e4c3df4feef10c229098d952e45027ad32ead99e8895ce8f138352e4ea60e11deba63bec5f4f1354e0a2f278ee7c80c147bedf9fd3f73b06d819ceced5d78d76717460559cf2987c4eb56715b229e0720bdc54bf131044e1d6ac76a022c71639a6bd0189ad1d25bfe2f24dc9a9fc2bda849d16bd1c8dee701f0c272de0644c17afb474662e07600c8be6636154cc1a4abc52aa92b4796e5701ff974d913d2069959aca9a9b7455e99f06ba07f86a99cb4330cad27d8238e17f932aada676588c271511ee2792e61f36e32472ea1a1ec8322a2c0af3bc04a2a75e202efe642aeb55a42ef7cc109a893caf9aeccf3b4dbff57ce70e8e0dbd77515e727b34c090230aad4e046ce1e721f23487e36f977dfb0520199e83b27d9e2efc10c5927330aa0e21a5817cee72b316ae134cc1125b31bb2ccca23381d828e535cc4f7fd1defc8c92a00bdd1439755847a2610a73da218033ed2e1cf6027ed5d32fb5147e6501c6dbe167849beecf69156c6ce71dafd92110c6b35e2e23fec75d2195ad7a87e771ee114bc404b81049e01792989cddc65cab808ec77bbf673cd070f9fb8fd759205b88a6a9ebd495150c8666bd017661fa0b4d98d1f280b837d1545567f1aee7c912a4c4c3cf1778c9bfed92bf89d014a748dcea3cf600b2ce8e6da09da6ccd8ada6b0a6b8240cd21032f704a2cd57b9ee2238ae9a01a84245c99fdb2ab3a98564072ed18b66bc7d8c562e6f1cc33a4fcd97b313055d82ef124bfd4ed5dcfd4e0a9b4bd5c3aa784e3438ee77871ab44d094579c8ea2ecbc74f799f8c81381591b3dd6aa60f0905a6887cb799e5ed8c4ee1ac1f52d6e39aac818b5fedf2c402599228ba6652e38718cb349a81a10a1499cd0c9593c7d332d896a11d150cc61fa1840a11231228c886b350d39ca2604f7efac68b1e88552369d81f99e856e65ed79781f2becdf323fa3ff0bb8291a31a2826388ea6953837310e16f2ec9f063db3f73fcf8628173b6c558f4e1af57f41443874bd4e77dbe69672a5ed3c26815cd6b8b3b26a774975848469fd45f60319c44971bbe535ea949a17fb0b46ad5ec24fe3a1ed2f8478c678efd8a85db20c435dfbf2d00f9fc89ace8206069600eb69abbb8ad0426b88fd4d34ffba8adec2f4acac3bbfafcda1e2e93410c31de2d1a3b30a4ee5493371da51b1fe4b86ef5a8bcb99d55ccf28330ff71ddc32a04161bf48ee6660076cf6da257f79048a74a2eec399faee144ff931792f1fd4ea2b405094b505a4a8e6ed2e9c88e48414cc4b51f67257bece4aac0dae0f8bc33bc7da39d825b1ae51e469f5bb96b4e241ff16fdf5f46d07dc34769a26d7179342f1638d01ffac13e8ead649a337378a0ee2f5898949ace2474344f1a85b551e5521597131f56116e449ce4c1424718b5532a501c73b85f7cc28cd9400de1a6e5e7ac8f70c13a326d284ac1b76812c7b1403e297fbcbc649e5b9e408b14f467eb1eb3821562de620809b3b5ffc960fcc62184fc39ffd7bc96986a847e31715bb29d368ba7e9ec044f60dd430f5c9e0bf9af07318d2441fef34396cab23a5883b6dab3b7329b954e6a0d768a1dd047e312dfe43e107bf0166a7b22affaf3ecc7014ee203f4e14c1db1dbcf510eaaad2fe3668ef63778f062de48a155fc831982d79ad297c96a4f3ed9a1cb36f3064974062a8ef9d12a346261b993a6ee79e71373e636d00f3b191b10b411e959446d2bd019ae30368b98b763a91353c1ab754884aa42ac694b9013aa5902fc71ceae5be8145d2a920fb3a267cfaa31c404837a12bb832a7a59d07ee3824bbcc37c8a580dfdbae46e7eec794dfcf9c2a5105de47e0fa289643230fc0bde6ba4f9b923074eff9ca4ed5cd8eb9b0df91affca098f1cb3dd895cb628fb1cd4f2f009f4eb5f76e22cd95ec10b22a71ade65a55af7e1b88bfdadbc5ecb787b67c4325aa83461d03798e7cb3d361847044a8207ba1567ea770c1473fa9e1bd7cc0dc8a3e852b8863821d433fb8d0cbc3df7f5d70d4dd84e20545cfa57f2f2a31b466541074631bbac506cd922448f3825d6271a25086b140c6d51ee664b73d1cd1ab4b4d1b285a14ffa9a64a3c3cef32c924bcbde6e7f6fd7e1c4134be88c01b15a5b2f8087ae6fafba68f8eea241e8c38f4f2ae5d828dd5eb3c57c4317ea4fd9342e67e11f3a0d7312cf7fe099a279f9abf445ed69fad4218a0f4660c8d1d7e28793e1cf7e0a6c1420727c95be5430793a97c4d2925358064171733db0d52c0fae5c45e30ca542c8634303f772c157cefd9a49dc106b1c2e67ce29791f0e591b9abc4cfed13db14934552b700760c91ea90b1429ff3fa6cf52f2c01d4144b2fa5a572a90c55dcf4255fd39f916008a19a418769355379a8c6ebf8e14bcb4ec1c1babec6bfe5f2c9304a0c627bb9027b5caa97a79bebae2cda97d672ceaddcfd94160b8bac38cfdb3bf4c7f358b6216dfc907ceed823bf19a54154f271844a262eb63b0ba59cf06688624777a9cc60e03751675d1cc4d7e0982006878b30a3ce2f666293a846c0dd1591806c0b171bcb98c3b6f287f66467e584c22f6acb5d565cf04afdf315afbcb234b4f059867d7835ebe5106db7d7b2d74d12eacc8df2283a9211938d5081310476c5ef4e437c80f74096c8bfedba2aa82fe55cccea225c5fac875b81d9db74b4b58a5041df37986c7b08eda1e92a59e79689d78a1b633280f7318731338d9f83325ef15248f3bb7d4582165a86aad1ab0251bc8335d60f7c7a93b43328b0feea9cfc8b23b477d3263b55e331a922098965208323e2b75324c9ba1c4e113aafb2e7ea4eea78dac447b59925a4bc4db77b6a1e538eef00cc14f33d81995c2ca009e48c65cd5a6ff392d12ff48adc8ce01e3c5f5df2bd76d311baa4888000ab6b922f1e420d7067b6a1352ea72eff9c3f371948038565b5732de511458ffa8955235a75811f4f4e90389e58b6807367ed22f8489cec20619ca9659dd46161f2f55a0ad359874197030925085116f5d5583b01403a98c9547879659f485ef7ed1cba4a3820edd8d9b76769b067e26055e2b38f4ba2d60320342df0d9751a2fdaafb035a84ddf8d849e86ff1fba082d9ace0cd27981f8cec5b31939e0879986492fe2698da02cc98afa300d26693410a523678f53d1391a232dd33c29463db27b450a84241884ccf968620b1f30e9116d67f92ff4ade6cf611dcbbc9a9cf08cceb0372864c3b15b1bbfc9bae760d51257ebd5b9dcd2eb47ec5aad8882dd75a6beeb7822fc3f3c19e7255eefc680a6ec7d33ccc26da5cf1c4380c7c575d6f43cb2bf893c8181f0c730920ae73c86f5fa1387e6f538edd60d4731e271151b9fe8e1c6c002c1ce2a658ebc8df3568043194994edf3ee24d18cb4ec646a62360d2471a1c52858d86f73a2adc32946000534928c87bede319c3b4eb5af11e147b234d5bfafa8214f3a07fc8cd05aab2becc9ac387cc580bc18e1839e9aea6d5b39e6aee39331986eb2f092caf1cb3114d93791309dc20ca17d58eabfe287c32f4fa290dcfaff3f6e00cc83fe35bfbdf2c63330dc20af1104b48725cf9e5e6c91e4743779cbe6dd6673881934b933372d95b914acca03946970e90a1089f3b553d9760329f7ac6a9d79a3349af86c0136f1a0f7eeb275d215f97abec1dfdad6503626aa9ade204a85e9511312d734dd095a6e398e106cae8cc98204adf9af302758b772f3e2f661305b408a3b1ee503518b3f18792325b4bf6daac7a8e9d2de74919d5fdd042dc35e8ca528968d58de2edb73bfe87799496b82447650dff3c3a798d62cf83d7e36586bf6b4a81acb67809ea8dad2b005d017820200bae7f125bd210b2aaaf21749e6eb12ba0a9a876e058e7d6d6f16e067439f1031b53f57b28c4843b1845bf5f4d0c728fd1d2f8b97b274ae298ccdb0bc42cf04e24322588666aa1f82f67482d9b74da6892512c299826ef62b95c8276f1aa689bfdb0f8fa599a7a09647944ebe259a428a7cd879956c5b9dd37c37020d619a21aac490dd4a6438a8c0885b1611a02831a056ff7d6d76770c4ae20329c8223183b95292588dfb9be1beac15ee9073063f639b26171dae1d981111a9b163c7ab8806b202a28f2137b8dbbfe169d0df8a4eefdb4d8b917d875a814744b5c24e1235f812","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
