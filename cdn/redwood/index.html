<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bfd2dd54957b876814810daf899da98201b31bd934745ec71f69884b7019421a0a28e19edaa365ed97094f04ecb886a5f447ff5e200475b1dd90d582ec162ad0f9635972c7124c6e72454ed811f8f55f0e595a27445feedfa8f482464c19f743ae1474b5e26aa5ab8b2115aca0397c761d9f5a2288ce11b2d81dd426bda4fc73277d0f63ccbdce0e6ce6de32d243be15c78fe54cad330ee68175b6ae0b05286b1eafbacb9706691fbcf817840110f1fbb0cf70709aae0b276f0d48653e648beb2d03de198ebf5eff9242bceb663eaed9c5a21ff27b60d586cc3c879214315063119db35d6c1d2b1c53bc0a56ef16ab4e67a614b37dd3fd0d8b797b54e25025c187a4caf141130b5ee851c1040da691d09baa18f69641d726fbcc0649f316b22fdbb80194c3a7eb91edda260b2875faf2f28f121a1284a79232daa46b1ffd1c2c1a0f7775e2f2342a6ffaf47c3ec1670cd11c73d0dc6ac4f719d1b736bac55e8fe2d76a0850a56ae8efb4bec8ef5a344fd7434bbb923c123544fb09111652a4c146bd5caf42cf72a322e90bebf418a7104b6a83028ad633b397b93dad15c43c78829c41d946f602e9235fab85a9a1df977737f47dedfaac5693fd098457295a0d58d90dc322e175fc358fbc4efb82eaa7f863de134d2171765d5fbb34985c1f290b6fdd06e6d23e0d67e03ca5e99f3155b40301e4b90fb9d0a054e14078f34e4cf08b8fa7fbd80250911f36879b10062d6aeb296249bf90bc43138d3824dff26ac605fd99226972619df53510949c1f2fe76bd24ebd7c091a020d076dbd5c81efd4f1f430d97139f3759ff558010477444392140510624da9c8870989f956dad40361b69936903270348d42cc44ce13d12a8402857f40eae4b77025ffe79af472017e1edb9ff2974c19ad363eb60c84cc1020207a04a8bff22d72d0f64cd4b86f1064522f69ff4599e21a28b247dfde11ad2be9c407a8177ce89d47b09f40d56450252a264941aba39eacce593ef8f1cd2912a97c4c5e3bc2afc38682aeaf1a7f573a18d9c1940732c4935cdb3230ba225366eb153d52f7f1d5beaefd3b272cc91b2bed5536b4cbe02ffd3043a57c39766f4f0a0f99d98f20e74f65c732b4e748315c0303ec7a9e9e21e9ce645b45c45d32ccb6e4d229fcda59b19dc340ae1663c1c196e8ad099f26c079a9dc25a3fe259cc605427e5d9313a66d238f705b784c2652fcdc47e76fb2fb34be7160f0fd2b0b9511b2f9a76a0e87b962002772695f76d4e4da7c18c9ffefd15224b84f52b2f56609f1ebd6e4d5c383132f2ff2c5076de1837fbbe0a1ec6a969b5882947ab6a1f1fc6357ce892624b03036850cc53e0de6fbbb959c1b1cf0e48a8c33e128e05a5320898178fe7257716bb3a596d7d9a4e90d3b111dd4e91b13af02357b70823028cd84542adc590e04cf1ee3bdc4fcea74a145577d72ad38e8b7c94563c02050674662240b06d41d8828cbf8005ef4e8c165188ae8aa119b1cb5693a70c4476ebc395eb5e779c0670b4f8f649230ed5f32b8256487023c9f981d493b967855fad44d081b8ccf8a4fe2968c7a8943e3b1d153a764b769d5233eb7a18825dcff09cba6ed3def42c95e1cf20e26685779cab61deb4f19a52cf3ac22ab6e3ed143e206339ecdbcb96a0e3cf0e9486eab39c54c1796d5a0f6638b72f9605711025b66c42da8657657db5b1ec8a858f2486daa959ba124aa5833ba80f320af6b85bed4052ed86afd83b81e645d5ad92971a93953a9736c9736c953970c8451c1fa1c70649fa3b3f6a64df6eb44ef85db444f96f3ec1bbec8717bab9bf2413787b5d7104873ef47dff02128fab6fbbce4811eaa8db6115e7f308bed4fcea7b7a4be355501ce5d5b24c4f42f2df34b3ae8eb14d7cc841d960091ceeaed36534bb5ec2a9e6624f2255ddfe5c4ef0f9f730ff93e07d3089156737d2c7d100c7a66e603891501ecd5d05af8c986c411b23b8e0bdcfd51cd2d3093cb47c9a0ae58e5a220178bb80ec23779333001dd76d93512f5fe03fbd3b2287fd87380cd131415212959cc838007febb1495c766c34ddeb89f46a59b927840bab64e6fc4f69ed0d58652265d13c008d75aa5aefb26de260f0e275ce17560a402c211d75a969033b224fa82ba0c5746e3c9457c43897f6ebc97483192fa58a9d5f837f9590847bd112a442e1c1e19e02cfd99f3b22e7adedaceb77909d8bbe0dae056039f26430766e57a3016b885bf2cbaafe453f20bb7a4cdcd41614f55057da26fcf3b8941a30e45c8a885045bdc263b517c9146a7e27146c3d5e24a0aaf89219efa9ebd3af59edfba296fbe14ba7d4f8e92e5b5191a050ca23e50f160058d0a7dd12a4865a42e508627a43bbf630c6fd834ecac1257be7a162e443619c3409d4826b4b0749d5d09c0df3972dcc09e15e5dca6fa7de08c31e1c07812c01a402a6b9166d6b3c62908595c550f145b135c7ded335b075bdf02b91e792e458ee95f272592dc98e391840409bc1ce57add1545a259208ffcea0d6cb8293a28a978d7ab13bbd709a13600a82acd53198987641e60cb55bc0e79c5cc4a8b6555961525a61fb4f78d471da4806637aac28031b5488aa0e817038a6628e8732f75288d118c0db752c760c2db8fbc157a87ef399140acf4c7307f26655278d9218d13ba9a1aa23783bd46a23ddd31e28c55a64e3001eb68cccaab75b1facf6749db129879e5156d6ce8bb5ab1e58adb0889fa187945653b143b47012c2daf4be0c5f8b4e73f45466ce46a49f724d0769354221d15ce72ce2a86d25fe639321f11fadeade54c2e75e7c4a6387dc0b0ca90f8c0662eabcd20e139a35d4b346ada344dcf0674bce9e0b19782718aeb83b1a684db13df63c6b58609a0d80abbe48c8352e1fc2d5b1a157268b564e6c2d10130f3411fa07c2b14200710309b4a33a156a10f99914a8e9241a48dcfbf503df0f48c7eaff5edf58a2396201d6ec93fb758f3ae7955b520f8ff272a7abcb62a352c8ac0abfa42fd441d836e15fb34b9358db800419e1683737529756ca08d1e32b00d5b86b79e7d574717aae0b0807fb5bede28cbf255b087a0358684c6abc0faa11420b8728282d4f90e9d6fc12a1e4d2748ab70602ec689f609355ac2af64271bacdca78acadf0016a426ef1491059f3a3d3ae3d13938224594209b16d7b4c857459f7e7874544d06d29f07f493a5b0e4d1b0c6c544dc08258a4cebe35d65716fa6e6c763ac497370b948173de0e42f70daeb7987a220be83d55b133cd0be3326865bfda43df442bcd026428c51811fd622972283663e64b70f136f9219d608096722fe9025cbb54c55fc4e5c774a2ef9b557155001167be49505cc4132b77a13be8ef37defef6d63c42bc9e9c3c9d0b9b0fc7319f5661076145139af2dab9d8da4470b20f905b840f6fef3a9c3cd5e5e3292637c383c5a103340ace14595a4ce5cd695f3f6a4744d90896ddc6c2aa81696a6b14b0d78a0de37f4d224662d2ad8e2003e5137b1ef3bd3a4f6cc923606ed5ac57f5e10ffc20eb9238cd324ce75566fe55c71efd9efed446bcfa1d9268887979615a454257e997c4c417f73923ba9a04f9a24ee86e9d818e6546ddbf3e233242e6deb62b26247ec5e09683da166608e448c6efd7128e862a0e49c7b6963b42c8f801a1cef58fe47b2b2a94e4cba26ab9fc9add61ffd78e9253ae1592423c0cce7b7d420e22923728f4b93eba5c6cf1c0e8070ac3947f928461509116314087f6e48825b63b107355f5a230bb2e146968f4b6cf620b2d059b41c19ceca2c6896d04ce9b9d5d692f6d86ea5917b575d5b958d1bf8d64a1abd0170676b83aae1cfaafe8463b16c86d84713b25041d3ae80b627b6ff66d50e531736c7a4a9737b27eca0d05ec26e9675f035eb9efbdca9ebe3a8993f0adc6b535117f74e8810e2448bdb58696d5e85c801ee79e4feeb077420e1cbb49f252076ef9323da6e1dfb2b971e240a228139d1b442485c362b691c882788df548e90f25ff3cd300a2824975f5c5a378a4f6d3b93a281db73505fe9af992f76bf786ab60778d5482f62bfccd200f6c283a26063a5bb4edda44b6a8a4b54854a2bbb1102382fe2d54a7956df98f3f2e17bd3cfd0b8b27746bee52ed3b0fcc23fec3ea800775d5519641b65ab008d3d92fada70b665ead976e13ae5241b81428b8e66d1d0bd2d8c6b9673f4f2e7ca9e18d1186d3217be4cff8354b0dd23115e296cc71be49cde57afaf76e2300146be86f22c716ffd1aad8b45594210cd9fbb67866902f714a6272b7a8927ddc1b1570dd079ca64e7b42867280051cf6869039dad832f06c1a73c6b3dd1472097e2c25cb7f75c564ea92510ddc40ce91d170fea5d0105e193f0fb2c3ed621adad8b4e1bcb761fd996bfb1e819893545c9c0baf058f7fa279f1dfca43f7219c58bbc712838e4c2824472fc0bd90bcb4ea1c30d2d1311674a8c3164b0809ffe9ada892bba55797ab29700c633f335ded7feb490e654c19168325d81e6971bf9a787c526a2eb0fd5a77b790f608302e9a20cb3cb1a246ac9ca89ccd777ba3a0c5d75b0b5e40e6bdb995578e0b02a57cff5010e38ef512f7ab3f7331ffaa186abadcdb4008c54346360c88af7037682bb9499407a90e49b976d08ec751c2ffc651b33c17a564839e8fdf62f6c33612049a8654fe48bb6ae76be7a920c7ff37d9bc8349c6898c1964b268c5342927e8f6277b06897d57d40c7936f5b5cef9acf304dc8022d490c6de6e15bf3a842dafcce9c29166c27cf7f4365dd49e1e28a7f5466eac293cdccce6d0fd53d578a2ebf5bfa6d08f00ecc8ba64208cf3ea2bed5e87a2cbdd7cdac98c1b8b0b5fbf1729790af43f0825f1b576a085d3b55bc2752f8d7a98ef16ad2f526141cd4965de9dc320c399ab356da0f1e35cef32cf4547ce2937b8cee7c1de627dbbb167f967c1fc5d1a2e48e878b0cc2f45fe55047cc2293213c0b1391d460569d595a52bec6518832d966206875635776e839472c303a2ff5f997696dd523c1768f9b76344b4771c7daec41c8672a04cdf8c6c1f602a79a855587961a2b4bfbe38d76582aa025f18c2ebb74ec7bb68194fbdfc54e55dd9767c08562f6d11f1e2450840d9944c12942f0e9562022f84f5a649500b13bc1124cf4b5cf6520d81240535e51006148685e7f41267b65a1da1a0f5a33db545c1876f1106dc539efa25dbbcbabcab9e90ac8e10d8072de23b6ced3b480bf04d01e3366020711d5f2d00043ed28b445a1ee39bc204164bde7be4df43ebf93ec33dcf6bf81cd4f0b61373f3fe06764c358e95d98f77718a25b557043446055a2c3e1055f0b1bb965c0b7e4978fa65cab7f89237ad97f6faad98826fd5aaa88ef7fc08248d92610a02cb99cb05333a93f52299a44464a7e63eb1d7a1efe41deda33a1ecfcd697105c754f146de9905b0578b5ca4de9d4d4193c60a2f83c11846532d9289c9b7b26182239e7324e2076e873e06f905e979db3979dcc14cfbc4eea1ab5f1a7ddfaca14c71819e0d2a14f4c5802c64a0031b662cabc666901206d672c16784f8697cfd5e9a6be64ff86fa14378b7b4a237cebb07c0c2f3c66f99e59afababb8e4d0a6d3a5d5b667b8e700c0d6620cc445ba69ad03d6e4ca4c276b325c3b6776263614386540d4f8d6ce238f4818c90fc64b4f9af2d4972e540d2e4cd7e194b190f3c0535e3b536d499c887297835c219f0e7e148dc5f0406c6f5856847a7d9fa25fe4943d174d4f5001a124ed502744c1a27925d0a823b5e0cf0f5aa5ab7358d363fbd230dfee150f82530887d6a058cde314735bf31e74b328b6daba5526a0b3315d8a2e2f7d0b440c6fa097a190bed92355aa1a2fe43241b9dd5c7861c10be1ded6232c1138d58d7f1c580f1d3c0a5aead11c2bf67c29c525a8c0286157747210142b3921929f5f9a1a7f16d6feaec1444de33aa270158402f812c66da877e97a621d3f893ea1563bc06e84ca3d8aa1aa4a9656565968ef365e6059697fc1475c3bcbeec79181a15af240df444f8958310002be4677e26f502053fb4f93f2f716185f472db9460bc359266ba89aa6ace521e12a923d2aa622e1f2acd0ae97340088434e57a684d696db7730c0cbee0a3c5290151d31754afc6d945d39b1d760be6d9f562d90c0d50732fcf659d3690f29afd0a9757e17436248061ea9a9818f549439a4d13845f0df06b41e1298ed0f588c00c06e7af16911f9024466a9a68c02b19370b890c8d5927dda16e2809809bb0a851659ed69a9a17bed230db00fc5c4e780a2645621109db0f4876a7c84afbe0aaf9c2e56135f8083d18664dec187720cd78f686e513fa4f28214aa65da831e8e20aa706f4b3fa55375e3478d3141729d9f2f922f23961d53d83b73fc1e179f97e97af42b02de3f1e413039a53aeb8e2f0a24666dd824fb78d2ea93ec24d047fc4fd2bfd63c6fef2e6718b3f5787e9a2e8b67536ff163ecabf7dd111557f22fae017cb49e42f1593f864438a74a9fc7784c2db9a96af9995d4f804ef4552489b5958d3bf223934bc74f6ab109925cfa3acd2e1359305e5ff0f86d1a4293cc64c176679eca1bbfc1e6021615bfc69cf0213e14f0b36f9f2ab745719397d68caf7c8589a193feff8498887f03d1f0f0a219b6197e76fc005368b5ef5c69335de8c9d26ce3866e412509f47491ee72bc98de1283c31065f2ea23ec38cd209b0263c76f7642eed014b74e5190e8bd456d3c93c9077d44d10e33d9c922b15bdc7cf6f78d92320a9f0d48570476fda3e40b1d77b35568e1a9b93e67f9ab559a6bcf111a9f345bfea2b55025afeec99f506dbdbc6e773c1baa31c7055356c04beb6fed76eb0132a875583362deac4bc9c926c54798a93a3cf90173a91ea076f3ec4c76b96190a9fb9ed49d1625bb270b89f509fc4b6407bf8af858d2ad898bfb0a4a0db2c435b2965180f336536f20045bef2d4548f9f2fd637b2d58ea2f7748f13c70956420b2e1d7e6da92c7fe10b28f82f6caee73c14bd78f9530f0bb29758a9369497b96b46b42a52780946ea28b109ab936ec90979019faf3c6b233913722b1b2fdf76afe1485d5b47145a1bfdb689c1358436c7972989fc5d4377bcd764542979286e83ef076f56172b594808b570d4c3bbf8c9048e7b9c60b32f6cce4eca3cdfe78c15109238ed08245705b5a58bdbd1672df130ef371da1082bbeaa41af03c25489aa760bb5baa0605987640f975c8236be4267d4e3e551564db9dac3187d4433d775ae2e214636c800a582c1a831c10b9f28f2bb32fdaec61242cb5f1b49868c5fe7e9899070c0bf8ae60ae428cd7cb53986cceaa2197bff62da40490b9d21f81cdd2b00c31835436caff61bf959a45acc3a727e73fcb3b878ce40e04d3ebd2b4f8eb0691e7ddd993c86ab3a15dd47df06a4042f2baa474709cd41ed66f94bd6768aecca7a9d460d7962d1d0586f202a40eee5ad88b427d6366837b3566102bb173e6320e7b6975f69711a38aef198b08abe6a595ab7d64731e634cddd03271d396e701ce5aaeb1d00a8b4d895a68772349840df4a4cc374963c793cc08fd0266883587e5cd19fadb1443377041832213ab06fa9187be1d23b53d05494183e9cc4a44f0e2522b3c8d0c7e668e615a65e63ed66c7c59d0d7876a4e83fc9e186950f9815583064e0ae9550f7ad1572b0099fe9e00f75fb6b0d135b821601dd9d1ac7d7a80b39c85ad6ce0399c6de81e3db43acd2bfba4d9e480d5adc34fe35c2ce8c0f33a76cd6f37d95306b94b1a47c3151a1d965d73daffdadb01d78707215c5f1b4d578e4300beee72d10f2361270f8b4c541e9c572d5bde066adcf2fe94edf42aadb08b37f440efe2dce9eb7ecf799599ad0115cdeb8f077b622419d87a2ae157471fbb5b25464cb957bf5bafb8d48bc694705267502c5d471e977a16d35e3b0a251739c583b4916d8b6e260c4f971fb2a9fe426bbf7e161a0103418cc42c2d91b090771bd942646295037e4150fd7b4cfd85e199836d7548b18b5bbe89f11885ef5968c5e5e49814b4d4b4829fe45d21c5df179e2a28a395651c388c36818cb1fddcb940cf85b3ea6836cbaeab46134e816d4c86062e3ce1c604ca7bacf7b5e6891aec46113cc001aa83324f0c9abffcd6df4e177d25ffbc3e63eb00dda195165e4fe4b295b34365611f7ea8384781095e0c00303a45ca474de01c354a2a9c1a0034b516cf1ab1bb528ee2351f01777380e7e758659a652951276eda0e2816d83afef15de4cf056689ad8e9c5d4609946feb116e311da4e10cf1f597d9b83802048f08ceba6bef05abe64cdd684cdca61639bfb65785e2d9906aa09ed3575ad55e9394ddbd690d22c822b16ae1d6a2b5aedcf4403dcd72f2804f37ec58a59de2ff961bd2f12bc7bf2675d8811940ac8aa6e4402034bc52fa989a68a1efc4544bd57742d8080c02c9df488e4902cfc4d7d203b2528401e308c81f7666072fcdea8c59193dc97df5b2e2f2ee00992f75ad6ea5825f863ff4759a0acbeb6a4b2e1441df3237b2f7452e17537dea67e12595940c80079bee1b18d49546bbef8bbbbb18a9dc6b920979444005b07d7bb6cb9f7c5e8321f1e4f0a0fb0b0de129b6661fe0323851889d64cf98791e1d4ef66da539b65aafe518586ff9c5cd9313aac9283ba378e7ad784c43e307da28bddd549e56fb42e391ee71fc581822e855746c24eaa0c762a39562409a5f5a931a8296012d18e966bb1a7329a2f8c9ff6ecd5d5b157b473517225c06a423bbbe33629bbfe0dce42c81b20a7c03f1a56fddf39b6b68068935c40da7c1e54b6241f3319742d7ed07c83771889e56264258b8095a9d1d78c9104f99bf9afcf8a2bdcc6b9fe8661e1f93619aae1d64345d38fcbb441b30ff9a223758c09606b5a1881d5ee279ec529a0f06c8bbc546939fcf8eb75b6e14eed10e22fb1265ceeba5d91e267caf4c98ddfd7c5dc656bbc96850c84f4045d0cb6611cf8ff97f8b8277477e3d2ec33a2ebada92939f8af9a2b2bee6ce1bf52c7c3f10ff8a2dd9c89cba220d15adebb9313e228a7b86d73c79f50c8ce7e947b67621987efe4d48df28efb59257eaf0a70cf9be24c63a415fa3e92772d8008a93f9f921530f6f6c5e0bb9f83882a6178b29e0acd69bdb576fcbcfd5dc94bc8a246081b7d68217490ed1da936c972ce91ce8fe83af8355c28e57924ceec04a8b96672de956218f237faae2aafc958cc31fd37362d511e5cd0855a918418a45d7f2d5abdc3129e92c91943fe79298bf429c10a305c4c40dfca9763d77b43d5d12dd76dd6000ce95b2e18c9d9ad2f4e0b392df536e717930d1ada2e54e3ad041a5a08cf63a6f22fc2dacfbb01ed83d8557d174c294aa1fc9b81c42343df81c950a26bd487feb4d12bb230e45d102a2d93c0f49872831841e8f5fa8e25b490339be1b3f18c3f1516cf11ee0030afc0ff0f07b74564bf68ea42bc4465385870e04161149129f5b51116256d4247f10f079ce3bcb86ff736eb6e3ecd22e69272be17d1527b6703016276b8c3c40cfb37fa2be747463841510423ffd2625acc558e18bcda3294f75936c10f300866839a1d9f21e0b88b73490948ca1077c1c8b37db309316656a158f6ecb702569d36c9c0a813b60ccb9d15b5fe0983af03963370c9ad1daf4a88cfa5c402442bc412f8b50f1a2f0d4e4d64cbe4ce02ee37700515be4b6156ceaf9a45d739ccd56c39edbfac38539cc644901df3b7451a7ff5fb93306ed28c358d61f09eb0f8e03929ba2890f63e8df0387832e152fc75570781f1f47356e705a446db143a96c19544d5eaeef9402f20245753364005b3c5c43b3addc6f1e13e1165b89f5a9e6d4ce68f8a811472bb9cfbf95491234975d38c6fdc70afcb8cb11b001f6f179db1d60baab1c7a747a9f9aea6175b23c10f9aa761d56b1d18c994b61ce7b6a5a8393f19984c06152685391de06443f06fcbf63899a270134fdc97a9433c13e1768bf130a0fef1f4a4492da4f05601efaea688f1541cfceb26900215b631fc7d5f404ad3f7b0032994c81074b7892211a87d5bb65ff95076b8ea7fc60be6c5cf2f8f67b3672f9cc5c79c09f2a9d2720ac46d5121ed03d2d6540a46b7a5e26de50e92a8aee3414abf7fc6d66f53688d926e2da93a94e082a89a284d83d193d38112c6a4e475f3db826bf6d0ca212ed8b3fcb26c6a203e676edb06366fe087ee203518465fc051efbfea98eadcbbd79e011bda099d3f830dc9a2b7217f6a51878d3c6d5ba013cae1a8cc711435c47d9aa8471b59ce289dff8c7c9fd21721b60c3f3647579f2a75ebc3e6835c8982f2346f9c582ef1b10f56a06b06fbf96425ff44c67eb9b18ddfd524a5c8168d3f8ce2377e1a3f11be2afd9e13f1b74b33c6825ec9f46cef0025a4636085a89fb5458a5ad1f4e4ee3e8f1720db956ce6b48b41fbb53489801e862fadc04ec3869bfca1ea1601b3c7c13298f8f9e4699af99ef03f7d720a5311e5eee49c6634a3950717d3105acb6e740e885be953f475738e726b55a84a5b95cdf4b86b0b8e1b5358395fad1a31c82b758a4cec8b7e2735dc29eb1568e92b9be56ec254de9fee58c721b8bc14014ecc15994d4eda89def46ded10af33f27cc9886ed959868bf7571fbca7211fff7a68f72e6caecf67cf605fe21763f549670f90b23f9733961d26e3a4696587024add6369d3fdee78f04ec29a14f43dd4a17b673d1b9e8e321e6890f58a3d27f8ca8328ecc08b70984962c729417628429ef9cfb1fe6f3cab2bb8477371e4067d2ced17b624f6635716a4561c1a3e9270a8551d32d0acfab78f7de350711dab0d57849c31927b25288eb67f8731f14c8293af3342ece7c3349ab77ae5bea2791bb35f5be215cdbf2042400d5b111ff676b3453963e6e02f01a32c51088aa73ba1aba5eab1f2a953dfa828eb08d8aab46afaff43b5dfae470a0f226fbd2bafaf1db94c77954c21496da57fe927518344d6486f9f31dc1155ed0dc1d89ea57934f8c4b9893cdb68416c19b5e86f3738a83f794ec61256c47cf3a2aff52dd3d5e4562027148c23840ec301dc63512950eb9edcf2b647ed2c9e7533c242b5a4e383d5d7718c48642159d52574aa4823f8bd737c755ae93adfc3ab293d0f70a31f049937e624fe5166fa8280af68e2bf3f78afab9557a11d17b706530acb7434872e89433333ad34c4549a4237a956140225a61b64d4a42715ddb8b53ebe3ac010e9b84770e2f62a8ffe34d7f15f2b04adbf05004c0ffe2c5f6655998f39dbe25da368cb1c9d05f7a4722179deaf5971babeda5a96ae5c14047f06bd9b611ff7b6e607a4c6304632ae2f9cfea738f9892a07f44895222c1a0f6a848b42e66f5091b7233de4bcfbbf8e5a2aeb2fc986406a0dcf865ccd893ceb03e1f5f3be0fa52ddc3ed47e0832718f10aa2c1cdab882891b4b2f62716f77aa22d0b3dc845fa056751e30226b143442bc040aa2ce4e07cb53e51e64b2b0f4b384a786faf3562688fda2ffe55668bf57202be2436b01b4db915c381582eebcd33151b7fe8ff4557bc4758de2f849617a642b0ad6488e048ec3dab057d161b6ae31ccd87e140df42b34339ba5b2eb4721531ac6e3de8f6be7bc6e02f9cab5eadff4885a05dafbbbdba9a7ed60d3be78878fa75dfcf0e215e29af961a7f34134d641446f18865d1b817aede60d8fb68b6ad898fbf1fdf2ba9b557cb6f44ece302d6abf8b12bc50a4b029426ee4fc1c53f712118497f49ad0bfd133e4c813e9a3a9dde050c9d975601c5e31da9aa1250f8436701e8e967ea5a1f753806f8adc831e17f744eafadfcbe4ecf891f2e154d70af63dd4954580490cb415de2092d8c5e85ad8a51d127a21f1588cfa8cdaa7cfb539ada387ee0803121e16e101ab2f222c17ab717494f4b7e43cc81c38d7efe2c614762eee66cfc609c9e97aa8046a43e7beec33be23fafee4d66797e1f3dc3d08c8d77d51b30f8193abc6cc8f63cc833e9ec45b814c022df5ff93e0f78d8c583a015451ad5c30b9a6a936b1e70f09e3a27939dacb1c625bb86289cdde12aeb82e5f6e9fdd08f25e892ab1a151e5152a66035a14d858b8482e3598be48c68dfce101a3be26f61ff9162360fb23508cdb676e8280066e185359b09726eaf94c3c0a151a663e14b0e0e09adddf0e9b4b27ba71741244c07a8e0c490f6e2a1b4856b6b2c4c7423b9fabce0b27835c30b3973dded3f231fcf1d293dd0193caf1fd0effbf6aaa6ece0f6d0e4fdb5d95715191a3abd7ff2636a994e853c4f027fe7bf2ac1360ed4dbfd89f16f3d433e233429411ae0b855d102337894fef3b5639449925a45766c4d91421f355580b7f0815f138fefaf09e58fc20f0a54f982506a73467b680dd0301cdf58fa3db96e208fb95e7ca0437329e0971ca2532232b2fbe37bc7ccb64056aa5c43ffdba6f91236d77873300eae7a55f7a34aac563dcf5ad771a1f21ee80ca7933b5842717a58e0a2c578be5cf2f597b7fe7cd882e046c2d459b9a6493b871878a53e5e15c382cdc69f48ff420a5ac82fb0f02501f049edde83428fa251dee152fa6e58a447a328342dfd541f268c3f677dbd8e31c89ea9a950143c56a15665866079ae22c7a223d7470fa8f1667c86ba5743fe147faa642fd5d7aeae1674a8a33b01f976fbebee82d8ab759927cd3f56d73ccff888db00c7a0bb2a978e6507795d10e5d92b0ff5da105d8461a257f73cd6202d4b7a4fb2c61635cb5eacf020b17a3872cd2a5607f7944e3f091ff15f2abbf1bb0b1365fe7d0e55d9da4f1bed159566d3764a0a0eee012cbef44edf42b8caf49d34ab59c386663dace17648d5f725ef23a5abcd1ad416cf3881f31e89588e5b3da028a58ea253938fd6768a1ddfdfd06817db8d8f05ceb86f22439956507441ea40baf5407270691e3d58e4e1d5eab6d2d5feac63b3f61aec176624871a0db2c7d4f8d7295bc57fa5108838709b8fa7ab7d0f7cb7bdc4b2c58219cd1cbc4b76585b757b0b5cadc7707e46dfbf935a73f1d7c19ba83736c62324e6669880639e106018d600a4fa1f92ca88de82fa2cdacb99e8021a2fbeaed200103b205e06ee00c0e084a3f2691535da6510dd33b2ff6093a72ff54137388faecc4646bf4b63924951e2ad4ec4927ebc1ced6b2a6148084225a5da06368f96d32543223a02f10fdc60fb7a266ca1280098b8bf057bcdaa6c3e8eccebb61ce59be9950f87c957f6b9906d310bfc6abbfbc430eea40e8af77656b16ece512ce9a086c09b8fd893ce5d7e104ca5445f39511c8b0f03fbbe04f3ed6945a1aabdeec94090611bb901d99d79a0d2cc5a66ede4b99f932f353a6b707da156049ef0d56e1f56d7f0750b61ff1978b3f948c29f92b924d88290cb3de33a0258427372414cdaa8053ad93b59c4c12006aac0249f46c3bc034b0b925ee523e742e1e1694df07c7e74f94df0157126eaac4ee400b21e5b5bdded221c61c521c2e93ffdcb45c65fe5efd4566ed05fa7ea53f00d5655c56a57214c3009904cc47bfa146bb0385a367d2d3939f47482ba8b89da2ce682151227707b8bc802fc8cae62bd1fc43861154521661c8959375bc30c6177f6f0401c0c2f25667f3e958000032b1c75838b2ec2ffd49044ae2a32338a465f1f4deb72c5a72e30670bb623434fdc8e9d24f808b871efd06e73591c8e2f5a9ac5e2ac719a708ef2701817844cb62069906020cf55f0508f46112899ff481f6b744d9ef857a2364cfe9e36a68ba975f2ca1751841d5022efe95301b6b2452d0413aa865a418575c6b016a82d8d3e97e88f4ca9e4341a65e840f62ccad9caf3f6849b63d9191c9c22ad1fe89ba0417c85724c3ef9304719e4ee0629bc7f901e4bf282ac6690feeeda0f1ec1ef57d8fe111443593238ac3aa422abe9bca2e2c9b8aa282fe8aab0e8a8cfe81decd02f65e569f2d0cd4866f5e9426dc5b4782da425b6ed661c4e8bf7905e00c80fe67a0c8e73986584b6d855246a3418a475ac0aa0f76ca66210cff821970b44e736436e79835e7a40b658fe1a4f1112389ac2145b13dc58c9e8e995e7b7fd02712c4368dc712decd759cd5f945476a06d03da300c13cca4b77e1db0403c326cb85637a2a331f924bdd9830de59e73d2a35d368985cc84d90eb97962bdcc96d1288bb589250952024b9fbda9be4ecd23bda539013a79f173eee41c680c7a4fb3413adda1e29fca05f399ff3c75fa466f059b59fca7a0f4636834159fcafa4a328b7468d367eb63e4776dd9481ca89a8ee411d4c0c908e47eb2fe07be775a3157cd31e9167a54569defa537f8a345e14586bdde0a6b0f34b1ee9b0975842195aff5eb94967c6aa2b81c00ed175d1f7478c6d0b028332ace0aa1a6e8c19a766b59ee1f31ca0041bc9ea283bca1d233b762fd6080bd0c852d4e22fc25bbbb9e8a8deb7806daf4b08746b694bf3c4e8cb0416bd4f754bdf9ea448199249bb199dab42810ec0b35a37f7c10dae79fc86c02235af1f224aa45fb2c7a212e7c2a3c0e9c7f74655144f1ee17c056700a183fefadf9d81c831e404dc18d868ab57e9e32a2972d52ddead92cffebe6a27329625ec56f1b2aa4321dbf05421d0729c722f2dea3e8b8371365c5d3ecca27bf6431699a241ef4aa589df1ffdf590c30ab0b9ba735797b2414977a246ea8bb25e29dbf7819ecfd0602b99f5fa9ff9a95471a19f350ff8ad2623789e8fbb326cc8df26029cdb31b6e6bc2eaa18c206a77d9ec5f8943f743ea99c5ea4bd7c04de0dd1aae015f6f71c47456b92b785e2fd4a0b3b904286192313a8bd192ceec910187756bd83eb1eea8080ce8b3e07ecd401e26932850e98ed37c1296da9c4a8626af8460c59aaa0cf08e250f23dcf2e72b364cee71a2d486d5653e7101bfedb1ed5c24be1e2a52939ccb9dc736ae7a3d25004877570ab40b2c5812ec8c99b118e36074149479f9f73b5d48466df072f4e1e590190e6ebb21676267851567da85efb8f3e4adbe25f00a0d28bcf46627300bd5c43e6048853fd5d477c1e379b5321bf3612e9c6ae8bcf97abaf1aaf94775cec4ba4280813e51def97a79f3eebebb185a7592476e1dfa276e23f4f4fd2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
