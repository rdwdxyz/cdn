<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f8b2f02c278c1592bbc3a004d4c651fea386485cff3a56baea92262c886cd2eca738d3ee55eb4504bac707f60445e2727b5043cacb3293d254b97742cb7e0165e24affb25da312678fd48bfa1ba1b7f163e123fc260a00aa6634be834e5896a919d4584ce0937598b035427af1128bd7912faaa06b9eb94492cf7bdf8e77e9b5446bacfa6919e3be85f851f5a7e9937bd58e0bca03d85106c037050f87f8dd25b722cfc8c69d83ca3cb9a09b9ed8a2b645460bc3c57d91adc6b7d26904d629c58d8c16e31741ef598cfc4c8f884c61847af0b367c9dacd12beacf4c32a31adae6702bda395cdb0826e7a07ede397c3dfdf06435a4f1edec2de72eec6390e6a3ce00146a9981606dadac2957958575bf7bd43581024fa63361618dfd76685fa5c1ac3ccbc8d304b253adacc00c5db9303a38658dd3591ce77ece6bf743eb9805d88d19196377c4c0e4d1c22b8dc20b6add7c28883ccd33d7a8347b03d20c6a67d739857ceaae208ea6962548bd93d5e9f876447e13a091e4ec2a27017864389010a2d3aa46d7618979de6ad0b3a2ee4af766b990742e3c9e8329ae1061073f853ee9c931d933d0e7495bcd252615772d873af095998b73277931de0515deea4e363ef8e9a118f8984dcb00f222e8d6049f2801c23a5a9700b89c7c83febf9befb9b769026f95c23524ef9b291e8450f0d6adf398100f1408d297b2eca80fc849afbeffa96d52b159233b7855dfcd73c80949f88851dd842779e8cf5959da016c9f91e3392d5e1fc6bb4af31d3be5328cb0a1af6243ab1932a8588eab8c77bd35a341740c43fcfcb86b62c36a1895ea9596833c0b81728120a7bfca14723a98457d9da628c041f1403c400f049d7bf3db8e3d80e2cccdcaafa88f1efeb423bb53ef94079628f2c12bda2039115eb4d8a21fc5ed995ec841f0f4d99fd623093704250c8e3e1ddd2a41641e2909e0d2501b7b41cbcbea55d1ea79b1a7b479d5246b2ce7535a1044a91e4f3c6ea11d603700f42b40a87a6a713382f2e07fd8569943ea4fead95c9a99a9330b6a0791d507583ea8b672f6c83c6273ad94d9c531f79d5a7bff168b7cfd8c5d44ff7fab0756ce0941f64fa1d2d26bb1f34462421b94dd2004f096e6bcd64d814ce03d011480c4663d650d51775c81a17e5607a28b4cf12dd728823a690b91ab5c6b6a4b12d79370019759576ee9e59aafdeb6152844ad5cf9d267d76c46c3e085dc103142b660c8595e4de88d941c5f224d3cc3a4369dae7f7b413a8bb0fcd0762c0f4d3cbd0a73fe03d97a3ad91210fbfb2dc7f42c6f0c1a9171fbfd9755b2bec65225e059adb6567071c8af280ca61b8b4821f3096297a008e2f9a301683f689f6069a6112e1a71d6733e8a5eef83b1c19d782bb7498c124c555a83e0eac53098b6c3aa26e410fdd519a9b8f9865692fb9e1fffcebb1422453b50dacbba79718a6f6c797892a42225505d30410af0797c241ea38c36b3709b29351fdb5ec5d25f9abd52db7ebd7f4f3d917a9c7da1966f67e11b4e0e92bf308a9576cba96017d84a0da0ac99d4b6bea91cf4ce2296e426b63d81619599b629bfd66416a54d47acb7da70499dc6591c3434fc3c40588d83cb7239111f6ecd7c162012147f58969f3256aa0bf888d1b686a120f9fe0bf6068e2aba7a557ee89f11c3ccc4fb5eef2b786a740d469e59a54433c5b1694d2806a71ca6b077dd1b074238b53aece7a1ced85b7eb17dcc6d0fb8678e54aae4132d3ebf453b01749b9a6d7ebbebdcebb90aad73488edfe31a1c41f5d215f875988ca54088df0938fb0fa1f6992459d87518f06baf6b8c41713247edc17804de1c569da720ea45816ad2fd3ab88b8595367b3da97a639eabc02550794836e35df420b33896cd7b6b6e702cc135d21cf5bdd28c2482f1ed643dd054f848e0fc91ca021c2ed9ab6b49dab92e016c98fc3f19208c1726e09d88ebce121934a0bb5587708e0f4faed4d6df6d4dfd92acd0820b2189efe09e148a9fcbed2e857243c1d76b14c422206dfd2ee1c5620b270d588583deb522a6a6b5d1c4bafcf0ddc70ff963233b31195e694ffe72963d9984a86b57cef41d3494f0bca8c4fd484a429d03f7f19444c38df4f67ee5bc345da529e8e0937563e5b42f4d587ec38bf2e0dd91fe903cef72a57c0361666f307e790a0e829e50bc9fda22e7ad7e6f0dbc566b679ba7229e23d32d341f72b63b9653d6135975a682e2b9a497e05e4901c4a4c77691138770a119e18ea1329a219efe514a40d295dedaeeec44db75db956a5ce51bbfa62efc77a4e43f87833fd39b1bf6951a516768f30cac5b75400ca04fd43390a3dfa0b53ee1df9c2e276c97787e6d67b6a3a2d06bbdb0d9658fcc36710443eb269555718def8686ee85b2870fc0a56d77a52d900e713c1f97a898b0ecbc2fed66f653371a57d9d8f1a1b10709106a64af193a412ce58a72cb4dcc574eb68e194884ef27d0f7be5a0652787d7e3307a154cea92e76b3ecde474a4e8d6f49ce75b008012b546a89ac7a904110fc84cd45b85afa78545feae0da1d766517e5c87aa70bc8cbf807e4b08a5433f6f81db9136b0de9c69d2c656fdc8f2415cc21f3a9122e2c1ab9b50705e9625932cd4078323fb07f54590bdf7f29ea96e247d9b0e97ad54f1caff311ab97f7a549bbef3cf1de564583c0076f3e70482d6da611c57435883da3d18b6470fc30f350dc7887dbec9fd1263e835b995940c491ff2141b8d73e903f36518b55155733da40caf4a1bae62dc04422f72c3eb61397c8c5771fd42d9935f09870b11778fd6e98e12164e77b90b358a5727a4282c23c6bee108e158963e8c914701165f435d9236afb257e239a134927c2b5425788d8693df48bd2652f400f3a776aaa94427570ab599640c71683fd70dd11a498c4dd0249df0b62a296e89656fe60a7b950ae604c31dccfab969431ca0e84d83f3e84fed6ee0f4d0d92eba042156fc9bbfe7bfc5626ead897c0833674540f280d69d724a6bcdb3eaf9bbaaabce935f3ecd872e0c4550039a9cc0eeaffc6e7a43cc72f7b67d6e6477c40b3b359ff305e9aa3bd91c163982675cbdeb441187c634ebd8c1fd61a5629cbc3c12b2d48165e5bcafc4cfbf51d4581d6ae6204ee1d8a77b167aa442658a7853b4fc9455f85bd6b1b1fb0a5e6ee0232610204454f26439c7e4238ec979f719a9175a4d27d302dc6b134f145c7c384d51d79b2fb62bb440ec253df9a5faada1804c546a71d550e4c52c1199105379ccc4b67f986f5a0fa48f70a47bb06b39b4a8d6863fcdbc87eed2353d4080e8ca677cfba2c1bc9f23582858623114daa3abd0bfe968f0a02d24c7f3dca3105655728339907ba449153fc27acd2d9c9b26b12e057aaeacca12d2c5f9dbb762daa91f86c58cb77ea9114f82cf564076f1ff2fb692428fb9e73f9275aced3351c4c0ae0bbc7293a74ba7700219a1a1254aa8071b9950fd82618cf88a1aa84dd0f3cb1d1ae6a6a671a7c913be8315daadd22e496db2dae4d0da17c971ec2e2b39a85335127a70d61b39c3de2b2a7db8cecf5d43643980322f7fc8178afb76b2e336d3dfb99391a1b181398a3978c2ea7cedfcf83b3ab28d8fe32c27ce1063db7f5ff360575e26508cee3d0df3cc552de60ef4ced9d16bbd5f7632eb6dce9a29d911962a7c953a8dc5420a12cd424f621c572856639d78b2d21df83486d4229d0256fd5c9aab49072660a8565cd0b06691b1ad0ca0239212194e296e50ece65234ad8feb31e788fa15cfd7570793df9fec6d9ebad904036c05d062d9ec8dd387b3b2184c09884bb6e18ff4d8a25fb1c276c8df2ca33ff684afa36d77c229e1d55a2155506dfcf18d523b1478e8541a8d57a47b0962388060a764840223b17fd1dedb90917ed45d3071da9b21b9fc6fd7dbda67ad99720b226a6f10ddaa278f569741d1037cbdfbf9065bd964f02d72f082b7bad8cb8b232f843e48c2e33edca598590dbb98c4559493f3291728b0439ec722d6222460f918d57762dace8801e74a35735edc788cd87114e7d32b42302c770d9ad5e0b2455660a3cf3b95d9f8b91217d27662351c432f3a14c9f6fa61071a246e819c8743e830626b9f71c05758e7d9d10dfec0b9d0c9b0f15417c9d57b2cb54f0143249a06e6c5ea13b52ea254cc6b6f1c7a9a36f826a2afa239891c9c88a4cbb47595d99187e8ae9a097004acb9bdeed5d8a654dbeffa396f0f3c7d71a453989a318cd6c4e4c256af8df7ab6869086c167d3f60296f85beb1b3d1ba7b967fb81912d4af287b2b0f302226c9f5019b06ce7f6712498dd6e6221c0c5e6acc77776b82606f43e8f609598b3a23a0070a346c7c6f8c23b6a4d321baf630a3c71bd709779ce576dff3305ba9bafbfb36ba24a058a1956d3e26ea92368ee2b37b08d30b85408bef7cf74f86aec19e297eaf207103b6d5f9a6303083af9468adabe21b7d3eee53c67cad61d8b2233d443b855ea1ffbf287af64835da5a4bf26ac81e9be47185cedc609ce5b37012684061ba67c22c8d3ba5894988ebb0b26345f709fcf98bd1ec7e5b36e19714ecf86a1e1babf6a36c43d9586aec55fe66ccc147f403b70bb654e75ba12bd4d8bc8704944a592814f0b7f77f4cbabaff24806a759215762a4795ae83d89499c085d5b64cbe70e5cb57f5d0216928231f3d6f8c5dd9438d1bf1ccc99da5ab897f1f29bc78d3fda64abe2eb81d68cd7f81de8627bb03c53bf85e07e64e945d94d35209aca585801cbd3758d0d6d462729b264a1195bea323253691e43bb38c900f6730d74cf31e04be29571c75a125a090af5230309ffc443cfb06021108e5bd52cadf2ae73ae9ad13b8b7f870bf92c5cc11b58564abc315df7c3e2b9d473df0f698f6cf1bcf5bc0a78732ff62e37c797ad09d1ddf44877a765515c0391e6f2796f2624a559340d3adf44c94bcf076704ea1f70a94dbcf2c764929321694821bd6bc81fb37fad98b4fcc8a176a5c2b2716a47bed5a089aebf01f90a010e4c6a5cb88c398d74b74ee8f29ea4a51a13f46caadb325bf8b82f4448a555df748164c7743792f8e3bb1e80b8779f5719a9543525455411d728c2f8201d22db0027dcf76d856ec696814b4b509978b172b5e3a4e8ee20d6dca7a4f515604633903568826926f5ff507a310a21e33b129e367984602efb37b8dc442a068ffa43dcaf720b11437bb23da93f0ad54eb6b63229b16b01242813671a39bac24d15ed6ffc5f070c817f346612ab0057002fa85372002e3ebc20366f5769bfd652bfbc4a915f04f0b9b79b917ff4365fc3d54979530e31b32c31d816c72871d6b08aa1b027a4af7f84896b3864b1c90e33caf18e3087ba3150345504177208b8f6fab2a598c8590019d74cca54faee13fbe808d22fcabdb18991839fe4b866c46e3fb04eaf5923be867370d003d3e51190625742130bb78e82ca4e10462fac96bd0a4d84a26f582484a4c4f35bd8de031b59e3734be8935a6e056613a89bdcf5e28b1262facbdec16fd4dd9c1e38a5fdd7793d2d9b1546a1886a190e81521b7ce4288d257e7715325da9439ca37a8f8fdd24a54b58e9e053f003094fdbd510e47a4b0465f9128228721d8d8a640f74a03887dd99e8fdedfbc295f32f836ba08b4b90c1cecfdde2744c74c39e52fe5e3d85973683564cf45d275b2d4c10279488c272a898cb0b78d9a8f8b2e16e7cb513eec84cca2c5ec6579d11dbf22849746ce5346fc93cd6171fe9f5ddf9d9fc9e35a3fe8509a7258e0efb2773dd307882d313d2753dd23db4515a361433a817268260e2cb4391143c0d4f65d2e78647a9ed233b68c21fda980c392422ada2231a10739b8b8a65bfc63d655ec0b045b5606c4062f28e776b7ea13bd0dbbc0c107074355eef3d1e5d894776a7c6a047da542c74b7b639d24852ca33f426ff872f8f746e821aecc70237f7df9840c730d70428c42eef9920245c89b3b53e5f1a4ee8efe0aa829e01c9263eb1d4dacfbba4823298018b5b2364b1bdbbc1cb75882776cc3d3e875763e2a465a7424a39643a50141204ebd8f2aa8968f1b575438f67cdd9de93881f4e86caf49836406c88f4695761ce299e1beb22dccc1b2f1b233dd1d317875042ed871b3f8fc774752d7005bf419d697fcf69d43afc4d89a2e7b6428bc0d27f8b72f9eb3b2e392207f46943fd6910758582c4a9ad77151027e00252e0674758182ffdd2bf0ae234fb4c8e8b67c1767e17f62f01d1637c1e32f0d4b0a3b75b09e2f365ddcc91bdeade77c89bff7fe15893b6c06d8c172aed2c0ed9765a52914212786b499c04623079abe280c3b37864be54002f67616b00257cf0a687eaf1860f33cde79dfcc458a074604905752cc6de7098a1b6e125b9a815375af262b6c4b56f8a8c1a3db4abd6899ee6cb10e0ac775eead07c856afb3ac9e6497cc830bfe8d892dd49db25e92fdcacb6477bc5a58690159271d6f77d0aea1b15f05f9e101f7e062bcbaedf19de8ba7b735e0ca565dfbc32bd8e55c252cd77adb17a3a1193bee835eb7e9d83fee1e3279e4d34ea382288984a769fc116e7cc1e43271c0cc1c45cabe332f91a810973f5724ca7681df4f64dba4c688c291de4dc875874d3d7ec555c7ca26a5f5c71912af4217ff4f1fc99136f540e0105fd33f44f75310b5efbe98443d3dc4b2455e9fdf98ca7ba59de87c793715d04afe9fa57ad15e4858c0ddb20911f0b6997ed0f3935a3b6547624208d2766cf5633e34d68d9f31721e15c78000b9f7091ce5b5d092365eea6a72fb5a8e5c9d5e09c19fe4fdb0e2673f772d8f2c7ac08a8c9cd19913e777c576a2701fc8efec8c47f856798ba79a54d42f9ea7e695406c427204f6f2384564fcab1e437e5907e3ab1a6ce7b681160ab13395c6b4703ecab0d9f5a6f685302e2e1dc0488d099addd1396c9c731e8dba6e7de07224f2556099e6a3f2dc123e8b09e78f9ae1faeb02832993003ede1f1d9e3e4c6f51aff02bb32c71f17e96dc88c016bbe69fc064e0b0b1f836ef935f71153d2bda2698b1512e14d0b07e12c5df8dd19a18d919930daecfd4104885db56795a59da132f74374f5f279fe6125d49874f6015d1238258310fbfaa060915a3949541df91394d60c86391bc5d84f8734ffe3c99d3362f867fb187823f70a29d347dfb7fc0c85653331cf463b4f1044b01e5f47dfa0c69f110af340e9d33c419d06029f335f68a1b79251a659aee8ebe964be23a8fa7c21fe76e272140ce357d26f58506751e9060a4933fbb05798766e30f16c94272aef1c5b3e91567ca402adb1e4c5bbd081dfacf357549b95c584d84ffd55f0ea4e5abf4d9435ac87f06341298f55eae278fb798b0c6dcd256bcde4c6953078848fb220d3d826cb0d0ef37b49f02d9bb6b93e21fa8ad41059e20c95b606ec15f4a6439819146b5d3092a15e01db392efda9019dd25220e84bc9507e7b86ef6e37c980667c4130ba13b9c7ce724c24b27f98007f24957176e4a10113254a79d1fe15b122a4c18e530403712af79bf34844f99ab50cdfdce9caabb4a3fca42ab1ace1b4316514acd589306d1b09143b7a927f5c8fd5e1bc79aada0774aa6819401314ff18352e5b316772f9b2cfa8cbbc6040c5da59a88aad09c549552a7bc5a6592bd50b733d30cd40498ddf3de164d89921c1a3ecc3b2eccda93435bc54b2959113c88b23d478f452c9d1d86af8674d17a820c78be7646633f885477e54dbfbe21def81e93dcc2243b7d05a4169e2da7248f01f53bd45533cf93c9d23cafa0d39eddb3cd0c183d35e9109ef5f46b85bd73bc33c893e11c5c8b8e4bd96af199ef00f8def782cdf1e0a12964672eb201792c330c70cdc8caf2f579e076143b928e340371638c7a082daaa68aec7b5fbcfb0251839e3e1325af80d813e1f19237fcfd119ab0dd0b174052dec31912c3ac8e68ab494b2381e891db20bc0893b673094365bad8327b577e154f1aff1fadf3266abeb449e2ce57f4784ac91595a35b65766eb5246c6f4786a03ad951e397999704c71fa0b73efdb3440e07e0bed5bc86a0185f0a7ba598ee8330aff5ab8ea72c41315d323b4439c96b77d5dd3e858767d0c44bb896bc13b2d68bcae19cd0c89472c88f9b8a71113ff3b5c7e9b64c60b92b081f0eca10725fb1e6bfd3e07b4f5d5dfd9a9e3026c280ebfdf0347f225c0b08aba49e7d17530e5aaec130a9492e836e93c9757ffcbcbd274b1618d9ba4b762a2228c7971d57ff1e4e40a8adbc5996e30243b0ea98ac99a3202e9f625fd54ca9caf08d7e9eba910dc899c350ee726dc45af7802b4ab6f69ac54fdc35e349c104db9e36881c2e9e5f4ff55000118348643b21f44798de72e0aacfc633ea4a4d00daa7804991d7a9bf8c523c24c1ca1bb7db2496a8b59b75dd34e8fdbf43f2064fb58a14ee774c56049053f748a0993935b717af8a36f9a1acc3cc1cec30992bccc92f66d3e6fdfadd9da673559d55935ec1c8ccc6ed20ce650811465a6c7377a3777173f8b0d3028d4de7bc83ce77d35ef2d00f7c964b88247b1b28e27de0cc154114ffde3c8859dc1389fa6257a195efab20bbd4a590954b22d21063fb2569ece179c9cbe743acc0f956a34f80f3ba7f02931ac4f25e772d536a9b43f885d2bee1c6e49240a71bf4a6f9b5f814d50726412bb4afebd9fbdb5a25460a053b90f336126e2a824f306c185864bf63640f4ed0c0a271878bb74e14e8480f2268824417251954fafeb797c3b21b7ffc8fea8a1e7113c115db79a7f9ee4c3254e81be9954dc1e3c47d444bcc51ea01e20f077d5febe0cf0a82b2d470aaa753b6e9e103d5c67a5a8ea9fa9b15d45e90ec93a2ba04268c4874c19dd5d64f25231a0c04fd359fa95341a2b44cd34af497b258ada5323e99c66ffe4017c009282fbbe2e2921842f7ee9c61659d70a516f1b0da2b2ea80057e0665ec4ba6ed5ba6d48924e65646fa8989ff40151303ee173546cf80d2044c93a0b4e0ae5785d126926f6ab5599161c23499c8dddb589fb811947f966e7c9ca6422161763f12775e0553f36ef6046d8841491e721eb98759caf53c8f4e119915173928e17d3e806ff98e68b78024ff1e5cc5d94c32e43a3584d1a398174f6547c44ae7cb22d612678faeb1bb78f8dfb32404b49db9bc74598ee8f23357e39f7a0e08cedfb60105c06fa9f863e4e50089674ea5b13330e7624302add999b7db51cf520f4576d309cf565d888a9e810787f98bc95641b52a638dab81f5b183d2359186be1078892ed28c6ae7844cd9395ddc1468c8c192bf7c5dfb93df7b41d7ded3b173adda17ce9eca6a3664519ad5038dc5fd71027da489b463d4a611862db089f44d96413239deb14b8f8ab090fd67dac3efdde56f662739a4ac2d8f40dacae116877863cf24e5f894eb759c0fe1273869dc8fff71d39e039a97fb766ae78583615c14c08eb1573f8ae136c25227f1103806e52668e8064d74fb2fa16a06a9a9a03e14609885487a0e24a3159078e28db4e87fbe4ef5c932eceac258bd0cea7dae2c33c3299aa7250293ef6690fae095d0d798f0e61a20cb20a2d4cb3fa1c747f61216d4ad0c0ecb1a80a807d2a5f0eec814fb85b7ceca8d3c98c0e12dceb2a1aa4d38c004f8d2d625bb8247265b1a459a7a85c336535101dce614ff26e8d2f1475c62700506283ca5f29c095440f870db3b862480de5b58c2c56531896b0a43d097935f9ac1872d0fe8814e5a0f766fd00f4caa0c1db0a3733c42c521b4b8515343666d4786afe26f1c5be6cdab0927d77b48a04595db774455650b11265f5a61b4df19d9765abc6ab726e435b7959c217cca2d5d42bea6ead43511c79cad0e2d1564a4f4aadf506d61bd32170d7a668f8304c11545b87a00cc1458b55250e2ae6759d0af3b3800681ac6ab49b5059387f82a7fb6ff0db74fd44ddaa7eb11c27ebec38f5cbb256a72573000ad24cc6b270e2c8839b524b6e630c9411be0bce3588753a9cd702be47295455682c49a3a8dbef5805582e8449a13f260e96f10b87b875328735a4511d85258116e774b63b27a756c1181b1cc9c4c8dede45364f34add64777df8e176e8912e6f36edb51a9493f557bf2b10caaec7a491501986ce58c572aa4b05db4a59b90b064bcfed51aabd5ec9559f3198dd40b5361c4d8748c5d704b0210c5784dcdfae209ac1517e29f89b48698ced032150c1dc6cf49386bc65140864f79965c92e03fd4f6318a68fc46abfac259cbf76a559cab87fa8eb3bacae74a399e5157bc16de5c413789c43ab156ae7df5691f0ace99c62738ef161c1c3a0e67723f74c7f8ab5e5523eabca8b3b2ab2df45d11f84556208b5def043a9edbf5a37e54fb90a2815504e80a6e2dbbafe1047c11476e6c481e896fd5e899f0bb2574e474bc99c85a6aba9c8f401de5999b9d48222e582720307ac921cc875589be614547b395e5d92f7665d39a0ddce566aac903c9a170dc2eae7709fea263ff7e961a3bea6e046107df1c41bfad8a1c90f30736a0965792e329539abce77f0b3a8e73c57dd14085784e988df7c7cb00733272322a68130c8cab1a6a51088f2d64e1b038a13f346b58bb74507a0e20fcdcbc486b7e4e2c0fa5663092542bfc0a4f5831425fc48b6a430be17161df34fbabe956d3a143f079518402a04f003add688fe82cde1df11134449966db8de2f2b0ac713bc6e9e38e8c7d3effde0cb2432e666bae5b4619b10bdff71af00e0fe438f09aa353df2ab7bb879ebfd0e5d00994a6ed5535ff688cc4719b06e1bf33a16bcb1c70ce8aef2f2a74802c7ae4a5568ab17d49288f0acb62550a1ab4225f78e908fe94dcd8fd65ba98cfc196ff7319b76993f9c814b7dd7c0b17d655717c44e988ec9417d4b49c60cf695eca00db93868de41fb9dc99fc41803e04dad2176c61933a7f88a7bac6837f2d89fa0158cbdf3fd292162003741813a46307fe73c4e6995eb947db2a5f3855ffdfb5df8a8fef989d0f142a5e529aea49e66c3ed70949f67a5ce7f2049cf98794162cee0cdb16b46f78a4598f6ac96ef51940ab35409492a000a3e4570f33df63b45741c945c68b550eddd14e1282bc7daf20ac2c5fcce86bb35b9ee0dc84b165d22239834584823bac5ab7a2475525c30419dfba7fe62ea69486bd3568fb28a91442a877edab7e05b64c687e12b28bf2fbe723c631e85c07042b1cfdfd71b337aede932e23a9a912797dafb61f63917daa4e9c2241056e204016183def775ade0f86242cab69c6fcfe46e74d12ee9e7f084e15002d8194e3ad3d8c8d5dbec53be6bd6b5aff6b81dba8c2a3fe69bee43954b0f056d4034ad4aee15d81d22b797ea38767efc3293678b3669cc93b0f04239ff692f5da2ac3e2c48c7d133a6fe610dd3b00c2d9c80e2a48f4f78ccd843b6e7b5e66088b46fc6922860309072146d9940998d337a8ec928753c012af4c43fd1eb3771373e475773ce7abe2785b626a2e5880c9994fe8c58579d234724fe233f0340b9c811963f424b18489fa4c21b76064a160f6d0e3398a05f45384afc902c9a1c558aa8e49a834f98d8cd934fb366b784360bf878097c763e641bfab942871c9dd25a669993f09d90074526aefe2736c8a9fdf77c5de472fd6d53d5f76fa24e88a6976f02a5accca06be48e3bb236878d204005a5bd543ce7ae4e9fa4608ab09d3374aea742bc0d502d47b6732adc4cd45559a3828bb01e42dd0133b58a8bc09d5187ea8f737a0cd48900b35430ab82f577ae1e149f138aa947adef3eac29f61f2f8a920522e035cd0366f10501ad5503e2d9f308e7d0f9b55a425d4c6432e85523b3eebd8130183f8ac187f6e2529d5ae4c808ed8ce784daca52e226d9a9ffc7dcd962185b07943a64f7502210c3027d57b4af54a5278bc0c73a454c203fbb27ff4c2c5260bec353053e22fdc8cc0b0c3d73729a032bf4ac29b3a777ccc9a4397f13a66c43e531c88fd91b640989e06b412ede4c1d35133c99c1054fbd6d4c762568d0785530772a3bbe2808f5b027da7885c6b515d314e8fa7c4319cb3ae2148086d401e67132f132a2e00fd83126512cfdd7bb327efebb583e14faa8b405435f5ac71797e6771429a5479e12398fd0ef8eb035905ba9088fee59523655baa92ac4e866ca81439deeb1ae7964189d4a808862386e652db5a6185bbe619a899b7ed8a8cd2d81b5e3820da4fee86a3c255fcbce1a77e211d4edff6df64d635eb4f8192c27ce1677b7e612e8ef4a804b4562237ce2088a357c698fa50ff8bf270a6126935d3cb780df951fc630cccea98a27b47c8664f50c9321ab5bae2ddbd3956ec585ebdbf6aa1231e382f397d2dae0a01797b40b6db5252e9f616c7875f9a6687244eb34590c0b82a185aea8b95bd616444584859b2ab9a2fd217f36bc48dc684ccecbcfcc3cae3cb4e199651ec0b67978b6f9aa95b995868b4ead3dca429c046f74a418a2d4e355c72e182117785d9669f61df919808e275a666dfce1e8de2ccfd5ac91e702d52c8891e8309ed1ba436c6274f1dbb5e56f77bfd61f5e4663dc28b25b77e4e1cda01d1400f6073de6d844d4b8a44d67db600fb4fd247ec2ca21b7687521e7e358fcc059c229ebae45657348c604dbda802955e4a6e6ab21789c0c3fbc7339acad0d35bbb7c3cb0278cab06fbb3a227722c3b52eb538b706ef3f75a8ae3e1db740c2bac081308a89645be31952088d201df5617500cfb73eeedea0c0ae78c7e7b5e21755b22b3ce91c925271f08b4c77066ea58dea8e50300e3e22fd4c30fccb171a2c183008c7c4ee24b8d89afc0bc24e182b075e98f1310f7a614b372992a8ed6e5a815c7bb73bd58700f1622f9de7c1c5b3cbc26359aff96b9b047e9ace9020c95694be1f2f0fecdc68bac1fbc207ce5492e06fba7492dae2bf025e3ba54f56b1b6a862ec469ca8d9569fe89b41a63332a89827fdab9a06c54b7a1397252da8c03f8ffebe5a5856f5c3908d1057330a52bc1eaca8c13028f91ece330463be02be6638760669042e29f3393a0db5f0ace1f9b2db3292f5c9d8614cbb36aadd150e7763db1c674d4cd782b6e8b6b26c18066f6e63c373cb28693d0df1d0399271c132422affd21396e68496ff3ae938831dc3be6eea715961d7c993bb73c3ebbda368cc59e38235d3a9e340516065db9b4c715296e5ec5bb7114eb209886296266c6303a32be5825d12337a8cdd7d4f53dc816b121614b315909e02105f62a0f96b437a3e5dd9af783893e51097623ec16aa55635e53736775ab6af67dff537b67d611a2ca3882efcef8b516bd43c52bcf999104ceac33782e1973f11ec5d97c80cab53d134fc82ecd37eb741622ec207b08ae3fa4995fa6f9f569226b25ff6c37c4632766a90cf81d27e74cbbe458a5ec3f151ee93b721b093e2ca091716bb0c41f9bbacf003e13d84fae56f1bac950ca896df20e3e8ecafbd3f1348c032794b945d693a7b871529462c639dc2dec8a1ee01c0bd63fa127ecccef15bea7ef467183e683e030ea72cc30c7d37128e034b9e57f6a011c1cd105deaab84a63659f1290534251c0fa40435535759b5fc518397a53a91a570aa3de04c27d58ce9e11dbc02e4315e0fad40bdb1a87ada730f4c7a848dd5c371f49b6dd702e15e150bd9526e30856c6acc2a2813588ad76d9a3e3647000c9576c885afea30ac72c9cab4f212510c93b377c009843faa707bc4baceb2924892ceab5f3c25b4e511afb1407abef87ece48a98a2f3dfaba0eebe8e3ec5dc8c6c48c04ff673d141e2f93180e6e1241479cb5eaba5a8ff54e4915148992bf08bf04e4216d0969f9b0ec7c032d35b46655b9b79138557b463844c8ccd86c91455ba4c9b255a981e221b36ba5e35261ca35717dfe543670e7ef6d397fe3afa6db326a6149c3b1a1f1bacf574a4f9b2d272b68a30ee77ea1cc98034698a40f1cdd11cabdd53bb5da4358964d9e3e417ff5a9534d209a7fa0a5fcd700970b11264b9460dce112a51266332e04da87bf41d2c6ec684a5137d3f6ccf30220aa3702378b10d9305bba3a4aaac151f61868d81b93ec61da536e059b917fea74c61dc42af660f89d47f5b9c542302dbb00c68279cee715795359294ab5740faa6ac0f29b50507026ea34d855f6e4c57587ff753205615993cbcd9e60103804c29bf58cb66d4e03adced48e058a8394b2e68de58ca7c2bb7e6694690c308f8b6818de9d37f97e96ec73cbf56c1eb95251b4a5ff2e506b1da765f86df0700a93c8beddae751417670aec56fddb410b9beb6b3c98312cce38317d3c5307deec198f9ab807e91cfbaebcb8fa1be5d3b76a8a133359baf9a9895bea7c8e9ae789aab8fa30132c57ae8d0af9110fea19afbfbb3c62abcf178f04bf92d5754c39774302217ac5969fd17b4f1f737868b9122ec75e82e2d2231a874b2648833cf08ee14f76b4ee533d25f43f0b5fe6c20b786a3cd5512e9d4ef72e9483a7fdc1e3425db3bd3c8dbb1c8aba2d78b1c15fdc622bfa6a0fd50fe79e25b5a78a819f2436800e670e59d5e95d7607d284060609d912e6d928d2aaafaf6b426484ff05de3471678f64dd1fc958839cf6d9d07370ebcc8cf464436f3c4260206779d85b937c95c7d4242fdc90b52498ca454882fe3d7daffa3a1f7d736371563c30243ba3a3c53f530de1f44fe5e10560e7e1dba27be5caab7d237a33d9960c982e890012dcde6440be6127a4d8f7ea05ea7397a52c023763c5a523add368df3d01cac140cf80fdda465bb12442a248f1b09412e6563d84fe1b9d45fcbe77a83539ceabe853cbbb8424cf58f947b007abae7d05b8d7bef57b516826092877275b1ae469161c1576ef81f75d83b13605c2fa275a47c016e37d6124627f1356e6a6334a8f5899a5ae5b02700cec90383f5253247b77ce3aa99b3b486c48bd5df6585637df45200988289d1b422d09715ffefec257137bc2717c3cc9a3aba7e9be7136ba783582505cc8b45cd4dc3a3f52177d24ac81ddf9ac7fd0471d2b121439aa40ea76e9e615ef3f2d77c2e27f0d3edf454edbe38417f5d182c4c7ae29d1552e9fb5ed0ba714fce191db153700c4524ee9ce209256b2ed6584d84acfb76a7a61ea8c1b3e7140bc637b64e1943f17657fb37089628dfcf29806f68f1055ac72e6d67ca5343b652b19f7db1944dc0a10b8f66fcb0b7f1812b800a4849fa5c21005969834a08c6fd70f272f2a57b537cd23f6f284cc8c88a6688b58452f1813f143b463b1c9747462158f97735131f05348ea2b4288253a5771f7803b6ab23180396507d3429f2cf2e598ce53775963ab365b27cc9df5b55b1635d2bc50f8eab025f9a34e22c9a25a365e4333a7d9a77aecd7b090971e77106c7e3df9338530f7a47f109ecbd98944bc11a79afbeb4b4b6e86bc13ba46565112c7b95ccf2dfc473dd6b2662a1e93d0e55073c50c6f27cc99622bd2267f7d3c49373af093619137fba72f8a60cc31b9cb1c7b325c14f8b8a115584332b87305ee26d4c822b593ae4c96c500962575c50b4e6bc8075c9027026cc803e5d230f73b2e3eef66a26c65950d5d906f495d96aa9ebddf096861f06dcc6c3236fe7460a0b2f521df4f0309d8e1fb8b0c063abc885a2d31d129b07d9da60bbb9c0627dfbd42ec7aec9e3ca7ff13f211aa40deead34b578c1c970e40f16c7096885310e8f2744de2a56690510f8b7debda71abf6248d3ec6ff9e96b0df314fdb67203cab716fbead7b0d5b46906a223a830ebb7ac43302e6eae8275642f6b4e8c94c8bd8ca6f9e9c9878fff1bd5b4dbd998fac9d591a1e5bce610620590e24cf37fff0ae083b5bf486eb998dd46dde84ac5ca0fe2404f92ec35216234b38027a8bbbb023b1773d3d22bac7593d02ef8364f9ed1ab46d0f756eca1d365a10ac9642b5164129fd1d38754158dcc237dfd67557bb3c0eff961ac2ec792882acfb74ecb0f57917d1868c0fe2052fbe27ba97fb9fa98a128e671b2f8e9d0f8bb25e0c476f7954ad99cb8b47aac50acb4a5b8a83c6b5c12b3862db4b7f99be9edc95b0f54ed6e81ea13a0797582e89ed27a24156b77d3cdcc38a30c395c7360eeb86312455e6b8bd35b60f5e2da22849d5a5b15ee22ba6f602c8df54b2b2229b03272ad259f5476e905e632cf3ee855325e9253804b366f24bddd4db0973a2805594fa22ede014524c078bc7049f9c18e7fec0517f642289946c18f4eb86d307cf381756e37a5bd40cd0fdf2af9a412b9e0d2ef9873ef2de1b7653e7c4bfdf1207e9838e318edd474529950004da89eeaeaaf4788e0a932442de0434d308d79bc90f5884a3efcb8a49a4c1f5a78636ff84f0f07e28208b90fb6cf8ed93cd11ba0f50afa1f778a8233d2cca7f34ebdc1c2c134603a667c743fdace06128b162cd82571362edec1a61152cb7cfdc79dfdcb9d46cf95b06045292018c61efba71075303aa06fb0cf80571a4b3b15d0e9014613f1a913a343a64c39fcdfaa8a3914ee6c75bf834e39f8a854d509a1b934cabbce9d0a4dc98652aaf45479068a39ab2a94b135703fd4d250bfc33d10f12eb41c8beb43372c5c91964662f63e46b8dcd9c78d2983fa2d5d5143c7ea89d86a361e94171658b3691d4fbf2742ce8047bd3c513ce32def759a65d0500285252668f0f76bf81953fc466d0e842fc7e5c61a69b6128f561afce5417124aa942e28dcf8129cb81959e42eb66ffe511de2ed8381f98bbacf41c0bd916f949cb6135b8118c98464b08d1f199fbfb8299b5f38b89d63e288c8cd2ef7cba2633b261b3f651df939f8ded0d95e3d8ed8c0ee3b21f66f7f39ffeeae74281bc8638a9665717a04a2411d0c4e969f0dcd35dc717ba57b2ecf8d460911237feaf492715bf22f0b6554eb270581e7175c7fab7f7cfa98cc0c285c3129da5e8081793863b0f16392cc61fb32cc16102a0caf1cb8f5d536ed1dbd63fa5da73cb0b281950a9680d7e15d14f7028e4de30a757d0b8ec52dd1ca384e1a727a2dc49ad7418296f6851685182343f72ab89b86a6a22d72a6eb2673f1abfcbfe58f993a4ec71709bc93399672c7a1fcab09945c66e75bfa911c3d5811064f742db77a3ac9be392445118e2c2c25d604d0598c959d8c19ef269db8e017388e5de8cbc83b2076d73a869594d70cd7d8a06a168f522d656e2cc729f9996f909b807edffa774a5c875caf85082c36f49da03dc09533165bcd9596f26802aa248f003fd2f44513b115d94e0efa9d996eb79d9ea35c675bc39811cbc9b1de9e9b8dc8d65f2aa004f2224de58b70861a49bfb78677703309c9300ac22cce212eb72860f0e0bc43db4916bca08ca4b6c214e6ca9a5e7fe92d989219ce491ca17739c6ed4e157ef7056a5c6656e6aa04770cfc4033e6f813ed5f4ad22aef3a27ab96fc9514b0ff193e8d97385666e5545d96b5c6707f242fb234211e481c586930c367654111af59533c90a9c6a08dff5fd4c6049e5df0f55ad62ca4a96c725e64979297dd82e2f8974c801ab10bbe94592803f769be97c22e9b25618be85bf3abebd19db8f3b32fa6a5dd4c224ede64f29501d8eec0c02ef5a1f1795795a436873f8bb1cf9c6a6806d23155bd68224576697583c0ddc9fe67cc30ca2c0df1a83d67aa046937fe613f233fe910f4053d11454c53712eba4aeecf2be59a7842a60ce073286c6f8558881cea8a76df9eeb449db2c5fb4bb2da2e55e9b976cb9b669e4491e4aa9965b6bf3fcebda120795160c0574d4c8a483870c8bb548c1c86347fdd5d1d8abb2687020d4e0570c50b4b75f2e76d7ea8e94036b173fda46fcb9b5a801908639a69f33974d7fcafd4a6ed2962d9c158e850183795677d9eb3f50c98f7ecbd5466e65be6c621f213d868fa10268a856cc6d0aac789f6a2ca226021395248121e2da4efa847876bde3852e97ecda14621da7af71b9d0a5fbdeeded73f6e7b636f19c705b2ac3e2c7a8db6ba339b38790e674605021283eb09d6fe70cd4761f0b16d8d3794f0783002f20fb70af99f9eabe7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
