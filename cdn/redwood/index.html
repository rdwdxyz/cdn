<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b63239e014d9bde5d55e93fd1f8af6dafaf17edfdbc7a030921f2e7cc304cc5b92b694ddbd482aab5242e07a710cd029012371ea992dd95d22165a0b9c6846fbb1a8989703f0ac6db449c60d87cd40bf3e949d340098567e8a538e2615d7d139d818e6cf2fc2fbf25f19254fb90680baa3b17f6cb034459acfa7d6ebd00fbdbfa4a505edf62106604647ee874f6944a088bf3e860dc08e7210d243329b139b02d10e31488412d5ae53e258e1cadd70fa958aea3f08cd1b73432214a8fd6f1f7b0c5279752ab00517812e487f6d22da91333e8ec92eb47f8920f4fd4415520cd81a61d971f67ecda2092115f67094ab402bccba1cd88a00bdb07a540ba07d7198b65e3d6014bc78b0e3f8822d7b3b73229d415e09500f64916fcfcdce0764a8b785a65497d2da2f0de464386ec6afe6520317d001ec7205990572e3d0477c1df45d2966900f744c6cbef5ca13d241cf85795a9fa0fe82e3a8919085060cb99051f9cc8a22c90ee57d2cfafb07902457cb0b66222ff776aeaecc2f13338e8d51f53bed6daaa67205633d631a2a9da90a85278cb904cd68ed3a71ac2b71f584d274f4118d62c8b8cbf0751caf07afd5d3e6042b2dd9d7181b6feea7a3f96df6fd5562a6818496aac7442691046358753af7dae0ba062667ac627ef5099ef8bb2017490110876c8b6aaa88a7889350c1c67940294707e088d48271187924a89c22533a2602da2aebc106bab23c49e83d3e67b67010d136b7affc8aa175e9ae4269db30b63332d8cda78b55fc7eb018f42181f85654a2617317e669c34d491798c9476b0e80fa87781dcef13ec763fb4f764fea450b3bddd3e53932322aafe0fa74346039f5f91c628cb9db07cacf5a322ed4045c7cbf0fb83517427148a41c587d07c8242c44c0f9fd0c118762df2cf73c429b895b63e4008ab939e871a5235c437cb138024a8d30a87b6c10db056b28ba6b2502c0b044d4772146c09e0be32af0860697d6d5a92e100c687999d1a01202342388cffb5c827f7525c34ab1cb7663279280d653af292c6e8be039bbdc6ba554c6d9152163482c6363967bfb2f24fefddeb4257b685455fe1c3e5cef6e649f4bf037d8f423306dee0ea6a8a28b22523397b43cad0dfee148ee085fca8cc4eeb5c3ee3b4dbcf9581bd0fd1ffc54b866cd4dc5778f1e923590f5f28ae1b4bbc0459680563a9d240c0257d6ce23d4fb253e657fb562f9a92fff6cd869da4859430dbc882da862710be89be952545f9ced9b512c90ab0a7de521398197077993511889c6518a185629b8f7e8d61db7a65d4cd17d6243f02cc768f7feb8843c1509db27a45f368f25ce72412dc040973f778c87072224effb29537e99880ac9aaa9b2bee81ab4a7d8fece7d16a4af68322fcb74ca2ccad90114e0ba3b575850ad8ff4035a6a9d02bd12adf549faba8eda6384e6e6f7c56eea05c499be8b1180df05f0c30282c9d6923888fba532686ec84e938bfb6cfe53732a8890f506d8a3ade65f174c2319d4de9c538bc503db10d589e7ed688cde15abb242eb22c3b93adae2f3a790faffba8a6583080182ddb9e908a4ccf9e7d6d398eb5517d94f9da82df452bba44cb4690b0c8ee98c880b577dc676e85dbb78d7eccc9a9f18d22c41bd304b8d026009d540e1c380f91fe75109edc5e68795a4a96f2ffe486168b41246ff5d667e72d41f9b6c226125bc8125471fb8273515241706edbcd9f9c4b05c047816624672b92cff1355ea9340307b915c8af9af7a7e3a6de93e1166960784e7812f2a46367fb23d5b3c9d325681b18caefaa97f4d4641152637c6f2c5ff8c0a85a169796af4d46cb26eb110e77e7273dc99feb7225e4612f9d949b90ebce50c3bb2996d28e65bff56489593af5700c8374e6077cb4bb7ffef9f103871191dc96e383eb5c8b0d86ab25d94b847a1a8c052ae3ab72fb9a63d255bb9bf14d8c6fda6185b33502640e1f3ea99cc99952b9befc22cd130c5d2f8c4bd99fc828b789cc62b497d740bd100dad54741cbaa7d62176692a5ed6a568aa9fc7c3541d9717aa93693270c99056d9930f0795ad0c358d7bf9d5d8d08201e0142ab05f97368f7d61daf0c046a1a7c40b5a8f7f9ab18e420863d14bbadcb00a5adb8da465ac4db094f5f042042b1b2f34656d6f52c55d14fdf3e3aac1de27c84c3cb0c9b7e7bb251ad62599555802ace4397feb966a311acbdfa04d083c848dfd2c83477597ed308c1fe166c192b38189afb171f2101c81415aaa6372cd26ae768e2724731b17f0e228d59752118321fba92cc4697ef9dbb53f41d484ef5a8aa6d69ed08cfcb43db078cbd4e8731858930352e2ed3ffc18279cdf24adb8760f8533d7bc8ab9d8f446aec15992ae125670bc907c66a746495eb0617fc2f66e734ac8bf550b01b0fc7472683eed62ee716cd4f3c6827e0395a3d4f93fd7658b9cac686b1ad4df0eb5d9bb426a53431e666ee2fb72f07ac16c0a12f45b0ddb1fb26e3424864336a42b1d34e9abf2b5cadd3406ae05e3cff68ee150d3d6d4d562487bb72dd4807ea0dadd4da23043bdee6d6445fb50d6c4b4113f67c29c45f37450fc38f7ea5b8d3bdbd77bfc9427507f97f35662572d557cccd43cd8d3ccf47fc34f2a8388e139c929d0ad56c860d5adb38399d7509fe6b312295e2337c1bf8354b0ccde552c0114e00dd3bca09fd2991c916bd6ed6c7041952c70d8f44094361ff5f775eb1c6115dc039c4c3a7a078fc8c86913bb801149256463a1201298aef42927f90f9078891a6e28007b3834209e7dd6e89482bbf899ed356114649a9de391f63b949be1b47e059d92337da6680945bf32060fb5b79899804fd1e16baf00f83963794435543c604a471f3f3184c803e12774d56be864016ec9220b443df33a6c45f0d721d2eaafdb90a63aa3fde4c53e5ab231f1a8500354be5d5a54db8dc0cfbef8da37207aa1f1eaca537edce3f7cb9b7b944cf4971f05ce1e8fc6b4e1837ea516799f6553aeb2cdf0392813240ef51dc1fce6f9243d9c8fbd9980506f7ace60e95755afbdf19478201accf9fdb7e3db99ea08107dd316922298c597978027c140bf3c3fe833a8670449fc529486be10a71faeac03b1318e4437e9c70c02d658b47ff40b5ef31c1bfc5f4e7c6cf18b35997938d15ff178bc52bc61dec9fdfb41ed60f076cc1a6780e6e5809dfe83679090bd6679bc4f5a9f99af73b7b530e43a2bde707fb324a58bd6f154f82778577320824e5b29e186a286f8606d1b0b7f064891c0bb5201b03f40633c304eb5f9c1505b1149514c7630e76e7adcf20ad57d1eec3877a5fcd31174bd9c338fafa3930905cc4dabdc4ba109b3e7b60a6a4ff7c2bc213bddcaad79e0afb10eca8822cd8f36dbbddedaebf7dbf2054c00a4a779f8c77c872456d8d32867056371d1d0aba1b6dae020e38306ff164b5fa7f52a6cb37dfbb4087a0d4e9c8dfb01d5e4410f7ed830aaddca6c307157600a87e6711b4521c3956f1c098bcedab0f20245c71edf0b355382c4fbe17107326dd062ac37aa0910bea85e22ed792af9fb873b979c30611d515d30b66a3002eb1f1fff4ebb494c9c1b7826854976b34e90c4dc33a9ed8b8f6da2c7d0b7b297645e55439e47c341c011442b2c4e2461a9489ead5937c092ba020896e379e76f6d1d77d74b60913ff755ff56d38f3940b3256411c55e006fde40b3e19a47f0b7aeb7bd76be0d3ebfd73423f8f57f42c3196531e95835395efe58f1407f051a6fc958ff295274b1975375553b9ba2f7a559b92fdadb9468ae66bf8ee6095a46d8b091a1ae2df38fbad40304eba3b85213e5c1286819c3f8128919230043b51418a834a000b91376ce671f582671852e02f849c9d74717a895a38b35186b2031f1ddf8ca438ab2db7cda8cee53f1611c45ed4630fd7cb845819eb455c0053716f5fa19b0a2fee660030dd1f2890a45a5743614e96e1fd5514319d21141e3263d4d27231030b86d73534816d0b58a27a66e4630a4c46fb2e1a356c6781fe988cd4938ad9a514b009fdfe2cb181a9f75265538413ff4ef67a075aa3207001578fcf49311f0b42bc7addbc6468b16af53ce39ec7395cb4fe07f8460967d263fe652ddadc682eda16a519631673cc56c65fbc56efaa627c34439f6a03d88e7f4c192d06a0cd4c5e46c32606690a158551034d0a9aedb64e37319c715fea56871262634e93bb97d6dcf9c2a0562324e0591495220697204d9541270b19f8d9efc683a14df225ef494986850bd436fcc543de8b8c9426c4e663b560265e247d398525494635225020f03bf97bec0e074b0badae52a76058b7b87b14f3543c783260e329ff87dfd61894b4ccc9a4969959c76729e579e4c4d19b2809aa7a01eebf84e7f173da7bd5aadec1e5e88a7cd5eb5d259b954c76dd2c0b416cd3a174ad221c165167eca863e93ccbfdf39013f01faeb8f4c65cb11cbf3d6115c7afc2c6ecbc9386707280dc7be906fb029c663baf9f3784f3c02d66ea7bc687833acca5835aff9ba1f3515a6e33ea8129a7dc1adfd8e053dfe292c7b7fb9b43319ba42b63cd65b9d59216e3c39a7c5bb1cc3974708cb3a23d4fee8d8bf09a2c37ad2e1150f3877f7c3cc240425f4b4a6168e3e488c8b5a91e537b59ebb806ab2abdcaab269a6c04b2692ac8ac0d956328886c81e966a9b598c62d81d13e488dedb97ed024bebe3c9b91727c3364180aef707153408331e909f66ef42f63e8b9c38f85d2563c1fdbf41bbc5dd219068f2c7e5b996d0567f5e86d10f95027dae97338d640b7e57405faf4d9d88018059b92f2bcfc3916a555c7adfd9b45c110426b35f478c55bef341fdb01758c7d21b0430e79bb6cdcbe3cbebf9aa04b60941336450aa2d967643d02ad943c2d2a73ff62105a63afaef20111eac2e1ce27134e708ba0ed727e40fbdd22788531d57222be5aa367c6179a7f9f9d857d53e5d76455e1810eda87aaadc0ba5b63cb04fe327cf45e1451623a01572829fc3518763a09b6820e60d0f0166717cf58ba3344562182dcf9bcef21eaddf1cd968604bbbbacde6dec4f23aa50b28a2196cf439485b299dd8cb543bdca7411d428473d6e5497e12ac54290d8008e6573ab54291206ff3cc07ee9051207694a829649d62c8b78f5de2475c7edbb465f6ea71a014c09fb40e7b0386451e50cc510dace661706bbfe750871a003c2993c4af35d51359ea8c60b8aa1991918e65cec08f55333aed6f3b6e603ca110ee9f7bda56b3444c4208e6b49ce62d50e27eb83e6f349a48a4734f5452bde6db50d02411f04fb30bad3434d15b7e9275d651128fbf6a6f644f688f634ac994780578133bc8996ad1f82dac89c704118d23b6eae5c729604f8b0ef888865b446cf0884cde58541cd0d57ab2d30ea19aee2d5bd267bc1e4e3de88606d5d79eb22a2e387645b20039ad27e9a719f20618d12779f94d2e7b0a7c0610eb8c0a364e6fda9da05954b69f1e11dcd4a73485539942a172e3c60f43afa6267559c4c4cd1d859643fc389b5ceb6b3172b9ae1cc71d716903d4c6a5deec4c2fee1354ed4bc6aa0dd6b7205c52be2e996fc2ea5635216ba86ce4688f6115ac92535d29d2832350a360945c08a6ba1cffd8e7b5eb46c6ee1a98fdfe1294ccd043a81977dd5b733042702d568b5ab692e4acb45efa742cf9e04351abff3111685826be82e333947312698f21f11541a0ca5e3d6534ace74e221f1e933216942a4ba0b5043e9e03281f1f723f41000e60d54443f89da729b6e5f5055a2683770c5173f20acd99f3518a3ec12dc97bc0fbedd7fab504e954b55ab44659826c2add7d9a8bff977ced966c64c98df477c7c2db3ec08f0636dbf27f9b8b4750965e53e0588b192f6f23cd20ef168eb9aa581a33026387a2bf6f4a7a8de9b0d12e13647fec8d18797c7a4e8109daa0435adea20116e4dd840c207f8d93bf3b284621808e1e003abc822dd786641adb59688280a550bfbc53a831e9aeaeb74635c5894e8cb692d7207de8863506950052b32db9428ec92f528ef0e3c840357c16f979cb0e142111c6edbe9ae6424feb6378224395f659b06da392db1f253fa27846f9076d726aa9ef613f9e720373c3c1c1ca14343a9614493a0b8eab84ad59b5753ab51f905ed50b6aa45cfedea641c65f94d4e53991d457113ab3f7afd07fb1df249f9a8a03df82071548824803461268c89c53aea7c62000314c387946d8098f9016669f31d86d200c5239453c9d3459136fd7092ec7697f02758c185b09e1e6d3c828dd1936fe43dab0a9b1c2da87e89761f3ed115c79c4ff4d7dff3b61859f7f28ee232d29a9526299785418e6903f9bd1a26dbcdd8915dbe4f02f9f093754cd93c13581fdc7eb2d82369d0924e540e29eb7612a2cdb31b0607df98980bed4bf48bab251ad712165afbe208b0cbcb42b303b95883cb78c65e65279a4d28f5cac5adabf30ec0df6873ea5cc54b09628ef26edf31b22d51356cd3ece4a46309fbc87d3504ae9f398aad142f534bdac8bca45ba2b3bb23a922399372e679b98a275150d08c48f4a1fe72be1257d493f24d7a3a77bb5fe6cc501ed7d7e67105df7e3ffe547b8e82c0806bc4f89de8f61c0a2d58402e0ac04743c440908ce90da305c2eb9d70f414cc0f8a1656ff6caae764fd5f73cb702048265975bc358a8307721da4fe244e90d09214cb608f7f574fb455b2b9163b9b025f43044f73bad1ffc51b588aedb593c19933c6b30c46de189ba3afadc3fdb1e3565a7ef94c1e71709991630cadd526faaeb7d8d13d25e6a2be9e6779f72d880eeaff762caa7088f90300171316ba2102e5af5626e3ac4f21cc12ed56856b5a71398146148a77fafc1b0a88149939454748a3796d5cf412e6d2f893f151aff9ff0050c7f9be31de3513e72d46f4ee63dd63211e7e56468c7cc6dffa879819b3fda7f7cb0403452dd863676c40096498df4a9cd9851bf901d6bf8f04f6f26d98b11d603dc5d412f349975327f7a43cc5836f7b006cf6015c21d83f61f50b594be37983084d80eb20c212653f5cfe149f2c0cc717c9497c31ec417befc044ee0303acf9b8a6b5e99ef11aa7607fb03b35fb26b9c277de6372b31aa46b06964dfc4b37012bc0338bd11e9a35aa0d4ccd0058503d353a105350f10a45d4943b2429ba290329eb6c9517353cc9167c9291c95d78eacf17560097f4441c098c060433ab98af77280d514ced73b4c757b54337443be8c438caa721b2296fc3675f88c85755235b24cfea856663d2fabd444d341577a0b3f8c7a3aa7ab7892e71762f2e0e16bf9faf20ffbbe7b3c01e9e0c52bb9c1e01433b72188dca836e1cac608669c7649bc0da9e55b038b74b69011d5af69558b8c944435b17d228ef11a6990ef00e70a2e1e28d14877e38ee7b1287edb97130c4427b162e875e8634f64060250ba6569d0c65cf4e827281c22aafc7a1661bc654effb8b8160ef7519c42955fd46cf1d07c9ae8ed83ca4a7a40a6cd5e016cd20031c7e96a33f095c91027fc8595417a90c90773a2515406297f2f944e86e1eb1bd2abce50e8d1d647f96a1d5523c78fc8f6aa5720c8e7422883abc85506f0dd8f40b7ef904e41c14131853418c480e3ee7784a6bb02d624afb1cf183bdc6f105ffee7283e5da2a513e0f4665c4df38264b3adff0883004d04c3b1d9f3a35eda980d5e1d955b9ba8f2b957ffaceebd67243479eecda9d6ccb62d25a4227cd69a9fcb938d311b80d3b01b5bc6ba1ce5c6feb2605de4431f795aca8b88d79a433804e7618feaf0acc889e5f80019c176f63dc91d76a5f0b7c57eb4454014ecbb14bff7ea3099a493818ceef602b3c3a0d99d281a35ef69d4024094dbc36561841acb8f2e13cc3111bc292d228c340358425376da2c44ed6054b5ad6b007a6ffce1305639d56fbcb5d9bd7474c99e354231b815df1a996fce9821d41fdf7b0ae8f0f2a48e5c4f49e4156eef3baa27a76b53d2582bdd87a6b37e72447b556e7bdcc6b1b59081b61fb3d1c2591e7c555331a8647c0d44d006f73139a89e9ca3bfe4f7a047d5f35a7824f148b8099a57fc054ec01d441ba8f70991513370a873f99d665a06f97f74c37cabd3eff038dace64aaabfca65c0524ee50c8227c3685420cb98113f54ae8aba347bf01c1f603925390689dfe9e94675a9798713c3b9b994fb9265dc1489619d41eda0e38e5d6c11fe942dc90fb6e5d472fe5e4697e0ac55b72e9a18798e0515c104ce4209c73112cf118b9abc1d050d858f65ead7e66dda661350803e72b8196fe88ae5dea17de6752adadaf645631cef85a3c2c9943881b65d9d2ae5f5b5ea366956badeaa98b92ff713be102804460ea192f6aac81e36a8f210522ed2a61f2d222115ada59f8544f361f392a2ffdb261d04153937a4d522ab809ce90f3a517c4dec531587553fefa7d78d67b13c5581cda974d1d54de4df876d4f5b5e5628ef6f95b7061d76e18ae9906b78533b28b8a41a89a84d1b2c23ffee9d37ed1d9d48ed3cd1272a3269bf92ec47359462223c5399f88d8bba9cf7659ebf2f66b2a43186b32abdae10f3ee0e5d4df5731550c82890c916cc2e7d37ffbc2e3a5d3af799d118d5fe9b82b81478b69feabbb4f8eb580986bd4f2d37f8be9bc215c8a7d2666162de9bc8455f087b5c161c7a55a5b8538ce7308d68ae2b146e1b887c30331f5cd2529db1ea517e9e45d7f44be6967bc416ebc8b5d07444fb41d3b41d11a1a758ae7408bea7c9d534be5feab7bb46b605ea84c6d4bfdb70f43f802dc6c0d6fa99f7c5e17147d64a66dbda216c482364f316d731cfbea4c1fcf75806bfcd2d031eda3317321fa1ca059e51c8515f96a54966e5d0434639cdaf68279fbf4aabc71773eebb32a5ba4d041b5a053c4dc0f8019f5b2862b4f038c3527af079b5f037015b85dd84965d793567d02fb168946f461c7e3ee163244ec500b8f5e7d4e425be74333472609eafd562b0d78416311bc9ce44eefe3bba2d50bc38a7717043c5c6de83902964dc1f68646daf50351986ed0b05bf09608524d3db57aad39788bc7a27a6114f0efde417712e6ffade1aa74b113c64a302b846fcafea104e935a0c2acf3aa245f9f473efaab42d244381ff0c22caaa5f5d774f1140c41b83fd3cfe69dc2a74554675c03f2e38e75f01ec498caa4287e24d1fd69fcbbab97be01aa1a4a1fec157690810fd8e30b0d9a1f28d49916b0d834df7018f1f3e8a23ea337a4d85d8786f616ca1807f42c6552a620bc30a6138cbbbbde83aba532cde99a409532268b03952d4aa3e59bcbe3de2f77a6375bffacacdbba4f2c3ec599da320759f6b8619fce85bb3c60fec4607f26546a87c162ce363977f4ced014752ccbdc8c9711e6c070d30d335d6f1133fb46be45a027fc5b4821c31ef72176adc9c697d627b0f3908e8d995ad16e251f4d11d435a76fe0bad998da217560d3a6eba0bc97c2e948037c166080efef4c59ea9866b4802536061aa7241bda5a3e2844b67817a53fdc79b12172e3d7f3e0fdeb9f1e6809b2bb1b18f97e06138777dbf4d160d675e4e08ebb4021ce14011dd52dabaf7194aa984d4af3df143904f1995f35d17af84c10c6568fa31ae32fe3ebd05605b7cfc4b55a10c6b6489888629afcc34209ff0cb55d0b7793fda5069bdc46acb502d5d352486b9b83f9c35fa6376e4babdb4fd76b8d3b2405536c2fb08da074d5f626c54594b9004791911c4fa39c011212f08eed3e9ea5f3e40590b82d2b3719f0998c9a9ebd65a6bf7b568ccbd639cebb8d71d93758e4a0e19a8c570537a135822fc957ab8224fda79441441f9d4dd7c5d8d9575c364d1b285a2d71bf8646478a7d7f46e4e87a31eaaaa4f4923e6dd15370967ce7f4cce06b788055bd9680589c7848aa51586cb4fb0146e44dcaf4d69c8b531bd4b2c0b20ef86eef390b9860fdf27ccd19a28dc18ce316e3ae8dbeaeddbcf0c97085b0248f9ccdedd449b37b799e23046f6b588875a34b646a33ec80f8c197605f98b46c111efbdb8bb15b1919569a891a7e409406eed8ccb0c30b789e8462f375d93238c6547836d09896b13b6651781e26b1ea056b3d35e067df7cafe5553ace281d334d5e88a3b1e8da7b24c873aa0fa7e2ad9656873d82cb1149aec93f95eb7c3d5fa2fc848fbe9486d81cf86fbd2eb5c02b293ac928843b1fae69dcb3d59621f2e23a61933f96e0ded56817c07be21338ae62af8eb8d005b4d57d68f4bb1d12d3ac74e59c437ae29c96ed5c9e348f8b4a628da744f88687d258d506036010417ff45fef0ea3845fb010899f54e03212fdd06eded0faaf2a8e9b6c8155269335405ca27d1e4f37619c51b4ec7839fdeed96e64a3e961a59420a2a7e5f5985046922fb9d52f6db6383f498e42bb2a1f1c1ba655eb8c36a35b4223290e1d7803ec0e47a3a0d7229674c2aa3cecf8de3da4a105fc0ff331126fd99deb26ebc6b83288fa43105502b1ab48d861175190cb279fbfe6143d394b69a9c13dbba1337b8d4c0b6067461cc5617f36b0e8dfe604b5c576a034358babe10c8208c778e8bd320ac2aa9bbf5d8ca51ea413d553ebcf7b419f8215bff29ecb7d504fe17001f7f27c9aaef763eee76b3424e1737fc8b0b215f1571675205b32786e7c8a05690ada87cf5772a786bc1a79331bdeab7262bed4c03d06a160439f6f91d35c933575c9befdff26f819bf58404f3728aa65f8f533ca8a5ca1ed13f8e7cb9b2d027a159d3489d8d02c5dc7767d5595d7b1c9ca8219064e209de11f6724c62354d3c0c417cf24d469ede226ecd303aafdd21b145705db00c45f6e6de498432d3a4b69067414a7ef1dbbe196a17f21c0f7c047b9c4470927ca0d31184b3054ce855d9a8f255eb6cc27f1582549b9dd2efd82ebb1cbd0fc35f018af5d021ba339d9569e3a80b516db1af9f09b5a2e6f7c03096ac5b3b9995e9c1f5790f6724d9130b4e305ab08d7f45d9f0fa455537da29e8bdfe42d292b437452a38b076fd873d435a7cffe24819d487b674661011fc6bbea32d8b063ad671d071ba1cb9a7e397520bcdef1b1eb97d33785e088f0523eb5f0a7c4fff8404f3a5df192c2d7e8d6f21fa5e2a710e71dd223f78396191ce88c94e0e30867caca8fe7e2308da2b53841a722996cff6983076cf61417d7c646ff1f21b8710a6f8cd81f06854d5bf6fced00e592d9c5a7bc00eb3fa07a0dc30a4e5e8d7fbcd56c5939744e5d3edc4813c9aa7918d0aecf4ea89f4e7f794ca7517370c9daf1480cd2730705db562c74b0b50318753436cb424f8177ad3b6ceaaf68829dfdf82deb0978455db0ad99958e2ec0af091bb4a6a31c1a9595ba6c44b0bf0ebb5102ddeac902be3c4fa230230f5254fc9305d40dfce7350ced7a290740995f4a104a88d07d7d2523ef7af1ac537782da59f8d0d37e82a5722897e7f7e513e6aa791754e3c8ed48d06c33ede30149ceba8a87196be56a52410e657e819f4c4ad52006180cdc7dd7488576faf041aa19a45ba5234de1b45270c8f1aaa5cde680def89f13eabf437863619ca3d0830288a50d8c7a225e718272e0e4977a48dd163a61eaec6715e51fcb888e67f89a4ece94f042c6755928d6a97f980aad1c7b1df2384d5ac6d3ea81cc6e9679ad753a88523bffb41d7b8acdb248543d9f6ce94c008280c001295136f089d4e4570d4d039b61844a8e57e000d3ec09394e2ef7653ad8b7d2fb44ec44adc31199749bfc4e7b3c297be79a17dad8807b5aff0fb7929acc6d5fff6ec5c242dafe49a0d3b61ed2cebfef266be27a1ba7f5ab20f8130863d7d8fbf6ccaf043dd72d8e84f2e9a3bc4bd0491fe57c142ff3736f780d636cf970439da849820044132199cdcd9cd60d095c8d54f5d6109ea5d30d86d42111bbb643627746db36e3ac6d0b6448a58ab238f3b705039ca9f65e71680d9022915180ecd4239129fd4dab66594ca6aadd99d7d21937948343dc46e6bea80e1eba76a706e1d47f9c617fce7d3dd4e366cd546175ce8b720f889a371e4a658bb998fc4a4701edc1acf31636ad300681f95e7460daee5c8902441e107b45dcf8735b09e21fea0cbcd8cd80f8e15fcb61436f10d097b7a482cd2e47fef7442a403ad6c53eb3a9ae367444530ee57cfea39938d0f77981ef5edda9eebf96f6b7611467f516e449384c4d505dd30f577f46e355916bf17daf1100579959882b5ddf3be0ac2d7b8cd25aa3b6e56bfe9857b447e7507b4f032a42a86c27bc8e28a8148a438afef3991ee1434c38fdbfc386590c92a22f166aeee0d449d18177d5f1460d9ee824c3ddeaf204edea4c2b1bdede127e2ca1f6c532cfa9d97eee5810da6543181669bdce000afc7045275015ce3455a7538319444c8629ba786589b9b93eec5a7b7b5f749f41c211d3cccf0e3ebe12862d576cb9ca37919ea36a1f7753aaf7a2fcdc6501e7b7f5c8793b64d413a3a23ae5fe314069b6464cbacf730f93afa2d114e0c9d1e89ba6d4c052e1b7ee2bc6f4684e5d8076c031134a35025535992c29d21e0af0f6e6c7338e65d6b310866db65a8a0539d1efc34ca632b395f1a03137e15c145fb02b70102e13e42b5b1f9403d3e724a0496cb605b2382b3116abaf8ad39f0ef51eaff9e94e5e41ba29bd63295d3cf842b0a75e50728e2f2988243667f6b2ca63d057fe40f5decea7a609fbab470f7d2e7d04c78fe39f668df2a243529239972b97109d9458a4a9c4895f9e47f89d5d95fdaa2e92e3b1ebd78931dcedd27fbdfdd40da4cd823644d9af293af8221dd56056d5227005e8744547207acc1c04a720a9a845cfb32afabbeaf3854350f478c52ceabe78ce2bce103dd137a70be49f9e0fda6288b8421b1e67a3028607c93c10fa75e0125d0e82cc69d29b1c870fe738d5d3eb8deeafcf8c0ba652d45cc123a3cc1ab65865a1046887c2460bed0d34748a9b2aee0e100248f3e461e3f7a959754995534dcf2f36f39cbf61208d1948f95375e9a991323547df291a69d64951b5e39412bf8540788c415581601a17a3ca14fabb71546db9eb40a1c4c088b292349559eed887c380df4aeb9347f94c55e2214806b3711933f26b3462b63738dd406a66d0e4f062b5d64c2f4ac226decb66fc0e5ebdd321f166fe227b0e3cfad839e46307cdd707f9e0f706ecc231853fbca6a275da77981c669dbdeb8685f74d1a29a828d41079b1a571bb96793972edd6ca52ec48ce3bc7671eed62ee48972f2f1cff381f5f0080fab8613274b2273a17b09130ebc1d0823d19eedfe25c54b94dcfc681e4ba7be80482bde46e813717dd82ce607d5916518507b360d450a21efe91e4fe81f9f54986f2996205ac2bf5dc9f8ffd14284edbd6b8ccc143c82d7559811e387089c17df5c4eed206970f1d26ba30cb21b0aff8cd5bf546487c92678d868e108c3f962d1eff31fded19c6c92b8fd93b2e56162284ff8fe6ac8d7fecfe6d8c2213ffa75c5daa2c072507c8923d47e8451b7cfd0cbb7a694f0930c71d87a227adeb526191fe709c4558edb9befd86cb684de899733f2d1241f5b79a9e9d8b8c1fa7980979836fb3798e0b9bb3c4c8c2b75b5070255d2d09be616e9aa17248826e3408a2f1623ff936f4b5e297698fd83f08b7b7bce892820750ad14530c2447e1c5c68315d5b62f3ef43b84faf46122b9cb266236deeb1f451e09b2726e804b45565a16245bec1806d3b64e00f6976e8a2f4171b0129092272cba2605430abd40dcafbaaddd4b2aa399109c87ed7387d09fcdeb3c0993897761aae7a724ce78b84a541f61a6119d7591f6a4345d1f5290b730c5c778d288bff9e1d0c64b6aac78c6ec5f3056c75b76309a73e7cfd5842e6f8aff1d4912014bae13a154c609856d54fa06a8d3e0123b13222676f3b7eb418e0a4b457e59bf796955416def2bf12a41fb89670185b42e6822637891d1aff17d9b53229263ce46f90cdb10198ad5e3638c692d352bdc2654a22b9247f71c5ee4915dcc4d5eed03283861c5d3b3bd67fd53d2fb97174a1819e283e6b59845fe242e732c845f9cdc3033a39e878afc74d134bcdbfd064c8e8aca02c39186ecb20f068731642802f342ccd114364b57dbb819ecd2acdb3a36c65330f73dc8b1b893ee56d057a2bbb63e0e216c5a59e2f51f337ff4156e5563afdc348dd4294011eeb722aebe4d7e4a14251d6bc4258acaa8db64114097a9279c7f511e897fb7242a8c4b01d9bc523840986f1e06e4071854e30fc58667407ff19d9873265e71810ec144c01f0f976e523f12ffc8b299d9473c80242d956ba634dc2cddc16a99e79ab7ced1c686a1a16f53bb0863a9b4a75d0391343276d064d2df4c9cc171e8a5ab5e354bf05e28d9a7ac2814a22d4f84559dbac0f10571742f0a8de2f4ae5f3c79f65cc3a7668562480891fced5708268f4c8456afc35c6009a582c32ad9cecc7436b39069a1155ab2e65d96d10df7cbd59b77377c25a818c0b162c16f4c5b173b9639fbcc6accbc6a66178035cfa3617b7739d4a5aaabeca93c8a9374830b991f88f7d4dba0dae15e7e9404b8674860af79d8762b61df5804d92d87e1f04233293dd7e4778211a644afee02105438f1e59d6ff09fe306842e52dc88aa3a8ee9a7fdb013aabd310b343a9ed3f33e5fa9945e24f20e74a55870b6662aff33ca7a26140af43a74591701ff5bcfa0305cb8ac69142e5b872dd1ad6f819094232432d6c14cbc5be8ff0216a6e2b63860874b4c6f7f92e75318e17c2413be0f9951d9e9eedfb0566fce38a1e10778fbf7deb2a028bdab210c1dc2dfdbd4c5ce710047e8bd7fb876b09f582277eba4c4e194411f7ab39c24043a5dd8e24a43f376cf8e791907b869a826ebebc61098d40d6cff7d6bab1e2bc1ea9a6c325a7510c16b6d1eb63e779800b64d3160deb2704d1b6a1539b0803b06ebc12a735eb5e72e524187e2e81fd6a177a56e3980c3f4efa914adb7a74fbb46ebed3f391bee86bee7b6f7c776d7c8400ea07b00aed79f5481bf8d635da3caa98459b71479c3d2ab2d3569a162562837849ae2139122b8312f949a04e2d1caff50e5c0363c6f963af1eb5925963a1fb33b0506931938a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
