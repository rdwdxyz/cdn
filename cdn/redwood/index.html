<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c1a9475193e4c5a04e97badf38939205dfe56770e9afb54ffa125336781e046e23a7073ae296838e196137ccf3c7b482d7421c97eb0b47b4b932c2fdcd41dcf683fd325298b395a8b372c954b8b1c519df1474c8a14999c618ea04fd567d10eafbd6ac139086df5a571787db059f9408d8c2d771e2f374bea9957fcd6b7d1379668f2d420840e1e5be1fe9b470faaab8090d181b8e62ffb88752f94a757a578d9a5b7cbc0f25d459a4091eb66a06729dbc375e9b14b0fa355e1f0b077ce02cb3101089cb8e16fa4c7a0660113ffc98acd06153a436d244e414782f33a54d36f064f04e1fc026ece479fae9f837bde8466a7ca2b9f865d320892fa2f410321a0c14225e6da39a9039a2c5102e711b198f1b072a3f67caa982f1ea666215d4dc0c6fc0c96f738cab7ef7a74d190c8514340275a851c99def9e9ef6bbaacbb466e38c11db55ff87bf5921cf043f65f0e41a36bfa807229078fb70cffb93534df2789ab2fb7346ad0456ff5b03c5f4e67509df17bd4460df8b045efb632614b824e9edcb5ad9d8ddf839a72bc18f4761bc79a02c011a31dd4da6bdb9f3ac8dc62db1caa166e2e22e8d092f94aef6882964b0ce4a2f7557ee640079b81ce48e994706a5f33a76120a4802991febf162b06bb4b7d52a9f2331347836767fb70fe447c3e7a55bda75b51be1daa550d5204d465358473b2180a636e1da1311f9cf79741f20be5748e8fb5d1c45873c948f9a17a9a74711446296865484e3dc90011c9c3d848bd5ff0add8fefbcb8730ee4820e5982f5c0eeb73f2d0eb04e62a0957916cbeeb0069c9a0ddd95816fc268b2c4e183d0fc04c8600a92446d7980f46ecf888619e66f2eaf9cb30feaa5439ca1330505ef2cc317ea36e09116f81f5e37efe4d60c1a90d100f1f9e06fcb5b2adffbfc1c1555b8921fb007d6f0f94db4357a81b7c3126536f7b2b4ddcc66fcdf0485bb41ab674c8ef69ed7a4e5158bdd456810d527d6de19bace47640d8df1b7df6f521562e0145650911c06b5576e82c75cdc9e0208d28b71dc5a099e0357f1d151ddd0f303675708043e9320ce256c0b802ac129983ef894db1248e8d234b783014861e2afa1b5c055481d3a350f728040602bef5b5d417f0a7bfc720799f66c790c7a1e172715f7154d7e508a6dc9e2440b86f0d93c52961ecf0515d326698edfdeb9d70d6f6f08384edb48f35c852cef5ad4fec60a635946f81fa394c140756c4b27a1b152e38235acf7d35bd7d430061a05603956428cf142f3c0aed14191ecbd112b79e229f253f6e89a28daa669ab170393d2771e07dd53ae0fd071c8f2305f011747e12e0c8773e7fa6132cf5f00cf354f7ab9f69c51b855c2a4d4915b368b0941ede24cf25c2cfe392c63b1f0d6d202684405b359065a18314a0231e7420ca5188e3d9b6da8f99e225fa58a9322910b07c76b7565ca8846f7dbefe8fc1de18b9f17d18bbc7be59d2004efc586fadee56e9a6fc4defcebd0bb13ce58fcb323386cb89552f337efda80a7b67e50c001bfe4527bc744ef71b1cf6e6777d294fa68407f407f5267cd7e611f458968afcf79f6cc04100970d895b689c984813d7d2cf649ea239cea8161c942744cce5140256089d345c1086bc6faea15f4d095a0bbfca59cdd916b2a3349bae0b6addd852e5c26a3db73f1f742fa080e8c1d49d8b806ff163d12f064f3640226b020cbe5f901207b6cbeb6dac497f221fffd9adfa348b4651e61791b47a7c4045d1a40ef142e3e620d22ef5d6d61a9b4ab24f651ec53dbcd3df5f10d5a88e106934437b4b2b35dffa55f6152341cfda26cb2c2afaacb49c35f651149a65da17b04b159916576dd53fd7e568ee8d4236ede587f6a657a214e03577cc09bde5d37ce62953b3bfef68984266a05d0500fe61b1b320658ce99208eb3a85d6dd720790d512ed330715368e0e07df47ac33e96e4ee673de01eb908f5d9dbcb0510008f0fdcc4433c2c5150eadfa99b07cfca21b1593618f56f385f9e3488cf4ffaa91cfb95d07177a6d2267fe19c21301c0435f0cfb0ec39337bf0cf11feabb585b3c00c530994738c437080eba89ad10442cc483a1a82123ec1d458fd60eaf1452ce01082e5cfe9f8d7de19bce6c41f6abac485bc30372986378ab6723371ede4526ece9adf8093cc40b49d8516b29e17a69f51fc7381820c476b98af52ab034ef6fc0458df12042c7a6f6fa9b7f0cb028f569861ff7b603a64043d6d4db52f1e81febd46eac63913ae34e318c4ef88706aca9f6aa35c063c474fe2fd129ed1d81b41871dc6088c426bb15fc30260e1a618b940aed2937a4d314a84e75df0057910f233c66f0a2338195047246a515c6282930d7d2f0b52c32039144988180c55a11a50d5d678019922a142c8eb144a1d73ff85c8eaa27142ebb061befd361c0d619b0f0e03a9cba79c62a96500ce15f00b4fe07b72a280e92292e6cb66752821f74297389846f6a155332f16640313bb1ecf9f83732f1a7d47d92b50d791e5fa8bfbbb2103c68fdc2503b987cb05bd959b85bb6a3a19e8a6f80c348808739baf76470d64ad1052b224c24ab1f9015f100b1986c8343e7c50dd07bb9fb435bef214ad62e62da737d70c84bb3999e16273a49c07c3dae984131d215a32ddb03a758c82a0344038659c01ec6a8341150c74bb44085ef463996d37eef5c1c1076bee83f57c27d04ca3fa2be60b5ed4493706af9d5a692289484c156b9afbdc71599abecfc431d62d4561bf66d74aad33791f9f7cf8b92ad2a21ec95f1084cfc01752be48a20650c2956893ba1a9d106e1e2aaa3138fbf3c91b59650c658fc6178ccc3505d5f35933ac4daacf051e40307bd48e9366ea07c96e0385e53e9629130c1cf00d3db4633b2bf09f56387a3ef7d3c09733a7ad8ddc48989bc150d6df2012f3b5b164f0ab4f449ff1df65749d45da81f3534e23cea434620de4e1451f31dff3da809c63a0f5b61b71098a2b59acc1c484d33434cb2f66e3df79a8169aca9c032bd0b75cae69d3317592f990bcb7a958afe3f9e10860a2eca4df47ce8e2f985979b64bba470c89b60b71aca37488c59896cb03b98e67ddfe7f8ff35d9d395268d5912c700a6bd0b202e09b4e587b930ac6626dbc685a2d79bdcdb80ffb424af4dc6a62245d87a7d38c3ef6c0dc58e1280bcb705d17eef16c66d0cc8a65f96b8f0e2db24dc1de2e0ef3f9062b4d31a64a40e841913087804463b8b6b28e93b5aee1aa64fc7ef1abedc5a6a88977322f5d9f3fbe37f0d5ac05496f221da735fcd4c0c2711a7b9590cb12d81eaff67912283af4f77662b596bd7d82a04f605fe6dacbcf07c887741e2f8e522e0cf01072aa0868daa89bb7207890d82d11313280fe6be781a30b195315e5f98eb3ab2e02de1ef0d6c0fe6d921474619e480f7a7a5f8f6cea761ed9c2585632224bdb9c07bbad928f5e93bd0e54b017c72a13a6ac22f9d5c0958d8f7c55745275039a20cda146ef0af804db712c2fdbaba8570483af4559d8e9e06fa8d5c104fd9cb35044d109c3c84a79e092134c22a017158e764489ffd46b82b4adbd51a3c9982caa74e6aff3e2ff236fd99b6d683109261d250802f0432899a5c4ce563da9fb119ddcce2074c6b0fd21226e948f744561a3a24bf99e9d238d6149213c46c5a9fed0f82d894971de42fbce139d588e1917f9697b42268b664d2a410ad27b87915247ab17f11729c17c1f8ed0bdfa16feca1120f56a47d11e3247507d4482d45e60109a8333a0fba3ed6cc49f06c76136861a1860d84e366a31e6f189b493f9d095656916be2881e5a26c28b13bb4b9785f1a193a83644c3b5d92a71ccd0be0dec8601d942b3cd3e2a7eb46f181adc65dd59f62668746e26a38ddc78375eadbdce15082059ceef221c52c418b2ef7675d407f10bb84e3fcf57a218c7f5fc9bee7ebfd0fb7d6e19227db64df5a75fa38b51f849efe34798551e19401f56823900c331d4c78ef4467cac7ba14c7ded7aaa341b0a58e24ce2ca8922c88a0e80c5037fad1b98bf68bac9f82398176d3be4f100d833f2cb6fccbec8197ed41ba19422c5f50d4d3135b1a5b096376e7b672513caf3b25f0838b0f407f8041f534cd1c18a48c6b6ac16950a8634ef51911507990cb549da76b5376949280858fa8ea1a75c41211c9ae9f49357110950e14ba5462752e0e2dba5a6aa172f33bba8605c9e47fec3c66d2587c834f2adf4d6702df14df8af0349b8c9b3cf4ad015033da9d17737aa90f2fef3480891ab3f02cbeff18a73b022e83bbbd2bd5e5e0933fb3080268de7ed123156e100089054229ae66a64d5da91a099066af10ac6b840c5e0527b87319c8b6a80c3685669941c21d1c0c3bc3e3bc2d0f25a95f74e7b7e4b36be4189c2b1a2929f172352eb2a091e1ca4b717c3941c48e171ae6bc9ac60c9933c8c838c29e24ea16b4f5f31e34befbb20d9beeaccdfc6c9fcc8a46bfab04ca2c467c10427f3a157ef628d4fff72e015058dfee06f44a4852a2fdbf611dcc4743631f957be5e22c7996f755f21aa3c1adf100bcac5d2e5a8846a65f30038831e04aae70610318dc7a315fedd0f7761cad3fa71fb6c2c13f1d4ca75d3d1b1949b78c79f67eb0e2c6f222aba761db7f1a255a9754ce6e6e2402cce98849d9d834dc6df5e8882e0d05c71910ae37c48796bc064e84e5439260e7bb07bb1146638bd9ed6e8dedf08086864fecb6c773ef44526e9a3ba7ea007db4f462582618ff3139859c62b41a9f000465967a5b90d0a663fb5d2686992ea06f53cba2137f62a96050e7143b177e5520a6d333bb6a418f7c82c2c6b64cfb99f3bc8b07adf8f35235c6f9961249e1c65239136feb16e7db1d573c8fbc1ab8549abf5e77aa7bf8468f730de3b7b8d942d81525865d355310a8ed5a1509798ce9a95deaeaad056d484b7414a168ab9245d234b24b4811182813d22eafcbf1e144abc43b843cb44a0e4cbf5df266e30def04fe0a65bb65c1bd0db64f427e8447e4185e0cd207a58407c0980cc3e606cb2e6c4195577f5f111728d74ee229aa80ee1ef11789f6f724c75976a136bbc978864ce4cf7f3d976f982fbf97711925b704dc52086e46e752d1c9ca2bad607d073c3af534cbd0cc4b007d6e0566ccca8d651468478c350b29d459b2862cd70df2f1d9a8e8c43c77ecbb1802546785b3202f2b1662899d61d91055e7cd37e790239e342762475d2e43fb6439c9d2e4e1f8efd993c47c26698b5d817519744a1801018e6a43eb094b2001a5d92082070952469113ac9cb9cd42a20e16c474f3a408af837abf99de0aab7060dce723f7f3c8a42f81b48f160e2b5c30d189d6f3dc78ea4c61e53b7f79892ad16e3c2180c52f0b934acef92bc4be928dc86c94473e7a94f41d9da84d7cbc34442c80786529d6da0db12547f8cb61b761619d2cccbca767c31543d7fa06b942c61e30edda691e165eee924f3f2277f58fbb9d547025f719a238b5026f60037228cd5f25cc638e25d45f985106407431c13021ff89ae92bf44a0b7eb981e9ff4405f9b854b200eeaa2d2fb94627fd8989e7b7e81b7ec5fc6b936d7849d96544f05871c5a92e2da3b6c7af1d68a5af2aae39b8634acad8598b37ae87cb62a21e707bf8413f6188b1d5a8e4425c98fe48bcc17fac4d09710af8de058666f1df9ce6c3efd35efd047033c6fb901afa1828731baac5cb5461580ce4f71eb17ff9f8ebf089a1a2bfa2eb97fa2de7612dda8b163c8fee985aa8bcdac0c47eb4abb179fc7984124baadbaf2c4ce0a800d7d935931d94d813b45bb43c19c0e369d0f4e99151994ff8a9a5ac080defb6f28f69f56ca160a97daa585e99c15e1bc18f7f10919033f3bfd3905d0b529e4151eea1f88651b7e4e975bb419510bef71b1a5dff830ed8bfc85aa336fcac8bf27190aba0ad9eb5c59f35b4f4ccf4ccd4cbc8114286ba7fb114b177fab9938b6ec26f3be26a3ebd8ebbde1a31d645688fcc48d17fbc6bdf361148cf99490e3cbe57cfa2d665df3a32a94cfc92ba1390b966a31ad4a122b100881663319cc96f3c052dbb1c82ada120b33da28c2bafdf11e42acc21a70472297f705e392cef2ab018d1d1fbf8f4cdd0b5322b00bd2cb4c168a0aa6fb0ca4663cf030b9cffd836c0caec64107cad2497b29bfdd39ceafdaa00168521768738c07e4da797c1519848876dc57d9f9816856c9b57dc4b01dcf1ce93913e5b3cf1aa26e49172c534bb7fb4a142276c9cd3cb1fd07ee942b785647432d07b85af43ed03286943e40e58081a35d838ccca44877376dba691abfffbefd0b5b39594fb2e51eabe00c62dddd1119a892d77c58aaa2d645e8c9f26bc44ba1d0b49af9671df6f549544eb6f4e25bf36697877305553ce98cd4a8219778a96efc913d063473c010b7443e1f0640325f5bd682506e60fd2ba9ce3c5050a45add417009c10dca1c1b51137c1fe8ad7bf04069127022effaf36ebe2327f0f069befbf5880d610ca33bb5bd9c8262b83e7aa7ad30fa87cbf3d869e088019e1a7aa7668db73a4953f26dc554c6932eee04b5e4629f2a7e86e8461f33fb4dfc3afdf83701e3312a2fb238d82acf7c0bbd7d61a9d1ed20a7bed7f2ee2819b402c5fca596e890b68bf5e62f9f3f9d7e4ef75652ae626b523d15f7b91c8929a08452bd2d271dbb2d8ac900d6424cd93fb72772973e8fef55f68281861ed100d7627e95ce1ee8ee4302903a07c9e9037575f9a3bed4426553e35531c933ad81847281560467c65b71af6b25c91f10b3bb313bd6f0df1fe99eb0c57eabb8fb038150dece492423c6fa9b16965a3fb71297c283b8f5033aeac043529a54618f87e241145dca497fcb0a1c93fb3b20b11a95aac979e578f51f5a1f08d84804d15658e0b5ff865a15c1e79991ec53e85a10742559ea73b6d50246365da343c98869d357c559e06e21afafae114be9100f909b23ac5a23f42247eb7efca5f8fded64d32df9163300b7da8138ab9fe95aa52708a89868cc2fab5a1f40fb25357df26e747667aec45459440189b9da12f73c7426ee719fc41a64f192f90df08703179c0bea3b5eaa73a7bad34ab4357f641d94b9b4ac57d5bfcdd9d18cdcf6eae1995ff861da081da0384dba7a90280195accff37649d5153c4397a8759bd8f8ff7b1395b649c8a8a707ccc3c402be73a2124f7f63cf529341035709d7f0cad9312b104ffb4a84c5fbf504ded7249667ff72eca70476854527929ab985c55fd5f5bf0835c576b5c5e5227c89ab7932120d437acb2754979f485c31cb7edc6cdecaae87be40d7ec54a15017aea16af82fa833f259a16ec000e687624abe1f51e7492698dc4edd4ca08ee4e07f0d7961013045b0ff04502435f92258b67d4e736120bd9e2d2e36cfff55943857bc5a16d339071c34e1518423469c79701fcb4273ac9ee5337c3a6c1fb4cf66db7e669ac6a696b19106647e5b4afe45eb16ea12508c6465f4d29acec82b5d99f21a250a524f327a8e3e9b282ba7e2a13541d5ca23927c2610d4847478725d99e8a332165471e48e2056388c263285c3a281827b9cc30b67bf5b1b61fe7dc7cdca5139100566084b69c50d419bf0b7833c4381f90a7e821e2b61b094f672c12ccdc3c3c497c5b72da3664761c7a510f6be9ec990a60f4ecf81143063432d92148984d6b81d70d04d0295dd24d087d2fad3800c786ed89729b107ff86cc844ed4851890d44b3020686c5ae3b021f28908a34848478551131873b54af7baaad66149ab9a6e4c891ae9f7166b99d7488f992da556500b0d399ed007de9d432ad6904a1b9469943bc46ea048d5a03a8c51ecfb7ee9f0c1f4fb022ead4d4bfce5a64145ebe6edad896f3c7d34eb2ae683fc2feb6d6863ad875aaeff17c644c303e9fcaf99a0ac94a23602a44b4a0433bf2b7bf2a1be54a343deecc51cc6ec8cd91dada0d24dde562c5d0c50be41e489dee36d3b240b28e7807d0b9f323268c9532b38258f4d5c71c5006f6fc3ec3cafbe9a07f4d371605d3c20858b2490a0a5db711aba319a6e91a5e8474a3b70a670ffff3020d46488dfef2ef61a672a7a6f8ee8bb7820f41b092915490460117f05133ae21cac96d9ff6afe6934e0b4f12c7059485e789686b2845a3182165e082f47e480d53dc50baeb0c1ca4c72d7f6e61f0b34706031a97b56843a1c3ebfef61592c0fd39d9f1497a6cfc683683d893fc078e00ff0b2b313c90aadf4614299d1cc1be349f8bec561e2f628a97c5ba372ee9f90d180e2d06321181522b8c832adfae48cf20ce32cdb125f0e802351ad6d27b0aea7bb51db52acadafa5a5b535950ba3cd33b34fe40a8532d5a4e5247bb3cf3045e5ba6d7969904b0a3602324c26e2765ebaca9e6af79b223c06e1b9b0c1c631c19f99ce7228f31c611cd17bb8e8bff7c4eeecafc5484293f22ecb33e96bf870fe42571f5abbc5e3490dfefaba04aba8a60502404ef084ac7e280afe065320c905d7142c1c052f95c87cbd6e25ac067b9270fa4ee1416ca291ddbc9ae75a9b08f6f1e4982d8f06cbfd499a1573627dabfa3087af6bc38bb51cd6249f5f6ac6b8b2c847126216d9e9b0393d0f3a05cb7e92aee07b703443e71d14bde0d6f45b0f750c39f2157a11dde9503bada51aa54af371fc4b8b93f2c2ac04565f08e3f6c6a91aaf93fee21675ce872e88ed2fc757fd042727471f6ccda5bdcc087a1e1b4a2c29c1efbcc5c06993eeadea039d6ba439b41d5cd4fb5b9d5556fabb9d2ca8ed9f5f68e497bc50febb7a71e77ef22720bd620d2caf91aff53fa9f48b233db8cda643c72461a11f6ff1c126f3179d2dd6590d95f9fe3d5116dfddcc0b08d66f109c0851f8bbea31be06218d83eb3cfa2f9ffdea51ac42b65a6e6dff31129b1cd35c9a20325fc81f68898e75a8720a0ed95d0d58c6f1e8e8206685b2c9074116dc22dc6bd4ff5b06e35eaa6e184f6b3d7aff45dea867ece1fcd745c3d649899621a8c4653ab6077c40a2b07dc162ec8eb31dd2fe983cec8133bddbdf039c7b5735766516d293ba6aa23b7c93710adc2282ebada7e6190053d2f7eb7e72fcd404d7b1c6e0ac19407a21fd25837bd78898767f072b5dc1bc48861c99d6941a308fd86d6b149235d8c9ec917ccac532dd572ee0c823b443bb7550d2586f5feddaa814320d62a353baffc7d4abea282ebe843cda168f824a80be2016109a26f68f71e7a5e034b5d4f1420a09cbbabb756538b5176647bcc2fd986707937492195543eff54461e74393372baea1d543396dadda19a899dd12a33d4c098489ee28b431e32e4b17d2c11a221f53619b68f63c311f0688a36a58ef2b07e9e9df7650e1d520ae05ee14ba1adbaa6b960f8df3875f58681eb212971a9c5a901d6b1acbaf70e1d3892a178a9ade3e494f0733bd9efbb7ab398869c93b26f9129e446ae0a83d4ef9dc07eb9f95a2abf7a1b30eb39ced1b429286f6b98eada7470c8a685b34d430d473a2c8aec292505495aa5621cdf6656cf6fa110c1c89098872e4a90675ece2f247ff57817447b03271932856e61d7714bdef704a6dd3a460d2e8f9c025addadf190ec275bd24ce02d32a692a50f31522020a97f2b56710579bb21b0a5aa606bbba7165951973eb9ddc4eb986ce7262f4001ab619006327c8a3b26945e0da62f1b700d0affe08e64a6a850de3a9010f992e0af1d2df77565ebcf39b5c5111ab74349f40277b8e3cc83780cae46b310b7db08e8fdc595fcda170e4a27a6f31da1bf98110a675769083e3574d5cb6b3035ba056a1b0f9551759bfe4b405900017ae30a68b3917cb6b2669f91f76293d781cc951c2b7c2338ab2ee8bf35ad26c75ab2bdfa59c680233e0ad8279bc9520df1ed65decf69aa0f5dc6f81072a54ee7136508a088c28e8340aa600b8eb327be8ee18ff7717cdb189c7055bc94a45267675137cf7c3164be941c54f2443eac2115fdc4792908791101e5702e9dddfa4766b14650975e33b207ee0282b515b24b8b8da9990feb912960d19a4acf7f4ef8e4ae337fb19534e43a861230e8f056116089e2b235104960b06d5df196bf39d689955fc43926a7f23cfc9bd70a541754c66d7278e9e49c10086bd276daad2add143af6c73711fffadb79aa9784b63867583cbacb36ef3fbc49242026da032e318b71907e0ab4608533ea968b0396e8a28e3788453fe08677b5aa4458d2a3c907c86c529abcc41ee8f49302d265db0b082fd94a73c732703e591b7f4687ad74ff8eb6239cbcdf7dec400dce10ddead37dc07e762252d399eed51c34494122bb78d28c95d153a90226a35608db7470fb09c6bf6526748dfeb331abed476c0a8f2a78f7ba61b96d7bd0320809f13a75f25f0fa0f10c255f72486d41370ea4059a8ab6dd54e333162745386860b0c1f2924e8f943487de89d269df78e0fd0911ae809215c213bd79f448a038ba63f08aff330371f041583cc0744f4984c5aaa93e01b93728be8c1c5a3eaf2b890394ae3db3b9a9b0adf644d3613e77fcd47eba641acafaa5c64ae74810c3aa0e2e01db9edc297d962ad73dda9d6530913bf86fb548033a3758f9ba22304797f070491e45fa21348978cf9dcd4fd29ac1ea3ce7f1b9c5e1a7ebe8c4d5ac2a6689efc81fd45a58ccb59fac8f1eca54bf114ae0f95da1c279a1ef29cdb6ce3b5b4a4023ea614d42b4cb3df59442ae005dfad1120cac6c44e1d2d12a06cebfb4e701e430445c15cb5e7064b79f7a682b81e67c89c7e7198f9cabf09990a9e7f3b288df46bdcf0bb77d4cf1e8a29d0880193fd2582d4361c4335ef80b1adfd9b3506a4c8d08c5c8f7ef1b9c57db3d02c2942a443eb456e8854d2301b910decb49f5b2ff45b33485a4068da497b41c1a3f4d850eaed55ad23365d32667477379a38cb3cc7a1d79d919eacef0eb4236cc9d66d31299cacbaab82cf121bad27ba33c485d4c7c1dfc09cc0b779cd6a5bafc365688fcadab9f69db98a4758e244ef1f9073444c4296ce116a324674001d9a80a57f1a97e1cf91be4f1cf114f6463ce1b2eaa9673bbf8aeaae7edffc69f69b735a7d7bed4c7c19671f08f826041031e726a433156ec28f0bccb37283777ab145f17a65f220070e60b33f1fcb573e31a697127ed210d06af7fe14c108656080c132c53f63231a3279cf1ff607b544afeac3732264b999c6b0fb1d75b69007e6eb20426c0397ef79cef4959ea30f2d2a9b855e052374d7b2a3506e042c183b0aa4be68df85b9219a518e9c6be8915ec88c0bec9c8cccc78620876e7fb6cef016aebd0ad9d715a29f58ba6a405ca825dcaa397c9bc45ca93d53649608d3f2eb34f80f627ab2c1d703d5af891fd94bd3c77dad251faa9bd7cec3b2644c684bc502c7a93098a3b7360ec5368097168e52713de0df15bec469d35d7c670f01a230bed7dbbd7ecac8201d47d3d188ddb10714c2d72c044dfaf934ed25bed8ca98ce69504e38089a1cfbd96eccd4cd67531ffb2a73535806168c02c0b65134f99b0a5eb65db1ea07469cfb306f16df44cb7c4d71ac6c6b19de15a70d7abba6023d1b7e301de0dae150fe7017381549765d2ba32e656868e5b80d0f3eb2348baaae55c2613a0ec6de91aa6b0e264fac40566a6f64d8757e03301c6273a13dccf8976d4b0e3e81bd19ce6b8b23d512c8e69ce1fc80d6163f49584108bdca0a69fcc3813e30f2de19d969b8996bda7f60eb1bade62b78ceaeb4b0fc741acd23860ecf62ee0e6aed2f060544c080072c583ca00661525b04f572fec451e12501b2841be219ecc7e9901762f3ae7c04b83e8058e3138f6cbfab80956b4a96f9873300efa8e10981ada70dadadf1ba5e04c09ad9f9530b7138677486f5fc5d3f24582606c80ba1ce226a7fb8743789696e99239a5a2374cab127ad658a4ba810d6306d9dc7676cc75526430c39281ceee61998a916aa985134c57c0838cfb70eed486057a1d00805f3bf57e975fc0c3705ac8ad7881bedcc60c6f28bdac25928e7726a719f7e7005977cce63f7d8a8aa15725751871f139548a4b5e83f1f6d9b43a418c5a84ccc2dec141845d5c9f694b95c73097104d8229edb4c515b0da5cbd5f968f264da56f1b8484b38003e2bb18614d92c7d7f14776a1d0810ed5827b4bb5c4572899580b8a6a28a9e55109d01c76778e2353f5b57712d4480ee8e2028c97d934741f2a74a25eda0b16469587a68efb556ea7ecf1c6e23ccfdd556bf9f4077ef77b121552fe941e2f72aca7299a003642e5aa4cdbf4139a269394a4d25999343a22da9713902ab89a7b1e4b065d15d90d10eada6ab88ee7b3361d083389c59dedbe9f2a547e933eac98f9794904fe292109f0fe84e811cacf5cdfb44fd56f6fc116dc3c6b81f5dfbe93bab3a9e30c7e76cea7a77de9c6be7a19e6b86592979b76db24ff78e7059d9da4a7037375df577bece15a6b578e70d571ebd9eefd1af786cbadbaba0b5f211a0d47bf702e14d7b50764840bf426f0072852154b3e50e2002baaeeef6afabdd48e5f0ca5b37716658aa4011565d04c4998067e76d8daffd655c3e24ceab3da75447e91645455d225ce160184d666b4dd17c28c5ec3e3bc94f9c79974cbfb7e10730895cb515020d279fc039d0ef19c0f7d87873ffacf3e63b3426b3a2b7086ed960aa6855fcebabcf5af3623231e2c13dfc786ea93d740723a50e7431dcd4aa26ee384db9bde30eef54d5aaf7390f47547c08d9c99fb52b0047f8ddfed004f890931fb5382ec283e7143d9ab4f0be6b654871159cc159865e573679c569e11b3412718cca6d7b73b8b19998a2c37f73bfa4fa5ca8812d73deb5071d89a433010ba88a83cacbb76a139a18c13ba9ab6e01d28659009a2c55e8587649d33b48af0329f9d39856b525f170fbc9927a8cd69e5a9a27167eed44f6842fecba1c1d616ca301bed1b17ae68027028fbab406635a61d9808b4f4b8a31adaca6aca0be2016d7e0b05d17733eee9f55081e8defae653f57f216acd3d2c3fb0eb3c0253800fa8e861140f5a81991cb13545af70bb5818810ec98322853f24a6bbfd2090b9b05145a73de78f9eb338ee146e70ed7e71e48ff1bcdcd24246535d003e823597bfdd299b1566a4576f92256c1d1894cb9d0c414b2aeb6e9ef35205d3aad92584b55a909788495ae77f24faf17d9f8c13756ab08c64f97f0626be315d0ecbfe23c80f28275dfc52473be138da4b82de10e9cb746cc5b44c0778713f77db543e83d25c11e0ef2687f08cf9e5c035df2911766c5dd74994fd550ce23d76dff688b0f911d78ba2ae717a708ceb777809753487eb0c339987cc76eb08b5410e8e7c6b3cc49830d0f9116aff68513f29adeda5cbe5de6b1409db8b7535f4c1d03045517c87c928b21fd44262d4907fea1aae5aae63b9d8973f6c6ab21e99f57f06ea70ed366bf6a54447f650c616d56c564bfafd53862d450a1891fff7dfa780d532069c11f4d61d49cdf5b15f22260375ce0d7f2a633474fa7888937b9b987b9f7cf1fc53900830c0370cce5a5cfca3cccc5b299e7855a45d6f822d9f9f4e05663ccd6fe1a40ccec2c144d06c07a92505a48647f40f2a2493dde2cb982a179a978a99f4e14f88866a5caa3770831a906f7f609f363589b2710a16aa8e587e017412e714d09e56b3ab28c0da24b727f5af7fd02f5d7d6f59a6240c3a3262e12e2601709b0a6f7c58df56cbb0ee45476f01e9e8cbdc4e653cbc432607459fd7252d4c7d6d33a179653383c6fa873c502aa1c1fccbf8c2ec862adf315b08df08c9c936c6576722c6bf47a615bef8c59e17e2cdf16ae6221ae66138e1b3eaeaa841eae15d58da32b76d8893f4901cc7acdc48009eec88374e1ac79511e8e6a1cdc1802f7a8738abc0a53cc128a3b027976fbfc5b15d6cd6af6f2f3eb1bfb143193c1ec95670826a1544329752ce7246da65c6d6f6ecb82918e4ae94d70c2f7f2c09590d24addf8ff9f73ea563c6876ca43bf5432cc0497d40df6826ef6197946f2d23cffd296d2f399615dd2fa200286a0c55bda6aecabf4f7f23ba767c33f80b3efe95b186a2b2e28691c6ac2cad18902081cfce2d4c682c013a86549a418721ce117c790e4a7216158430505d4784af120956b220b0a47c6e1654ca1037d1d4333d4cd8bc819807589182bbc5d0f061e571d2a7a53c72f88aadf7b9d49adf959a28721c4f4bfe12718e100f525860683eecf09c73abef02635b8b52cb2e1d61d9ac8ec3d1574d3ffd72f19b155e5c4a680d31fcec5893d61576b6c6a0f7de0f1d7378fc7b3ccd30d4d857b93ee2f7de00fa9aaedfeb880f00e2e0adc1479ec08cead5f0844f8a3136ffa32e5c2abd87f25de8a87e638a51052cfcbc65f72129c6d77cf9177abcee95a8cdfe87c8149d725c8f6ea842163ab26999644ac23d9b9bed795f12f203c48ce23805a72e406519907fd41ab444cb5fc97ddaba1157833b14f178fb645546de244462aa28bd936d3c98fcdfe5187e1a9fbddce3dd2854421a8a6db1b6d4df942207c9e548a10ecf142663efcb4dd0cffe14494cffadd488951c0f5ae82117f0a1fa02fa902e2f4895e55da1972a5ec97ea0cb79aa1d00ddcf4cb7c9426bbd4536edbc6c182beb8ef68541b4e2488f4951e12cc853ddd6b20a0be5ad6a6a5d53a7fc3cfa17ec6fc24dc3820b5645e686641fc09054d8590df333f5feb2eb2e71db0f436027c4fbc3d9b52e5a77c49e7522b1b76bc36b24339e4fbbb4848e1bd5c2abcd3ba1861d4b97ac1cc53012ca6c36c1f6498eba7f81fc81e4121bbab0ad9444a01093cabdfd4fdf7bf8c2ea7be661c93a2b22b62b0c723dffcb7b18507f2fbae97d68aa297d757cd54024ca95b158f01e0a66a0afa601cf1438f84ed81292e2b9f14ec914814cbe7fa7da6f060cab9479ca0ae76dc7752be33939e221974131e3de5c3d068af9f974ac1c71557648b7874f7ff37e21f467f4641647d6e7f12357e359c5dd5328bb7a5af02dc9a5960708a0328202e3de51aeb693b1dc82bd594c5ecf8ddfa39935a014fd7ccef8b5d1caccf491d5f6386dbbaa6aba5eacd11ddffd302346417e349a808d8acf5984348c7e2c624ca912ec0920b69ccb115b87ecee18e4446dfd9f577ae706cf5c50e91c4655fb3e49157b47d62c977e58ddba5117ed34d6aee6ba7818ec9d63dae86e9b3870f57223628b9d2ed340ba674798530fa486d45715e89e937c248d85cd4c29927a0c29c6ba6b39f2bc5f70e5f3270192903f2e8f68a3875652e92a4bd8eb96f367ae547a47018f9e549f287e8952828fece5b05308eec58d1559ed1e56e0ab392cc28c3fc8e35ba9ab2e5c529e10a188a547b9ffa41524d02e829d7263bbc87427ef7c634736f6495cd65f7e7c0a951dbbbb56d64de7da9d62ca67d3b8e1d315ad5d119b54d528fa8a76d83dc3707fa1c890b13f07a563c09805cb023eea677fff0fc12c3adc565b381f7442a761f5fad597f15e8394cd17e5c5bcb9c30e04ab75a9fcd25101b3d4285680b2a729a40a8dd061ab858b1ae8cf75567c3013e268c0b250f23d8ddd401e56ed22afd5178a4bcc749ac591a02d280ee0c2e3317dc4afd73b8d092f8a8cd93b8cced2cc1ff38f233430664e196b1ddcbbead059361d342d17a5e8265a506c44baa793441917ca3d215a1145f095768a6abe10d82d0e091b079b52941e535d4fbc8da67a3bcd9712b7d9ec3581a733643303534d7e2c7220e9dd7fc44917ea7b682603e4c65dbfda9930b42fdf92e08f1820edd61c405f8b3ef7a7482785643536bb34cf65125a7041415b464cc68f2340939915223874cf5017afe4504c12394514423f5c02de4cf7eb9de8646fcf81d57bdcb567e486f811739b298845efa4fce947288b9e4ea7994327b522d9d7ba3dbeed1cb7cc987b356c6845bb64ac6ad1f9a9ee44cf4745fad1de4259c1864f4f3887564282753aac1619e73fdd056b5c0d8dfc9c57961d3d71f1eb626aa1238a42ecfcaee54f4a5d90ac2da053ba02a737625c05f51dd855c8e5f2cfbf0401bef53850e28809956f88d3651cb1b443cc80ee0fb8930d55fc52722edd59b526a71b5e51d053217cef2e5109d1e97efbbe68cc6dc0503acd191bc1af7e210305876a0f4ef7dcaad3117d35fe35d5716958797d06f2998554ba00b086611682630ee8f4c84174a4dff5dc37c1bd225f4c4bbc3db33ec3f2348b58727eea8a460ee19c7b38ad5dfbf9b2caab5d38f2ac2dcc9c76d18c794926f9e4f33b022bd3f438c7158f9bae3b276d5e2f35da36f9a8215b322e72cfc61c1ad59ba776e0be31e572371b45cb9f7296b9c55894328cff4bcd485092a92d118183f79e0d690242696dad854a1cb93272c42a7c1e2045aaea674921dc0f99d64e3ab8c5be1b4c6c76b26360fd3324fba51c410656ebe1f9ee12ac934e542580ca17de6360cb20ff0fee61247d2f10e6206302588480aae1675d6e98a9f822b0ec245d2c3ec9c4752f87f311f7f035395f8a2d563c3f862668bc6d4d6a0e75a8792463276b5edbf2c8b9fc0f4939c05ec692e554e3a8905b8554ad76ca002ce2a0179bdfd521d802846d2bd46631d4d039757c6cce165822650f64aa16e1995ad029a48e754acf59e4406388b9a71d732a574cbfef8b4b97ea98756a62f1abe59eaefd65aaa73a5d527e976fd1843eeec714b42de7190a2629f83abf35162d3d593487d4d5aec25d86cac0c35ef99b0284e93321da9f89a817178d44f6fa76cfa10704b897c902dab89952925fafb3212ee583ebb0064a2892bd980d20d11cc0544b504132956eab556d8de3fa20322a2cc9f34cea4048ad6c4a3021c8e390ccd212e3d3107f4d0d6550090fd338ee9f141b60645d506e79ad3bdfd646cc4ce0a1f86250e897734dd95ca5b0dca69560cc57d6dc42c76a787eb854ef90f74a1fb1fc94e16b354cf0b54cddc7635438afb28e80d47a642dfcb5cfc2889004f9d654b4de9dace63591de7ff451aebd89b620d86a674fad09f642b561e4bd0694de99c224ed0204947b5fbc1645ef46e909e3acb873c36567661ee300d221b24eaedcd6eb92133a69f78041283a0a8e1e9744127b3cee8e80d6a1291027b7fafbe998e1db23f15852e06a42c42ed5a416bef05174de6b307d2a5a4241005266b643c04b6e48cecb01689d483c4e34b005e67c88442bfc4ec0fbfd935bcea34d4109a891099e034bebe22a7d0b50eda051a8e2309cb22dcba1a5ad5f0433d11afd1a1d0dffea8cc0c8247e3605ceb1d8c683d209e20c404458179945abcc52d07d883ffee8ca96f8fd9d96ff6844304d1f9e79df0926c00dbdd0f2df2558847e75a3015ea5c31d787d24c0200f9ce0fa69d866dfdf4b97d5eb9f4d7f7808d708c00732c0c78bbfbc3c1cb3fcad7c34a2f9cea20fba324809c982e6e6f33733ec73020ea3244a1c0e1e48b22d045b14c58105a6148319ac48f056e1ed7f93b820329130269bb29976c2b6147ba885d3eeaddad53ee2fe5a778f086eff6341db8410bbbb4c0501c3c816710a04becc7982f6be5aea4a9a1ebae3a6598c988d94f8671238c367e2fca80fafa4b751a00729b71900f99dbecc7266f514d99bb57e03d978dcdbf7a85da5a8d59effc91c4d0f5113033acb2da0f16db79014181ffcdddc803d0300ea7a7c646ae89359d5172586956cc7aa91f3f3acce45bfb1b7a71e434c6df803176228e5b16c789b7283f9192f3e5f103e16c1b003d8be40b74ae9c3ec3479af1e801237a632edf1587ccbf260e61bb48e268c05702afe25ac14c738fd5db7daa682ae5e85658dbb60fd7647bcb1607c8c988c4d99523f94a14807f0dd4c6ee53c31ab8de86e4f4e60a0f03dc9d2d9a6380746b0ac14c2e256f25368ceb9eec58571e6b6c133c0a8b33aa449a79179e213e45348932bf3670c496fe65cd80ba45d518402eee347fceddb890adee396b6ad597b2474a6c7222d81dd49c397dcd3680594712e9de63d49037e810f83e6963f958e29441590c0737b0f9808e231f1369af029","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
