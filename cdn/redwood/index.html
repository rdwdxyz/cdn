<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30243f6d06a1b45b66760111fc5d73cd6f651cb262f89540b2ce89af205872312ef22e3bf57ea6c8abef58fe70132a60024c06163f463248c78cd09ab7170571370b794963c6a18090df6968ebc423685547c54639ec7c594bf77ba181f2380d5e278bee24f5b95f09624ca1422214e90d8875fe072156a55aaa7bd6a8ebb791e0ed05dd172e49ef10c28e8ba8a2f67516445716dc50a24837c0640bc1957e8c575b824e7afc98985a89cb80cb507ef2e689d485b9906cf108820be6e644075bddd55c90960e183b1a3542b7976333cef1a2f380be8c847b1af117c5f5bbc62eb3973d8232639d6a686c3da5d52caf823c18e87717e8506bc3de69c3a76ba185f6613e5bd6399c39362119af6740c483f1f47e09b899495663647bf918be78c9785960713a1c1426022008afe8aa96023826617d75bf488f64bf3947772f48e9552d913e9b27bb99200af55048596171937523988468608b5208a687a74a21642f62625dfdbb0aa180eff58e69fdce921343eae8c11956b6a8393645dc9cd7478a663bc7f0e8fbd52af3b2cf1fe3dfed1815e66cf377735a210e1e9761653f1de62f7b83aaeea1452b6035f83e9770f1274718d10ca81db3bfc25c3d67034fe2215185bc94ae4404716f2a821f88864b395feb12349a957f6a89eef22b3347cb0a59cca92bb4b3d49067691e61a927525b2d7088c50cbc5a91c3696ba11b45b6b0d214d6820cf5cfdb6b8adbb48af334bcd084da55a9ae9d7bb07b54dd339b6cab0780edc7bc058971b9c000a0d57a8d4e2ba0db65ae525197145ce2220a0e07d5ee16de8ee6139695c77c94d29b31df4b052697c8a367ccb8b26e42f298351aa262e11a7f6d23ebb4a86d0841e9164367772c65c0c0af6dcc0f597208aa73eac1cc0ae57b495bc45486ce00a84f0c31fb1633030dc079b3f5453701f34caa749cdfc162b3b59edd83276fb97ecdb95a3aee974070d9cf7a7119e9d108aa9d0adf940180a7d7eb5ad5109eba34c5ee2db54c290969f3b36a27e32c7edf6a339bfd1bff1565d739cc913866dc1289be2e21d00ecb024b8fec2e09e1ca500bf11b18980da5f07b86721f4702cfced8b1c835d97129df34ddab2eb0a01759fe2645e0225bdd9475635fdda16000affbfc0040e9926eaf9e3d11ec1c98f3c73c66142a8612dfa155494b236719659ee0f29020f8fb96e6234d65429ed823a549a2bc73b2b7b5185c917e57e15af4ff77497f54dbb879a5344523773422ec17f7a1d2e457b3c55cf8601d8491895d81070ae9d112d327cdc534205734828f4694d4e5d538a475b876f4f5aeeaff5010b191f886ad6945f2c6d1888303a65311005d34cce33779644b31618b6088b516eb4fa1f3c04c9152316237a82b264d390aac5bc840f6ca38610a2637f833d1f81c4b43f9050d36eaf83b98bad7823e10a25cc58aad2e5130066ff370646562a70be5723868d36d2a442e6ab9b835d7e258004b4f6bd6a37cacb453dbc618594ce0b9ee8e14bb518bf1223b097a9a482abe9282fd02821e88151ec8310f3c7feacd3ca74fc58cab9bfe84c9e9256969f87481d2109de58cf442f46537dc57aa97672758778a7e156654dbc88a6951be2d2a491950a01efb0eab175f093fa5d64953975cb03c6ded1d4281c7b52cc4be1a20efbf4c3e23107751b61db80293fd093353183c80e0e5d185b67cf7c09b15ae9c2804ab16e7e8871614377d958a9e3acfc79965aeb41606a4167b761c5755f3767a472a18fca6b4fb8dfbcf10f1d256497d4f8089070a2edfa530e8785b3d251519d5103ab001c0f56d726ff04faa41b6764005721b5e8df3c4eb7ddf2ab13fefa565f4e2186a6e9ed82c7ea3b774d173ba4da0f4b628729435655bf05bd156c5d966d6d038717e7bc139457050190771f56fb9e123ef40040f1642762496181622f9bbaec4d9f461935bd07adcc28f0a0f34f6f6a77b96aeb4507a3cce28076515ccfad6d7e92710e37b4e5f7af2160e1947a7ef8a439caf7f1d3f22eeb249263dd77ed760d3a8797621b346821902736513a8c8a89f1c8018a5268d2137f4a97a4cac9476736f4612c507ff7b87f9ad06fa5a09da0e9cba474dc778be6c959448cd19a6412847be40dfe790016b98b7f09d3672480787e796ba53dec417df8a62a08059bc9b9e0f4643cb9d27e9b95e2c894ea0d958369a8915eb5228446f5e0c56d8a5ce554391a1e883a5d9c73368801c0d32e9e695f1da7186499e490f4c4b7ac8ebf9ba5f6e86c5de15dc6dd6ba0c561812f2f05295a47bb2c6efeb255df210e26ec38dfbc79488cf96213216e5d042c6c6f659854fca220d8a9afcf1d9a7120ee12ef2b980128c25bcdaa34d1993dfd3c7095f342290258a7f7a08bdb4999206624aa7ecbe3d91739541519829b4118d9d7373dce51bf0d81c0b791590131eca874a1f36b53b138cdbedbd2e24d291311f50d5b461cb73259359e2d8c29a74720c8345ae8bcf00c5d714f790a4bca940d02c1fb65db917180481fc0b5cd989b1c79e11e629a5a2e23216dccb4da0dd6f78d1ef5eb00e8d288bd283bbbf10a063e937972d9517b944f38803e2116d306df529e4ca8813adec3b23266cd015db23fa41caff1cc5f31692e7471825bda96b467881cfe58e18ce647aecff4021844c874eaa02629ca840a1aeb3a6ecf54420ec8e3776c1c4d279a33a700a8793a6ad13a0015edee88e071753e7c9a1f7a825f4d2a500564d9b6cfc233c5613125b64b66fb66a7c5cd4d1b7ca783bdeb168c5d81de7275ee5b46ac144cdc1d1d5fd1a63f9f839baaa75a43cebaeaa7cc6eb99d9cf850fcbced77b299a0194ac4b2630bd04d3d218d469beb9a572bb83297999b174ea3a182bd5020c8fc97e7f62541f9e9c0d95717a29e0e7d75ec99b34bfd9be3ea52a5868f18c49060a438749657e7e9c43a8239de72ab7faaa215bcf3d66ba705d70aea30f001669e68c1d9d82708dec1343c25bc3ac3b43d27e834780eb94c6f24dccdef36291e503a19b09fc042d956a19e682bff057b11b510aa3167f16755574d7df612e7f2c37d57b3cbce44646806329e73fdcffd67cd14510b8c09b94e0912e3a3fd6a99bbb01ae2e926b71cb650b7cf12a494ffc67dea1eb3aa0fe3fb804346d73e9735172c70a2157347cafd44340dcc66dba78afd7fb3980107133976aeb5bffcee2286e4483235c300316b3c6c5c53b1899af02e41c99407954e0fb5dc87c8be229a7da3510784499bab90991925fabf6a95515483f6146db699a8a738e7560d396da6871bc3eb8cc814b621fdba781896a77d3f55e34677ef1fa3e9d74f018c7bbbc49aa9c2f743105830f1aea6ad740fa7b2f15bce10d9c7ec7113a3610683ee3198017755ef96d1e8ee15bd0d1a170a931d1988bf09df4f53a26bd26752dbcb689558a224bbba325e9cb2f4523f1007c9a5a9ffb6a5415fbac82ccfdfcb4d74215ded17feb7ab1e2da48021b8a4db23fab8c7dd02f5a6bb5714ba874fd901591cff7508107d6ed363ce3ec861adbf764e4067215332d82db1d2586a789832dd33a77047a21d7fb864192b8eacd2530d43fe91bd82f1994f9580bea88b325935710edd707947654955b67304cc3c4da86f747163a662285230bf5991ca65091c8e3da890fd9b3941db1b505a79ccb43d55e41a0c68c552fa74be5a322d3e8d1935c4f846d04c8d2ae01a1ad66acbc8ff30ba6d595bc7cfd1a2efd7ea6fb0ac52d99d4b52edbc90ba11bce4195e66962e765a19d7b883f3442897d904f343dd497d7df9cacfae37e53bc5c6b4799d63f64b6ac1f9ba2ba13b2c34735da816514c0d7e1707671f12f53e3203f59294d4ec78004dca85613fa2ca35fd4ceb9e077dede665226d7addaa667cc240c52595813631217bf825b409833c1dfcc110f5dd8a4def5ca06588293849fb358c26d92f2ded52137a20025ead5aea78d7c114e53bd4278b0a687910051f6353e0a09e3f839c04225b32778ebf0404d01017b130099cb425e6df2879b8276ed8d9a882dd0be8f37f47414047becc52c8c319114daae0939fb2a2e205719bc504b70c177c0ff8656f184e2088402ca6f34c860ae593334383d57921a0d1eb957fcf3f4450a816fc66ef4744c31e1e3ee175a58ef8ffa24fb159b747b826b378d056c1ce39f345480ee4a4020f6a97c7edd247981f6834cf233a2836d0071111e60d47662a2ae9c691814c5476ae19f262c75061f3832662af12ce608c83221e78db95246000c67ab1faebd442499ab6c19693e81dd8d244565cb71bd4739dfcbd618baea83662b81361beff8f0442282912e6b1d0ef66b498aee9903ca37019c232ba6a44b4f17ec77ca699dfaca426c8b0020572906f37fad70602c9d31e70e145456e11f7c218a776c4dc8889ef39f453109c5c0f64a11995f96afa6859cd3b00364ae68210e6c70f8a97a395bdfe70856474ed5af2b312ae8f68873aaa3740150f48fe923578be0f57deb1cbd40d71dfe67f631341f1a50072b8f23936c61d14514c12eb3893cc93bc5cf50cba683b79f34dd25fe8edb730404e1f78f815a1cba9842ea8bccbd9f3354cdc36111262812b81c0c5ba90545735302c522e6438ab4a0ace93f7ee57ac42ca130bcf30593e2db01c1e3ad410eb778af21998e105525ef15edbc5531d7617d7f085ad5b82c2c02b25eed540cdd6e680781d3093a8ccda2b620564163cffe4b8f464bf083e6fb9a1b9ded07f1ce9f7116ffd1114ff7d5b8e333973ec990347a776534de490f353d963d9b05540e70eaad0d93ea9fadc49a8667d7d2d4ab70585342d04f5ea05ece9b3639ea2927751150c0e0000e9ea47c2c705cc9801f2623d0eb829295e8d5da49a6f475949b7d50ae344b9986d4bdffa76060251801c85fae68e5552c077ac5016acd3e85757e96fe071cc1134507eaf13eb83958b7417fa67665a3d207294fce2f92a806ef82ce74a05d0ef63ccfaf450bafc083512097b6c298060989c4504933451ce3eb31c5ee5970c0716ffecfd8b706e34a940db9e09cf236f0594d66d94f4cb48643ce02962dc531900313135293ffd57f4fa8a225eb358f194e4d0203f0fba3685b7fe7998bd87f3f7811b706b6cb52da77f43424611da7489e68aae16a923bcce7bbad72fd91dad5a0597e5f006e518b3f84c738379dc982fdd171528aeaa59160723864dfec440d8f7771f51f26a46c16cc9412c58bfc8cf4017e255bd7a41f2244a6d12fd22f5ff168a0467b72ba071385f3b0d537dcc430c3f4a21eeb8dd93c1bad3d2787e7ace4d921cd972b5564bafd7a97dc2decf7c9e1683903627d3e76c2e67c16798c0e12a1a1266206868b3f47283e3b141b5e97379e1cb5b1f40ad373673db17801841c4209532f8704039fe7468ba960faeb4f6d5ea7daf7485fd81cf3ea7a5dcb7d299869f9676484dc05091e6c786e6501782201864a266e1b9d932073a3b05ee7da9522064275407a7872710ceca1d00485e40e098be8dbccc55987db4cbccf0a2a8a6a1b9559e20b8c16c83d28f5ed32dc3e5fa89073c05d1f66b6ab6dc89e76fc5e4e375a9544d99f2e176be2be9b22fdf90deec0de70bca8cd992e1de776e3c4a7c184f544c4b7fcf814310070a5198a15d21a9ffefd025ead32ae44e634675a7843d7acb4b0e6a9b02e0145dcc06f4ef76959a5d55300671050bd66ab7ab3ca835b0ed952c5575c2c0370cd37c234289d5666c1e92125cfa9c1b3474895e165aba7ae299ef8f875382aca165a0dea32deba7e7cd5835cb3dd664103902899b04a89ee5f7d7b1367a014dcc349befd2c5d96afa0ab870467ced8997ccd1ae3c2ba54f6d6a05dfe6cfcbfa42a712173b2838d085b4c7fc0936b47c691f1d12c8b1c223309bf50c5d61dab3c572c3e931fb041c05c020b1d2fe3e73b782facd3e05361975311ff390acbec59ca19c790a422105e203dcbc116bf81c37a6f4258bd4d8177b502dc722d09a5815ca94aadefb125333427803f9745139bb5b23f9bd06e6f48d87f128c16aedf665fa410c00689c766c18edbf0d1213cdbccabc2f7b6a060f1907863f92ca264067834f59ab309f5bc7a645cfb59e0578a804587d62d032e335040e10e34c0c2d4dae499ba5f80d47694752f159c279680ceb3289f22f11e2b31da783777ddcc923a3c13f94795d1910d2ed2093be4dede429ae9a407de6018be27dc2903048398bc5e1415f2a770bae0cdbb34f180a1750f5c864c128069340cdfed012dbc69ec09776a3e1d2b7e80d79099e79153d64ae3c80914ee041c0a3a01ca12949c318cd52164182077ccacfd1dc7aaa47f92e0f820726b38a9de46ad0cbfbd0dc8fd4f30a112c6277a713191831b78823e725092eedd82a3f0154457dc182a12851da63a277bfd19e563aa002bb88bcfd723ee10814e88c5da52f4407b294b2dd84fe5be3520a6a6c32ee1e8a879a31fdfe05bc0da3ea2176f9b8158f8a0aa8b6f8729dac48958e82f930268705107737db5ea05e9f8399e686ab3e6b0fe1403a582e7e1ab1f072f2d239dc6a78cd5169f8ca03a6236583a315d5aea5c2651bcb33daabef9e6ad1edf877d876a3d16a397bec1c26bbf505aa96207bef2bbdbf5f4d129b1a5fdb7ea68831e5eccada91ba84fa4cc9a0663ecffd65bcf52cdf1b2b1ac6d9786bae83c8ca59f153377a5e6a524e84fbd5094cc324753e36eeeb6c5612689b1ab2e9868a34395b43518f4349a2e49985030405b3079e40563b3ea584f5ec1f14079d06d861c79d2d66d45c67876bc01cd4c1742b95ce13cd24f36e1e7b2721ebc24d1639f18f66e04644c5cac85adac6564b919713d209f5623f25ff4db2ecdba15688d2485fd513638f21b2c8534369937ce1ae8e42bd84a70c7cb0b262f863b72f89ff7817eda9f7887bb91ef3cfaa2d45ead0721547544e656dab5492ab64192c6949f036d33bd97ea778d005dd87897c412a64646a501dcee17e1ba6093403aa03012e31fe71101d4d5ae6aff2ab812f2eff4acf3e2acc4e36e8400f7f07d6eceb64d773cb31e87b4d3b587ff52be8a07b6386ac6772fa554638b28f09cdb25ff3f51b66de3d4ed9d9436bd528435299a63840ed88ec61d3719e15ad1d010d0a2a9ecd1e2edc734d1e86b2f80a444e834629a14c8da9da5c017b634691ef16336115649017daa3afe80c9127b75162400de37cf34710a5ba0d9859aaf3e357551199889eca59260eb81a20e5ce488379e4458a71a1e82036c248ac12fd936b26cec81edc2fbab804db9bbee9205591c26eaa0e752d6d350572191aaaca584d6755a774502a8fbc9dd31ef807d1b3c60ae6c4cde9e3903eb6184fed61952b4f4652023afec8a973756d9dbdb8998ac9f00fd8a14f8d2c2db64494dd4c7b00c46b51a960d12693f1266d0ac2cee6ad917e56d253699b35d8880c2c7e821b7bf998011be7a8c6fdd8df024747f10cd78953aa2abbc60ce78b1972725b3948f3424adc8457f7503698d5f8278383105c06e477cdde7bd47f73e49f97dd0b07dfb308044389e7e5efa23284c1c6ce8561f52b532799fb7f4533d6d59bc6cb70782b0ac7afc6251a6d4c525711d9ef7dc4ddb8b260e89233d917e6d46e0043104776ac3275d2272d373c0b2b58f7f199710a918fe4ea8f400286537f23171a2a7847300935cf383efaf6b77b69b6b1547a41d21737ae2d4c9f279a10a61ddaa4218b35be7d1b427adf9870c4278b4dfa6f848b87efbaf5996448c81d467b3bd3814258dd864d3585c559134dbbe5de591db352a371af57390aa062fdd287aaded67805dd697f769fe33cfae462ee4020f04693745ea1f550f2c0b084897b2fc2b57b7101fba1dd5e669a3375e0f69ca6572293383555b17d6cac8c0f7c6e3408afc6b3f837919dd6f813dd68811b1e6551818be27dea2ef79a381086be83bb1e56468f7a384332a7e3ed2c78c899a6f26eeab15fd6ae116abe19b0e2466bb073d145920a9017492c39c875d07f1607093bd4bb956a7ec2395c58a97b5a66cc35e95c0c504786219cb166217822aae216794a57c93ef739d33000b3440c27e0d416fc080a39ba44ba7a5223bbcf711458f6bb265d3936c2206f2c5bfde3329cddd34d1bd182d314c28a29caacfbf51f8dfcaf0af4ba43047126fdebc011ed7ebcee9fdaed4028c32662c5771313f6533c9a86ac26761c81e6948a5778a4a90d9b3d626c95ff663dc9e9e6784121d13a7593d77fd151db988b9cd9dc28c4ba35bc9f315c516182746dfcfe8ab20938898d44779973836446e9aa9e5f12e870f09f237606a6f5f9429bacfca7f09015f00593a274527e13e254fe6ac855b9faae074ec0beb8ce87086dc7074c012ccdee0139f2a028d1e11958afc8f44db8bbc2284ffed66447a7da36bf2c632110fbd94933178378805315974ad315da94eedec79c765f53cc7fa2fe27df1ff235e77487cb25101e48577dc34dce60415907efde42667459524744fbd8441568c6ff7b76074baf6ce68c7c14fea4e7712922449b0bb66f62b734bed12d899c61590695ba6cfc4435c0aeff60b64f71eb8fb30b08bb958179b8b1b27a18620a4877fcdf322d750d293d0842d7e2a497d85f45c165d38ebcde7839e2d9f8c0f139355794d034ea14bc276ff9164afea0c3a3c86d1b9e76aec2b409e15ed19d97558870176b2700d426c1a41e54facf703ed6376da91e06a78b509aecaa63a4878933c7e4b3eb2480154bc716ab60b2aacc7395edca25433f0fc9522b8f9a87014040dd130464fee555312cd6dccb9a0b8ddea5e98fa5323ac6af8a1e7c252acf2b5b1e43888f58afb8593ec4a5b8f290bcee2d902463f6de6694e5de724fa57e02b6fa276f3e4e9cbbc8ab1f064beff376c4b7b892b4910b247df417644f03a66217d10f5e837717bec37ea3a14e7ea50e735a045e644caadb40e429c74a2c25d514c6f411618cb4c5ac7fe8a2fe1a944a2a6d2a55f0e9bda1ee67e07c7d71b5a6b4576ef786bf84a08380997a47918d1d5e60d69f6a6cb983188f45cad2f6bfef52839eea9e84d5289f74418550e256b38d9f24b11b4a31999d594297bcf19cd1e09f21da5512b813e3eb4b61d641924ded1b6e24c4d873a492db752e6625d975ea1caeb15e13b2cf3eaf7f348cecfb6829cc32061f0ef746dbb975248081343b5f024d008636353f8367e80961243de66e5e19e796371ed01fa921d9a0cc3b843f6cf314c97d0701b563cfa0dee17dc2a0d0a81917c89759d739e8f59f6093540638be36cfdafed19684b134e80def7c1b84a4046cfac0a591b05549fb85c8ac212b257d4d505b5bafdc7a3b8c554e3e5b9fad4037024132b42208b6895c8d778c8f5eea7a7e1abaaadd7101cb9611598ffac0baf6aaf4cb251067dc5ae53481dfeb254eeb605b029392a5e78248b728d513a6be463561172f2fbcecd5cc50478bb6fdbdffaa04f5b06b73b0dc2c5c57bc72ee61b0734bc810da7a653d92160225acb92b755703613be4621cde5945c9363b9f37d365bffa2a64e43bb7538b688a0b70c5a6ce1e04238eba88e30e1d553582ff0cf8e2e1321c9ebf4c090c9a4c51d4d1023b21fced0255143f4d757db10b353502e49a7cf807e3eaa7e7bacb2763f7744739c9e1c30b853c65068e78a2aa903ad004cb11d085c201e4759be54eea975a762ea9faed3b99e159b76e72641d3177b005c95639d0ecb618102a73d05b8eb948e178b776f376013dc15e800355f89180e43c0d5829bc50af133bda121ee30b52cf39c28b36cce5b709dde7cf77d1421df193876674fab9cd778b0ad0a0d50a8972a6aef69e6d4afd7bdf9bd5bd6b0f836576b70c44235e9d60ddb854b6ef58129659f4df382094f4679aec09b761055bcdb68846dfcb32cab282f9c59a61d114cc0d0e649c39b42ef78a0d126836449a57d17a329687298e022a6c694aaf949a257d5b313d00396d78cbedf0d4218a15cfaccfd46b8ab12dd415fb00db0ff6be3618e4e5f777d0d3892bcaba38708203e4347de0c2b3e9c69d0fa218f54990dad0ccc6a1928d0f9199fc32bf96aec9a59a60807d147d66ec7ab54cb71ec6686ccb55c98b96148f41cb5253a87b6bfd219cccc4e58e4a764973b0ed7305fe9287afc63e4f9ca46e711e2a79d5cdb97408a08f9e6f5317803d55dea0a87fc706b099f01db2ab53da103716277e70629cb8f05175c18050d2f73169b5718084707e5f1818a40cea938df055ef8b476af4810ace276204bd2f07fe1c193432c4ccdebc3cb0be58cbe1d40c54963363111d5d2ae18de634f5fc2b5bad49ee2a7104c90013ff5b6c368d944e3c6417f7818eda06ebe33838f43394de9344658a3ad416405db191de52a68c170261ca6f416eb477a51b995d4ec95656b7869841bdfbb5feaa4c297d8a899b13c3ab382146c64815109a0e5212ef2dca345f4c54bf5a232d9882bf436017498355920b1bb3a517ba9c398c7d1d057485b1318b89d2f82c62423a9e4c2115882745c64f93209374b2be29b5437fc725039413e6fc791a4059129bb1476d9af856a9681c4b25c836bbd08f81acd7abec62ee937567cef6540e3278989222db91e1eb892e7685b1dfb0ed91e98bb0abfbd7c5c1054d414536f0d70d44f1df73e810ec8b2e6e4fd3cd88cf4bb9e138830c9df78f581bfcb80a8b81970bf86fb65265c96668eabf57ed4f0decb4c8356b754ffe611be7a4c5ef6d9918d97433c490a3b98a89aae24abff0deafd4f468aa10ecb1173e2c44ff071c95e86a6e05c0740516457a4ea37dd5c7a2fcd029173e8f24e89a91a99e91e43ad066499cdd15fc08aca2658930fbd16ff0a341cdd8cdaad6ee70a562cbc2e19c7c384c372ea07aa3b07101129cf4a190b0f1ca082e3b509a9e3a9402816aa7889ac6c4d849a4f16ebc790c20c877b4abb3a7ffcc5e24df03819ca1c1324be81122864afd956a2392a1e06a366c93278021568fa5bcb0bfddcf94d666d24a35151df465e8d44fda083b4f49d3f08bb1a7a82557a87cb1efcd11b8fdaf2fab190beda902deb4f493f49351f11c40a14c90e4566fc21046f40a83f2a06453a052cc3a21865778263e616c61f906d2ee8589d9b3a745f8c4f8ad12aff757b27794fc22f2b919630ad9652971fa959b213a995e2c6fae522fa5273ac102b654d18dac222626ca8aa2c1b05bb3bf41c844f202dabd0a4efd42332aa578005d0610b5518c92d6c99588ba0cd3b550f86cf7f7045741bf9f06a01fa6c9bd63e2550be309f9a68dd56ed524ef1f04df81d6ae615ac8fbbf8aa0bf87ca775194b93611abbb7c7698aca8507d1a383d813cee4be8791927a909135221336c7951f032dd24e626ce2dee39bee3fb97e48b9bca9838b1235f542518a0887d2ab046e483e458cea277a15374cc16d85e86363152ee2bc99def11c42b83b94bb0baf3938cb08f4d22e63049e9c9cbaca0502a7defe0cfa11bf79cd599e111f698f42a68dd445000f1472b2418b548189cf3f18e679ab4c93fe74c020d410c6599dfe945ecf93615d961ef89c180f3ee7b4bee44364079fb1ea0733fbebbd5c735d4966b8de47e77098e83e81cfcd90fc429a29913e659ff87a4c64fae7da8a9750f845b7baebc2aaa4e248512f60e5784449e80a4048e3582adda17cb0c1eeebab28c86837d8c8935d76942c043ac49dd775df97caeedb233ed19bf001dcfe262b172525268d69a50602d3278922cf659f49ab58cf65ad60805469d5a265cb9f2cf445272de4464875e33cd39fd719d89f4df5f749864c413e6e3b335ab8a3a33d6cf6debd15701bdd81dd8579c2fca47f3668f76fa97fd7e779ed3139560d40863c95dc9089f2cacba335d37b221d44ccf3b7a53ae1713193159c43f337ba856b7e7e70435931f02745c550f2219162e5ab08df7246a2167b2a75972b2d9a67803e2f3b5c429b4f307f288981284f0b6af2034f7e92f563871fb63b411aa32469c73551e04f6361567214c124ddc772217738df016f4669486337dfe71e758b73585ef02216c808da804ee45113fe7a83df76528dc39c28d480a90af88d96b651b13bdc820152b4f23dbcaa38d31bdec317dffd3d62f6dae7b9d2bf107d8c1d40283823cf35dcc6da8c884a67f684511f3e20ce5ced2113ea1f564ede1024577af49fa67be761a22d2fa332685b632581fbfc2da83897f07a1544e9f8cf9b35c7b66fa9f57f90aaf10e95f7e9ff18a28b9f04bce5305111d1c00ccda075d7e263a6b974b4f4db77c8dfcafc224b5e8d590170cfb4be93725686249ee9e834bee6d2158013b0d00deac417723ecb571142526fc38abe1a6ec7293fdcbb9d1c7e3d711ce372cf1409fd0975a7192f92edea6a1c4d19ce3b18e16315bf9f0e1c6ff9b4c7689390922423bc764ad2663b4860a8bef9ee7901f6b3b94dae328e31b2657dc304926316861799293ccda11b6cfb518e4014dd817358b4a76eed7070b59efb24291d6e7bca655da71d7a739b87d9367232fa6e1f094608f1f4de5d5e7c21c8eb0cdda6c9ffc199183e372d01a5c140f9f97e1aeadbd2cfbfd48d2fbe1001c6266a8b2ece7c6a0eebafd5375c0c243eb8a75bff0d18f17e68cfd79be7189392c5dfdef421b70b2273ad94fc458d0c2fd498aaeff8e75b60f386c56172bcb914a3dcd3c518a6c271158c0b7c9094d2ab1caf3f9165afe3da691afb0aa32c41329731019d62cea190323560faadeb567555fe2a2d04154cb689cfd079108664be68994346ea496fd6771a7bf04636df1915b8ab9d568c174ac1c18eded4739d3fc4f6c1e40e8aab42640aa5ce1e23cdf8ba1d4717d2b47a5419ba1a42d0ac00db03e530d4bd360278e709c2aecae947ab4fedfc7effc82234b65c781f2eaf10bf0aefe88f8b1e8f66ceea00d5264cf17be2e52f116a8c49ee8d86cc2731a58688cab19605bd290e8fdc2820d190feb6dbfd18df8ec95a8c1f36d6d5ec5707269fb9a04d894f9eae105ec6d38d69ff3ba56a55fa52d589bfc8dab077707e008aa9009277b1bbb6b54cfb465bab1e98706deeb636fcc58edc38a6cafa291e6f7502ffc40b85f6156a57ba6ababf3faf6fc6eae330ce3c8cfaca15fda56db492d589e6d53c58d6427cb192f3aa8e9bcdd7341dba8c2e99e56d988961d55702c9c60734146d4d6a60af3d4be99bfd5457a0bdee7ca04b5063b92e68d58e4de56336a8f62e9f372df16c18405018ac08e9ae5afdd3021d31b77ef6e7a502842b06553dccdb7012fce3c926a2a8e8d4a4749e9f4da9bddfbf0d24a1a93684eb07dcec682159db9542ad588a05b62895b4af08478cc6e53f7c19bbec5c82c5277fe07aa5366b694ac69b03ddca52d347a49e834d3584e51172765842a96de70bb05efa4f8f21770f19d61fb02557ad812b241536728cb254f9183c545f99f7299f26e98c4da7043d9065a3fc9ac0a6d67664d61f940fc98d1443cafc4d39065e2c2733d0514c2ae74e1eaa5121cc9d60a6071e4952e64d49c278dd140ffaba0374add62d29afa4de2613cfeadece315d78350f4bbd4a4a9d4dde7d74d2ea84ad044a034a54b56def32e8ad894d1f2ffa8edb20d4732e8cea8170310a1f655162f31b8bcb8cdd9edf91bbf29b07e894bf7d43d5a593a4a2b861ed93c89ed1001801476c44d54e9e6a5b007070549bc4c67a27e942ec006b10bc08d2e10e408ed4132c9c12ce3c8461c8fa17bc1e5820aa308e1b63cab5ca17ee35f13528cdcbba8dddd07604f1a655f9a1e4b970b17d2f81c7dde035c79fa0557e1fe7b09527416c02f636286789609cf8c8bf1d998d562b6d330bb8245cc1e9f81bec4164d29628a8b6b266eafe201196a1f761eab5a821528a129802ab6b1dbc36dd2ed4a01837f1c0648dc81cf12b6dee4b3bacbf6c13875c6bfe905927ceb974e960ddcf2efb1aac58cac1bb0fab0183007b328b0f04b132316fe60cb9b8a7cda2caacff40271c82ded0267edda11e7fe861fd6c81fb5ca2a78aafe7de35e26c8dc6f82478ae0810e107d2776d473d233f2646b5ef8b99d82afc39c7029a437a2757e7d8e6898ea30dafa5ea6ca6d4c78d62501cc3322a5e2c2f341251eb3aabab2623c1c7bc0e1ab67b9b19265e1d0fc93edeed1c8115be89953b083a393690306a1657815afdbea305a8234632a7513cac3989a4e89ed8007e956d7c6da8009a6f28ff2d215bac8a5415ad48d482475b2d10b1ec9d6ce1bb7e76394ade00a1bc0ef018ef0785b568e5bf101fd4e4aa9fc95c3ef5609344aa87f7f0b3eaa3e08ddff387e0e855a644324f8ff85d3a76205682a05f1b2f8f0e432747da7de71fc1327b5110f74f93f6506e0ffc7686ec88b8ec31bec533360da83529ab31dce9a5ab7e3d3715cab8eabd50b6151b98a7a88e7fb83e41fdc49987a4ac044f3d38154f14fa8b19dbf7ab460f8c5dedf1c834d2ae2bfd1be0cfc433169078f936ef1368515a44215eb32cbb8df86fd4aac67587450463e07462ba5cd58dc1c4394754161ac04d6f8f3c6209c05d253174b390cb853fa86b393e465d1917d3c2b74a50f17cffb116cc3fc351eb4539abc552c5a6168bb105d8a5c49730ab09d87dbb3728d986a83199baf69b32b32ec60904b1bc39239919d55632c76f204aeb7f6310eddc5d11f4d9057379068da8ac9abeabf4a853ad1d4991b2342cc1608225fbf0e3738aa3407a305a40e74cb4a60a1fd3c945458381335e790760f522cc9a58202226df8b4adf492ab10d464b15f45049ec6a1ec8d53004542374168a4da4eedcd93ac10b87d144f0baaa5b343cc6a4a50d631f05556f29b38d5b3a2012bea141877b431f6dc8dcce8d738a8386ca77e87a0ab81735cae4c514a7e0c0a51cab16f134be44442364586754ed7e3394f39d6ae6d2105e2ede3e380c84b6db2c98849945d025da6a878a94cf5a30a2a8cb0a65a5640c6d199595dd659d7a78eafbfb65202fc3a9f8e5f57ab0ee791e6b4dc90996ed9d9826e2b2c9a78151597e33434b690c9da35abe1b538e7f5e4488eb87b56346f2bd00a526903b54bde92a0086b73882d338a41216c2ada9d17670ded182169692bcd4b03520e3a6dbfbba180954f25735b130ba81c08f6d53e333cb67e2bfa793a529db43444658f60c4274224bbc3c73cbbc796dc21e880a7d99208a35782af9d062c01e80c53bd6d93cd3543c2052d04a0e84e3060cb7ea69e9e562abb24743d79a11ec31e0268f18b8531b7c7f3cb156f2952090582a915d3c75d2ef4fc7d580287bef350fc17e41f8e04f3c3a5a43918587782461ca86f34f1e10e3d5b639b2609d22e8cb3b003931a294a7371d201b1b503c423c146f3610626d4da1bf6c30a0f008c8c438d454bb91dee1367fe615a28bebc80145aa264c46ada802a3e6fd1cb1f18849f74901e77c70ef4dca10256686fb3b4c1139a8fa6b22cc1fdfbce67b3ff30caf016ba7bed734e70c7d2ee71a65d397586cebe67a3fb286884a38059b914b58a35242882335028afa6e1f9cfdb73ca2992545986c3e1e760278415767591b353261096bf9a024e124614281ccb767d58c837458eb84a7f7f60815ef702d8dfd7d321db0538348f7a007cc6a1b5f1a1a2fbaaa2499f5d8bd7fff92228bce9198be87646d4dee7f4bf76cc18b58d8fff19cd0c22aed4d460de969dfb09907b4ae90f6ac7918726a27eff6000d379e3d40271e56f9ed6021865c52bdd9ffcb6f2e3b48af9093e1d31ae8fb9677eeeb88246fb67bec724b3a6cf07e3067575787c3acf514113916e25d782de6af827904a43a704e03c9fd778365bb4ee5e6614b65da7c623725fb3239822512aabb8d47eb4efd3fdd90e8a342e9af8eb23a0a68806586e63823b1d3d9444811f805fff553b7282c1f9da70cf212fefa053338afdd4a6c86dee09b6dddb7696ea395b0adfe21cfcf2ebe07c914585f64c550bd215a418cdf0127b8f71ea877a55f3f7f47c68c81bc9dff3fbc5a9b5aefa4d52c323488094e2c32e6eecbabc722e677b2f28178d44655c3d47da60e9c4d0d95a6a030bba0e2410b4b0f265f67a029398c7c3357045317a62f879a5a6ee777eaa498ea586bf5d4f1b64ff0ea05116b07e3fa481eac2ac0688a0685014c28ae215aa794834ca951f29b69521dfb4353f07b2e76071ae60e6826c4e12b5e90f5a4460608ebec83a41f1cdac6dacbc69388a314611d8d577bc4166a0f3ac90a964881b07d17d79dbb9d76b2185198916b8310d1ce34171b1cb806861f09610f16a90a7fd42c96ce6ca7f5749a5887cde842d8f3be23f629850245c3806715031f1c0c50f0efa27db17d0700647c0a0b307bf41d55ad8dc9334651e56fcd712289a5e63963a0daa6adfa759d920c229b1860f972ceb44ea4a39a700ba30f7556e62414817961e2e19a77584c93ffe97c3dca16c4fbab6eba2a06a0d4647d3b7aaf9e327d5a4cc04027547def7f12019bcc4b860cdc4fc2053b2c90e96ccbefd1eaad5f2980fae26afac531322ea29acec2b4f8a0e709db34907c7549de686f3b86fb4f97e0f0b30a10595af11e3078f6ce1ccd4b51b1ff29195621c442aaddded8b8215167efa155ad39a6d6255a3a2bbcde06c8768f7b01361d86d6ba2cda12e320560ad8de30e6f634759a596853e263f5396f61253a67503d562441e821408a2e5d12c3682ecea0d05605b45f3442db47095ba26120e7ef848a1d953160bdff1c48c5f5b8265f0316a657db95e0e35d48432ca421de1a8b26e96366dc678cbc1a0256f897609ca1e2d830738baea3e4a1f2261fa4a25b8fef234be7217bd335a31dd4fa201338d72bc423fa88ca9dbac5e3cddb8171526f9522e0a2e2efdd789a776867cf5bb0709cb3db2d774e2665e87ea8b889c61a72fcab9291ce19ec3e73081ad8e0af37871cc2a009d9b5b61eaece7096144be0fd4a48e6d6025d25b48d40d33ad1a2f2a59c6779124b309a6deb98b1bead444e58d4758ae74df5c6601312ea34b3d867970ce16dd94a4584e0bc35e9b933a8f86665b709f91a269f1abbade72bdb9611a0dfb4db38b93b60e34703c98f44d2fb3fb5c85b2749eae939538f272b395e43f362dc2c05f2353c1da0d93deccbaabf2a4dc35b70f7f7265bda8af73a8f73b7bd6e5dc6076dbea134270d3551f5c1e0e582cdf2858f5945fb9b2a4b16645980966110da8052b748f02ed3fcad59d470030226331ccc4a5448e228a07701eb8b33f108ecf3e8151c86ba458b0b3bf56dbc87acde63c9e4e3df7073973171e800dcc050328a772d9ef8f8d1d60e7716df0a17cf6d32d3e44a7c7b58fe238eba8f0d86ad6b908e8a95721a2df43ddb98a44abd500a2ec6ae4c76ae939a17ee5e1172a87d9b1c4d7d4de78e73cbe397196632cd8731c325057b6f8f58b3c0ef1343056a81b77fc8967aaf9901a405e7fbb8ef2eb5bbc1903f55767c1d1d165c008368e527a968040106129244759d8ea390fc89ed2cecfb1f2c31eba1d9789d45ecce612d83f1f3ba00befc1b363436388a4c4f9d48e6dbaa5bdf7a6b3e4fbf2e8de6605b39650dfb523be201dcc628f1b323d39d953937cc582dd937818d1939606bb1b5133b33c44a4344c6f5b834b681726a5e848f5b529d16f70eb4b03fc0a59be46afa2ea59274156bf04c633acd2e2595622e22e3383f1e0ef9f4e98010cf1105075abb52853772e5921bffab23aa32628c2f48a5dc49fb6c63c276614ffb8777196307e90e3055da4fe2d4423775bd029a346c09392b4a51c9beda39056d90a4089f626fc8319f14099f992b7b048358fee90fe57ac31f0b8dfb78010af4aad5301c14af46676df600f7abb0e779d2e6b4940c56fbed85a92f24b9cb74f54008162ffcf0f21d2269e8cae79c0d40d51e06807a5cadbe439ce9e1470a62a5c6d76d1721bced7e33b58a419966bf52f1ebc12bd2d1c1b268c55b7b094c6c8051857436c4924916214b229bcd7a0dfbc22367ea18bfc0a25b59ebc4fda331e2c96bb16cd66da9341ae70b27697e6d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
