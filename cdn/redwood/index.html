<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b021cabee9e8f64778dd17bb11e71267367951f156402647cd79012abc60f602cd27a9badc85f6700c1ef9bf56b7001b9ce98145dc1c9abf4e53aefd9453e4f1f69f15d04c986ad9412c58f7dd5f7703ceae3c0e286558af6a3a031fb6be016c9523eb6956454a9bd6311306a8712e04e7876ce148c79047250801fde8ab4b31035bf105889a12f37d15bd131a40232cd9696091cdb416dabeefe6cfa15f0cf8de9777e55353db2cc39db7f41d8c04a1b1d9d039678a73f1a0f41ae6e4199c4239a3be984354da4ee30b425518c3439f56d7d09d3a850c7b9fd4663194958972c7c773b0c1e7bed0b20da343826c6e06fadfbb8a8bbc084c4384cd137307f3024fb612a72fafd513687dad8723b954548b521e523d86a1fcaa6b75e1134be376840632711b43f6820cf48a0b7d7165a98bce105711d7d62c05a231fcec22e3e5d7428a367fb486abafc49249f902552af1096f0c70dd4f488e96f07a28ffc91b38160c96cc87174d65dfe1a57a3f987a49efd0f550deeabab6665a4ebc7b96a9de1d1ce52fc06141aa675d2a2a005622d16a82bd805daae69c0a29f979066ffd57290f9fa934b3becf4d22e578e37c0e1dbcccc6a4f72d0700a63071926ac2f7b3fd446940670556dc46e5f3434d557a04bb21c912133d4a7ceca877e91482526b15bac5ce993d1ed6b60249f289e1fd9b90ec62828dfebf2411e77a6b570b3c011fc67e656e5af3f6d45d46c3d45c1326d0ba55fb75aab452b02c800d2e239b4c0f0f3d747df874f56987f5ef9e5d153be9a5df9b8ad3f3c160f96584fdfa030301e90a3ffc15348716e364ddd614fb1c7aae9095e311ed07d6fc0600a8227feeeb93e3082518e862edfc8729c218a18de54078d7f51f9090fae2f5f7056138131b8e24fb57e2a28a1efad2ad4a0354d8782ccf01bca0638e178e0fde5d354b152832dbf95de9da9a86b5443dbcbfabef6f3cfbd436ca6eca94dd7e6b287254756b03449c9a567682de8b4a0d5e78b9ffb1dce82cb84a483853dc613f7ddc48913cb0a0cd71a6bb5732e6047f375e9224fe16d14241028d26a0685b21519da8dc05b117da3a97481192718e1111d51d03eff830780ca34e6159c0e53ee9f4e64aa9737281067af3299758f835b83473675ac951b84593111a24570f6b88a283a4c357eadcdc9242b1d3964b4c168ffb3f247aaf8cc189e0262c797d89ee1216698b7a1c5fa37d6a163598f0e46b3ea2a5fc6ebce7dcf065f22e34a3cdf49d92efdf4404a760b78886b87879cb55e16fe813dc0daf9248972e3d88e4f6716ac9de321518b668f4c4fd7b8156eda0dc6ee6a78ea6f2495bce613b1e59b992e760713fa0804d576edf83a4f4a0d46a0b70ff99c2f106e302f60e18b396380d7b808fd0bcd22e6f0176ec38fb96ddbc2291065482a90d192aa4d5cff23c7872b280a1d9ff1668532a5f562631dad2324222091d58735c93cd4b53c26d8c5d1c5ce3ec1ae089939d2fabdfa73cb16fedf5e58d08e64702ea666d5c204fb7460221e07d3d4e5fffcdf998312d07c7afc35c23e0b29e96e1a180b3ef7547e354cbff3eca538ef31f70b4b1247537b6f9ba8a22e222f60e0bfe4431428161231010fa06c322bdcbf9deb2c86022574104b8be9f2ec383c83fecdf715519856532688568062e58720e0e093ccdd7169b807997a25042d98ef093b6674c2c50984b097be8084bd9fbcfd515d5968d526ca67f73f9aadaef97ae6fa8c5a2f6c7917716c6a5aca9f86aaba02c812dd791cff26664b64560b2d5753126e20d4d7b40d69a64b05f1b6569031a2035541956f9cc864159bdfc7be10a4a64ebb832b23891a169a6fce4656fe06ae646a79c747dbbc465e943a8ade472ec58c63e2072d82eea1a08969ba45d369992e2d81e0a2ee6dfe3a3014f38e201d07e988f28ca917bd102fb9926bce92dc0aed610ecdcdd034b95b4242a4a12c2f8d64a7a36cd693d347a7101671f7b998ecc62d4231dc389a9ecd05591fb9702b993949058e03fdc7f6934907242688f709f6a373a6b7075038c7a70ad5947d55db237de9b4482612d99c97d4d90537e840fb02b4a80630b9dff35d8f56f70bc6e41543d4422948058ab0b39610cb66813d89f441c816d06a5a798390e23fe78febc31984d5f9ec44a416acb93925a4916c0122edae6358b6d43d5cc43cdb50dcce88b3bce686aaf5ee97a6e0930d60a6ea021b5763da249b6099444f683f452e8a8345e93711a162572a0754d0494f943593f5e200bc9908e72cd2ad46940f3ebef8435c00a14a9893f462bf773cbf310a6cf2a739d2703c751b59afbf725bb7e53b24ce6c6e04080c69a042a4ca9396c87729950b58aaa915de528d64b715d7350dcd0c3b048e8a335812b98db762ff92e343c4ba5d8c2d4b3ff26111a1be9de53496c167cb388cd998e4500cf2ab3d699a71dcbd27c011c72ed45724a59ae0b95ac2b6411c5f5908b07aa736a0ec19051586d5114683177e05a46bcc9b71d78c4d351c89c4b62296fae17e64f62cc7ab3f493ae3fa8fc74f3a35bc966411f0e5d42f2eb7970cf69ae7845c3952db0d1cfef20e3af910235224b5afb6e8c6b4bc6fc23a729d30482d9daa34e11e1eff69ad49432784d5202143d66e81c9f97c322c613e55bafcfaf5a0c5a099866220fa14642df93176c0553c41f3a2c15ed6fbb03fb90ccb3f55183b0f053df37b3d97e93be91d4a9422d8a633db355565ecfd92f288651326133a39efc1f161bca394c4cd3fd0c4325c2261998467221fecb4f1ae511f17445e5bde902adc5d06a8dd6fb5f838f43dd968babb9f96d1209f895174a6aeeec0ad57857c5742c6bef388c21b4c20a0e0eb8f5c7d91673d33a5d66f28df3b58c9f32cae59bccac2999a279d64a43e588af3fd80f321a056ac7f216c098a329156e7fd4640f9a8e28da8a289282c6ec369445241df23460c4d7549f54bfbd666f9aa27b765c52dcb8266d6b569393613373576b5cc1051081926dd7f51c22d133902173c484bc637a530f32fa1e46ae7f4980f05a765b2602111228febc64fcaa7e08a642c7dcafaad1a09cdae2ccbbb4b9f40af902068e1cf13b89fb50548fe2eb460d84d1afe9eca99c8b1722c5487689d09c175e68f68365a8c231dac5297e56479e82e5f3ee4724b6ce120b251a57ddc8698f9b2dc6c3c9b872802240a2a40f2868fc9bde6ec06d1b79aea6c7dff04534557857af07234f0a4f3506f0dfc1890babd2c9ebe98ec4fd9e69b8e285e1c5ff9f39185681807026f1dc90b63d9e8504581a5603866352d8212925ef1cb5e9d1874e3b8023a59f81b9de007f8bdfdb48ac78c121554211f5ca3be0177ee3a216ba98e73aa5102735e92d97ddf238549f8f99b4fec98c6039e4f3b53ddd5bef10f471e6088e26ca1f062a3f85ee4c5e15db96b9e71966545c1571176b075af0227d4ef91855f8396074da82524688a6d3d122b3596a203e2a39c95ff60e1f8f867483546af7218f4c7184ab60cb64d69623cbc4ef986008f233706e8c77c8b64409ddbfe55b056a730ee02a79a36e3f1f9d4832e3bb39a3638c87ed7374d32288aaaa72cb4f5222ba4d66a759d2cc2cc37f84da9f92e3c1e655f7db5d65cc81337587f41e28164260a98c5be3f140f16ee5519d642ca62a1c5633288a80c6869c3e95308549c2adc189b1f2f7dc025c72858a986ef50c3c1a0ed80e27432bfbcb532b8d8fbad4ad7699e6c372e0a7d34a8ee9bba97f5d520b807980f6d23eb4dea19ed6eb0fa22f1f75f8099b0eb687658fe6e4d8cc8b181bef2b63b44478d921763eeb229c842483d84e21ca138af4a14f4b2f6cb3e29801b2727418351710be32219dcf7d612236516e534704a5e586df23becab7b8baaba082512f1bd04981619f845d170ce042dbb61a85209d846feade2343b4f5abbb6b9a9e7f8f0ae04606124972168b2189c4b8fc6f62847679af8ebb41998021739dcf7406919bea3fae7bcbe6a8144fb99e6296b59f82546228c5b653bb5986cf99b1b75b66a72e0b54282186fb78439f8f7525070e0bb9d840170a637c743ab03fa34f4abcbb8f00d41e97a9ffca780ffc83d60e0d42e16f7a675ea1ffeb7fe87b25ae99154994bd4282602d5bcb075be8f31b2695963597f2513f22e648ca9494d8496096895ee10897b2577989568a2b9fc1489058dbd5e84672d94881793f9419fbbea0d8abd8fc3f60d32b479d91ad044bc1dcb4eda817833e0985d667e66b7f06dc8f8e4c623ced344fe7e6cb3f9c0c1e2bed6f53e7a3c4faf3de9c80ad2ec4c2a7fb225b46837e7b448cf1a8852748194e93b671fe0f10e6bd9202355f34c928fd914c48e6c71c32e09460f8671c544724af6ffca6da03874e420edd5cf44ca60a80b7c0a6ec5bbd6ce7d7647c00a226caa7ae2e1b83a3f41dd7fbde73817acdb86b912eac2e4269e084d10c102e4e4158f22ba8079e947c421ff198954f46a3e17a2bb1c657a20cfc315354410d4e7772fefea3b832db7a49e0fbf5b3709e101b2b312d53a9907ed890e4daee49bf04d1887704391134e601e4509f959a99dc06c3a4199a679ec63985494ceec26b9d599fc6d58835c2809d947279f1bbdf1e89e22e6d41af6ca8c2a31b7dd0b6343b36c92df05616e6ee0e5237e493f9b4337d8a01f450715a94bbd05ce6b1bd96750a31cf7f718c119aaef64f3800b165e0f6a6f1b2554ad6ee197f5e9678b9f0bed7a4dc07084cf395d0edbf70297fa83917c40452fd8bf21cf34317ca0d36be7443dbd86cc46476781a4e5c6dba640064dae6612c5a242d4c2b7cb78213c7bbadc21b91b548f09409f7e57f104bc36a2046857b44e6813939f748d2f7309f7358a3439475e5115a314eda4381bea332d5b36d578825cbbad9bf21814da0bcd18a2a0cc7f378622e30490a3a7fc1f9236756a2ffdf09a2d5528ba8705de8e513a9bb75463d7be7ca89a293c26d5b702902a25a06bfaa2bb49ec4da47bb276b9b7da7926d7b39cf84941ab1621494f67eeea852f8e75ff1f54149d5cc31f56bf4faeb85659c47d050a8b5c38a18778c6370db05f067eb90f6ba341182642e83727431f7952f43d12e7821f20d2216690d8057a48190a0f059a88c4526f6acaf867dc665b4e8e346544900b264f10744b54f4055c2fde3e550925c2c79700efc7258effc51c1d75adcf352e07a41b470bebc55498234a4e4b33531a9126b080c92cd91ec4edfd6edb756d60669d7526507affefbe43fa0fc2ce6c9258979be337c7e67c71f28d47e7cdfadf9595edaedd70ab0a0eeeeec9de4c55e73cc230d378f1df8769bdb6e04f09eb78dc1889e6630b20e1ac5445b7d0bc73a372f20c5d6e78d469869fe0cea20d415f6b7fff47a2973185140dfb29d35045abc393ca27550eddcc95042ab5cdfe5717bb14d7f867b7a1b175d025a46f3005dedca0a537cc9033e13799be6387a9a1cd55d8826fcca3e9c760e1e1c5d8926180618204b954e3dde069265a39ae192446d9d5566a6d0c3e4af7b57a8a4d1756a025d3300c01476d4af67cc960dd1696c193fa04523c2734eef779cf0a8932b438a2283178d8476fafd6faceedfa20f3d43157991bf5c3451c5cdf375471a556774f0f275ee1d6ec7659fd675048dd63ed7b2b2a3b13ff8aa1df070a39c7e5aa23fb6c0bfb89e395fc0946a190d54c6061999ffd29133f0c1c1de17201bdcb81198736a2ea5758db8b81bea138585dd30cdc356d591bfe2f5099aa1bc389a4cdba1e974dd36c00ff26ac318c2c94d569ff5e63377d2ff447a8fc3daac02ed4e94aa8c0a15682f98774871a73df9525a5ddca65266fb978eb1c778e14230d45cb4073c19c6a8be29b6bba6b4143906ced0d29dec64a236b59a218e3470b496850e1fc6366f6b70611635dcf89f6d72300410cf0fa4db5e6fe43f3e79ab59150e14088a3c21892385aa1ce0c9e5eb547c4d8d6a804422d6d3cfbb15a69b2fbc179239fe7337455a2e653c718a74f46ecdccb65f30ea3fb3c2dcd2a2922359398c88262e4d44e9a00f6910a4c82b05c5589ad23b4c8f7294534df9b5c3c21852a81fe89fb3db67a3e52597d102df67359022c3723b3e4ada7073d5f42759bfacab389b99b784c4d4ed16b72e262af8837a5839b575a3ceaf2687ca25443eeebe11c7c2b748837e01759aab5668b741a26f2c7141b6446ea466f8e39e7ce898bcfcbf1994d8678712aa72e7e321ac74d504226eb7a15a70c36b35fd49cb6392ded9d955a004be62f475f69cfd48de18d01cd1908b9253e7c4352cf8b28fa428c733496a5fb15b64cc8987677d76a8ebf10744948580e1b33fbe8d263727f6ec929e61aaef33b8cfb64686753ffb9ac054d9abf485712b4e94bda0c11a1e5b3c23f4232b9f617eeda6e6b1ae30352adab0b3b4bb30415a844b62b4c875af3ef6fcb706b53aec47bb216245f763d068a41557cd0cc6da521ce3a73988f824392dc493c7c3426945973d90c7a1f927c91ea3a2e9ee1fc1c61758cb07a4dcdf9151376f6a4491e047281fb20a5ffd44adc278e957b2f389c0314de0abc65c040bffd419b1daa0d928d2a734a3a6042471e721251fed044649761189c4884e9d1d8caeed4a1e1145c982d8a4db2465238ea0fe6388f2154eb361bacba53a7a4c8ce5c1b472da8d66cb399b985d34d5ec24831dbc5316c9869012c094dcb9e9be86403fe17375fe92b7746e8b5301c6236cbc3a6a3bd680dfa88036838d9da45d12471919836476d1fc374a1f44366a1a1070858301c5e5a69f5494f51f1c5f1fa9dc0b39272816919e8a856a81a0110e3e079717b570ce3dce12479f7df75f00e997eec5e9374c1eeed9c149712115ba49cbf7d24bda80face54d2914f5a599f6272efbfcd89c161fda4f4592172211db9e74423a495df802c0b7aa05e69529289af01b55aa2b8b4c91865dd8962637d9343488ee8a8aa49cb77a339da413e4cfe276f85f12c97f31709892a5508c8c5325e67f8a0e10795290c8ee77139c181c443171147908225004ff0417cebfb674d653c1c2b4d2482f464189c581614ce8e255cabcf08b6cfca08141529cd10c5a3cfe2552302e5f4584b5892d46a4152e992c98252cfa1463cf1d52fd4861648c5257ba322523bb22713a5082c4799e39174782bdf3792af6bfdf96006ef1d692e8ca77905264b4239b2d60bc71fbd481c76ef46c09d17220dd87d24f6350bb2e7e843b1b3fe610619a2e852e202f5c9883d6ce72e8e6de7409d53858e826c80c83b13be795e5c16d8bbf25a8fd8cdfd9d1635524559e6a3f8995081325f0def9eca831d13933e485d5013f5d6d03119661cd3a63b330d1a057ea32d3a90ed2580164aac800921ad934854407636ebdfc280cef3ca461e7cbe247825902a79bfb5222a4e57aa65829cfdbfb8f09e30983c553f13dbf3e139a0690ea0258f76c611fa0d3acaea3f092065b72315ee796c104067f41b1c0dc9cb2bb9dec8ded1ab9af65b06a2af0548d3799e917b0814b90a84462a856e5fdd2356e12e770cd191dd9bb292805995d67366dfa6c9ffacb217fef56f041641dce82240de589b52ffcf3a834dd13051928cfc4b5b21bb0c27a8c120660e1dac53e9b33f108e08d97a04133710aaa451a6f945e8c3d79fce076ae71acfec7d5824d8d04ae892a01dece88ab74a030b7d49fa34fd8569dc0d1d91bed1526dd4a1099403c6759a77dbc49bacad570861b32f12a1e2a87537dc0f918678d69172f4bb2f7e72a7fd0a50ef47eeece122cfd8caef67ad008c7eaeb5dd626ad8efbcaf9d8af5bb251105e39e37c5a9ef98fbd473dae4100d2d54642813de64c6fa3e1b026c3f13b1c81792b9020a2a31a1e0c3cd38bc3bb0eac22158a2bf433a3075621ed10bcb96b10f5b331bc7060a6e7736d261e1651ea209e13ab18492b6b2758373c8d71be20cdd4b172431b51b5b9df261923067d33c63c0a7de9e0caeb07292b5a115b5901eb1e8c537d8db864af03032139014f99fef75b9d80afa072d288b9c9656c48df48f6d8883b584b5c9c5fe9c13eafb689c75a3cbb09c0855ea1c1912f199d5c0013cf1d1ee5a4ee2295cd801a780b506a5d87ceca305251c7576785cc1f969c49894ae05ca99e513c0282c30433658fb7adb6d972e3fea34799d20ee0ddf56b98333bd27461ae2a079782ce7de4ea8e9bb03f5d5adf8a29c9395453302d4af84a0058f036a1babb8355314a30a96bc68f074bff75bac5d347c3bb317e1bed87f3679687a00099e7db874bcec7c439e96d4eae2efe9c64a22a2e40bd81fd5b02a4f59a42f7ff3968c11626a6178839768b6dee4ab68bf7bdccae337ea91cce50af8adb6667e36ab0de8a27052736420741bc11e54e629de60ddc3425f2259a15182bae5f42a3a34b81399681feb5b192a15d2ffdcdd3403309015900b2f92d18f0d69d92a702ede0d50c5b9a1a23e5cba763c214e8778076a1790eb0752d05ed7be59091db455d594f9756814a2eb6ff60a286a470552a898386972abc1cfd54b22306f5c7a4734869cfc2f46d709b31ccbfe8d0591b844806d2ca3f444bf8cd7e727deb7e8336c62dcb329683614385e6530035b836e5b63831482db279e0cabc3e2cf959a81f880b1f255fa8e0549276f48995719d17797b2b03b8354be2679fedeeb29ee7a33bc928f583240c5c6b012281ef002a4637489685c459534dfef5ba05b089edfc41863abc2aee6d7bfc870e9614e94b154d18122e200d57b10b08064ddd0ec387e30ce8113437ccf423cd60d5b971e549cb639ae8765c8a298d328237d9757a9589dbf11cabbce697b509cb9528de260ced1017e13ba2fb9ea4281c57677522208d75383d33dcadad4fd09de1f460032dea9bf23d0b126e3325e17e1d7f846134462d2663334c21620e90d48b9ffe58e5ecb371cbb14d8cf0ba438b0e08008d9141a35869f4eac28f4d5f732ce2b28d67ce32a5cd595634103576e08e545f090f4b477fb975b7adcd3f34d22efab0ec52ed194a891932eff751c17424d0bdf2db66bfa881e3d08565158f23bc921d6c68de45d7e2d1760a05409c4ba584c8241f022bf49742a7b7f4f57a840c7b8d5d5a5501e71032326d9b273f66cccd9dd850094c1fa406ab97f6debf07a22af962c7666779d1cade0aaa427807e97003862b39abe19aee5b834b12b7df1edd338bbdb2b2d8cdf8ca6d24bd108abf08eea13ffad76efc3872901a286ea5545cd3a8963abba4597171f7445ae0cbd28418a5cee4659310e5acbcb13b5ec995a3e8c035803604efe81022eabfb8bb7fdc00afc20c845cd980c54c25506f93393cd8a427fc427cad573c67c68083dfe8f9fa8f00d8cf6023c0789968cdcbf40f28ef6c2cadf73323a1b7a1dc9cdca3e930ad9d08192d19c78b1498398634c16f810632f685c40ca759fc9abca25adebe496e28d08ea424fc926b7aeec341066bd9e842f00a3b5d081f6a619b42fc047200e7d084d1c1b14380cebc882dd36b27982c77e8db7bc91e4cfe3bbe9fbd25abb18b5294c37581c137fe792d697653c6012c04a77baffd1ac9ac9acb8ab6200541686e3081a0b7951032118a1fef57b30df97f85a6733d2ed4b41c9676937cd589820052c4c9608f4e427fd6a04036880dd1ecb1fa81755ece904dcc84af33ec805c7821a160a5e5a0dcd03e8b266c2174c0aa5bc9cff3a3f41f3aa0a2b929a3334a8308702aba736d4d17e6d93a350642849bee377936ce5af567460813873df14ee2dd68c86ca5ed4cd093c67e17600b57a0c4839fe7b4a46c498d455de1b1954048375afcf9df92eab2a428facbb197b70e6a49d83fa75d41daa27ee0b5d5f4de683110c532aff7ed7aa3814c5b0f4d8a4fa2adaa7225c0de1d9d1863ece62e2b77176a652f2f79d08f05fdc5cfd0193bd626a3991aae936c5ae55dc93075db772e21d0f034e6e58e061c4bfb547c18937d71fe736de29730a4e16bde11dad91c4f0007ded7faa70db460b8ecfe1e5192f8b57fbf6e88742213d08dd421b4d3285f7bab70397909931ace6dfca5f40735bd7ed86288cc3d44255b3d412a71c2f11504a10465a679394a34f5caf0ed9681fecb63a8c0c5532fdcfe40b8cf207b56a4b2f9bd171eb379611c8408d3f6b66a18ab9287d69f3db7e68d2e061530d48610291c28a5c42cc2d81203c31016fcd8eaa901d26cbace36964fea77487e655d01015ff419d66db5f9c80985ed65bb841cb88181d93df68611c88f6d0a329d0b2534d0e59a1c9c8067602b03907ac1c625e9e985a03d906dd2b4fb477351de8f6dc824d7a83d727e0950dea8687172b3919ec3adf9f288655011c6f8d7a28922a982ee2a4e49ab041ac48d46962683f40faa1ac690a9496eefe4abde363ac431fb1572dc46009d23a42c85165065d63760be6937e06f06787017010cdfcdc73d1f8ff3ca28dc101354f2c93a48ef9147c363dd70fd4236faf1eaccd523fd95be7b77d288dccf3f32bfecea681c56501b68ff7c1a4b27bc2d0a58684cb659fb38155e816783a57e9f1b61847669385f13dc0a1ac87a9151c6b2ac030489ac40f37361079d113a5763fd56272e30fab41428cf8cd7a9ee39599892b2a7ebac126c2b98d70d1fb651bb3696555e5ebc074d085c0d5cd7997a2c9a8e85b3b89f4172e253cd55810a75835ff58991da381086a9d6af81147d88dcb482d65769bbc9fcd69d99d234f25a73d9ffa866dc692744bb96ed630cc5a42130bbab99005f2783462868c00d05dbbbc2dd7155dedc931305b36ee7965ae4fa5eb89b5fa3941c332acd7100c97471dff98dd3a275a61b5c739d76abb1e8e56fc3bf94775ba3769dea2bb78e005a7df92cce9d2d89329273826b9327e48a8f57bbe6528f88f1df6a5037639c3e5ed54b67d7ef862418f4c588727f615207677ad9127afc92eae1ad73c01c0978f1a831b65510567949d3fd94c4a52638eb421be9ee6b7f12a4b39263fe293c39c461096586948cc6630d8a8df13ea4a0b29f8cbc46d151ecb7d0c6a6b07d1e5fd74bf767513bc8461a5f8f34b1c41f1a724c84327de38e4b7a8d3ff1d2f1f5bf7cade6dbb7adbceb7f6d33256c76a7d4685d2321858097d837a80a656c6ab5a5c3814f0ca9803c620de6a71b56e2fd8373040a9ae1d85e0de1a1690f917bab9916d0204a97349b8fdb460c7d482daa128b10e470afbb120c8a5d1b97dee442e93a899ead22569fa8ca0f02ece935e78de3f91fb0ad7b868507d16a87cd32f1a09cd3a571b9ce3279f73e0ad873c1fbca5510b17fdaaf897de65d2f1a2201f9f482257a46080b2dce918554f36a932bf3154b8ee36b1c4a518f25d56c6ed841ed6b6db9f227b5a6e52057c998d934a83b75ab89599224a60d672327e08224a4ce5a15d5ade2f705518cd05a32d1174cba894e3d4aaaeced9d82821c23aa4729dca943ad74bcb44b759a5f61ad31d6db7605389a64e9b8e9c8ceb93e1c04cfe3ad980b35ed62f9e5218a83b4e1febc8d44cc7d5bf3eeaefdd014d6154ad6c141b818d009bac3eeca33ad2271e76b12c4b412c749d41b27afa2835cd06b33c994545ad88c2a3376e3ff6af34ed63908234545dc045b1783f158ac1c331d85cd6b24cad6baee2ff48f3ec9f62ce22f34d0b5004069e83e11b2abb596e8e276f5752218aa61bb0145e48a59c2fc6e1830ecd2f1e5ebf0388d853ec66f21aedcd987297094bb84f84023a50ebb453ed0c0f07c1ef58bfb7278703d58192d2c53e86e84bdd6950aad7a1199e99fe3c8e8f487a608ae676233ffe4b41e8699de5872fa940cb982cf86b697dcc0ccda38d08b21abc4dc3b7a978be060f7a7f8b908b086d13831851c15b2f9e9c08b5a0a4d96724e175ff4d28402477663498c73d19eea10c3e5976e51646389ced33cf16a133df2c0c46a12b633e3d28ecf8a1a9f98a2185aac88112291c772af6f649fceee759c98c4fd5500e7895d40059a47f284051f7971f20e89e714c904345fd5fd2bebcf6dcc690c67c2df032243af6f0dea4777ccc69873a0ec88b59140cd5f1bdbafeb064981553abf76391d4e5f18a771602bdc69f70e31182a2f1550de66bd59d4f7e81155e268e46076457318bf28b56e650b617a4823237ab5f0266de6b2351bf531496a89b9f326355108a64c03cab0e244db9e627a67edbccb9639d33c1f2722736bd21b74caca4c26c5b29bd52d8d06b54b366c3e660aff2471dbe6b3df7409179b3b9c0e6e3cad8da7e17d435a0dcbe7510478f1c8d165202645e987787735bfc13f575f9bf62f8209a31e9359766bf991b77154b243e3bafd92c348aeb1915f20cc1a3f0d1d9df3b42d587cb26943dccb08e736e1f65644c82f864cdf34fc7d758bb415dfbc0fd700f4f383d476361fe583dc8630ceea63a082e07137da25632843ea81266ab18c8c1368e10fc373111cacee40301f984cb4f40158751eeb7783a5f3e64c1c32de3d3b9902418173d896597cecacef6ebb0fb82504abe0ab7afd273d6fd4e6cdb5abaf5e182b07043549df317d699e9cd595f4030f71ff176c5d8034f5cc3c410e7f5936e2d9c61ff41857ebaa24f507015b100a3a33ef84a87bc523fba6f025122c71422d7a21646038e6b548b8c62f70d297cb1d70eb0eae1ba3c737acc572dd1669dbb576a293569ac198718d573f64af7185bd48bd8d9d897f637f7d162d45c67054c34d06d28327f885e59bca977a933d3a0c16051256153fe75a5288bb820a9f60c4b9d7042923c775ae97020f3cc236ee430c79214fb3a1b02160c80fc267642c703590cc8b1a8918a5928ab3398e7699fefadb8de6bc5d4d6411f96a7638eb41b113c163601fbe4c5c0713a19c3065bc255eb13345adb7d50f1ebbee030530b9bde915477d4a802707a7cccb91a886c5d82c8ec7c6f2c1a8b78879680d12e242d167062c4957e39aa66b90b4c82ec1356e4e37958ce9c4e7d0e0fa2f51a09011ea9629eee33a0a77cfeac41886d872cfb960946eecdbdbe295ba0db47494f4cfa7bcdbf217d46e77f84cea05c3f9f0085a1001488cfe2298fd83679c69d16fdc447f9d0ebcf7af0acdaab04fe070be1ded49f3511c93afc1b600944eabad9444624bdf6ed3de132e61192cb57e1a81d316bf5416a9aa4f6e528561ec2f4bececc55b800cb6434b89b0fc2d1b86e38fda175df69ca2243a36316c36e9b7a70eca437491c67f294ebc3263cc1c1477c85797c3612dde14c5b3c467b5633644ea5d18f0ae3b266e5910231c63eccb1d05251f830f297c976042a2154f5f575da3b8298aef380a8348d76385b45b1553c58c7723afd3443df48bb5bdd23a1ecc916151ad7f9e946f64f1a84229496d112f0a1ba5c1eead138ffdb5ce5aad014e2cd8579167f33d8088e09b979f4db69547e587dd21cc8ac23a7fa33c3e1fd28321bd3f7f6777303a36efd4bb7537ce29aafefd5ebab0cc81ac9c2584af15e44535886e4b702711b1d31651f1727cba2f16714e724c9510766f821279bd7f5f19c04d7de0af58feb27dfb0af1cff7a092b4048b5e65df32026d67ecc00fe78d5a978f5e6d0c6552e24f6295f48625f3b319a35b6291029099f62a8db25bb18b4c22d3c6b685abec7552d57dd83531b6ff70f515ca7ec57decf6241f39cbc0434493e0c17d4c4cf9672825419bafb7d0a0a99b2a19bf0bcf6d08d4c09992b9e1b34d93aa7b04f8bdd3cfe99946d59fee277f12afbe23af5868bbeb9df9d196681876e2ffd7b6ca0a7d570488063703e781d89508819fa521957363d2554c5f32a4c01bbe01d072aa8163dc58055d1775bde9919c8e181295f45babc7249056b3da5c6a94d4969a96e0322f537a0fb36d3629ca24eae50b454c31bc2bb7887b5e55afd1235e927c94cae8af4d9536223bfea0d9785e2346044711e0a654ca03ffaa967ea83801c7a5fb142160f8366cb26271885d59ffd6e0e7b937a4fb7d2dc38920e830c083b9419abaee3146043888b862bd630a21123c94dad40ff9b554d1f5497caa16f047ce1f7faa511aa761208e0c8ff25c7bd5c94570c17693efe049b0b4809807ec236ff42a2f6fc857c0460026ec8fcc8f24822ca74a4c0e0426c8facdb14dd77d53ea923f633af96fa0a0208e23cbf2b83f1e0cf52ac9987ae6af927041faffcd5a1973a5f4fa2ef5028a790214f26182c3164b15545da2b7ed8d56b9fc79c8b3e318d6f6ad16187f926fe85cf9a60ff5d2df6ad9dab80756c415e13895bbf839c08db93a875ba45092d5ed0de48211f80d31b8bbd1c03d9d29fabd5bcfbc62754ff854e8a7bc2b271db099988b7be12f3f168ad41dcf004bd30fc8801ea862a9c5d7b4fb70c163a9e2adfcc5d7fe2ab686b4f875409ccb31d0ed650c3c9ef0ebaa00703e343ecff25a099fb6932f8c93d730b40772612a2e8f75a99b4962fd9d905b6d4fa113438f3cbed164b7a84d6f7fba360884f47a24e4136c9145ca8c4aec6c4a5b86f43d32aa2d73585c939cd12f7aa55fe9484edb1ea51d16b7fb66beead4cb89a59fcd1b61feb7c5b6ab45a48380f81c615625fa363bdac55d4ca5a7993508d75df65cec84eddbcd28abf0a0db29a424666c6e91dedcf84103950083c5e96f36e57f4feab7c3633c8d6de3555f7a541fb45044cc19b5167a0b685048c31530c46eb88e8e531a84a1ab9e724a7b7f8bed933d07ba29c37ff909922350f0807d2a19315ee615f8816bb1ff27c986717a72279b3609c70598b3e7bd8904d947ff66d871b3c1d660a9a17a6d5d9050f3b07abb7d03d09a9fcbeb69e2ae62526cd261e332a0bbe97d38ce99d29035a64474f1d0a07b391e975468f7c854c3e2f3ed1774f08a542cce4627e01d07124226317132cae646e30f258e4d98c8f65db12debf660a8e1180f6362df3b8c922608385a83daa24c407fe75729e1530c706af527307081c866affae0005d08ce691aabced0de6b713aba6652748d3a5841f24886ee32080e38b123c19a4e1608c188068ad1ebc6f46beac119493d7ffb481b7cf3057d7c853a78739aace914ddf2ab23955cf38cd0adb09d689f6a52745ef595430cb335205c36c0ffabcfc3d96c21e17a7857726a6fed0cefd32bec797ee78f4f3596d8920f972dfa975c3ad116973cf29e5f27cd0357883cd021b0e4d9ff536081f9284a8e06a13b3dffee5ecf5881e0c0e3b89b60bf89174a57abb398c3854885d7f39cfc0e562da94bfd75e7c5fc42e1a82dc0c50479a6c5da4cf668b86972032439e8f4bd5c5a3b16f105c761b94eebd474e702868df64abde7df750b668ceb5a8fdceca971b2fec8dcd367c17a662ec15ce8df1df5590d8c275c611c793d1886469af29337c5f46fb0400453acce33b5aadf7325a4b2a0ad512a98198f77a55317e2b52be2d20b230b1b144bbd7fe24981ed9a1ce6ce43511d7369238429365d7619316de7f15a85dfdcbb4390c636774a34ac9e58e2542ccb86b57585073b26a922d6f6da917f18609d86a56df5a7bdf8e79fd4870b14690efb1470a9dc92fccf4eab8a29399d819646b26d920b347e4adbf24c7fedd590a8e606437b78f8781bed8e480284b3f2f04338125e11d2a6f5a80748ccfda2116aebc3ce22d85d7006e7b880ba4af44ee0c06e1282a6693969d7df7c1c758ba78c28829bb8f1c8d172a7f386d59d4171c5bd36b52dde4e6882ccb5dd75ba52b6b583681575582ad054a1fd0630a618b955bdd5df5f73e383018a9601f0af5f50461d48ad93e06251ea885f96209c73fa86c518283d5f80edc609bc32dddcb6642b1db319240fe9a899f843b3f890376f687cbd0c856abc1b3d76b42a2efa41c577f4670b711d65694566edd73ef81c674e3b0c97fcc7c378c8121f47067716a9d40904ee7b98fd75988384927d07763a8628e9833b0be097e4862cc5c49a149f8e5bc93bf058eed4592ba18410d812a6880d95e3dfe300230ee3c7b3fd1d637b125496d3b9f6819c2e634d2079bf9278709378346df6717dfa67a93b6fd1a45ad76473026d5a4c412dd81d6ac1f1f8c9f9b3c71428876611914f64ddfd52087a334f4b2377b9d0bfd7c0809166ddefad448fcc0b51c1e5fe4da27c4d3fde086b64fa240e05e8b7ba8fc53526249b85f2b3e596804e1e4a7d15ea02be9279549adc7399ce81f897e5c73c0ba0e7beb3328a9682e90d713dab7e07dd2d0e8882d267c3a563664f96a381db252e043a6825dd22984a1ed5a459e090faf8dffaa77013a3714912653236a7ad0f5b8678585e672cb89d8fa6618597d1fbdb1e4b72caf63183578b37029bac75aebe3210c728a98ee5798557bab6f600f6b810b230b4a56afe3f2db62e3fdf9dee7d43408624e9498d7a0677a02e81c511c833a1de33d4658cbece6a2ccf76eca5b3e522b0dcca825174599809a8bd7b4de0264d3222955fab0915b47b6c5b1fafb9c2d1b6417a885af97ef36c90e05d5a68ee49b3dbabe7031d2ce81d079216c00a272d6d23357c65e5f372cd94fb34899a0a5d213d3361e39f4ade118c30d83abb8a595a08eec32d7f6db9e105b3d4b82553da9e5920af2b45bb0f1cf9df53f4b9359aa3258861d9d1f198fac1681f4d0755a6cb25969825ad01d1c592a40584e9179fa6dc79cf4f1f961e4db474e16777e1d53b468829bd0463cf066fc0b2d4804a875b6473bf3dcbd8de5124b0bcce27c1d8037639698ef1017b5310285796c686410ed932aa05e8fd79ee7e3b892c611ba05678205e45d5fbc3c649a97dc7a69ef00cc511bae17dee7a31c9fd2087e366948caaafb5cb61e63c5adf4ed018e2bb09e8d64e3b888ec5a3c31484ed213abc6a5d97a45e69782263ff79b6d2088e8c1dbbd9a75366deeccbe13d2910a1884d785c054d5b5e79113ec046f0e4d1018744f24a5c3d5fa9416ea85bd4dc490d3e59fc70cf19a96d741cd92afdbf3715f013b7eccbaeae9ac86ff84a36edbb592a6711c3abd7fa2016d2b4de55d9879a978f3a617fbbd0e8e6a5a753a469fe10442d1b4a1613b382daacb5b8c5c600c978e3ce176cdf5f94e31d7a8872dfb7c1ff3a15366db3345666165d4e4d06c2a03e29bde500a48905416d3296646985f339322e476c80969cd87fca8582b306fb9cde855a7751891e5aea358720ab3ab78a57cabd2f080a612ee2b1951971329322928fb67489ec39dcf0d489894efbf77949f630d1a03388d3deaa9d967b595bbf7cf1861980175ef707b4f1214a47eb767fd87d9b9f2fdf2570286b3c0983a619fadc08967050fdfc4bcf18a32272fd3bac61301d96b074aca8ccdcddd19218d5433d09bcd882da8109134ea8af2bea3353c7bd1a9bf358150bd7c21c893dfb0c34381e4353c470e5e5f98a5e507d7d3a4b67bfd629fe7358bb28098670192282549c055b48698e2f3973f0b802b57c11bf872429b170c98d155c6e1a46b84ec26d443a9d23ea960f7eec624a171bc8a9b8cd5284d5be8b419ca991e00e7b0bf2992b5bc99ff2daf52d0a4513b5d95726850e626e77fb60405424575f5d5957768fa3440601d49de35981eff5758ac2a5c3c9c20bba06d90c12ec7b40dfa8ec8216e3208bfc31f68eaf535a53a5890ebfae0d0f25b2b51c369ae712d1da514147413341a60aa55432ca51bd276049cd77f66d44d0eb96791c7c456f3cdaa2bf301a37614f13f8ae3b063d133d2deeab6524f5315dc33b18139942bcaccfa45bedeb83c74a66a142961356a32c693021468745b2abcce7875e1ca100de3fbf910d32604b2e7d51c95b84b3aaecb95ec7817330880bcb169d26707a91c81cb08e504e735a38b3207db66b0b5c774341b1f64305d4435587ad30b749f9744db8283967289d8cfe9fb18a49325ef5e22d187daa53443f9b7182703711797b5bd81bcae1f4dccb40e51abec7d0f6bca5975feedea640e96a580b80cfdc53c82180eda68b0cde7671a1ec7fe6a9c3af511a49e6f3c658883a2436e9f986258aba8eabda5c15900853254e1cf9d6037505bc29d10154d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
