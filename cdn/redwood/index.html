<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"274ef11ce1beb9ce3db4475c8a33c06ee0dab488c43a5b0f0cd20eadc427deb1670711e00c53a9a3eb13bbe7112e25dc01e620f0fc6e5641b63c63c07501a9cca53f7f1d4eb6e4e85d1cc245b0ae439c37571aafed261e000b17bfe3ccd5b3947001dd48b2556dc4b167622b015effddf095de2b87219efe4bb45573faa9f3868db536b4536814ae1f9416c42d1e2f24e09f877a99073b363bd1a986af92389e19a5c11cc0c9f5dbc5c567b8553f8495380f3368848f8beb01ebd4316180ca258bb4e329a2461e77b516911baf646ed3ba7b94ef21c3a0b872aafb90df434c681279c26be23da2fab99dea4d60d0ddd10f99c309f8c35bae4eee3ce8ebc76514140b96a381eba5ccfa6fa645f13ed13e91dd428a0bfad4286d565f582d8bd73a24643fcc1dd1a6a566305e0291426177cb4866fd274a9728d2f0624dda0630304b8d9b946de7eef3b08a2a312de48bf1b3c8d91b7ebdc602f866ddd8cd22d8cc99b44c3799b8f3bc7820dad5d2564f1f326e41a2d5bb7cf276f534f5c78303f5602a38f11bda5a478c39ede9fd75078044f6f388b659d6ef84079ac61061b58fe153a9b79a410280216d2d53ef7187776f7cca9beaab9c3d3bcfa0a7d3ff2307f2f6b37b1cfbfb0774612e7d4c6889da851219c6eaa344c54f7ffdf541351f91b5c31f9d2a107fd117d2cb44d54553b8b487e67300a9aa158154d112f3379c866cfff68f60a4a61740953a2fa86b19c0e1ae963776b007013a94ac6a6e08cf8966bc389d8a9720ccdf1c52ada37a1d25ae63133b66d7fb73fc73e4454303d468a4b00ba558660b0a03e9dd685730051d3b94598d1eef1463f6733e51a38b9edc07d5d8c779b5c4c47bdb41e3629dc47a12c9e7570768ed7845462dca1959e018f5a1a504e6f0b70d28406959ef8790461600a1dd33505b7c6da6d72acf58845e86f3b34074430692f6805da6116f6c51a50d612ea4cbd95a5848d92e85724024ca808659cecf1fa5065da871506d6704bd484218de462cf5d6ff57d516e56b6eaade76f1abe8d3f6f42c7f2939c6b0a20e8cbac08fd510627820beb0fb5f6a76de2d64dac60ba9bb227507aba8a0c4848bd471042dc89d30a08af59d91b2f9894d0915d0c4accbd23c6c2096be5ac4f0b2e8cf65d32ffef4d9efb5ac75176325fc191e9af2e1d27fb887030d1d1a0e9f80ac4e7cc639df83d88ef178a9ee209fcf70816f0027e16c643f9e1b2363b19b2521ef8f860369e99ec823ad62cd5e095213c18a2ab554999f025367520deabd3c6183767528871c75120f30a7a4ce9f6baad29e93865a76757686f4e6cc60926a70648bf55fad2fb7764a171f1902a09f92267eaffa82b8f8406f8e07d162c0888964af78b1bea3a92df2d80e2bc0ec1448b578ea1f3ac54df353d671aa1d4069d54a2d83a788dd6a1dd8fbf018c7ef84d315a5fafe1fb543faf62a47b91c707dae04d5605b59923ee83828323571f30b0b1b7bbe8f60646ec2b3c6c1230fa7e931cb55b2b7d1b482fb93509b0d366d22c58b69085107f067fe10b3c7d812711750d8a4116b75d475ca147b824c2848cdd00b2f342949f38b64900f24e6e768ff5b19bbcc8703db760c9114a0da029969e92e87c0fa19c5d6fe09b831cd158dbf9abac6ecef4e4bcf85bf9491efbf6de3746857d219d82d883652c4e3cddbffef4a3d419aee9ec5de2470e54ef13a386a39e2a8fdd24fba6e5f9d0c6b3d4e6a2d4b7b870e2c3f3ea3763d36f0869bb4c1d97afc5ec7ae37ece30dbddb89bf7e316e1f85e311838cdfa8a97960ca71b1d0fb88ce1fe9251d923d9ad6dbe1a7307d5da93afd58385a8f3d07c9406d19bde58755176953bb714a69b49c6189dcd8f1145220f6a4766f073edb96ec415594ff86ffcbe75a0209bf35cb53f41815d7825accfaa60bc5b559c8c10eb2aec93093367b353cee16df655df76216de6241f065daab0c5b962d3efbc0010d133d87486702c3b0677cdd557b5b72ee976f52d1d2854f9bbc7e5c18adc8c3d92425fbd4077c90c577bd4ba451693cb811e3ac203d145f4ce8ecd0ab5948b77308c99d065d4b40dbfa9c5921d67c6f0849c8b0deeb9e755255f76360b9d0ef67405cff959a6bafbbc011708f9ab7ec98aae6f759a181c998143cf3690167d942648ae9238c92a337223016a60b363f423fc95efa5e5311e8cf7b02f4a5cf6d08cb7d054c41e844e6f3c4344e95610efa6b1b2070c11b8d2c149f22649ea25925ac174a1adafbd2836fd11815d24c66aa5984c7bc27fcaaf3f2fe2afb7d49e6bfae6d9710470a61ac264b2156c1ae31b6c03b5e22499fa99f6a76354650fcaf29d70633bd3e29bfb4245500bc42d8413c5c23147d40096c204b92e41dda6c39c0cfd787b67e2f5897cd8dd9b1cf3d3dc1eb81b202758c1159264d160df1135e5f69525001f2c5033f9451e0dd8ac8ea5bba858ea9bd3afcd8d589084a76f8a0b3c5978355b782b11ac5d1a022778a09ae949732190ece86e12beff686686223e578c393d9fcf914f1748ee0aae53ff91a8ab4e1dff589369f40fce68bf5f81286e76999adb0b8eca750202345b980650930fef2a43ac0b7d5bf4c84f6bf9afa3394bd2aa03f2e3856ac04cb60d7b3c3734d893d959f63d4f9e8acc50da59c638806488ff719180675cb8a13799b8feda9cb73b88e75b11942b37a3f51b95876de6b16b4a74ee538dfd94f3d7aa7e062b0ea9547d6a9fd8a96e3f1731140f52aa11029e674e3686a16bb6ec29021fa7c8ffeb5b4ee05918736e63e94ee0236b3fb7d26c1bd3eccacb3f11010bcd0e536653765162931cc48d5b290095c3026ab6e964b482a44b906640946700de7e14c4e256d41633fdaeb592b57eed29c5dbfb8367e6f730cdd06c14f541407240b7e6d262f3db28706b7db925360b84a8ab6342b85d8084acfa539dc25ba9c6fd6b01ac96513b692f830bd2777b6c588d10b4455ff697a0b71cdd020385efd21f2de0b92411b14c51111a11fa8a9f79583bdfa4629a826360558059e0056eba1a1f45e41f8f9127b0830c56f079a594c17ff147cf3820148387f0f2411a1bca0be460bd627bef32b229354519f04dba5130ee9fd962f5bad710f8d577d8b9ae06451bad8043f5bc6d0148b772a65de143f8f1111e7b5cc40674181724bb4c29e349d44dbecdf40c03e31ba698115368bae21eaed309d37f852ee0391fca91d5a49471f23c6286b8bd482ca0106a847295aea3f5146b8a875387ee529d30c7860d48cd8144e86f2f1cf30d7358604d31eb4e55e8a3a4e5e01fd992da485b4f129cb39423dbd09910346a8559949612a67e726448f464bb3faf9e07ad54bfd3d9b2115d20de90567889b9e8d431fbbce12019aa48379975e8048a0bb0ab4812172ebc072df68e31d7cb801b6c8b6be33fce56c830fdfaf3e57efab1aec8c13888cd8b877dc34016b082c92e8eaf942cbe200a5f3f97cf411c62ff37ee5d900243c7febdc02e2bcce938e5cb279bdaa9dc1d3785d31f65a7194327700bc58a23843aa2d08fd0cd0ebd51439b5e1372aabc77ab84aee200a56c6c1041da9f79a23449d32d5110074b739e56f4e0aa432ab5385bd5d30b0ac48040195d62a0c24777e2b2f77bac24870af9e234ed416629275710d6f77cf457cef13da558b5ea9b6d9315abe59dc7a736dbaba7e2e347ed099592923b52b8086e3a6479469cb0a9b105c98d80b01a872dc9262fc965470fb2ef72f7f4ab11afd130807f88c44a4ff7c05f0a6e2534ea2936f7e3b2a8643f222575d1bd1c55b0784419155d4ea19851be8516b3c8f97a8dac418448968863e8ace0f10f40052c0d9673798f4ecfb04ee8f7b11ee65105c801fed0d9c6c0d84ba235fee7cbedf31df957886a7a09d4ca72ffa66b8d221b8a681deb3edf63a1ceb305b4ba88923bc24227e10e0b2c69064a7788664cdc2b5f743f5c3eb9e3c0db864f0fef26b121f6153052d1829bf5f64629895cded4a3564f9ec7535c0adda8686480985c744ff5a4806f4233941cd4a32e6140334943fd07f8883791b173b10cd87591ca67c4322a41e0c7584f95d33cd9e95f1483591c11f5862739a12890278b3140e97778d710362fd330e96f47a859d7f64c84f11cada0e7aa9a1ffb467edd2e80fb06beb5a99dd0085023f7cf5ba2f30bd71a1365e979cbb2109406a7d57c182892d3a1deaf97547adcad409373d5866c80c9834a6e6391d59c87e55778f6bc2291cab003063c7f7ba1f04182e8f12977c2d0ccf1333a0415647e2bc206c584992e1fc178c51f5762b7b809e2e443c12b9929c5c248bfed0ec07476f2a8c47ffd1966a6c8816e58257574077e24bf377931c9d93b6b782812cb8c180abc1ce69cc02b25c14dc55918c44c657b173fd80ee78e030947ca899cd1480b70a2904ea913ec17b04d410fbf0dc32873b61f9d90a5f0663261b10f001e7a3c5502089210f712dde05aead76a4776462541fcadf9a62b6050150af7983f35e87e7b58e7eb592b665aa3b5e153d90fccfb491276a79d5ca6ed6c7b534ec092ee19f5e534b6a0901f0d4e0b88121172b2dee20de6a8d97986f032e1025fd3c3d7876d3988f29de73cb0873aefed349d0569413b22cf45a93bbf150a7665af13cde2e40c1c2ede24892073f505eed7a1e8e4ed68318e5ec4c9796ed463872d7320a85519db7342a8f97ed0c43e308d52a33da0ee14fdf4f0415fd7c035136f727e8c96490a2f4e2005daf9910ef7f732b310c7551eb929b427221b006d8e3fe84aeab9ac31f819d85c407f288cdea32152f98c2cc650d6704915fdb77fcaf89156e0b2559da18c823d44c0ec6f9d3e9ba06d86bae225877b9773588d2482fce027ede03df3814e4d21fe687227439ffc046b5f8544feffe254c42b6710acd41f70875b1dce22d76196c13d9da9f96126097ef15227c283e402f63ea4d943f824bc289b7dd2bb90a71b60ab9e5d24e9fac19a8ec13bfbe56562dde84fc9e57407436678fe4f056e1127ca33e9121196d286401dc810e0b27abd54cb4115c004c9b88a0399f0a5ff86fee8bd18ac85f0810c8ab6d873241d22151505eaafd22cce1457a4ec8b322f7d060b05a8cfa8803e2284d0db1bebeae291ff8b2e661d1cc160db5188117e71677fca28e869f9693d3558b81c4e387e14e4f3046aa091b5170f81a2b8b73eb53b3fbb0c17a7852d4533e42e2b0f8d35de39c4ff6620a887ee087d56ae8fd9881a7745d0f674c05c7098f688efa20358f7b5ec3b3a411f63bfe18e308a8f516acfb81913d6e86a0d39d7655850a76a82bdc5e2e484bf721b4d6eb89aa4915bee51ef7c57e2ba1bb85655d08464e00de123043275c00a31fa843a0a253e9cf369bc3ebae48b91cbc2300c6634c1f66bcdc43a514edc15c2f32f4acbba16b1e11e2a52121294beff1c5554add2ec67a01a96fd8fb98b0fb2253dbd121b8b8d2f25588449720f52d22c61092bdf43c8cf0ba760bc5f2c0f32893dd0ba6643b2c8072e2bd19634c2fa7b1561536bdc36208f7bf3d503c326d433b382bcd2550a9953f4597aa0a99762afc8287fdd295566f1bd7efdd4746fc790817b7b8d9a7fe378f1e8fc2546681117c4daffe0f7e4fb63446412093fce19b374c4e6e86bef10890d51afa7358e9e5fb51e455eb7042140f20249f5862ae8cc75dee1457bc18110165f5c15f3cb4b34c5d7c9aa966f562137bcc64d179023a6aa6ff9aca4fd5a454731f8925aa4c13dd2cbebeb1535ef79093d14c46a590a9e9ddddec5fade77e355e214fd5732d12c933eefe33c7a2e1d4e846987ff2163f4450560c64677afb678baf3c4cb2c320764006cb9afc6f4758ea8e3b2c28588f11cc23873d265eb49f628de4ce931798b5b8866803d0cc881e746f65100cdeec634dc963378d20cc9f7e6cbb4da40a61431cb00967f016837118adde143e010a2a65f735138b8b0d337cd6caa4981637e1b36466d8e0d758e556f9fe6803b3febbc1ede413c466a16cc766cb0c6475a79ab4675776a0f877bb88c2c2e99e4d55a8740ca3796ae4074bb60ad0400046ff6c4b3862cc35d0dc7cb172a5dd4d89d6ef6453e1885f83b272654440a4ffed609a7b8d2b734f3a42d34c8e8be7ee6051e961e45a00d5cda7e3d38e5c607ae6864ec8bdae83df7b51e3a3f13e1bd5dc370367ab30ac44c40c567f126f32f84944d9a057094fd5b6be2809cf17db41a0251af604034f908783fe54275e30696ca7fc94bf5b4203b5a332149d8397ad4b95876cefcef5b33f440b6e1cf2f4d89b212a44633168445a2a8a13aaf76e83eecb757c3a3f8216391ee41ec897e36d53d55cb50500dcc000fa95bea6567ffdd7a43533471c99ebc75854010b69665204a48cd495f62d89eedb488c0c97675c1945d785556f7af7164791db8d0fd9f124dd22a525473eb6f32794311ea0fb29f4620453b006ab9b461f0ded84478e723ee4ef0a9d0e11afe77c8041a4037a17b686cdb80855cad3ea2d36f540eeae3b0d6578cdafc9ba6e317360fa7ac38474f1625568bd16197a71846a0a4381bccb6bc6404153c77c93011290ae9e0a837413bde9d0878f826bfe850714a81b2ab2c461163e55edba294102c302ee1f3bf323bacbfc0c7b12ffe541ad9802e3719903a94838b183a742bbb0128fbc681e0b614ff41339f36e6c58ca017355162688a49ce2d1c3468b477229bf32858d8fbb0c509957b1ab5df8f51fe2c2bc4e7e627d6407f45261d8e22a3e448c9e19271e7aff043237cc585fd23844dedea53496cf81fd7e2be4e4845237c377d07f278c771da7a76bf0984e0da3342792510d916b039674cb1d68f47bf0e078b8fa64cae23b2eb5b47c376855a7d7936199d5ed9cc8615032a312c9cdf4a6ebec623ea04e13a0517aa5cb74f9037e29f3ada9c1fd908ba9adef2072413350d6a5bf5e6eed72d484f7386aace0120d72163411c4b4a71cb9845ef6904867a1995176e7dd0fd967f2e525e21aee89d1a04107ad68664c74d0273413bdd85e39aaf0cb1decfa16747e3deda5b1e213ececb25cc86f529406acae8b09d3214c18f08e66fcd9ef0cc8423843c19421204c8b5cf1886de6be6cb049d9e1dbca2b8f4763e9d1edeeb1d7900ff2a980b02446b2b9779080c094cf14727bf2eb7059142d4fb03dd035fd76a0423b43a3a83d016597c716f6d4969b1f39aeff6a58d2ffb6c1be904bb2cb73a1e7aa8713ba0e627f6a2012a1eb04f43c379e2a0b30da8ac4305139474b2c150f9042175dafad0fa9227317b536c1191e8222b6415477583bbc2ed09bb1d3771110e8d044833c9bf5f6dd6b6a3f2ed82fc00b3c1a3853fb1bbd87a0487b2dbd5da94a569921f84e13cb1a3b3f4e3a2e2cc4d237b621dd16fbb467d42c2f5f24b1ad3860e7414b6473f622e3dcb069e1d5d945bb4f33507da6f980c63e55b1ed7c3089b72fff2e8bbb1a0996c7f6efdb90cca4fc13018185f94592e38dcdc0c8b8a2a8b0863c20beb23c50add2f7a7c78892052772bf591d9331eea53bf9cf8f131c4ed1d391c5d57fe24bf691bd104310ee3a2ea9544f45e3a4fed350ece41f8287ded4c63d47920537d519d5e9d97665712ec78f8cade6b8712101b801c686e6b95621367528d89c5fbb814c46d31d92a618af4082c7dc3072d4e4dd2964e8f979af9a443ecd7df00b6cd4c078cae9f6196816f66ccfaa0e96c648cf63829a4267c9129879df70596b6e94e062684be4e186cc78324e03b81d89aad0a65e2545d31950ec93983ba6b3a73c3a54871fc39aa4d5032b352d2d41032462083a59efaf81f1535120c31b7f69f284ccf26ff0b18ed74cd07aa14494b5ae008a05613c1eee87de89c0d68bcc9d48ebb19cc0368d8498c57fddc5664c3f3f0428c62de11831553f9887dc7ad0f1da5956865b46e00c88e6d5eb987b75b6f6b5e4a14c648919e8ce15ce4415bfb48534712b444d06a934dc9f37bdb920412b1a9b59f44d00c2a8520e1946446b21da2b4a7a02191d0321b06708b60cc0f7b3bd7d4c270f903e445c3af5f6b45484f3167c0b5d2644722cc5e0ebc1aef89a937fe7f968ea5469799cac37062a508c6814be5db04dc68b12fefc18efe93d63cf6d78d526977df5eb2008c90cbc64e302994d5091e9d531c26d66e27f50f541b8999c956aba2e2fcf2f860dd0589b565eb6dfefa12ef2d46580b5d535795a3d98c3303f10d61128bb1f39bfbb92c7e276d31890a3097b27065aa4eb592a2eeac30e6afc6c9bfae7ba3996acdd3fdd949ae362db55d5277b2973286d1c70be537f0f32d3cb0dd1682d96bca407f22cb8150fff85781b3ac1e45750cbda60c1c49821838cd3fea0fbc6e3664a935a975878a28283e12b71f8ed28d8a4c0d5dc924855636d6095c1159526f5f9f09e92634cc15d3c4f12b9e4e0dfca308852f1bcb838eeba4296fce712f2e1d0e11722a2df5d7f55025749146dde80138e99276099cd5604a4739ca1ad8aa3804f81e9ba4c1c5554f7eb707af74dffb16c9336dbbf3a65f83107427568a0942dbbc37171c64299ef8d5c13a13cb80773ad7ca7e2242cc991c8aa80fe81720e8fa3698651d289fb74dab9f2e71fab75923a38fcf2dab47e3cdf1d8c742651759a9ff3f00ca64ea68a49da2418a63e89bfefff522700600b9807d6e1592c61740014b16348dad060939e375ac0a569b33c2f4ca9b0ae1a2a26820c0d8f0502790ce1495c891391be44ccd0943033d5e98d4eacb00a6e4f824ffd9ca13fce006997a442e065b7117dd03ac6e7138c5c95008749827ba5381a5f4a6fcf05346caf9882be7fa8472794c4e7137d65a0abea0044d5d54d6db1471db63726d1dd139cfbfe86396d53bce96e437e33520ab1e58c4d537c59261ab76ab386dde518d833b50d9bdca377d8fed004685d5a42af18be74875f4e35eff007995fa89979fdbd7b6afc8c1e8ab44805df6dc02d888fa13292df2ea35af8f43c95c7fdeff090d454162cfb3b61b89fde8a2704e0ef44d97a6c411babe6fe85f87af1a692531a409cf415b7cd68e2042be0cccf5f889fb29a309ac766b248c20e510169b597e3963a5d131758bb2e0155a79943a4e3aa6bc3dfd1484998bb74222e372f940a22400fab2a3cd72454df5c61be9b5db306473e05d90643daf48705fb4eb029db483b9dd8925786dd67ab17ddadc516bfffc5537b140a67c48ff9a5dc9e160ff8ca95c2f698ae54ece7fd5e437a201ffb98329da148143904c42cac923fd061780d74526dec56be56c0ac5698dd2f38b96c9a517f4fc9f36603766f551d5199df4f5f1c98638d9074ca78de56adb427e941c54a8d0b95b7c0d2f58468b7d7eb41bfde5690c25da6052c05aa35d4e4bdd7de87592c3e95764e8eef41868e734abc1d2b916233a711ea004724623a9803736731ec6e81e2cf2ec522a92176820408c09584706926d35188bc96f2a443cc5254c830aaab4ab2b6c936324cad33469bfd2378b3a743275c6cb378d8c1b99a8e12b26ff3aacc67c686e72a8c702935e7f9dba7a4111f8ad58530c8915b37b264fab46cf328eacc972df46506b45a920ffe238101057182a4a0127a17036fa63478b5d6ad0e80c9b42fea33e7828e0a0bf51ee4d379783619e692444b9bd9aa2b56d701aec03ac9aafaa05e21e489048ae3cc32ae9d339ed873631a7af884e37237e9b2e3b97ea85755d268e3c765a0a4d3135f81585acc9d7951671a6ae450bc5c6074d32137ca0cb43b7b88df7eb71bbf06503dd237b629c009c2268fd29a6babc79d90ea3fb94857dfe07ea9d9e36d530ce8f9fd9f148db72eda75843df0c5443147d08fb031274164cc370da37f1e2806f50c08c7c91dba58f46447eebf5cf0a3e56bfd51099ea1a82681884d05be3dfb7de26a7b2f67f1aa82482cd74e4d10bc159f867238fae7a37f1fef4a1b9786f67db32864b44734d65539c4dcf1683cd659ef2fc234c163d7f1c18c45590353fb9169fbf2cb4bccd572ee73a3962d7a19edf750cc5a1d2082b69541bebdc137b37320812abeed2d05e932875f9f81dce24d0506db17b43d043d6d23661a67dd292e694eac3a93e228bde3024b058fb206eda604c649cc7628e1bca5b1056d08ef71ae27904f7faffc5029ae9291068b0bb69dca9742569c0eb8a58a29effe55e5282a514354a315bcaec8fb601f9dc2582c2bead347b375c8ec2f2f0e99bdd385eb065ca45758c61e4364527b9caf853dbc3179c2fcca036441f76d0347e449e104bfe5a4a20862701ad6f80bfa102a4a41f2e8996aecfd0c2db5934f2612f35a0b1b78b30b09ff81daba65d136d19033569a7f537fb0290ea579f5d8569410c5e91036347a6d1b416dbe9ec0b630a6949f7cad8590e8a5827258edd8b9fc3d488508c4d86375ddb67ba93c45db8da92fef12853e7f27bc241dd1adebfe273c3f341add1f6301db7c548f077bc312a2f1cf6a71044c9f99dfe6a1b4500ab2b8dd120ea99681f7877a16df723c61ecd10c804276754dbe482b4e6cf1690e5caef28479f235f057ecca5b90c3e0acfa1217169ebd882625b5e1088894bdc939d3ea97cc58deb69a0a3e9ddd83a3a139ce68e8b559455dd27b2f8f51ed2e85f20e4f8e774d9354d12aa7a04cfafecc9b98c14febf81f3d7ea2ad9873b0a80487e358d7d3983bb72f138fd22212b2292df1431ecbd508c3cdd2d90acdec333ba560ff06884661d46480385a28c5f9fe24e5a7fb182e8a93866cb199760ca074c73dd3eaa18448f931f26f54e0307a186210923369d3d6efafa2c7368d5700f8e171f6ce5e65d66b75101b8adb7c71772e3dc22683b8717a73bb71c8253e2636e8f252c4c7776e6406b94b2ae158b213d4fe637b1d868072a5435d2724cfb1b04c5985ad17f05f1d72f95059ffc88715e34a68c27c7a2a3bcd13b1d1bd631d6cf1d6652082a3701171c81eef0e49a96b1dceb1b7d4f5432a72ffc021fd5271aa9ffc03e0d198e89c906aed6bb0da2dcada1f7415f72e2f093325ad9c1b4eed97c5b0c15403f60e4298042d2e9d521e4b6574644c82943fbfaa288a571a103e8c87d10fbe051830a6e060609a62e1bf4e2aecfd1b8240b5fc1c4c686f2e7fccc25802f0bf4297990e414a276424b25065f4f416fad7310d85e5b1328fda309e984f698ad352207ad6b7c67f6d213b30f3a103809e547391e1ea4a381a2eb1ad77548a175544f99114db0bfdaee14dd85a74ab83b16165e01ff4cf2729233f0f2ee7ec70559bd5e88a1bcec457c15b652b0b63b4c95d217bc470190f2f71c544694bbd952372d50885b0d07da441315e2e9841f720fd87acd7e706a44b6416657fec38d4dc6dc5a2a9aebb8f12c642306900620cceaf296bfc0f8d05c57cbb2b3208e18db5661c1e8891d4077f7082f98dbb0fc470e651f7a16b86cf86cb00ebc3c753ebceb9038295952725053f5bf2edff97c256bd299ca7e6f29f59f14ea2d72ac1395b15aa0d9b0c3b4b1ec1c56b3a09cf6e0b253ee66c84e060e354048c97a4fd9bdba11eafd93b86ce46957da1ddbc5c06f4708556713c51c5fe834d6f52fd947f2240bc617e7723c4386e44003585f27094fdee08399fdee8823c9010669c72c40abe4f0d530e5902e09e6fd790373a4dccb0a012f66086b73b8fbda64de4700221f728479badaa39f8e6d38ebbbc84ad6eed9900ad80c6881076cc1723c71a73c897f8806ef54ec1deb566732be91a43a5b5850d60bcab92e2842c86ad87240ff9f69c3801ea35d5d0b0d8af8fa89c74982029f24c8bffec521a34b71b1b7eb1f3ced8db0ccecd299128e12dda96ea7a372d42149d82b3021fe3925b89ad4e11d5d64428187a929e3cf42a62746aeb1334245114666de0336c43645c849c97846fd41ae34f0e18a35657a51e22bf45e2815d1e246ad40d3fa05f5d7164551a1432f25b5cafe51f170a2ff9389183a1de2873f2b5f2fe27389572057d2dbdae65a727622f3a914c4ebf08cfd63d6d73869fd58110f318c27c16f6d9300f4fd254ac90abaf68461e35066ec335ff120498775e802ce0b96e9903afe752aa0ecbe359251bacbd6c9e2b3cdd8d6e9159205c7cd99766701aea30b69d6ed2924bc0a8dff389882bf1ce3cce1bf388068401771e0084b77d9bec086b0b04194caa23dee7f4a9446c1b452d8d149ad532aeeb7cf590651175b292246bdda0406edb7b3051078787ba84733a30bc6146087bf4953eddb15a0bc8c59f1e929f475b1cddfab56476a51e954dd503b4db6b381a7cd675b8a5bda44424d7f9f3e1775d26b2b720d47cc2c429787ae1ea82760edb8406016daeaaf4333465d89ea57799c1a65f8c7c3111066632bd41edebb05fdcdb6e330b84e8494946c55e2225ffb4739853cf984241b76f67fdeb7491c75c641627521f79851bbd6be5f297cae9e58a7459d92dc441fcdf586f478e27848dd7e7bebf60ff407ce9b455ec10dbea1fb4d61e6ae548343898e6fda8c2a6a58817e54c74c4f96ac335c1a3fa201ccca6407308ef2ca7d9344f59c2e92820f50278d2bf03a53b0385122ef1ebca2fe76fa37dcc8112ee50629dbd544b6879d00e5a33e595da8d6d4b032ca8cdfe77ee65ac23e073dd9fcbceb8af7dce76ad677dae5478f3213a1b9371ce04309b7ccb3db21320deb0a607c52e378e4fb110b791466bee659fe1488cda9c516d0155c1bf95a8e03e8491b52e882c2b6bb1df6458f7466d5a47f1c4baa8163b8031bce60de0835ff1ecfaccee94678af040eac1ef61d5d0100334286a2eb83395b5dc18217a276a05f1fd119f30932023a4df6796db8552ee80a2bbd581921912643a9ec01e1c586a6cfe98c520aa657594ed1c4e1a0f513f738506a132eacc8a47344f7ac2342e8389ceb1e751b6e3257cb37b4210e99e7dbb7a87e91fe11c85d76787455712426fcaf2a384aab07a2082026eb27f13238d8528a0f27e18f25a243dacd8fc42e459cd43fe8d2244f37833cea5177cd2c94821d873033425af5a37ca9e560381cac077001c2f9457a983f2007416571bba86ca71914ee0c1220cbfd3976ce6a6c849541c9ca4225af7cf808901cc087d0fcfd3a3a7713e8e2d1dd803c6663477d3c8785f7a0c5b497a8ec5e18b5a0b110ac610c3cc9511194746c659bee46997c8f88eb415e20970f08b0151ab2859cd3348a1c7c6547650301f677865b527edd8edb4fa40f3e73444a3d4c3f5b018175c656d44ca75295781cb93dd5ba8126a9becda1a2a60d2ab1e3ca1de791b14ef0bd3a51e860d112ec9aea66b947260609128c9d4d8162bb22d079119c7205703d159dd1ff283fd87ca81d56d7113de023c6451f97002a867648588dafd39e8f431e972d16d26bbeaf5dd930a39d816a5a96d27fa1969410e40f3ce49cf6c6097b3918e46947609de39dc18a136dacd2cca493475c6183cea98ba08f778c6296711e45d157d25fc995e420c87df4b084455f55e78a58f1c5871fb5bb7aa0e445ac31a2cb5867cd985a218c0a9d3c0fd0cb10c7eeaa3df1b78bd3d131e7c5c392e0dbce0bdb842df3bd3f84384046fef7c77d3aabd220f787ee9a3bd11553260111ca3f8ad868987880584341f7a2b864e88f087e2c0c757e8120178ca5cd73af61e512a968c81b77bc2634d8cb3a0fede270d5479359d496834f160659b4e55ae9feb43e4886d090fa2c745120c7dc4991aabb8f82b06c240968d202c6918ea11f302e0ce51949d6e163afe92ec4380c9ad001b6e77ed8f5ef660b59605e4790b1351bfa0aa7e9404596322a0e1fbb84b1d828a5e780623a5ea46dfd16a23de876f2d0aa7e92979fe98aca15e88171e887a5fb2c11d64fafccba212f81c3c6307e34e9581af1d88b193bfd2908ef3a4cff262a015b23c63af902b5ff04cb2fd898cfbd713242bcbf23e47652f7ae25f57cbbf0c42e30fc82bfab945d9ecffb152c20d5dbb8441084ce868f1258a6ed6ad672915ba5bccfa2f535a1c575feb92fb1340b5a74bbcd4b2f7a509ab9cf91ffffab331736a7147c9d07a9250d2f3f00106cb744e37dc09de7f627401013c5ae5dffb62ff82d067038df72b44664e8e1e48aaf846de045c5845c8531ddcefa9e0195f52a66d2a40c7937116dc5cb65d5c7e208bb1d7cfd60b89eb7fbf46b5eb8643b4e1f2e96154c95a0f423d047b0c0f42cf3ae636b53733b8f9a6301c5e4f1ef79e21053ec7844e567b2357bc3d8ef28385976f642002c871e021639e78deb87c010f40f98337e14d0a82b607dd99123daad9665bf2e5e84ff78533a8e4cfcc0a0d212f5a208d76ede28a8cb82be42438e152221b527dfc342d31e07adc91ff12fd7cc964f369b6bbbb325f8e2896a4d9251938979567665a6c0024b1787f9fe97b9679d7bd6429c3ad00e543c93309e2a91b501a054704c11cbad54947b962257753fcc43567201b8571a74dc1ce52fd30e44c626e35518e90e9a78a945297984b78041144449fee75e9379dab3e224a0f5787d8bf682e9dd5702ea726027f1c803f770d841385604f440d091f1bc967b84497678c3a3f67fc6d7e64adaa8c662bcea930e13144c9a888976ddc2b145af0ba88190456b1581ec43d32cfaf3a22638be6b53512863fde468406a56c1335b18cf592860895dd1850c6a64a8c38f6b11395631c9eebe5fec283ac07fc05d7c1bb3024c318efe86a470825a8e6095b94bbc3ce145d9e153d3ed21219294b6275b5d981f8a48211de07185979006cdec41e50dfd7d793466b8f065546f7bc76161e952e99a84d5f5118e6fc6a714afa0ad0a217303929bd6ededa42076375bdc71cc0b7ba773e2054d534329fb787f6980fe019faf7a3a45064eba2cfb894784428ce497dee94cd3560ada1f8ea12a4ceedbe698738224337f4ed017283d6a0763ece856936c24089efb0a585dae36e6fb76d3b9f4cf73db34e0524dded425e76f61fd9d8af5137de45952782146c2d67c7f5ca6367f34232d822b26ede010441e5bf38f44be85658f9214acdf120d10534a922affb1dc6313c7f3125db49d6e752579d5bcc37264dcfed33a7c449ddb574e4705383fdacf9cbb32489203d756f6761e165020552e18284bdd67afb9a6db0fec2079c4bd1224f202a6863c7d616ac4aa540edb148e28cafada41ad878d4d189d1c640fae89124877b6ba1f2afdeed111b2e617344359701d4fa118fc5c5732e2d8a95b8f9d2ac9dce8481e11a9250aacebc2c3a92547f8cc11a1829bebb07fed9b16601dd6232ccf71f089f66b514c0cefa369a6dea86c24793dad4b391a385cf9029f2d6f3d15e0ab16f280340f44bb1279d6c21e86617f1cac7f2dbdfde7d11d874d438ed713d1c27860420da104d94e9ee3ca94016e11b863cef45c54cc9a2aca887e231c3bb9267768897dfda77e60167eff62a0544f334fb258258674cc919afa4d1f1cfba07e9c55f030db2d8fc7fe16850cd1ad68e52408b66a922afb8c04dc746cdcc620921c767f336a98ee194859163b06283f48d752afc712252e0cdd5ed49594ebe31c3501a493e0e99d83b2650eaac81e6e15d8532bae184ba137c05740a3ae24dba7380b5f683aa3d35fc5f9f49ac78496e7ffa66d36c7da7651ecd89c5f6f3d808ffb2595859daf19496aa219750c641eda07e5bfee6ed2cc004a1f9e8e04429d1064855ae3d19bf8e36f53ba67e4e0e3825bd79152fccb90c8d73dcfe59744eccb292fba92b5a43c3d6cb88290283573227490a363e29eb921d23d27a895f1386a7fe9b32148e258b575ff71de30d7b007a1d610644aa2d35d10aeaff2586f05487360a82c964c687e22fb0314d8d982e6149ca18f631dc77b3099b3aa7323d42a14adb1729e837425d9198be5356ddb6d511b3d0d23ee272681fd1c1c50bfebcea6da149946772162f869217c08b25e539bad882f8853425c9c0785c88cd0259f57f6018ccc0f043a7e2f4c2afc57e5913da1c9f34fc9720b5b0d501a4a580ea518884dd0a7ba55b8c8bfcc6d506b64f8c6f1c7006bbaaacd6ec26021e7fe2e4c3b5cf736671c80b276b8ddea06b68472b4d3c4f8c7e893762d1e30ec099063b7597c69bd17a40428dee25373c1811e23dd110b8cb12dbdda31cdab5e464a647a001ad795f9f33798c5c585ea08f356d8b6fbab544a23ad19fbcc8c3432931802febe24266ffd79fd9deab61a823159c7a6c215cdcd46dfa5f6856c7071429b806708ee07686fc895e0998892f31a4ac252dc2914fc67bae18c780be7b17ed6a52c8ff374d61dd3805fea13edc2a94dd3704014bcd32410511ca0b80b2e443b687e1aafaa57180c1e3f5455e4141bedc92f698a6382e35559cac7701b48a232309d24a19767bc8dafb8db5415bd80203ade87f5e36834f68098e696388e9b928c41921e6c1bc8324e78bc7f43e5becf1590d85483cd59c321c218f73a8d8e66299b7396009bf0eed0ac42626419b92e40f64ed451d5e9912305c626c7bc86dfc86618d1153a57e457f836bd35d7c1743511847ab469058336504f1cf0b4d555d6e83413f4a1a4bcf1d975c710ee80481602cdf5c643b86941fab2088e65a4311b4d1b46a8fa00fe78aa2f8bcdebd008a3d13412e0c173386d4012e83c6acc02cfa406784b889500b4e1be1569767df54294acb4385b2b7b4db127ecb0b2cc2e54d55e558e39137a362dd9a5ac0d18c4810027bd1ff1f9c79d32c71cd7f458fc8dc39d7240874630111a7f2707c1d7528409e9abd4d601b76d923f2ec9bed6048dad85a59d031711c072ed5dc3b493869d3d749daf1db61587c150633e89b21af48df45bb56656d19ed9cfc6b56babe064adc6a7d5db1abedb2115275a87f18888027572ff714d0bf3a4531dc15fa72ee1c4d7bb261fc90ac0e9b6503391f752d2332bdf1b0ab23617d2a014d5437908dc88e1c2f5e07694d30ef188b85dd66f5ff2e2d415ac602101db30f4480861da4823bb3c38008bfc5eedecdafebdecf64690b0b48e18f9f88d863f65332914a2e2ee8505df2b30d05710df8bd1757d78c5a2919ad93e39432a22e770fabbc263962f15ba93e76a73c865fb75a5aee27acf105c46de63727c6b73b403b1c70d668185698c11dc04af450b7bb49f892dfcf4c768464b28bfb24a21d6d460aeab8ed862cd437ae3c6061add0db5f80882635f20988e5c3b2ecb8890c1ab55f4be2914dfa8f428551994e0354d79823287aca16ee50bfe4b0cdd84e1bd41f65dcc5edb2db05939d742b4f5e562efb698ded6cb592814b884766e5149c602789ec188b49acc28402fca4c7e8b436bec88d57af6a7577488d506d4ba3c23afeae4eecb218043c4a3c3432f12f32ecb3e6d928c7f8642e8c7fac116ef49bd6cdf65d462b6362ad61e103f951f8d5ad3914bb2b4e089917bc7073198aa3fce1eebef2c619808bab3d8a123a11478792ef04caca93b13a77cf12982992ae8964d35ceb34a9b0df77f917d1f105cad20f94db3af3477a1bcb3bef29dca609176226240930f9fd91b909a3345485e75b316b74405dee9c2bb1ab536735a62bfb33ca588fd3decd3a80135eb243a42c569bbb033fd9d6f43f6527dd3efeebc26be96d2b35115e3cbc686aa6717111ae582845f61802f14a61e3f1f965104fb31f13de1404a9037e7db524d4ac82ff308d1ed6efc7b91e4d7a85b5d4908dce3a8482e34e3c381930f86d7e9adf4adf9dd15b1d7887cb1a1fdfe1cb8f84f45214d38cc0d966df5f7b91748d94f3d01014ac1444af635331bebe5a2d3b13ed4cb231cb7590b33b96508e61e616dfd6aff70c64250b902dcca0adfb21ff30142a56cd20664ab4c1b6c946fc10ae457011dcc565a397c51f442e3fafc5b3618c1e662266bfae2aa28577bb908cc359c697b55b4551d880ed0eb610c82993252639bdea96a944ff3e6d5a3b28507946e270d66365bb4918b1093683e7acc31a613ae117683aec50dc37c1f4fbbdbcd6292730ecff81c7fa4b85fc6140cafa4e80099a639a8bb81b6842de163fa7920ff7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
