<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9427bff5f68be78c37efdab0e32c243eed2e1fecc39bdb056bba53c5d75a3790b95db0cf4e2667325754a6ecd1e092a47dd4056256b312e1599bcaf281658bce91ffdbcba2b005d054d69e717107db42da9454b4ba850e6a601bc6a21330d7a712f6a5e519e7cf89a7caef943a79441f3b57fa8cf1b4fdf93d4c295ededd3d87e8aa938844b835a94fc7d3dd52e29045e7e44d11e4a727d8f36905b81e6c71660b35f04b88f1fa85fb5fe118e9ccb778d8f224e1354bb376e2cac6f146360578ef42ca4e7116633edfdfa76b7d62799e751e0874eec07d1a4fc75ae11795127778f81e44874bdbc4958077036ea11a2be6a90565e9df7e6dc8169efba0ad1e1a2655f16846b6461b9da6460e8e86439127689e5b96e64c4b7ba3ad196eb426be24d5537d031ee6a9625009685dd281afcfc38af995fdcea2ba88274d04d198ecf0739bf3477dc75d86182e39e06ae0b05b6484fd39abc25c52cbdd477e450c2b92b6be8e4fbbf04e7d37d9a45492df6318cfb201a931e7cc00ae96545e9a15f457a554757a242763111a3858dd4d670d5fdbe6796593bef1a605bb3d5b20b1b43ad629cfd9bf23eaa6b517cec09b677692a54fd32eb5673c7d48d667e33215497bb1a12ba4b679b393bbb55d2c9288deeef6dbe97d143668b85f07e41c45d014e10c6ccb62267475618ab778724e7ff6a5549e79bad9bb406f509b3ffe77148e8cb8b692e6d8f251d922fb941ea988b046c065a610c629b4450eb2886e30e79e4207d128f37ed6e8201405139c5b5b5b22c56a5399c5eea61ad51e4728bf22930e6ac7c9a0bc700e1e138daf56c45ad89beb59d8b8709593ad41f7466c23caa36cf6195330d614a6f679a659e7f9893c0bfda5d8fff333d8d15751e459aaccbc72d18cdf2b820f96cb41d286d1b3fe3ed29b56a63b841025b21da40aff916fbb757d6bc32042b9b61542cecc0cead5571a8e37c0f2793512b5e540b2db36f0f3004fd1a222014f81b1b4120a7822feeed2a6042a4e4256b6aa427e24fd169c602c1b5e8d9db3e9438c9efaa34c40a9a0f20d6a22e522b0ba487eb6a809455707d9e6f9e18362195932c8130586910e00d86f57670d115b3919fdddb6374ad94fb7db134028d520ecae01f733dc2a310455d496b3ed516226aa50349821d6800f64522b9df5bd319765f5ff4c07b7a6dd1d6c830918e71a48361dee310b5e59390330e35d88c8af215897801ecbdc50358ef03e424c905a56b1c0593ca1a8dc0a9f3eda196532dd1914d381ae0e184a2ac541978b4a42adc59e14d2fcfd15b553af42a07c9ec258150920e765f32bf835888ef3ac20bb6571322f262be1a31a568f3f58da67aeb49da630e8c5a8b31867e1fa23322a43fcac309cff12e74a2ce811c5cda2e6d06048868833c580fe2ac3ec4685625131b6917723c45274710a8c21474b20633c341adec2e633c26db738a12627bbcaa0723b2f7f22392d8748b2caae34faa8f106ff6dfcec85166b7754988d1438751a3800fb5104e33583bfb8ed911d1176374726172e267a00fff1d68db66422fa7567154fbc79468c4681b0eaa86be118f86e8b335c6b5e5a7ddb364b06e464d25eabbf05f15eeb332cb9959f2a537ca2d8c531bd7ea8704211e4c98bd65495eba424d9da6ccf68990f9551450cbd3537333c39beb2856557f84a2abbf6bd180b3117c7a46d3d2cb81d8d635bd3dc6c803d82cdcb4f87279d0b7169870f9e643733d6c7280547be50ff36868d853ff73dc9eb8a8bc77290d6b9d28d52ba86912a9ffee23b0647c1ac452f615ac42d6a7dfcf4227490bc6f9c81fece9fbe0ca54e504aac986533133a3d0cb0fc7bd05f299c27cac1fc0c7223e89944f486ca4d34d944f0bbd47813672c8d550e8a5be42182686368419968da927c4f80ae0e1959a26533f60534844e17b64681cdb21cbbdc57ddf263040737aeb9b4374acf2e6d1c0c5bd0eb99b455197eef72629142b8e493fc266ac08a696b24cfa3fcd2965c79cada76d015819949cd0de94dcbb81ad8c1a2af5075d5822106d05c940d71af99136c7d6c3d9488e81f4759e8ca4245c6d2df7d3ecc6eb94566e7d2ee2a04144af2908eea5e60118a420b8594d420b73d7eed6c1044335e2c0e396de5d9ce58007847958b16ce81a8028bbc1b09d0b96bd4a8b59644abc6de3b81b1bf5c001eb8fe4a1bd822963b582be41d1bcbe2cad3e3867d4de350499add15c1c84b49f07ee063da4459a5d2b4dc148346802b7a788cb1e55b52c2c2bd08a996f80c189ffe977c043dd34a0b66eca0732f8f71021174bd9ba5d8190192bf532c251e33fe4ceea0a6c8e0f3ae4506abc99e793affabe2ac275ed319333154eb1619d1cec8cb3a457e9f44591a218dceb86e87291337ca249f90dcc88d756421053fea3481cf7c91446537573924655baec4fbb635a077b80005fd51c8779ba9680b88a95eb8a0cd96126af8d80389312301f863e84fa6d651d511b7b2da860b682fcc4e48675c6630c1fefd82a33f8bfcec6e067b307789996af948ab92ebe5da8d3bde0c74c7552f69384b64bf29472e5df1964c8eee67c6c6c46f34d940e09703cc738ed465c867fde80f2ea36fd9a0ee3e2df5286e103a1250f576b31996b762ff41bea6b427851d7e83397e47f0cd57a14a29446ef9794ff384b35fa9ad368f8ee96aa8501ab0064060cb813656f939cc706db9d1288f35ecb439f538221a44ecef4b9a33cc7d185359e7aea54fb996105f777c0cd953912c47a19818f0b34b838f467de1a7ae44ed55cb0ed6f89a5450b7a66527d4e41fea153fb4c592b9f55773e0812410209014c03db4e9a8a4f82736ff62666b8b3d303ee9d3a80668ca99fa7f922f210e40f14cd97cd164a53ba6c7b487f6b10dd6942d72412b8e9be74aa127bb6275102e7ef2513e148502ef179c19979a8afa1d1a53221ae6cefce3d606fd016f7066d930dcf7532eeeaba19b68309dc15b00c7b24a671991a7c08997fe6d94cb14ac608507cd66588849c5548b480f8546ce63f9d2905050ac938a1465c76c2c2be748c22d4f92530dfc2281bd9dfbd5bd3b2be8a7d5d3813f3e25cd7b1334bc0442934a28e98302a2a4b74dbc88f9c57985809584d7a651c35ccb886018e830a52e5b05689ec74d586025da2ab79a6749290acc31973456ce61df6dc7e19914f8eb19d9b6c5fd6bd558e140c08f7e0ebf22b6384bdd97f918afdd46314b41c2b2376bdebeea8dab8972423cc243268a35428ebaab4717b66704371faff2f2f6743ca8b8cfbf157cb46bcf96d9923dc0de18c8c80da19b860d116420f5e7a5d7e28c3e305ac17e3f6f3dd6b63820f2be2ef6fdd9110c75add76c8f29b13015bd53b8c5ada2332ca796f97102d4250163a844f8e3282acf3102445ad916767c819758b85a6c1d236155ce8c10ea855164fa1adf31825ec4d2070a284663a779b437d872b914c1856dff66623a0cd6876111a19db3f25b9efaf2eeae8512ca0af46e2572644d488c6d3a6b19c4d7fe9d202703091b98160e70b9a5515e90fb80c29a2bcd334ea91c857faf2a5ec1addec11db788f8de7c11dd687cd6f0e9c67f70a608168c6f9da478d406eecf58fe177e52eb81cc0c634a75843fc2391abf64f8660e114042a80716daf190a28d5ec4132f76c5026361abfd10047e0750e90b82b15981efc43b466c1aad67bf5606a29acc522c2478e8024be55b47b88f23d4e7e82b13b8aaeb5fb7c4e08f050bf7db67f82db91281b10523060e3d485b05e9cd175ca117611ccd7899766ded16a9740e062472177dcd5303a661b35e11634f615cc3545166f034a08130599c84ebbf69fe9b5f76bc7850bb4d2ada1936621cd5a89e468d726fd0aca6070c204f57692f99cbcadff5e072c5f2775173c0351b491ef2b230226dabc40746ecc8f86a74e037c6c82c67a54e126ea3e140d57488ea5bb14ba88e2e58020685c9b05c6106d5738211b06ff6f4d68b3552c850270a4bd3fd5fedc5d67719034e39822a4b2758bf7e84236304a499ed3860f76a2fb2dcffff7c089ddad209265a4728ea671374171da0aa7847fa44d3ad53df6d3cceb03c3a89963c6755ef8996116701b55786f329158fc72a64a1521bd5aefef7c52ec10ec857ef9ed32bd3dad7a42fe0f5ba258ed01b2a7366c15b19cec1c09db241a0d4f07afe19ed1d92b661bae5c2679c74fcb240a758670ff8cd542f4a37339fd91d6f09ee51e9af900a439afd2a85473e1a038791edb316eb9aa996b686b162215dad43146685465008d01ffee86c864a528b9be9a508457260d00d04b1b8f67408150d975f07c4e5cf525a55c97be831293f651045c83631ddf114bea171488ef947969edcd72fe4ff63d72713be656a4addca598ed2a6f7a4cfbad2c9be5370fde02ad4f3c478ad1550e3ae6cf84b4b02d1abb7c85b6c0c5a79068578619e813706e8dfe98214344a4de6f4fbd893d3d5dd8bb50de2012bc7865da9d277df19ccc6a27b86a4390309ef2a073f34f8758d010753a18a3c4a3a82b7176e928f3c7190eb1da48098d719e3adeea111f885bb71bc03ed6496d5fd1d97c1f418b8f3ab87a32c5b31a52b2bc912589997a02345a7b0d7cb63ef451aef7a1170cca08ce30c5032d5415fd3211350d0c6e01c0da807d6f4e872663289efad56518e05bd78379eeff8ca2457be043b58fc238a68ac27d3566db9e1b2676dfd8494beb3787e392cdadb2a05da4e59910946df0056b69ac259f787e95a9cf9f1834849229909fff11c60acea607ae19211e129b6a023c5b8b0f586edba89be4f7a07e07e33fa126821b023f7d3449e030409be6211e254487fd58ef42c38bf706a0243dd3e839d44ddf4cc065e4ebaa44f51db19a15d55140b0459f00ceeb09cfdc48d4125d70c704d8b7b055134f67256e4981fb9fd149dc4e5bb8d7fe3675b6996ea83e1fcdd3177dd63096ce5f3ff2da4205a9effd9514b2213c959e37b98674cbf32f57ace7fa852cebc38d5e3f661929d76baf6cc5cd54319dc56339942839d7b06636448b405a9fd57556190611858ee5d7a472a95f11d7495aa3bb6ac0424f8ee54ceb0f780186d349ec451aa08b20deb2fce1ded34d5e6f7077fe14a2aafd9f409a79b32ef1a9f2e1f9e6e09d79c47b1aa97792bb4673bdbec9601c36a134d2b3fde5b972a050a4d5462d3c1d863de35254c3004a8f78707d2cb47945d7b30e539c0d1eaace583ca61939b4aa0d896a0c82002b939c7f7ed1e0378d8e4baaed139415693b4c4f0e1c4ca2e422fbe2ee23f106b35b4870a10c764658d005be6d6cf24126b5474ab4b249c89fa0cc972e58e37ec836298aefd1d343219caba0e478197cade6d1cf194b8fadac06dbebb9d124f0821a85c13134209c3a397f1f6471ff3eb39e289dc356b8bb64b97b1a2bb41610fc967820c0dc03ab9455d59a7ca596b7cff7d5a53927ff95ae386e6ab824043103d5d5842ca1778135e4d5156b5ff22e558ca45b8f27ff6310c2cc9973b0a909dfd76c39abc48fd9d17ba29765d5df373eda0a5f7e55d2875fb61f0558598e84fec58c7413fa779b915351932f134964359bf7a9447094202c7d482fc852cf6ab4ea495fa4c0f41f70c80521ef863f9a3985dad97031e6cf181d68fd0b544171130b8673eb75e07292d9af1de322791fcc80fb64e3f32c94358a65429aaea92fc785963d5db6d000c5ed4c64bb253f45841f6f466b8b748398ff062bc3190d504c61a02261a8b2126ca86517f355262b761f95f45e6ebe5eef65fb2cfae7db39f13a7ffe64a4a911b0c23685a359a7a8d81e38613f79db0e1bbdb4a07216501e31e8544d0663014eeed9c605ce8e5f251fa49ce5bc8ce0e37e6dbdca915dd984c5b03b36d2626a056be1b9d15d61e840ff0ea8c91fbf32ea76e7afa6b6be2f7b7960d581a81c41ea04d9c7715c6c0f7eb2b5116afb785e4bcc7d64961628f36308665efc22ce8b4b4ad68320b80b1d0f7a72ed61170ad881641d49b8bc94f956893e58a5b91249b7f887fca10b5b859056d1d521ed30c306200ba9f7afeb55e4a39ae939fb3ba2c90cf3f3cc4d174670f4318c0ff6f43313c506e33af6c999e4ed7f299bee7f0e070ab27a9386bba4748cdbcbccb7b61fc1d841de1588579257c1669916ce90955a68d98c7c17f78582bfbe2ff762587d3a9640bfb6d286c1af0b893494ec4a51af6a31e183d35b2c336df8c1f8076271ae8a3a8da97c86c386744f96fa414a26ed33dbdddaefbb60ad70e53c6fef1c64c54d7d852bd6660549ddecf77c7258a08398fdb2c0825c42dbef541a08b7682c222cf2481c75d4637add95b3503197f1eb3d93760042d29e8bbae7db56035465a16a3714c30884752e255429861b046605028936db8e48f2424e393f5f11f6c32c09ef88d6c4324e1503d717209a84f05e3afe73a645722353b5bc5929ce5eca659dc05d3f5a5833598cdd828d1f8cfbef9942216957d8deda533309289630c5242c7fb82e78aa52225af51ca286f15678117d3b2e57221528faad5d2d829125c47a07074bd5a9a4f4424dd23cce90fbb9c0334c23105abc106fc786894f71a62284d0df0e8cce6d913b3e8c1c95e658982de69a79b3972216b4e51260b417d89fcd0de6b0c1a4a5f9acb61fe573d898ec4ee21d40d9c66b9a143e46e9c9ef1a2e8ce22c2432dc7bb135471487c957de9a5fccc146eb416d8484acc072c68d6b9ec5ed1a438569490dbe76f2a50077eadcb0f0d67c1211f881d0750a0cdf1691041bbb6062071e47bd16bdfd1a765afca5671cb3229f8ba490d6bb4ae99d58d152d7614cac68ca53aa2800a1ebc95c478a234c0f8103769865fd5e49e8f10292812fb00693a89fc5882ee11c1237ef66c99b6805163cdc61a2826f9c752a7db141a301836ee101370dd0118676b76f0ea1dd7d656bed43c26bbcad6216d81b48dd06e4507011e2a1f874a50a4bd41cc0eb4c5506e3f5603b2634cf3ca24f7afecb311c545ebe8979655cdded4151a21cdc6eef5be2453ba769bac312064f8f6cb6c4379b5f4ed84c60c600698a22b22cf5cb790119d4be3f1254cbc1e642d2f79060f3ca884238f54d1285a8261fd0ccd1aa128798f963ebbdf773b0bcfbf33c19278906f69481dba17101ef50097acb015349322597bb3f90204ce3cd2ec5ded0e5c8104fbe7330835bc54f5070aa5819ca874605764ece1dde4111d958e3ff55b9715d9772b7989a5f7baf59dc857d52048cfea8cf4515a966973409e1d21a763d7fa586885b0be1fa346a243d844de1446179b28d7d23e75650900299346c5dfa3f441d1137b6f6e7e0de3a7d677eecd627881926bdeb9fdd3c2ae22486f444eefcd23857a384784a9d29a649b93129b2ae05598f258eabf778c5944ec98071b741255c9bafd03dbc001798134733c1160e783db19f5d7d39741aa407e6297a82a7f3ff3b37c48d3e5957e16fff73d5a9d6ba82df91fd699eaa7a5f0966328cda2f8f6f256d0ff877d80712d0b62c9e47884a4f4231addc3ceb4e0e35a1e8d0b3871dca2d65253f0698d6de465a9a04a6f8a48bf90af7ce660adf907e091fee37b04fa4facbd5a34ba9000633b29e4fd63501c315a6f9cfc614bda60a9b40fada86e5dea18908c37861019b5d8851aab51a177263e3f1e30ecdebd9e3919251e363cd642f2217442f98eee935fe33737e21ad13f07883202810ab978407f99bab0c5c42919989ef4fdb362238ebf15e1a433ff21283405139f4b51dd65eece88729c976975131df15588f216a76a26a349c8ebf1da6525111db1735de5d9d42122b620368d294723dbb8bf7d2e92973af6d1f321959489b087e85440c1fcd2a4c0ba5109cf7ac0382cdc68316265ae59cb229062f7324c0deb3865ddee777bc77b6ab6c38e7a244b0073dbfe65e7108dd9feee6cb0005f047349f26e42f4ab39c3e8f9db46b7d74d49a76151f151ef87d3a3a711a92c0292ef47d32e223e585fa4c4df47d460e0295fb30bf00df9a9243f721283d1c68b3749fd6df9ac3dfcb402283392d15c1e82a262f620fdcccb5d46fdf11237d69815b14fab4e0294b427e40fc1f3096cada206a43c553b6464b8241bdf3cd1ceb62c32983505d5903fdd56a3482dccf48527a102e4a0ac1129079445e2a65dc02b91126286aa6f44c6b4554feb0ecb892e720b708e6cb775bc77d0e4a5d9a21e3a7abe391626b53b490e2a4bac2ac38f6dc6ff3f9799a4a0f81a744c1285c1dd07ef44118b6f1199af62215f42ce091fe4e5d5cdadfbf27bd0e193d0a28d909a994577236d39551328ba682ffc0849a3de5337fc3ff6c24b733c96351c9e74dbfdc92aed29ebd2384ee656c593def31147df9a40c5ef9abde5d4277d7ef260f8671d0708a85eb0811aabbdb2c5e65cd78d41f646a64a7c22b71248c646282473fddfff6ed0b4dd62b8bd99ed60f1e45ef5697bab99843ee4eeaec18eed5a22391e43dd6181ed2f4946ce436acff2531a80f6bb3203308386196cf0c9ba9763b58769280a1cd9ac86fe5ee02f45633961a2e601046dcafed00e461680f1761c51feee3386faef7e0a843c2f2c8b1b18e52ca64ef239a96e35dd504a4dc0b8493ba12f93b390cbee61e12a1ed60bd0fbf1fe372461b7e3f20c6fff01d921d1634afa935e51a5bcb63371dcb911a83211a79feb25be9704407de2ac0019afa005fe3b5f4ab30c2b1d2d7ebc7167bc72288395371cf545905fbdb011e4acb8ead3c67c57afab337eff655f80e3b32fc7deb8c38841a950ac5eab4ab090a9692b4c52942b6e846e04e17d084cd1be50df61aa092a1e516fc3d34d120f230c610a127270a9e4493cc71c2a2a160568687f4374c7d81eca21e2f23d808357fbe9282844a662e5bc7615f99f910b578bb0d5798285ab311ab46fc90ea3a77d30c3e5c0f252eabec9199dd46f14fdcfd34129db2cf4563686714d25930dae0366c6533465a701624af6066b3e7cf2ca206fe6c022cb45f21fca21cbee4e8f8a5a0d4a8f80a3bdd76fa88528758f5825b5ab88090307531fb477246e6449c9e4ca38735d91149530e95923381174fb95798b6a84bf4d9ffd897ac40ea8d59bc15a0b02b1998efad0a295f4d7922bfb5d975ea6cd24d89dcf69d443988157db0243132c30b258a2bde0afa96a0ac46b153d43d259d06df2a0773c3cbec3d3a0798fcde575fb165679e9220796f1e16c0f6ed66a2d64ed9b3b72b93d12a3b5300874ad9943dba378632764991e2860aa3d6ffb91f94cb690fe31e16c4da5153058bf48259b61c5e6c7398bfd31dc56200cc7e7b3347953013b64a83c0a2903ce28e21904cd74ac187accf57b0d0fb83567954ac405c3158eba6c850c8eb70ef0767d6b9d95383c5ff11a1bd60491036cf85e2eb296dc8aac5a3187e365884c2ed533eb3edebaef7800258753e83384d352132d2f8c01fa834d9f172369faaa14364619d5f5ae41ae81c9cd0dd5b51439dde7d3ddbbbe3d7bbc1f51b5d28e736b032b92aec6b14c5eb6cffdef2d7759aae89c97654c5f54850c5f00f28c2e43704da13cfa21ddebbab507828600ac20e1f63dacfd90a265b6cc31dc73fc7aa902e697dd43c00149d75259d750b886becf720944bbfec83313639a24cf0fb91ab2e4ca89651b24990484812995fc62155187e5b67a2ca1eeb6bbac0ac6ab594a08a3c34e433bf79035e646717ec9732b54311ff2b63cc8ffe6a2fe919c4b4191d07a52fdc43c85bc349cfaf408aba6dd40814cefe12d7ed91eacccc4c79a716db6e5ecdf8b53459d68736c4f8459ac3ad8b1009dd4588badeeb9f82566009e3af84e0b8313b7240863159c447d3553365cc5d5c0b92092ad9ff2855838358dfd944dadc2050c1ff76e32fd9ad4b4f7a0101313472fb1512ed75f944ed511f5e4a953afaf9921b2476b650acaff110ffd3e94c6058639ff6844ddce52556a58218e823e237614221871fdb87e8e204b512d1676e88cacb4c14fbb81b70d35ed053bbe5d67e5c07a9fb04550097957ba81a757124bf220216478efbafbfeede63fe4fcd9ef08fa9eed3a9fa61c6ca332a25511c4b6dde943b86f9739fa17ca6ba221eb5f89b0e789b8a2cb3a702a16b99eb48866b3e661918ff9fc4455a5c46600d035fdf749e19e9797f03d3cfcbdaa17677165dfd30a27e85a352da9ed12dc98ab405eedfd1f8ccf358daf2d2b9e7f2df1abd57d6b7bdd1d520d5adcbea823065d295aa6d67f424dbdd871000ab3d4c66411ee99042722cfc0fb415201964b172f8b13a183b90b6f61ae4c7ea0ba80ac3edb0fbf3e77d8910dec6d5ef8b6b0f86c3397962a397d4cfa801c142801fcff2f11211e427fd2520c13da86a6992aaade15b650dd9561632ab02dfa01efcd5a046392c177b8a1a0bf66b123be242622056c0eb7682e4ce20c27f0be45caa1f2068591478515ec4863cd79dfd246214a2e4bc5dfa12614b837851f8495b1faba6320d2e9ea7075a07cd49d2fbfa1338f3491febadd1adbf18ea453c33b8a2b62349d32d1613555bb446001801d78201bb0f9769ad935b9573d929ce10593fbb0646fd44bf02228b46033cc4cfa81481c9fef9e29c8c71b7ba220f3ee7e4ba5afa7bb88d98d770ca576438482b5692a39a6a5fbcf75133d0e84a56f6fdecd6b5f64ec9e9ac2ece9798327e7fe7f63b8f324939060e9aeaa526e07e010fcd0a84bc0986d8f273dc91c05bf8be0ad92d1e1af3bd358fa70ad7bcc656435421fb5cf7523f3b2c5335dccacbf1f7a1b3e375ed03fcf8565842f1ea1d0b131a23c63bd627972f4a5d376b22e36f78d172f6d125bd21c07168655efe1788caaa28e78a257c8a33d4d25b9ea0a6eae075ca25208a91e5241ea3c62c6eae4929f2729c259e9d02404823d8be2fc3ce2427c6441084e0cabc9fd0d9d8fa0122bdd002e4733d0e7d2ce4adef6c8df2fafbbbf01aae4e2bc9972a5d2adbdea214fe828e7ccae720b0eb7d48f5d9adf18f6c2815a4a5434b9b8816d5778cc8084d0e4a44252ea820f7754535e8e0abb842f0ab49a6eb27476a14fdd34de7810e98f03acd90ae067fa05bb510728eac2618dedc19915a6abb358f1d63362a6aecf8e9865d6750aa26a25cc744753011264b8e201280d0bf4c0ece9d64f706aaf2cc1d31cb0820f945217f4ef5ddc766b8fc3df874d702549145969b687e21ab7ec8ae3ebebd128312eaf43e161b4cc794ff22f9d9896d6c1753a3671490f7fd0cd7f453bfd84939cb4b2a1aedc3ae28b338418c1b5501c6214ab130d1cd8686cf3617d8e3606222453b8d15ec1cf55fe6c25d17e81231fc73830e538128b157fb48ffb36745335179e99cd447f91a2ef5dafabc6a668f6c8ed34e51a2b248348610e2d4732e4df1e0305d4bb421c36e67be880a562710f0b2f1deaf50f14da8b43c8f182f08b22f59a68ddabd1daf8ba2fd9bb266668c9b948132c92a85b89dd7858c8c734cfc50a09abbd2408ff1a9a19b333610fc8ddb3058a118226e335142de64c356d5457f96da9e0865628fe1934c4acef01169680890734428190fc1a0e7e3cb86cb55ca472fdbb921711207cfd16373779c5056de951f89027539843e1a0add622f6c97bf314405c0f2390aeb2313231594df11b1ae40e0e905f55c85f849577307292e7b68abdad566b42804fd0f3a253e33ae859935f760578c6092e148b2403ed86d2af501ae65f51081aa6dc016dc59df95adfc8bd9b54e483af96985aa986ac2e060e900cdbd37a8492d4ae50a60e74a44363741b5bcd0a1895a3db81a0deb6e99962b0c083e0495a1716acb615d3ba369de15a2164aea1383ee67b29ea8775ca1984d80dae2f71317e4302a2eccf09f5246ca02cc8253e64dc1aa9ae7ba0506c7532ab11ea30d5473b3f92d809e750e0bfc34c2351a89f0e3690f4a73480cf42564d435ac22df4092fb7432e3614c7e48761f5113e792d66f25cf2ba2a6122b98083fe5a45e43d48d0bf1341298f6b17fe712b8ba28b306a4aace17d0afa107cccad006b50bec7d81cccd7752ed4755eca69d85e577eabf3c4a6412b18d0a93c6a22d40d74f55d6cf1c37bad9a6d74ccbf6d30215afa87b96dfa6a0a8ce08f2a2650a30abe5d99cbf533f53680fad547ddc548b8a1d1e66e117d98bcf6cdcb4a9aa1de78d8452e3ecd2318942717b441dfd7f63681351aa864a795a81f96f4fec54c6ea5bb950ea7a41cc312c2ecc60894b9f21559e35028eccb2b47872ce9663143e8122edc7b4ca08df26e8f7f08b7c4397d2f345800eb8da0b1dbd47ff75e9d1da93c564de904f17e97a4737654b551443b486136e52bbcc021c74bfb1011313dc794eb154e5a898a2aaae4906c3093b17adc37e5f134aa685c2cd699ed184d91a384d6d71b0ea3605abeaebe01c66dc93f225c1ca1a312e2564d3684167cd4faeb42a3252629c73598580db40e57b531333975280179e0fa327105c83b10ed8155ed6f330a3adfe3d9ebc9233048a919b87060eef6e1db5f591190eea75fdd498097b3d6885cee3a54a6b6c48a8a5c857164ad62c165df71af44c2fce3f205037a6b5b8f3ae32fa1323c37401e522ce7ac83211f60729bbbc1ce51c33d5e54b28ef4d610454e69b66ea8a632d6a63d36eb8f16ac00a62abef5b1cf51f9fbf50ff406fa95ede402bdda0c716117dd269c0e0b03d9342f1a09e433c0f1f7512cdc411c88ba1e889646332c973b44c83528de02a99e8b683aa2e2dfa5f634474a6d8a733df96fed30c673edffe9fd220d79f706411b8cb1e8ab5d2f85c95e3b853932e26746192652bde574c4b70d20bffb224ef03de658109e4eb49a70b0b3271c5ec9e09b788cf601bc3f959444fc7b2fbc3272778a604ff83bde4934c92c8de8ae1edb21a7b9748c15adc7f02caead06d50f381c880cb2e1a46e0a4f6c7f74da5e94474bc0e4723e4fce31cc74b2c2d48537d7745b8054146064238f05d5a0c716995585d63f9d11737c28bc7012aef7b99810924d053d8be4e7bb6bc2697f7e718641d743486d976b2d2c30e932326f3adb6704d1f2513db9d52719918767a498ddc5e115d8778e23d92c6e07a7c8d4fd9ef243dff851f59226806f731e435525348dd3a9942839b1dd9ea56cd2abf0c4e85e3d70bd05338390d0bb6ac3e5bff9568178d6722ebe8268e0607b671e821db7ae11a42a6bc8a63f2042bbe49eff58bd7527a73518c5cd329b029c512bd5f86e2aceba1925d13b513cc3a960d1d851e7064a0fb761b7d3875c8852db1a4e7b45b1d2bffaaca3328f6c1f4ddc104fb45c03580d6bba6bf9b9ada1149ebf315d5852f2beaed82e4387eed18903d8bf54d22151a805322ff94583c1dda6a951c9e7e304c06d9b34b698d5ba2ee417bbac63a3d4997023cfab89e0d90f25d251551115ac032b20e5782ad052b713691298a9e2625e4797dad04c66c723b344a3deb746429b321e566982bf9c20be4661c070b6d20cb79221dfddb8279dc905c5927e53ce6f9a449a8994c4bb99c8cb266a72be6366dc78ace2b052c60fa6269098d6c03d1c7f048d260a961022cdc81400552fc1c3829e58366314453d24647e9daf41ab6958413505a9366872120cf4e373dd36772b4eacafeef2e0ed95e44ea8010859804242df956e35cacc8b17562568375ec7a8184df10dade4323df64196716113c37cc3ddba326981efaa21cb30508f0c2ad0aa98d073545860975ebc3455f0aff1f8d260ab88b01e9b22d2810ad766dbde643c7073d12d4508c256dac5202982bde0f888b07d505853ddc71966b4f3e05bdbe8fabafe277a9cfdc4eed3a8b6a762e8db7a0caffbc18e7a37f1b18f060c47a9c9548e6c326444edd1ac1b851627178bd739d9c09812c28414f158b273b18250297034ab05ab8d247c9291ecf000de895ed080fccc4f162af6f31864c6e1121929543d59c77887e363ffb2cf9a501c6b29029c6d658b01aeb3cc63376295d1b357796bab471caee82e4968f691258b2ba2c960d007cae432193aa36646f731d10d71ba613df988048a4b81371a2f368d4648aea2a0847d185b00299b8e9a4e408399f2ccbd8b56a6769a5b08955257df425553eaf1eda63443736cd14f8e86ec28a1b9cd786b6b4d5c4df627d1d8ffa00b779d024a0071c53038839396cb3a962a5cb5a86b17e0fa49bb235dfeabdb25ec553d4d5eb940424cec884e998d83c83cf9972584532927f8ead7ebd0519c641a8e4395a4b2bd188c7b4b76dd4737fe5972480f3ef5ad092f1ca85c47e8ef93064b6f4de10538d6e323aa0e4d9b2181ec945966fbe608718a862f5a2315aa48da0c137d4ad57a6873bfdd08bc96c32a61c5baac8461ad269e2cf79cb89548279721d3d6ce8f3bf96ae742c3c674dcb40d4cf64fff9f357256ea1e5da844f82deb05c81e712bc959feca94ef6340945e454d2519cede736d892389010d9c589418df5adc80206af23750beb8b3a637f3e3582154f9273ce75da6609f6be1ba1fea1b06f18bc9df27249a5c7dd38de295e1ce26ddfe903f57287a6686e3ee3fdbca3723e304a67f5f38d1d677332d0daa9cbfafcf9a263e44cc28b6e552cc92e832cfcdc6c8addfa9d5d1264adcc974ab66fd8f3c9661317d0e9d61b932a2a5ebb25e93286a46cb4e0c8794dda9cd06c523738e86485adc66b345f3709b57508dbce4325cc57fade994d67caf4329200fb75b3e2195944605a8110da19a3c5ca5fe7b2011e6f763efd38ea319f97920dc0bc67dc7bdf5906f328e25c836b9ce54687736ed17bba48345207fa955c24aebc5c4f8aa1a86a0f4771e7747371b4059f0150764aeae5570902da0eb42370f1884724f808461cd47bf687e3885d7c12c08e2fb058510c3dae651be174ea054343b517c1bf5a434f84573ec955000628ddbd93fd57153570dc8047f92910f33aba78b0a0fa2d45fefda3dbf953fa55eebd47ec6c5029256f171b583a58ad513fcfa4a8d120e11b96b98b3c2fb646eb27186f9c3e30f913ba3b41607603b88bf97555943165aeed804f93515825c95f8583ab212964cbed3d46b18e3039d7979f2df63b33a789a18f88f74905ad7757de9478e645642f97c648a6202274541f5bc481ffd5d7022dc8a8fa3baa7bca65ca301fd2f1185a18e9aa9facf1bc39e711484d29864f76cedfac3ea283597664d9908229dfbecb4feb8e9de4572a6d0bbb7f542bc346d30b8eecda0c5964e80485b5a143053f03d81541a456f79256d544e7b226fc395319beec860bbf60c7aaa5afdab5dfa75077d487a377c8b28d236944e3f7aae132749ab0ca181ab7376eee78bed475c16fa2c177be9e22b7665e4faa44a9c5bb02a203a0281d72857c67ed62a95c950a44fa76974211ba60ec812b9fd74f0baebc56021a0af043c96dc7eadc8517b5f861bd7be7423e5a5779ea0642d89b0bbe1e83b3e932656b3244afd3197c2c668d834101bdc02ad4aebd4805a6e8378d04454c8912f3a909133f837a5006206154c9a6e0be62a8f88d5b2ba98c79fa4a367e13116f0fe225eb28ba38a6e224c17f63cd8c2c64c9564fd04d2d6e6c2e3849df1820d3113eb3b2a2f8bd045b92ba375c3919b7a0fe4aa6bd1658663e3e196081db10c794e366d2affc27d7b57ae1b7a777ba99bd23f851ca47db4f40572a564975772ccd22494a6ac2583495bf1c920afb277fd42ec07b192ebce93c7d089d6d9ffd79c4082c82186ba6a6e2eda94c16d26fa3180d3b8a869b42613991a0e983e157e0d9f95f676f4e2b634ee44a1cb32666697cb3b8c446aa79d7ba5bec641b9dd36a9a280ae1c2b7bece211e685cfb41f35c5d8f485baa824e0a55aa4c6e159eba4688f7bcd259e9cb38c5ce8b8d42328c47c7570d3e30339b697a782768dbeec5958ffaa87572ce930453ba9f0610f998586c90077ea0d8515ea0930e672a2f5fd8ddf02d7ca994788fd4ca5458ebc70028c8520d47e128687dc4452fc6071b8f561dfe68e346f81e2d0763c8ca65b05635025ef2399ab904bb0ebebe029bd2f78a2dce6cd8d525ff55326f90d5103f3d9e405ace4b3a37c3d635f30498ce280b037332dc469d6b1d15ae0100c232bcc4df20220697fbf08bba7e7d9439d4254c0729e74f8fae024fe5a6d6a34c939d45dbd9f5a2909acba13e544b5339ab8ab04684c31e68d6c86d659d5cec586a61704a1295261de13447402cdf963836fb889cb12fd6653565118591eafd94beb28022a1bb52dccd6fbb827f82ea7f643d5e0e85f9546ceb93e7449555d5263af3bc8786e981b9d6ecf1d9a8c49e2620e9b8c52ca1939fe0e26ab3842093f689382568b2b703c70f0a528cba65067d7dda1fd0e9e3976ddb2738f888cb4c31a8c55c0205c86f95c0376b822d67955296d565098ae434413f7d1231a43b09db479ebaebf4942b607c5b73a3e9bdcd81272e605ebd78d8ea8064730cd52e7d409ed682360d690cc74d01ff10a56a931a790c06b4ff9191e01285570c31e35e19e6b4add55d3868b25a32876cb14e2372614fcecc49664f6e4ae40a5db754bee1296e59d63ad1f623bb2cd9a155c532bd396f331abffb5c78b2655709dca055c26b6b2bb836e01437a3d40201537358319bad546e89aad982e3ca6bd39cd6b1110c1193a04afe78800883aab07f4cfbc4ad07415943386e436d6f3c803ac846ea8126dcf9cc93ceed92c49cc909adc80abf762e66c841ad1c01f64b66dd05d2a60a9bd7e2d53ad9216a4edfb8a06413cc4487bbfc984e09dcb08b0d1e338b9e4019a185b4e7dbfd7fba764108ffb81ab05ee48c4b6c5023915f5786819931668bb5c01bcc9e79db596c76972c7289a012336dea4c0a108f1d0331a7175d6e376ceb4477c22ef237b0832d88e798d2432663c8eaa33c8e394697c3c8bf37355ed38baa1caf29574522dcdd23eb7cefdb19db0398060d5f5703df630e7bac47fdcdf00a613a8deeb20f8ae21615313b08ac895e847b89f9847ed881f1d77a35ade089931c9cadbf2cec4befafd0b35ffbefa81278264388eca42ffa1b83239f8a679b69c193b9ea260e18411ee6b2d96f2bc2d61f75819a835119a0d0c520cdcaea3fe4d47b974fbb9675be43ed5d14ee81e8e2f0cc64bd6d2f00e436aa5edd6b709edcadc83a26d84eff683aede4a422ede99f9abe9f8d4167f6dd2a2f1bf79a922f810fd9624a6b3bf2aa24f34ca2baed758f03b595120db16b0565da0b5bfc476a6a153418c167ac337c1a288c0aa1687ab8d5fcc445fda85bb3dc28ab5cfd7126d7207ab05f4134ce0d563328e558a661bc8363dad126cf8c2e73d8890279d02d880d5139d4ba7eb2d4f76e1a724a1e871917f7c149a0e8b1af1b31f6092f099d621767c60cca81a6490854a91a1ba3e8512820beb4c84dedf9e98fcecb49edb2379ebeb3b874cee4f5f7e7f126e6388ef3b0643eebd0dbbb36bbb8fe573ac3edca130b1db529530c21b23f525c8e982a423f819d94b8afa631800ca79077f21de86dd17649d6c383e4b1531c0e07b759faa77de632c72d1907648c1b039937745860490991d037969dc434a0798f2c5c40e5714398c5a9dad8d91d68cd51c058aacdda2560cb7919c9fc52cc8c0ed800c0de43a63ca5e7197ca8f2f2770165c2366a0eeb74e761ff7ff6390d4db7e4c388f715bcce8dca398c21caed21e269e563c91fec40f4d3673331c96f09dee7a91aa68a9efeba9714c06ebef8fc4401dad8796608134edcc0d8f692a097b6a3741f0be02f5be90756dd2db95daf20c9c12d5c93180e69ba130facbb2abbe165335980f3651430d44dd3ce4de25624ff98b668e0597eeac91d1ba54a8463742c00967cdc2215e3f79685abe1ca06c8a151f67910e38020d58016d3472af413a3057cd8fda54f7956a9d4142a1a8f47fe700c97864d6ae8c6bce04d65cccc20ad560deb7b7373df8cf99ecbc904393019a80807cbf7c84df0415ddda071c4f27c1f89ba60c770a1bfd4e9a786be5639d2d0f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
