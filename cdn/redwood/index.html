<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7e2c71203ddf9329fdc374ea64caf260ada51451ac4f4f7f6a46a700e87e544a96ebac439cc575415fd16095a3336bb325c6602bd34644e7ce51e7a3a1180395a96c827d0a0c0d220416d8bb3f5441d90594799263ec7c5ef5c7fd7fbfb26b0e8c38c57bacfcb725ba4e1921e6f215fa00e444a4f831d2307eb7528486ed22a758a04e7ee41c2d43fe135a3499c3973649801b706189974fbd3b83268e1757d48ac8b7cc7d7b8f836eac8bc5380253267f8edb383804c75b3ca84b9d019c160781402732e68ee4801880b552ec945f18f141f7336b35644e327fb47366eaf75cac151c0b2eee32ef5d5cefd207302a58767d9f88ea69c7fee43b7fa2d957d2828a7c5a07db5cb47b759e04b5cddcc4c49596a0cdbc124906384217268a80c47fc0122311c618e711b5d4f5e670110f0cb468acb8c81722157cd1eb673b2d11d8eda40c568cfc8f866f58a605b52a3e30f299b2d3cc2d3b0b1e2c33092b121525171f72cfdbdb90f65a0509f0a0e4db64a01ea08d8def987ba5fc1c2f36f86c262bb5110c3eb2b4d1a36f00df13a0a424bee443a2bebbd0f5e044f6d26a8ac93c29cf95d7cd1131d3294e1f712b1946f5bc3165b9f59a835c9cf3f51d75b7ec455a91b9399d915af348edca0be085c76d4afd0d800c804c588bcc43a3ef9cac2beb67efbb41cc813d8eaaf6d088a06e384684f5062e77edfc9991908c9efc631688a947fb146ec7e9d5ba12b8f6eb05ab7aa90c80fe6a93064cd051c15182e11d293843add45196caf94ee84e3ff5808ef31cba1a9a1550d6ebcd65d51c6819a19e113fae8ce64dd4e6d9ba9c18d87485b97c916af9b1e0b619ed70768b972e0f9760cd66019c98fb51b03f884b2280b373b87591a7cd86a030a9bc256ec7c500d5b8e140ebebee59296a105478bdbc3b82de3eca65b1065c97e74b8d622d7809f4237f9cd88c9db3bfb8e7f660c69ffd865846d0362fa11e07836c8d90b3363886262c0799eaf2093bc3f41ee431acf0e752e64768fade508129fc84becd0bf13ae4ca09ace08571403792f387eebe794014089c840b7f29ed54f6a34d960b956a0df3ab8925f4c1ab4eac507e0dbdb39f135662683af94679328309a9e5a41854d7a2b5d44394413b7f2c84eee9f2fa774f0d88f5f1bb277c1b307012533791a31d6719f53ee8269aab7d18d954b4d6c611342db082f1eeae3338401583768611f893e505615953bc2ceb6bd8529215768d2d4615d2da33444a208e677e841a70aea0ab2c8da243f08168777ee2f6a890cb640d711f911becd97f18744f9896ae42662466f3d4813433f97838e6ec54aafb40257e2872e9b17bfab48cc120d3c1c99c4d48eccbd359e885e5cce452e58bc3be9333a11125bc0b10db9c2df31f2b9dec0cd9ddb998962b4e10ce766aa05ec43caa28fd04f1166fc38cd9d43d7699132ca3ba8e6c2f5765820d88a56563a226a832b17621776d4f10b22c194e295a6ac06c41b8f8956033e4d60ce5219acf6bd52314e3fa5696af3eae0320ef91dd28327bedf5fae4b7a614505f26068123dc46a43a3f10b3153dddb4219c230cce22d84820320c2bd4d642d73f0603995ff5330e815d02d2c3f163700b51eca6d7e0fc99a76b20a357f1e9c12c2903d688eb785b507f5a428f44bcdbb5ad5fa2346a9c471f07b935f1f98b0e9bfc3760160ce189da09fabf0b81162bebdce93094b5191a170014529ae0507741388e9a8eb86a4da2c4c918d5869ad417d276767202b7deae6f0ff7dd672fa85d10fa067ee795792eb311dea2e53f74f5a7118378096255e5172dc8bbb93df02b4fafb361391572191494c171bcc235c986c82876742d2d063e4266a4e6064a67409d6465b7bea2da858716de102ae2336e40e329d09fa4b7e84650754e11edcee22829c21b0bc235e9dc83884d11b77d9657ddeec4731e143c94d33d2c942ca26fea40b97fe2eecc417ad23b29052b59f038f2f8722fd98133f56eda3320a4a6b616331864f4b7ad6dc366ddb5415e23f124edfa5f81fbf76b3f30f5bdb40faadf92d7942abb8f6b83481ff4f2548c748642facb588bb4ada552fe4fe024847f76f87e9baaa1a06742bc01248863d5855a7536e6729e7ba4530d7293fcb9c4daa6740728bb8e2ff82155a12ddd0979788e2905e2e969ca8a91c30dbc939955c49c7ed33dc9be7c1c781d39be6601f20e596828c93baffadfee07b21b8b777cc25d29c0be10dee5ed32c01bc4120819c0ec16be40f5ee46b72d7984d2b73027dec8927165fdfbb4e5634d3a835b84285b90cb324aa84a01a2b4c7c04eba4d4843b875bc32d483429debccdb3d16ab891b270432358abb70aa345fd90d05d4d5694a70ae6e49e9c65c30d109465bfbdf3b7be50d9bb484ca735adc4ebd561cded15c279a4b0a79dcbec428c9112bdde08d060d8a84b99ad66f92bf0d22514f9a87b93791293eb14d3859a08cf2ed864d4a0cc0647d572b8bad46f4971cc8bea9c7a4efd07c7ccea8aa649caa868e1a98eef57925d601c1c1e58a6aa6814a77bdab4a7485f30607e4438ce16e1f217adb52bad90a8b0d09b72f6b32a04453571624c3d672c8d42dbb89227b33d26a1f80624177b874d799afcb3317fbc911e0a970568347352dcc2cf0c78c382370ad84a7780a7248cd16a2249735806665e97b4741db97ddf5e85b561d8d4e2b3eea227dc611f84bb37d7f48cb1f8775582aca68de4e8bd23175d33d7adb84dfb7cf95fd2f7df4d4819b474a5f7fefc122fabbbfbf307f8b110d1f041e6802b79af288dcb54e3679b08d03b82a6dc96f55a694b4d87c95f0e139f37bd1e668f2eace9d0aba40ab1c72fc419c48515cf6c9b7b0c82b7d6fa18a7a028907f5e09e7628d5a8770f6093667b5c89ba8cefa845101198172e64c06be8c45a75f8b89a806ec7510e7794c205cb7ef9604996920c400ef58b586ea57a3de9a73b78ea95788d77511e5f61fee5539d66cdff1a8cf161cbc2dcc44da75dcf8d6e781a38b7fa415374950cab29b16c9d2499cc35f9ea752a86636cd3abc8fc1999cef1e190f34d417f3b01571fc9464683294eba1393bf72fb729d195b65e6f56b58dc1853f4fdc588a78a319659b7e42f8abc1c39bb23584d1c25ff42f8f012e4ff5686162b99e316a90e357368bc76044ea4de31998e67087e123a61d7c72be3310f4cbfe95ec90771d18bc01ec7809138bd9a55a214cb77617efa02d197219bdd9005ccd79da0a3872a04a17c64c4726f3c37e84b6c86be3fd419678229bab8107b2eb1ba3d3ca4dd81c0b3c9d9fdcb2c2d5046342e347321401360e9a1bc1e29df5cc4e448e2d8e6627e1063fed140b9e8c3565fbbfac1131f44677d1832f81966379e2011bbbe1ab469a888a95418e0f937773d5a21c2a3e2b5cbf0f650b2844dbd4157e434db27181355fd919e7ad2318439203613dc3b07f1e315b8b3088249e049d2a33e0d1d53833b58087af554ebcc44f6d155482221ad320b46162d31e7348a0981b8027fb81048da86c0fad0e75127aafe00602cf9eba9b5f41d61da3ed4a9f7bb3ac09a3fa7d486153f6092a93836475558f80b2b43a7a45b6f55736301961bad8f731904275a7cd6f3f29ad75f997103f28922febe191f00652c23cfed9836565493526251e65e916c0ec3e728685bbfa600fe0d45f7a0a4b20cbde23205fe6cd79398e0523819f5aa92fc450952644df09141aaea49fd0071c0c2c993262eebbc65bad72c47f36590ea98416c301f1021f46bce2dc0a4fce4d7d78472b726a6435589b37f474844d67edbdf69a54555347df9fefde7f1914cf3d61215deba77e23942f4716d012625da1522004fc125a3f81329bf03455920de2508e3eac8ca69384a2c4f3ff61110597ca234125c7e1ed621941cd9fff10b4354eb2ee026b83bbdc71f45088430a8d0995244d6ea7319e33c68733b7b240cc34c6d75a6d297151c91c843e68206cdb7906539ed982613c09f9c545fb8c6cea98911d533f4c3a1c73ec18fa027e792a1cdf1e5fc0dda8b8b5b2a378c9d4ab374d95629688dcf5ed4e8a319db4d78060427102164ee76e0070ec11e8310cbf2c8a3535c53685d5e49da001281e1c6f49dcb390950339e6752e506ced601e05a3ca326a22097a709cb8c8bbb1b4f9003fa9f58ba7ac67eb081ceb10e8c268a686373f6871b1f9de6c5f1111eae0fb951e642548a8d538cb5220a6101a6aa25a3eb75be42520f5166181f8c2614acc13a804f88d08137e373b97e76274efef54cd47d914809cf1b1b05a02b46d9194f5d30c523edb315fe3975d9017d8d9f4c5ffdab590a2f9c6c940aa36e45d586ab6af12d7a0873b1a283a4560a294e81b6fcfc0fe29b21ed22bb51a54044bdc375700e204560270a4567a59826c56cd17ab7a85424ac04a80faca95c6ae7a9584d12794cf6dd465124ca9a48ff978ad7d05b95db981ed520d16c867fc77f3c83f59a5264463078fc496f85987ccc9892c6da4bcdfe71e8d6243b1958b098708b7135fe864e76ba5034c081cece50c4a12f9c4b8f0b2ddd0485136b23ca67ea272b12ec9a21b362a1ec918cdd493e73337f7eb2f3de97f4e884e2f5aa0a72d4b4922cb1757083ce649a5654a246417479ff39f7dc8f8397af88aa51bbc1642eeb3021a41bd4ceb0c8d1195a90472aacc0d18f3f604a9db2ceaa0bad88e7dcb08584c40d6809554df94ca66ecd31a7b1d216373dadb4af5296f104d53b457448dcf05001b90ccaf2729413cc868d7a62f9bd48ce8550b4570a85758695acd97d3524a52ad97ef8a36887365b3bcaee39941708377c42962e6777a29763bffbadda4389c3f0bfae981c99f182b23b42ce0d3bb7bef1d8a581e1de74b260c49dc97a513f8a9c22032556a2b559fd1d34ea45d69d9168cf46f885ba36ee485a31ddf709e60baa677ab9627dd4d2130ec46f3f7ceeab1ee0b9e1c77c0e95d18d82a2284c3dde9e7cee3571aab8f29b2909bebab4022ab4fe730e57ccfa031c91d96d2dbac4fd52c63dba78dd8f9f557bd633109ea98f6e219073036fedc751818096d5c3925b45b27184ed62809165090bfd00f4e9a498d43873aef8f7c18b9128221021670dbcc75997326a674eff72a146e4d12ee0aa311ceeb265a3d8637062796e0a65d1c06cf01178e23d54b3c4dd5b48d8f85fa26a3ddba85fdbdc630d1919c2a3372af3700704104056555a108a43598ff7b5ae928126a18ebf14a48c87a03816318e2fc5edd862fd77f09db49368abe28ecd6002d406574a73083f041b106a69ea29c28c7d7ac2cb02337fb537ba614d82457d2a38f0659e8f83e1e8127b7fb84e40ad3934f952ee2091e4638737f8aceb7c08b127dd1bea8b4156aa21306819f86b856f1b07dc10cf6971d832acdc91c7d7e6d1d720d72cf58987be40d45987caea7f5151bc039bd6c64119b46665d8ee4a2211cb3b98c9ba050bb95d0203ad22f0009dde797ea0a4a71eba514249e8284f7995eea84ead5a7a8de01eed9ff1aeb105d9afa2deea57d0ec06e4ea592afd28a9525a7c83aa858b79583581acbb3b5cdb7cd3f0446d57b107b6542e2a908dcc6537af061553efb0d4fa5d443980f24062c0082f7cda772d54ed95b68ab9a3c2f6e4493310020edc4cd4bfe6963902cf5bea9612ba99b445df8af30baf43877ed3221ef170e1da43aa80e3d45c493028343bb2c586b353cf78bc4e104728b50610dcb1d4e0d5166f6d8bc8fd5435e01bfa4e0fec811bfb3aa236cf073e8d6d50deeae2f367be7dfda13a827292a891cfa20769cab97e5c4a739d08a6cadcf63d320ebf2c186689fe4575695295b682f409ec1dd54835f069adf4a9f23e5c51234098937f5dd78c9ca5121a35fe2d68ccdb84c9c55580d2e4f455287dca72475c40d4aa524d714e6498ad4791dadc776cf333a5d17b2b0264049bac235d5bcbaeee44dceb9f01b3c6489f0cd42f6a76b8203cb5170bac1d2844781bb026c4a308deb34a238ee4f5d48d3f0bdbd369d0f94a91a413ea95643070eaf8cf9160d66141d6add6a872ec7e19f102507737ac94c97b1ae6327634c8b890c59de201c70c3da511904cfef1e223a15fc77b2f543a251452c0b624f4e14ec1070061d1acf6bb534e0dc02dc0f2f94eb414974e0995e2a6641e515f8f6ab00b39bebd8690c844dfa6090c6fe871d803255c4c423f79fed5593f140ee907383c97d71c46c2f8ba8bde97a20064bfecb332dfe310b2c57657aab5df29980461dde82d35c2786c21d36170e13b82cfa5c0a695783a174005e7e268bf04a98aca51b29f6b868ff19ceca842bec89d4ec46517c732f627abd24ec5407a67223d4d164c88161298910f3da48bfcfe4907c07187219e9d28bfcefefa1d114f291eefd4674a19152bec8e0683827c076de79abee865b39c294796f80dfa863a63620c81d34168d41f6146a3c60b95cbac4b2b8a1cee5031560446a34aa002da0b98081c4a914cc19a3b0e0a82cfb5b8512677d6089992ff6cead8b9558c11e291a19e20218f3ec58ee44b9d7e0b15bafa509ed746b857501983c37943a3338d1f833e2097a723d66efec2e5e9b514699e8ab49af4a360de44f3ae5d4e2e4307e929d7035b2a72899d5ff7a73a406982fee7646c3d484489438583a6dbd88eb5edb259f8a1feadb2adbe50f322fc1d1c449d8165cab5e55c621750115a9663155ff2493351252322d136f6f8dbd8b1d1e6ff9d2043c028776c4587cec199b83bcc2fc17373f7b64074ac9b7d6ccc8dd50530a1634f01447c5d230e53717659416efc5f24f80ff268d8a3ea9744dbbb8ff6b3ad1dc4a7c8d4a522740324ab4798ca601bf1ee544bdf98213ed1382d67feebf37df7a9f9a6be27d8ed3a75d97c01dcb795318f945fdfd7d6e6844a10bbf98f1f1c27342fe3efa1c2eb2049e2805f7aba26be56bf75c899bb7b5f66ad9fb571d69db6da799b358d5772ee4bfdb349df6bab2f5efcefe0e01ee2c6e1ec5e0b82b44915c1fb1b1416370ff9137e7f60b176c2ab08913d58fbc4d90dc6dfa525d700ac3517b6ff2866cff7063d6ac8cba78a5b860f333dae964f4410453a034f6122fc9874a34d578a9b5ba6caef398dd06df167914093c09a9f083b98270d203f4e2d837d421fb2e30e76f7df5e0cc3a6ce85e6d652e31185fb70bad16252ad9383b1b73370cd1b3eb49e9ef264976b76ebe89a9baebea317770b191016f5800724845574fa1d07dc922cf81d485c09619e1b581eb0cfb6dd75e4f1e5122015e59f116ce661979658d55dd7c91636ca1cdd5bef219b29373b5cc2a6a140ecf15f3dba579dd6838d129c3aeaf211cf017852415a5df3ee59d6586a690e2a2e7d3b835e55880d6d5e912a73b158ff264ca621441b84662061d05209133440081ff10764652791aa4064be42b89e424ad6569c211d1254011f2a4869d4541351114707ec1a8ae389c83a46435738df7cd86a65fb35e5436e24d797d9ddf1966d532bccb1f66be1794bc1ec9e00d94ac716ee8dc0ada35579165dfda0e4f08a24e8af4ff30406a75a9abadc82d4f5cf65bf774dcedd418338eda683743e2916777ba96a42dfbd68afd6bdb600d5d34b651324e0d04595ef1bcf027bc952be2cb03f01808d1ed3aba5ae78f0b908fb25df28d4bbd3f1357819babbe7e9a95ce4532be3bc2bf94d19fea863d9ed81e24ddf88aa005725415f62311a665e26bc13c6445a9e5e7cd11a2059182d03d8a7a4f9ae3c1d9e65a26921ce9dcd443c8aed9740c81f5d1520a61bfa58b4fdf3c1b050776bf2a903a32b0d872f657a231f68842f290d27b30ab118c4baa493267fbeb52bccf702626d19e584b026dafd6dbcb607be698354095a392a7cdc676f0649836fc139d75aef0e9b8304ec39bb24038b41f550160a8b9db053019f531c60d95a36054b88742d593360e2143b88b8144a221c44cea7a8650048f8402be30237794e13d55efce28b9b75636cd50d9d55114a9ee523bed92a95eb59c7706c82d3b123a45a060cb2a82a04ab9c62b1b7b1016504ad35de2b5bd6952cdf446ba607bef20244ff389927b183ba4e70af23c968edc2a5bbc0954d14a186099d0bfae5ec9961ef268cc47022952ec08f1a42249e93314add620b098c2b00cb38a8686d5547784d55c01ad918258494e05877599365d089e951f1a4f2e229b1e2673c2ecfc8d0855bde2c6087b788ecc8814df95a942fa7688439a947036ae5109a2eaad10a52098266b4bf06b2d2df5c08c7fb8f749bb01f70157ff2001f4a042f5aaf0150418bb4ca5e446d3ae92b495363e19d3bf06eff05961da451dd030c92a4a59c858bc38f06b7ddaac0f2ee038f713118922787cfe3cfcadf1cc65bd73e6af707b39de07462557ed314a172c1a8868b514416d2d70313aa2815eee4c7fcb25c77085c472bd70246dbf0c9ba2e90c58c4e01e2a38d0fd12221d70cca334d9d30fbcacebf75ea5d00e15447f0410997bfef826bfdbb0208a1bd147c6de50e81cf60844f23eae3107c3db23651c28e2f6840fd87b9adb1c90dadf37037a037f7d704578ebd9e6d503fdf726d5d4833ba0e7eee0aae3ac8309121126a98b6fef41cde1247a1b24e6760b836bebe1e6ba4ecc54ee4ea90936339253071ddf2df02823bdd32c7993117435494d567c48da02eb56c05452869ff0a9e132f2c0c9655e36f7b71c3ee77bf34a58191f4647944cb45fb13014d4aeb1cf7a74eb999b6f9d88a3daf2ec894bbe54e80c47009fee5edfb63cb5169ae2db725365abb4620aa7e1c49c652975d9d62714b7a45a470e34aaa30e143f7ea525ae50099fe61f07d1011b540b64646f5298785e90a5bab33024877cc3364fbc1dd709d635a1f3f1098b4f715288182d7831c07433477beac011554cc7321f66b47c25807d816256a54da8a297029033cbc5494b23f1f38ed04f8c6f7dbaa8c1728ce353d2084144ad9b9cfd4e82e04108cd2ac5c84f6dbe35394acfd3bd2932c741b217e44f352c4228e00dd7eb276bd49ae7e80e500758429275045bc7302b0a1abd744bd6d04d482a3853c2a6110233eb6178c48b4e6b4f5635fc565b06ff74cd214fe3a36a38bf69711ed5440bac702836a11d4fad168f5413a8847d04098e125c8d398c532eefa21ca8578bc034fb93f63e83c91120ca44a3f21c92937c8dbb0ca33e21f98b24366aa85a8fddc42e54fff4df8845ab76170e046ada0006cead0c2c17b0de9dd31daafc7abaaa33dc925cd3e0524f5099d2c9831316b870e3834cd36114c377551aecb20f2c64f6b01751194861168e0d97379412fe48032b4e11c1e21ee3af3d06e1159e8c8c3c117f45a7bdc16cf39f3ce341abfb022699418c2e8b2a5af779fe2535b6c1edf76bc343c4634940093b3a4e24492e3eb011e6835da567dc2fe9d057e6b1cfc18ca7fb57fefb563cc8ba3d1d627eaae647c9f924df771378e892c846188d81dc9670c4377e7c7e2e5c814674cf65baa586671098550b3900bcde35d44bc5cb916f92ce88f2753b10b2d2d8c29f5dbed24a4b1fc840405311a7c5ef23c1529691e8eb286acc967e95e33f52d8977f812703cefc3193c3b68024dd1ab3170d1fff7ad940c29f33e492a6320bec99339e5b01b2c33ea9f8d001d07f49aa1eee21adce8e2fe230f2b48e43bc825c82c7730a7369e98429452c9f616a95e3754bbebbb83f635b8f54f827a75a6433549135132e009a6e166b5e789201e94425b83776588c64bcef397fc009351b5b6b38054682c76b36d3a728e7147bad02599737bbf54a087b85f7ad48f3f58aa212504a0c0323e5e39ce79364a8d4756b1538cc64cfb34b3e5868094ffd443f32a0d40e37888df8ef7fe7091f5a96a9b33e70efdd5e51400c7cd4512868e3df7ec57af6d1a8e56aed24cc12ead63c76c13f4df803f0521d2116ec3d6a26c713dc9f1c61149d7b5dc0d1cab2eaa88c41ee9b9797f044a52db80c410efd021274d65a61aebbe3de9e4dece94c44c349545d2a6ec37dfa2534fd93f27c5a8c87ec8b1c587371bb204030b10fc4988dc1ee6cba37973519b208726591d18dbba9023aee895b0e72be4f9cd1750441e49eef8494504b8ca19d6a12f1688886f7b5d18c7c99d0a7920a8d47bf40528525f320171a451aa47aa16bba577a2e5e81d8174daa9038649e52d6f6e7010a846a39b269be1e4c313d61aa9a529261edd51dbf556798fd91bd7635f47c8715686a2bd6285f35946acb68e9d888b66eb86fbc71a207812ff7aa249f9bbc168ccc687dbbfaa3cb1c8a5edd86766e8bc4427ae5a7f48165978e9ed4d00a548c3ed299b9cacd0ef1eb824164dfdbbeddc6cfc5020d48765313d1ef02013c3fa9f4f37ee8d8edefb3cfe0ad794ed4320955303f897fa599b564880d511925f62ee106432040748e947bb2cd26b9ee48183ad312d5667f50f4e1bf3e22824bd4a4b606f79b94ebabc62b88681152bef9b4e21e78ed6d525f025d6616efa05d0c9c48c84e1c2bd84086762f121aabf26ee3f88a9b85f53dbb0ed306ea19f97b9e365179cfb698904b72a17113843802f73030f1f29f23b7c722c925e1f93051ff0842754e7f84ca83fbdb940987db0311a92ad05b9fdb90c70ecc7dab5f58c60487bef4a6c9fc9c1a3f3e4d4ed18df8356dcdc00454fe41a2adb82f64be221b3aded58c01dcc33ba9e5616ab573ea69300efafc43ea07e965f3f2c0187bc290b2adbf9617372119d28086c5c7d5efad706a78db0c351b852ce0252c878b785d329ecc640d8c7999ec0e18b5fa9fe4cab79bdada1d44fc9b88fbc5ce5ddb9937c85c78a285a88845e1b085d443d89363321b02eb461c72baa55456e719b639a2cbe338123e38c69abdd5ff07151e24eb8f7aa83bb39c2e44ef47d4a764fb014ece3f9f0f91f597821fcf9afdb8f62ecf81e6c3d0f6b1e443278d43a209f28c506a8e2e5c63a0ed3de952336c12669ff64f2aa18a1e1efb4b2a243dee6ee6bfa4eb252bea66742580c6b92fe06f575ef469817b839334ae392784edd695c0cea404982531073a9d970422c11d1297e868fb74d4ae59bdef6e0ddeada17d10fb9d4bccc18306427b5231d39435c68ba27e108ae286e2c9c64cd3adbe1a10bcd4eb7c3173b4701d5d63fcaaaefae5bf10f64d5578f320f10327141aa865a779d7b7da6891f92411816279ebe993b5c28d43a7fd64d8c47c42bc4fe2314c8df98cc416bcd05756249565dd31e67afa066391d01c0749f7d5f6d87acba7e9c0b715aa9b111d3321d4ff26b01940fc4d7365847f1c97a30c03be3e9bc0cace2d9f478c3a2e73ac6f2a3c86e9f57bbd69ef40ce2018cc26e47a10e99ba243a9397fbf4e348595cc5af9efd97bb419eeaf6e7d32b52c05ed092b87b2ebf2d02b9579f2298a6e4775674f28636098d0189aba903fba09c9dcec47ce07c21998f0b8f4efe567d4d11de2f390ab4a7a0ad020a3095020344b3e835d81fe9516e7ef10d1b38c82e68c972b957b5355489df6d672055f9d25e6a5c3ea7ace6aa967762da369abf3b46184427e736b6521f9dadc52423ea623b006bd0d00670f6af1493b90428c69006392a6b1fdb01b846e5cc4fdb54256506d291b104cc0dea25a3acf078de3b0dee809f5d2184fe92cb34e4096de2bd1c66d05a7ddf3fb0cf376f742bc57a4b79c0261290654f5b0be3c3453e79f85183e40e0cecc1e1211ed2ad82b07f55f43be4403fcf04b1e339f8ca807dcaf099a7aab09d8ec9ffb992824e1828ce79afdff8d1bee1771e64c77613ec14852edfa409df2b72892a20e95487b024909cd6c9c2733d83c7af941cc692628fcbcd04514ae03c33682542e8d0e07e5a80e03954d93ea1068de0d035a3246523351793a4af79f79c2cb405c6b33eaa883ca13fbc0b83e073d0d501b10ab2726c98674982ef4eaf9d536aeccfd4eb9cf7f284f0d4a0451c152d7a372276902e2bb0220c451e84dda001ef6e04565bdee4a5af2ce26bfdf45e069e87de16325f389c3fef8d0b64bbbdd0f27616ea07b926ce2076a9c5d689431b0cd8561824a178d3823829bb58b2c9df04037d55841bb71ef54958083e8a7b93de0d8b5a04b3f9058ad01480d9a5a0c60dde8e9e260dc806cf3d00b36f63ce40a0961ca76b90ecff57cd57d0073508709cf4c16454d01360d0a45967b16e15cc0a9b749258a1172c0d57ba5c76a22484f00700db203b1e1fd2d397db2aa4bbdae9953662fa3a88c8f40a18b4629953cf93c6a52756b3f0e3b2f45192b475a4f4048846e2f898d4e30a76916284f447436074d0c446a1f9203364df89f8a6c213bc0bfdc3bb923e0813eb2d864397aee93e69191d676612b2ac245c2714d5ba44c556c65ecd931789c797ea4e80803e87bffbe51f0998c92d31de40f8594e281bdfe5aab39e9f66a4ad3c71a9284b1fd80eeb18f8d6692bafe7cf4f6dd7ef947f045515ca9d3465cf04a81c7b6167b2391c8e190ae4a478c782b71430407c19e890e0e808fdf7dc6e1d1fa552b8bb3bcff07b789ec3b752685c5989dddcb02486f877c78cd07ae6d893aebd3dbe52f48847d5da5c6578475e906a3dfe6b877468fe2553419fd281b24f77ca01123f0720f41f5931d635324c0126dfb7754745baa8172dbf63a7b589dc4cdbe3ccab4a5ec0267f41ec453acf03c27d70ba1d8b75ccb0a4b392ff398389a13c68984954c4561252e22bf85d4004400932ee947e286e546defb11e8ff1e1f18bb384a4b868e48ffd3beaec6d1d251caf535359dc8aff0885cdf17c55c5d142a13ea7c9043539496da2bfd64157c9a49f6e7afb6fe9faa1934a97d93781af2be90dcc7f7861e21f4d09727468706ffdace53b891a40d6103bf0a3bc4694e457b6afc5730cbb3cc3ee102015d67bea2aee6d721d545765d561d2a1a63aee3912eab14f06b6b5fd0db26d04678c9dc5c22089211967f4fe724680293449640d3e6b429f5bcb669d6382e5cd458072067458d5a87a8b64199b0034e8226aa230954a185a1626bea12175722322b12f46f1546410ba021ebd560934831fe68813689f7aeeda443362042511a296b32524802ba4d92a81bbcdaedacc220e01201687375d4feee0a9ad2e54faf4eff3eca2dcdb14083158a641c4c4da0be2ff7d06e25f20dc886585ffb2603fb0e250f66d86bac74ef94301464258358c93317860db7ccc13a30808a82679e8819049ebf0b71f7d9669f5ad0c271f23630efc4d7cf9fca39f56513120bb346c9ec0fd27ed5a4e5439fbab606417a72e57e15d64e9ec1771d5c07e8e8c48e064484c50ca56f171aaf9adc51cfa411cfeb6337b0d3b0716f28e1e456d6395248298883a84387fcf923ab37f5748c64eebb8ffc432ee43e9aa27f710101e8db5e3e35b1e54c71515d069ae40c2fdbebdcd9050c3403f79edc164f183aabbfe51b5c1a0777c29cf37ceefe118eac0f0165a3c4901447bf117cb841e1e29afd781e432ed58a7373ee30bef878f718d5309e2c33ecafa9ed6473d55430c631ff005d8a3eee5854bad762db850c534adbc2d558e3637a5b6a65fe7436f6b038832d9acbc69767827db9576f0f8ca9ab4b3a399b73ea84217ca780436803f49e56bef02b5e6a067eeefacafecc765ea1912a61529781b48296be2c9c17c944ebbad20d3b00899f44709b544393d613bd2bbf27768a6bdb767e29ab111f879f198e6fc5dfc8f78b37aaad8b877f1b5aa967153f69a0fa9116c258ec565c32094742a8ff1f3fd775f41d2d325cba955138b29aa38f8995c0666ae6058847e96160021bbc85d17faae1e0ca94a992a16e603751ef467355274230b2b1d6ba4a83266509d19fc31e20d177e26e4f64bf31d88917cdd8754b3fcd2aa84657f2d566637003c0b5ce6faba2a1808aea6929bf68f55650f94bc2f2a0de561a37f29e9a356e137db39195ff556ac1f53db634fad7191da81573ed1c772472ed34bd11abbc9fa1919eed192c343f39d14fadd4b6b8cc05ef9797a6a56923754d374c7f489ee8a06abffb7fd0948dc89ada0c13a0ac81dc67e118455470e05b4a7afb5e4b6defe659c22655b5febe3c8b7d2fd6eac3de1e13031161c18a653c0060e399fa9f74e0cee001628a63b4d2dded8004213be710069abb2513cc1975f79f0cfb15bfe3ff562fa4576a005b87da93faf56e3167e2fb8b585aa79ad7912d44635eccf0fec84f5837c5f0897a8cd8ab7aae668b84c417e8c55f88e29df15f8f4c76f7659acc8a41811cd58d7373c1acd6c318e14b3df7f87cfe898b3c53fd6763456659e41f33d002039f3f3cc0e4c6b53d8f65e624edc05ae7af4a8e55e30973f251b26d9a36302a4725a644b318af080284ff7d1a5987ce888290285b3937222a489648b197e5001845b9d2cc29e287cea21b62f8f3ccad70d558819c6a510a2c1edb2606d2b939f8021b8585e16ee7dd26267472221e38a77577bd528d7741c72cf2767bc3d7a8efb15b7b782b6e5375ddef1f61e7ce5a635baf93b4c21eb2ef267342b07d7b99758e296ebf74a3399c21fc1bf7d6d4aa79567341db2a118a559a496f4b43d842d8f4d0c319b0948da45086c4c49d7482b74208449c7c43588766f2cc02c3af276658321a5f0ac63cb95f76f513b6943cbf3f7c454584874d9a5b0b8456f9c73ef725161fdcb678ff4232247819ab70395cee94b2c7df7e67c70c5395785195cdbab143470b2935019cf17c6369bb57e4d8c6f8706db678440716ab45cf7e56d077a53e72580ce722cc1592962e6fabd6656a6be621c324c146a3b3566fcc29053f6afaaf33b36d017e0dc63c044b1db747e578098718c31b9245c276feccd82696672b09b95d25be59adb3768220d99aefb1f0832d59968e9dd09664bc4878408a0c48b9d82b645692fc8bbe7dde86a3ca8a3d77473e0716f3c8b1d487aa4aa5d43dfefff3d553f2aa8e54deb732e6e68c08e05f17e44daf2c5c3e123ddea488e3fc661b4162065125d7440bc29c79b09dbb4d3f42a1f7ca7e694ff038f30ae91bdec265bfe7f74e7f22947c28421346d5a8f256f6f03f130eb5a43542260443df46aa12f1c64f79a6f9a806cccf57d5805f2f79f22e7e875e564d9ecca127ff92b27d3f3353e2625fbfd75a23f2875cfa6fafb869b79d5fb5a3a6bcc88773bf2bc63eed4c5a52ab2a2d846b71d779e1bb47d93fa499bb63c861b83fe84af3f9a6ab05dd77a90033723aef6b2fdd0f3249b95f7cc7e5cdd695d5d2984930569353b8fe6b3b0a4a2517d796c657c1407f0e899a2e2cc4e9481b047d6d88a4df010f12b94678c9a25d3cb3b84bb10b5020eae04aa87b760c90766494f59058b96797f18dcb9e89e1501fce9e75bfafec8e50ad33da3ca94c6a09fa7f55f35ac889374baf5a639111472a5282a04f3b8e00215cc62efb4f40322e78899d5ee38d63a5291a6b4da6447356161b6282abda3a68fab9a7705a4c7903ca5307e9fc17f20b5b3690c72b21613ae97174c38bb75ba1238fde6ce4e1a03df699fc76288db7d31fa376bbdc3198bd378179ac4d4ee8e041df061fff32d33a905102ad8abb6b813597c862eec84907861961b68c657c49dc429cf7a6a3678b239a2911306dd2db1d43aba2e7ca710bb53a4c5f0046a8704821053ba1ebe47c1f9d0c7363110aed3b52fbe509505a164e2109b0a0838d8c77291ccb8669484091f7bb207ce461a279079ed7c605008e65339a0290663dad59d612c0cc3dc21226574aab134acbb73f12917fdfac25c96cfddbebb1039979631d8666d452dba755c47551a1343deae63bec028fc02b7e7c271c53d999aa6da1b06531ab9c5ea52caf0878fc3f0805cca69c2a970dde6a6e7d28f66d31e34089c9e618f463077c2600c9055090ac83687e1abe626456744a15fc6a173f856854531bfcca29e9798276feb0dace55db161e3335840b6e35f3128a2c937b103d1833dc61b45d6bbc83931b44dbea38e3477a3da550efd745828d0836495d79a621d8d632c7415a4cb60385601d3b11c307e30af860305cb5cc72e269578ef8d7b8b4fd89f7f147a7267531105350005ef240350926c0b0fa796fbcbb9ea06928f3f382236b612dd78a2b443b9903bd0e48f5c3ebc462b6cc0d99a09231c8d29af968c09f21f869909ab6275b273dfa89d7e5bed568f5d3396663f62de921018ff663d077472d58794f347676c325ebc85e3b7f8dc01786dd3670dcde53200ce2c24dc0f9c8c4f9d93c58f0906d72327c77ca519f8967ea3705c8ede9e467917a33d29fb77f65fc1a421c55e9da3ae0f8e2ef60dca2101b81d5cea8a2769e9ee1d438f5e1f2dc0ed60ded9e5529232263234af3f5a6733e6bf7500d71f4a7738216e457b33821835e3eda1a4ad70dc7781f1ce726d1f44a832572b77355ab18906165331cb72834dba222808ac4a20a05b2547561705401940eb01c9fa243af523d2334fd17770b60d0a96285b2646a29fb0611673d940673b171cc0ae8ef7e919d9818a5735a3c637d21e9659b91f415549fed75cdd191a95b1013fdd06d3e1a3c5701efc2eed0632fc0273f3463fa71dfda4ca769157b7c51b93e3db8578283de5928ec3a765d20b9a87f492c52a134b41b478f1862611e243f19c915d56cf7c557f7b45413c66b855b2218926b4719ddc08c55f888a63066488fe542f879a739c7ab476155d1e05ee8033ff2c0b216fa3325f21ad386536e2f29fca1717fdd476fb2030252eb809c872f923ffd21c16b7b4996eb67ee6bc88ec97174344e90d09b8bcb9f2db7731e2cc2293824ea3e5dc038572f4276b7ad162e9ba6b41c20a5baf05369f93f0bb94db61bf71a1c8c782af3628d51409d6bd8a691a5276c5baeafe7222b5c2bb237d2e30bdc40c356597e7d0337ead879278d36dd23221111e41b5706ea56d44a1553173879f7245b5ea4453f577c37b032f0c3e142968dfcf3156f32343fd272c81ba9b5d33da15f6f4eb52640427c871de482491577b43bd0692918de530048c90bf99dbfa42ff7dd3e8dc36f13678d7bb2af624b268a10a2b47abbd5efcccc4e6c339d1791924c33182370fed27011d9ae369b32b035ff145aa8a929ea18906f6d6362f8c8cfdd67db04b13011c12a2a4c75cd3f8dbcef5533f3cfac2b87060beb1c93e0212fb03437eb3ed472221dd94fbaa0bff7834afa1380c816d96bc8feeda5dfef14759ddfa7f147f37e665f16a15830bfd6ff6e8caa00329e04150a94e3d261706e3960d70ca6d84719bb9ab2a5b20edb1c8c6d2333299adf008067ed917c72459ea0dda49d46149e727e11dc090c70633c536f336edaf31e70d76236326134400af7c15d74f72e52c46f55b7b4e5b15be63dc4453bb926af4d8f95ae5a1edf774298cb2cd158dd2a6f637d0dc12d57c538c8e817b0b6d10ee45bc2a2fbc9f61f1864f7721545d32ea0d2023d08ce8c57d8b42d97c30db8e6695697438f9d0adb4d916cad48357dc152be5b68de781278a4cf04bba6433a1b5fb1d88b094cfede5e16264533365ef2befb737b5defd76876ad44d64d7ba621e8f1f1dab04b2443fa5b94777331f837316b5771693354f00044e328dbf4ae974e8dc8fb1c3665b76493ddf400b325470e6b33e190e40847eee45a023387aa3ba137225c87ca71caad282bba0cffd8dddecf989dbd1953e6625e2ecb44171f07bdaee4508594dfcaffe5da3c8106b702ab23ae2c225b55772c30df0f8f7783030ba06f16521308b8fc3231db61dd4de64a5d95e2469e12dd42fd05622155f645ce6b07fdaf898f4fc24eb0adbb4e2f309f4988ea0670570d06a2f82710081a878e59c22cd77d580b7e6cbafc467c6012beccb4a11d02401a33f02f87ad340557ebac1c9be3defc782858e460a71ffd744f8335b53339dea2510ea484135fdbaf7c33a24b01d3851c6aa282cc15f92969be9a4e0bc88c2cf17a6350196c4259e3edbe86afca5b35ab586972ad1317be3514b4139753d964ca96cb1dad1454f5d548be02b7de915098413996","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
