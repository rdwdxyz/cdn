<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1422a42257ed6b7ea2199fcebd7130e859402282b0168f37a169e8b4cdefb296dd8883f735c5b52058dd81e7bddb337d7bf5dfae67558d234346fb9cdfb7003bca63a86878a42f3013f4fcf75d2d438d8e6171030b05bb37503f84baedbdf28c3f3c51ef6792f3034e65ad555fee79f8d1e232828c518e16db7642471aa321c251522b75982a3ae529c861a6ae568fa308e00a5288e4f2001f10854a6fd1c90e7d3c2934a8c66668be26d6589f0096bcdc2b3c879539554f00b9fc1070ee56ab523ddc6900a3c377ce4458de117cfd4ef2abf2280e65075c9f40c04723b261876731e6b1543611fb72de5307ff0bf1fed1dcde14548f7aeed8d04626ca25769dac9a82644a56dce85b062ff7f3c1f0510730e25db3f0f09ca049cab9b18d69ed5c73cf6dfd1e7d26c27ee5d889eceb53c30f54807bcaaf8fe9f221bc33ab3427c32d919a8dfc00b5274b63514f8ec6d40037adb6db6c5f02432dcef2b90c2d6fef69056ae51f5417d23206cc0183ad595f1096576539c8ecc436930e77731144154be9c6b2ee7f604d04bb00dc310a797fa0fb110ff9751875984dde7dc79b94b826770dc45ddc0479ae8b1a2f384324a350b337049d0bb3364eef232541968c6eabcca6fea01b8e879aa24913535d5db72cab3d490f52e425d03c070cb83cf0ab66ecfbbabcd67c4897e2dd6e184be48ada21e364458378d01cfd96966881445d3fec9966da23c4875207b7ecb84608fec495319c363554b25a2248ddc3c76c4e0f32b413134325a56776ad4b4b2edea9eaca9b38cc640b0fc077319a82bdcdebdc59271f936820828814d021b505fbdf9a241a61d008333899fb0577ecb4cae458a87ffcca26421c4043beae2a11da71e9b666ea75351dc91e696254df10f5eecbe0a2dea2ad33c93d46f85538a3ec997fb2a4edc226a558c2c08aee19d6c16256bfeb8d9dddb9ee2adf5240aa7a5c5e712a75ed20eafaa5eed9c4bd9c3e39f33be21a1891a767745611974e57121e2055a3cd760b3e1d0eed599333679c6719c0c84f70eaa4039b59af9bf40c4dfba10f827aa298995daae9e109b70b79831f08e849906a00b3d2b7abfa3f5cca1a8453a72366133e3bdc9cbe0f9de02840871d9dda7f78719c817c497f73e43081d4ee212222a97a5a70a1a8cb4462d327673c2df1b0a784101fd4c39c969e94a1e718c439ee34cf76eeaa85a7dd035b73440a8155d0939277f30a5659b4e0d2ccc0b0e05c014152eb6a922f673198fc536f5745aa18d40492412dd74a7381c3dfbd086ff1c4ef6a05d6603473d06bb96bf90fdfbe7f14fefdf9aa347d989eaaf7bea1eb31fe32bab330a8957d80f4effc0ea80b6395b30ca5596a23bcd297c115615800d955b3f46cfe291a24f1536cefb53940a0a5f5daddfbe3165f5e27d5dcfd2bdb3073c20c2af9aa4c9f6eba032103b5e44389ddd8973ed49d8f6f7017d065d77ce24ca114b5d2177e01aa37ce30cc1d11a003a620d371187627bf3912c7b78737fb403dbfab2b12b9f4918c2aad1e0a75ddddb7f9b56b83448caccb765389a50f060cff354b95bb0e03b54d0d0516650c84327c5431e3fac61c00353f72180c98f9f80aac3ddf6d1d849837e019231e80a4823436eb3e86be914dc323be620a0de007eaa4013ab51a2efadfb70920a57810b08a1154bffb51bdcd0eaccbebd9f329cc2429766f20e8a5377746c1ac93e0cf37e403ff2a118d90c2eee1bcbd296ba43ae6740bb1ac5cba3bb2af3571f7e6aaef0f415e6a2739f54ddbf96b31c3a2bb8a96d821743f3cb28355211544183de3d6f6f66acf3e12871ec8fe2f89898baeb7aba92599edcaf19d5b08671a93a5b4c6f5a17555745b2572ab0a7668b242f08b59cc133f1aec63a016fea042cb0a0013cdeb153118ef5eb4913ee261a2a38cd82f8e7dd2d26222bf48891925f77f52c0dc30b5955c7510ceff9c9670ee57004410331a699058186989965e3be194ff7538adaec17dcb0709fcdc22d11e50ae4b8c47541f08cac28d5222c01693171e77fbe192f8f938cd2a7ac6091f2fb9a0669ac5ca1d0f31ddcdb24363ba0712d25cfdf61bcef55fa7bc426731a9e9b2f42a390c1d279dedcf715bc71ece074712c36a558225ab2eb76d0cbb8561f081edce175ef4ad1ac9b7d3f16d9aacfe1a6c6a8ae61c8085a8f5eb178a81f6e2aaa5df90f75e9d50cd5882de271920f44d243bf0d172970835bbbd309c3ca0835c59c5af1e76fa5b98523d995d93915bed882574e870d4df4a8ed7e4a829870a4f154ef0e1d35a9ad39f0492e8796fd608a61e380fd6b6d31d9cd6f5d966b26050ca5cd5fca5a0b1c39a41c7183fbe2e8974207e0b69657f78b4fe1937206f9b38a28317cd023275b91af1025e32ae0dea76c2e8a53e338f0bebcd4f20eb3677b413445083784f7f8160459257de51c668ee76271f2069e8d17cfb3e81e037e0aaa735b6b2a70f20d226ca42eb8b0de6c0da18cd4a57a5ce60fb860d33b237f25aac9835a04c33592aa0cbcf0721773bba2f5cb9ea4d00fac3d0ca242329cd8e47e05402afc653d1002a994db750d4358135d4dd8ed33187d7c3ed8d408c1d8c924d7c0d7b15242e82c13965001ad603fe90e093d19cbbd4e655dc7584c74e3c10d3a87d0e8ad745c733f0278a1c2f16b0597c55bff1665f9ec0f62cfcb0803b74382aed8b7f0757c449471947c080a66b742e7e9a08e41ccad033ea24f7e3ebc8e42d445e87f72c2897191b9f8696c43e82f8ba2fda7794e21356cda4580d18aff0ff2dac19a142dd77adaf6dd2e7c800f5f081048ca14e9ea4b08ff14705fdd25fb3e2821aaaed0ca2ec746ef2d639045beef0609ca46e1b2cb0ddf49f18e4d22d508f03b0579503e05a2ae2cac099659bce9285eee97e3d72c942b72ed190727dd2574f7586375c9d9001255647d0d9673756f9b9f950ceada983b63058d7b643abe7cf75a8fa0778d9a189bda61d9f2f1230da1c87e625edefd72821554496b4e1d8664a5d4ab31d947b72eee1072b27fab4377fd41c764aa3ef89784c282ee65bf062d0ef5e122b3966e9917ba42c94138457ce7a126564fd2ca2a8b59f8602d442e18276a8bacba7a2687c5144501bf9d024179f2d423e40f265fcf31b0962dfebf7247281403542e8e913999fd6645a3826b1d9f2cfcd7f4101ff909e242883177475298f9d4346c032f1eb14335bd4eef4652b8e87eea8c5fc6bd51df4f87fea93908d86e47cfe17540a3fd6ffa3da32d7ccc70d085b62709d3d626ed71b64f21dcc91d9f31c289d403a7d9974135dac02224c3c1727567d9de84f235f49f9207a3ce68de390f3a3cf67080e8e4abf0b486cae3d8e5fd9d8f9348821cf161ce851cb226e0b44a4775c710a7612fa5ffa08f33cbc60350c554a0de1b088a542b653b3ef410a2cdbda064dae8d75217ba70f200a69897bed3852c86409950c2082302f10ff164050ad3a9ef20fa2805a3d3a8f8b08cee76048817ccc95460532aa1f450b520f671b7533d47730a015538add77f6137b353c721afbf7ad25c85f64a4f49a24268b9a01844980f51cb03db7f2c6347d6541be10a2d227bf40484024f215b61e5bb75ef4254466ab28d27a0685d2138fc715a93b706df53d3fb5d03ab2a49919cac453ec43281e81a7650b4c849408209a124953274a7a824bb9f7997a898eb4f6867d15f1a450e388e4a6ca9740c623b5bf73a6c0226690440535719b7f11ffcb26bde22b9329834f8bc03797ed145718a0167baee43bc9a741f40b3ec2e8d2cd476ea476740cd85a720ecedc6f2ace52b51a984f9a43412c3db6c4e2613b9ef75ad456cde77f2a0dc548115a6eff2284ac11513b62c87554fca9f13bcbae00a859b570ae7e33be59e95035f359cdfab770c30b514681ca3b907c705ea9a72195682d6d4d26dcd4d74164fecf54d32fc8c421b887cc615c68c0c7d5f1864949aafe3cb8eae36ed601790839ba3fc1efa3fa509813302229aa49dd701ccc7ca5b3a8237cea16f9300c2c2c89ac641ebec6aeedeeb8eb17d8de18d6452887601cc69642fd540b15866150470562206887b605f3686d0cbdbf9861ca5b7fd52d9d6f54a315d2dab607ea6e49121537e59af3ba0442fce2e7cef06c1b7dce060cc23e82d928706eec882c29a74631cc5c35e5a381169437fd1aff923b6eca2329e3a5049689c53e77ead307e40ae81368736f310c89b4f5765b7995cd2e7a96336e800cc9cc43ae09c3629489f46aa7203d2ac0132be1138030f9fb644173959392d1df4fb5cef36652555f98ac6cadfb52696a3f7458a5a7676be84be6a6b87dcaad7c9a0084e490896c55c2d8aaaca24da3a8f8b41a55f40fbb6b80750b7b9ce2ffc440271ed730cd2a6e099d1148a213bb34b8860b75d13342e41112b9a6f122a41b078e2404b437a12b7d18f13df4dee116279456d5487702665b3a83f29c30c133727027216835956f37abd1a70be55a0459ab218497ea3b872b4e951f4623297e72c872b02ebea9a45e1b4f0078199afc0736c25538afdaa6eef82fcc7e925dcedde96d272bc98daf1cc976c3574efed161de35b3e792f3b8f7c45fa796b152ea9ac29c84da7766eb02f7dc23300e64b05bdc2d6dfc38b4dd89f86e1b680880cc87829a8ed7f6d1375f0136286ac76e8638370ad29d3bfcab5bf0d2fe1f1f03cae7afef7dd855fbb4e21c8913e5fa8d600803b7f670a3ed569ec59d70c2ad08eef63493752d09a41169d9dac1d5dee1e8240b1e892ca1178ee7f38066761429e75139dab4dce2a98da686916ef801d8f0f0a944934e4bc8fa02e8041733f56ab515e622757c64a3873086a099f3c289aad6f06164bc100c97e30d2af832f3b82e3e8aaf4e250e2df9eda441e81fac51f8921824e607e0f85e08066195cf18446e3fc00cced951cf1af391912d963fb989ffb4efd5084384f4e2a5065c98a24d299f6104d032293ed0ececcbd8429fa42fddbc908872ac4dc9c587ffe973bf8040ec9b4a14536c4a31ec3ea2088e35742c74e072100668ff90b90abb4aa3bceac31366b4f6a479164c7dc95e1a958af9f6bcd3d5fb4b340d23d401532d85cceafd7c0e4fa7121edfcd41909d4cac468811efe734f979f4689e0eafc569b21f2bf2ba3e95438d5e525cbda2253bf472fe9cb2c5cc04528ada11db7585ce6685bd016603f717730c6f2cb448d92ed0a40bf2e8e1fe3e0e3ef052a62f1cd898f532b36b7957883f88ac3836112be4bb5eedda2b747e0b1f6c379e4b24b65c0bb3c74eae57db77e4187ee8002121b61adaf9f2e444fc7e37c10c5456fa86fbbb1a8fab24fdafa8e700f0eb533c4e15ec49ed9047068ab8e4df02f8d17c10e4d2fd7c4b6f531026d760d9bff1c88271e84a405609f88f4e3a8fe696b5b12fd618d314f3d293f8d92ecdf8ec3314f9858d957db1b8ee8b4954a138b680ba5b9f3b8b2dd2faac118da4874b68cfc0e94dc209bcc052a3788e39ce106edaec0ba69baf0432ef2751a03b55c3483cc5118e4b3025524af7280339850dda9abd2f0ef958e30e9d93cb53c68ac2536b6649f0e3c589385ea5c43ae3170723b4d483c5e6e43b76f6da32ca62a61ca39e590a91b8b54eaa8257cc8fb2b2b59d41f5af1b50115b196721eb3241e1ab3982a652b1b5da9bb8ccb99a35800095460f15bc6027fd539764ff5eb2f83e8b67800cc922d023ace790b33a4f637bf792e2b82b1a7cec153d49cad1353e0d92b7069fe1aa580e6316e6cb0b73531ddecb8ab87e7fa541de3c9a77ad23779cd739d967c36d3b6854570834b21c3daebafd265f521947258e3ac4bc42ee375a904c9ba8691ca615d4cb1318e3558e7e9813dfae03d2c9182ad7d430e08b78b5af8322e8385fa848c0cb2e139385d5207e32bdf2654a49d4dc6c63259a79169a0bd627f129b596dec71cf6784b425327665fa4a1f2941ad41078385a027778fe632c198e96e7364028057474d9e03fd5f85c50f984b10dc1110596cacb1fb398ae992caf22f54191bd154752d177bd0a2085c16d969eb8fbef1c3e8de8e2ea8099b6b8e183419b151138f9cb732b11a58d43b45a2b2d0134c04f64db237bd235e27e2ecf0893aee21d15796648987eda10dabd3cd408b8c89fd411e2832f1936855edcafbca6d2f89ab2940f6d1318b5e372499e72fa05714efedf93cf30830cd27573e969b8ecde41745a5809feebcf67f80c22a038a51a6176c1de7a8a1c717728b6b96a0d25f02eecd5db493647f58cb3dbcec9ed3a99650098f914a88e566a74e9348b7f7131e2beeff7771ad4beae9fcfae1316e89246d6f6876fe52fa07801885cf6c173c6a50c7160b2f0e885cab9077db1220eae2fe24ab8563e1523b1449b2fe0455191134ccbbcf140638da657a6867eb23f7ae6bba83ecdad4e957ad98ac17e2e43328994982e7dc0db3c0f7721717a279465baeaa638ca49cb3915429908a4117fd2147b804c786ecd979c68f96d67d56ee041c47c356c05f6d7e0cdfd0a8588b5f8a8ec383dd3245b6689e77fe7da84f5151f4054fcf5f609782e482253bd86c1e528c04df53e375a43462f131e8fbfeaa17b47d1871a6937dccde789d4cad16cd1c33570d4938e82863800aa0c05468979f5e9de79c393d802a60be8a851e20e1909d4f1c5913151eb347d08e4b5090728c1a8913e7cb825c7de9a0229cae890d076f4fbf0a24551500b7880014373822305ebcafe0a50f33ab8d97799508f8e4bf0e44ada026209bbfd9136651cffd14f7308865268e1df443935ea80f8f27080630da5142d24da20ad62c75d12eb79d67b4cca196df336d20de0fc7b5c58039ccf95be0c58f7e01af9b9c9c346a25557cdb7fe5d2fbca49f5fb0f6393d78d1c055a845f0971c6994def2c87b9736599bad93c0aa16b866b7a174276571be97694589edbe8f8fe1b236f64b1919dfebed3bb854a5367b55b34d4fc71474c13a4ae372996670a50321467c7912dc2ffd3703f4aef33edd8cc5cb044fb258c10ee48f016034dacfa2470bd60bd2b937e2d3b2c5cfebd26319bab6d84281ce73bad0fee82f867cd1de60e5c536632b38e28302bca2c69dec827b089a523dd3c5e391f8970c75dc6373a5e69722378348de248b25d82259f7bfbde98ab87150f0315ffae6dcc243832e35d640763ecd5231b1639bc3e2bb14edff992b95768fe3b39e862ec6538907373917f9d57f30d3c06fb46d311a09cdd341e2d1012b9bca2ebd6f866e9551c1151d6b3343116b234b87fab7674e62dbe9b26c81d3f8795cd935214b5c4ee1207311f6c55b93df35a819fc99e3aadf966c0e69c29e216070c3d6240a11596d34dd397919fef29093a4990b5a8676afe6c2689308e8b442648b877ac5a99764bd8a9ffac99a2a8381a60fcf879c77bed28ff4c96d5459776fc235b11cd5778b45c233d311828318adf47c27d031d4379d662a24bb031cb3ee86680df9639e7bfc5cefea096fc1a05b3c2a080cf50e12bad184a2d21f7e637a3ca9f782b492b26f071a12cccf46eccec230c44e98d694519b8fc867e68b9f9d89bfd7e57c12c620f1ae5350342b96d0938850fb69182c4739c77cca317942a80bffe66255b3af25e87ac778589f01076d151f278168a1c4f2f1eca7c9ccc3242d32e5a1125fb2dd54108923ee806701aa384b26d9e8c60806b1d294934c8a31e97a753bdee81346d55a8c6bbb5bad1b22a39201a207a494b361bd19ab6bbc8f340ff7fcf9e3b1502bc7e0ae7f658a7d294a50a6e5bace6d0345e8c14f0cf1cb3390edd27d7ae2702dc5fcac64643d14b6ded27132e4a19e6bd76be47e7cb7b80376875f2cf57167331de57b6e7ba1291bdecb433c2e5ebae90b23e4a4ab7d86e1c955bf777e0ab72f0d254909a7c904b717e9c3d4b4dbcac7e2338d2c7fc2b3bf83207dc10beaa85ab344b01f474ce7e18f0f7ce51adef00c86cd9720a4f8e3f91d6662612689417100184f42785155d6fa297713ff6afbe1b7f973e9935a098e1b3ee9ee301e10e545c6e7b6aa7fa0e73002a05ca61ae9c8dc4ab62b95081f78eef706bac4b6c05aee89ca0074f04ce99d00c161e0b67ec641f8514196c9a82913897522a0e1d22c21caa5e520676d0dddc96d8a5c316efea0a5d541f2d664ddec4f3ca1915f37e013ceafacdc85bec3f9426e96d3f9f9371a66030ad4f01592b025bceb24ea9bff2afb02c081e03334bdb04a3d0a984328ad201744667ef75337f642582af5fcac8ded236f1b57c13c478fdede1e88556d0a0aa7588055ef328454f3106be1b7dac4df2cef75abd93ee03438f33dd1d4a910704f01e21b9dc88d69c63a4d94ea78e7bebfefd83f13632a0263f5ecd900807a5dc5e452aecd15b6ffe71c5fbe0ad46618ff68600bc347ea47fe39d05e79502a244d9899b4f9760dfddc7535bdad8ef1b3a91e0ae3fe6fa2c3049bb30e9ab66976f780b95b3280c292e830d4f4103f5147b5e39ad160757122f85ce6ecf809d6160b89590fccb921898fbfb86d5a0305c11a1a0ce4750946fbfd6033a16b4d83b7be68f185d779c4fe1a54fd927a3ede393da28256602ad88baa67d5583975cead7e199ef25692e01c050f15b6579b7f4996363d958f5a1596d4297d83817985c20f906093a96a52b0843bbcbb1108f24cd25cdc43cf92ec37c4d693323046d06afaa8439598f553d6407f9efd85142a859f69ce57cb7c974e20e2e0b4d0306985e769040feb023a413734dfaa6671514bc3d437e1b9465091312164ca89fba77552008cef58aa916fe01448bfc88e21e7c5d6e699b7a5656c9c7fe12ff6fdbeca14ba6c46deb14c922cb750c30fd9c0cdcabdd3224e262efbae39f3b20510c0e82391921d4101df663319260308397369b4cffa444ac99dceb7c93f369a5e736526098b4f486943e61688ddf8fec26fa0af6e3f0f04a54a01d699bfd269335e1cd4fa93a725ceef232b0c9a8dcace3eabff8670ab2a562de8ca335038163d07edfb4aabb0ba2bb25f748eacad24004b3271d7c89053c40a4684777f924be86cc9939789a439259e338aab53be670cca866cce5300bdaae16c336c6147369f767ac13acc80eaa453390bdae7a02558a5296ac846f2a7299300df6c956bfc6c12d66e09aa728834f183c65a4977bc87f61977bf78f995b8b18f1eab7fb19c2684ded0e40bd48803ae454267da57ee2e2e5fa14e61f85d2aafc1fa51b70e3fa039e41646eae55f4d4f76cb3ddc430ebfa29c398e78cdbf49dfda5bc98dc240043f0d1d4190ca8142fa0ada19be0355236ff2cc7adae8ae538b3a14e7b9890e86d002d1bfee4c356532a8b4c42090f25a388abca8afa04fec9c3a9dfb2dbdb6e6cff7dc9222a1e4259097f0e0c6cb0a700b55f37ba7b24de8eb298211805c03d31a1f3fd52ee37a62588d566d7d44cad770536278664fc315146cf2ba7b815c7764966cd05d35c03184d18253601a88a8a87fabaf688e8f9e1f71bbdc44cafc5298299845afb86e3f36d8e1fdde4c54227268e087834299fcf46649bc08a46ce510714289b5526fb8781c6979ca2a8a7329b06002aa2d513d61b673f764dd6f180741c6504dbe701e70ea9638dbc3890f993e137a73d9baef50d64207007187eeabb8dfd71b7166e3250aa5643f5c86987622e077a37f6ec71b531809b3ab35f5bd7b30d96e7bc1df48f6599c8d6834e52c1414fbda0f1b390ccfec1e17c3bcb037a89fe4e4a64943bb167b13eaded9ff8b4c7f2a7a20a8bc0b4b53805640bf8a43a27ddc49a66efd0445d97950ccf12aea9c6f947d1aa7d3a40ed0b237e590cdcdbbf91ebf82f6ff676376050f5013372f107c1a37eb7fcd5e3d6acd2c69e3c3e8d50358c6b9eacf41f95f8367748b5471369362b30cf10ca52bd3e8585030013311888be5137b6340ea13cbdeed043cabdbd91ef875429e8dd99d88466259152e5d088fc148783aeca5cf08bdf6c277dddd83a3c15f9e1f73d6dc4ef0d3737a16e482db813918608ab2224c8c7a3739897d6b557f0eab86c8c8e01bbea64b32eef196f446122dcff98f7156b6be961a85125446f259f0a0d55e23a92bf12f420f5b004a99b88f2b5634b1adb995300951279df8ed3f26f0ce7dc3b8b42797e18473364c18b4dd8d36cf7779db349ac6b5c7c8af531bd70319cc29cdc44fbdc0ebc7ae139990515900b3205b9de007bcef03997227b6035e8cb91a6dd1535a1f45c3185df10614690fa2da40a6cbfde33977a5b59f836fd3a2fdd03ebbb0cef3e94c825990f874de9f72d14a53df214d7471723743d9d6f00319af1198a3dfb20fa1a8dc19572c5a688f597b5731e7dbb7aea72a8879f47895a80cc1aa51212cdeb4d5dd456110380a873ca4d7f468b1a99a4135adc1a8ff1f9c8d2a8b2c1a4aedb56032b96c73ffc72234e54d7c238514a106316ec56a074525b0abda4874cd38d1fd6fa2ad4ddad56fa34a6c5773f4dc39c5d568a31074b0736a285918fc1e2d79b8c33c24d41d8c5ebbfbd26d2c49ca67d5ff117c526575ca876f58d658c49a9b2ee2269ef1ff7ecb9cf7ae2443b323a0476dfdab964ea23184ef51d5366c84e07408630bbfb08f8d85b9339b7d9781697a84f00b727b707a9dcde4327806715b121b883dca74b195b28ba1a7038ba59154456990a9fd3f938a9e1ed7589bb683bac645bde129343bcf0a7a8f9acd22a8b3e8ddfe380f83276112355403d4868813fde8a8e8ef40be49dcd289a39aa35752e2ad98dc4b37891009853e7c8f58dfde42b1f959aa16b6b83054a1228a3b92246417a2e7f11ea81d5d21464381c2a52dbe5574be4f9d72c01211e512d33ec624d418d90d9de5946d86bfb23e6ec2502959668006851e90546ef5e272434eff0cf334c1e7b795dc5a70c0aac275b6cbd8d98b630eac0485a117bead5f7509307d89d430c2fe0d9d41e74f9963e67525637ff091ecf6d69c668a00fdf4a14ca2bdde7e1d729705344ee1e8a69e8f241afb7b2c949271ac62f4d8765831dd5f5a40a9d309e6912689ffda591e14fb1c2cb5daaa4540585eac908c820d474eb67ee9f02b4007421b2881afececcc75f6d290d7a46f8784ff323eb63740bbdafb102a7aa97f6ee9551f27afa5328e37ac460f5d305a672236d7e387f9c0b86c9d21cee3119f89fea8f9819565321f6e83102d94fa335b9d79b9b55e8aa433160bd8ad4da4279148624805985cdd626f54e21618a237babe5297056a30df5f04f4253e47ddaf10ddac852667f1d511e08d7d7d6728b0478033def1deecc89d527da6f0f38f8223531df0ba602f3ffb10baa011825b033773afadc168cfdcfebef055d49d1286190f78215a691fcedf24a3ddbebccf9ac575ef9931d9e6200a2bc5d56a777b1fd38618975add07e7b3567d0100cc83ca32b498e148ba359156830ca523ef161db62b23b168e02708e87775baa3a1a17acfefd2bee408eb01de668443ca441b8a6de1b4c6997819063de287f142f6c194399404be51fc086a9fe1ba09c50ce5e6cdf8a7af53fe9327edc236fe8b7e09ca36ae634197b65bc79144793db26b70ea29ffe326d30ab37cb0f4c32b3038f27fb9ca2766b06a80741badd930a82d25946953f601e8dc72e299ffec1a1e8d0902200f9d0b7c0c470460c50c507218dc22296b4295ff6c14d28d0527da98b757d46b4905ecd530fca8e8d2fcff71f07ed44efd4970b41ae227e88274fd367683dd8dac9b756c1f6fd67b08dfc26bb7679501a9abbd0a0ef8cac4c1dcfebcfd26d53ceb566423ea0b87ae3639a2a19176f9c45e6c201c8911668d0c25c745017c2b36b6893bfa7c1c27118a2ab6b9a4f4346adfa847c167d0692ef3f251cd1c6b5d652e81ddd8957ba07f1a0f491711d13ed53c7fab1d01c935af976dab1c006330cbc14647a27960a8826947e884bb82492d3640fa18702b6d822edb27ff6e44b51f4ee6e870a30715409eaf47cb3a94060cf7a6477cfe13bb8fda1e8bb02c6b6b3dfed15f2142c913c334d7f2d580d5f3d75fdaacb0279e4af0ffdd6f543e9b45daa51322b43cef4fc2955fa9885335a34a053d2c45d3a0aa9305690c0bcfeb69972b30592f66e2d5ff096ccad192a7a7a4d47a90435c8dbd28048b8bfcfba73df202d545f9508a12b5b08c76352e8e8172fd7eb4f1ff02b5c32b040742e6585dd618271d2876f62bf492325f4d7bc1cdedf905d3bcab23346c109ee57caa69fe836cf6f196c087253a4d53d4fabffef7566837d9d3781886aae0219fcb2dc57bac8a6d3ed57abd8bf3a6a39ac40714f4ad9456c08daba3c50669352ba287313f81eb677d0fcfef2ac3509b17c54d876c0ff640ef7f9f273b147df06bfd6278433d7a2fe540f6b4019719777b602867d811c86de0d6d35045dcadac921778cf09fddd9ad318fb7f040620ac566189b1070f53b0bbd36399103141f975a0728781adfa02d24700cb313e51e7094d38bc6123b02c03de260cf3d23607f546d437b4fb54410e1772335bdb3643802424697ecd458097e7a12e0ad194450aa9cabd9df7b9d6984aa9b43d68048240bcb3482eda4825eef2de581a53adb21b8868a4bf64fd061fe19fdc81ca8140f65d97627f5d6ec652cab3babde538c899d917e96041cc7fbe83393a7e01854818b536a8bec5733d97ec7ec5c3f855ca14ff31e4c92460db8de96635b8983b41dd716fbbc06c7287627fcaf8a5c2ab3591dbc948e26b7201792918a2ba9afbb3422befd6fbec493da8c7339612cd38a876ac90341e4926ab905e7acd523cf7f92221d4d163f1ed5d758f6cca07dfa0e9cd01601387dafa0cf413808e58f5dbe062c3a6d7610ff2827b7b07afca7e7e7f9961b3ade6f21c25c905b7607f4ddf79c7bd221be250b4b69d3784a529237acb6ced183f4bdc84985efb9c1fb45adc8ced8f4117ccfeb9ce66f57a637d1e895c3e024c51ac89cfa7e3c35e80c432352a35c337ae56f4a793587a2302e7c3f6906d62a6d67477e70bf207615d760223581452cf1b72eb40b6b91941929d70b09c669d4267f6bd6788203ef22de8751e3be6480d8f40d361d362acded9d8efe091f8dc4f7d1f345f27b6242d28939776f9c79584934309cb088227f323173cda4b1d715c62ab57e153cbaa5d72e6cc3af6eb9c7b4fee74459b619700d6552c41885331d30ab58fa88ee2aeaa36de5e8b867d709a80920b1968b9270c8a2680b8f546d1f6f640a7f87ad75183f3e9e0082f66d9aa09e5e2d35d3fb406192289136518ef05a36841d8d031f45b47bec6de7b6e6709122ab321a0870142d5438081e8370e87136118edb62497c62e7b6eec92f59d745f9c6e929f2647b46431ce57441a2f868b1ab58a30aab11f5aa7fff5e3648dc62ee282bfa6af919d9ec16f5fe4ac103150dbc017c342278f97ccb930bc22fd2e718933b9cb8702bff17fb54b8368243d92b12f85c526a48ce66fcf6a863071f574220c5bb41bd74ec21e1358c96ab19b9fbfe07ca681af4a953723fae98185239bb4a32b1ce9c06af0a5c188b743b3df29b643c2dc5d47042bf391d817d8af605fb84d66bf8e42c71749b4a8c6f9e9b2c74f3b3d2b32e070f071c9def0b77a29e75b3f715aed38447242bdb2a8048245f99c0d6503945e2402fd36adea4a7701a4ec5c818d35ffc7841f242cb52e14b57d2896fa91898be2ba0e6e6e1f1f2f72c9f69fb5ebf49e038273684b9945e9a9dc65fe7fed9f8761edd39ea4c1f40b5899c63a1a5ca778e24d1cde913c3e4a028b8e3c217a5d881bbf292596275b0bb70fe31f0eca63a0f3a30c410bbd16cff0ad1305cc3431357f33362b4c9609066bd86b1b97730b6e0fca52c55988f9fa600f18da28116e946ee24e5d3db975cc2ae379146a208f13d2a8096de72ce0d15bc7c974284de4b506eb74332d1b61d55238572299f127bfbc1e6162ca8d0bd859adf6e639c71f3a788860937921bbebc7267a1c26836452d6da42db01a2f3157f7aab13cd97815756967ff10e460a4bc2b94f93500a4537d5a017eb17a608b278b66533c65a5c05b5fcbef47edf44e303c0025bca3d2e6931d66845e29a3dc99b7529b25613b7ab9b2c52249ec1dd547206a75ccc6f847ac86329d2f5800014c4fa4b0dba11584af75d52882fc22508a1603017c202738e76b4387c723b7dbd7e150650f683cc5692c1ded94219fe84d414b19e8b7559f4177b808a77126c5ffd65167b656b36268ef0b9909cdff1ff3d294001f33260e0f9b6f93501cbe9a6a2db9f52e9dcbe2219361cf2a338550adcfa91be68ccb338af5419a9d03fd49b7dcb9766b41b7f12ea3ab957347071ae17dfa7403b6c6353cd9dbe0e03a92a236785d1e5e1d029da6b98257b05124fb1974161f5758a3aba1085bcdcf1084c7e7294f8f3f55c01e3064b68269be1b014a2b8b7171b11a5eea2ab7702f23c3f05c918defd6ea04a07886a5376a1f68260eff9efee9fb3484b5f2ac0b59b428479eb8e5d94358ea4fe686bf9d221405634f1e8ee8ec71aa2a93e2ae3a0794eb8f0a252f022e6fee01d9dfcd1e37cb11db87a0182817168e151cb089a65453d7a2c46b0a8e04c02aee5845a4ccb99a22549c202b5f8e7f08748b5e8286e0c7edcb865247d3274f19eee9d1034521a1f48d5f0217bd92d11658d6eecf9a727aff10992be5fa6512354f7a7ec152bdce5c5976c448274d85028af74b9de50defe02f0a2417da1a0215900314dad98871d6993007e46f794e61ccff9824fb8ad82b031bf9681e8378590b201aee4f4112e1389b745c3dc21b50ce13536b00c1f587a8a5b0bc6f292ece7d885fca10f88a563e17f9f585a8194f865813ef1d5553e7745af3e947f7a9db5c2728cad39b950b7b8e20f0f1b017a56dd3eb0bf214d11f2f4b387e6ca006079eddacfcbd0ba50ed980b8c23bf6562d1a03bb58d86aee1d5b9421551d6dadfaf778e50582120e676214b8240962ca1d095bbea1d8180516b7715cb8a297ade208f48fa637027156b89fb6d7c883037c9c86cd4db2172bc80c36a8bf3371f7091ad7566eae05ff5c6523c83f53c6405ba3b81884e2c7337df1a0ffdc88204a4d5b1deec2202c6e333c2d90386d9d26ff797a060d99354cb4db178487a12c93abcc8f87ee6700ace4da8e01705d878c4a89d63a0322677b46c0cd6fd4bb584c89f47311cdc5b2f59115d0e410979889be539f75adcc00f26a6c29626e5f650507b1d6780a1c0d48a06cbdba61fd5c3c840950204db8886d82541da16bd0ba2da8406406b01dc7aeb7d935ec62772ceee279fa094ca54a4834c4a657114962208f17101963dd1b78437b0236deb20cddf06b9675e22af3c73ae6615935e4c063279743a3a04f7010003820e59a316525464d142761ebe55293f2c1d9e5faeaa067f21dc321a972ab5eca532870f109abc8c6bb66e61e2dc9b7d03dcb1871c37d89b3d27891c43073574e75a2a481ff490ad838afd0d8a66fd36773f9753129d416515f60dfe30a353d81f8b730295cb74cea6c7bf37ebad395e9281cb921ca8b716c14df604e4a2ead217f10e7b06b631e60c1c10f3c46f40bda341a3bcf74ee88efdbe31040f9614134f5855fd38683f31487285d3ba65206febfe0e95231fc266e41e726aef2fd6df4431088ff517ab2b224c19bde5ff3e816ea381e459cff8bab1076e0c294e3c5e012adfc9323556542300d0a6edac6d8365213716a62d8839d3fee5dabf917ac970c26206c2987a256cb4feae26e02cc18ff8559bcb2c02646f029720f54accb316e95001c387a2c21a9c843f14f5a6f08d47603933284e69029aaa2996d70592f97130673e724ac89542d6702040508fcc9f5dc7029a4ff9aeefce3937cb5039c536f85ee28b9cd8ffb5e38a036cd9296f5747a9159b1396f589f018c6edcdd4e7462254ce12102b12ea26eef95983f5a823ea6ba2cdd0990e3f2d5b2a310e17db98019dbd6e2ce5eb949318fa9732007e7336257169d6cf2a332d4f471d25d0aeeb7ee951c9d593c9d7c081607feda223e4a47136d8ed5311715826d1ecbfa0680fe93da7a7b950e61252823c88919ad00e1d465477b22d67a860cec1598d44fe104d1f4955926fd52af9d72c52bcdcefd1e0dc9eacb6f8863bd2aec238d70c52f5bf02f29d1507bc5c43c6ff8ebd4c004febc1801285eddf3d640c1ac0b2c978b4a269254cb13a5c437ad1e63c131556dcad72b4c92f0dee3ef3a78f7157b9f7027d056e593ecb07c128de4b1e9e1e23f60ccdd4742c6b9b1f04d284de3a7fb202f6b54473c5bae249fde19973004e10745889abf043c9a45ca31edcfc745380219a79de06819757ee5c560874d4e5c44f9facb4e671b05cda3036c8f4e0f1dd24d29b178c9e5a17c4affde74890f48def38c4e6b38fee21cced63956b1594bff87e19d567a3c30b81bdf91b09ef2903b327dbf4b3801a327e277df31e1161e62abac43d0a798650a853e46d13df5d17d9716d9bb7c226bde78583ba248508707a28f0045198ab3212854be74b18913ac05e6280f51813937f6d1790cecec4f96bf4c1062d138c638ae72c8a0b33e27e76ba4bc37e40967432db13bbede9cb90cbc552ae0a1144c147111e841be72b167c508a7de270064edb43f8d1fd22c3fa65cc7624e13fad7337eb5bb2e81545be23ebef15b3cfdd8ad65ca96107e945d16be212ea6d53f670244691a800d0ff3b79d929ba17121662a1fcb6756636dbf6fecfe62fb8736a5c08ed97165dcb60e246297ad679ed4479d09279a9ebf88a8626486476eaf95a62ec147519a72f5bd042402e935a750ce46d0ce8f044aeeffcf597e64e25149f66f76a67d4aa105c33bbbadd0dedb489293b352bbf60343a7a23e507df99927e9f1adc96ef762a08f64a1c94c3041fcc24137766bbc40d8826c7080e9a84636fe856a7418c2169528d23eb22e0a56f329add8ceea85bba7dc3e738d593e19271de8d165eba55bc14f5e41245898ef2cbe0842d75d9edca658f059d6482ff837ec1657dc6ca6b029d12ad3ca73ce8e915ca4ea3a62d62b719d8aed550791d632e3d66b9c6e6674d046a5dc3af3bd9db435194594be2be7a2fd457e91e9d0fdd673f9eb33ae81c958a40cc2a9c6f22fd7a43fbd13eb8809159ad39b0a355e07b5d9c006d8dfa8f5e664b0656c984d6ff5b1c96402ea6b2921bb2af06906183e8d744d3d2b5706fd02f487dbe7e46c5d9207d4352ca880f26ed44e317b42dacabaa54373b7897a779fde9c572d11ab396eea7b243e106cecd912bebacc9cd9ff7fcbde54441832a7a10478882bf2ac559a3fa358c8a1231e66cc867e37a69d8b15eb6f796a6bf44cabf59addefef3ce2d3a0a84a96df136fedf1d3a34f426139d06eb1cdd224d41d1d1d5962dbe13bfdc4dd15ef7381fab13638e7e883e23f14d1cb133059ddd8b11d6b8c36dfe5567c9036310570136f12f15245fbd52a89eaa22202815834176cfe3d5b8488ecf3b4ec1d3755ad5613450c6efaf40d05b9b82e9c1bb887d02486efac2533cffb676b5d44254ac4cee849d9eec5b5ad3b8222ed913c7355b8c3b839169fb297f25182761e0bf0995b1e2a0eebbaf0ec07d25fc5ef81fb1f1488f75cef54b9e99bae3a4b23c9ff2c47838e5e09bd342ed967d5d475a7619d11181c3a32ee94903c5d1956eaf4ab054987e9b52c682163c14cecc995fc56d3de35aff5c2805f2b66506f14e6f916ca38bc3d62f93f3531886ef7a8ee3fdd3313aec3e99da034ddae2ef25f48b8bd639b3439a657a1ddd626a9a1a83edf939f37af005273c78a0ac977a97049439a71949451f2c9e11eb940d306e5efa0f90ab1499d28fab9c1009d09e74527a39ac7d9c75cbf3c0f43e9d1182f09a6eb50a9c60358558566d1b18ff38bdeb2fb16a0dd9cf2b9c38638a37920102bea54e7cde1adb5ed57eaeea2a832e39137597850c0488b25fbba018b45cc42406194e5c6a26a85413aa28e44464b5c4783631e8107709f66c11664b426e3f068acc5a432dda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
