<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8cf9aaab04e29ca0599713363d96c48322b148767377b03e7be51bef9bdbe426939682f1526eb6dd9376eade159926357f48c4fef4156a41c528713ccf8007ca1c00d3481df6089c549ffbdca58719e108629194296b95b1d4c1c94e8c44142e010e42d07bfd85dd611f12a103095bf0cf73da9e949fe5d9c662026ed766a9248fadc21e45f0337b8eb338058fb2441072a33b9b92aa4fbd3797aafaae7cb21ad9e09269cdde0a4a8024be2490302acbd7640d8e592f38bd7a69962ca0e7de8a5f9be3e852a4d8acb1d8e343f5e462c83c32ce61d2c8e0dc3cfda6d5e4c3e3d4e5c3a71e0de5109245cdfc828d6c8c79953c72507a5feb584b8ed8a8710d8e2aadcc4b012b738fcd65292de7f6448673f51403df014c29ac21a4d6fcf15fe25068e8952c3812d451bef07a1a9d0924a5a58e7420e2a627a00329e3a1e77731bc3cde09ef281e00cfefadad2b1691c1ffba2620aa87e3ccf6659171a29ddf97f66df60a2b4ea4f0ccbc41ddbf2b1a8b84171f8fa543c3bc2e651b9c47d0ef2c87b6727c69e05079462acb3a9575bc652e108d39ba4543f5b7e5c1b387e3eb0f4142e0c7cceed7425a321599234e7d2c59f9979ec25ab370f88172752d24c59d8556585e5a409daa7ae38877a1f5475e59731eaff364ccb262c6a2e865e71b83776e51546e7c8eb2a2638d81d0d247fcee724559c863e5120f7481f70c9078f29434da88b51388f1ad61aa7e5cc02e7dabbaa695c3a3d1aceb8961e487cce5af7599eb7584577f3ff63be176a3aeda613fc19f9c129c2c454bf9598c8b43c40b0a9f728789da3cc2001b8af25d35d9c0b63252fecfc1a3d4a898f6bd41f5c79e80a3ff08561081aa4c82b0702e9b95081b871e2022f1c7de8aaf355f0c7f7582ad04af793e3f7a042fa1acd2cf17e2d950936cabb58fe5f5354d42349f1f2150d4e20f4882d67d21e929457a446d5a7dc5c7d62da29aef0de31f813385f0ff40bdc3c26c3919b7065327069b15a470e7c06f47febdcbc1ea42b2cde480708f00ee85975afe6254a3de0d21c5c725216c25cdfae4854521d5046a4fe27b36232cf52182d3d5dc2f9b9d60293cd4efe73ea2934860a13c155da27788886f03406e42d97a5171560c4f8bb7a6d82fe00176112c380fd90f68d8e8b01e67a1473ba88466ce966585f30320818e337101107a93a4ea6f92c66ebf02d5955554cd399ba9a82a980251a500b4f9ca7542a90d2163d8e12e65ca35d3a84dae29fb3cad5b0b96c4e2231b56dd0f38efe0ea516df71f9d332f75f8f1561806874de039500e7bf9d58de859931a5d21e09c4917aee56b118850639d73f2551d60d0f220b35eb56883c5dc08b2b670a67bc7dd161cde8d2ddd7f873d6fe786cb4ffd24490b5de1fad863e9bca0ec73b168e7ae6bcd6bda4bfc158b022b615f1d3a48ae4affb0f5cb1d6c7ae09f0f45944d0ff0467f846d61fa691f04fef107c74222daa23cbdfefa1f50a5bcd88c617291a0b7f7017e2f0b9c3938fb60ff28422d35739f83befb3dadde95412c3f481a9d9c0cb8ae82f7536eba09568b1770c761d43bff781f370a413598e724c60ce81cc13577f248a6ae9233ad5a08c134cade79bf79019a3c6c3261be84b830d25cd409c89c61f7771859e476e66560185f049f095b4d9109d04e3070c268e8858034bb4aa9ef5dbbfa2a16eb0296144b7a24f384f6d11091af073374e6cc233677903079758541249d41f20e4f88297ea3e267a038c6f370a34d4496858e18d93e5f49289cd7869ba66b26dc72dd39bf1a8781b72ea9f88748743d68e03f47fd3a6e199d1227fd64d1d14d312439d7242501856ac9dec4c4fd964c042d62ae43581545d23522587ff811f8fe227aac005b2cd6808905cb63482f26fa06423fc031935d89a1c0c7f691690665e5dd8a3e19590ac9cde6f2144fe2f4716b2969da86a5b765b9e2f95065c27c999735e0583594a6f41975029fc81608df23ff99ceea54eb5784ab0b1bfd298ab985314d26f9d9e682f02290885acf6fa6a83324e44eeee4234e63d275cfaa33d7ea52520704a3551f219c7e36ed186fba69f973e780a42d35ea16b15712ea8e5506ac46ab742e55b2bfae160aedd69799b3e205a3fa53308ef9f342624db533b4aca162dd7b97aae994999a9abc7b8ffe225417d7c0abbd223a1195293f6407f781acf16d654aaa63fa86eb3efa1773913bf0f15e98b47948c4079534e79d33788cd5aa9d71344c4f4e2e14eb6734e82e7a584a5f7aa2e900a7a70201480ee0fe3a75e38b7f084bd23b3d692ab5bd07d232f18236da6c1c161eb5eab7e274898d001f2827ae9b8355d4609b654ceeab3070a34014901132fe63149005cac6193baa246b36e821fab851a23296f62933be9dd7560b73fc0c629d7718ff2588bc0a6946f83907ccdb87f4c9fe180df9d1b3cc48089ee8632eb483d3a9b32929f9982b46006983f2207e9eb1b87ea0966b15cd72669ac1ade163ad7dc3ba0b0dcccd79a5593661a17fe68e0554c64acd594a80726467951f95ea5255e147495a04391fad67824a3f3ca527d47f5171b3be67acc9f71620a895449d16c6c4651de7d26c832399e82cc04437804b3548733a290df8e0b08bb75a74ce752ed5e0509a6ebc76766252eff9470a6fce155ce813828af41dc5411355557a506312d53c69d7f0b09f81b6ef4653815bb21300da8cf35e73224048e3fc00717fbca5e279a14f32326649b3ec6643289962035ab624873090ad708ef5cfd24db481d67eb99fad3e8d50165d8b12738b2d4d0970372ee435ba72949dde17ccfa260598862d0e03c7c7439e2251c7dea8af5e6a3ea6d200843aa1310d73c68da62f2b917630f3ed3d18c318b7f81bb8c41d829c0651d8b12b1d390012dab2a2ac1cd24dffa7a0b0e42b5c9f975989d188e7c8d0533c9d25fff9acfcc9d91b662c57c24e14f3004ca2c4d2476dd3e28730abc19346dafd3d852ffa021fd9562e1073a17661b68003cac43b1718b9169b4622a7da9284fa73940b585ec6ebabb591bd753b76e5a96c1ebd1b2aa39cdd52ac931992c3e981cb31fb26eb859d897ef5dc678719e501cc95710f83c326fbcf1e95edd23043e3447ffd005775b021c22a19ac265d20bc73f33a74bd8b80d9d12e296110d73c1e00cb4f4d3dae1bfb0f5085530f1236a2c2d41aa287115014569d096d0ac32ca2b07d89d98c3a35faf93bcb58aef0ee4d1bf7349b3043b2302db2cec681bcc59d198f3dc77ee0c9f686b52afbc6501bdbb0d67b3f39967b7103177d899c713b029bace09e8c1f520aedacc373f49473f119b3918c6f18ae2cd615ad5ffd81530ca7bd643ea14b3a0b9f5e8775f54897d1686fc27748d509cb5bef9ab736ace09a48e2255886eecac2763effaf53179b44c871763030d13b75bbe6cde87b42f561285baf8b6b21bfdd6f82f61c33224e6b851620ae5ee729804ca3f21bfd0356f845d21b5852ec7246f1a2c9c28003b052639ae856230e390ecb19b1db53273d4feb0df508f6be2ffd42ad36dd061e0cc4d98215e1631b09f41627ef41aaecc6ec060ec3a08f021860a15ce5d92f82398b7fa45fbba3ec784f59a9746466be188321e40fa74d6754897b874a87fe33bd289835bcc7e4031aefe3611d582f01f7c02c6e92cffcf542eff1392b50100c7f96946164c548a6388dbb35203a9aa3fc946f0c9f5beba7c6b8fa3909f62711a956921f621442cad8a32084c752b0d83d5879844c08bfa49b3a6b63061ff339ac0bb80e079f97af5c361718d4dae8082a17d9b0bdd9b74166776f9461364ea9c1975fc184d757edaf4968e8010c18bf9abd344828f048bfac00b53870536609ba92255d03cda122554466ed14aa0d41af333d0adc5ea5a0041ba1f2bf67dfc76db69de3a033f3cdd8da932f2bed12433f85a1f12be8962fff9d5b546afbbabc7d97911504a21f47b505e9005446058bbef9468da1ba89c70ec6b125e4e5146c12856953cdf760aae84838dc0c0d77cfde2df9a14d393de19ac18aed55b3b508985b2d2813dcdb9d178b6ba473b3281af10eeb8f9fbc6cd799fca4910720f1a56004b0a92bf3fc989257cf692a6174860bc2d5378193aab0d589d69aa0bfccdb93dd1a5df0e511d51d7ebd0deca99801f9853d52cc5616d5b961228f56c6124f6f9bf0654c8c42d2f2997ef8e64003989ea694a7c8f9a088b7568c1d6ea0344c2e16be8cfc6bc9f94066d4a0e1d7fab96c03ca9328de71f2884d2633b58ac310e17923ac53e4af079004d958b92f385ff601ee8203010d6fa8f3edc6397ebed9cbfb7fabdabf48f22539c49ae1359ae1a129c5b1b17acf7d3379dfc74b63f00886933943b23b933274e768b4d1b027cf57efde632c09103f66b4e2e90b3fca92e235d8006d083b6eebc3f9b4cdb5433cb4ebff0282f2084d9221afbbfe9cb5b165639eea84332fb9240d1ae10fe339df6dcbe8513595547c626a6a304bd08decbf5f8e875f8965b7601dc1daa4e2b8a268cf545041b91e13de8dcceed441622dec516ba6147618fc9e066e5b51accb31be768e7c6d8e65b9b90f1f18bd0070ebb1e370ed7c21ac97b3d16587384850e9d17faf4a4f094d85333046f07d940f16ab603a438addc42fc4d76a8fd040f7457efc777320020b588e185f2291342ae90754cb6726a8a15d5a8f452bb1769cec509090c6a8eaac5c2950ea71f46c652860a3f26ead6fc5169c137cf5c7799a6d8f705e919c814eab07fa4ce669d291724056619ff210a00f77a740fac456f1ec36ed345a094d11cf47f738cc7178a95fd6b757f59ffd843beef0e02848351c9616ba06edf5a722eeba4f08d768168db9954ed42c7321a43d3781c24c5cf1f0ce894ebd1407e8c3b922fd77b11237c787ca7acf5280f41ee9a73f7b01fe49488b111ba16f1737465476dcb14f9647f45463961a2cf06dc044bb736cdd8aaacf8f836cb2b84d0f223d0a4b37a20143c7ca41650966c15322a5fb3cf8d081615e5b62dd92395b53d3bd1be70d0777421530d2be8e0a307d5ae5975f0c3025512c0f0092cce3b517e0b6da1449608c3c8ffcab469552366a6de8592e18875c1dc35da6daf4c833d13255c9b30564ed7534d6cff50d73b9bc6a74c0fa349cf280e25fb5b2015269c9dba7762ab4c54525bb4bc1139c5903b4b29035247b83a417d9a8b050203eeeb9fceb7eb6a3115f638206cf178f1fcbbcee340d45fa013772dd3c47a0f42fe255327c53d1fd99518a3433e21c2c55c098a7ce162d5b884b041b33f447b532dfd9e811fcdd1b2c923489b8371a6457b2d716995d669e19d2e7658a12e5dc89466153129b6c5588a795def67ce48d6a730dcf6867bb0e622249c519d6cf0958e58f6e67acbca64580683b1e52083e14856be3f132fef4847a2e2d5aae67eba6f0edd631d563b2c98b788de6fc73059c328de6731994d2af7eb2c21724c07807384d6caadadf818d7559e48f699f8b7f118d5b4a145a8fc6e347e706b51218d0891f5768644fde108349cc87f819a9e49963a822341f63fad683df513f63184d8002b7ca5a3692f2c4826c8dad63d080dd552cd752122496c2b952759c48afa03852ee3366ce33c19f6c477b10597a2a90222765ed38325def0393e5a7cd4eb8796e47f3f7d8909e7c57b641bb77f5e4b88efcf2da5881c17fd3b1d8193c46011c113e13478b3751362c76eb36c21548879e05ca956906ffd302e31975e024528c02c2642636569ef734541047876f44989c2d87e24349cb04e5c9b5f0a2174c1b051589ae1c00e5e13f32439792dfaddd5c462af54d2f0a492b4d48ea9d31ad58874eedda985e15343966b707c6044bb2e9f11c8be250c43a94dd5744ba8959cce2362fd2ebc10df1acea0a03f5784ab85bca09909db729af22cccf91fd6bd28e73b6381e6b220b2a67d751e4c2373d94e9d57d0e6c220dc9c330a08a6590e3e27140a6d8c8d5c7b3689717f1947474d85b5377ecf38001c32a92a0b52bc5d929e979b6d3414c07bcfeb057f05094e532aa1fa4938c0b9e837fc9ad70d99a11e290bb4d300f09085ae424dfd5b99a30419be5493fc4a0e37930b7dce2ed74bb1fe913c1af0e6b742b545a5c46416f791e1ecc033af1b8067fc8bbee6384e9d44f87143e67d83bb704786bc19eef2d796aa95c4a5a5f895c0e89f6ec35a2f733cd70bd701ed1bafc07e58ef4dcbe514ff104afc57c4ec849ad8d530a5ba746ab66684b7f86fa5991065633ac606f7fe962307988d586bef95e4a66e8f10ac4bbb78d0c2e34a34caa5ac671d917290f111a2ef8c09ab9fe6cb7922a00b51830f8213feca6cb573e6589b5fed103d43d542c5d714c542ad77d5d57949cc1010afec3fe54128e76c8eb1655b3dca1a6ebf8757b640ef38cbdd7e0e4ed01233f68814a124b12d6497924caa8cc1b80fd6cea81fd625b23b5dcdb8f91244546c85c6338ca5b41689b9174f53781a33bf89d4624170fa08d657da65e2cabfc985df228cb2d8f5dc8e028281fb460602c0b228b9c88a35208f20cd4d4b106df6989adacb2b3ef7a078c609a4c9a6686fc11479549591d5efca746fd5fc03a19d7483111788ab477f97d141b688cf6cbe4cd4bb09579902dce5ff512a62549c2aacf0c75faec0d51f3f9cd59ec154ef213ff194346af9e2529d0572ef87012d0ed479fd118fe67e3f50aeb43ed4c8dbe3e937cf29bd0244f4638a9de8990a48dea4ad6430b26e5f1a2e172a4a32eed5d7374a328bf8f5cfcb23f5ecf78bb489c5be38a1c56a4791263cbcf299a5deef5043796de657bb358858111ab8da8d507df8addef56f657590fc8ee99f9ac25ddfcb15bc22cc66d748e8c2c367b4bb9d5ac25bfa620d4994559ae444d30a8782fa7dd676ccff4f520a23b6c25adddcd202b0452bf07b3fb78810ecf5ebcaf871f442cca4609b1cf56f3dd56ba0227812af9479c86ec45f3cb9f37df0a7e05e4ce61f8c5627e956bfcf5d13b1f35a6bd1c7754dcd42d73a5abfd5f1277f5525fd78d66220260596de4228428db923bbcb2baef174843584bef0e521c5668e4783247bc0f32db616e6ec4c4d80640384472bc57352b7cb6fbfa096f7613e96efae1585904e6d72b6227e6944f0a6a4edb7999df3e0d6e0e346747ccfad17da0041e166577193d98c57e29020766c9cbe668d5b7bda6d7b062e13e32ddce67237bf84ecf6b4a70e1bac8f4d31acdb1e728c258cf5f3d2a9612857b188a29c5afce66cbd24563f1a83c99f9b191faab7c5713d25b1eacf9f5189d7fa810796c4a843929b5c55f1f81f6755d245f64e3f71bbe090670994160a7d8891ec92a1e0685f7354e00184b9c98636c55f0a9f8702ec7e6eaf1b7c353580230b4d234d26f4637e7bbfefab908080b861f4142937d00a7bb723b5ed6bbed670b0e3d1bdb826ca3ce14dc35ab0605c18cb39f63cbb31bb17fc021e36112799f83b3313bfb66cc6c3851b0241d8d8a1e4e46469b309923273c10abbda5b19486d74b2d025c8ab4aa11c1a7e2b910553f273a5e8c03764bfb733b1921436822a1ddd40bdff15e990b81d1f7b17cf33c7f0d3146b960a7d1d638cc742c49ef5a6c7182d77a0e21820a7f84a219e5658a970bf7466611edf784e8c4086a96fdbd0ca892c20180f70bf6c6e0c610b385dbbdc21d49e00946c37299fb3bf0636f0238639b2a24b847eb218156e88fbab2a765297da77c904344f54a9793c53f509d88c2d498a13229ab48dca4052d73d2ce86ac3909c02569a6a58e7ea13a726d41dd2118a4086be6cf5034865461df0aa66128456918c17d1f00ea17775e3bcf41a58658e23f2741c8b2451cc7fd9f8052c866130d7edac64fcd9d8b370bbdb56821671e7f5a200403801f4e15216a63f5f6005435571b6e08858abc25bfb76cdafab0dfb6ce8e4255017d9f2c2eeeae2224585df343e56fc27f60bd831546c5e186631730b4f923c5ef3914cd48530c13980f1a9bb8648bd4a132c714e222763952f38839470d1d96693986784eff71532b7fc535f8e686e28cf1fd8e0804a4bb25e35c0aa9b2ccfc9170e4be4ba37ae00f0e6ddd3d21bdca24d9e5bdd0732db74390d93bdc694a4d766e54fbafbc8fe25f1350c3ff11be79155cad0b53346135790012a79ff36ee5e9961453c37abdf7001d2be0914f4908a9f04552ce7a13bc54e6eec3d77287f636eb0638a6d7bd1d0f5eb59c49a39e3768d2ae0dbd7f03e6fb1c8ea57b4b87430811f18809d3189761d165de7b7d848d4ba1ad02bb7c9db8eab255871e1078ecf040c5a92eb565ff6925e2ef0b3af0970da94ed1cb5cd3c74d470de2ba64c0ee076a853da6986e09128b6636aaa512d3e161b75e0a71cb37ed474ca66312174999efdabfafdda32c1dd4a5d21647bd96a420115581f282d3a6e84ba1a578aede8046dfe4145440fa5f686f9f65b0b8895d5e355518f79ee8c8f8b8e28a79ed50326da35dc4f8bb6ef17654a0f16010b4cb46049ddc3284d9f41298974f13a48a21cdaf2acade3d36c0b6aa17f18771dc1feb508196f361536adad6d95afd3520712a69865b8756aab1751664b1567576ad01fc3eb3ae25440068a000cca25d958ae3ed1647ee72b149b1b9242b24b4a69808d7f261d7686284b42c9271d3cd3728deb1950fecb208d973e5953ca5c316aaf6a857e55b8e2d402b50f641f0f792246c87e18780f4f86751a2e2cc75553003768aa4d41319cd2d9bc5ea2448764bab1dfd175543e54cc863454617f8a8b16f5cf274711cd418330209486180370367c20f8b8f1fa7be95e4fb7c321b6a8800479bb2b39c9104f39e3cce23e79075e8d2344bb2607905ba375795dd6b2d0e80b60f0be14d827e0df6add8979ca859f794f4c5d84896f2d59289da299ed6a610ef188f8df17fb4b331a0e0a01413c9c801129853a2101f8966a10f98d37a6556c3df24af37aa79de6a46e09e412daf0130cb447525280441e32e689891b68417ec666a3d991a34c8414aad345b3deaf4655f7302a200f20cfda15ea06cc4f6c34c79a0b4d5057c38fef733d40fbc809f8721a87d1d3c6f756ae0b30216b45af3a2b189b83cc5b91e753343497e47a487b09b26cea2a0fe6b3dfd612a0122633663f5585830a7ec405d85ab0694737b2ec710ac6de2b44bdc5fdd2427eae3614d731b0d188248f2b2b19210d930e91e53917367ba6d7a7e6fe84668a183e7052e45e7c36ad4bfd513ac08f8482ac638a25de512b1ae70041b1cc26344641b8f6fbd00adbd42de83c5d3ed2940881db540d6494394be82cfd0b53dc483b6ad19ce4e0db4d7d9d413cc6a80687b912a6295e0cbacd3c4c39ac339956b4f1488fcaa2ce9e019ee8872e7db8ecf7420b7f3f67558e37ab6f45d605ad01543616e31dd1e5ee9dc2c12f3bf9fcbaebc5ce3a4845c453e714f4bc5cbdad7f974867411f84ef9c77de6ecd7101be1ea73176f9079cb61e0012d7c9c436bf1728dfeb3f647be87b7437c6fe5d00f2ec727d543ab6bb2dc683d473975f6ab2888802756ce3b1e813ae0e40bad4a9ddb3d5dd066bcfa74c6204f84ea6c47d648ebcc39cfc5b4dd633872bb00942aebc3aa09ae1536867432dd19056b0c811def9dcadd61381a6f670542165038988d389da04336ac4948e38ccebac2064d798d907f06601d5685f1c5b74f74f301fd9bf3f1e3449c772018345de9cefc3548d9fc43974b5145fbf378a675f296d3275c55e259ed287c830489d19108be326b709afd1e62a20f69d1af3ca2fb7213b3edb7fc965d7cbcda3923f12730858db05e7f49c29690a42e516c8e774e6f369cb923263e310ec57f4a027f7585eff6dd73f3322b0b1df01f839c58ed3b6c4288b1809924bf7b6267612551650f5c1555a1c163d56f480822f297b2d8b3ee347d44e3125ca9e96ac6bbdc695c3848e9125a29f1df4c1b08336c4196006b29a6f9c40b039c1d9489e1a4bf2fa5d6285ce0ec4bed335e578fe2ce1cd5935ca592726cf9ee8c8dd187836c136b931820b99b990b7543502ff2a44efe5a7419ab347a3bff9abeb63e937facf21a782bfb64a3b3cf622a69e644f259dbe7a281066ba5d5d5124f78b63ff86a8aec73ccb8cc8787b419e2b08590993fa45a00c3941976c009c152cbf6985de239c8f41d760a14536d82738b256dbb4068e1934f8b5c147ebfe9d000ac061a7791e694a3994b6d4881239e942123d1f7def6c814c3cb186436a7a2c14e0835eef5214759e610c820d49aeec8315ffcec10a91973e91d27d51a84989ce6b9d1c339a7269274a94eaaa8123fa865a0ed7986539043791cd22c15d293265136daa094caceb582f135d2067ad15c64cf2011ba4a8d64ff3c58148c17c05301a1b85541bef4ba7cb0bc0c20671fc79487fc59d40879c8cced89f5d98d7e29bac82fa1e804fab3b61324e9a7491ac8c9924d576a00fd6e967555e7e207d47067f1f9f3b78a8f83e11e9bcdb42482915ef79b6384c3f11baf9241abe44c1ea24386b81c9cdda66102ef730a4bfc9bfe1f559ed7f5c0bdecdde5c65f471eb50c067849f3ec45fcab84e6eccbe1e993c79caac3f35cd2fae9dcab7e95c60ad670dc7f1b7700008a4e705d8b7c635f92c8ae36bdf09648eaa821da88b1dea1f4792ade36c65cf3fe2a1a54c2428ad8b201f59b34f4be7212d9fcc483668cba22ed8c9eca15cb489e1872a531472399d4b12c707972a5cc0a02eb8ea192d4dd3a6124d375b6d0ce4cfd5c45dc0466523ab58f025886d579071fbdac57276abb4f3d393c54c0c228783ed12767ebf02daa1cd379f104e297028173cb48516dd5aeedf4bfe97076e673aa4cd7a5ce26eaf6ecb46c318c46e3e67fd74226d89e215f25e3f06f2209d7850cffe716a048a8ba0c231994b6fc88b29202fc0020c02b1991f821ca1ceeee519757e658c578cf13c77cd6b7f5154636f27c05806034ba8b765fba83f2628f03d9c8dc2f7ede0c3448217fdcaa75270656b1bdb4b3dd628ed11f331b0abea128ebcaf30e197219518e4da1505eee19f855321bf52a2e59b1eb4f971d992049919a38161f894ed936012d7ce0d76f4c37a43b1cbafde912986c19619d1c75bd1a154cfacf817b2aedbb9055e5adcf95ef96e83903249e83d900a6791487198540e0ca88facc2a4f8fd175aa2df3576f322c795f60af433bb59ccbd97cfd6b22295ebfe43175cd941caf25564e11a217da6f4c6446ea1f9515eaa2a27af9b9919efdc7489eab3dcfb39ebc7e718fd5d99c69bbe3bbf6ffd9704f19ad907df65b5f08453b31368e4c6704ce11175b7f25291c2e110c6c3a8fdc6ca6eab2ac75a74a7af4f2513babb6a898b31e25bf5537f022065e52bd2448d28fa8a6a2fbd767aee65acbd511d6fa5471008c75ffd15d938abbf4ca35945f8c61ed118365142f9b190666c4bc323cb184e77b16939a08b713d3f69765490b2f2d5b632ed5cdcc088a0e21377cb53631eabce01b3973975350318949f4431b44dc0254fd182d20a23739284118df9e1ceb0fe1e3ade3103396196e4fa6281ef9d7ab6bb0a30316093c731163faa6bd8d99ccdc3cc4aaa6167437a7de1b302a409f034b4307b4956a951c862b70567dec94bedf13627692a5c922eb60d608962ca52bc6d5ee209f9b5434dc6bdafc998622e901872f37b25bfbffc6cf0776301c151e08cf6acc9f17a1e92e445899ce5aa91c51b3550a10de20a76c4f6e50338bddfa5eb7a4aa50445e530c8dbda7040e5468eac5088b1963fe2ecb0f3a2ba0e259a5a08633a296bb43e769226eef564814f46bcffad248c144b3a53356ff0815903e7c9ba845d28d08cfd3f416ae126f8b8cdc0193cd849fa66044911572957d883946d989ee08f6faa9049fa663ce0b5161e01601b81038e27653ed68c7374f2f4587e3dbbb953d802b8852d14b4893d2f6c51df508b7e51e4d061b777d311a083dc42b1b9b9c983c19a3e020e66c200cbbdf188d56da08b267a16edd1b1ad63e9eb9900ee94efe909c9c1f0d5ab7b20ef6e26033b027fe6adbb76a68b943c2b0ba18120e3aac296baec4a0d5ab4aafec91668f11d625469ebe745366d9705f549971ce59f4ef0219972b51caeb1c66950830449bc7173ae3aea002ba7db8e1953102bdc5101fb61864b8fc9dd376346296f7dc7a9fc4fea40f511fa62f4ae7bbf9296a01725eef6280525c2b6ea02c8a71d21ba39166812e6004ebae3bb526a87244a6683a46c77868096ec8951f1bcf2c1ceae9eab9ed725eb06fd7ad47af9c9a25c59d92c0808b54ed45fc91e8724bd7f4c5fc6f06e4a6bed3b63bf13bfd965dbf1f99ae391a08d09a94164c5fde57fce15949b1137cdb6e4209df757eb652fed7e3ddb8ef0cb498677da62455d5d90d646f4255a5efd180e61d4bdd0cd127fc8c4a30087c2e49c2e1e892fb350b8019d9be1d66fdb7bf4e4fa0e6c84a25e4a7ceb2763f9fb66446e824d674774e7ecab80aa91d87ff79b6c1723c2259c313e83e3a0ced8a35590dae0086b3d40a7e78debc5c6eb3b6cf98f563b4cb684c5a7ec518affb93f8e96f9eda100f615900264f787fe6fddb222352c4027fd407a2c4151bd400d277094ba2d50e1fe4117eaec7e504a37211836d293753034e19811e1e736f50e673d7470d4176001c016ea3a96e3cc660dd42274f230a7558d718314efa3620a223a2af4d920085f81b1690d44cc6afeb4b65684262ff2b293e5db1f88b1966df57bd85e88c37d9daec469590a6be5b3bb057f0143e540d66a0962f87f650a6e429804e6b763cdddba9124e5241a503583e1e5994e9e7b013c4946aa2c5a198eae56baba23c500718934ecc06a0b8fa8f85456d9170e793ea484bc242cf780ff8b4b8bb8b9aa4e5c897e71c749aa5968423b70ed5cfe2d4cfee393b4ce368750c86b888061a44e3fce89f7b06949230ae3e76a803194647ecbdc1a865a3e9d5097924f00f60f5483b9d94f9fa5e08d1063784eedf2a454b30233dabc5207ee09db79d52d0c6f9e10575c6b90d1deaa63a57227f36d917d1a0558a4c9b09a802365a3f4084ea8998224d402dd5aae1c6aa096fa2d910da9784596074fc4c3f40569fad42de5b85c3511e06cea68fb723100f8586aea2107b61bf9d21ee0f4102419f35096d3201c5a8cfa3aec8d9cea4a46e73e6e17387768ce2cea3c6211fd4e49d65ee67c5098a51b30fdb79bb62d191cc3d3ee3140114bafe47e213da458c0299ba36fddea2ec1c9ef2fde6e93e244d8aa8f2f8c6cc38a741eb6d2c022f6e8a8c028d3586173e19a92f8990d1cb1bff4643c8d4cf5ed2b07955f25866671987f18ff1f232968b54a8580d598d2e3158d233ae59d943f0022daee4cdae115671741302500ae76de56635bcd11d5553f02426f81771e7bf9be7c203b77ac3282489adfece94d110704d7c2038920183f05d3cad2242199a508c45eaf985d178f63346ce1aef256920830bea5f77c625960c5089d692d2e0fb17b7da6dac8a7c7259cf834d6dffb58a67ae8d7a096db2718ca3dfb2284f0ec0d339094eff812ffb082ddacd42be8e8d879caaa6f28e3fbd3f1a29f891c3132337abc9d49ef311888810240e6aaccbebe3200339efa98632bd406a5968d18e0696f497da0c054df2eb587540ae5cf061a4041e16bc576627a7e4683e7243cb40ad8c7d08fc04958c72080956e7149cc304d81474ba5e485a6a72277f66b1e170bda56f302ccf3bb17fb504c2a44a60350606b2d2dd17749fbbc0c63b751e28d1ad948d4bd528660f99a6e2029a2eb8f2b32d25d84c836cdf2756f2525d6549bc6b5239255d6d6322d5d61f0b6b098ca4fec0e995759b0be1b9daecdd918974ddab2a213d8454bac88a3aeb59118041e7e36083aa934a6b467df9c71cd3ede2180bcf68e4a15e226fb1be54710ed5355f9660bba3443bbb080439e33d3437dddb3904e3ee670e4d99a5a6a8e518cc2d7bcca3f0413b97517582057a3462534fb11c9c16e75832ced6823359fe1f205607c487d693eb0178dddb9d47d1cb546126bc525df65e421421b610ab44cadcb8840b3a914f0f6287ac0a13ed6dfd0e376cf8498c05d7c91d10443d46e748c7a37eca26992750b403ac347643563e9bf4a4e62b9f4a2119b64a22e7dc55d576e660b3c101f624c3b40037de1e1587281029538c09c699c248a0f99a86dc4c3fb5e98495d9c29e51bbee936da7422871e7233d75129e4603f0cbc10d055f2d439da41c716cd344285538aee44c62870e6dc05bca961b1923849827af87a7959049f4268e00e11190ccaf902a5dbcca18c40fd17ec75723092a1ac815c6f0d5b805b5319985877ed151390d7aca57ebe05b60f9475cc316b69cd9ad05893ba7af80fb94d44de5354fc3f58edda9f63bc4e2b189e462c7a332044e0178fb5223e7bc5c81a919ee665ef68d60f9924c0af0e56b08d1d42f6dbd37457b056059c8a145243f4f86693f43ac37d4c0283534a9cd37483e96cc4d379a360e4781efad592e86b65f1a52fc3d5674f75d8eb2faf5f20ee37f33e6dcf274ec66b4b6138674c1132dce3b801063e785c5bfa9a445fd326554f8f7983898226e2308f1b67ec3eb5ae43ed41d4e38286aadee0bb4ca822a1def04914d421b35e89739b28ffc9076a941b4ae3cb8ea25d9e292813ef74299236b33558117e57e622a3efc18872842680b6dc63fa1467b60f3be1702bf1d836cc1d9ab77278bb07a335c4d630c83f1a12cd65ba59fa4058adb85e32b7f76910d7463116f10eb92af5d60a7ff11a641e96ebfae24be63225d2f6562b94fb6a53559fea692eedb7b9cd2df4fa48439de402d047cdc736ad0bb92874dfc2f91e3f92b625c925ac235dabc720f88e5e7b5ee9f6751c0a5c6c6de74da59e380b69e984b5c195b875ed4a8f166fb85e28379a8a4f28cae48ee18c92b59396372413135181bc1f6a0d6e5427278f310998cf25b4a8f0cfe6782e86b645aac86b858185e7afd5621ae521d9d498cbde3cbb8ee2644e7490fe1cf62b009373c82b7dcb6b9bf2d1c68acbddc23c286543a2ff085b063d9df340b2446d7a1e3da37cfaab087d774fda3ea33fc5dbf83eca4eff59cca62f530dccec02239e80e2b91e7f378fd0290913d97ea245ac4ec879fefdbeaf72cd245f690cdbec973029e55e5106104a58e9dc6884ef4c1b1b012b75a5a70da8e86ccc252519b6780322add2b160993f8c348209f1b9c8ec8b48e414012d51d0f1ade45ad9950619b26572db612a0034567ea94008e055b81b8de8019be1effc97a159ed1c511198925552ab53bc016e31c9115fdca3317a44e68e6e4765bf6b57f7b3608f184a79a15abcd7cdf429a15146d0838ab5db4e33d11f62b56da14b1f083742798022dd1f8867bcfa5daae2f0aaf2693876ee9896c5e7f5d50d00b10b36e89c732a62a35f0756162db2157c1757ab4ca38853e01d1ff09a97aabf98c9804968666dec103f4b39981e91ea0a4764456dbdb489f770829c6210e222906a49890178bef4d18cd76771e4d430e0d0d2569842ffc85902d283fa1bb1dd54454d75dd86a7eba190396f7cef893c812c216e4d8ac7df39de92100b48bdd72118d17f0a3d4a8abc084458bdeba08e87d9631e4f3baa01ad8b80309f943ce841df838c0e83483ef264be4250d000dfc8f6d1a69fe32d88166329c2c27da6e0f6439a7624e21daa27b9c421a04855d16eac8f0b41047e85718b781d8b16c7b225996b98701f01759e044a5eb185f51bf54bffa5a9612141529b9a0a62b7811e8df0a6564d294b799f0203e90503e6d43b2f9b20e9e19de8f449819f535bb7720606ca34b0377b1555acdc7551bb83f0eeba478283ee6fe9e042a84894c2f45aa087eac80d1f1270bbb525e5844b9689ed54b319ca9b645c54fa655de4b7c12348ac5c7bf6afc6699390507aca015d8583ec691b0d068a15b8a232af0b55339464c9a6879404693fc2b4dd768dabc67d3b1945424c336b5eab9fba8501b6bd0782189aafd7d907d1df4a39dd898afac60d38b971dba84041adf0022598a390047a0b4f7bd32cb6c62cd8b172f80a2bdab6247f8d3669f88fb58ddac651c005fc134b3e59418668315e4cd8330eba659fcf9ee36d164754916690d82c07d43b6b8dbfd458ca60ad112e7a04f8e4a75fecc8a32bff094a477920cb951f04ec69270e673a97cb2a48700c97a0678370829a226c24d72303c4b3eb9da57fd8d0debc5821dd3bc26f6722b51ca8256fd96ea2a1c9ed79835cf7b1473aff45d50e678e6186312e3ecd60771617b1ea6699dc0cca52ffd8ed68d19341bb1339d67f15512243c0f9a4ba32807f094e756614da0bb81e886c7154cb140beb5cd192781c5043391c83045f97707742285099639871ddbe1751986d178ba94f728d141f611c733bc7fe347abaa61aaca8a5558eb9f8408c9394c38d14455ef333922e48aabab2f89960d41762bf97862c7420c98ecb840a68bf787276092660b9ee28ddc4e7a896175081661a7a96ce756c6ffa1c25ee8355733f6f1d79f8ecccc87ad0b24ac193e24348f8de7ec80278711f7334ac99f2ff786aee7432f951936c7728c56905651a609e1fc84b9c4d8e10854c94cac62044f205481463d7afd55e41c28efda28be6fd310d566299463d492459848b36d87c4be47f2a60ca9a00a0eae75080f133b9d9c87c71edb3ae8b55c9347abb7d9574940ea205739988bf22a3218cf98236af97fae8bb259b07c56f426a3b66fac46b2245eeb55e502f1ffa4854a31b7c6b6cecb9c47009112705899cb772788d5ddb6f81b05d5f42a38277924d3538a5812713e2dcaf113ebd2bba495c692dcb2fa51063bbf0815df59538032a08f6f0b4eab0bf4e26779b93e9a7367121cc8c84bc1d9de793b102faef41e509730189b8a905a34e338ddecc7281d13166be7fb8e01e0ce60a81391bab9196b99adbd03a10c493e48f3a8f08ae64b570a4c68f846d99951605e08491f591ca0e920f6d38694fc1f602fdfcf5c524d661d9ab4daaa190290df70b5d85ed5babd761d0ab33e17778d66756c65f5d4b939028e98ffd787d66c8684e628efd3bd121cdc67478bc46f5d861518e63d54bd847c2b25be1aaafab1a6e49692dd49fb163364255056e7b87915d5214585c79fd19da926547ad6b81046707cf907b4205b2e732304dc75f53a7379a71ec8457718bf0885d497c6c23c4f46b995170e8f1e12d5644a198a37241e3198cdd8a901de520686075694a3925d2088fd7c431c4cecb120a9c3cf05eac2c6ba0df6e5b3354d0ba4f3b67846e65f04e7a32ad5c660c19543b42e4649e049b81ef29e7dce9524f009d7e617d1134624155c96e93013db442cff8afa3196bfee3f310cffca919561cb898c64f441f3e825df850b4231077858d1e74758ac3d599eed668694464b98bec14616c694390af244ca2e6c304cc2fc10dda2ca4a37f5f39feeb7ed04a9a0de19f234a9e8aee2ba46976d98066188d5d6710c514820b7fe5ab73cec087151f35fde8cea4f9a52fadf297d7f93914d80fff33cd385fb8cd2f63fdaad3007c2b66bea4cac41b2e63687ec1a82a2b9788b0f301980f216faa304e9aca94f378e481a457124a11e6d922063179c3490544268653e2ae44679827889a59f05017ef82e5f40fd740572add4143df82608aa4c1b80e2c38edaa3b473d4c84d8bae62e595b5124b47babac9df796c9d69e4c63fd47f7b498685dcb3596eb79c2aea73df389f0a3e0b8fc0453e2876e3040fbd2c19acb72ef0668849b5d9505240078bfcc043fcb518bb5f8f5534a0309d4c1d007b8bc15d66e1a345ed2a70f183873f1e4444d8e880f37120065f570d8d400da45153f411bb2ed77506b539bf1026f2111386818fec7a05f28c5ff7c59d89a702b574d2bf164735b198765a830a0029b16a4fc041158d7c16dc60aee2f006cb02c1aaff6e62cc8ba04dfccfa0eeb11cc5325337d98399252c73a39d636c4d2bd168876","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
