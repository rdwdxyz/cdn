<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d153196773b15c5098cc702995ef52ddae424029cfc8361745abd8663397d158a02e166fc1b00b4d5585b225768441c22ba5ff52c60d3d528fbe09cd72e2f8ad408ac26df27886cdb5cede7a898516927deee82a03437e0755a1319396b1d0e08a28371bc8c8e2f595541663b76a255f2b3f0b0b5b3423ac917d552d5a19d62aa1a284e2648916e79ce5a4c6ebcbfa0c23ca27bd7da044ba83ff94e12905e79e4227f044ef734248ff39623c60a257f4c95ed763fc671b5185312a7c680d8a9c20b2de87b366f2c502660f34b715a7762d9e4f3e7b34da946afa23c013dd987002746a09a6000cafed85714c6e742159ebefefc4ac835a3c17f512b62848ddbeef13e92f69ac3f0131cedb85c33f54e58e39b43add5240c727ff8dd67ffdc8616ab48f5d3283e6e06131e7be11ae9130587150c3cd23dd613ac85258bc5c06e181c5700999248c1e08ea3fbe881982f2aa3e339100e7d9302b4f8cc4d999fef99f68a7406d6b3cf18c0dc923606d455c3c9b33a999ae0064278fdb62be1552868f39990b8e17a2a2cf9e48d0e342d054aace8ca0593ea5e1c6e319b1f6b4eead79b0d1d4dc05f049f86b14d070281ff9a42b347c4baa223a4770ee9586dd3bd891d41c0a0f0fb5bfa25b98f55fc7aa6d54a4768471fdfe109aec837e591783aa6ede1e5d48d932a869145e3ad40c8264e3de4ca7aced96b99e43c420f120555a6be99413b43b9ba1053fde6e82f32dcdc5497723d1e72e15261a44d5670cf270a7bd28182224a71ba8fa18a5ffb0ff4f25d60ed5942b1a2c0eacfd015389f317052af2aaea4f3611b5ffd9693028981d68a70f371320f3b209178921e168e61f5e4078faa883e21b2e51b2edfa748c462dbe54be9b56968dda0c5fdc9f4a21a1297dd1a11bcd9e56171db56246fd4112709bd880119d120251f153a5b004d32ea95ab4001fcf78e4167acce6fb84cb42e12bdac93af83a9fa5b059b42656ee6707b0427e5242cee6ff0aaf7c4b380282bc42551c5add558ab47cf05718d5ea9bc8d8322f6d93b4b57b0c8b1f435151ab478dfb3ba5679f40f039b0db0e2dde503f6046f08ebcefbddf0c1acdb1bd49d4b5a0e9504e70594f99d44ad3aa55ef178f32fb4f4649128ba23e7a8af0e3a4f5e6ca7384e812ba4dba3a08a9dd0e99ab909bcc6f265f4d8e05da9a358637201f10b24b501c27e78411e4f85dc1aae0e09c2adf9178c1291eec9840bd9aa121e19328ed8b7a5de54c5b8b4f8997eacbdfd1bbefd4aff897c978953ca3f560a24f9e755179bbfeda88393b7c2212b43ef5b5f0e1d19b28040d12eca538b212301e05cca14dcbc33022da15f3fb0b5ab38bab24d16911e8ebe267f18d686c335a11e74daae362b7e54d00689d3c0f3fda539c5d1541818768f020065a20e57bcdf91f11d106a4edc2046b6d403f4f8b823bdb7a790c66c5e566226e7f72201b7e00e912502064a01009a185d81d98b769fd33fd2f93fdf19a340d4db287a2c7f9f0f65a4f8c237d77743be9fcbbf94752d1a713b2227893e703ab62fe9ce3c0ebf29f9bb481c2b29cf4e2c00694f290cf614920ca9bf39fd40e690b41a113658933d8a596e56dd7afdebff7d711c17f1fe96f1ba4dc33fb9241b84859ff23607e7df0b8b127ddfcfb2fae22a39bacbd3a4011ed720e47fb4fb1a6a527aa7b0a127c1c41375f9d4fda3c82eb3bc0862b4bbd8a46f8593df3d64b00b59882219164650988a65c275b7f5b2ecc2a8930d02c4f96f56d5aeed33f924c1a81ca2dab50a67b9dad14716889732e405cf50aeee9756be06d66e7606f4017e60024fac60fadbf3a57a5bed3d551dfa8fc9ab6e5bc548436279fcd1ec510d4697e3484923b78e81af3f256765cdfa88998c796daf6cccf7341224807699952ce2f9b7e9b037783b438595d5c59406cfc270a4b26c17683fa70fb725694d635a885e3d24c8101eaf747840bb2ec6ca59c3f3b59dd378d0766e6f42be62560a68e757260b77e9e09a0d2e568d2930e5b47df74c3b25ed61b17fe0f6c7a755aba0c35d428b05d387b0e03a28a0c333b928b0d836b0c168ad848ebdb7444c12b7d3c2820205ddc05fd765bc12892f402c8eb768e53070bf0514457c52b64568a38dc031395e73d5c41f5780bf048dd3c65beb4ed8b61194a86f5fe327e97b6559feff471e532ee77b8a217032c087b13b03b8b680fcb1d5249ad09147e12b17cedd932320037b06b319d31c7d201d1d65f7de51ee923896947cf4427f6452e955566400d8d5dca0d75e768fb804c9d245875e86f336637bba754df52f0a395050205eea1044141db6daf69c5e48cc69f5689114376ac8a1d4327ff72b1fdf81ebf80994b48c17d113e6b62d742c439053fccd37519f7ebcbf370cf7a8a2015ef828170a48c8347e98963a9506faeda0d3022527a5ec2f33167b01b3964ae72904aaa991f754130fa1f939b656614ea5b108e6f207e83e5bddedf2fe54a6168ca49178e5e7424be81ed5bc1b49759c75b41450435f96b6010664b0d801075b97dd7da8b84ccef556b3d5d66ef425a200079fd534f8e45ce7ffc018ee875a792ae9accafe59e81174607ade7cff8062ccf50a15b9afcab7d53e84ce23ff087707f855e4cb39da13e806709e50cc240041014fbdee56876c44140a6b36050aa14faefd53650937de9efdec31c8d059e6a15447a133cd9bd06c16a1f4aa64fc18c167e6ff3a0f17a972c57bf687ca83157602b6e3a272292f4a26ab45b190427f523135cf299acc1c124208d16ceb8296ac0b371579d0607b47bed511bdf9823ee1b3338040805f6c93b34e88fd67a71b6d529de14347f2ceefe6b2c891d7aac78ef39f72cf27804c57abc9253276b9d57d6fc89244ecdc6e3becc53dc38bd9e488047000dc5c3121f709e456e982891cad8503d66a150755a9e3b146fde29a364bc64a1749bb1a92d07805a18941fdf1066778eecc578549d44ddeaa55d0f2b6f7b241af776329b8fa606c842c80b1b11a23a1fd3caa5853eba0cdb6ca94faebaa94433714cfe9fbd73bd808eaba16c37e747be3d417d961804c3847a2bd238d5147704342f7e871d834760261c97629fe90b6d6d8b1ae875c6bd223dc504d1095af8e7389818aeef78102c1435b40b6eb223e0314238c212868abe383f959c0f9cabc736488f3394e9e1c150cca651ce38e6b4a1eeeebff2a03774297388c1c75b3d0f6721b2a762b81e01b902d90ce38bcaddafa3845ba3608b9f0aa1789faabf9c888cf6287f6044ade694162cc006f5ed75e94b022a03cba40f93d2d10d5f5f4099a104d97fa9002c136607d93d9a383c2a6a08a78bb0aabe902c35cd5c5e2824a28612e3cd7941fadd1eba5296518b8f5dd1226f4b6cce49eba25c3540145c8084b682ce111bc28d4e5837af239180bfcf45dedb6477a6ac620cc6f6013acc083e18f089510f4b7a910ad6d14bb24f42b8bd2c2f3fd587e06e0e4e9837b5c91769cb6a47ddf6371407b698f5d9e7d4be72d7dfa0e45c6c8099d6c1cad75f4d1d5f580f04d40f90af66ba3bc14b54a8c5efd9552aec8e5d9fd74a2f23ceccdec2b44c7d9524073e5b0c28a2e2220f61ed1eec945e52bf36adab7ca92de3eceb9a3aee20786411786599e59380c2bfbd877cf0f6be7bd3cdff4b145c6edc46707eaa2c437b71b8a374ec9be3f93fd11f77634a42eb2690738552cee4543b220664c7e1529666f206b653e71a616b7277b7880ae8b69a1cab5c9234d21b59ee8e340d07013281b45239881135de240d389bfd837f83a83fc156e9af396a0c1ca5d9adf5e311a15857eb6335e5798bea34b87914b641af8bc43f18524ce0b97cd71643c3a8fabe4c3c0abb666e82765ba1210324e007fb948bd1815a86914fece13875fafab26584154f83b12bf610606ba7497c1290dd406f3eab446ccd602114a85e9e09b36e1a8cf1230fbc8b1e34c447f66d288808b9c590d4acb2a20aa9a2597a0bc4a45259c28d610db5baeeff4730e7986c4960fe847cd8a3d65f0a78d1db370fdcc4cfe2b5245691cae0ec43dd986c1ccd21924f8576be964f11d470b7bcb09956ce2130e388e9f78cdf1193b9dc3ec805de67991d1e4568a5233cb88f8daf362b03bb03469f058895b2d8b195e876b53a187f87e483ccc880ba5327a455a8383973ed68de5cb3770c34ad53f9a1f6e4b78592ebe6dc3ab5a9a8beb70eec2dbd23d81ac21181ec788e43c11c541213a19f6205a72f912fd629f2298ba78fb1ff46a1b893481b6538a165bbc2c29acf2cf40b12194704e199845d4b7d313b6e2e77a90d7a566ed35f389f8f975aa8d9ae2e1a9628f034a28de489784fafaa056bdef264bc0f00b86c931a9bf5abff06cc936cade5ae3bf269141a6a7990c1baca6307ff2a6971112c7d27e5c217d5a0a83e5bcc46d775ed01d37508fdc166f56f2d3c856dce1453dbfd30ace5ba25f7f8e9ee8c0b800b1c891b44aa8378e425447bb80b77b573af45e3fbb099ffbd108e9c17c0b44537b8e3428b499d907251ea0191ac5ca63f35cce2a463fc48a7b90b1dcb7366b8a77f671fb325c3953417b3419f9c56be8146424d1be404f46e7add45128a3931d600353cfd286dc9e54e5cb7cc9b49aec491a0da930ddbbe65198734fa87a4bd0c650168a006f70f1f4c7efa6a936e95392fffaec7f5b6198ed78caf70b1740dce1ee86d542f32de73a43c32b1dd224e569981b0f1e0df63dc5f515bc583e3edf17362e2ad2bb817e0a06b23b2af5086f27d076f81afe2913e3a9f5f10d321eaba305205958d0ce475e3eb190c4295fe0847763414220e3176466e730285b45147758234b3d1103cff6cc3245d43ee6e1ba6d2b88141a6c249e08224ab95a8c1e28610e00b9bc8b8018fbc8b50fdbc35c1601652253bd77027156c4badb590b999272be4881e1613e229cfcc401f14588eea5dd9c8836f647831d1af7b185b07666a99f38f827630f536b94f8cf78b08a267078de9eed20c6666fde265fda5efd5bde30a25f73dfc8a49c27ae80936957dddcf58469206fe88053664df3076715798f6927a4eff22db93a7c8705db854b18322819ed83fe3666dc3a66819c063f221c967ae4a02477922107598820f3e360c3fed87938e41b0f9b95e68e26723663f15ea378359877a31e14b957530016e80bd12c86618996ea130f7a136704e8e4c1e821b2cd04be7df2af2a6a9abedb5aca07b42ae51be46613549532ee9a1a757a0f1398289d0003f011f3ea339ddd7b6a5dfe461749de9920570e2c03c41c858b108597e7e7a062d024373b84cd24550bb1e9a2bdeb4e369dd36315de99014254935dd13d4e5659016cf3e4837990bad7137400df4494e9f44f02d61a85533a083ef3560c293f30f28cf271afdb987c194facfed12bccf97e76cf8db8a8ae4920f6265cca03b314b0d56e2410a83d6c05b6580956d2d501014cc522d810de2eb0fd922a9036db4ebd28ce21b9bb55e72c283778839acd07eec0a63436ff6b1f774f3b0b63b77addae8a2b723618b72b044284a9c484c816c17be0c107bda96edd9495142c97d73d1e2523796dfc7358415ecd6fef0c8e7d8b77fcc7854b5ac34cb8977f210c4b216302993dad66b73259d52ed05409cfc8961833f40d56fdbf76bbdbd15c5bab1ed999b4c68f5b68aa5eeea78b57281c269d0a3ef03edaf75bb2cfe5de1ca409688087be554abd4d8bd5ec1023dc759c7b5b29402d73b52fb97a312b71a608e914afae5240ac3c4533e2a6a83748460a8e00bfd5111cdb74413e7ea6876cad17bd72799f9d10636eefb3187ca03ca7ca313a5edf96239babe9870ee4b2210c9e69cf7b95b896ac04de0edacf600eb95fd218fc221918720805b70d291df9b4842d607764e6d0775909c1e3a578e306af7643b5529b40bab3842049b620c96d1232da7d81c459111f75cad2ef48288db98303fdf0947f14821c6d0dba9b2b619b4be059617c48b10b26821e3d7a5573ff476e22f6c6abadced6eee8b1384ca8bd87ccf1df40ee62f7b8f92ade594f107bb90fb9ec408c3e467ae821bf67e2d07475bec9be11bd4b7b3b4f38be42ddcd78291509a70761ee4e09ee7263253f776684c97f4c84d6a7cc40724b6c3d4389f17c4e1e504907ed6e1bf55fd0c20581300151857af2f8663eb8c51f6e8b3bdff79991bc4692cb196d0c1d31f76211fc83aa09435426467bd8bc149c06551551aeb7b2ec1dc544fcc7e4463a9e434c6f6949921f5026111f5398a894ee0efb265e7420df477ab46feafa7b23cf897c1a146eeca9c4e7778bc0ba50768bca6ef94c10e3d2ac8c9b1f141d73a5c688c65523e11124c4d435d10b60e5d812e13fcd8d4b4054bb08c42c7d88c31715586cdc93ef1662e98cb6f0a659581478af2bdcd6bdf9125948e624a64f9a2c51dbff7f3377f383affa8beb7b23eaf17a0ca1d54d1cfd16daf2669957ac5fcafbe7eca39ddaf346fae4541388839385a35eb1d4dfdabf515fc56375706898a3226002b41e06eb54c54e7c944f2d7a53815f7f55d49b72e875d4a76814422f6d79594ca3295c09f27451767f63a5f65374ccb62c01be4b453e1a32d2001a25342917eafe00dd95d1ec184341595e1f60b80d01b458760f3c20beb4c6c2ebdba60d850c726c1b5895e2f23ccd04c8b51295b40c26a8dcf07e44258b22de51df3a8fc84248f9741ec321db835501cb73d40468c9ed0be1eb85c12bed4752c455c2a3cbd85d6fb75848311da97affe7edf30ac712be202aace2302c3655d581fa67a031763a84c11f4033fba3ff28b0432852a054e08a5e3a37a54d25adfb428660d075c6ee3d8abe87572731fc323d3c68a03c02df6df90aef418300f674fd14cbf9679279f8f5a5f73ccf04d5f8866057b6108236ce395efa8fa53da1ef86ab558ded7654098cae1218b80980fa4bf6b59039462b95bc3e18bcff148448c427b68aa95077fa3e29f5505e27a4a35fb564d52707f27f143779790ad6bb03d41ee8aa06ee6bc99f89755c6f48cdb870844a9182c293430fbba7543b872149403bf6e250de540fdbb8f92d682d8c7974b9970342b6ac323ee61da4f25aa4327af161c81a098c5f7d3fd6fe835353a20b42a3109529516c745055945bcfcb39627f9fa0340c5ebbc10a075bae4a417f7d085efad6ed2f5cee1776373edcd4c76003ffde4e12e1d3972b9a5a648da35040c7140d1f9ec235e53098b30ae8f6f0c614a49e56df0b0353efbc819c734bc92c532189aa96d3a15b8e51fb5986601ce0b4340e9ba39e23c310a77627cf3cf5d9bb31ed3477155c3ff1c2c4ecfcfb34a619855155c61016262d6dcc635aa048c075b76fe0a16ace2d56d69096dc24d3b55b184a7afe6beab364c21e5541d722aaee3c14f45935c269aa7cd3fb6f098f963afc77cf353ee599baee602f516888610665d2446d1ab19b1b8e19df25e8f0df7f40fd828eaa6ed595d8967a3e622f82f845ade15f27ebb298e1fc798826c7979026c40e2874fff8e5db0f04e444aeee255e8a42ca671d8ca66ac04b5e3b4d92c844f6ee7b16c03e90f705ae17e50f590f54a6716492d9da79f6a7557c7fc6d97380524fca91352c97cc2bb8ff3cf975b979947d308234f537faa2a950ac329705783b5effc7c9a048a527a9023f642e6df33bbeac4d13e265dbc96b931551ce9c69d052337916544c01c7cd18479f5dda78b9d0c2b354641072fc73e9cc55b97afbd39cadfaf3ae5578217144f227758850d4393fc82c8603a494d4d884904a5a98cc164ff6f97958b4d6e85fd5c8da2a951e928879da62a0e45a0eedd4d97b32020185b88844d0aff0f9196b5e7c798fdd5a351509638d763d9d766685896712daf08a8b7a6e58ec51c2529b3ecd5c05090515b3200f37b4ee64733912691ac3fbdac455e635e6b4262e61b2f6aac382391f6592fd2c1265fab0c936cf4ead5d2161fef5cb639108591269a858510386b6d25af2cdb2aa9782d155adf724b9d7d7b8645758686ff2d98e393088208da5702e3d32f4fac33d3b257bd41757bdf63d322d11d7e9a5bbe4019aaf0422f04278e766c11d0d6ff4d93f9f7f3944a89c893f776e1843dfd7324bca85299ce8d5d11de9aef4f8faf9bb920586ad95f27b4fe071cda5780619b9c762554338b0021c675fadca1b3447a1461e13a58df53fc7684565d60308163c8498c3207d9c8250df501aafe92b5072de9668560d560888d1554b014bb7dd85a95a74cb10b0850905b32e6cd475df26f3cd2412f401fc1df837ff50fdfcc28115bcaeedae34c32fc933f29d39831e7fa28223cdd09f7748ca688a40a2fa53197f7a6db13385d3a09e13f058108737f07c833d1c35035f165672adbcf85fba416dbfa15e6e99843b7b4c13879e9f59b8b68ef2c5525c82a2eb2de69b65f9e0064f6e83c15a0550421a7f914c4b0c147e8b691ad6e6d73482bf323fc2082efdc952493cb9a71b982382dcaa5bbce6da892c2c8e633ef5e285a709d80ec9c2c897a0e5658857724b81e937954e58efc252c2ca0b4d5d74d6f0fd4aafe6a9b11356e3eec1cdbfd663c17d9d80a40d6e403039f0c3f4aa2432f24bf2fd83485bda543adb988559dce1d0ac2d5ea2623bb182fb5c48f0b95863bc7147460db3566f5ffcbaa99646914000417f0b184376e3e7b7c7a137b9952459caa9572294de06a3e93f19d52f24fcaa4c9083e01ad680841a0c63cfe27fb78a26f17b20e670514bb730c286cc447b670558471855550aefe89196039bd25c51a74188edf148f17d996aff50981405f7742cceb08b279125795591548fc82b415bd1b9ddfb5bcfe885df8e42d302f8782f8f83fdca8d0801c7dbff7ea21d127b0b8ec63bf1734bcd15ce4ee96014516d1e4dc2b883c2c230765b5c92a0ae6307a9fe757e326c60dda023c9017fc98412a2313701d94f38c34f9bdaffa652f95b8fa8acdef8430a5af8c2a1e680ffb13c7fe376f3987dd490721dc7301a0167a1116ba4d8fa5cd7d35f922ea0f6f531b91005f66cf36023b0bc01bd41334db2d289e99f893e1266b7c7b56cca963f64d476893ff0d692522af009d0f92a5b3acf4afd53ebc687c61aaec87958a3d58f32f5100e51174daa23def9a7f86a6e6244b089a83911487001843930f596ea03a653657fdda0fd81d3348a27a41ef7d75e16c3c2e79cc0b7cc03f82dc4d10bfa39d604237ef5ff94ed9fe4e5a49754626421d4c99bcac8bcf04eea5a265b96b3ea7bc648b9ce2dd693b51ef3bec85bc3fcf441711f7434928aa4d74be8457d29d2150dc61917964670319458146c0199c4b67de8a86d4af4de0e59338e5b0a3777b5a9425444a1fa2f3eeae739110fb1647ce4d93d816c5d5d1cac07e5546baf57eedfdbd670b8f4ad520658c4adc9126761ff0aa54f1ec38fdab5fb9fdedd54edbc77c8e9341bc6ad8a704b147ce500e22806180bb2432ef701a2e460736247705b5c59c0ed32b76ba00a1dd0554b37fb7f2d0bc00b9734a912674d101a4f8a196a59e69fbc62c08c40b87716719b4a8c0461c78ff588c1a7b8467f98db9a331611c1c8512b48c5626b31fd0f9e1c98af2ff3e94c013cbef4af754b431cfafd7a1cafca6d83788358b8ff4b483a9bb90d4d3cc7239419711ed9edfc96057dbf8fa6caa4d55db47a6f77d27fd0a4dded31a93042e7e084956d6f708ae934f8b9683fa6fa8e2ecd9696313be30810dda554ed717e26429276321b5184837140eddee4514b6ac4d4ad5385deb709ca5e9597a1c6d0fef68583e5053e48d143604a58012ba3290e4d9463eef38a7dfebaadc9f6a49ae074b446e3a84a25f5db687e40612ff5323e0119452575bcd1039c3c3012ba95c3520725237da3d9d7f46b9ebade3222b02889a9f00b68cb1b5be239a1f4485eda54cc697207c655e60591664670ba8e8b453a5169df0161c67da7096518781d01d54d561615370bf749e42d5cf2d6ebd714e3b688441fccb55a0b8f379cead1703c129b2e3b66f561bb6476288394373c4de6cdb9e81cc7d36ac9398e381953cf61ecb8a6fb07280cd2b5eef4e6df60bdaad86f2378d919d4b3472d55fe21aba2630cc025571427723217510c0bfb7fd28036a347fac4aafabaaf9b8ac765e517d3bbe6e7f93a4baa647ed3c5b95a9b942062faa3732edcbbdbe387287f5efe0c4477f9516b37cde50d740b9464dee69a775ed2322135922b44762c750f17f2847c195267aaf7d49c181d4e8c00b3f6cb2aef2c0ed869fd0fed70d31a889c7c9922b9df4236198f2465e02f0cd49569e17f848c1d3b92849cd9093af7050a8ae90e2b35e27d13a2acaf8613b39e74f8ab17e9137f18b8b5005676c8cf95a49c954b8a4a3271ba423630fcbbb9e3b35f81ef1896f5d1e21de75b0829273bc45ed45c0e348c19012fb56cbdd9b1fc0173163b34bf58aadece9bdb74288c8cece0b7a531cf968b0649d113b943dd8635f11a4b7e6f21bcc1c1d305462b6a8869abfd858218ea23ba7f5b0ec4b0f7c411225bcfd2f117b464e63bd0a68ee60df8a6c8a4fe2666efc1e93c139728936817dc9175c85208d14ce18bfc6cc0a9fd9ac2666d2e93b71b06afa55e1e3be1bd2509306fa0284f18887717ca7d9f7a2d5a61f1c1d1dc80b3053ff3d0942b2eacc8ba6d4b253d3b31472c76fa7e594b6240745eba08054b8b18209493d342f12eb8f1f6db3d1d0ca246dbfad910daf1dd9d6caaec60939908685453e29cab17bf26b165b94b54c3ee4af26588c9dd42ca341c347426f7a9302cab76979f3a7ac9ff48b4946c63271e5eaa14f55b3b10dc00932fff824c8aa861f083e29d21ab9e76670f2169a66746328b219b7ddd1a439ffb376135d8d385272aa1e92ff2119891fdb9ba394c0d6b38747d75758c1cbf25676e2ae136af4deccd0912d2f9009d813a770b21480e7830b104a7d621dd17781edf0cdf6869175169eb784c3bf281b385fbce85fd5d1e6b4fd9e06e8c2158387c530a8d3c1e3d3a9d9931f9dc2a5eb890a89ed59d21b4f1aa62a43051cefedf01bf6bd5605f4c8843087233b713765b3e3c3eff47afe151cf86e710db2dbbf260a53c30ac6d3baf739bbabadb5c31aa56b12cd09cef82da01ff25648408984b74c96af0a0a2b99b3050dcd6b4c4fa35a767a97913e4251074e9d51422b83f6769b7bb9475ee05040c72489720f5f83db3c19e361703bd297ecccd49f18b0477ffad53de4feb6a9d8f979ba902afe20cb5ff77929e159c8c8b71925db4c3b2a0f89559724780eca897df592364a2f21bebff1f97f4cdf69fb2ace96bc203712383a340e4b0c48783881941c1f7440040a2d5575977ff46cdba96b6c047d253916f13eb67f1e32d4bab4b8fedd90f4c954431b7099be59fac5b95a8d0450917548fb2c258cd66b6be586fcf6300ffd628c85ce55e6604523497ee5d8c859649b60208c6ee6d88f1032cbff21a0f48b901e6caa4369c8f91dce479d24bcd17ff0d148601d13c491c0848776d1dd64ee67fe04afe18bd79446bb8e470251eee750bed00a5241e2241938250151cebbf3596a457a3b278944661bc5a0c4c2fa9168429069fc60ee3f2e3be1824bb0052d6aec14f3fcd927f6d62b48a3f38ef45758de8fefc57b5df0e65be6f65afe97ab8a0b88a049452588ae672d4bf2468dcd042eafe8efed2f5fa4947a5310d7bc321e60883e326eb21ef9774c334f873ebd4f566163df0d5c607942a3949ca781fcc6336261adb74e36472e61b3c0b0df81d9bdec18a854af00b312f6f5df829327196cd0646a7d706eebf9ef1753179481438ec7c0035e69b749818d31f8526c556cafd5624012172980d64a5a01a28c15f894d40d84e240c2fb4a3bfed1dbed3d7c439f0480b0d80eb46b3f1a16a8ca6dd9527dcf17b8486427de7e632c6cd7ad140b2456f4dac0b47222d87d9300f36eec3ef46e16a2342ebcb6a80c54e89b45de73cc74c465b2256f713a41a28c5091f65bdf33f84814d0452c54e6c8985eacdc25ab4b127827a08e0ee3b8f3399de91bae8ad4d7ffed5772a603ca71734a70c0dd813c738e9824e805959daac461008eba262419222a5135e32076477224ad572b9f6730635f2b7d4179bacd2d3d0cfafe5cf20ac8c995c168b53ab7506fbc2b7dadd42ce12998f146f872df1c09cbbd59d4374ae9a474f4a02404e3d0ce0fca977153e9bbe5a01de8cfe839041fd4441f973ffa0473466e05633911ee5d731cc176bab168b01b75010c6e6971502e07d96fc3813567903b3260c000b86aad78aa0d281dcde1ce541c7b0e456418a71c48546c683dfc8073f16e7307ac3f7b74fee9304abe1199ec23ee7bdc96325ad4b1a44ac4c280f17ef94eb2f763ed2346f7ab6f5b8c42dee3463460fa1fbd1bbe37358424587f78c5fdf5601e08eb3ce2dbf31a438cea8ed09be011bef5176e88b5fda2322e629876f82d580732d488b0aabd74ba892336aae8548167131e5b2104f39a56498c2f20498f27c0e91a4b5c72b499b8ec712fef9538cb2b5d4dad7ea7bfd24b7bf6dfd2f8eb7948babe13a1399c856f9ce62896335b004c3381ca4a2afde47d7da5cac5d787ce65d39440cb7b6f9a7de339faddd45de4458ce854d557bc8e9a879de1be5182293500deeb43bf45505fa2761c4be2dc2ec6fe94c9aa5208867925cdaed1c0c7f984a238d65364d7252a2626deaf79eeff553106d761895d715baeba43fccef5aaabdd8df318c95f724ac4c3a487b24ea5ed36846f8f06364e5c2426a6f537fcd165b0d893f1ce06d81cd967addef60d0a1e608a7db850120b45f6a7117d0fb39bd13d5bf6721671e95fb70715f32dd0b33cdd90bcb99759e57ee40328fcedd43e1184bf9b1b30da882a6b77b747db8bda67762abbf1f9c59b8e428d6f4d27240bb9d2ab92013c837f6be0e1c540e21e15368dc45a43e3e470c89f2b7a681e614437fe321200831dc731b6d2025898690bd2cfed1e34eea7f96b2c981434ef14bea0a17ad5ad2ce2215ad7892ef86fd1e2b27ed6af4d9a9d4047df0d2d1ea8d6946881d38dbd4beaf7846664f0624e26eb406d39ec0022267275fb1f668c6300c1eba56928ae49382f4a0d60d5ada61b59f23c49fcef791609294b4bfd780a5e28001c5b4273279394f12f965ca3696cdf7a0333740f1208f69279e7a7deeaa1d0649069b2bbb1b0639b3708797c0a8252824cf8b0443fae757e5c6c92537e5647ce616ecfb796cd7a0076e7e6d896f0e00789907f6bf42595bdd7a8c1923c37abdb270fd7aefb06c4387be03e35f959049a22cf706908a914618b88bead8dc276677333ddc9996bc0ab2c36628171b4b403cc0ca385d834e9acb753f55f82609312caceab2f75756c5887b42b553b97e896ae4ecc6cd6044cd0b1fcfe9e20cb45e1d5bdfecb50dbc925910156aafa0b5e0b62f479d8a290c5f569027bf2ca88b1c0f98681a2acd448cf602351a52cf46086c2ffed4034919dae0d7a0cac0b5dcf6a03a17e6ca1a051232399bb2537f7c7cd80d7329a987ab2312ff57d7748f1f9d323bdba855804f6d0e52701c9181ba2e95791a697ffb9b7184c2ffd8ce6127d8e850c254e5006282d34249cee6699bb1c9aefb820d8b6991824b4b7fcdb7b2df282fa0c52671c2e03a0fc738ebb8354eb7d7670f0bee5e9c523b380bdefc0e70534709eb590fe4d61fa19e5d3c09ae86f5c617b482fe6c62628d12b31433d64f16c5a61b15ee0d9d44fb7c340fae2e093122b3f04388ee19ca3c7183f82b4ea83bbdaec6f3d0f2183dd9fb89670a53e83092642b82997fd6b51fb48ff51cb9ee5dd8d512f9a3368774e089ddd2ca3f0d7026ea9284b3d7450d0e0b9cef805b28d80296986751b21140d012f5a761d2fa4f001239eb6023dd42e942448a1258f9b4954225d94dfae1400e7386d47f40a12a15babf69fddbf21e5603b1d3435f1becc4bbb806c3bd44e0b8be7ccace4f57e4497506fa7a5971497607acf5a12df3aa130b8b1630995e4d2fce533bb41d0977f82d733fec52f488ee4c3221e126e68fe130d5eb9438a8ad7b78f29533712887e91db631f44257e076d3cdc1cbf9739bcda92fcbba374a21e3d2bf1c6c5705c4df30b03c6182864846ba554c05fde1878bdc9fac0acfb0916c8e280756b9540fc6c0ac128e551de62cab54b78dcb63bd903fc9ee6ba455191500d206d51be4ce269040f6c4da66de73ae1df5e163dfa25e99d97959f495b8599e6b198b474c4f26181c0b87761f79963278aab57976840e5725c86ff5fecc35b6d7d1fb2aa2216ec5e830ff64492cff7d8c11e9204ec3f1fd2fbbb55e9f2e71771698ed0e31d082bac857f7927d85ed6e3b0906efe05c106023934a00b23b8225b2224804ac00ec0c15e5c19a8988b26a0420ff738a8468881b675760e4eb018216dc7aca18b8eb2b6e58821e3c7a6c81fce3435a50e1d902376b248b9b5506f7b84a4a6aa95e456dce6a81961f07bf0869ccf6da5070481bb4e66fd10ba151a9d69e637646d02c2f49e565f0bd968de4be92570f0f13b24a482a71c5a96529406e2e06b176de0798de532fa3d564791a75836d0bb62c24d3ad297011507a5882cd3abc09b588a8e637349ce1f61213f265ebbd6717c4be57b3cad7c901584651af6dbb96c3421b3e862b19ddb85911bce6f66c3e229cd597614b2d57386a868cd070ef72290a8181ee2915b4e1e5b005595e2da736712c834349466002ae8b7cf73178db10e902b80dcf714cb4809ec1bdbfd620a879c0b7aad048a674bf3bb4f137cab2f476b952ee978daf61213fed58840c8b2c0d175fc1d0c218f14317a2ebeb0a47de71b6a4bbefb3931b1bf31995510d02a8df0b945078bf3c343a6c01038cd7db5f3253da9b28c1f080b77b2eba74f1d5ee6b979acbb9480879554428b1ab5cf31374c6ec56cd5fc0bb80fe4ea8379107fd778837aa07bb794c611408c4bdd31b9e4d4c92b9bdd31b9e8054007e4e0dc4da89211adbcfdb0f11914ac0f133b9d837f0054cb30744d6be77c80393d9e6e11570c7c51ca4ba7d811dfff264368540a75f78648a3e121918042de5f1d5430b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
