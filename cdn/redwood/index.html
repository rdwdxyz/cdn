<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b819ac56d8df97ea657138ae9ba2cf283159055c60c27aa1fcce755169d56c2d69d780f6b7a5d4079305f742497bdd8bb479d65ba85c6d4db30ec41ee3648d88a57ed80e36fc3bfa4777966884a2c660303579f860cc28aab53784dd7fca1f91d5e42b562cb468eb75b53506f59c08721394db2b204d5b38089b3a2cea40f7e9bea67c18546773b4be2cad482d95d27538245afb0e3d0da104380057c0f60b8c42d657291ce40c88902e761c8f1201e2f76e04a766687f2f8bd731003443938890ed893b5f36bc778a043ef7b22ceae05f0d989e0f844f81b92d1bac2e97f06f6f7e1ab0945c22f2bee76167aeaf8f766427572497d79cb0b90804251a09b19202bddd5e8e9c3ca2eef0a2cfa66825c9da67434785129a2b7491f8bbd0ae0df57ca643fa55c5df26ff1a53aad94019b51fcda1c1b325c01745cb3b0644f0c2c98dfbe566155853a7205a4fda7b0b7f810fd3b15d4dd56a55dd5fd93777b2590cf3d510d9b519b45d093e71625ef688562854383f420871cb246665c31aed8fadf37ecc0eac58f66612670baabf148aa52fd399a4b08439af9ffe7eaa57b59aadb33d4757b2e8b0e7a025505e2b0c287b9f747aae628a58334e6c63569be60801742ccd72d130a30d43bb6488ae47be8788078efdce7e749a5b274fb53d5e60ae406d42aa25eb7ac4f6ea2086152577900379aa0b906880d9b4f540797ed00bacb2d90a2919944b480782c2f50a9cd3089de539dc7de0b9a43a7d7c5f6ceee32520e256c9bf6565529110fc9fe5ba05606059c8db36bed1c3c793ae58ed4056c799d58c606dcb5112a2f1603ec33b6dc8b8594d50061ecfc7c7dcc20a86d82c91209682b5d1cd302d63e00b529510969e24a7971ed1fdd930ee21dad5fda66616009886784ef6c97a480632ce4f9b2f60417044aa99c61b75b77ad81222828b5e038687589d31c8a06e8367a99dc0c1a60d814f1492963817c9108bd769ef688c035fefff399a3bec8b9fc8b4664abedf1846b503e8d9fc900011d834de89c7580545b215064cffd7f17289afdbc8e9af6c1ec880176f9e33f9250947a4867892c3fec6115a80d6a36510ed44968a3551041950d6af333754403662eeb4e0704c48e541abf239ea6723c244f1b2e1e10380ff8a544a56b51d46acec9ae2f0ef4554197e1dd2308c4ad42bdeaf0e7124a040f68ba1149dad3f1646dd5df4b741dbd88d84de54c01148a61b4101e8678f79eede82f3e2aa8470f5284de71a598bd4373f4e5c190f8e65c7618d3904d1ff2a4e4155077dfca2720f14dbfeed876b79e4b87a9c489926a1c4c86130877551dbd74e3234e86b4148816bc8c1d304251683a2bc43e5101e4ee4abc8d28a6664a5ebff19c5b084bec9141803c8fe726108be67d2b15ef031b6edb11ef2f4ee56cb76b2f4bba90bf269f00f75b8f237c177c229bacfd6fd6acf7bd9b690e4a0f0e9fef25341c42befa5b5394a90545dc2bc18c423fb2cd094fb28269c6b45569899021f15d2630f3f732b17135c54bfc5599ed8057e6b863d05f2a558a8d5261a9bac5583777ed345581a41bd1eedcbaad08c4c03b5960439c36e54f55d27d67bfc9e417afe49b7f54dffcaad3a6722f808668ca405a6c132be3cec194ad5060d2ea1aa25d0ab99b254e0970c327515413f16886bb682f5c05a0cff5dbcb07714bc4ee501780f6715a03a8448862b93bfcd27ad913d74191f65a356f051a39ead628d71be9b543d4b74a8fa510df6c8e03f367a264ed7e2d023567b0a696534cdb43242d037e131a0b72e13954b8cd41a0d06ccc7731f75bccd81f0f26c0ab3d50a10113dd5c87621499cf1b5d591ac6d7fda572ba55db02351cf600f27dda847ea7a093044b8592f223292470fc88ae550e8ab88823efe93a31520d744769de39ec3a0b9c1217990b3024f6cffbcfe0839311ea0fe24605d9519b46ad1a1308d0e0393429dbd4d2040f93c70abff8ac81b61da30b17786ec2d915b812b704ee2c6ea8eaf460af2a540e2f52427246aa632739fee714c1d6d67cb5690bf0cd52acb72a98edecb7541673130b020cfbf05f07f4b192de7b44b6984ff75316dc415131a3ad31b6dcfa6357f115c06196fd70c05621226a801dbed506411569a86d43052391d97addb2467140f1c7a59cd9a04ba07aaa1ead9d338193331ff9c063f89ef4af71a7ebfdd43c18dad31e3ef3f04e38e36d18fab8df6c9ccc5705fa54bf325a96b2159b19e0003851387f71daf54104e3ce043e83398d4e5fd3922d978a9ba5a50ce6a05d71962ef7f92d338d329f5869aaefae2c8d1938164b6f561d184721a8a0a9610c6c3ff2a7d3fba59913324ccab5ef1b93862c038f39273f9e012c863d31a18938080c7e232d5c914d3cd839fcb33e29d26cce148035bc4e68dc5872303c726058f35ce0274089f69cc11ada9f1d54b326920487b4a3fdd5c24603478245d7e09203e5b56ef12e2035959e3a2ef0e82cf6814d0caf9a1b8cb63e776f3d82e89ded5b5f508131d87fc071db785c43b6dc2e72f89efd63c2d026ae5852597704dc0e8d3f739f984fd52f05d8e77cdb48f7b8c6385d48a6f2754c937e5788915fca91613a91b7ce5855315f5ee0691d74dc065899b9dc4ced0032eeba1c04c6fb534f78748bf745ada70e6bfa1b8f166ca9d2640cfd17e9bcefc37f10917aaa3ebdb5431d7ce522671f8a0496e6ef4820356b92eff3dc39f153474376db479e612275ac69164e459bd762634505abed7c9f0626f77b8a3a84e16f836fd6a381e1527d5d0e0439834337935e0866653ccb8e775ac5a8dacacd5cf16c1113da0a1183fdad2a03b123302c09c88e3ebefa3e433624d0bc6ab31f7264f27f489885ee19bd5cfea9119b4420ed2e3989cc49869c8df7d6d3fcc4414f3b82d2ad5a61c3a2907054e1a939d154f0431b734a7e6c28c383f6f9ed7eadd4dd9a323b399c2b7a3c41f5e689eb0b51ed2c89d44fafa56c26328e9e6971f5d4631a598df2c7a244bef87eae1a3b8fd1b1c238dbdb9ee38b3ce673cdf63269ac36240a646028a0edc7f3f18cd66144066d0546b1077301897f2b14a81d5930d69002e04a5deaa7dee4806c3afcea32eeb4775809e6c55b861ff08c11555dc142ae23b558f545791d52365d9f4d31fc7289d63cdee25c10bc852258e5e3778f20dbb61315e5ea1bab53ee05b0fb344ce6a90c0602c9088bd8f3bf0cad1b8de7cd9916e009de0d0ffcdd32126a714d3cf5ee01d649fcc99755b9c637187101190ce9e16aa26705fae555d8d6775d03179d71c338c3a2a605a0d815a7e5021de4d12c4be115d8795a37e83c4a692e4b233e88329e09e43b810c1ce2f927da8b05b0c75a9d4086fcfb154245aa191536b8466e9e18d2078ca90e2849d59fa0e8123afc41ba04a4c67603e0916281b17ff4b1431b0febc6a0cae2b9ba295baaae150afd971f282e3bf8e4622d7b965e3fa4ded615f98f67eed2a0a4b633886abd3610566688f4bc97290da82c3162835ccf76efb8024ea4d6395a4e410027ab601335dceab4f47047bc60b944a0a2740407cef636bbc78d4829b46a4952da139ec344ffc7df77e9ff6045348a40e2a75e525184701659da0345dec77660472a682043b74384bb840cb15676dca8818c4501bb6da8100f812db321d7ecd105540d2efbe2682c56de9c48b50cbb61e55d72991209f12fb5ab1d04465db1e943c0283f8eb5639a477f99caa4d0e4cc01df5ce52daa1c514069dffdc957378aec32c8d4f95b8877da8059e9343ec94154ebb9aca7537876c92f2680afba53c431ab8090c583b30d457501f13258159b6e2d684027335331d95ca4619be5fcfbc5e35c29e3de334213b901f9a0bf5bd837d49c2c5337402ae2fdc8f35fce6c645e6c1a07c8989343c407380775ff246379855c7c8502a30f15209201ffd68568e9d2efcb596ee20792dcaa1a9fcd217fc08bed28198729f97a4a2bf8b97eb05405200dc8f284d1914a37d5b01cce0d11a6f1f0b5ef90ae474da12723a352abfa7e01e9a6bf477c07453ae1011d1198dcf0e0155270c3711dcfb8f2a344a1550952612e95b09ea56e7f75c8d4b0e667dfce31e37ce1258de091731eaca00e92f36cd221d9e9113ce6686ba522fcb3eed349fbd2159fe0fea6510175aef6055aa377802309464e4648350bca5ff1916e8db10c046dd32b84214494e8c29ea284b9e4c2d9b14abb98015411a29f4d62237e55f45aefe3c29318a4acffb7b14580a6e1064b217aaf51beae2860700d01408d1128deb970dec6cf7a3a340aa909447a45e6d25939e5b4881ac2debc63303a6c347ee49423f96895f12139e5ce8237c2d2da9aa5e7c98c95edae4f9a556e1d757e80f41903bbb6a1a96ef8f3f8d526f86cbe654a35eb059a2b11a2dfa7a50bf662ca811fb43cf300c1465efae886af05720819e29c903f4c9cad7511b5e231f01cde509ed9e86cc38b5e1512010d87fe9b90bbc6f32775fb2a1249cdf75144db7650be1686a0d1297bc13494fde83c68acb08eb8ebe0e51fe25a54d309cfb61a18f9e5a714ba418e237101872550db08d870c3b8ea51927269895e4a6715330ed4ec51f29ae3baa4987ef9810a276115c3793f17f366148924b0e910b845c3fc0b95636feb10eb4e5792283e921cfb61303f54ce06dfaa84ead377c7140bf118eb5244bc0fa2273e4a66fc31511f828505558def107187670a6ea2d9fe256d2fe4e24bb8b565cb533a17adf3f24c1fd08994dfb1ecde91b0fd7bed64a6cf5009fea3babf7c235add33fce7597601db80566330a61930e1b8469c27f25ae343d17bca497392e14b8f9b773b817321bdba10739e47b2fabc4853a2a93fc269fef37e47eaa6c72e17224089ccb46a98fc05b4ffd1e4869e54822ffeff2a2cd293a6be3188e0e6317abde38354c2d3243a67e338c49622d7bb27ff1b64f2002c4830a18fda5c9787ea99b467dd870f24ac57eb98cb04d7d86d5862c8b269107129a6d42adcba8ae0e56e11f7e3329626a7ac04a787da9b49be0645e13256a8cacd2f68dabcbaeedffbc2caff564ba31069432855915fe34bccd40dd4dc1056581194ffe7e168949451da6487d07fcbcd52df6181d849f5879ded9f940d095772d356ea56b4e6f276a821840344576b188aa40c6400d499127bb652c4e2b7e82ea623206dc9c8ad8b33de63a31ff2db142f7d667695b8b6d33c4dfd1946f3af1d6964ab53d6f81cb517ac401e241a68f5b891e66b27e040a4ff0f58c2a2e337717062d43b9dedb8c693876af23bc879454c9c337768912cb2f91cb1f40edce3e30c620cda0fba751f2cec54484e453fe4c7396028a9d5621649dd3ad0efe15cbed26bc117cb54022c4f9856bd9fe4e83c8f6f2834973f6e4572909e739c2d2c762bbb616ad8ba9fdb6b2ab51d013b668f298b734fa5551faaf7cb0e6b002ee69b7bb65f8f041562ee5d64a0b8a31320fa76a7eee4f936ffd54176c9806b7e3c4574d9fc4f80d26d19ded0e52c16a489e8f19dfbbc9d8bbb978e461cf7324023f82fdbe0a42ad1f6595d3104c7486770eb3eb699ec954c9802cc495486295f82e5808181ec795042f72800d675e7968ddd79db81835186ccd99e1c5f1de1a2536fe7053c673321692767d855b0b24fe3242167dbcfbaf3f1740d18fd6425474d1a4b1b819a1263d25f2accd1d188e6196342f7fbae218aa75cefd7cbd2c40e2242e504a3697c5656f22e3e574f9c23d2280b0f7563a7a793309e7419b4ac3dbc899191bf307095becce77902046e5fcde2ca8e3cf8c6d61c39fb5e0a9943d932b18f855ea24d8a7f913dfa780d344e34cb003cf19c49372916e439295213474f5a9be91dedd7380e2f735d8c490d90c675a6bceebbb3a8bda36e6ffe51bd22b3e65f471bbd9ad68dbed259dc69b5f06717f72fbe38100e5a6ee5773d3baaa3930c8dc2c00cc90c4e642105790f4e345526ac6ed8e58c6c2305eda88f86ecfcbe5a31e7484e1673bdd46169ba50799df945d2f2eb6e4dec7ff36015271f4e39954abcd4431ebb3385d75a443da96f70862d9319000a110bbf6fe92c1b325a60861248d89e2e20d9123c54f4229a22589b2e077b8c9cbf7e17dc221054727cabbd55f32f835d9421f7096fa93636eaeabb3e4ff377cbe2242ede77ff582691eab21a991c6237fd722e89c88c1e0113c64cfa07017a85375a5d779c4619165a64e7d7522f9a1c2ecee9f36a7928d2e399d881b05e14c7e40667211e06bae72eb2ea2746c103a808bb37844f7925451b6be053ec7b7986d5ceb1341cc01fbc6f78f83354b34d517953d7e5fab1827e0d31d4219a95d0ea5d1785d1aff127872d4a47592ec503def37c9fafb74920779c9ba86054f8b7866e55d8152e738af6a6a7190b4f95318d0dc248714eee67a34fd61e471cc994d00e84ab85813ba731332787d46f74521ee98610030a1b81637354fd05ec5318fdcbb7c5016ae4ee3391d9522bc497a542167f59223543b378109e5b297617535de3e001d290c99f305678fbbc128904ebffe970c0ac28ceea00c2de47e60bb7cdca3ab58bfdba6eeff5ff1a7582e24f1ce6f814d18d7536ac0eb5b79b4f0c9ead735ce334b1054871def9d41395359ca98b8749c80dcb54e9a8b176718d7b04f71466954144c4da8704c9efba66d1aafc599200fcf65083da3ed484ee39839e5a654df0fd132c6b2ff382458b032ad74c3c8fd0b181655d8a75ea7149488ce3f7ec1f71590077b1d625d0c11308ba52cec3fed0f5f285930d0c6f379cfa95dc7e3fbc49f2a6b89b7ec58f1f04afe6a12fd5df1bcdd9f6bc1fc935f587bd729ef534f9a747cd5f187c20d02ea229f817b741ef59d995784d324ac43df0928493f037501cc37b0814412da3c543175787abdcbfa72a453a1b18c5c26866fb24b81587d2e64355a139736ca960d3f182c0d64de76439edc43b5ab5d09f3dff3ff6fbe8f3e6fdc8cee6f9bc8f0c11449e66596ef84a86c9229fcb5b78f0ffe95c72f818fb2cec1a9a2ce30a4accf63ebf75075da87db7368c893240875e2e0d2df6a6d6c8397ed311b95baf1d6a454a5a8488ade413b7a6e87a20334ce7fd1f173e98e98310e3ea7e59ce86a9038c9cce2f4b7009b35c6c6696bc030512d92464735a848c1a2be827430a7a2f2bb068093599484e75b16879ada9d31f59685bca33a4d828324c8f46fd529470492959b3c1ea947eafc74075cc09025c9c6f00ec0e3974a6033966be5f4345fb2438fff6fec86be6e418a259e945c142b2741cff28878d7fe00ac35858618d48bf69f92e09758dd68c2351f2c4abdf64faa22c3af02cde7516a3c7fc837c0e6f1f81879dc75f4ec3779ba7b6a4315dcde9b6f4316442d545d82306333e54887e317489bf2078808800af855cea8c234ba9b49ce2d4f4343a8ebecd7c049df88b3cb8a747f822ec7cfba1c159ab32b7f9af49684184e5dcd4b3acd26f940bb618b44369096ae85c0662b16ebfbf9ad854fbd8eba04d983981c6d6ac7a94a020d1a00efd2f37cdf918fc56a334ec44cd594d62e5f1d45b9b77210c63668e0e5777cafecc0742923ab18f40b01e916e9d9319bb8ebf878d4f05848ce36b1faa6a9dc7e091ba3aa4b82393c0fe3d0c7adb0b5af0fd0bcb408ff0d6aafabaf244a5dff95372c146fc248ec5382788a963a6c8459f9f1768d2a2bb539718a2a9ccf20f1583e540e87abd91c0c2ef990855d721808f47f182392ae863c6a2daeb261cc598e77e9650517d5adcf568a4541878b5b7d25c81236058aea987bf37e6ee706b8d423777b2830c9f27c1a356acb320794d979f18487f451ee2fae9fca4a3b2d8ccdfce715af2ee2d6cd3c5bd0186bb8bb7b1933f4a3c98be56ca4192facd86585941b1f888bfa8f98c9015f4f249df6401012448901a141f2a7b4d7926673177246de9efa5162a7ea57f5e47f9b691ee777806f5006e05f80f0d009a9201beac4769ea5d299bc8738d21f4ddf251710e8329e428263ce76a4601a3180c5bd17dbdba315c45155088143ecdb3b6f475390bd95a4eb5363585f5238779c2fd68cc4dc6a0a930bfb57190b2c8fe7dd63504df67e087b63e8639094acfca31e9324ecf25326d3f28a60edbae1cdfb9b4e49c68715530dddbd64e2d76e5699a9b72150f5a5c6a1132877f991649e9d949589162f13cf0c7f5120c7a5daba0adcd118d390106718a91dc35d24e2415a55e07bf08bd8cd39de745a0ed667c615797806e8eaa69d8bbf011507a3b674004b3ec8f6d0fda942079bd16aaa3c87cf5fd55c3e383734cb09141e4983bdaaa919294035ea4f25f49231bc0f36ee9392a478be9b4575c9b0b186532a9d4e14be5e40c1b1b95f52d969061490e0c723982c9496c2a6ba61d1344463a13d1165ba4508bc902aa0b85b34434326d35a0d80a93f56cbc48d4a697df5a8d005e55fd9f8b20b19d29d6694ced6b6c109173ac57c5201fca8dd70018fd0f668986dff8c9f671c5e2710a2acc776ad569c397d368ab80b3db9ecdfbf43f8cf269b68933f78c9a784ba40622e741dc1052a765f715e5a683f9bd23dd79b9e356be2ff5684d073d2bb23dd1e3921f7482583a0eab8c9e7fb894d5c1857f08bc0cc97f3a54dd2622d5d22b84ae71f7cf54ea3c48b2eadea3c500cf5a7ff63047b9af56d2edba1c3895a3fd427d1f5dcf8c865468225ed9bef20257e581a2b83fbd17cb5546dc3ddcda3a2372d074481ae00428343bbf1e35175c425631b8c84059a39e70f1e22f423d17babad8455dc3e074cb898c1e904b122ac0c85e71a674ad60b218de82b3cb777557e0109d46dcbf27e7398f46f08dddfd5705de2be97bce9673589577b79048c59140a6c4e5bb81aefd552f6876dfdbb6bd6a74bce3b189083cde18ff4a4ec80cc901a6d2c4f2a697c297908e5c331851bee395ed21c2d797849def9ee27a0267adcf576f89bb41f81750f069ad71e9f732534072e3e0835b0f0dc4432ee9a89470563f47f984b9d94843090ae31de1ca4421e8371ee8df7dd2d7aa0263fa349daca6230f457e43d705d5b44da6372e3e74fa52178cd8848cb54acd11f8ac9ad2f8e2114246f7ea14cd00427c1969dd986fcc672404858753eaf6b4ae66c5f591b3fe4678f4d582fa25a01d769eb6aa2ebe241c15fb9b782f35004b75d9e466827b373103181a2ceb815d7ee98d7c5ed8019a030b80a2edef11d993f510680746f3e7227248db58c80dc7d93abb6eda9a4f0bf76e542085906df27a09db3ed0b9cca1add0869635b45b0fc8aa4b36ef66a793b383a1d45de00ff2c435db1190baf39653317105b4cc2d21481cd152eba6076ff73460fcaf03267b26cca5102d8049a930b5604e9f5f6b26bf4aa4a1d6133bf662ad84e948bb1351c2284c0daa55aa0cfae59dd1983f11a7db6753a3802518ec4b45c93a5f76cc4b64bce46865551a915d26a416622b8bae2dc077681f2be213ae3e54924c74609e9cc0d53e880c028fd93644650856fa3fd7140213f22b976d7426148db20ebc0dda2801ce65ff108444b2449ff3f879bed8e05c3b34392aa4e363c79f96d3f25984dd767d9250dc2e9aa362c611663de59c7e4d6a92c5047a2542b20c457f11d580bec6472fc4b95882eb416c1f37d0d6aa59697848a79be5e0aaf24807b77515275db189623f282f552e884a389e41a16561217a89ff24b352a664ba71b740f52740e0807dd36865d808bc3e0c99ad263a204ef69971df995319a0d1f40c3e85db2cfdf4db582e3bf858da48f4740d06e8ca2f27f3af7f85203461c64e7b319cf2a74345b20135cf1030c3c28a4ed5c5ad097350a58357f95649af332ef708d0ddf2404203bad0e6ed8da66a5fb7441f9e318bd7179306315700c1c579ea24d2fbfbbb46c7535aebc4203f21f0dc19ef8e7de91fdca6221fcb6f9e4a2a6dc445784b7e7b0c424da9fbf6e20e11cce7d489fe1571700c9115473702e5a9f17661ea606addb48c4a504b45cd33660b5c9cf9f8ef160dcb5c1af0aeb6fd12fb0c1ab753f55c984a65e16b2cf295138d46ada269d4894b737cd33ed363f5b591eb405c489bdc6ae46b35ea5c9dfc4b49ab16b75bb5361994690b8079f145effc15aeb04b6af8ad7752d8de161e0466930513946d3d022391f210f2f50649743a9f676cee2b5fac60dabf6d76689b22ddf02e19d520f7466a0f31072a4857a26fec03a24463f3beba7053ca59639d5d7517918f01ecc0d131b471da58b946b0b74186af155400f8f6af82c1a76c1e7f0637e834f536864533d156d32508ff5200a859f359d768dbaa9a4a855f009e068f5f29777e0d636741e74699dd4e027d22c9ff48830fcc359634453b83ae51d0a24c622864a221b8bd5083c798b6869a4624843c3d5397e8569271dfb2ebc83c26feaac42ea265d771555dc831bc28e1e5eb61567c1f8caedb37b013d0fc982a2f476d992fc398535bd2c51824857c8b3bce9bb621b1c64abc897d10ddb445f28e10658032ec993c2d74cb356ce015211d3ffdb567e65c01e2037076a823a31d72fdc95bf27a33b1bbd15dc3729e65e20587ff531fa4242e4cb6f6f309794ae05f229aeee74972a593605cfd24ebf9c20981db92bf9ff6bd20e5955c92d00f45ff691fe280ee68158b249a548f185d3f54152863b7fa8e0d902a1d3a762672b12b334d496e9c64d4252f0313a76eee4a9386665efdd2eff96bc5260ef47b152a7590bc8336726c277a7028b54cd1f10e9b2705081725f1e5a1d36b1391ff93f1af5b3faeadb6087aae5a647992dc23c29118b3393a571c0a2a37565dcb89d8650d1aade261228a360f5415b044cfa4946a59936247ed8154348209bab28e07fd700ad85797b9809634597f6ae361b95af0e57b98c42ca8917007174619945732530aa0d7ffa769439c6faa687d7511034bf095bbdea51064230913c9a2e380e6631e60c31a2e5e0bd54a48affb35282ed4924f8cb5e903894555913fe4189f8fb09cdbee0f8b1d9fc8a32e7b671db23e0d71bbfeec395b41db7132ca0de70b03dba21ae102c9e15e36e761722324b8317ae2665bcb30abc7daf4ab197a00e74bdd6d9b5ed75ca33ad3fb7f72575b8af2bac8f178349b16154ef243efd34d904f4c05035a5d655f25c326577c07afd5a3b3c5c97c0eee5ba06e9a6178537c759cfa7bcc0d94d408409c0c12bf078980435f5a66c43edbfca857a14df4b074b6219a45169d506bf0f07ca34ce305133b1c2e76572715be418d387707ac4e9532e147513414152fa62ee5890a0eed46c01c342e6362bf7ef648de164e9267566447fc9d365b2c2c069526797cfaae0d8c212373dbcda3502fe9838cbadecbd2dce6256bfe60317c39024f576eea3315a3b4abb3468d00112cc4b89bd04b8997be32b31270f01e0fc3166eae7df857ae60f09e049227bf0607ac48e34e97c0a865a4a98785f2fac1bc6d962b34949443b6b2fed4f119c1e3d2625ad983a26cbaacd50f6b2475df86f995037698d81c7293f92ddf05106232f3fddccd14aaa5909e4d699e63fe6306c509ee1630700e7c6e2e7593fd62b423746addf501c03ee9d0353f29efacfc87b18aeb5ea9fc0c8f0568be1a64ae4f8f9df5d347ce97f11096bac7c9091e67342e6ca9e2eb5b9e9aee127081b29d3be4528d61a78d994472eda668352174e0e0efe548017545bf3e04fb6098d801edefa8e787d6a606749c4edc667e5e5c461457cc7eeece5453c3fac017e090a3cecd5f27f61b784eb25b70d60a7b7080ebf77e186863387d0900abd17160ab40a85517410f228e212e2004e4349a07c0ae9caac43e353937c03998f2acd37c40d5a164e4b365f018f04239535e7e6158a25f95957fcb500cf4b241cdf7533b3471d51911930a7b4cb36025c4b61d1b8fb97ac2aa306563a6272b50b176cf1198f932ef310837c4cc39cd05fab8e07d4039eb81ef7ee9cee2622497290796f47f397d792ab61c9d20fa96fd8e90c9a42c0e1016a57b62b80ae4682cf992457c151666f32f8f4f0d188fedef324c478ea40fb70a6873f095ab5f9ab9d05159c1f1b0c07ba7ae0d49033561d8999667b317d806609b41875382a7c3a05e70b0888d04287ba14ea16bb559b6dba2365e55ed43c14b0064a88315f2e96d3fc2dac92ab9b545bfcff44bc0b279576523ebb7ec3e115a1817006b70142348582a2f878c50755a5b9515eae257f7ff8cdf5db8d9b751b6db341fb5f85fe3c3e1e9371b07bf6e68cdcb3605f43afbc629cce9e018760a95212fc34992c677b80f98f21368ee8477e137ac08fd1274eaf1e58526536ebe5a6ed5f22200afc424e3292cf4ac74a852a4132ec2cdde674089faa4ae596dc3dce3c6db1fa78853faede5bdbea10532d84bb03207624b2f9083c58afb6d2130d8028f23739873c638391fe02b779f3c2c553f79a177888f441d5941799bf9ed7d00c1bcd632754fe22dca74a95f5e561e57d14e0d177dc9ec730e1a490b148e20f8c9576541de1bc600bd1bf974283e5baf358d02274114dbb6bf70057505bd659294da2fe71f84766780288c2d24c6e79c99074b88b08f2f56125257b2a1919843ad9a5b824ca5678dc25d4fc11083ae8c8cb3bc4630887596820d8eeee831485a6797d4e6cdaf328b8bb197f684e19556db572b37b74b98a79ab8be3250fafdc467a515838b75a3ad68a87206772b2d4f8d13b822e2b17545d4c816580748848487eabfce2328e5e5bf98a6e80da5d64f0189546d12791b622620742f00bfdc18389f236cd704e2feb16cc1a51d53e2c38e146496fc37435c8dafaaf312a2fb65380fb0f54ae47a179343b9a461d19ce2a455785d9ffaed0e5fab99d1754b0d748c171f9328fbc0952cdedb4f58fea94f266216729c79cd32e5d61de64661b18fd45fe74801cb6df26bda1cfc73b3c438e6ef0f43926895df19c774902ad652ca4d54946a7afb555d695d55c2b2b85094185a7f9515079111c900546477334b67438ab411b68d4e0c381419f8a350bef99e66998c6c24e91065488c0a7143c2e8304c4bdd267f345e68cb902c3893d6f017e31adc1c72a76280e41691907dad82861eae5b81883f5589a5a7f50bca6e6f83bac5ee7685414f0d9bc7c75dd7fe677cde5320954eea1621285c81d781853c4cd9556a4976d024a36c74a78bd8ec07a391af939b6f9e0f60ba216504586e878ef646b28e6fd6113ae1f9b9cc14621d73ff5ffd1fef26403e575f0f69f1f93a578614be1c963a5255cb8406f5ab6c72e987d426e6ec930c0c374c5b9199d3fdafbbb9ce3a5dedea65fe461c76931169c82f7fec936de2b7359af5ce6b5dcdc0af38c209249d69a88ffff04bae20410ba3fab12db8b5691caaa657d3e03babef8a4d0c298e30a89e77ca39d116902e637d946f54328b73d493c5bf20e2f3ffab48c2c7ba20a9c17852b4e9f107390114182a66024fbbb3b4d18f90b560510cc5f265e380bf7a38e353bb166673a676ed3efb5aa85de2248fe930d775ef24580a83e31af44bfcf782141ebb6fe9d61a7dbe989c34eac2b422fa1210603071b72cdb9ead423eb1286a88dfdb176195a619757cf611ac628a4f34397356bcfe7312d46007251759e4e2f13e68a03d637e44abbfbaae32f61a2aaf643dbd5290a802d01707714a8538494a6aef0f007e609ce0f29f20d497408a9dfd515920ed056aca60aa445a09083a38f4f8307f4f2ecdd6e8165b507439fe807dc67d2723f04d6ac06bdcf7e9f66ffd8131a23b73efb7add1bfedea6780d4173b26bc60a0774182ecfe45449dec260e4cba2f77c792964d2d8edff1a0c2f196036872f226b1ac1861a13d2d680e080e1aaf459cb24552e0d14cb84247970f5ac18a4ae871fea0e4e9a77e9589d7158c74864df3aa619c3e5a098fb54b6eb14d6b1d55ae894c2f26e62f395045f0771915cd3ea3acc62b302914232413eab5be21bc85ee245bf1879a3ffc857a3ffb15b11bb23e2ff4389941bc9bdd3721effd6292351a505d7f084a33431c1d1a069ad240faf3be058dfa468ff3b34fb61a36abf27679f57db25a989d524ee7458f388baaf9cb0235128cf7fb1f544807d9e6037dcb234247f68a1ccf05bcaaa6dc1441b7a023e5a604db7b997579fd2dc81d0122f7b53bb2bbc2244951d05d381b8db78f5c8e76d28a78b071032149cb421f36ad7c90004020c59aedc5126409d699fcf1c32317f9a741f1591fd6d6a6fc41aa252301948e7c9306c3030e9604834f26ad2084854a39a2da2799c99f905029b58cdcce7f2bc2b95da5d25cb68b3ed21f16edb40a98e955fc752de584a0b1d95dfdd3ec612111202ce9439c5ec6fd98e632ffd4cb217a1148b0fbda1a149ac96e82ae1403268fbfaedb67c02b9621e8ba0aeb80048783f942bb58b3ee7fe2df5db3b46f649d6b7aa6f31cf3546e6fe1687ca437040f77be6e13163073173fc5caac24a85ae4427c542f2ad62bbd2148acfe0294db61953998b1243e00c338d184fd8700e335b9b59f183b60e56a412cdf3abe21d521bc21fe6a6f9dfac48b829ecaaff879a06aa253ad1e5c75778ee149085fae8fc15e611626a6ff61f38939cd790e7ce8e143e94bbae35630246261e73fecff0d80e1e0ae477d7842c34f3e94b7bc0ff6cad9a376bf72e3a28cc8ce1293e69f68cb114debfc9093c7fc101c1a579bf9c6b3df13bdb7f05e89417118655c44bf6ef27b7c1981052c5851376ae38e9454cfdf08bd7cd5ce2bc7a6e483cfe8e76a696a198fe890645705e7a6fa8a5b43dc77bfc0bf9b46752195f8c1f960bb252ee76ad466e43fc1cb9eb57643dda1966dd912efbf777115d024f35fa85632e69447c81e8419e218750002a96643fd50ed50975666ba093732c1dc35fa394736c66523ae1d48df04e101cc3755cc54012ff3d7955527a133f34d5c22968d839cec9c67071ee7d2beb00c0676b89c13749a3c1e29ba84e33d304e5c28f8454e3e82b6097648a3e70f50304b44dbccdfc6078737ae1fe9b9ec72858991f47deae597964b8ce4e8ee29ff6f1df1c182132a1995178ebe9da32023d4d3fb7ff8467","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
