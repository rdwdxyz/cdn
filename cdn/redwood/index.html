<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ebc1dbfb2c90c21bd7480cdf4cf38186abd19a8dd24a13fab1906a9257d9f554e530deb4400fc07fb627173cf4bef7449c827dbdb23537cfc6ccb0b3f69ee748817a319e4fb82259dfe84ac62c420a755d79687adafb519fefdcb4677bc69622798b24296c50bedd38ba9c9906e54a2c098ae5ff29af8b0c9dfbced925a0f4212bdf365820869add2980d23344d5beb10db61e28759adea64dc11be3810907a5bd9c124bb5dd61cafd6f9af771a311c28c23ac7cd1c441a14e3f4f872a505611b05044b54f93e311577a20ced511f8750c350a0785c5366635acbd81c854063002c69a4d931cb93f32bf474997905920d4db5fb587449e39efa1c8b90400bf657fbc6cf4b6544f828a9429ef5bf10161cfbd288d26aa0f954c72d8353b41f808213b5d9fe8ba9654b8d4a73ebafb40e5c7cb86aeade09aa2967583ba9b566853614f74c513171f943427a27bf2827f1644f6da81ba928ae7131ae998f8d087ceb8a8d95df576fb8b5f8a2c3b8749f606d24df4a9bb22a99ac9bb23985010f744afb4fac61cf137c66afd55ed4483595fafe62d869dcb591b74e87c61bd70f8b2caa52f4611110d0b959ebcefc32ed137b4fa1cfdc6741aac00d5049848e840bc75ef6ec6fd12f6e211d743de0f9df09e2afa4dc62a0e9a84155b892c704bed917ce143d5c813722dd59d05227df59b33351e3e071c98a9d02ad583f25f87ed083911fa1e28df17728f06525798f4e5b6f3b960a70088380a5e5e0513d5015178a98085f24f659901683f9e38ce0b7701b775f860117696bbb5c223cefb7a8bcc929e45e3a2ea247da91ca95b252b390267f05f6fa7d675ac46f4f828445ecd86507862e90a656a15dff8f92166ebd092f2c5a2a92f0f6ac94da82dbd43b37f55c191cd1c1d5313ed10301f089c07974a07f03e85f93be3765ae19f4750aca508c227ed6b79586f15a4c94f3e89dcd306c5e4095a0dec095b634030948299f6402182e8ccc4c0327f105741b4fe95bcc6a40d14775c5895a37f38166f54dc85e0fe42e3d3c16f0fcbdddc883d1706ac81a451514e8c21d147ecfeb4113443e2bcedc0abb947649936fce13005a9652fb13862854781e2edd84e5b4cdc869fc1cc155c79d0c4bfa337599b264ab476a289eeb980acdd1637739177f02eeba998f2dede5fe1cf21a89f351c64fbe96e8b30dce60f38ab84ecb18d8d17b3787c39338c1d73da069130396b33f967541324a7334685c70290ce4effada39d02845a9eba77fbbdf7b0c8204463a6df77b91eaaa4be3c2d7a552417b1d2db649ad644d5738ca721c629c8ba82acb05bfb6522cb65826d8e4a145a6887c184b03f61ad7fbf712cd34fa45b7028de1fd389202fc7c03ab4b712a43bcdb321e40365c5d8faa2f5c5a9a15b201fa87665565b7c18aeabfa736f6a3842858f8001526f6a509be993e9cd1fc5ed4c8bc5e1cb74c2c048c6186a8a71ce238daa436f083e28b7f47b8972dd781f73814cda6176f530987f11219cca12a939c955f7f2b92614565912d3056d40f13f754913a4d9936ac15cd1076ad0ccd932c484e06b3c3fa9ddaa43c949e1613003b2a7f152db2d710a6fafc61ad1be522d95dd43b6e2625876299788d83fcda73d7dcc9a41e2ceadde971d7403ceabdb7b2f53c5c6755bf5ba0f358ae3040ea38e347677d8c812f5a667063a16d982080ae7f815f2c889a4d89ba84e7885427c9c853cbc25be5ff003d1ce4dd5fea0422f9fe6cf095377b21853f5382ac6d4168a406a442d5bab2efe28b66cd1b83264290a82154d325e4c65acddc4eb34d00cdc5abbe652019b531416adb48f5e90d44b8a5e2a2702de9011db99f054ed02db4fd4ebf334c8198a756a7079ceae86923c5e42a646280020b69e6f873273ed1432b0af62ca4d6392e23e96ccfc18d164bf5f68d52971a18ff5a99db3b6cc7fdc04100fa3391fbf692af6b5aceea8c3ad47757023f3a722640e919bcb4702983350c65a250bf91ab3e94324cc7d6536867fb0c806f87d6ca958c5f55a9af1057d7e4a09d8f4385601d9b3fda5dc5a00f0763d4d84bbc1ef7693d53101562c1e4c3b081e2df0107ce3557daccd9d483beb740176a0c38ca490029ebafbd801a8e41b868605cb666b254ecea319fdcf363e579d162b2d4f35b9efa27e218a7390db1ab465b1c71612878ecfbfa12ef370b660654d8a1304e3b222d6a66fae5b87e44934104e7c70a9b74bf0a53392688deeb774f588bb62faea931e7c77718dd259ee9426965e37d0c0f1be65a6af71b86904132ca13a2cedf6a60d9194dfb0409ee0174d9fcaa8cef04a502d0f41095da9e70ce275cef033cd188a62e7bb8c763994341a957fd09b707d7b7d8f4e8e88524e099c4d7742d98d682be42b319c00eb927cf4d9cf2e1873604677338418ed8ffafe50df95c5d792b7b59de26ad192622d1676efff7bf1ead0e037c2989cd3b49f5dc57b1085c83df3107638b35be9fdb9faa84da9cd6df3b0a9669a9cf6fa6596983a2af62de17165100a3f3334574b1c469bf2ed71e24b71a0ab8dc76fff72f1c4d7b3f33e5d015ec35d6621daa09e11dbc7f1dae56d2a9af3637d0e5c8b3b8fd9ddc6d0ae7039ca99d9542d538dc09eac31340da4ed0a8494c214c3911da0c1a3c50686156b6a4a627ab464afea4df2258b40e4312d58512094b92f9aac7b7079d6ebdac82ec63fbfc325a365705744afba31ef7bab06323fb61eab92d99c25fe753f50ff13e0fddfd435acce4aaa5259a70d0dde2785b88f0fdfd818e3374b5e090f3444192f5fd4866d578f8b15a68ade9b69189c6fc75fcad28fac843dd3cc4725b3b72c47e20a903a8d29ad605e6b31daa034a8fd628d669eb9230b4a5a9d03a0ea4672f6a4e764a20a86c07ae3938703c7027b7e6a00ec23232d69f773bd9f9ddc6ebc15dd5b808b4fceba859bffbd4e166d63a658ecb05fddc529bfcbf592f3bee9246f77bf84cf55d8a7f6078075b6d0a636a41bea3f77e541dfadeaa6f9abc7af04947668f83b3449e9f43b8f887e527cc3f73e389f5625538dc2a574ba9dab7de5310e83f7b960029b5d2d6231e3f4dd705ce16b02c12f7aa51acd0feffc013710744fc8f8076df72d25f0c605cac7e9769287557467d3d9e022b9980a7ba2f0918b0d6e8e5b350f95258cc8e7491283f5f122f87c9ba40120104321478391ce8d2fada58e9ee810276d49b97e9e50f68159da5725094ac8cd9c8d9b01739f7f64c267bbf5b15b6904b50f35d54d6c8f09d99a63b20ce2c0222500755ea9c9270b4ff966c3163a4ccd2e19362282163a0b20615f7bfaa08850568a325b1c5e7b5295803df1ca66834f9705add17c34c4ede5ed3a89093ec0c148e1f11aee5a6c773c87851367dd62b041f211694b85d131dbcd934b290abb30d41ab7e685dfee83c3e76de17320529677ee43e15f765fd20dd11d6122398dc79f30f94fbfd646add25f8a299858fc383d687e4cc67fe2de1a3f505a38f5d0fe9656b943ca94bc33485793dd13b32c254e514d43d5fd0a6e19ca7fbb68e7976354fff837b2981eb85b4abb96b0ba21836f9b4e9350dd3f64f84b05a482c7fe4ae08c439b88fb13fb7e2f3ea561899d27bd84453e5735b188c1bf754c0a0b19a0081797e8a6ae9b2215c7fed749a0a5b9be5b31be954dc8587aa53f1aa1ded9caf400c856cd81d415ba325ea4bcddf70bf0304efda3a6050b04b7ac3e9f0e86ada2821bf370d495cd7eb1a61baecf318da0f8d29f0c5a0f5e909a458fd93b60aa48ac54c92b9155f3933f81d6073054e21551167d9b6248cb422ff7cb105c12dbaffe78a166c12be2572d542952d1ad7abfaba5cb1afed0614eb5a8a38ecb2aacc01dfdb45566f421785ed2017ea6326d51b8964d01e0b758bafbb5366aab8abe205859deec9610de894d45e6c3458d25e71f0ca6cc5c960d484a54d1a1fd2e6451273294656c27319c5e451b3cd736800da2a43e71cd21db719eda30cfac19639b659cc3483ae4522f31e442d9734b54a82d5b0f37c2d99ae99a499f5c9b6deeb2e36b8b217a0160619c3e468aeabe5004ec3ccd8bc6475cc60c5641150517d87bdb3aa150ad2a9632422bcd2faaaa1d28618993d0265f85f5c37de4f9e7c93c929d94f12850bad4400e88d9867bcf40f2660444f219a0fb623dcb93c902eb8f59f5177d1841fb002950cabbc12b313e34eb384902fcbc00dd8f85ab538a29969ee788ba93a6f7f0f893f1586a47d9fc470c1dd63ffd7b4d6af42ae393c4368ed9b01e20dfc74bab339cf660a0669320906c342c4ab5a380fa546739273937fdf53b4164893953948a3b9e381801002b4234e3cf8a7f1b6ec9294a79b656d0c78ef2abc41000720929286ff4b068f1d020b6ffd8b91ee431b5140f6e35c945e562eb9c110a2d85e9a2743f14d31e5072ebcbda6abc13ff2066a8c6fc6b4a8b02a25ff55c19f4a041ee3ed0d66e7f1d94dc2be8a94ae5f60316bed2b59fd02db917b764752088a91e6f65400bb4d3f096918b8b03da37b4421e38051e72c88365222f845dc47e12960b32b12047fb55d32eaa4410e1b324e85adb8be54086f0fad5e3073407365868adc15a5a5948033a6389df1ab7419d3a97188acaf35a87835416b9a0b7b5581579720c810c7486888c10423e044b638b2eb659c5b70ba9e327135bc1c3e82c7f48abdf138ae17e7c9200cecca2520d15c6ac2729db66a37b02aadcf5b426e97450ed41a362acd627f0d204c1b6e1210265df8b13457fc0bf48ab2ccde902ee0da9af8a172c4e684f2e9ddd68fc9f37ebfda100e5d17d2cf7e1319a674a68e60058e47abd1724d65dc98b6564cd52cbf5497a90e39f56b212f4647e6f8db2a7e5aa9b757d330fdc501421968f73b9fcb3d5a905509a01395bda5059761c1c0872b678a8d49e2302f7781f383e2146a83b6f01bbfb64ae294f3988657dba9603f9994857b303f5f9970da5fe896a4802cf964c71ff5628b6688c7ab49e90946fe7dd264193ab1510d1afaaa81aa51643505ee9559f0ad8a9fabca9db28e60cd28572b8301790898bda2627d0bfce0df0700f6fd7fbe0d3261d347837b3efb5952a666d3f16ead1da6f49efb374cb326b6cea36d3f7a6c2533fe914be39efcbaec0323d1deb4ade2d59b1e21dae44f63a66cd389d8220465249522f5f0649b976e2c6d27629ffbf8672b296b06ec5c4e4158c639919d9625a482b3dbd7710ceaa4e8b6e0fb87bddb9d2917e8d8f3f82309f19c351829cf40ade1972d114fa268402e193f675c428d2fad9bc0fcc1628cce343fd908b87355f16c7f4673f7abf6a61fc68691a393e73875b113ff20e918d125646a0ad892ae25994ec9f6e5f283d24b0ff4a88d354850090ff9a4c1b84ce8310f915296ac6e9ab3e32811cfe899e7c72455141f2f330bc1c9dda651453dc10a72661e9c31ab617b1a3f6d60d4f2661b0d018bb85b503784ec625589da0b9a58fc886f20d3ad5cef9266b66e8342fb1294734e5280ccefa99477f7134210daaca395e3b8e9b6b0828ef1bc8151942a3c030987b4b57fff0ddcd4de0ff8bedd06f9b1aa444bc7f5863b6f311f130f2496e73c3ca19a22ab46ce42d110c768dbf00e7627edec030d16e96660990afa9f31574bbd956b5cccfbc07a591aa5e4b17f09534623504dc5c9d497efbbd88a1be4f4a24ab68e951bf4bcf5fe777bf06a21370051e3b42879381d5c659d146b2d2539fe861322940aeba01289a880f2765d06411f37fa83608b184f2d0e7612c5344af2ec2e912c6898639e9e1f921cdb8acc4fc9432e4826dffb34c31c4d4065c2fed3d9d22d213bf31b64df34be83ff634b8009cc27c3b13c5ae67a8120b449e1dba941b22fbf356989d5a8e590bf40a4bac2967f01f874d8968961b4962cec99480374b69ba7752168f1e5a0037d6a8d68f7ecb27671beaa99d2106642300d5d56abd46d604aa4a62df32d0b7a42bc2c248d2b262495d4b74466b8e63602ef43004f85e54a9f33c19f841af7ac88cefc6b9b5682fcff8dcc5246b460cd63f2c7261c3e977276da892dfa7da9495a20f46357bb6a9177b958391604f338d7874b9c9421acfd1cb4307b99fc395cdcf955149c5ab3cf824cb29a34e6a4929cb402fde3253180dffbd01a029977176b2343bf6ccab49d58ac3c443f652c5f1570397548d6772508ea89eee009079dc90a28c0fde32e11e1d420c012d8ad1829d67182bf91435ff03fdcdd9f9743f306df781cfdb384396c91cd5c4ebaf02ec2003cada0a3863c0f0a6099592803f4ad84b5198edceae1674daad33695104d8650d79b8fc22adc843616fe7bdf5e147bc2fe2ac703323163e7f867d7c91077d4766202759bbe309182c273686c559779c24643bea14ff9b98783798e196542bb0b7da75a01417778ced77891b3b044833017071680e280bda254da61c7782411bf4fee4ef2eb1c1429b42aa0ec5dd21e8bb398912b1d9df20abba2a9963ff340da3f83515644a11e45fc7a81ec335f5921afc695a000fed33bd992146a746951f826697e5f94c1b46aa2629060451106d35e2bad962596e4f49da46f5071459320b5b1a6d44a50f66416e62cabfb83fb5045eef9180904d08f9ab89b641349b9c78802cf29759e8d046f952499485a9182ef4e84b057bcc3f0b510fb3d25db762dd27d024ada918a66be759cede2ca3a5cd68595fe7ea3900568896911dd37e08f18fffb47cc0f46bf58ba0ac928643c6094785438137800636bc3fea4759f5c8aab54f78e9439b7c48971992c095be451841fe429f06eb4435972bb01d1aba59c376d0a62d767055625e13a0b60341d49c1d28bcdc278f6862e971c7952481bbaa5ebfcc4ca6618e8ce8cbdf669926b72d5d563094ab9fdd0e1e1b38b0e9fea61e0772be931aef02670ac9f4e864bd1daaf19d24414f226d72a637bdcbcd296415d8f566739ab659b539acf107586a2147fa95bedca0ef77c3a97c0ca574d2e1328773ae3dba0ca2a824d06e8958653d7fe55c205e199a2ec0ce1742bd68b39844427080c84d7b78d492cf9d3f3b8480b6660b05a4129f6a8f3c0fe0cbdc54097cf81ca2671fdafd25cca7e14673d2811742e36090907a5cbdf090bbfc1ba187aae5d4cbece73554e9204ea25ff236fa725bcd8b6a73cd6b0287df781bed6d7dbc3d607e72797dc96821de599c209eb74ba6cbfa93ef408d5843e688c7508aab2d42bc7fff579d19d85426b7e4bfa672f404372444242f5dc73a99b71b9c846883aa8c44a2cd03cc08f711aacd162c9f17cee01deb70d0c331d672d8128971e5e0a7f7280e812d3f7ac4763cd0a636048f34da515cb3804312fabd752dd5271c8499bfce8249e30749065e85d3c8d8bc3b315e147564ba2a77e28d6b6f3f3b4d0386feabc4f666338b05b62c0375bc0aa72b72fddf35db1acbc92b031f42cd3556403017c63a9f4b95a1dc0bfa6ff0ba1e712c061c0bf532fccc7bfebdce8f8534906006b2c8f04aed46aa9d2b1b6c647316e09bd1211f37489ce2096c7e683a4e39c9b80e712f23548ce6d3266dd975f2c6087895ff18dae642c299426bbfd7c800a3a91ced198f87b9a3e780074f00296f0539dbc31d21c58813cd80ffa1842dace663b80f0d3741255bd8f29546497dcf2eee7cbddf4d8edddf92a28c90f739976a881613811c7bc2858c95e0258ccae89ef5a51898404012748968f9d7f8059e8e0bc48896f551d9015b1c704763fc74488f6b60beed653f054c9aeb94f47a66bf1dce2a91a48cb8c565df78b9b8788c23fb961cfc718539cc6b2214805a2122fcc73907a9db95d9b29ff4d09bd38f1fd5c5f89d20bbf7af2c749d01d2af7c97f7cb78893a317add17abacfeefa32926b034e7c5198c391dcd97a7d571b7308600ee72d95cf64595d7ab0d5ffc6d5bb11961b21fd7d5ef011fffa6fbd23320e0c1ec6e8176eff5cb9c860bc53d6e8c6661634251627c29967467aef3569058823228adabbf2cb05c71b7e726d78b7071f475833919c94d8076f5ec5097662e4803b2b31503ff4564868d7378502a03166f9bdbc512a3100e591a53044fd8c74e1a21dcf815eac8b4de938351f97d65405d4f91ea27a14ff9195596880ee7b1a40a3828d12ce4dae7b5d75e041691dbfd5ac59f7e6218b1fe8158d9148d3b4990d69787bcc624c5185188520b16279d2209d6e85aa11babf66f602368f8b6a0029bf07e22fd38aa3e5531e718445dfad7f4cf111dc1ad041007d1dbecc31c42044322d76e0f926d9988f78dd7f837b4225808134ed7668b5008a5a74c9ae0e6068bd14fb5eae150b3e7f92edc98f8aabd39e03c59587e5ab1ab66a5ef786a383e2266ea57b23827e040caf94b1b7ae1480726e07f09162cceebdc35328bf6581abfd2a0c5431964b07fafbbe02e2ebdd837f960eb27980ec8dcbc0e43df8c3685e3dde5cc383b27505bfd7cacb62ed3e0af125fd61b05d1bd3604a3abe4f96d99e09acfe98727389cb0811174e77efc68a147691f5bad0db5c1b9536b6f052b0b3984307bd10a1af1b5115da288a8527c35e3178f10f98cfc7d47560424e88a1472b87e1087b047fb5c5563759cd29294d2bc78bef6e1710501fce705cf45998f2733cd8ce90833159d5b42fc23e0e4bcb3606b9319491bd9b8b6aec897aaf701650ffa4bfd4940770abdab769b0d6fd15099460bda4d35d43805fdd2866cf9757d4982764b825e769c821313953a9d7fdcd04c5d6b9654e541b6c459eb5d8ab10f65f0a6de097bffb26f85c77c346d6bc1249560a1e04037b0df6e14af62069cf60f589a308e7a35caee5c9b3a02b75b3baf446472fef7f508101c1bc5339bc988416eb93c05c917e684b9ad9505261cd6394b83e2ab431c6aca23d32f8c154e70c83320a3442a3c2bdca1119693e3f41e82f17e3fed5743c70f0889e200d70daa672d88f5f219d5978f9a84cbde38dcc18ad8654cca2a83cf3ab19da5e43408ede848e19b2b42dc499d9336a924eb6b19135f4138af1895d453e60af5c4caf32f37e09137454127e4c478f651cd433c837ddca81034311c2b1860571e53746f0ab6f4de15c29fde18106f3227df1e3784ea261fe25a1b080fe896401ba85f6b10b0ec10186832d0da1a5fa0b70ed1b2df6c9deb679fa65db105cd3da2ba0307d725e55f28b0318ba1a62d2ce6abbb5a77d589641a736a8c42e84aaff58e3cb68410894944c519a995f9533af7c6d14c64ad42c313d9557b0a38fb0e49cfe359d01ca2e170e8f3243a0c565d73251aadd7d40656dc1d43202ef63439e409b8e58cb17d8b4434b495ba4b5665d278b3fe850787c9eb5f5a917b9ccc0efd8f7ee1b8cddbaaed7f566efc8e2107b9ad199011ec0dd2162423b3a1d633e7dd57b6ae21d2cefac47a6ac9b5bfbb2cc5cfb9bba1dfd73b3834bb5f1a8225d4d6039d8ad4735953376f1aded317d59606fb2e7946d908eb6991cd920125587260f87519af1185d59f467b5d2eeb74b4b2f0d8260cf06da9d300b81995313411a71db25b0c54587905875b81ce281419e71ad20e2bf97475f9c3db3d1a8b39b857d139caf025c0345ff89978e836a748c0e19049a34146cc17aff3872bad5104f8a1f394830b639b5a3fac90ffe4ae700bfc92d93684990637fe42397bfa05af2277bf4634785b6f0bb0f99ec5f4d20db7126e9c2cf1824d5c81a36c4f4cc573ef8121f88a000a0cb46762309ced9dfa78b706b699932fc938193c2cebe4d3b7d5277dd5e2874483c137340d0e3b611ee0204fcfe14fb6f47113fff66da876517caad6ed46422dadd68c2c2d16152eca22c20ba63f5cd97531d38b51579dacee00067b6f8c6f00403c1d7d9172651a4882d375b809a9152eaf04c5224b3375092cfb2e2a22ce9d80e4245b1f6299557b0095630161e4be58ae87716ca6be16dfaeacb8211a801d260d75107ea9603aeeeb70f948bedea50b0bc54fa6239f62bef49afc729da32e0e83cfdd8f7e14ce64704e430d3183e6fe6a973cdf1d16ff44db99f7d572aa7a1b12de82d004b9003d6c073229c0974ee2defb23ac0a6e1c973b8761c13c1b4dd387b08371aad8720e4fa6b0fdbd19f1882f8165c6994a8363c51b6967d71b0620f5f302bb152330261a721dd62ffba6caada54cee7c07c8ac94c7525438f6daadb091a62e8fcafacdc3d0b33c2c62699bfd59adde71f856d2c71855ee9b9c707d6240643043cd2b3359d6c18736aaed32a498c9683fa9dc6ba0d94609c7f249610f1bca39d16103842f7b4c60eb6d377d3393650dd77590b5c3db1389c5744c35b6870548c6c0a5dee45bc979a43d1451346868a69bedb400086c78ab023a01d1ca11087be6bffee79dff5d880449ef6652dcf91af1f9040c0a5a670d08ac8a835fa1f239d072e3c2a581a69620cb9e31eeb55e3737954e49683329c83a566353019f9c73a29ebbb70bc430fe81b70fa054ebe513e56449f4c612bebdf6b26860388a157db23a52c5d3fa510ea65872ff14a228aa65f383d13757aed63afd260eb525cb184943c901a80d44f5880a8bd134de9bd9411d13343c4081aedba8a27537a2978b539a63903aa936e9215dad5c481de4ecfbfcd58d0b25d91175876f58b9b0b4cf45b55d445ea538505e3503603ad773880b54450bafbb388f52856944df27843806c9011edcad16ae726f7317df2f4bc8474af0fa1f01d2ad122ff049b3d5a90489b5e504187afe5a96a0fd94b5f72c7063ab7c1169f3debdc14cc77186da9aa6b777ee62867f7d7390874f12d1148f7bd0fb0abd1392c2ed3c3bd699ee989e8c37801ddd19dc6dd7dd3b893ccf47fec44be41f01b323ce6025d6bd2543a9a8d5d6502ca08691a3cb7a72b5b9eb8f86df734f84237cd1ccb47459dd07c3b76ebf5f0049a960404710c345cd779ad8779c34996b9fa05c7b5ce0330fdfdb5c4451e0dbd254e9c1987a7c13cb8de16aed9cb9d6a7d51b4f3072532d4499ed152ec63668fd8d70309f3c6e79ee88f7d6630b59721d0e2ea269191fb20bcdd7ac3880022d451097e752052f30e2f4e04256ac1c37af644fc840a03a05b6044267387dc601fb1a3c6aa38243ac3f353198389a080aa21ecf0af1164feb677c9a1919aba0da32c0bf4177271dbc4577f95ce430340d9669bf9d85264bb5451314f6487ca9d1a9476df18ed90492532643dffcb19ce90bc1c5311ac5a62b5b2c5c7e57f170673665d0103f66d535da05e7482f9673b81641e7189992da631c2b1bcc20ab94668b4b0eaf039e105a69d1b0634aef116c4d04a0c039b462929f5d25e16b9c178a87c112fc9d0f9e8ce981d1a2a5b7a28fcf8e062035bfe2069661f691ca9d37f23a6a810d3b72736356f3925acbc0044fd4504c75546a4aad640d863ca55a4344235ae2ded54e2c545f49a9a593704ee8dbe848d475221c0b406ea12b374d9408418e5cb92c9c3b3579f890144149fa900ba198ce7757ce530ce0abbbc0818c594eab29705f4b920de179f32d9073067f8689e97a55eac92e5294402869bf3880128a995c994c6fa353e464801c6a871e3e99ed78872eb67e7cb2cf55161b1821562e537585bbc80184d7120fe111a8c180f298505101051d94e28ef4a79f482b6ac4538037fb5f5424688da6cfb1d833641ec86b78e51684a24c5e94f01f0bf9ff1f367c2f90b8c827413c36e0112452a442da4fb66d9610f7edf820a3ffee395daf5179f48d9d965b48eb6b3b0f08937d4bf1af0347bac60a05d8b10ec7cd4ce4bfbd7dff2f2037d36782596a9efcc35d9d5d43353cdcc774c672d5997e60c08478bf42a942a56e85f1878182d16749f303f8edcd6cb2fe33244000e2a72cf79f54f4ddf822270283ffdac986c7cb75873194a785cc0baeec6048810fdec9e837ac1e97504d77f5c061bc172a6aae22846489c88bd81144c0724a29697e2ef90b96106a2fbb78d422ba5ea31b43a294ce98b26e33bb3793ac50c6edb609bc179793d615e62891281623902136ec8d9ef441a3fd9fc2deaf192a145f3e4b0b5b6ec0d2f6c9f1d3b2391c455a5e0dd15ba229dbf3758d4412e4b007f28edcbe16c1dd8499135266564150d3d637abf7c70693646dbd151dead2e51f5e4a27af2e81c96730f6d3ba852ec15f8be1b0e19ed87e045c25101648f2de366bda3ef4ad924ba8a707e27425ffecd89d86c4653d5602bf2ee2acbd75c016dec68525b7209bc1fe6dadcae67b4cdc2c6fbb7b5050736b15bc954df367489c63658a0a7b8147181d5e99c7589f72c35c78e518543616bce7c3ee30da7eda95124feb7a4b7c0dbe98b1792e508bca7f0c94db8e23c3382f8de809a69803699292178b2f810cc575e13d9dab1bbcca7e0509df13f261bc0f4df70973cae21ba83372aeea9f1da4b6577bc76ee8489c4dd4029a6830e0e3f093e7a8b741f745b0cb4dcd44b048c27fa85d421dd6d6207d842273e06a856b28556aeb961f3901164a987c82c27747418be5bc91cfc3d6de99f9f1c37b0d1c7ec1d672f92440039f88cbc53caa8d24415d134173d9136769908e290a8819fecd0752fe3809f6d566c4b5e433d7414289ecb371078f2012e842e7841817e5df21b6e20bf57e9e70c095ea740e51a31e2eb479d164bf885f45848d1e5c49906242159b117d62b334d567f1590d2c80db970a3e01c46732a61d1e59c5fa4f6eb7d13ad751c6a0a9e0b9132493a056de8c6b17701d97e76cd1a4580870636164fe760a2817ec5f33b7b313e52a7e4cbfa67214bd0c523593d09f81767205d54b07b9ec50e2981148826908fd8410135ed2b4a809e89f157fdc7bd532d51f1c7f821679b471f8d8c06251950aaba93f11fe4c6a6de2e2dbcd6783a4b82cad830d5102781cfe446b5b56213227b274271dab733218d54519f85fc8c74eb22fd1ebdd59a7506f432332aa950d399742255ed41d4a5f1c7a855665e47598cf99c82069e474f2c419fa1788c0f5f0e07c7fafe7aa1bd9d3576ea6b61d19d75fdb03da8ebd35306aa209f59d8f2fce3dec217fd98cea845ddad15f150e3e5d9386c063354e5656ec37a07f77c6cb22f254ab4e5170cdac1a39d1f6de2a0f60417dd62d98992b0ded9f330c14b5726f41814d7a0a3f31a6861ee192f1da47971a2a245f1c20265c6a7f6ea750e0ca07c191f0dfd0870eaf27c14fd386c14985e9ae6727634defd775d754f176a4be35c453e17381bd5ed59a324be650508567ec35ada85efc04cd7c3a52e55f2c9f643ea8f34e478bfb9ed110f42085f8d3371d1b0df3f72c7bfca8e83023ba0175c5f79d855fa98dede5b01f05f8e931bd62fdc3794efb700651a9e659e20526e1a198e93a34de333a8030eb27a7716f6637d00f87ce167387e4fdc2ad2e554bbfd4f77f00dc18f35d70e5380513e61a1ce76029f0439f67df938c80d8f7112c4ee570fb6e3348afc24f83b35ea7ae1877b3f21b408033f0f77d8ab23c4110e160df005cd620b0c5de8f3937d8b770b902006c73268eb99883ba745e3cb56808bf09e1369eeff69d79c707ddf79b10ceb792c9a9780719c32a2c19ee31d672419c3609730e9e679e54b115779aec5c5d5cb138446fdef207a14641f7677db4f1c8aae3a50452a203093625cf66798903f377c512247605c08dbc418d9f12e129514d07243f3c6b2b93ae84f5801cbc2d876dba48ff5b4cb3d5ec42ea7f42c0e00e36625d6849ef007a8216835ee0a6ae030affb112306833a8e11d043416b7167b154db86c60c4be374d61d4f22f54c9d64306d86c0678a43e11718dde4055a4d714dda6cf593a4b96ea05772a9de0dbbf512a93855be22fc6276e1cd701038880649eba4cb587337559e49f8dc79eea823773730b6e3bad56c2ffeaf2e7fff4f39eb6b55a3e2c80f39dd85eac9968d38530cf10fbaef0c6cd5d29413dc3e67c2204a46df2ab9a8246c82916cacc3ceaf8856eb9ef6b4b06fc0c925abbdc375a496fee17f583723a553985ee49e879b6ff6048ed4ccb7fd2158493a5eef9a77cf6de8d0097d2c6043fb37ccc05088f2c69c8f2f74b8287dca197d0e2667dd3ec931ed36a76992bbdca3cc5d8e8de20212e955248f8b85c94faa367bbcc2807ae12ec1834eb2a8fd5241be8d221620f76a2db87f5a1a17f3f3a93c5ae66d99d44996bf21bd7ca60dfd0523b457c8568bb02923622e9efc1c1e88cf8c927530964750a9c0482b7e9284571fd8038d58c7014507cfbf97f6d4a54a6a92893644f93b1d7253f94b7098a92fe58a1b6a12deeeb90dcdc9f0e08f25cd8342c5d8698252d43968b56ceddaf961bcc187cf29066aaf271d84a886cc9757e7056a74a18e140711567f7f237f38f7f758f8ad3d2c062b37ca86eeea211539fcb5ed2339f76244d6a210bda91f892e371a7c23b4c0ccd857888f21a495f6466e5fdc73decc1fc3efa8e0a406277796e267a35bdbe3fe4ad8f4ae787d29eae7da570f056cdcb5a3b4c04d320923fab439c4f7c5381f686e9ea7d58a44bb7e3f1adc8cee467799ff21cb344b181d0c9d799c0b7aa256b7e6bbeb890b99933f433e92f60a12f480a89c62321ebad38a773c5418f7a52ea628ae0d0b4ee665e97fd559078cd5a431b1d1a570f5a18cecb276c4aa185b8c0e54971c6de6a25d08d6831f80be180bdb91432add70c41b0c360e7b2053c8e33a8d17e3e2b32c38fb1e6c6835199bb049d2e42869d8c3f0cd695cb9d26eff6ef1b5ac436af217c98c21942d17f7cfaf68226cde623b7219a915a464019b0736fff03d1932032898ca74acfe55092506da3f87c369f822adcf6aba31f22d8f0c5f0bd4a3b6f933d45fcae2027aaf6372ab042060278a07feb64ea3c94790b0da6cfb0bdc86082abd932dcf521be0345f89515f34d0050bb56a08648951230f9b5c6e4be3bcc6396bc6356e10ee3ecd5329413ae6c734864294458d15ba3072fcd6c578a554b742a3a077d73b902d1397edea17eb3e5b3ec89eb0935285ace1d66c4d031f4c0aca9ea8cf9b637399e45c17ea3458b66330e681f13edb905b65beb564c6be3e15ed5412f8c444d1d8bb65182108920fd2523290b454093c711e2630d4b13e2a87d09c0d0f76e995ca362f0932ca3d0df01c5fd3aab9b2f629c6eaee8d3740ec90951e3998421a76126d6537d68a87a27cca685d2f24b5309d9256f7406aa0699a88b076310dbce7ba73b234b8e00c0653490a0c50df796722e074003a2e5c14eac90fa6562bf389a17226ab5dde0af25492b56296b11aa2254db9426808348c01537dfa7d4a1df43645201935df9457aa6f210e17d1c9875fad610e35c2f21ebb7cbc3af771fdf6dd720f7157c71d0f8f126546e6cca632e866963d5445adfca49115fcc86732c05e8ea3dd5b4303a76980bef10c259dde68255132401e6e0e144aa7162df8927b16baa30303e6e0d8aedaa8a713e912cb1fcd2939e170922799b239042f048a5efd13fd1a851600c644b6f99f2789cc9de961a515e8ac6b7f527ed740a673470e4aa9f8d6f3dfa80627ed87606e15ee36dffdc3cbad159fde8751d55ab6b406566a55555b11a1138c3b276b1e1a00ae92bec1a663209276d46b43984d39fa07dde4e09734263aa42dde7bc47b629ed6043bc27e67480b5c1f9165057377aa654a6210d3bd42970931f3d85de30b0e71c2ad09e7f5d52dca1b1af44f8dbfc5c31f482d94296fce120d97a2a41934b9979a4c7b46d3cabebe05367034b49f8539bc4ee2b487bf4961aef991dafe63e895bcfb0bb55e70124f0be0443c1424c4df6a4841da65987050e32c859fc45ae82fd3354d2cf3d62c774e1a5c780761376e568261aa92ead632459e81f26d2ca4689f0e252384f2b024e06f71587b2ed47218da0e362c722d47857b0802d516926172e57aa9afe216a52769479e322cc22ea8d81a4fd8cd860a446b470e1fcc24bf742136f403e7dc4923d23415c86bdf790c87c160104d28dc33f837a483af4de5844c7c50b47e56e40232f782efc5e2a077a4e90fce512fb30d0967a4320fb80f3da9c77940c78d36ee771edcb24b5a491d2edc733e22c8228f64ef8f37ae4f68be4c0846cb0a97586a4b7dc32a49bee5b435745524c8e2b5b100dd8de6325b9c15b7316348c19c927db363d6553bbed6e0fca596ffefc81a3670064cca37806ec676cbc18027f0f7694735dae9c559eabd41d4e44cae33af5d3980631819acb71a1684693686f71c899d4ebfe3ce7f6d7353158d1d9895764fe0912cfd9baf7ed98a6b579e1ef6627e2609e931ddebb1571ad5129d560a2bba69dd367c8580a7e3466aa66046ad3559f4cae5880e6de0d4a6bff21c1eb56cf9ec40ac9f01babcd6a3f9d12c333d02acd0ad145792746be61aceeeb33bf96f453a0e32e2845ae90da32fc6aaeb4c8cfb0f7b66eb0ca16e4b9405dd948fe4b45cb1601711698023d411e22f18e41388a1c39d98227cc69c7365404ca95ee655d7dfa5288fc3476aa85ee42a418fc00204b8a9fce719ae830253f8f26188ebefc310ad3a1cec9ecebbdf971aa975eaf28d3dc0091bc5905c90936b0e9020ac624f3860d5c08dda6fdfb82872e35a87fdbf871dd80a580348b862a75308695e46b6af04660ecd50fd80e69a3868fd7f00e52e0390745c955f8470bd161310db1b9545375fb9c8ce220bb7b03ad937a88502c360cb6dcc5bf07f88603ccb8b0f6f4de9c1129e1886092c7fa6269e7ed72d5bd5bd6db50400c504851b69ee8b0f4050de82d9ba655013422dbc874d1c978bf316368a85953ac913e67b5b7062b458404659e16d1ff03308380299033489c07539b9770a1374e6acb543814dfa60c2994d545e35dea1de780ffb5e29bf4bac69ececdb32016a8a9d37cddb568660080e691ab0a51dea4a59604e263a1f506dbad9e1d9ea388b2efed3f54b89b5c691d807b4442e8cb1f5859709615229a4a75f7fb289f647c5067930b18480261cfa1891d9768b047379ae62a95216ba68137f7976188dbfe4cf0d0d4f8aac96ddbf34da4023d7948074a07c5be255be0fcc3c0c020c5174d31441630edc04afd996d84e2e31b600a7087bc12e5391aa5cbb802203cef2c29bf17f9de6f2ea256154545e38ad7d6ee32890914161954ca56998fa75f6ad1f817abf922aad47050246a5bd0b2e20be208297a205a147087668b194aa0abbfc491f0405ee4961f67d83700a26b85098d514432ce4f9267fd1dd278a8f6d9143ba1c5b04c8a465e916067b3f99352ed80803fd6e8bfadac7d9bf47c550c5a37410228b6c5a2ac8d3bca91e47cfbdf901d9d858a9b47a3a47a9080c39919656977eba291cbf706b70e30274bd212caf87d0d8e52a2c1b54b34bc74d9e7ee87abc37e0d50e937b59628ae5809474d55b5a17986563ad01db67aebb5ba3f8cdb0db985388dd017e3222dcebabf7e9b9cd00df69a5e016a7cea699a93cd12417d249d529d65d77a86073787e0d2cc16e101cd04856f818af11ad72a52a3c49f380eba021886029577487b7ea9e32f32ddcaf18df7362237b8c5979f200872173f92427501a7f5fe98d8374bd58b700faa04535c388c1b810d0267452d671b2f6559385379ce6e99cf397a37e7be764a913fe827a363d1fae382bf83332de6277005ae6b35326dbb24a2e6c24ee91718834a5fad8fff10709edbe076b5ae070c74e6a96f00b59e2644a53d0c631c49c0b9433ba0df482bbe9420f234b9f5f07f034f14c66b8ed14ebf4d9e877bd2ccc63a36fbe6dac0515d01cac8bdd00306494659ba42b7bb5ee966d0e467493031423946166be81c65e2beb2983fb874c2f5bca1000575ecf1d506f6d619ecb518bba7f95f14112b2535164789c77a59e6347edfc21e631863e5691517d027e1f6ea679ccf9f63c0b40ffe0c05710566e9990ad2af81274e8cce894bb46a1dff5b492fdc8edf76642ca32da00f90d421e7eccd40bad8eb4c0a21c34b9d1c9f4ec41663651a17855ec9388c8ff3ec4a3e5d644056c2dc40867b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
